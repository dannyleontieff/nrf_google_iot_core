
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0000c000 <_vector_table>:
    c000:	20034898 	.word	0x20034898
    c004:	0001af0d 	.word	0x0001af0d
    c008:	00035459 	.word	0x00035459
    c00c:	0001af3d 	.word	0x0001af3d
    c010:	0001af3d 	.word	0x0001af3d
    c014:	0001af3d 	.word	0x0001af3d
    c018:	0001af3d 	.word	0x0001af3d
    c01c:	0001af3d 	.word	0x0001af3d
	...
    c02c:	0001abd1 	.word	0x0001abd1
    c030:	0001af3d 	.word	0x0001af3d
    c034:	00000000 	.word	0x00000000
    c038:	0001ab21 	.word	0x0001ab21
    c03c:	0001a2bd 	.word	0x0001a2bd

0000c040 <_irq_vector_table>:
    c040:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c050:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c060:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c070:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c080:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c090:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c0a0:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c0b0:	0001fec5 00038113 0001aecd 0001aecd     ................
    c0c0:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c0d0:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c0e0:	0001aecd 0001aecd 00038131 0001aecd     ........1.......
    c0f0:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c100:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c110:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c120:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c130:	0001aecd 0001aecd 0001aecd 0001aecd     ................
    c140:	0001aecd                                ....

0000c144 <_vector_end>:
	...

0000c200 <m_firmware_info>:
    c200:	281ee6de 8fcebb4c 00005b02 0000003c     ...(L....[..<...
    c210:	000352a0 00000001 0000c000 0000c000     .R..............
    c220:	9102ffff 00000000 00000000 00000000     ................
	...

Disassembly of section text:

0000c240 <bsec_codegen_sensor_control>:
    c240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c244:	ed2d 8b02 	vpush	{d8}
    c248:	b087      	sub	sp, #28
    c24a:	2100      	movs	r1, #0
    c24c:	9c13      	ldr	r4, [sp, #76]	; 0x4c
    c24e:	9e12      	ldr	r6, [sp, #72]	; 0x48
    c250:	6121      	str	r1, [r4, #16]
    c252:	e9c4 1102 	strd	r1, r1, [r4, #8]
    c256:	7521      	strb	r1, [r4, #20]
    c258:	461f      	mov	r7, r3
    c25a:	7031      	strb	r1, [r6, #0]
    c25c:	f500 793c 	add.w	r9, r0, #752	; 0x2f0
    c260:	4616      	mov	r6, r2
    c262:	4605      	mov	r5, r0
    c264:	e9cd 6702 	strd	r6, r7, [sp, #8]
    c268:	f8b0 840e 	ldrh.w	r8, [r0, #1038]	; 0x40e
    c26c:	f001 ffe0 	bl	e230 <bsec_Bsec_applyUpdateSubscription>
    c270:	e9d9 2300 	ldrd	r2, r3, [r9]
    c274:	ea52 0103 	orrs.w	r1, r2, r3
    c278:	d02d      	beq.n	c2d6 <bsec_codegen_sensor_control+0x96>
    c27a:	1ab6      	subs	r6, r6, r2
    c27c:	ed9f 1bc4 	vldr	d1, [pc, #784]	; c590 <bsec_codegen_sensor_control+0x350>
    c280:	ed9f 0bc5 	vldr	d0, [pc, #788]	; c598 <bsec_codegen_sensor_control+0x358>
    c284:	eb67 0703 	sbc.w	r7, r7, r3
    c288:	f8b5 a40c 	ldrh.w	sl, [r5, #1036]	; 0x40c
    c28c:	f006 ff60 	bl	13150 <pow>
    c290:	f000 fd0e 	bl	ccb0 <bsec_rt_roundd>
    c294:	ec51 0b10 	vmov	r0, r1, d0
    c298:	f005 feb2 	bl	12000 <__aeabi_d2lz>
    c29c:	fba0 230a 	umull	r2, r3, r0, sl
    c2a0:	fb01 330a 	mla	r3, r1, sl, r3
    c2a4:	ea4f 1a12 	mov.w	sl, r2, lsr #4
    c2a8:	1b90      	subs	r0, r2, r6
    c2aa:	ea4a 7a03 	orr.w	sl, sl, r3, lsl #28
    c2ae:	eb63 0107 	sbc.w	r1, r3, r7
    c2b2:	ea4f 1b23 	mov.w	fp, r3, asr #4
    c2b6:	4582      	cmp	sl, r0
    c2b8:	eb7b 0101 	sbcs.w	r1, fp, r1
    c2bc:	f2c0 8144 	blt.w	c548 <bsec_codegen_sensor_control+0x308>
    c2c0:	1ab0      	subs	r0, r6, r2
    c2c2:	eb67 0103 	sbc.w	r1, r7, r3
    c2c6:	460b      	mov	r3, r1
    c2c8:	4582      	cmp	sl, r0
    c2ca:	eb7b 0303 	sbcs.w	r3, fp, r3
    c2ce:	da02      	bge.n	c2d6 <bsec_codegen_sensor_control+0x96>
    c2d0:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c2d2:	2364      	movs	r3, #100	; 0x64
    c2d4:	7013      	strb	r3, [r2, #0]
    c2d6:	2300      	movs	r3, #0
    c2d8:	f10d 0b16 	add.w	fp, sp, #22
    c2dc:	e9c4 3300 	strd	r3, r3, [r4]
    c2e0:	e9c4 3302 	strd	r3, r3, [r4, #8]
    c2e4:	6123      	str	r3, [r4, #16]
    c2e6:	7523      	strb	r3, [r4, #20]
    c2e8:	4622      	mov	r2, r4
    c2ea:	f10d 0315 	add.w	r3, sp, #21
    c2ee:	f8cd b000 	str.w	fp, [sp]
    c2f2:	2101      	movs	r1, #1
    c2f4:	4628      	mov	r0, r5
    c2f6:	f001 ffa1 	bl	e23c <bsec_Bsec_checkIfSensorRequired>
    c2fa:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c2fe:	f8bd a016 	ldrh.w	sl, [sp, #22]
    c302:	b12b      	cbz	r3, c310 <bsec_codegen_sensor_control+0xd0>
    c304:	f895 3459 	ldrb.w	r3, [r5, #1113]	; 0x459
    c308:	7463      	strb	r3, [r4, #17]
    c30a:	f895 3457 	ldrb.w	r3, [r5, #1111]	; 0x457
    c30e:	74a3      	strb	r3, [r4, #18]
    c310:	f10d 0315 	add.w	r3, sp, #21
    c314:	4622      	mov	r2, r4
    c316:	f8cd b000 	str.w	fp, [sp]
    c31a:	2102      	movs	r1, #2
    c31c:	4628      	mov	r0, r5
    c31e:	f001 ff8d 	bl	e23c <bsec_Bsec_checkIfSensorRequired>
    c322:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    c326:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c32a:	4592      	cmp	sl, r2
    c32c:	bf28      	it	cs
    c32e:	4692      	movcs	sl, r2
    c330:	b12b      	cbz	r3, c33e <bsec_codegen_sensor_control+0xfe>
    c332:	f895 3458 	ldrb.w	r3, [r5, #1112]	; 0x458
    c336:	74e3      	strb	r3, [r4, #19]
    c338:	f895 3457 	ldrb.w	r3, [r5, #1111]	; 0x457
    c33c:	74a3      	strb	r3, [r4, #18]
    c33e:	f10d 0315 	add.w	r3, sp, #21
    c342:	4622      	mov	r2, r4
    c344:	f8cd b000 	str.w	fp, [sp]
    c348:	2103      	movs	r1, #3
    c34a:	4628      	mov	r0, r5
    c34c:	f001 ff76 	bl	e23c <bsec_Bsec_checkIfSensorRequired>
    c350:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    c354:	f89d 3015 	ldrb.w	r3, [sp, #21]
    c358:	4592      	cmp	sl, r2
    c35a:	bf28      	it	cs
    c35c:	4692      	movcs	sl, r2
    c35e:	b113      	cbz	r3, c366 <bsec_codegen_sensor_control+0x126>
    c360:	f895 3457 	ldrb.w	r3, [r5, #1111]	; 0x457
    c364:	74a3      	strb	r3, [r4, #18]
    c366:	f10d 0315 	add.w	r3, sp, #21
    c36a:	4622      	mov	r2, r4
    c36c:	f8cd b000 	str.w	fp, [sp]
    c370:	2104      	movs	r1, #4
    c372:	4628      	mov	r0, r5
    c374:	f001 ff62 	bl	e23c <bsec_Bsec_checkIfSensorRequired>
    c378:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    c37c:	f89d 2015 	ldrb.w	r2, [sp, #21]
    c380:	459a      	cmp	sl, r3
    c382:	bf28      	it	cs
    c384:	469a      	movcs	sl, r3
    c386:	45c2      	cmp	sl, r8
    c388:	bf28      	it	cs
    c38a:	46c2      	movcs	sl, r8
    c38c:	2a00      	cmp	r2, #0
    c38e:	d16d      	bne.n	c46c <bsec_codegen_sensor_control+0x22c>
    c390:	f505 783e 	add.w	r8, r5, #760	; 0x2f8
    c394:	f8b5 3454 	ldrh.w	r3, [r5, #1108]	; 0x454
    c398:	fbb3 f2fa 	udiv	r2, r3, sl
    c39c:	fb0a 3212 	mls	r2, sl, r2, r3
    c3a0:	ebaa 0a02 	sub.w	sl, sl, r2
    c3a4:	fa1f fa8a 	uxth.w	sl, sl
    c3a8:	f8b5 1410 	ldrh.w	r1, [r5, #1040]	; 0x410
    c3ac:	f8ad 1016 	strh.w	r1, [sp, #22]
    c3b0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
    c3b4:	4453      	add	r3, sl
    c3b6:	b29b      	uxth	r3, r3
    c3b8:	fbb3 f2f1 	udiv	r2, r3, r1
    c3bc:	fb01 3312 	mls	r3, r1, r2, r3
    c3c0:	e9c9 6700 	strd	r6, r7, [r9]
    c3c4:	ed9f 1b72 	vldr	d1, [pc, #456]	; c590 <bsec_codegen_sensor_control+0x350>
    c3c8:	f8a5 3454 	strh.w	r3, [r5, #1108]	; 0x454
    c3cc:	f8a5 a40c 	strh.w	sl, [r5, #1036]	; 0x40c
    c3d0:	ed9f 0b71 	vldr	d0, [pc, #452]	; c598 <bsec_codegen_sensor_control+0x358>
    c3d4:	f006 febc 	bl	13150 <pow>
    c3d8:	f000 fc6a 	bl	ccb0 <bsec_rt_roundd>
    c3dc:	ec51 0b10 	vmov	r0, r1, d0
    c3e0:	f005 fe0e 	bl	12000 <__aeabi_d2lz>
    c3e4:	e9d8 8900 	ldrd	r8, r9, [r8]
    c3e8:	fba0 230a 	umull	r2, r3, r0, sl
    c3ec:	fb01 330a 	mla	r3, r1, sl, r3
    c3f0:	18b6      	adds	r6, r6, r2
    c3f2:	415f      	adcs	r7, r3
    c3f4:	f04f 0a00 	mov.w	sl, #0
    c3f8:	ebb6 0008 	subs.w	r0, r6, r8
    c3fc:	e9c4 6700 	strd	r6, r7, [r4]
    c400:	eb67 0109 	sbc.w	r1, r7, r9
    c404:	f885 a45b 	strb.w	sl, [r5, #1115]	; 0x45b
    c408:	f005 fdbc 	bl	11f84 <__aeabi_l2f>
    c40c:	eddf 8a64 	vldr	s17, [pc, #400]	; c5a0 <bsec_codegen_sensor_control+0x360>
    c410:	ed9f 8a64 	vldr	s16, [pc, #400]	; c5a4 <bsec_codegen_sensor_control+0x364>
    c414:	ee07 0a90 	vmov	s15, r0
    c418:	eec7 7aa8 	vdiv.f32	s15, s15, s17
    c41c:	eef4 7ac8 	vcmpe.f32	s15, s16
    c420:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c424:	d47b      	bmi.n	c51e <bsec_codegen_sensor_control+0x2de>
    c426:	ed9f 7a60 	vldr	s14, [pc, #384]	; c5a8 <bsec_codegen_sensor_control+0x368>
    c42a:	eef4 7ac7 	vcmpe.f32	s15, s14
    c42e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c432:	dc74      	bgt.n	c51e <bsec_codegen_sensor_control+0x2de>
    c434:	f505 7340 	add.w	r3, r5, #768	; 0x300
    c438:	e9d3 3400 	ldrd	r3, r4, [r3]
    c43c:	1af0      	subs	r0, r6, r3
    c43e:	eb67 0104 	sbc.w	r1, r7, r4
    c442:	f005 fd9f 	bl	11f84 <__aeabi_l2f>
    c446:	ee07 0a90 	vmov	s15, r0
    c44a:	eec7 7aa8 	vdiv.f32	s15, s15, s17
    c44e:	eef4 7ac8 	vcmpe.f32	s15, s16
    c452:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c456:	bf46      	itte	mi
    c458:	2366      	movmi	r3, #102	; 0x66
    c45a:	f885 345c 	strbmi.w	r3, [r5, #1116]	; 0x45c
    c45e:	f885 a45c 	strbpl.w	sl, [r5, #1116]	; 0x45c
    c462:	b007      	add	sp, #28
    c464:	ecbd 8b02 	vpop	{d8}
    c468:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c46c:	2301      	movs	r3, #1
    c46e:	7423      	strb	r3, [r4, #16]
    c470:	f895 3456 	ldrb.w	r3, [r5, #1110]	; 0x456
    c474:	4a4d      	ldr	r2, [pc, #308]	; (c5ac <bsec_codegen_sensor_control+0x36c>)
    c476:	eb05 0343 	add.w	r3, r5, r3, lsl #1
    c47a:	7d52      	ldrb	r2, [r2, #21]
    c47c:	f8b3 1420 	ldrh.w	r1, [r3, #1056]	; 0x420
    c480:	81a1      	strh	r1, [r4, #12]
    c482:	f895 1458 	ldrb.w	r1, [r5, #1112]	; 0x458
    c486:	74e1      	strb	r1, [r4, #19]
    c488:	f895 1457 	ldrb.w	r1, [r5, #1111]	; 0x457
    c48c:	74a1      	strb	r1, [r4, #18]
    c48e:	eb05 0282 	add.w	r2, r5, r2, lsl #2
    c492:	edd2 7a89 	vldr	s15, [r2, #548]	; 0x224
    c496:	eef5 7a40 	vcmp.f32	s15, #0.0
    c49a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c49e:	d10c      	bne.n	c4ba <bsec_codegen_sensor_control+0x27a>
    c4a0:	f895 245b 	ldrb.w	r2, [r5, #1115]	; 0x45b
    c4a4:	b94a      	cbnz	r2, c4ba <bsec_codegen_sensor_control+0x27a>
    c4a6:	f8b3 3418 	ldrh.w	r3, [r3, #1048]	; 0x418
    c4aa:	81e3      	strh	r3, [r4, #14]
    c4ac:	f505 783e 	add.w	r8, r5, #760	; 0x2f8
    c4b0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c4b4:	e9c8 2300 	strd	r2, r3, [r8]
    c4b8:	e76c      	b.n	c394 <bsec_codegen_sensor_control+0x154>
    c4ba:	f505 783e 	add.w	r8, r5, #760	; 0x2f8
    c4be:	f505 7b40 	add.w	fp, r5, #768	; 0x300
    c4c2:	e9d8 6700 	ldrd	r6, r7, [r8]
    c4c6:	e9db 2300 	ldrd	r2, r3, [fp]
    c4ca:	4296      	cmp	r6, r2
    c4cc:	eb77 0103 	sbcs.w	r1, r7, r3
    c4d0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    c4d4:	bfbc      	itt	lt
    c4d6:	4616      	movlt	r6, r2
    c4d8:	461f      	movlt	r7, r3
    c4da:	1b80      	subs	r0, r0, r6
    c4dc:	eb61 0107 	sbc.w	r1, r1, r7
    c4e0:	f005 fd50 	bl	11f84 <__aeabi_l2f>
    c4e4:	ed9f 0a2e 	vldr	s0, [pc, #184]	; c5a0 <bsec_codegen_sensor_control+0x360>
    c4e8:	ee07 0a90 	vmov	s15, r0
    c4ec:	ee87 0a80 	vdiv.f32	s0, s15, s0
    c4f0:	f002 f884 	bl	e5fc <bsec_Bsec_getModHeatingDuration>
    c4f4:	f895 345b 	ldrb.w	r3, [r5, #1115]	; 0x45b
    c4f8:	81e0      	strh	r0, [r4, #14]
    c4fa:	b9c3      	cbnz	r3, c52e <bsec_codegen_sensor_control+0x2ee>
    c4fc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c500:	2116      	movs	r1, #22
    c502:	4628      	mov	r0, r5
    c504:	ed9f 0a2a 	vldr	s0, [pc, #168]	; c5b0 <bsec_codegen_sensor_control+0x370>
    c508:	f003 f98a 	bl	f820 <bsec_ChannelHub_setInput>
    c50c:	f895 345b 	ldrb.w	r3, [r5, #1115]	; 0x45b
    c510:	2b00      	cmp	r3, #0
    c512:	d0cd      	beq.n	c4b0 <bsec_codegen_sensor_control+0x270>
    c514:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c518:	e9cb 2300 	strd	r2, r3, [fp]
    c51c:	e73a      	b.n	c394 <bsec_codegen_sensor_control+0x154>
    c51e:	2365      	movs	r3, #101	; 0x65
    c520:	f885 345c 	strb.w	r3, [r5, #1116]	; 0x45c
    c524:	b007      	add	sp, #28
    c526:	ecbd 8b02 	vpop	{d8}
    c52a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c52e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c532:	2116      	movs	r1, #22
    c534:	4628      	mov	r0, r5
    c536:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    c53a:	f003 f971 	bl	f820 <bsec_ChannelHub_setInput>
    c53e:	68a3      	ldr	r3, [r4, #8]
    c540:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
    c544:	60a3      	str	r3, [r4, #8]
    c546:	e7e1      	b.n	c50c <bsec_codegen_sensor_control+0x2cc>
    c548:	ed9f 1b11 	vldr	d1, [pc, #68]	; c590 <bsec_codegen_sensor_control+0x350>
    c54c:	ed9f 0b12 	vldr	d0, [pc, #72]	; c598 <bsec_codegen_sensor_control+0x358>
    c550:	e9d9 ab00 	ldrd	sl, fp, [r9]
    c554:	f8b5 840c 	ldrh.w	r8, [r5, #1036]	; 0x40c
    c558:	f006 fdfa 	bl	13150 <pow>
    c55c:	f000 fba8 	bl	ccb0 <bsec_rt_roundd>
    c560:	ec51 0b10 	vmov	r0, r1, d0
    c564:	f005 fd4c 	bl	12000 <__aeabi_d2lz>
    c568:	fba0 2308 	umull	r2, r3, r0, r8
    c56c:	eb1a 0602 	adds.w	r6, sl, r2
    c570:	fb01 3308 	mla	r3, r1, r8, r3
    c574:	9a12      	ldr	r2, [sp, #72]	; 0x48
    c576:	eb4b 0703 	adc.w	r7, fp, r3
    c57a:	2364      	movs	r3, #100	; 0x64
    c57c:	e9c4 6700 	strd	r6, r7, [r4]
    c580:	7013      	strb	r3, [r2, #0]
    c582:	b007      	add	sp, #28
    c584:	ecbd 8b02 	vpop	{d8}
    c588:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c58c:	f3af 8000 	nop.w
    c590:	00000000 	.word	0x00000000
    c594:	401c0000 	.word	0x401c0000
    c598:	00000000 	.word	0x00000000
    c59c:	40240000 	.word	0x40240000
    c5a0:	4e6e6b28 	.word	0x4e6e6b28
    c5a4:	42700000 	.word	0x42700000
    c5a8:	43700000 	.word	0x43700000
    c5ac:	0003ad80 	.word	0x0003ad80
	...

0000c5b8 <bsec_codegen_update_subscription>:
    c5b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c5bc:	ed2d 8b04 	vpush	{d8-d9}
    c5c0:	b08d      	sub	sp, #52	; 0x34
    c5c2:	e9dd 9a1a 	ldrd	r9, sl, [sp, #104]	; 0x68
    c5c6:	2500      	movs	r5, #0
    c5c8:	4616      	mov	r6, r2
    c5ca:	4604      	mov	r4, r0
    c5cc:	460f      	mov	r7, r1
    c5ce:	f889 5000 	strb.w	r5, [r9]
    c5d2:	f200 412a 	addw	r1, r0, #1066	; 0x42a
    c5d6:	221c      	movs	r2, #28
    c5d8:	a805      	add	r0, sp, #20
    c5da:	469b      	mov	fp, r3
    c5dc:	f02c fcfc 	bl	38fd8 <memcpy>
    c5e0:	2e00      	cmp	r6, #0
    c5e2:	f000 8097 	beq.w	c714 <bsec_codegen_update_subscription+0x15c>
    c5e6:	793b      	ldrb	r3, [r7, #4]
    c5e8:	3b01      	subs	r3, #1
    c5ea:	b2da      	uxtb	r2, r3
    c5ec:	2a01      	cmp	r2, #1
    c5ee:	f240 8106 	bls.w	c7fe <bsec_codegen_update_subscription+0x246>
    c5f2:	9501      	str	r5, [sp, #4]
    c5f4:	ed9f 8abe 	vldr	s16, [pc, #760]	; c8f0 <bsec_codegen_update_subscription+0x338>
    c5f8:	ed9f 9abe 	vldr	s18, [pc, #760]	; c8f4 <bsec_codegen_update_subscription+0x33c>
    c5fc:	eddf 8abe 	vldr	s17, [pc, #760]	; c8f8 <bsec_codegen_update_subscription+0x340>
    c600:	f8cd a06c 	str.w	sl, [sp, #108]	; 0x6c
    c604:	2501      	movs	r5, #1
    c606:	e016      	b.n	c636 <bsec_codegen_update_subscription+0x7e>
    c608:	4abc      	ldr	r2, [pc, #752]	; (c8fc <bsec_codegen_update_subscription+0x344>)
    c60a:	411a      	asrs	r2, r3
    c60c:	07d1      	lsls	r1, r2, #31
    c60e:	d515      	bpl.n	c63c <bsec_codegen_update_subscription+0x84>
    c610:	2201      	movs	r2, #1
    c612:	fa02 f303 	lsl.w	r3, r2, r3
    c616:	9a01      	ldr	r2, [sp, #4]
    c618:	4213      	tst	r3, r2
    c61a:	f000 80b4 	beq.w	c786 <bsec_codegen_update_subscription+0x1ce>
    c61e:	23f3      	movs	r3, #243	; 0xf3
    c620:	f889 3000 	strb.w	r3, [r9]
    c624:	3501      	adds	r5, #1
    c626:	b2ed      	uxtb	r5, r5
    c628:	42ae      	cmp	r6, r5
    c62a:	d30e      	bcc.n	c64a <bsec_codegen_update_subscription+0x92>
    c62c:	eb07 03c5 	add.w	r3, r7, r5, lsl #3
    c630:	f813 3c04 	ldrb.w	r3, [r3, #-4]
    c634:	3b01      	subs	r3, #1
    c636:	b2db      	uxtb	r3, r3
    c638:	2b14      	cmp	r3, #20
    c63a:	d9e5      	bls.n	c608 <bsec_codegen_update_subscription+0x50>
    c63c:	3501      	adds	r5, #1
    c63e:	b2ed      	uxtb	r5, r5
    c640:	230a      	movs	r3, #10
    c642:	42ae      	cmp	r6, r5
    c644:	f889 3000 	strb.w	r3, [r9]
    c648:	d2f0      	bcs.n	c62c <bsec_codegen_update_subscription+0x74>
    c64a:	f999 3000 	ldrsb.w	r3, [r9]
    c64e:	f8dd a06c 	ldr.w	sl, [sp, #108]	; 0x6c
    c652:	2b00      	cmp	r3, #0
    c654:	da61      	bge.n	c71a <bsec_codegen_update_subscription+0x162>
    c656:	f89b 3000 	ldrb.w	r3, [fp]
    c65a:	2b07      	cmp	r3, #7
    c65c:	f240 8087 	bls.w	c76e <bsec_codegen_update_subscription+0x1b6>
    c660:	2300      	movs	r3, #0
    c662:	f8df 92a4 	ldr.w	r9, [pc, #676]	; c908 <bsec_codegen_update_subscription+0x350>
    c666:	ed9f 6aa2 	vldr	s12, [pc, #648]	; c8f0 <bsec_codegen_update_subscription+0x338>
    c66a:	49a4      	ldr	r1, [pc, #656]	; (c8fc <bsec_codegen_update_subscription+0x344>)
    c66c:	4ea4      	ldr	r6, [pc, #656]	; (c900 <bsec_codegen_update_subscription+0x348>)
    c66e:	f8df e294 	ldr.w	lr, [pc, #660]	; c904 <bsec_codegen_update_subscription+0x34c>
    c672:	eddf 5aa1 	vldr	s11, [pc, #644]	; c8f8 <bsec_codegen_update_subscription+0x340>
    c676:	469c      	mov	ip, r3
    c678:	e002      	b.n	c680 <bsec_codegen_update_subscription+0xc8>
    c67a:	2f18      	cmp	r7, #24
    c67c:	463b      	mov	r3, r7
    c67e:	d07b      	beq.n	c778 <bsec_codegen_update_subscription+0x1c0>
    c680:	fa49 f203 	asr.w	r2, r9, r3
    c684:	1c5f      	adds	r7, r3, #1
    c686:	07d0      	lsls	r0, r2, #31
    c688:	fa5f f887 	uxtb.w	r8, r7
    c68c:	d5f5      	bpl.n	c67a <bsec_codegen_update_subscription+0xc2>
    c68e:	f10c 0c01 	add.w	ip, ip, #1
    c692:	fa5f fc8c 	uxtb.w	ip, ip
    c696:	f10c 5000 	add.w	r0, ip, #536870912	; 0x20000000
    c69a:	3801      	subs	r0, #1
    c69c:	eb0a 00c0 	add.w	r0, sl, r0, lsl #3
    c6a0:	2501      	movs	r5, #1
    c6a2:	f880 8004 	strb.w	r8, [r0, #4]
    c6a6:	409d      	lsls	r5, r3
    c6a8:	ed80 6a00 	vstr	s12, [r0]
    c6ac:	2300      	movs	r3, #0
    c6ae:	f64f 78ff 	movw	r8, #65535	; 0xffff
    c6b2:	e00c      	b.n	c6ce <bsec_codegen_update_subscription+0x116>
    c6b4:	4542      	cmp	r2, r8
    c6b6:	d007      	beq.n	c6c8 <bsec_codegen_update_subscription+0x110>
    c6b8:	ee07 2a90 	vmov	s15, r2
    c6bc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    c6c0:	ee85 7aa7 	vdiv.f32	s14, s11, s15
    c6c4:	ed80 7a00 	vstr	s14, [r0]
    c6c8:	3301      	adds	r3, #1
    c6ca:	2b15      	cmp	r3, #21
    c6cc:	d0d5      	beq.n	c67a <bsec_codegen_update_subscription+0xc2>
    c6ce:	fa41 f203 	asr.w	r2, r1, r3
    c6d2:	07d2      	lsls	r2, r2, #31
    c6d4:	d5f8      	bpl.n	c6c8 <bsec_codegen_update_subscription+0x110>
    c6d6:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
    c6da:	4215      	tst	r5, r2
    c6dc:	d0f4      	beq.n	c6c8 <bsec_codegen_update_subscription+0x110>
    c6de:	f813 200e 	ldrb.w	r2, [r3, lr]
    c6e2:	ed90 7a00 	vldr	s14, [r0]
    c6e6:	eb04 0242 	add.w	r2, r4, r2, lsl #1
    c6ea:	eeb4 7a46 	vcmp.f32	s14, s12
    c6ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c6f2:	f8b2 2428 	ldrh.w	r2, [r2, #1064]	; 0x428
    c6f6:	d0dd      	beq.n	c6b4 <bsec_codegen_update_subscription+0xfc>
    c6f8:	ee07 2a90 	vmov	s15, r2
    c6fc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    c700:	eec5 6aa7 	vdiv.f32	s13, s11, s15
    c704:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c708:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c70c:	bf48      	it	mi
    c70e:	edc0 6a00 	vstrmi	s13, [r0]
    c712:	e7d9      	b.n	c6c8 <bsec_codegen_update_subscription+0x110>
    c714:	230c      	movs	r3, #12
    c716:	f889 3000 	strb.w	r3, [r9]
    c71a:	a905      	add	r1, sp, #20
    c71c:	4620      	mov	r0, r4
    c71e:	f001 fdb9 	bl	e294 <bsec_Bsec_checkSamplIntvlCompatibilty>
    c722:	2800      	cmp	r0, #0
    c724:	d168      	bne.n	c7f8 <bsec_codegen_update_subscription+0x240>
    c726:	f999 0000 	ldrsb.w	r0, [r9]
    c72a:	2800      	cmp	r0, #0
    c72c:	db93      	blt.n	c656 <bsec_codegen_update_subscription+0x9e>
    c72e:	4e73      	ldr	r6, [pc, #460]	; (c8fc <bsec_codegen_update_subscription+0x344>)
    c730:	4f74      	ldr	r7, [pc, #464]	; (c904 <bsec_codegen_update_subscription+0x34c>)
    c732:	2300      	movs	r3, #0
    c734:	fa46 f203 	asr.w	r2, r6, r3
    c738:	1c5d      	adds	r5, r3, #1
    c73a:	07d2      	lsls	r2, r2, #31
    c73c:	b2e9      	uxtb	r1, r5
    c73e:	d50e      	bpl.n	c75e <bsec_codegen_update_subscription+0x1a6>
    c740:	5ddb      	ldrb	r3, [r3, r7]
    c742:	aa0c      	add	r2, sp, #48	; 0x30
    c744:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    c748:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    c74c:	f832 2c1e 	ldrh.w	r2, [r2, #-30]
    c750:	f8b3 3428 	ldrh.w	r3, [r3, #1064]	; 0x428
    c754:	4293      	cmp	r3, r2
    c756:	4620      	mov	r0, r4
    c758:	d001      	beq.n	c75e <bsec_codegen_update_subscription+0x1a6>
    c75a:	f001 ffd7 	bl	e70c <bsec_Bsec_requestOutput>
    c75e:	2d15      	cmp	r5, #21
    c760:	462b      	mov	r3, r5
    c762:	d1e7      	bne.n	c734 <bsec_codegen_update_subscription+0x17c>
    c764:	f89b 3000 	ldrb.w	r3, [fp]
    c768:	2b07      	cmp	r3, #7
    c76a:	f63f af79 	bhi.w	c660 <bsec_codegen_update_subscription+0xa8>
    c76e:	23f1      	movs	r3, #241	; 0xf1
    c770:	f889 3000 	strb.w	r3, [r9]
    c774:	f04f 0c00 	mov.w	ip, #0
    c778:	f88b c000 	strb.w	ip, [fp]
    c77c:	b00d      	add	sp, #52	; 0x34
    c77e:	ecbd 8b04 	vpop	{d8-d9}
    c782:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c786:	f105 5200 	add.w	r2, r5, #536870912	; 0x20000000
    c78a:	3a01      	subs	r2, #1
    c78c:	eb07 08c2 	add.w	r8, r7, r2, lsl #3
    c790:	ed98 0a00 	vldr	s0, [r8]
    c794:	9a01      	ldr	r2, [sp, #4]
    c796:	eeb5 0a40 	vcmp.f32	s0, #0.0
    c79a:	431a      	orrs	r2, r3
    c79c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c7a0:	9201      	str	r2, [sp, #4]
    c7a2:	d143      	bne.n	c82c <bsec_codegen_update_subscription+0x274>
    c7a4:	23f6      	movs	r3, #246	; 0xf6
    c7a6:	f889 3000 	strb.w	r3, [r9]
    c7aa:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    c7ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c7b2:	dd04      	ble.n	c7be <bsec_codegen_update_subscription+0x206>
    c7b4:	eeb4 0ac8 	vcmpe.f32	s0, s16
    c7b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c7bc:	d454      	bmi.n	c868 <bsec_codegen_update_subscription+0x2b0>
    c7be:	eeb5 0a40 	vcmp.f32	s0, #0.0
    c7c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c7c6:	bf14      	ite	ne
    c7c8:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    c7cc:	2300      	moveq	r3, #0
    c7ce:	b29b      	uxth	r3, r3
    c7d0:	9302      	str	r3, [sp, #8]
    c7d2:	f999 3000 	ldrsb.w	r3, [r9]
    c7d6:	2b00      	cmp	r3, #0
    c7d8:	f47f af24 	bne.w	c624 <bsec_codegen_update_subscription+0x6c>
    c7dc:	4a49      	ldr	r2, [pc, #292]	; (c904 <bsec_codegen_update_subscription+0x34c>)
    c7de:	f898 3004 	ldrb.w	r3, [r8, #4]
    c7e2:	4413      	add	r3, r2
    c7e4:	aa0c      	add	r2, sp, #48	; 0x30
    c7e6:	f813 3c01 	ldrb.w	r3, [r3, #-1]
    c7ea:	eb02 0343 	add.w	r3, r2, r3, lsl #1
    c7ee:	f8bd 2008 	ldrh.w	r2, [sp, #8]
    c7f2:	f823 2c1e 	strh.w	r2, [r3, #-30]
    c7f6:	e715      	b.n	c624 <bsec_codegen_update_subscription+0x6c>
    c7f8:	f889 0000 	strb.w	r0, [r9]
    c7fc:	e795      	b.n	c72a <bsec_codegen_update_subscription+0x172>
    c7fe:	edd7 7a00 	vldr	s15, [r7]
    c802:	eef5 7a40 	vcmp.f32	s15, #0.0
    c806:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c80a:	f47f aef2 	bne.w	c5f2 <bsec_codegen_update_subscription+0x3a>
    c80e:	f8bd 2014 	ldrh.w	r2, [sp, #20]
    c812:	f247 5330 	movw	r3, #30000	; 0x7530
    c816:	429a      	cmp	r2, r3
    c818:	d01d      	beq.n	c856 <bsec_codegen_update_subscription+0x29e>
    c81a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    c81e:	429a      	cmp	r2, r3
    c820:	d019      	beq.n	c856 <bsec_codegen_update_subscription+0x29e>
    c822:	230b      	movs	r3, #11
    c824:	46ac      	mov	ip, r5
    c826:	f889 3000 	strb.w	r3, [r9]
    c82a:	e7a5      	b.n	c778 <bsec_codegen_update_subscription+0x1c0>
    c82c:	eeb4 0a48 	vcmp.f32	s0, s16
    c830:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c834:	d0c3      	beq.n	c7be <bsec_codegen_update_subscription+0x206>
    c836:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
    c83a:	eeb4 0ae7 	vcmpe.f32	s0, s15
    c83e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c842:	dc04      	bgt.n	c84e <bsec_codegen_update_subscription+0x296>
    c844:	eeb4 0ac9 	vcmpe.f32	s0, s18
    c848:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    c84c:	d5ad      	bpl.n	c7aa <bsec_codegen_update_subscription+0x1f2>
    c84e:	23f2      	movs	r3, #242	; 0xf2
    c850:	f889 3000 	strb.w	r3, [r9]
    c854:	e7a9      	b.n	c7aa <bsec_codegen_update_subscription+0x1f2>
    c856:	f994 345c 	ldrsb.w	r3, [r4, #1116]	; 0x45c
    c85a:	2b00      	cmp	r3, #0
    c85c:	d188      	bne.n	c770 <bsec_codegen_update_subscription+0x1b8>
    c85e:	2201      	movs	r2, #1
    c860:	469c      	mov	ip, r3
    c862:	f884 245b 	strb.w	r2, [r4, #1115]	; 0x45b
    c866:	e787      	b.n	c778 <bsec_codegen_update_subscription+0x1c0>
    c868:	ee88 0a80 	vdiv.f32	s0, s17, s0
    c86c:	f022 fe48 	bl	2f500 <roundf>
    c870:	f04f 0a00 	mov.w	sl, #0
    c874:	eebc 0ac0 	vcvt.u32.f32	s0, s0
    c878:	ee10 3a10 	vmov	r3, s0
    c87c:	b29b      	uxth	r3, r3
    c87e:	e9cd 3502 	strd	r3, r5, [sp, #8]
    c882:	4a20      	ldr	r2, [pc, #128]	; (c904 <bsec_codegen_update_subscription+0x34c>)
    c884:	f898 3004 	ldrb.w	r3, [r8, #4]
    c888:	4413      	add	r3, r2
    c88a:	f813 3c01 	ldrb.w	r3, [r3, #-1]
    c88e:	4453      	add	r3, sl
    c890:	f203 13a3 	addw	r3, r3, #419	; 0x1a3
    c894:	f10a 0a0e 	add.w	sl, sl, #14
    c898:	f834 5013 	ldrh.w	r5, [r4, r3, lsl #1]
    c89c:	4628      	mov	r0, r5
    c89e:	f000 fb8b 	bl	cfb8 <__aeabi_ui2d>
    c8a2:	a311      	add	r3, pc, #68	; (adr r3, c8e8 <bsec_codegen_update_subscription+0x330>)
    c8a4:	e9d3 2300 	ldrd	r2, r3, [r3]
    c8a8:	f000 fc00 	bl	d0ac <__aeabi_dmul>
    c8ac:	ec41 0b10 	vmov	d0, r0, r1
    c8b0:	f000 f9fe 	bl	ccb0 <bsec_rt_roundd>
    c8b4:	ec51 0b10 	vmov	r0, r1, d0
    c8b8:	f005 fa74 	bl	11da4 <__aeabi_d2uiz>
    c8bc:	b280      	uxth	r0, r0
    c8be:	1a2b      	subs	r3, r5, r0
    c8c0:	9a02      	ldr	r2, [sp, #8]
    c8c2:	b29b      	uxth	r3, r3
    c8c4:	4405      	add	r5, r0
    c8c6:	4293      	cmp	r3, r2
    c8c8:	b2ad      	uxth	r5, r5
    c8ca:	d803      	bhi.n	c8d4 <bsec_codegen_update_subscription+0x31c>
    c8cc:	4295      	cmp	r5, r2
    c8ce:	d301      	bcc.n	c8d4 <bsec_codegen_update_subscription+0x31c>
    c8d0:	9d03      	ldr	r5, [sp, #12]
    c8d2:	e77e      	b.n	c7d2 <bsec_codegen_update_subscription+0x21a>
    c8d4:	f1ba 0f54 	cmp.w	sl, #84	; 0x54
    c8d8:	d1d3      	bne.n	c882 <bsec_codegen_update_subscription+0x2ca>
    c8da:	23f4      	movs	r3, #244	; 0xf4
    c8dc:	9d03      	ldr	r5, [sp, #12]
    c8de:	f889 3000 	strb.w	r3, [r9]
    c8e2:	e69f      	b.n	c624 <bsec_codegen_update_subscription+0x6c>
    c8e4:	f3af 8000 	nop.w
    c8e8:	47ae147b 	.word	0x47ae147b
    c8ec:	3f847ae1 	.word	0x3f847ae1
    c8f0:	477fff00 	.word	0x477fff00
    c8f4:	3ada740e 	.word	0x3ada740e
    c8f8:	42c80000 	.word	0x42c80000
    c8fc:	001279ef 	.word	0x001279ef
    c900:	0003ad14 	.word	0x0003ad14
    c904:	0003ad68 	.word	0x0003ad68
    c908:	00e0200f 	.word	0x00e0200f
    c90c:	00000000 	.word	0x00000000

0000c910 <bsec_SensorHeatCompensator_SensorHeatCompensator>:
    c910:	4916      	ldr	r1, [pc, #88]	; (c96c <bsec_SensorHeatCompensator_SensorHeatCompensator+0x5c>)
    c912:	6041      	str	r1, [r0, #4]
    c914:	b430      	push	{r4, r5}
    c916:	2109      	movs	r1, #9
    c918:	4d15      	ldr	r5, [pc, #84]	; (c970 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x60>)
    c91a:	4c16      	ldr	r4, [pc, #88]	; (c974 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x64>)
    c91c:	7001      	strb	r1, [r0, #0]
    c91e:	4916      	ldr	r1, [pc, #88]	; (c978 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x68>)
    c920:	4a16      	ldr	r2, [pc, #88]	; (c97c <bsec_SensorHeatCompensator_SensorHeatCompensator+0x6c>)
    c922:	6181      	str	r1, [r0, #24]
    c924:	62c5      	str	r5, [r0, #44]	; 0x2c
    c926:	4916      	ldr	r1, [pc, #88]	; (c980 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x70>)
    c928:	4d16      	ldr	r5, [pc, #88]	; (c984 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x74>)
    c92a:	6404      	str	r4, [r0, #64]	; 0x40
    c92c:	4c16      	ldr	r4, [pc, #88]	; (c988 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x78>)
    c92e:	6102      	str	r2, [r0, #16]
    c930:	6241      	str	r1, [r0, #36]	; 0x24
    c932:	4a16      	ldr	r2, [pc, #88]	; (c98c <bsec_SensorHeatCompensator_SensorHeatCompensator+0x7c>)
    c934:	4916      	ldr	r1, [pc, #88]	; (c990 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x80>)
    c936:	6385      	str	r5, [r0, #56]	; 0x38
    c938:	64c4      	str	r4, [r0, #76]	; 0x4c
    c93a:	4d16      	ldr	r5, [pc, #88]	; (c994 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x84>)
    c93c:	4c16      	ldr	r4, [pc, #88]	; (c998 <bsec_SensorHeatCompensator_SensorHeatCompensator+0x88>)
    c93e:	6142      	str	r2, [r0, #20]
    c940:	6281      	str	r1, [r0, #40]	; 0x28
    c942:	2200      	movs	r2, #0
    c944:	4915      	ldr	r1, [pc, #84]	; (c99c <bsec_SensorHeatCompensator_SensorHeatCompensator+0x8c>)
    c946:	63c5      	str	r5, [r0, #60]	; 0x3c
    c948:	6504      	str	r4, [r0, #80]	; 0x50
    c94a:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    c94e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    c952:	e9c0 4516 	strd	r4, r5, [r0, #88]	; 0x58
    c956:	6601      	str	r1, [r0, #96]	; 0x60
    c958:	6082      	str	r2, [r0, #8]
    c95a:	61c2      	str	r2, [r0, #28]
    c95c:	6302      	str	r2, [r0, #48]	; 0x30
    c95e:	6442      	str	r2, [r0, #68]	; 0x44
    c960:	60c2      	str	r2, [r0, #12]
    c962:	6202      	str	r2, [r0, #32]
    c964:	6342      	str	r2, [r0, #52]	; 0x34
    c966:	6482      	str	r2, [r0, #72]	; 0x48
    c968:	bc30      	pop	{r4, r5}
    c96a:	4770      	bx	lr
    c96c:	3d96f007 	.word	0x3d96f007
    c970:	c04c3fe6 	.word	0xc04c3fe6
    c974:	408350b1 	.word	0x408350b1
    c978:	40a00000 	.word	0x40a00000
    c97c:	3de17c1c 	.word	0x3de17c1c
    c980:	3e0ccccd 	.word	0x3e0ccccd
    c984:	bf3ced91 	.word	0xbf3ced91
    c988:	3ee3fe5d 	.word	0x3ee3fe5d
    c98c:	3fd78034 	.word	0x3fd78034
    c990:	3e27d567 	.word	0x3e27d567
    c994:	3f403afb 	.word	0x3f403afb
    c998:	bf853c36 	.word	0xbf853c36
    c99c:	40400000 	.word	0x40400000

0000c9a0 <bsec_SensorHeatCompensator_configure>:
    c9a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c9a4:	b086      	sub	sp, #24
    c9a6:	ab04      	add	r3, sp, #16
    c9a8:	ae05      	add	r6, sp, #20
    c9aa:	4605      	mov	r5, r0
    c9ac:	7800      	ldrb	r0, [r0, #0]
    c9ae:	9300      	str	r3, [sp, #0]
    c9b0:	9601      	str	r6, [sp, #4]
    c9b2:	f10d 030f 	add.w	r3, sp, #15
    c9b6:	460f      	mov	r7, r1
    c9b8:	f005 f83a 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
    c9bc:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    c9c0:	b9f8      	cbnz	r0, ca02 <bsec_SensorHeatCompensator_configure+0x62>
    c9c2:	2401      	movs	r4, #1
    c9c4:	f105 0a40 	add.w	sl, r5, #64	; 0x40
    c9c8:	f105 092c 	add.w	r9, r5, #44	; 0x2c
    c9cc:	f105 0818 	add.w	r8, r5, #24
    c9d0:	1ea3      	subs	r3, r4, #2
    c9d2:	2b03      	cmp	r3, #3
    c9d4:	d803      	bhi.n	c9de <bsec_SensorHeatCompensator_configure+0x3e>
    c9d6:	e8df f003 	tbb	[pc, r3]
    c9da:	1d23      	.short	0x1d23
    c9dc:	0c17      	.short	0x0c17
    c9de:	1d2a      	adds	r2, r5, #4
    c9e0:	4631      	mov	r1, r6
    c9e2:	4638      	mov	r0, r7
    c9e4:	f003 fb8e 	bl	10104 <bsec_q_Entity_parseAndDeserialize>
    c9e8:	2c05      	cmp	r4, #5
    c9ea:	d01f      	beq.n	ca2c <bsec_SensorHeatCompensator_configure+0x8c>
    c9ec:	3401      	adds	r4, #1
    c9ee:	b2e4      	uxtb	r4, r4
    c9f0:	e7ee      	b.n	c9d0 <bsec_SensorHeatCompensator_configure+0x30>
    c9f2:	4638      	mov	r0, r7
    c9f4:	4631      	mov	r1, r6
    c9f6:	f003 f8e7 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
    c9fa:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    c9fe:	ed85 0a18 	vstr	s0, [r5, #96]	; 0x60
    ca02:	b006      	add	sp, #24
    ca04:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ca08:	4652      	mov	r2, sl
    ca0a:	4631      	mov	r1, r6
    ca0c:	4638      	mov	r0, r7
    ca0e:	f003 fb79 	bl	10104 <bsec_q_Entity_parseAndDeserialize>
    ca12:	e7eb      	b.n	c9ec <bsec_SensorHeatCompensator_configure+0x4c>
    ca14:	464a      	mov	r2, r9
    ca16:	4631      	mov	r1, r6
    ca18:	4638      	mov	r0, r7
    ca1a:	f003 fb73 	bl	10104 <bsec_q_Entity_parseAndDeserialize>
    ca1e:	e7e5      	b.n	c9ec <bsec_SensorHeatCompensator_configure+0x4c>
    ca20:	4642      	mov	r2, r8
    ca22:	4631      	mov	r1, r6
    ca24:	4638      	mov	r0, r7
    ca26:	f003 fb6d 	bl	10104 <bsec_q_Entity_parseAndDeserialize>
    ca2a:	e7df      	b.n	c9ec <bsec_SensorHeatCompensator_configure+0x4c>
    ca2c:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    ca30:	e7e7      	b.n	ca02 <bsec_SensorHeatCompensator_configure+0x62>
    ca32:	bf00      	nop

0000ca34 <bsec_SensorHeatCompensator_doStep>:
    ca34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ca38:	ed2d 8b04 	vpush	{d8-d9}
    ca3c:	f8bd 1038 	ldrh.w	r1, [sp, #56]	; 0x38
    ca40:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
    ca44:	4606      	mov	r6, r0
    ca46:	eeb0 8a40 	vmov.f32	s16, s0
    ca4a:	4614      	mov	r4, r2
    ca4c:	461d      	mov	r5, r3
    ca4e:	eef0 8a60 	vmov.f32	s17, s1
    ca52:	d06a      	beq.n	cb2a <bsec_SensorHeatCompensator_doStep+0xf6>
    ca54:	d846      	bhi.n	cae4 <bsec_SensorHeatCompensator_doStep+0xb0>
    ca56:	2964      	cmp	r1, #100	; 0x64
    ca58:	d065      	beq.n	cb26 <bsec_SensorHeatCompensator_doStep+0xf2>
    ca5a:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    ca5e:	d14b      	bne.n	caf8 <bsec_SensorHeatCompensator_doStep+0xc4>
    ca60:	2704      	movs	r7, #4
    ca62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    ca66:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    ca6a:	e9d6 0116 	ldrd	r0, r1, [r6, #88]	; 0x58
    ca6e:	f005 f8a7 	bl	11bc0 <bsec_isequal>
    ca72:	2800      	cmp	r0, #0
    ca74:	d140      	bne.n	caf8 <bsec_SensorHeatCompensator_doStep+0xc4>
    ca76:	e9d6 0116 	ldrd	r0, r1, [r6, #88]	; 0x58
    ca7a:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    ca7e:	1a12      	subs	r2, r2, r0
    ca80:	eb63 0301 	sbc.w	r3, r3, r1
    ca84:	4610      	mov	r0, r2
    ca86:	4619      	mov	r1, r3
    ca88:	f000 fae2 	bl	d050 <__aeabi_l2d>
    ca8c:	a329      	add	r3, pc, #164	; (adr r3, cb34 <bsec_SensorHeatCompensator_doStep+0x100>)
    ca8e:	e9d3 2300 	ldrd	r2, r3, [r3]
    ca92:	f000 fc35 	bl	d300 <__aeabi_ddiv>
    ca96:	4680      	mov	r8, r0
    ca98:	4689      	mov	r9, r1
    ca9a:	f000 fdc9 	bl	d630 <__aeabi_d2f>
    ca9e:	eb06 0787 	add.w	r7, r6, r7, lsl #2
    caa2:	ee07 0a90 	vmov	s15, r0
    caa6:	edd7 9a00 	vldr	s19, [r7]
    caaa:	ed97 7a05 	vldr	s14, [r7, #20]
    caae:	ed97 9a0a 	vldr	s18, [r7, #40]	; 0x28
    cab2:	ee67 9aa9 	vmul.f32	s19, s15, s19
    cab6:	4642      	mov	r2, r8
    cab8:	464b      	mov	r3, r9
    caba:	4640      	mov	r0, r8
    cabc:	4649      	mov	r1, r9
    cabe:	ee27 9a89 	vmul.f32	s18, s15, s18
    cac2:	ee79 9a87 	vadd.f32	s19, s19, s14
    cac6:	f000 faf1 	bl	d0ac <__aeabi_dmul>
    caca:	f000 fdb1 	bl	d630 <__aeabi_d2f>
    cace:	ee07 0a90 	vmov	s15, r0
    cad2:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
    cad6:	ee79 7a27 	vadd.f32	s15, s18, s15
    cada:	ee77 7a87 	vadd.f32	s15, s15, s14
    cade:	ee89 9aa7 	vdiv.f32	s18, s19, s15
    cae2:	e00b      	b.n	cafc <bsec_SensorHeatCompensator_doStep+0xc8>
    cae4:	f241 7370 	movw	r3, #6000	; 0x1770
    cae8:	4299      	cmp	r1, r3
    caea:	d01a      	beq.n	cb22 <bsec_SensorHeatCompensator_doStep+0xee>
    caec:	f247 5330 	movw	r3, #30000	; 0x7530
    caf0:	4299      	cmp	r1, r3
    caf2:	d101      	bne.n	caf8 <bsec_SensorHeatCompensator_doStep+0xc4>
    caf4:	2701      	movs	r7, #1
    caf6:	e7b4      	b.n	ca62 <bsec_SensorHeatCompensator_doStep+0x2e>
    caf8:	ed9f 9a0d 	vldr	s18, [pc, #52]	; cb30 <bsec_SensorHeatCompensator_doStep+0xfc>
    cafc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    cb00:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
    cb04:	4620      	mov	r0, r4
    cb06:	4629      	mov	r1, r5
    cb08:	f005 f85a 	bl	11bc0 <bsec_isequal>
    cb0c:	b908      	cbnz	r0, cb12 <bsec_SensorHeatCompensator_doStep+0xde>
    cb0e:	e9c6 4516 	strd	r4, r5, [r6, #88]	; 0x58
    cb12:	ee38 0a49 	vsub.f32	s0, s16, s18
    cb16:	ee30 0a68 	vsub.f32	s0, s0, s17
    cb1a:	ecbd 8b04 	vpop	{d8-d9}
    cb1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    cb22:	2702      	movs	r7, #2
    cb24:	e79d      	b.n	ca62 <bsec_SensorHeatCompensator_doStep+0x2e>
    cb26:	2705      	movs	r7, #5
    cb28:	e79b      	b.n	ca62 <bsec_SensorHeatCompensator_doStep+0x2e>
    cb2a:	ed90 9a18 	vldr	s18, [r0, #96]	; 0x60
    cb2e:	e7e5      	b.n	cafc <bsec_SensorHeatCompensator_doStep+0xc8>
	...
    cb38:	41cdcd65 	.word	0x41cdcd65

0000cb3c <bsec_SensorHeatCompensator_getConfiguration>:
    cb3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    cb40:	b085      	sub	sp, #20
    cb42:	ac04      	add	r4, sp, #16
    cb44:	2505      	movs	r5, #5
    cb46:	f804 5d09 	strb.w	r5, [r4, #-9]!
    cb4a:	4606      	mov	r6, r0
    cb4c:	4617      	mov	r7, r2
    cb4e:	7800      	ldrb	r0, [r0, #0]
    cb50:	4622      	mov	r2, r4
    cb52:	460d      	mov	r5, r1
    cb54:	f004 ff9a 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
    cb58:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cb5c:	9003      	str	r0, [sp, #12]
    cb5e:	b1d2      	cbz	r2, cb96 <bsec_SensorHeatCompensator_getConfiguration+0x5a>
    cb60:	2401      	movs	r4, #1
    cb62:	f106 0940 	add.w	r9, r6, #64	; 0x40
    cb66:	f106 082c 	add.w	r8, r6, #44	; 0x2c
    cb6a:	1e63      	subs	r3, r4, #1
    cb6c:	2b04      	cmp	r3, #4
    cb6e:	d80d      	bhi.n	cb8c <bsec_SensorHeatCompensator_getConfiguration+0x50>
    cb70:	e8df f003 	tbb	[pc, r3]
    cb74:	2c35223e 	.word	0x2c35223e
    cb78:	03          	.byte	0x03
    cb79:	00          	.byte	0x00
    cb7a:	aa03      	add	r2, sp, #12
    cb7c:	4639      	mov	r1, r7
    cb7e:	4628      	mov	r0, r5
    cb80:	ed96 0a18 	vldr	s0, [r6, #96]	; 0x60
    cb84:	f003 f83a 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
    cb88:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cb8c:	3401      	adds	r4, #1
    cb8e:	b2e4      	uxtb	r4, r4
    cb90:	42a2      	cmp	r2, r4
    cb92:	d2ea      	bcs.n	cb6a <bsec_SensorHeatCompensator_getConfiguration+0x2e>
    cb94:	9803      	ldr	r0, [sp, #12]
    cb96:	a904      	add	r1, sp, #16
    cb98:	2202      	movs	r2, #2
    cb9a:	f821 0d06 	strh.w	r0, [r1, #-6]!
    cb9e:	a802      	add	r0, sp, #8
    cba0:	f02c fa1a 	bl	38fd8 <memcpy>
    cba4:	f89d 2008 	ldrb.w	r2, [sp, #8]
    cba8:	f89d 3009 	ldrb.w	r3, [sp, #9]
    cbac:	9803      	ldr	r0, [sp, #12]
    cbae:	702a      	strb	r2, [r5, #0]
    cbb0:	706b      	strb	r3, [r5, #1]
    cbb2:	b005      	add	sp, #20
    cbb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    cbb8:	463a      	mov	r2, r7
    cbba:	ab03      	add	r3, sp, #12
    cbbc:	4629      	mov	r1, r5
    cbbe:	f106 0018 	add.w	r0, r6, #24
    cbc2:	f003 fa11 	bl	ffe8 <bsec_n_Entity_serializeAndAdd>
    cbc6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cbca:	e7df      	b.n	cb8c <bsec_SensorHeatCompensator_getConfiguration+0x50>
    cbcc:	463a      	mov	r2, r7
    cbce:	ab03      	add	r3, sp, #12
    cbd0:	4629      	mov	r1, r5
    cbd2:	4648      	mov	r0, r9
    cbd4:	f003 fa08 	bl	ffe8 <bsec_n_Entity_serializeAndAdd>
    cbd8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cbdc:	e7d6      	b.n	cb8c <bsec_SensorHeatCompensator_getConfiguration+0x50>
    cbde:	463a      	mov	r2, r7
    cbe0:	ab03      	add	r3, sp, #12
    cbe2:	4629      	mov	r1, r5
    cbe4:	4640      	mov	r0, r8
    cbe6:	f003 f9ff 	bl	ffe8 <bsec_n_Entity_serializeAndAdd>
    cbea:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cbee:	e7cd      	b.n	cb8c <bsec_SensorHeatCompensator_getConfiguration+0x50>
    cbf0:	463a      	mov	r2, r7
    cbf2:	ab03      	add	r3, sp, #12
    cbf4:	4629      	mov	r1, r5
    cbf6:	1d30      	adds	r0, r6, #4
    cbf8:	f003 f9f6 	bl	ffe8 <bsec_n_Entity_serializeAndAdd>
    cbfc:	f89d 2007 	ldrb.w	r2, [sp, #7]
    cc00:	e7c4      	b.n	cb8c <bsec_SensorHeatCompensator_getConfiguration+0x50>
    cc02:	bf00      	nop

0000cc04 <bsec_SensorHeatCompensator_getState>:
    cc04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cc08:	b086      	sub	sp, #24
    cc0a:	ad06      	add	r5, sp, #24
    cc0c:	2401      	movs	r4, #1
    cc0e:	f805 4d09 	strb.w	r4, [r5, #-9]!
    cc12:	4607      	mov	r7, r0
    cc14:	4690      	mov	r8, r2
    cc16:	7800      	ldrb	r0, [r0, #0]
    cc18:	462a      	mov	r2, r5
    cc1a:	460e      	mov	r6, r1
    cc1c:	f004 ff36 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
    cc20:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cc24:	9005      	str	r0, [sp, #20]
    cc26:	b1ab      	cbz	r3, cc54 <bsec_SensorHeatCompensator_getState+0x50>
    cc28:	ad05      	add	r5, sp, #20
    cc2a:	e003      	b.n	cc34 <bsec_SensorHeatCompensator_getState+0x30>
    cc2c:	3401      	adds	r4, #1
    cc2e:	b2e4      	uxtb	r4, r4
    cc30:	42a3      	cmp	r3, r4
    cc32:	d30e      	bcc.n	cc52 <bsec_SensorHeatCompensator_getState+0x4e>
    cc34:	2c01      	cmp	r4, #1
    cc36:	d1f9      	bne.n	cc2c <bsec_SensorHeatCompensator_getState+0x28>
    cc38:	e9d7 0116 	ldrd	r0, r1, [r7, #88]	; 0x58
    cc3c:	4643      	mov	r3, r8
    cc3e:	9500      	str	r5, [sp, #0]
    cc40:	4632      	mov	r2, r6
    cc42:	f003 f84d 	bl	fce0 <bsec_g_Entity_serializeAndAdd>
    cc46:	3401      	adds	r4, #1
    cc48:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cc4c:	b2e4      	uxtb	r4, r4
    cc4e:	42a3      	cmp	r3, r4
    cc50:	d2f0      	bcs.n	cc34 <bsec_SensorHeatCompensator_getState+0x30>
    cc52:	9805      	ldr	r0, [sp, #20]
    cc54:	a906      	add	r1, sp, #24
    cc56:	2202      	movs	r2, #2
    cc58:	f821 0d06 	strh.w	r0, [r1, #-6]!
    cc5c:	a804      	add	r0, sp, #16
    cc5e:	f02c f9bb 	bl	38fd8 <memcpy>
    cc62:	f89d 2010 	ldrb.w	r2, [sp, #16]
    cc66:	f89d 3011 	ldrb.w	r3, [sp, #17]
    cc6a:	9805      	ldr	r0, [sp, #20]
    cc6c:	7032      	strb	r2, [r6, #0]
    cc6e:	7073      	strb	r3, [r6, #1]
    cc70:	b006      	add	sp, #24
    cc72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    cc76:	bf00      	nop

0000cc78 <bsec_SensorHeatCompensator_setState>:
    cc78:	b570      	push	{r4, r5, r6, lr}
    cc7a:	b086      	sub	sp, #24
    cc7c:	ab04      	add	r3, sp, #16
    cc7e:	ad05      	add	r5, sp, #20
    cc80:	4604      	mov	r4, r0
    cc82:	7800      	ldrb	r0, [r0, #0]
    cc84:	9300      	str	r3, [sp, #0]
    cc86:	9501      	str	r5, [sp, #4]
    cc88:	f10d 030f 	add.w	r3, sp, #15
    cc8c:	460e      	mov	r6, r1
    cc8e:	f004 fecf 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
    cc92:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    cc96:	b938      	cbnz	r0, cca8 <bsec_SensorHeatCompensator_setState+0x30>
    cc98:	4629      	mov	r1, r5
    cc9a:	4630      	mov	r0, r6
    cc9c:	f003 f804 	bl	fca8 <bsec_g_Entity_parseAndDeserialize>
    cca0:	e9c4 0116 	strd	r0, r1, [r4, #88]	; 0x58
    cca4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    cca8:	b006      	add	sp, #24
    ccaa:	bd70      	pop	{r4, r5, r6, pc}
    ccac:	0000      	movs	r0, r0
	...

0000ccb0 <bsec_rt_roundd>:
    ccb0:	b538      	push	{r3, r4, r5, lr}
    ccb2:	ec55 4b10 	vmov	r4, r5, d0
    ccb6:	f022 fbb5 	bl	2f424 <fabs>
    ccba:	2200      	movs	r2, #0
    ccbc:	4b1a      	ldr	r3, [pc, #104]	; (cd28 <bsec_rt_roundd+0x78>)
    ccbe:	ec51 0b10 	vmov	r0, r1, d0
    ccc2:	f000 fc65 	bl	d590 <__aeabi_dcmplt>
    ccc6:	b180      	cbz	r0, ccea <bsec_rt_roundd+0x3a>
    ccc8:	2200      	movs	r2, #0
    ccca:	4b18      	ldr	r3, [pc, #96]	; (cd2c <bsec_rt_roundd+0x7c>)
    cccc:	4620      	mov	r0, r4
    ccce:	4629      	mov	r1, r5
    ccd0:	f000 fc72 	bl	d5b8 <__aeabi_dcmpge>
    ccd4:	b960      	cbnz	r0, ccf0 <bsec_rt_roundd+0x40>
    ccd6:	2200      	movs	r2, #0
    ccd8:	4b15      	ldr	r3, [pc, #84]	; (cd30 <bsec_rt_roundd+0x80>)
    ccda:	4620      	mov	r0, r4
    ccdc:	4629      	mov	r1, r5
    ccde:	f000 fc75 	bl	d5cc <__aeabi_dcmpgt>
    cce2:	b188      	cbz	r0, cd08 <bsec_rt_roundd+0x58>
    cce4:	ed9f 0b0e 	vldr	d0, [pc, #56]	; cd20 <bsec_rt_roundd+0x70>
    cce8:	bd38      	pop	{r3, r4, r5, pc}
    ccea:	ec45 4b10 	vmov	d0, r4, r5
    ccee:	bd38      	pop	{r3, r4, r5, pc}
    ccf0:	4620      	mov	r0, r4
    ccf2:	4629      	mov	r1, r5
    ccf4:	4b0d      	ldr	r3, [pc, #52]	; (cd2c <bsec_rt_roundd+0x7c>)
    ccf6:	2200      	movs	r2, #0
    ccf8:	f000 f822 	bl	cd40 <__adddf3>
    ccfc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    cd00:	ec41 0b10 	vmov	d0, r0, r1
    cd04:	f006 b9a0 	b.w	13048 <floor>
    cd08:	4620      	mov	r0, r4
    cd0a:	4629      	mov	r1, r5
    cd0c:	4b07      	ldr	r3, [pc, #28]	; (cd2c <bsec_rt_roundd+0x7c>)
    cd0e:	2200      	movs	r2, #0
    cd10:	f000 f814 	bl	cd3c <__aeabi_dsub>
    cd14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    cd18:	ec41 0b10 	vmov	d0, r0, r1
    cd1c:	f006 b914 	b.w	12f48 <ceil>
	...
    cd28:	43300000 	.word	0x43300000
    cd2c:	3fe00000 	.word	0x3fe00000
    cd30:	bfe00000 	.word	0xbfe00000

0000cd34 <__aeabi_drsub>:
    cd34:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
    cd38:	e002      	b.n	cd40 <__adddf3>
    cd3a:	bf00      	nop

0000cd3c <__aeabi_dsub>:
    cd3c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0000cd40 <__adddf3>:
    cd40:	b530      	push	{r4, r5, lr}
    cd42:	ea4f 0441 	mov.w	r4, r1, lsl #1
    cd46:	ea4f 0543 	mov.w	r5, r3, lsl #1
    cd4a:	ea94 0f05 	teq	r4, r5
    cd4e:	bf08      	it	eq
    cd50:	ea90 0f02 	teqeq	r0, r2
    cd54:	bf1f      	itttt	ne
    cd56:	ea54 0c00 	orrsne.w	ip, r4, r0
    cd5a:	ea55 0c02 	orrsne.w	ip, r5, r2
    cd5e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
    cd62:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    cd66:	f000 80e2 	beq.w	cf2e <__adddf3+0x1ee>
    cd6a:	ea4f 5454 	mov.w	r4, r4, lsr #21
    cd6e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
    cd72:	bfb8      	it	lt
    cd74:	426d      	neglt	r5, r5
    cd76:	dd0c      	ble.n	cd92 <__adddf3+0x52>
    cd78:	442c      	add	r4, r5
    cd7a:	ea80 0202 	eor.w	r2, r0, r2
    cd7e:	ea81 0303 	eor.w	r3, r1, r3
    cd82:	ea82 0000 	eor.w	r0, r2, r0
    cd86:	ea83 0101 	eor.w	r1, r3, r1
    cd8a:	ea80 0202 	eor.w	r2, r0, r2
    cd8e:	ea81 0303 	eor.w	r3, r1, r3
    cd92:	2d36      	cmp	r5, #54	; 0x36
    cd94:	bf88      	it	hi
    cd96:	bd30      	pophi	{r4, r5, pc}
    cd98:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    cd9c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    cda0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
    cda4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
    cda8:	d002      	beq.n	cdb0 <__adddf3+0x70>
    cdaa:	4240      	negs	r0, r0
    cdac:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    cdb0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
    cdb4:	ea4f 3303 	mov.w	r3, r3, lsl #12
    cdb8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
    cdbc:	d002      	beq.n	cdc4 <__adddf3+0x84>
    cdbe:	4252      	negs	r2, r2
    cdc0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    cdc4:	ea94 0f05 	teq	r4, r5
    cdc8:	f000 80a7 	beq.w	cf1a <__adddf3+0x1da>
    cdcc:	f1a4 0401 	sub.w	r4, r4, #1
    cdd0:	f1d5 0e20 	rsbs	lr, r5, #32
    cdd4:	db0d      	blt.n	cdf2 <__adddf3+0xb2>
    cdd6:	fa02 fc0e 	lsl.w	ip, r2, lr
    cdda:	fa22 f205 	lsr.w	r2, r2, r5
    cdde:	1880      	adds	r0, r0, r2
    cde0:	f141 0100 	adc.w	r1, r1, #0
    cde4:	fa03 f20e 	lsl.w	r2, r3, lr
    cde8:	1880      	adds	r0, r0, r2
    cdea:	fa43 f305 	asr.w	r3, r3, r5
    cdee:	4159      	adcs	r1, r3
    cdf0:	e00e      	b.n	ce10 <__adddf3+0xd0>
    cdf2:	f1a5 0520 	sub.w	r5, r5, #32
    cdf6:	f10e 0e20 	add.w	lr, lr, #32
    cdfa:	2a01      	cmp	r2, #1
    cdfc:	fa03 fc0e 	lsl.w	ip, r3, lr
    ce00:	bf28      	it	cs
    ce02:	f04c 0c02 	orrcs.w	ip, ip, #2
    ce06:	fa43 f305 	asr.w	r3, r3, r5
    ce0a:	18c0      	adds	r0, r0, r3
    ce0c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
    ce10:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    ce14:	d507      	bpl.n	ce26 <__adddf3+0xe6>
    ce16:	f04f 0e00 	mov.w	lr, #0
    ce1a:	f1dc 0c00 	rsbs	ip, ip, #0
    ce1e:	eb7e 0000 	sbcs.w	r0, lr, r0
    ce22:	eb6e 0101 	sbc.w	r1, lr, r1
    ce26:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
    ce2a:	d31b      	bcc.n	ce64 <__adddf3+0x124>
    ce2c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    ce30:	d30c      	bcc.n	ce4c <__adddf3+0x10c>
    ce32:	0849      	lsrs	r1, r1, #1
    ce34:	ea5f 0030 	movs.w	r0, r0, rrx
    ce38:	ea4f 0c3c 	mov.w	ip, ip, rrx
    ce3c:	f104 0401 	add.w	r4, r4, #1
    ce40:	ea4f 5244 	mov.w	r2, r4, lsl #21
    ce44:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
    ce48:	f080 809a 	bcs.w	cf80 <__adddf3+0x240>
    ce4c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
    ce50:	bf08      	it	eq
    ce52:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    ce56:	f150 0000 	adcs.w	r0, r0, #0
    ce5a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    ce5e:	ea41 0105 	orr.w	r1, r1, r5
    ce62:	bd30      	pop	{r4, r5, pc}
    ce64:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
    ce68:	4140      	adcs	r0, r0
    ce6a:	eb41 0101 	adc.w	r1, r1, r1
    ce6e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    ce72:	f1a4 0401 	sub.w	r4, r4, #1
    ce76:	d1e9      	bne.n	ce4c <__adddf3+0x10c>
    ce78:	f091 0f00 	teq	r1, #0
    ce7c:	bf04      	itt	eq
    ce7e:	4601      	moveq	r1, r0
    ce80:	2000      	moveq	r0, #0
    ce82:	fab1 f381 	clz	r3, r1
    ce86:	bf08      	it	eq
    ce88:	3320      	addeq	r3, #32
    ce8a:	f1a3 030b 	sub.w	r3, r3, #11
    ce8e:	f1b3 0220 	subs.w	r2, r3, #32
    ce92:	da0c      	bge.n	ceae <__adddf3+0x16e>
    ce94:	320c      	adds	r2, #12
    ce96:	dd08      	ble.n	ceaa <__adddf3+0x16a>
    ce98:	f102 0c14 	add.w	ip, r2, #20
    ce9c:	f1c2 020c 	rsb	r2, r2, #12
    cea0:	fa01 f00c 	lsl.w	r0, r1, ip
    cea4:	fa21 f102 	lsr.w	r1, r1, r2
    cea8:	e00c      	b.n	cec4 <__adddf3+0x184>
    ceaa:	f102 0214 	add.w	r2, r2, #20
    ceae:	bfd8      	it	le
    ceb0:	f1c2 0c20 	rsble	ip, r2, #32
    ceb4:	fa01 f102 	lsl.w	r1, r1, r2
    ceb8:	fa20 fc0c 	lsr.w	ip, r0, ip
    cebc:	bfdc      	itt	le
    cebe:	ea41 010c 	orrle.w	r1, r1, ip
    cec2:	4090      	lslle	r0, r2
    cec4:	1ae4      	subs	r4, r4, r3
    cec6:	bfa2      	ittt	ge
    cec8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
    cecc:	4329      	orrge	r1, r5
    cece:	bd30      	popge	{r4, r5, pc}
    ced0:	ea6f 0404 	mvn.w	r4, r4
    ced4:	3c1f      	subs	r4, #31
    ced6:	da1c      	bge.n	cf12 <__adddf3+0x1d2>
    ced8:	340c      	adds	r4, #12
    ceda:	dc0e      	bgt.n	cefa <__adddf3+0x1ba>
    cedc:	f104 0414 	add.w	r4, r4, #20
    cee0:	f1c4 0220 	rsb	r2, r4, #32
    cee4:	fa20 f004 	lsr.w	r0, r0, r4
    cee8:	fa01 f302 	lsl.w	r3, r1, r2
    ceec:	ea40 0003 	orr.w	r0, r0, r3
    cef0:	fa21 f304 	lsr.w	r3, r1, r4
    cef4:	ea45 0103 	orr.w	r1, r5, r3
    cef8:	bd30      	pop	{r4, r5, pc}
    cefa:	f1c4 040c 	rsb	r4, r4, #12
    cefe:	f1c4 0220 	rsb	r2, r4, #32
    cf02:	fa20 f002 	lsr.w	r0, r0, r2
    cf06:	fa01 f304 	lsl.w	r3, r1, r4
    cf0a:	ea40 0003 	orr.w	r0, r0, r3
    cf0e:	4629      	mov	r1, r5
    cf10:	bd30      	pop	{r4, r5, pc}
    cf12:	fa21 f004 	lsr.w	r0, r1, r4
    cf16:	4629      	mov	r1, r5
    cf18:	bd30      	pop	{r4, r5, pc}
    cf1a:	f094 0f00 	teq	r4, #0
    cf1e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
    cf22:	bf06      	itte	eq
    cf24:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
    cf28:	3401      	addeq	r4, #1
    cf2a:	3d01      	subne	r5, #1
    cf2c:	e74e      	b.n	cdcc <__adddf3+0x8c>
    cf2e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    cf32:	bf18      	it	ne
    cf34:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
    cf38:	d029      	beq.n	cf8e <__adddf3+0x24e>
    cf3a:	ea94 0f05 	teq	r4, r5
    cf3e:	bf08      	it	eq
    cf40:	ea90 0f02 	teqeq	r0, r2
    cf44:	d005      	beq.n	cf52 <__adddf3+0x212>
    cf46:	ea54 0c00 	orrs.w	ip, r4, r0
    cf4a:	bf04      	itt	eq
    cf4c:	4619      	moveq	r1, r3
    cf4e:	4610      	moveq	r0, r2
    cf50:	bd30      	pop	{r4, r5, pc}
    cf52:	ea91 0f03 	teq	r1, r3
    cf56:	bf1e      	ittt	ne
    cf58:	2100      	movne	r1, #0
    cf5a:	2000      	movne	r0, #0
    cf5c:	bd30      	popne	{r4, r5, pc}
    cf5e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
    cf62:	d105      	bne.n	cf70 <__adddf3+0x230>
    cf64:	0040      	lsls	r0, r0, #1
    cf66:	4149      	adcs	r1, r1
    cf68:	bf28      	it	cs
    cf6a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
    cf6e:	bd30      	pop	{r4, r5, pc}
    cf70:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
    cf74:	bf3c      	itt	cc
    cf76:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
    cf7a:	bd30      	popcc	{r4, r5, pc}
    cf7c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    cf80:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
    cf84:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    cf88:	f04f 0000 	mov.w	r0, #0
    cf8c:	bd30      	pop	{r4, r5, pc}
    cf8e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
    cf92:	bf1a      	itte	ne
    cf94:	4619      	movne	r1, r3
    cf96:	4610      	movne	r0, r2
    cf98:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
    cf9c:	bf1c      	itt	ne
    cf9e:	460b      	movne	r3, r1
    cfa0:	4602      	movne	r2, r0
    cfa2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    cfa6:	bf06      	itte	eq
    cfa8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
    cfac:	ea91 0f03 	teqeq	r1, r3
    cfb0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
    cfb4:	bd30      	pop	{r4, r5, pc}
    cfb6:	bf00      	nop

0000cfb8 <__aeabi_ui2d>:
    cfb8:	f090 0f00 	teq	r0, #0
    cfbc:	bf04      	itt	eq
    cfbe:	2100      	moveq	r1, #0
    cfc0:	4770      	bxeq	lr
    cfc2:	b530      	push	{r4, r5, lr}
    cfc4:	f44f 6480 	mov.w	r4, #1024	; 0x400
    cfc8:	f104 0432 	add.w	r4, r4, #50	; 0x32
    cfcc:	f04f 0500 	mov.w	r5, #0
    cfd0:	f04f 0100 	mov.w	r1, #0
    cfd4:	e750      	b.n	ce78 <__adddf3+0x138>
    cfd6:	bf00      	nop

0000cfd8 <__aeabi_i2d>:
    cfd8:	f090 0f00 	teq	r0, #0
    cfdc:	bf04      	itt	eq
    cfde:	2100      	moveq	r1, #0
    cfe0:	4770      	bxeq	lr
    cfe2:	b530      	push	{r4, r5, lr}
    cfe4:	f44f 6480 	mov.w	r4, #1024	; 0x400
    cfe8:	f104 0432 	add.w	r4, r4, #50	; 0x32
    cfec:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
    cff0:	bf48      	it	mi
    cff2:	4240      	negmi	r0, r0
    cff4:	f04f 0100 	mov.w	r1, #0
    cff8:	e73e      	b.n	ce78 <__adddf3+0x138>
    cffa:	bf00      	nop

0000cffc <__aeabi_f2d>:
    cffc:	0042      	lsls	r2, r0, #1
    cffe:	ea4f 01e2 	mov.w	r1, r2, asr #3
    d002:	ea4f 0131 	mov.w	r1, r1, rrx
    d006:	ea4f 7002 	mov.w	r0, r2, lsl #28
    d00a:	bf1f      	itttt	ne
    d00c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
    d010:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
    d014:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
    d018:	4770      	bxne	lr
    d01a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
    d01e:	bf08      	it	eq
    d020:	4770      	bxeq	lr
    d022:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
    d026:	bf04      	itt	eq
    d028:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
    d02c:	4770      	bxeq	lr
    d02e:	b530      	push	{r4, r5, lr}
    d030:	f44f 7460 	mov.w	r4, #896	; 0x380
    d034:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
    d038:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    d03c:	e71c      	b.n	ce78 <__adddf3+0x138>
    d03e:	bf00      	nop

0000d040 <__aeabi_ul2d>:
    d040:	ea50 0201 	orrs.w	r2, r0, r1
    d044:	bf08      	it	eq
    d046:	4770      	bxeq	lr
    d048:	b530      	push	{r4, r5, lr}
    d04a:	f04f 0500 	mov.w	r5, #0
    d04e:	e00a      	b.n	d066 <__aeabi_l2d+0x16>

0000d050 <__aeabi_l2d>:
    d050:	ea50 0201 	orrs.w	r2, r0, r1
    d054:	bf08      	it	eq
    d056:	4770      	bxeq	lr
    d058:	b530      	push	{r4, r5, lr}
    d05a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
    d05e:	d502      	bpl.n	d066 <__aeabi_l2d+0x16>
    d060:	4240      	negs	r0, r0
    d062:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d066:	f44f 6480 	mov.w	r4, #1024	; 0x400
    d06a:	f104 0432 	add.w	r4, r4, #50	; 0x32
    d06e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
    d072:	f43f aed8 	beq.w	ce26 <__adddf3+0xe6>
    d076:	f04f 0203 	mov.w	r2, #3
    d07a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    d07e:	bf18      	it	ne
    d080:	3203      	addne	r2, #3
    d082:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
    d086:	bf18      	it	ne
    d088:	3203      	addne	r2, #3
    d08a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
    d08e:	f1c2 0320 	rsb	r3, r2, #32
    d092:	fa00 fc03 	lsl.w	ip, r0, r3
    d096:	fa20 f002 	lsr.w	r0, r0, r2
    d09a:	fa01 fe03 	lsl.w	lr, r1, r3
    d09e:	ea40 000e 	orr.w	r0, r0, lr
    d0a2:	fa21 f102 	lsr.w	r1, r1, r2
    d0a6:	4414      	add	r4, r2
    d0a8:	e6bd      	b.n	ce26 <__adddf3+0xe6>
    d0aa:	bf00      	nop

0000d0ac <__aeabi_dmul>:
    d0ac:	b570      	push	{r4, r5, r6, lr}
    d0ae:	f04f 0cff 	mov.w	ip, #255	; 0xff
    d0b2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    d0b6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    d0ba:	bf1d      	ittte	ne
    d0bc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    d0c0:	ea94 0f0c 	teqne	r4, ip
    d0c4:	ea95 0f0c 	teqne	r5, ip
    d0c8:	f000 f8de 	bleq	d288 <__aeabi_dmul+0x1dc>
    d0cc:	442c      	add	r4, r5
    d0ce:	ea81 0603 	eor.w	r6, r1, r3
    d0d2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
    d0d6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
    d0da:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
    d0de:	bf18      	it	ne
    d0e0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
    d0e4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    d0e8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    d0ec:	d038      	beq.n	d160 <__aeabi_dmul+0xb4>
    d0ee:	fba0 ce02 	umull	ip, lr, r0, r2
    d0f2:	f04f 0500 	mov.w	r5, #0
    d0f6:	fbe1 e502 	umlal	lr, r5, r1, r2
    d0fa:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
    d0fe:	fbe0 e503 	umlal	lr, r5, r0, r3
    d102:	f04f 0600 	mov.w	r6, #0
    d106:	fbe1 5603 	umlal	r5, r6, r1, r3
    d10a:	f09c 0f00 	teq	ip, #0
    d10e:	bf18      	it	ne
    d110:	f04e 0e01 	orrne.w	lr, lr, #1
    d114:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
    d118:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
    d11c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
    d120:	d204      	bcs.n	d12c <__aeabi_dmul+0x80>
    d122:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
    d126:	416d      	adcs	r5, r5
    d128:	eb46 0606 	adc.w	r6, r6, r6
    d12c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
    d130:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
    d134:	ea4f 20c5 	mov.w	r0, r5, lsl #11
    d138:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
    d13c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
    d140:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    d144:	bf88      	it	hi
    d146:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    d14a:	d81e      	bhi.n	d18a <__aeabi_dmul+0xde>
    d14c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
    d150:	bf08      	it	eq
    d152:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
    d156:	f150 0000 	adcs.w	r0, r0, #0
    d15a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    d15e:	bd70      	pop	{r4, r5, r6, pc}
    d160:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
    d164:	ea46 0101 	orr.w	r1, r6, r1
    d168:	ea40 0002 	orr.w	r0, r0, r2
    d16c:	ea81 0103 	eor.w	r1, r1, r3
    d170:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
    d174:	bfc2      	ittt	gt
    d176:	ebd4 050c 	rsbsgt	r5, r4, ip
    d17a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    d17e:	bd70      	popgt	{r4, r5, r6, pc}
    d180:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    d184:	f04f 0e00 	mov.w	lr, #0
    d188:	3c01      	subs	r4, #1
    d18a:	f300 80ab 	bgt.w	d2e4 <__aeabi_dmul+0x238>
    d18e:	f114 0f36 	cmn.w	r4, #54	; 0x36
    d192:	bfde      	ittt	le
    d194:	2000      	movle	r0, #0
    d196:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
    d19a:	bd70      	pople	{r4, r5, r6, pc}
    d19c:	f1c4 0400 	rsb	r4, r4, #0
    d1a0:	3c20      	subs	r4, #32
    d1a2:	da35      	bge.n	d210 <__aeabi_dmul+0x164>
    d1a4:	340c      	adds	r4, #12
    d1a6:	dc1b      	bgt.n	d1e0 <__aeabi_dmul+0x134>
    d1a8:	f104 0414 	add.w	r4, r4, #20
    d1ac:	f1c4 0520 	rsb	r5, r4, #32
    d1b0:	fa00 f305 	lsl.w	r3, r0, r5
    d1b4:	fa20 f004 	lsr.w	r0, r0, r4
    d1b8:	fa01 f205 	lsl.w	r2, r1, r5
    d1bc:	ea40 0002 	orr.w	r0, r0, r2
    d1c0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
    d1c4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
    d1c8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    d1cc:	fa21 f604 	lsr.w	r6, r1, r4
    d1d0:	eb42 0106 	adc.w	r1, r2, r6
    d1d4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    d1d8:	bf08      	it	eq
    d1da:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    d1de:	bd70      	pop	{r4, r5, r6, pc}
    d1e0:	f1c4 040c 	rsb	r4, r4, #12
    d1e4:	f1c4 0520 	rsb	r5, r4, #32
    d1e8:	fa00 f304 	lsl.w	r3, r0, r4
    d1ec:	fa20 f005 	lsr.w	r0, r0, r5
    d1f0:	fa01 f204 	lsl.w	r2, r1, r4
    d1f4:	ea40 0002 	orr.w	r0, r0, r2
    d1f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    d1fc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
    d200:	f141 0100 	adc.w	r1, r1, #0
    d204:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    d208:	bf08      	it	eq
    d20a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    d20e:	bd70      	pop	{r4, r5, r6, pc}
    d210:	f1c4 0520 	rsb	r5, r4, #32
    d214:	fa00 f205 	lsl.w	r2, r0, r5
    d218:	ea4e 0e02 	orr.w	lr, lr, r2
    d21c:	fa20 f304 	lsr.w	r3, r0, r4
    d220:	fa01 f205 	lsl.w	r2, r1, r5
    d224:	ea43 0302 	orr.w	r3, r3, r2
    d228:	fa21 f004 	lsr.w	r0, r1, r4
    d22c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    d230:	fa21 f204 	lsr.w	r2, r1, r4
    d234:	ea20 0002 	bic.w	r0, r0, r2
    d238:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
    d23c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
    d240:	bf08      	it	eq
    d242:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
    d246:	bd70      	pop	{r4, r5, r6, pc}
    d248:	f094 0f00 	teq	r4, #0
    d24c:	d10f      	bne.n	d26e <__aeabi_dmul+0x1c2>
    d24e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
    d252:	0040      	lsls	r0, r0, #1
    d254:	eb41 0101 	adc.w	r1, r1, r1
    d258:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    d25c:	bf08      	it	eq
    d25e:	3c01      	subeq	r4, #1
    d260:	d0f7      	beq.n	d252 <__aeabi_dmul+0x1a6>
    d262:	ea41 0106 	orr.w	r1, r1, r6
    d266:	f095 0f00 	teq	r5, #0
    d26a:	bf18      	it	ne
    d26c:	4770      	bxne	lr
    d26e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
    d272:	0052      	lsls	r2, r2, #1
    d274:	eb43 0303 	adc.w	r3, r3, r3
    d278:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
    d27c:	bf08      	it	eq
    d27e:	3d01      	subeq	r5, #1
    d280:	d0f7      	beq.n	d272 <__aeabi_dmul+0x1c6>
    d282:	ea43 0306 	orr.w	r3, r3, r6
    d286:	4770      	bx	lr
    d288:	ea94 0f0c 	teq	r4, ip
    d28c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    d290:	bf18      	it	ne
    d292:	ea95 0f0c 	teqne	r5, ip
    d296:	d00c      	beq.n	d2b2 <__aeabi_dmul+0x206>
    d298:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    d29c:	bf18      	it	ne
    d29e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    d2a2:	d1d1      	bne.n	d248 <__aeabi_dmul+0x19c>
    d2a4:	ea81 0103 	eor.w	r1, r1, r3
    d2a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    d2ac:	f04f 0000 	mov.w	r0, #0
    d2b0:	bd70      	pop	{r4, r5, r6, pc}
    d2b2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    d2b6:	bf06      	itte	eq
    d2b8:	4610      	moveq	r0, r2
    d2ba:	4619      	moveq	r1, r3
    d2bc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    d2c0:	d019      	beq.n	d2f6 <__aeabi_dmul+0x24a>
    d2c2:	ea94 0f0c 	teq	r4, ip
    d2c6:	d102      	bne.n	d2ce <__aeabi_dmul+0x222>
    d2c8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
    d2cc:	d113      	bne.n	d2f6 <__aeabi_dmul+0x24a>
    d2ce:	ea95 0f0c 	teq	r5, ip
    d2d2:	d105      	bne.n	d2e0 <__aeabi_dmul+0x234>
    d2d4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
    d2d8:	bf1c      	itt	ne
    d2da:	4610      	movne	r0, r2
    d2dc:	4619      	movne	r1, r3
    d2de:	d10a      	bne.n	d2f6 <__aeabi_dmul+0x24a>
    d2e0:	ea81 0103 	eor.w	r1, r1, r3
    d2e4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
    d2e8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    d2ec:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    d2f0:	f04f 0000 	mov.w	r0, #0
    d2f4:	bd70      	pop	{r4, r5, r6, pc}
    d2f6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
    d2fa:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
    d2fe:	bd70      	pop	{r4, r5, r6, pc}

0000d300 <__aeabi_ddiv>:
    d300:	b570      	push	{r4, r5, r6, lr}
    d302:	f04f 0cff 	mov.w	ip, #255	; 0xff
    d306:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
    d30a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
    d30e:	bf1d      	ittte	ne
    d310:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
    d314:	ea94 0f0c 	teqne	r4, ip
    d318:	ea95 0f0c 	teqne	r5, ip
    d31c:	f000 f8a7 	bleq	d46e <__aeabi_ddiv+0x16e>
    d320:	eba4 0405 	sub.w	r4, r4, r5
    d324:	ea81 0e03 	eor.w	lr, r1, r3
    d328:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    d32c:	ea4f 3101 	mov.w	r1, r1, lsl #12
    d330:	f000 8088 	beq.w	d444 <__aeabi_ddiv+0x144>
    d334:	ea4f 3303 	mov.w	r3, r3, lsl #12
    d338:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
    d33c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
    d340:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    d344:	ea4f 2202 	mov.w	r2, r2, lsl #8
    d348:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
    d34c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
    d350:	ea4f 2600 	mov.w	r6, r0, lsl #8
    d354:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
    d358:	429d      	cmp	r5, r3
    d35a:	bf08      	it	eq
    d35c:	4296      	cmpeq	r6, r2
    d35e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
    d362:	f504 7440 	add.w	r4, r4, #768	; 0x300
    d366:	d202      	bcs.n	d36e <__aeabi_ddiv+0x6e>
    d368:	085b      	lsrs	r3, r3, #1
    d36a:	ea4f 0232 	mov.w	r2, r2, rrx
    d36e:	1ab6      	subs	r6, r6, r2
    d370:	eb65 0503 	sbc.w	r5, r5, r3
    d374:	085b      	lsrs	r3, r3, #1
    d376:	ea4f 0232 	mov.w	r2, r2, rrx
    d37a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
    d37e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
    d382:	ebb6 0e02 	subs.w	lr, r6, r2
    d386:	eb75 0e03 	sbcs.w	lr, r5, r3
    d38a:	bf22      	ittt	cs
    d38c:	1ab6      	subcs	r6, r6, r2
    d38e:	4675      	movcs	r5, lr
    d390:	ea40 000c 	orrcs.w	r0, r0, ip
    d394:	085b      	lsrs	r3, r3, #1
    d396:	ea4f 0232 	mov.w	r2, r2, rrx
    d39a:	ebb6 0e02 	subs.w	lr, r6, r2
    d39e:	eb75 0e03 	sbcs.w	lr, r5, r3
    d3a2:	bf22      	ittt	cs
    d3a4:	1ab6      	subcs	r6, r6, r2
    d3a6:	4675      	movcs	r5, lr
    d3a8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
    d3ac:	085b      	lsrs	r3, r3, #1
    d3ae:	ea4f 0232 	mov.w	r2, r2, rrx
    d3b2:	ebb6 0e02 	subs.w	lr, r6, r2
    d3b6:	eb75 0e03 	sbcs.w	lr, r5, r3
    d3ba:	bf22      	ittt	cs
    d3bc:	1ab6      	subcs	r6, r6, r2
    d3be:	4675      	movcs	r5, lr
    d3c0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
    d3c4:	085b      	lsrs	r3, r3, #1
    d3c6:	ea4f 0232 	mov.w	r2, r2, rrx
    d3ca:	ebb6 0e02 	subs.w	lr, r6, r2
    d3ce:	eb75 0e03 	sbcs.w	lr, r5, r3
    d3d2:	bf22      	ittt	cs
    d3d4:	1ab6      	subcs	r6, r6, r2
    d3d6:	4675      	movcs	r5, lr
    d3d8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
    d3dc:	ea55 0e06 	orrs.w	lr, r5, r6
    d3e0:	d018      	beq.n	d414 <__aeabi_ddiv+0x114>
    d3e2:	ea4f 1505 	mov.w	r5, r5, lsl #4
    d3e6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
    d3ea:	ea4f 1606 	mov.w	r6, r6, lsl #4
    d3ee:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    d3f2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
    d3f6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    d3fa:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
    d3fe:	d1c0      	bne.n	d382 <__aeabi_ddiv+0x82>
    d400:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    d404:	d10b      	bne.n	d41e <__aeabi_ddiv+0x11e>
    d406:	ea41 0100 	orr.w	r1, r1, r0
    d40a:	f04f 0000 	mov.w	r0, #0
    d40e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
    d412:	e7b6      	b.n	d382 <__aeabi_ddiv+0x82>
    d414:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
    d418:	bf04      	itt	eq
    d41a:	4301      	orreq	r1, r0
    d41c:	2000      	moveq	r0, #0
    d41e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
    d422:	bf88      	it	hi
    d424:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
    d428:	f63f aeaf 	bhi.w	d18a <__aeabi_dmul+0xde>
    d42c:	ebb5 0c03 	subs.w	ip, r5, r3
    d430:	bf04      	itt	eq
    d432:	ebb6 0c02 	subseq.w	ip, r6, r2
    d436:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
    d43a:	f150 0000 	adcs.w	r0, r0, #0
    d43e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
    d442:	bd70      	pop	{r4, r5, r6, pc}
    d444:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
    d448:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
    d44c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
    d450:	bfc2      	ittt	gt
    d452:	ebd4 050c 	rsbsgt	r5, r4, ip
    d456:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
    d45a:	bd70      	popgt	{r4, r5, r6, pc}
    d45c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    d460:	f04f 0e00 	mov.w	lr, #0
    d464:	3c01      	subs	r4, #1
    d466:	e690      	b.n	d18a <__aeabi_dmul+0xde>
    d468:	ea45 0e06 	orr.w	lr, r5, r6
    d46c:	e68d      	b.n	d18a <__aeabi_dmul+0xde>
    d46e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
    d472:	ea94 0f0c 	teq	r4, ip
    d476:	bf08      	it	eq
    d478:	ea95 0f0c 	teqeq	r5, ip
    d47c:	f43f af3b 	beq.w	d2f6 <__aeabi_dmul+0x24a>
    d480:	ea94 0f0c 	teq	r4, ip
    d484:	d10a      	bne.n	d49c <__aeabi_ddiv+0x19c>
    d486:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
    d48a:	f47f af34 	bne.w	d2f6 <__aeabi_dmul+0x24a>
    d48e:	ea95 0f0c 	teq	r5, ip
    d492:	f47f af25 	bne.w	d2e0 <__aeabi_dmul+0x234>
    d496:	4610      	mov	r0, r2
    d498:	4619      	mov	r1, r3
    d49a:	e72c      	b.n	d2f6 <__aeabi_dmul+0x24a>
    d49c:	ea95 0f0c 	teq	r5, ip
    d4a0:	d106      	bne.n	d4b0 <__aeabi_ddiv+0x1b0>
    d4a2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
    d4a6:	f43f aefd 	beq.w	d2a4 <__aeabi_dmul+0x1f8>
    d4aa:	4610      	mov	r0, r2
    d4ac:	4619      	mov	r1, r3
    d4ae:	e722      	b.n	d2f6 <__aeabi_dmul+0x24a>
    d4b0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
    d4b4:	bf18      	it	ne
    d4b6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
    d4ba:	f47f aec5 	bne.w	d248 <__aeabi_dmul+0x19c>
    d4be:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
    d4c2:	f47f af0d 	bne.w	d2e0 <__aeabi_dmul+0x234>
    d4c6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
    d4ca:	f47f aeeb 	bne.w	d2a4 <__aeabi_dmul+0x1f8>
    d4ce:	e712      	b.n	d2f6 <__aeabi_dmul+0x24a>

0000d4d0 <__gedf2>:
    d4d0:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
    d4d4:	e006      	b.n	d4e4 <__cmpdf2+0x4>
    d4d6:	bf00      	nop

0000d4d8 <__ledf2>:
    d4d8:	f04f 0c01 	mov.w	ip, #1
    d4dc:	e002      	b.n	d4e4 <__cmpdf2+0x4>
    d4de:	bf00      	nop

0000d4e0 <__cmpdf2>:
    d4e0:	f04f 0c01 	mov.w	ip, #1
    d4e4:	f84d cd04 	str.w	ip, [sp, #-4]!
    d4e8:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    d4ec:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    d4f0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    d4f4:	bf18      	it	ne
    d4f6:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
    d4fa:	d01b      	beq.n	d534 <__cmpdf2+0x54>
    d4fc:	b001      	add	sp, #4
    d4fe:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
    d502:	bf0c      	ite	eq
    d504:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
    d508:	ea91 0f03 	teqne	r1, r3
    d50c:	bf02      	ittt	eq
    d50e:	ea90 0f02 	teqeq	r0, r2
    d512:	2000      	moveq	r0, #0
    d514:	4770      	bxeq	lr
    d516:	f110 0f00 	cmn.w	r0, #0
    d51a:	ea91 0f03 	teq	r1, r3
    d51e:	bf58      	it	pl
    d520:	4299      	cmppl	r1, r3
    d522:	bf08      	it	eq
    d524:	4290      	cmpeq	r0, r2
    d526:	bf2c      	ite	cs
    d528:	17d8      	asrcs	r0, r3, #31
    d52a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
    d52e:	f040 0001 	orr.w	r0, r0, #1
    d532:	4770      	bx	lr
    d534:	ea4f 0c41 	mov.w	ip, r1, lsl #1
    d538:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    d53c:	d102      	bne.n	d544 <__cmpdf2+0x64>
    d53e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
    d542:	d107      	bne.n	d554 <__cmpdf2+0x74>
    d544:	ea4f 0c43 	mov.w	ip, r3, lsl #1
    d548:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
    d54c:	d1d6      	bne.n	d4fc <__cmpdf2+0x1c>
    d54e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
    d552:	d0d3      	beq.n	d4fc <__cmpdf2+0x1c>
    d554:	f85d 0b04 	ldr.w	r0, [sp], #4
    d558:	4770      	bx	lr
    d55a:	bf00      	nop

0000d55c <__aeabi_cdrcmple>:
    d55c:	4684      	mov	ip, r0
    d55e:	4610      	mov	r0, r2
    d560:	4662      	mov	r2, ip
    d562:	468c      	mov	ip, r1
    d564:	4619      	mov	r1, r3
    d566:	4663      	mov	r3, ip
    d568:	e000      	b.n	d56c <__aeabi_cdcmpeq>
    d56a:	bf00      	nop

0000d56c <__aeabi_cdcmpeq>:
    d56c:	b501      	push	{r0, lr}
    d56e:	f7ff ffb7 	bl	d4e0 <__cmpdf2>
    d572:	2800      	cmp	r0, #0
    d574:	bf48      	it	mi
    d576:	f110 0f00 	cmnmi.w	r0, #0
    d57a:	bd01      	pop	{r0, pc}

0000d57c <__aeabi_dcmpeq>:
    d57c:	f84d ed08 	str.w	lr, [sp, #-8]!
    d580:	f7ff fff4 	bl	d56c <__aeabi_cdcmpeq>
    d584:	bf0c      	ite	eq
    d586:	2001      	moveq	r0, #1
    d588:	2000      	movne	r0, #0
    d58a:	f85d fb08 	ldr.w	pc, [sp], #8
    d58e:	bf00      	nop

0000d590 <__aeabi_dcmplt>:
    d590:	f84d ed08 	str.w	lr, [sp, #-8]!
    d594:	f7ff ffea 	bl	d56c <__aeabi_cdcmpeq>
    d598:	bf34      	ite	cc
    d59a:	2001      	movcc	r0, #1
    d59c:	2000      	movcs	r0, #0
    d59e:	f85d fb08 	ldr.w	pc, [sp], #8
    d5a2:	bf00      	nop

0000d5a4 <__aeabi_dcmple>:
    d5a4:	f84d ed08 	str.w	lr, [sp, #-8]!
    d5a8:	f7ff ffe0 	bl	d56c <__aeabi_cdcmpeq>
    d5ac:	bf94      	ite	ls
    d5ae:	2001      	movls	r0, #1
    d5b0:	2000      	movhi	r0, #0
    d5b2:	f85d fb08 	ldr.w	pc, [sp], #8
    d5b6:	bf00      	nop

0000d5b8 <__aeabi_dcmpge>:
    d5b8:	f84d ed08 	str.w	lr, [sp, #-8]!
    d5bc:	f7ff ffce 	bl	d55c <__aeabi_cdrcmple>
    d5c0:	bf94      	ite	ls
    d5c2:	2001      	movls	r0, #1
    d5c4:	2000      	movhi	r0, #0
    d5c6:	f85d fb08 	ldr.w	pc, [sp], #8
    d5ca:	bf00      	nop

0000d5cc <__aeabi_dcmpgt>:
    d5cc:	f84d ed08 	str.w	lr, [sp, #-8]!
    d5d0:	f7ff ffc4 	bl	d55c <__aeabi_cdrcmple>
    d5d4:	bf34      	ite	cc
    d5d6:	2001      	movcc	r0, #1
    d5d8:	2000      	movcs	r0, #0
    d5da:	f85d fb08 	ldr.w	pc, [sp], #8
    d5de:	bf00      	nop

0000d5e0 <__aeabi_d2iz>:
    d5e0:	ea4f 0241 	mov.w	r2, r1, lsl #1
    d5e4:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
    d5e8:	d215      	bcs.n	d616 <__aeabi_d2iz+0x36>
    d5ea:	d511      	bpl.n	d610 <__aeabi_d2iz+0x30>
    d5ec:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
    d5f0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
    d5f4:	d912      	bls.n	d61c <__aeabi_d2iz+0x3c>
    d5f6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    d5fa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    d5fe:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
    d602:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
    d606:	fa23 f002 	lsr.w	r0, r3, r2
    d60a:	bf18      	it	ne
    d60c:	4240      	negne	r0, r0
    d60e:	4770      	bx	lr
    d610:	f04f 0000 	mov.w	r0, #0
    d614:	4770      	bx	lr
    d616:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
    d61a:	d105      	bne.n	d628 <__aeabi_d2iz+0x48>
    d61c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
    d620:	bf08      	it	eq
    d622:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
    d626:	4770      	bx	lr
    d628:	f04f 0000 	mov.w	r0, #0
    d62c:	4770      	bx	lr
    d62e:	bf00      	nop

0000d630 <__aeabi_d2f>:
    d630:	ea4f 0241 	mov.w	r2, r1, lsl #1
    d634:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
    d638:	bf24      	itt	cs
    d63a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
    d63e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
    d642:	d90d      	bls.n	d660 <__aeabi_d2f+0x30>
    d644:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
    d648:	ea4f 02c0 	mov.w	r2, r0, lsl #3
    d64c:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
    d650:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    d654:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
    d658:	bf08      	it	eq
    d65a:	f020 0001 	biceq.w	r0, r0, #1
    d65e:	4770      	bx	lr
    d660:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
    d664:	d121      	bne.n	d6aa <__aeabi_d2f+0x7a>
    d666:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
    d66a:	bfbc      	itt	lt
    d66c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
    d670:	4770      	bxlt	lr
    d672:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
    d676:	ea4f 5252 	mov.w	r2, r2, lsr #21
    d67a:	f1c2 0218 	rsb	r2, r2, #24
    d67e:	f1c2 0c20 	rsb	ip, r2, #32
    d682:	fa10 f30c 	lsls.w	r3, r0, ip
    d686:	fa20 f002 	lsr.w	r0, r0, r2
    d68a:	bf18      	it	ne
    d68c:	f040 0001 	orrne.w	r0, r0, #1
    d690:	ea4f 23c1 	mov.w	r3, r1, lsl #11
    d694:	ea4f 23d3 	mov.w	r3, r3, lsr #11
    d698:	fa03 fc0c 	lsl.w	ip, r3, ip
    d69c:	ea40 000c 	orr.w	r0, r0, ip
    d6a0:	fa23 f302 	lsr.w	r3, r3, r2
    d6a4:	ea4f 0343 	mov.w	r3, r3, lsl #1
    d6a8:	e7cc      	b.n	d644 <__aeabi_d2f+0x14>
    d6aa:	ea7f 5362 	mvns.w	r3, r2, asr #21
    d6ae:	d107      	bne.n	d6c0 <__aeabi_d2f+0x90>
    d6b0:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
    d6b4:	bf1e      	ittt	ne
    d6b6:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
    d6ba:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
    d6be:	4770      	bxne	lr
    d6c0:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
    d6c4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
    d6c8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
    d6cc:	4770      	bx	lr
    d6ce:	bf00      	nop

0000d6d0 <__aeabi_ldivmod>:
    d6d0:	b97b      	cbnz	r3, d6f2 <__aeabi_ldivmod+0x22>
    d6d2:	b972      	cbnz	r2, d6f2 <__aeabi_ldivmod+0x22>
    d6d4:	2900      	cmp	r1, #0
    d6d6:	bfbe      	ittt	lt
    d6d8:	2000      	movlt	r0, #0
    d6da:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
    d6de:	e006      	blt.n	d6ee <__aeabi_ldivmod+0x1e>
    d6e0:	bf08      	it	eq
    d6e2:	2800      	cmpeq	r0, #0
    d6e4:	bf1c      	itt	ne
    d6e6:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
    d6ea:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    d6ee:	f000 b9bb 	b.w	da68 <__aeabi_idiv0>
    d6f2:	f1ad 0c08 	sub.w	ip, sp, #8
    d6f6:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    d6fa:	2900      	cmp	r1, #0
    d6fc:	db09      	blt.n	d712 <__aeabi_ldivmod+0x42>
    d6fe:	2b00      	cmp	r3, #0
    d700:	db1a      	blt.n	d738 <__aeabi_ldivmod+0x68>
    d702:	f000 f84d 	bl	d7a0 <__udivmoddi4>
    d706:	f8dd e004 	ldr.w	lr, [sp, #4]
    d70a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d70e:	b004      	add	sp, #16
    d710:	4770      	bx	lr
    d712:	4240      	negs	r0, r0
    d714:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d718:	2b00      	cmp	r3, #0
    d71a:	db1b      	blt.n	d754 <__aeabi_ldivmod+0x84>
    d71c:	f000 f840 	bl	d7a0 <__udivmoddi4>
    d720:	f8dd e004 	ldr.w	lr, [sp, #4]
    d724:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d728:	b004      	add	sp, #16
    d72a:	4240      	negs	r0, r0
    d72c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d730:	4252      	negs	r2, r2
    d732:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d736:	4770      	bx	lr
    d738:	4252      	negs	r2, r2
    d73a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d73e:	f000 f82f 	bl	d7a0 <__udivmoddi4>
    d742:	f8dd e004 	ldr.w	lr, [sp, #4]
    d746:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d74a:	b004      	add	sp, #16
    d74c:	4240      	negs	r0, r0
    d74e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
    d752:	4770      	bx	lr
    d754:	4252      	negs	r2, r2
    d756:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d75a:	f000 f821 	bl	d7a0 <__udivmoddi4>
    d75e:	f8dd e004 	ldr.w	lr, [sp, #4]
    d762:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d766:	b004      	add	sp, #16
    d768:	4252      	negs	r2, r2
    d76a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
    d76e:	4770      	bx	lr

0000d770 <__aeabi_uldivmod>:
    d770:	b953      	cbnz	r3, d788 <__aeabi_uldivmod+0x18>
    d772:	b94a      	cbnz	r2, d788 <__aeabi_uldivmod+0x18>
    d774:	2900      	cmp	r1, #0
    d776:	bf08      	it	eq
    d778:	2800      	cmpeq	r0, #0
    d77a:	bf1c      	itt	ne
    d77c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
    d780:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    d784:	f000 b970 	b.w	da68 <__aeabi_idiv0>
    d788:	f1ad 0c08 	sub.w	ip, sp, #8
    d78c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    d790:	f000 f806 	bl	d7a0 <__udivmoddi4>
    d794:	f8dd e004 	ldr.w	lr, [sp, #4]
    d798:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    d79c:	b004      	add	sp, #16
    d79e:	4770      	bx	lr

0000d7a0 <__udivmoddi4>:
    d7a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d7a4:	9e09      	ldr	r6, [sp, #36]	; 0x24
    d7a6:	4604      	mov	r4, r0
    d7a8:	4689      	mov	r9, r1
    d7aa:	2b00      	cmp	r3, #0
    d7ac:	f040 8083 	bne.w	d8b6 <__udivmoddi4+0x116>
    d7b0:	428a      	cmp	r2, r1
    d7b2:	4615      	mov	r5, r2
    d7b4:	d945      	bls.n	d842 <__udivmoddi4+0xa2>
    d7b6:	fab2 f282 	clz	r2, r2
    d7ba:	b14a      	cbz	r2, d7d0 <__udivmoddi4+0x30>
    d7bc:	f1c2 0720 	rsb	r7, r2, #32
    d7c0:	fa01 f302 	lsl.w	r3, r1, r2
    d7c4:	4095      	lsls	r5, r2
    d7c6:	4094      	lsls	r4, r2
    d7c8:	fa20 f707 	lsr.w	r7, r0, r7
    d7cc:	ea47 0903 	orr.w	r9, r7, r3
    d7d0:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d7d4:	0c23      	lsrs	r3, r4, #16
    d7d6:	fa1f f885 	uxth.w	r8, r5
    d7da:	fbb9 fcfe 	udiv	ip, r9, lr
    d7de:	fb0e 991c 	mls	r9, lr, ip, r9
    d7e2:	fb0c f108 	mul.w	r1, ip, r8
    d7e6:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
    d7ea:	4299      	cmp	r1, r3
    d7ec:	d90a      	bls.n	d804 <__udivmoddi4+0x64>
    d7ee:	18eb      	adds	r3, r5, r3
    d7f0:	bf2c      	ite	cs
    d7f2:	2001      	movcs	r0, #1
    d7f4:	2000      	movcc	r0, #0
    d7f6:	4299      	cmp	r1, r3
    d7f8:	d902      	bls.n	d800 <__udivmoddi4+0x60>
    d7fa:	2800      	cmp	r0, #0
    d7fc:	f000 811d 	beq.w	da3a <__udivmoddi4+0x29a>
    d800:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    d804:	1a59      	subs	r1, r3, r1
    d806:	b2a3      	uxth	r3, r4
    d808:	fbb1 f0fe 	udiv	r0, r1, lr
    d80c:	fb0e 1110 	mls	r1, lr, r0, r1
    d810:	fb00 f808 	mul.w	r8, r0, r8
    d814:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    d818:	45a0      	cmp	r8, r4
    d81a:	d905      	bls.n	d828 <__udivmoddi4+0x88>
    d81c:	192c      	adds	r4, r5, r4
    d81e:	d202      	bcs.n	d826 <__udivmoddi4+0x86>
    d820:	45a0      	cmp	r8, r4
    d822:	f200 810e 	bhi.w	da42 <__udivmoddi4+0x2a2>
    d826:	3801      	subs	r0, #1
    d828:	eba4 0408 	sub.w	r4, r4, r8
    d82c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    d830:	2700      	movs	r7, #0
    d832:	b11e      	cbz	r6, d83c <__udivmoddi4+0x9c>
    d834:	40d4      	lsrs	r4, r2
    d836:	2300      	movs	r3, #0
    d838:	e9c6 4300 	strd	r4, r3, [r6]
    d83c:	4639      	mov	r1, r7
    d83e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d842:	2a00      	cmp	r2, #0
    d844:	d051      	beq.n	d8ea <__udivmoddi4+0x14a>
    d846:	fab2 f282 	clz	r2, r2
    d84a:	2a00      	cmp	r2, #0
    d84c:	f040 80af 	bne.w	d9ae <__udivmoddi4+0x20e>
    d850:	1b49      	subs	r1, r1, r5
    d852:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d856:	fa1f f885 	uxth.w	r8, r5
    d85a:	2701      	movs	r7, #1
    d85c:	0c23      	lsrs	r3, r4, #16
    d85e:	fbb1 fcfe 	udiv	ip, r1, lr
    d862:	fb0e 111c 	mls	r1, lr, ip, r1
    d866:	fb08 f00c 	mul.w	r0, r8, ip
    d86a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    d86e:	4298      	cmp	r0, r3
    d870:	d90a      	bls.n	d888 <__udivmoddi4+0xe8>
    d872:	18eb      	adds	r3, r5, r3
    d874:	bf2c      	ite	cs
    d876:	2101      	movcs	r1, #1
    d878:	2100      	movcc	r1, #0
    d87a:	4298      	cmp	r0, r3
    d87c:	d902      	bls.n	d884 <__udivmoddi4+0xe4>
    d87e:	2900      	cmp	r1, #0
    d880:	f000 80d7 	beq.w	da32 <__udivmoddi4+0x292>
    d884:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
    d888:	1a19      	subs	r1, r3, r0
    d88a:	b2a3      	uxth	r3, r4
    d88c:	fbb1 f0fe 	udiv	r0, r1, lr
    d890:	fb0e 1110 	mls	r1, lr, r0, r1
    d894:	fb08 f800 	mul.w	r8, r8, r0
    d898:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    d89c:	45a0      	cmp	r8, r4
    d89e:	d905      	bls.n	d8ac <__udivmoddi4+0x10c>
    d8a0:	192c      	adds	r4, r5, r4
    d8a2:	d202      	bcs.n	d8aa <__udivmoddi4+0x10a>
    d8a4:	45a0      	cmp	r8, r4
    d8a6:	f200 80c1 	bhi.w	da2c <__udivmoddi4+0x28c>
    d8aa:	3801      	subs	r0, #1
    d8ac:	eba4 0408 	sub.w	r4, r4, r8
    d8b0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    d8b4:	e7bd      	b.n	d832 <__udivmoddi4+0x92>
    d8b6:	428b      	cmp	r3, r1
    d8b8:	d908      	bls.n	d8cc <__udivmoddi4+0x12c>
    d8ba:	2e00      	cmp	r6, #0
    d8bc:	d074      	beq.n	d9a8 <__udivmoddi4+0x208>
    d8be:	2700      	movs	r7, #0
    d8c0:	e9c6 0100 	strd	r0, r1, [r6]
    d8c4:	4638      	mov	r0, r7
    d8c6:	4639      	mov	r1, r7
    d8c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d8cc:	fab3 f783 	clz	r7, r3
    d8d0:	b967      	cbnz	r7, d8ec <__udivmoddi4+0x14c>
    d8d2:	428b      	cmp	r3, r1
    d8d4:	f0c0 80a4 	bcc.w	da20 <__udivmoddi4+0x280>
    d8d8:	4282      	cmp	r2, r0
    d8da:	f240 80a1 	bls.w	da20 <__udivmoddi4+0x280>
    d8de:	4638      	mov	r0, r7
    d8e0:	2e00      	cmp	r6, #0
    d8e2:	d0ab      	beq.n	d83c <__udivmoddi4+0x9c>
    d8e4:	e9c6 4900 	strd	r4, r9, [r6]
    d8e8:	e7a8      	b.n	d83c <__udivmoddi4+0x9c>
    d8ea:	deff      	udf	#255	; 0xff
    d8ec:	f1c7 0520 	rsb	r5, r7, #32
    d8f0:	40bb      	lsls	r3, r7
    d8f2:	fa02 fc07 	lsl.w	ip, r2, r7
    d8f6:	fa01 f407 	lsl.w	r4, r1, r7
    d8fa:	40ea      	lsrs	r2, r5
    d8fc:	fa20 f805 	lsr.w	r8, r0, r5
    d900:	40e9      	lsrs	r1, r5
    d902:	fa00 fe07 	lsl.w	lr, r0, r7
    d906:	431a      	orrs	r2, r3
    d908:	ea48 0404 	orr.w	r4, r8, r4
    d90c:	ea4f 4812 	mov.w	r8, r2, lsr #16
    d910:	0c20      	lsrs	r0, r4, #16
    d912:	fa1f f982 	uxth.w	r9, r2
    d916:	fbb1 faf8 	udiv	sl, r1, r8
    d91a:	fb08 111a 	mls	r1, r8, sl, r1
    d91e:	fb0a fb09 	mul.w	fp, sl, r9
    d922:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
    d926:	458b      	cmp	fp, r1
    d928:	d90a      	bls.n	d940 <__udivmoddi4+0x1a0>
    d92a:	1851      	adds	r1, r2, r1
    d92c:	bf2c      	ite	cs
    d92e:	2301      	movcs	r3, #1
    d930:	2300      	movcc	r3, #0
    d932:	458b      	cmp	fp, r1
    d934:	d902      	bls.n	d93c <__udivmoddi4+0x19c>
    d936:	2b00      	cmp	r3, #0
    d938:	f000 8088 	beq.w	da4c <__udivmoddi4+0x2ac>
    d93c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
    d940:	eba1 010b 	sub.w	r1, r1, fp
    d944:	b2a4      	uxth	r4, r4
    d946:	fbb1 f0f8 	udiv	r0, r1, r8
    d94a:	fb08 1110 	mls	r1, r8, r0, r1
    d94e:	fb00 f909 	mul.w	r9, r0, r9
    d952:	ea44 4101 	orr.w	r1, r4, r1, lsl #16
    d956:	4589      	cmp	r9, r1
    d958:	d904      	bls.n	d964 <__udivmoddi4+0x1c4>
    d95a:	1851      	adds	r1, r2, r1
    d95c:	d201      	bcs.n	d962 <__udivmoddi4+0x1c2>
    d95e:	4589      	cmp	r9, r1
    d960:	d87b      	bhi.n	da5a <__udivmoddi4+0x2ba>
    d962:	3801      	subs	r0, #1
    d964:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    d968:	eba1 0109 	sub.w	r1, r1, r9
    d96c:	fba0 890c 	umull	r8, r9, r0, ip
    d970:	4549      	cmp	r1, r9
    d972:	4644      	mov	r4, r8
    d974:	464b      	mov	r3, r9
    d976:	d302      	bcc.n	d97e <__udivmoddi4+0x1de>
    d978:	d106      	bne.n	d988 <__udivmoddi4+0x1e8>
    d97a:	45c6      	cmp	lr, r8
    d97c:	d204      	bcs.n	d988 <__udivmoddi4+0x1e8>
    d97e:	3801      	subs	r0, #1
    d980:	ebb8 040c 	subs.w	r4, r8, ip
    d984:	eb69 0302 	sbc.w	r3, r9, r2
    d988:	2e00      	cmp	r6, #0
    d98a:	d05d      	beq.n	da48 <__udivmoddi4+0x2a8>
    d98c:	ebbe 0204 	subs.w	r2, lr, r4
    d990:	eb61 0103 	sbc.w	r1, r1, r3
    d994:	fa01 f505 	lsl.w	r5, r1, r5
    d998:	fa22 f307 	lsr.w	r3, r2, r7
    d99c:	40f9      	lsrs	r1, r7
    d99e:	2700      	movs	r7, #0
    d9a0:	431d      	orrs	r5, r3
    d9a2:	e9c6 5100 	strd	r5, r1, [r6]
    d9a6:	e749      	b.n	d83c <__udivmoddi4+0x9c>
    d9a8:	4637      	mov	r7, r6
    d9aa:	4630      	mov	r0, r6
    d9ac:	e746      	b.n	d83c <__udivmoddi4+0x9c>
    d9ae:	f1c2 0020 	rsb	r0, r2, #32
    d9b2:	4095      	lsls	r5, r2
    d9b4:	fa01 f702 	lsl.w	r7, r1, r2
    d9b8:	fa21 f300 	lsr.w	r3, r1, r0
    d9bc:	ea4f 4e15 	mov.w	lr, r5, lsr #16
    d9c0:	fa24 f100 	lsr.w	r1, r4, r0
    d9c4:	fa1f f885 	uxth.w	r8, r5
    d9c8:	4094      	lsls	r4, r2
    d9ca:	4339      	orrs	r1, r7
    d9cc:	fbb3 f0fe 	udiv	r0, r3, lr
    d9d0:	0c0f      	lsrs	r7, r1, #16
    d9d2:	fb0e 3310 	mls	r3, lr, r0, r3
    d9d6:	fb00 fc08 	mul.w	ip, r0, r8
    d9da:	ea47 4303 	orr.w	r3, r7, r3, lsl #16
    d9de:	459c      	cmp	ip, r3
    d9e0:	d907      	bls.n	d9f2 <__udivmoddi4+0x252>
    d9e2:	18eb      	adds	r3, r5, r3
    d9e4:	bf2c      	ite	cs
    d9e6:	2701      	movcs	r7, #1
    d9e8:	2700      	movcc	r7, #0
    d9ea:	459c      	cmp	ip, r3
    d9ec:	d900      	bls.n	d9f0 <__udivmoddi4+0x250>
    d9ee:	b38f      	cbz	r7, da54 <__udivmoddi4+0x2b4>
    d9f0:	3801      	subs	r0, #1
    d9f2:	eba3 030c 	sub.w	r3, r3, ip
    d9f6:	b289      	uxth	r1, r1
    d9f8:	fbb3 f7fe 	udiv	r7, r3, lr
    d9fc:	fb0e 3317 	mls	r3, lr, r7, r3
    da00:	fb07 fc08 	mul.w	ip, r7, r8
    da04:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
    da08:	458c      	cmp	ip, r1
    da0a:	d904      	bls.n	da16 <__udivmoddi4+0x276>
    da0c:	1869      	adds	r1, r5, r1
    da0e:	d201      	bcs.n	da14 <__udivmoddi4+0x274>
    da10:	458c      	cmp	ip, r1
    da12:	d825      	bhi.n	da60 <__udivmoddi4+0x2c0>
    da14:	3f01      	subs	r7, #1
    da16:	eba1 010c 	sub.w	r1, r1, ip
    da1a:	ea47 4700 	orr.w	r7, r7, r0, lsl #16
    da1e:	e71d      	b.n	d85c <__udivmoddi4+0xbc>
    da20:	1a84      	subs	r4, r0, r2
    da22:	eb61 0303 	sbc.w	r3, r1, r3
    da26:	2001      	movs	r0, #1
    da28:	4699      	mov	r9, r3
    da2a:	e759      	b.n	d8e0 <__udivmoddi4+0x140>
    da2c:	3802      	subs	r0, #2
    da2e:	442c      	add	r4, r5
    da30:	e73c      	b.n	d8ac <__udivmoddi4+0x10c>
    da32:	f1ac 0c02 	sub.w	ip, ip, #2
    da36:	442b      	add	r3, r5
    da38:	e726      	b.n	d888 <__udivmoddi4+0xe8>
    da3a:	f1ac 0c02 	sub.w	ip, ip, #2
    da3e:	442b      	add	r3, r5
    da40:	e6e0      	b.n	d804 <__udivmoddi4+0x64>
    da42:	3802      	subs	r0, #2
    da44:	442c      	add	r4, r5
    da46:	e6ef      	b.n	d828 <__udivmoddi4+0x88>
    da48:	4637      	mov	r7, r6
    da4a:	e6f7      	b.n	d83c <__udivmoddi4+0x9c>
    da4c:	f1aa 0a02 	sub.w	sl, sl, #2
    da50:	4411      	add	r1, r2
    da52:	e775      	b.n	d940 <__udivmoddi4+0x1a0>
    da54:	3802      	subs	r0, #2
    da56:	442b      	add	r3, r5
    da58:	e7cb      	b.n	d9f2 <__udivmoddi4+0x252>
    da5a:	3802      	subs	r0, #2
    da5c:	4411      	add	r1, r2
    da5e:	e781      	b.n	d964 <__udivmoddi4+0x1c4>
    da60:	3f02      	subs	r7, #2
    da62:	4429      	add	r1, r5
    da64:	e7d7      	b.n	da16 <__udivmoddi4+0x276>
    da66:	bf00      	nop

0000da68 <__aeabi_idiv0>:
    da68:	4770      	bx	lr
    da6a:	bf00      	nop

0000da6c <bsec_get_version>:
    da6c:	b508      	push	{r3, lr}
    da6e:	4601      	mov	r1, r0
    da70:	4802      	ldr	r0, [pc, #8]	; (da7c <bsec_get_version+0x10>)
    da72:	f000 fa7b 	bl	df6c <bsec_codegen_get_version>
    da76:	2000      	movs	r0, #0
    da78:	bd08      	pop	{r3, pc}
    da7a:	bf00      	nop
    da7c:	20020a10 	.word	0x20020a10

0000da80 <bsec_init>:
    da80:	b508      	push	{r3, lr}
    da82:	4802      	ldr	r0, [pc, #8]	; (da8c <bsec_init+0xc>)
    da84:	f000 fa7a 	bl	df7c <bsec_codegen_init>
    da88:	2000      	movs	r0, #0
    da8a:	bd08      	pop	{r3, pc}
    da8c:	20020a10 	.word	0x20020a10

0000da90 <bsec_reset_output>:
    da90:	4601      	mov	r1, r0
    da92:	4801      	ldr	r0, [pc, #4]	; (da98 <bsec_reset_output+0x8>)
    da94:	f000 ba74 	b.w	df80 <bsec_codegen_reset_output>
    da98:	20020a10 	.word	0x20020a10

0000da9c <bsec_update_subscription>:
    da9c:	b510      	push	{r4, lr}
    da9e:	b084      	sub	sp, #16
    daa0:	f10d 040f 	add.w	r4, sp, #15
    daa4:	e9cd 4200 	strd	r4, r2, [sp]
    daa8:	460a      	mov	r2, r1
    daaa:	4601      	mov	r1, r0
    daac:	4803      	ldr	r0, [pc, #12]	; (dabc <bsec_update_subscription+0x20>)
    daae:	f7fe fd83 	bl	c5b8 <bsec_codegen_update_subscription>
    dab2:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    dab6:	b004      	add	sp, #16
    dab8:	bd10      	pop	{r4, pc}
    daba:	bf00      	nop
    dabc:	20020a10 	.word	0x20020a10

0000dac0 <bsec_do_steps>:
    dac0:	b510      	push	{r4, lr}
    dac2:	b084      	sub	sp, #16
    dac4:	f10d 040f 	add.w	r4, sp, #15
    dac8:	e9cd 4200 	strd	r4, r2, [sp]
    dacc:	460a      	mov	r2, r1
    dace:	4601      	mov	r1, r0
    dad0:	4803      	ldr	r0, [pc, #12]	; (dae0 <bsec_do_steps+0x20>)
    dad2:	f000 f869 	bl	dba8 <bsec_codegen_do_steps>
    dad6:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    dada:	b004      	add	sp, #16
    dadc:	bd10      	pop	{r4, pc}
    dade:	bf00      	nop
    dae0:	20020a10 	.word	0x20020a10

0000dae4 <bsec_set_configuration>:
    dae4:	b500      	push	{lr}
    dae6:	b083      	sub	sp, #12
    dae8:	9300      	str	r3, [sp, #0]
    daea:	4613      	mov	r3, r2
    daec:	460a      	mov	r2, r1
    daee:	4601      	mov	r1, r0
    daf0:	4802      	ldr	r0, [pc, #8]	; (dafc <bsec_set_configuration+0x18>)
    daf2:	f000 fa5f 	bl	dfb4 <bsec_codegen_set_configuration>
    daf6:	b003      	add	sp, #12
    daf8:	f85d fb04 	ldr.w	pc, [sp], #4
    dafc:	20020a10 	.word	0x20020a10

0000db00 <bsec_set_state>:
    db00:	b500      	push	{lr}
    db02:	b083      	sub	sp, #12
    db04:	9300      	str	r3, [sp, #0]
    db06:	4613      	mov	r3, r2
    db08:	460a      	mov	r2, r1
    db0a:	4601      	mov	r1, r0
    db0c:	4802      	ldr	r0, [pc, #8]	; (db18 <bsec_set_state+0x18>)
    db0e:	f000 fa9f 	bl	e050 <bsec_codegen_set_state>
    db12:	b003      	add	sp, #12
    db14:	f85d fb04 	ldr.w	pc, [sp], #4
    db18:	20020a10 	.word	0x20020a10

0000db1c <bsec_get_configuration>:
    db1c:	b570      	push	{r4, r5, r6, lr}
    db1e:	b086      	sub	sp, #24
    db20:	f10d 0413 	add.w	r4, sp, #19
    db24:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    db26:	9300      	str	r3, [sp, #0]
    db28:	ad05      	add	r5, sp, #20
    db2a:	4613      	mov	r3, r2
    db2c:	9402      	str	r4, [sp, #8]
    db2e:	460a      	mov	r2, r1
    db30:	9601      	str	r6, [sp, #4]
    db32:	4601      	mov	r1, r0
    db34:	9503      	str	r5, [sp, #12]
    db36:	4805      	ldr	r0, [pc, #20]	; (db4c <bsec_get_configuration+0x30>)
    db38:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    db3a:	f000 f95d 	bl	ddf8 <bsec_codegen_get_configuration>
    db3e:	9b05      	ldr	r3, [sp, #20]
    db40:	f99d 0013 	ldrsb.w	r0, [sp, #19]
    db44:	6023      	str	r3, [r4, #0]
    db46:	b006      	add	sp, #24
    db48:	bd70      	pop	{r4, r5, r6, pc}
    db4a:	bf00      	nop
    db4c:	20020a10 	.word	0x20020a10

0000db50 <bsec_get_state>:
    db50:	b570      	push	{r4, r5, r6, lr}
    db52:	b086      	sub	sp, #24
    db54:	f10d 0413 	add.w	r4, sp, #19
    db58:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    db5a:	9300      	str	r3, [sp, #0]
    db5c:	ad05      	add	r5, sp, #20
    db5e:	4613      	mov	r3, r2
    db60:	9402      	str	r4, [sp, #8]
    db62:	460a      	mov	r2, r1
    db64:	9601      	str	r6, [sp, #4]
    db66:	4601      	mov	r1, r0
    db68:	9503      	str	r5, [sp, #12]
    db6a:	4805      	ldr	r0, [pc, #20]	; (db80 <bsec_get_state+0x30>)
    db6c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    db6e:	f000 f9a1 	bl	deb4 <bsec_codegen_get_state>
    db72:	9b05      	ldr	r3, [sp, #20]
    db74:	f99d 0013 	ldrsb.w	r0, [sp, #19]
    db78:	6023      	str	r3, [r4, #0]
    db7a:	b006      	add	sp, #24
    db7c:	bd70      	pop	{r4, r5, r6, pc}
    db7e:	bf00      	nop
    db80:	20020a10 	.word	0x20020a10

0000db84 <bsec_sensor_control>:
    db84:	b500      	push	{lr}
    db86:	b085      	sub	sp, #20
    db88:	f10d 030f 	add.w	r3, sp, #15
    db8c:	e9cd 3200 	strd	r3, r2, [sp]
    db90:	4602      	mov	r2, r0
    db92:	460b      	mov	r3, r1
    db94:	4803      	ldr	r0, [pc, #12]	; (dba4 <bsec_sensor_control+0x20>)
    db96:	f7fe fb53 	bl	c240 <bsec_codegen_sensor_control>
    db9a:	f99d 000f 	ldrsb.w	r0, [sp, #15]
    db9e:	b005      	add	sp, #20
    dba0:	f85d fb04 	ldr.w	pc, [sp], #4
    dba4:	20020a10 	.word	0x20020a10

0000dba8 <bsec_codegen_do_steps>:
    dba8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dbac:	b089      	sub	sp, #36	; 0x24
    dbae:	461e      	mov	r6, r3
    dbb0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    dbb2:	f04f 0c00 	mov.w	ip, #0
    dbb6:	f883 c000 	strb.w	ip, [r3]
    dbba:	7835      	ldrb	r5, [r6, #0]
    dbbc:	4604      	mov	r4, r0
    dbbe:	460b      	mov	r3, r1
    dbc0:	b1dd      	cbz	r5, dbfa <bsec_codegen_do_steps+0x52>
    dbc2:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
    dbc6:	f04f 0800 	mov.w	r8, #0
    dbca:	2701      	movs	r7, #1
    dbcc:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
    dbd0:	2000      	movs	r0, #0
    dbd2:	2100      	movs	r1, #0
    dbd4:	eb07 050e 	add.w	r5, r7, lr
    dbd8:	eb09 1505 	add.w	r5, r9, r5, lsl #4
    dbdc:	e9c5 0100 	strd	r0, r1, [r5]
    dbe0:	f885 c00d 	strb.w	ip, [r5, #13]
    dbe4:	f8c5 8008 	str.w	r8, [r5, #8]
    dbe8:	f885 c00c 	strb.w	ip, [r5, #12]
    dbec:	f885 c00e 	strb.w	ip, [r5, #14]
    dbf0:	3701      	adds	r7, #1
    dbf2:	7835      	ldrb	r5, [r6, #0]
    dbf4:	b2ff      	uxtb	r7, r7
    dbf6:	42bd      	cmp	r5, r7
    dbf8:	d2ec      	bcs.n	dbd4 <bsec_codegen_do_steps+0x2c>
    dbfa:	2a00      	cmp	r2, #0
    dbfc:	d075      	beq.n	dcea <bsec_codegen_do_steps+0x142>
    dbfe:	7b59      	ldrb	r1, [r3, #13]
    dc00:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
    dc04:	fa5f f58a 	uxtb.w	r5, sl
    dc08:	2d17      	cmp	r5, #23
    dc0a:	f200 809f 	bhi.w	dd4c <bsec_codegen_do_steps+0x1a4>
    dc0e:	4f76      	ldr	r7, [pc, #472]	; (dde8 <bsec_codegen_do_steps+0x240>)
    dc10:	fa47 f005 	asr.w	r0, r7, r5
    dc14:	07c0      	lsls	r0, r0, #31
    dc16:	f140 8099 	bpl.w	dd4c <bsec_codegen_do_steps+0x1a4>
    dc1a:	f04f 0a01 	mov.w	sl, #1
    dc1e:	4650      	mov	r0, sl
    dc20:	46bc      	mov	ip, r7
    dc22:	fa0a fa05 	lsl.w	sl, sl, r5
    dc26:	4686      	mov	lr, r0
    dc28:	4689      	mov	r9, r1
    dc2a:	461d      	mov	r5, r3
    dc2c:	2700      	movs	r7, #0
    dc2e:	9103      	str	r1, [sp, #12]
    dc30:	e013      	b.n	dc5a <bsec_codegen_do_steps+0xb2>
    dc32:	f895 900d 	ldrb.w	r9, [r5, #13]
    dc36:	f109 38ff 	add.w	r8, r9, #4294967295	; 0xffffffff
    dc3a:	fa5f f888 	uxtb.w	r8, r8
    dc3e:	f1b8 0f17 	cmp.w	r8, #23
    dc42:	fa4c fb08 	asr.w	fp, ip, r8
    dc46:	fa0e fa08 	lsl.w	sl, lr, r8
    dc4a:	d87f      	bhi.n	dd4c <bsec_codegen_do_steps+0x1a4>
    dc4c:	f01b 0f01 	tst.w	fp, #1
    dc50:	d07c      	beq.n	dd4c <bsec_codegen_do_steps+0x1a4>
    dc52:	ea1a 0f07 	tst.w	sl, r7
    dc56:	f040 80b6 	bne.w	ddc6 <bsec_codegen_do_steps+0x21e>
    dc5a:	4964      	ldr	r1, [pc, #400]	; (ddec <bsec_codegen_do_steps+0x244>)
    dc5c:	edd5 7a02 	vldr	s15, [r5, #8]
    dc60:	4489      	add	r9, r1
    dc62:	3001      	adds	r0, #1
    dc64:	f819 8c01 	ldrb.w	r8, [r9, #-1]
    dc68:	eb04 0b88 	add.w	fp, r4, r8, lsl #2
    dc6c:	ed9b 7ac1 	vldr	s14, [fp, #772]	; 0x304
    dc70:	b2c0      	uxtb	r0, r0
    dc72:	eef4 7ac7 	vcmpe.f32	s15, s14
    dc76:	f108 092e 	add.w	r9, r8, #46	; 0x2e
    dc7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    dc7e:	f100 5880 	add.w	r8, r0, #268435456	; 0x10000000
    dc82:	eb04 09c9 	add.w	r9, r4, r9, lsl #3
    dc86:	ea47 070a 	orr.w	r7, r7, sl
    dc8a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    dc8e:	f100 8094 	bmi.w	ddba <bsec_codegen_do_steps+0x212>
    dc92:	ed9b 7ac9 	vldr	s14, [fp, #804]	; 0x324
    dc96:	eef4 7ac7 	vcmpe.f32	s15, s14
    dc9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    dc9e:	f300 808c 	bgt.w	ddba <bsec_codegen_do_steps+0x212>
    dca2:	e9d5 ab00 	ldrd	sl, fp, [r5]
    dca6:	eb03 1508 	add.w	r5, r3, r8, lsl #4
    dcaa:	e9d9 8900 	ldrd	r8, r9, [r9]
    dcae:	45cb      	cmp	fp, r9
    dcb0:	bf08      	it	eq
    dcb2:	45c2      	cmpeq	sl, r8
    dcb4:	d104      	bne.n	dcc0 <bsec_codegen_do_steps+0x118>
    dcb6:	9912      	ldr	r1, [sp, #72]	; 0x48
    dcb8:	f04f 0804 	mov.w	r8, #4
    dcbc:	f881 8000 	strb.w	r8, [r1]
    dcc0:	4282      	cmp	r2, r0
    dcc2:	d2b6      	bcs.n	dc32 <bsec_codegen_do_steps+0x8a>
    dcc4:	3a01      	subs	r2, #1
    dcc6:	b2d2      	uxtb	r2, r2
    dcc8:	f103 0710 	add.w	r7, r3, #16
    dccc:	9903      	ldr	r1, [sp, #12]
    dcce:	461d      	mov	r5, r3
    dcd0:	eb07 1702 	add.w	r7, r7, r2, lsl #4
    dcd4:	e000      	b.n	dcd8 <bsec_codegen_do_steps+0x130>
    dcd6:	7b69      	ldrb	r1, [r5, #13]
    dcd8:	ed95 0a02 	vldr	s0, [r5, #8]
    dcdc:	e8f5 2304 	ldrd	r2, r3, [r5], #16
    dce0:	4620      	mov	r0, r4
    dce2:	f001 fd9d 	bl	f820 <bsec_ChannelHub_setInput>
    dce6:	42bd      	cmp	r5, r7
    dce8:	d1f5      	bne.n	dcd6 <bsec_codegen_do_steps+0x12e>
    dcea:	4620      	mov	r0, r4
    dcec:	f001 f8a2 	bl	ee34 <bsec_ChannelHub_do>
    dcf0:	f896 9000 	ldrb.w	r9, [r6]
    dcf4:	f1b9 0f00 	cmp.w	r9, #0
    dcf8:	d06b      	beq.n	ddd2 <bsec_codegen_do_steps+0x22a>
    dcfa:	2300      	movs	r3, #0
    dcfc:	f8df 80f0 	ldr.w	r8, [pc, #240]	; ddf0 <bsec_codegen_do_steps+0x248>
    dd00:	f8df b0f0 	ldr.w	fp, [pc, #240]	; ddf4 <bsec_codegen_do_steps+0x24c>
    dd04:	4699      	mov	r9, r3
    dd06:	f64f 7aff 	movw	sl, #65535	; 0xffff
    dd0a:	fa48 f203 	asr.w	r2, r8, r3
    dd0e:	1c5d      	adds	r5, r3, #1
    dd10:	07d2      	lsls	r2, r2, #31
    dd12:	b2ef      	uxtb	r7, r5
    dd14:	d50c      	bpl.n	dd30 <bsec_codegen_do_steps+0x188>
    dd16:	f813 300b 	ldrb.w	r3, [r3, fp]
    dd1a:	f203 135b 	addw	r3, r3, #347	; 0x15b
    dd1e:	4639      	mov	r1, r7
    dd20:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
    dd24:	4553      	cmp	r3, sl
    dd26:	4620      	mov	r0, r4
    dd28:	d002      	beq.n	dd30 <bsec_codegen_do_steps+0x188>
    dd2a:	f001 fc9d 	bl	f668 <bsec_ChannelHub_isOutputValid>
    dd2e:	b9b8      	cbnz	r0, dd60 <bsec_codegen_do_steps+0x1b8>
    dd30:	2d15      	cmp	r5, #21
    dd32:	462b      	mov	r3, r5
    dd34:	d1e9      	bne.n	dd0a <bsec_codegen_do_steps+0x162>
    dd36:	2300      	movs	r3, #0
    dd38:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    dd3c:	4620      	mov	r0, r4
    dd3e:	f000 fa77 	bl	e230 <bsec_Bsec_applyUpdateSubscription>
    dd42:	f886 9000 	strb.w	r9, [r6]
    dd46:	b009      	add	sp, #36	; 0x24
    dd48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd4c:	9a12      	ldr	r2, [sp, #72]	; 0x48
    dd4e:	23ff      	movs	r3, #255	; 0xff
    dd50:	7013      	strb	r3, [r2, #0]
    dd52:	f04f 0900 	mov.w	r9, #0
    dd56:	f886 9000 	strb.w	r9, [r6]
    dd5a:	b009      	add	sp, #36	; 0x24
    dd5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dd60:	f10d 0313 	add.w	r3, sp, #19
    dd64:	9300      	str	r3, [sp, #0]
    dd66:	aa05      	add	r2, sp, #20
    dd68:	ab06      	add	r3, sp, #24
    dd6a:	4639      	mov	r1, r7
    dd6c:	4620      	mov	r0, r4
    dd6e:	f001 fc57 	bl	f620 <bsec_ChannelHub_getOutput>
    dd72:	7833      	ldrb	r3, [r6, #0]
    dd74:	454b      	cmp	r3, r9
    dd76:	f109 0201 	add.w	r2, r9, #1
    dd7a:	d809      	bhi.n	dd90 <bsec_codegen_do_steps+0x1e8>
    dd7c:	9a12      	ldr	r2, [sp, #72]	; 0x48
    dd7e:	2303      	movs	r3, #3
    dd80:	7013      	strb	r3, [r2, #0]
    dd82:	2300      	movs	r3, #0
    dd84:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    dd88:	4620      	mov	r0, r4
    dd8a:	f000 fa51 	bl	e230 <bsec_Bsec_applyUpdateSubscription>
    dd8e:	e7d8      	b.n	dd42 <bsec_codegen_do_steps+0x19a>
    dd90:	fa5f f982 	uxtb.w	r9, r2
    dd94:	9813      	ldr	r0, [sp, #76]	; 0x4c
    dd96:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
    dd9a:	f109 5180 	add.w	r1, r9, #268435456	; 0x10000000
    dd9e:	3901      	subs	r1, #1
    dda0:	eb00 1101 	add.w	r1, r0, r1, lsl #4
    dda4:	e9c1 2300 	strd	r2, r3, [r1]
    dda8:	9805      	ldr	r0, [sp, #20]
    ddaa:	f89d 3013 	ldrb.w	r3, [sp, #19]
    ddae:	734f      	strb	r7, [r1, #13]
    ddb0:	2201      	movs	r2, #1
    ddb2:	6088      	str	r0, [r1, #8]
    ddb4:	730a      	strb	r2, [r1, #12]
    ddb6:	738b      	strb	r3, [r1, #14]
    ddb8:	e7ba      	b.n	dd30 <bsec_codegen_do_steps+0x188>
    ddba:	9a12      	ldr	r2, [sp, #72]	; 0x48
    ddbc:	23fe      	movs	r3, #254	; 0xfe
    ddbe:	7013      	strb	r3, [r2, #0]
    ddc0:	f04f 0900 	mov.w	r9, #0
    ddc4:	e7c7      	b.n	dd56 <bsec_codegen_do_steps+0x1ae>
    ddc6:	9a12      	ldr	r2, [sp, #72]	; 0x48
    ddc8:	23fa      	movs	r3, #250	; 0xfa
    ddca:	7013      	strb	r3, [r2, #0]
    ddcc:	f04f 0900 	mov.w	r9, #0
    ddd0:	e7c1      	b.n	dd56 <bsec_codegen_do_steps+0x1ae>
    ddd2:	9a12      	ldr	r2, [sp, #72]	; 0x48
    ddd4:	2302      	movs	r3, #2
    ddd6:	7013      	strb	r3, [r2, #0]
    ddd8:	2300      	movs	r3, #0
    ddda:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    ddde:	4620      	mov	r0, r4
    dde0:	f000 fa26 	bl	e230 <bsec_Bsec_applyUpdateSubscription>
    dde4:	e7ad      	b.n	dd42 <bsec_codegen_do_steps+0x19a>
    dde6:	bf00      	nop
    dde8:	00e0200f 	.word	0x00e0200f
    ddec:	0003ad80 	.word	0x0003ad80
    ddf0:	001279ef 	.word	0x001279ef
    ddf4:	0003ad68 	.word	0x0003ad68

0000ddf8 <bsec_codegen_get_configuration>:
    ddf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ddfc:	b085      	sub	sp, #20
    ddfe:	e9dd 5710 	ldrd	r5, r7, [sp, #64]	; 0x40
    de02:	24df      	movs	r4, #223	; 0xdf
    de04:	702c      	strb	r4, [r5, #0]
    de06:	2600      	movs	r6, #0
    de08:	2410      	movs	r4, #16
    de0a:	2b17      	cmp	r3, #23
    de0c:	603e      	str	r6, [r7, #0]
    de0e:	9403      	str	r4, [sp, #12]
    de10:	d928      	bls.n	de64 <bsec_codegen_get_configuration+0x6c>
    de12:	bb39      	cbnz	r1, de64 <bsec_codegen_get_configuration+0x6c>
    de14:	461e      	mov	r6, r3
    de16:	4691      	mov	r9, r2
    de18:	4680      	mov	r8, r0
    de1a:	460b      	mov	r3, r1
    de1c:	7029      	strb	r1, [r5, #0]
    de1e:	468b      	mov	fp, r1
    de20:	f240 3a17 	movw	sl, #791	; 0x317
    de24:	e002      	b.n	de2c <bsec_codegen_get_configuration+0x34>
    de26:	2c0a      	cmp	r4, #10
    de28:	4623      	mov	r3, r4
    de2a:	d01e      	beq.n	de6a <bsec_codegen_get_configuration+0x72>
    de2c:	1c5c      	adds	r4, r3, #1
    de2e:	fa4a f303 	asr.w	r3, sl, r3
    de32:	07db      	lsls	r3, r3, #31
    de34:	b2e1      	uxtb	r1, r4
    de36:	d5f6      	bpl.n	de26 <bsec_codegen_get_configuration+0x2e>
    de38:	f8cd b000 	str.w	fp, [sp]
    de3c:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    de40:	4640      	mov	r0, r8
    de42:	f001 fb15 	bl	f470 <bsec_ChannelHub_getChannelConfiguration>
    de46:	2800      	cmp	r0, #0
    de48:	d0ed      	beq.n	de26 <bsec_codegen_get_configuration+0x2e>
    de4a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    de4c:	9301      	str	r3, [sp, #4]
    de4e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    de50:	9300      	str	r3, [sp, #0]
    de52:	aa03      	add	r2, sp, #12
    de54:	4603      	mov	r3, r0
    de56:	4631      	mov	r1, r6
    de58:	4648      	mov	r0, r9
    de5a:	f000 f9c5 	bl	e1e8 <bsec_Bsec_append>
    de5e:	7028      	strb	r0, [r5, #0]
    de60:	2800      	cmp	r0, #0
    de62:	d0e0      	beq.n	de26 <bsec_codegen_get_configuration+0x2e>
    de64:	b005      	add	sp, #20
    de66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    de6a:	f995 3000 	ldrsb.w	r3, [r5]
    de6e:	2b00      	cmp	r3, #0
    de70:	d1f8      	bne.n	de64 <bsec_codegen_get_configuration+0x6c>
    de72:	4640      	mov	r0, r8
    de74:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
    de78:	f000 fb44 	bl	e504 <bsec_Bsec_getHyperConfiguration>
    de7c:	b968      	cbnz	r0, de9a <bsec_codegen_get_configuration+0xa2>
    de7e:	f995 4000 	ldrsb.w	r4, [r5]
    de82:	2c00      	cmp	r4, #0
    de84:	d1ee      	bne.n	de64 <bsec_codegen_get_configuration+0x6c>
    de86:	9b03      	ldr	r3, [sp, #12]
    de88:	603b      	str	r3, [r7, #0]
    de8a:	4648      	mov	r0, r9
    de8c:	4639      	mov	r1, r7
    de8e:	f000 fae3 	bl	e458 <bsec_Bsec_frameSerializedData>
    de92:	702c      	strb	r4, [r5, #0]
    de94:	b005      	add	sp, #20
    de96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    de9a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    de9c:	9301      	str	r3, [sp, #4]
    de9e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    dea0:	9300      	str	r3, [sp, #0]
    dea2:	4631      	mov	r1, r6
    dea4:	4603      	mov	r3, r0
    dea6:	aa03      	add	r2, sp, #12
    dea8:	4648      	mov	r0, r9
    deaa:	f000 f99d 	bl	e1e8 <bsec_Bsec_append>
    deae:	4604      	mov	r4, r0
    deb0:	7028      	strb	r0, [r5, #0]
    deb2:	e7e6      	b.n	de82 <bsec_codegen_get_configuration+0x8a>

0000deb4 <bsec_codegen_get_state>:
    deb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    deb8:	b085      	sub	sp, #20
    deba:	e9dd 5710 	ldrd	r5, r7, [sp, #64]	; 0x40
    debe:	24df      	movs	r4, #223	; 0xdf
    dec0:	702c      	strb	r4, [r5, #0]
    dec2:	2600      	movs	r6, #0
    dec4:	2410      	movs	r4, #16
    dec6:	2b18      	cmp	r3, #24
    dec8:	603e      	str	r6, [r7, #0]
    deca:	9403      	str	r4, [sp, #12]
    decc:	d928      	bls.n	df20 <bsec_codegen_get_state+0x6c>
    dece:	bb39      	cbnz	r1, df20 <bsec_codegen_get_state+0x6c>
    ded0:	461e      	mov	r6, r3
    ded2:	4691      	mov	r9, r2
    ded4:	4680      	mov	r8, r0
    ded6:	460b      	mov	r3, r1
    ded8:	7029      	strb	r1, [r5, #0]
    deda:	468b      	mov	fp, r1
    dedc:	f240 3a17 	movw	sl, #791	; 0x317
    dee0:	e002      	b.n	dee8 <bsec_codegen_get_state+0x34>
    dee2:	2c0a      	cmp	r4, #10
    dee4:	4623      	mov	r3, r4
    dee6:	d01e      	beq.n	df26 <bsec_codegen_get_state+0x72>
    dee8:	1c5c      	adds	r4, r3, #1
    deea:	fa4a f303 	asr.w	r3, sl, r3
    deee:	07db      	lsls	r3, r3, #31
    def0:	b2e1      	uxtb	r1, r4
    def2:	d5f6      	bpl.n	dee2 <bsec_codegen_get_state+0x2e>
    def4:	f8cd b000 	str.w	fp, [sp]
    def8:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
    defc:	4640      	mov	r0, r8
    defe:	f001 fb23 	bl	f548 <bsec_ChannelHub_getChannelState>
    df02:	2800      	cmp	r0, #0
    df04:	d0ed      	beq.n	dee2 <bsec_codegen_get_state+0x2e>
    df06:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    df08:	9301      	str	r3, [sp, #4]
    df0a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    df0c:	9300      	str	r3, [sp, #0]
    df0e:	aa03      	add	r2, sp, #12
    df10:	4603      	mov	r3, r0
    df12:	4631      	mov	r1, r6
    df14:	4648      	mov	r0, r9
    df16:	f000 f967 	bl	e1e8 <bsec_Bsec_append>
    df1a:	7028      	strb	r0, [r5, #0]
    df1c:	2800      	cmp	r0, #0
    df1e:	d0e0      	beq.n	dee2 <bsec_codegen_get_state+0x2e>
    df20:	b005      	add	sp, #20
    df22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    df26:	f995 3000 	ldrsb.w	r3, [r5]
    df2a:	2b00      	cmp	r3, #0
    df2c:	d1f8      	bne.n	df20 <bsec_codegen_get_state+0x6c>
    df2e:	f000 fb63 	bl	e5f8 <bsec_Bsec_getHyperState>
    df32:	b968      	cbnz	r0, df50 <bsec_codegen_get_state+0x9c>
    df34:	f995 4000 	ldrsb.w	r4, [r5]
    df38:	2c00      	cmp	r4, #0
    df3a:	d1f1      	bne.n	df20 <bsec_codegen_get_state+0x6c>
    df3c:	9b03      	ldr	r3, [sp, #12]
    df3e:	603b      	str	r3, [r7, #0]
    df40:	4648      	mov	r0, r9
    df42:	4639      	mov	r1, r7
    df44:	f000 fa88 	bl	e458 <bsec_Bsec_frameSerializedData>
    df48:	702c      	strb	r4, [r5, #0]
    df4a:	b005      	add	sp, #20
    df4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    df50:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    df52:	9301      	str	r3, [sp, #4]
    df54:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    df56:	9300      	str	r3, [sp, #0]
    df58:	4631      	mov	r1, r6
    df5a:	4603      	mov	r3, r0
    df5c:	aa03      	add	r2, sp, #12
    df5e:	4648      	mov	r0, r9
    df60:	f000 f942 	bl	e1e8 <bsec_Bsec_append>
    df64:	4604      	mov	r4, r0
    df66:	7028      	strb	r0, [r5, #0]
    df68:	e7e6      	b.n	df38 <bsec_codegen_get_state+0x84>
    df6a:	bf00      	nop

0000df6c <bsec_codegen_get_version>:
    df6c:	2304      	movs	r3, #4
    df6e:	2001      	movs	r0, #1
    df70:	2207      	movs	r2, #7
    df72:	7008      	strb	r0, [r1, #0]
    df74:	708a      	strb	r2, [r1, #2]
    df76:	704b      	strb	r3, [r1, #1]
    df78:	70cb      	strb	r3, [r1, #3]
    df7a:	4770      	bx	lr

0000df7c <bsec_codegen_init>:
    df7c:	f000 b8b8 	b.w	e0f0 <bsec_constructor_bsec>

0000df80 <bsec_codegen_reset_output>:
    df80:	3901      	subs	r1, #1
    df82:	2903      	cmp	r1, #3
    df84:	d901      	bls.n	df8a <bsec_codegen_reset_output+0xa>
    df86:	2000      	movs	r0, #0
    df88:	4770      	bx	lr
    df8a:	b510      	push	{r4, lr}
    df8c:	4604      	mov	r4, r0
    df8e:	3068      	adds	r0, #104	; 0x68
    df90:	f002 fd90 	bl	10ab4 <bsec_GasHumidityBaselineTracker_setState>
    df94:	4620      	mov	r0, r4
    df96:	2101      	movs	r1, #1
    df98:	f001 fce6 	bl	f968 <bsec_b_ChannelHub_updateChannelInterfaceDependency>
    df9c:	4b04      	ldr	r3, [pc, #16]	; (dfb0 <bsec_codegen_reset_output+0x30>)
    df9e:	6623      	str	r3, [r4, #96]	; 0x60
    dfa0:	4620      	mov	r0, r4
    dfa2:	6663      	str	r3, [r4, #100]	; 0x64
    dfa4:	2102      	movs	r1, #2
    dfa6:	f001 fcdf 	bl	f968 <bsec_b_ChannelHub_updateChannelInterfaceDependency>
    dfaa:	2000      	movs	r0, #0
    dfac:	bd10      	pop	{r4, pc}
    dfae:	bf00      	nop
    dfb0:	41c80000 	.word	0x41c80000

0000dfb4 <bsec_codegen_set_configuration>:
    dfb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dfb8:	b089      	sub	sp, #36	; 0x24
    dfba:	4688      	mov	r8, r1
    dfbc:	4616      	mov	r6, r2
    dfbe:	f10d 0a16 	add.w	sl, sp, #22
    dfc2:	f10d 0918 	add.w	r9, sp, #24
    dfc6:	4607      	mov	r7, r0
    dfc8:	461c      	mov	r4, r3
    dfca:	9a12      	ldr	r2, [sp, #72]	; 0x48
    dfcc:	f8cd 9000 	str.w	r9, [sp]
    dfd0:	4653      	mov	r3, sl
    dfd2:	4631      	mov	r1, r6
    dfd4:	4640      	mov	r0, r8
    dfd6:	f000 fd03 	bl	e9e0 <bsec_Bsec_validateSerialization>
    dfda:	f99d 3016 	ldrsb.w	r3, [sp, #22]
    dfde:	bb1b      	cbnz	r3, e028 <bsec_codegen_set_configuration+0x74>
    dfe0:	3e08      	subs	r6, #8
    dfe2:	f10d 0b1c 	add.w	fp, sp, #28
    dfe6:	9d06      	ldr	r5, [sp, #24]
    dfe8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    dfea:	42b5      	cmp	r5, r6
    dfec:	4622      	mov	r2, r4
    dfee:	4649      	mov	r1, r9
    dff0:	4640      	mov	r0, r8
    dff2:	d227      	bcs.n	e044 <bsec_codegen_set_configuration+0x90>
    dff4:	f10d 0517 	add.w	r5, sp, #23
    dff8:	f8cd b008 	str.w	fp, [sp, #8]
    dffc:	e9cd a500 	strd	sl, r5, [sp]
    e000:	f000 fb44 	bl	e68c <bsec_Bsec_parse>
    e004:	f99d 3016 	ldrsb.w	r3, [sp, #22]
    e008:	4621      	mov	r1, r4
    e00a:	4638      	mov	r0, r7
    e00c:	b963      	cbnz	r3, e028 <bsec_codegen_set_configuration+0x74>
    e00e:	f89d 5017 	ldrb.w	r5, [sp, #23]
    e012:	9b07      	ldr	r3, [sp, #28]
    e014:	2dfe      	cmp	r5, #254	; 0xfe
    e016:	461a      	mov	r2, r3
    e018:	d10a      	bne.n	e030 <bsec_codegen_set_configuration+0x7c>
    e01a:	f000 fd5f 	bl	eadc <bsec_b_Bsec_setHyperConfiguration>
    e01e:	4603      	mov	r3, r0
    e020:	f88d 0016 	strb.w	r0, [sp, #22]
    e024:	2b00      	cmp	r3, #0
    e026:	d0de      	beq.n	dfe6 <bsec_codegen_set_configuration+0x32>
    e028:	4618      	mov	r0, r3
    e02a:	b009      	add	sp, #36	; 0x24
    e02c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e030:	4629      	mov	r1, r5
    e032:	4622      	mov	r2, r4
    e034:	f000 fec8 	bl	edc8 <bsec_ChannelHub_configureChannel>
    e038:	4603      	mov	r3, r0
    e03a:	f88d 0016 	strb.w	r0, [sp, #22]
    e03e:	2b00      	cmp	r3, #0
    e040:	d0d1      	beq.n	dfe6 <bsec_codegen_set_configuration+0x32>
    e042:	e7f1      	b.n	e028 <bsec_codegen_set_configuration+0x74>
    e044:	f99d 3016 	ldrsb.w	r3, [sp, #22]
    e048:	4618      	mov	r0, r3
    e04a:	b009      	add	sp, #36	; 0x24
    e04c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000e050 <bsec_codegen_set_state>:
    e050:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e054:	b08b      	sub	sp, #44	; 0x2c
    e056:	460f      	mov	r7, r1
    e058:	4616      	mov	r6, r2
    e05a:	f10d 091e 	add.w	r9, sp, #30
    e05e:	f10d 0820 	add.w	r8, sp, #32
    e062:	4682      	mov	sl, r0
    e064:	461c      	mov	r4, r3
    e066:	9a14      	ldr	r2, [sp, #80]	; 0x50
    e068:	f8cd 8000 	str.w	r8, [sp]
    e06c:	464b      	mov	r3, r9
    e06e:	4631      	mov	r1, r6
    e070:	4638      	mov	r0, r7
    e072:	f000 fcb5 	bl	e9e0 <bsec_Bsec_validateSerialization>
    e076:	f99d 301e 	ldrsb.w	r3, [sp, #30]
    e07a:	bb23      	cbnz	r3, e0c6 <bsec_codegen_set_state+0x76>
    e07c:	f10d 031f 	add.w	r3, sp, #31
    e080:	3e08      	subs	r6, #8
    e082:	f10d 0b24 	add.w	fp, sp, #36	; 0x24
    e086:	9305      	str	r3, [sp, #20]
    e088:	9d08      	ldr	r5, [sp, #32]
    e08a:	9b14      	ldr	r3, [sp, #80]	; 0x50
    e08c:	42b5      	cmp	r5, r6
    e08e:	4622      	mov	r2, r4
    e090:	4641      	mov	r1, r8
    e092:	4638      	mov	r0, r7
    e094:	d226      	bcs.n	e0e4 <bsec_codegen_set_state+0x94>
    e096:	9d05      	ldr	r5, [sp, #20]
    e098:	f8cd b008 	str.w	fp, [sp, #8]
    e09c:	e9cd 9500 	strd	r9, r5, [sp]
    e0a0:	f000 faf4 	bl	e68c <bsec_Bsec_parse>
    e0a4:	f99d 301e 	ldrsb.w	r3, [sp, #30]
    e0a8:	4620      	mov	r0, r4
    e0aa:	b963      	cbnz	r3, e0c6 <bsec_codegen_set_state+0x76>
    e0ac:	f89d 201f 	ldrb.w	r2, [sp, #31]
    e0b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    e0b2:	2afe      	cmp	r2, #254	; 0xfe
    e0b4:	4619      	mov	r1, r3
    e0b6:	d10a      	bne.n	e0ce <bsec_codegen_set_state+0x7e>
    e0b8:	f000 fdc4 	bl	ec44 <bsec_b_Bsec_setHyperState>
    e0bc:	4603      	mov	r3, r0
    e0be:	f88d 001e 	strb.w	r0, [sp, #30]
    e0c2:	2b00      	cmp	r3, #0
    e0c4:	d0e0      	beq.n	e088 <bsec_codegen_set_state+0x38>
    e0c6:	4618      	mov	r0, r3
    e0c8:	b00b      	add	sp, #44	; 0x2c
    e0ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e0ce:	4611      	mov	r1, r2
    e0d0:	4650      	mov	r0, sl
    e0d2:	4622      	mov	r2, r4
    e0d4:	f001 fb6e 	bl	f7b4 <bsec_ChannelHub_setChannelState>
    e0d8:	4603      	mov	r3, r0
    e0da:	f88d 001e 	strb.w	r0, [sp, #30]
    e0de:	2b00      	cmp	r3, #0
    e0e0:	d0d2      	beq.n	e088 <bsec_codegen_set_state+0x38>
    e0e2:	e7f0      	b.n	e0c6 <bsec_codegen_set_state+0x76>
    e0e4:	f99d 301e 	ldrsb.w	r3, [sp, #30]
    e0e8:	4618      	mov	r0, r3
    e0ea:	b00b      	add	sp, #44	; 0x2c
    e0ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000e0f0 <bsec_constructor_bsec>:
    e0f0:	b510      	push	{r4, lr}
    e0f2:	4604      	mov	r4, r0
    e0f4:	f000 fdfc 	bl	ecf0 <bsec_ChannelHub_ChannelHub>
    e0f8:	4620      	mov	r0, r4
    e0fa:	f000 fc41 	bl	e980 <bsec_Bsec_setHyperState>
    e0fe:	4620      	mov	r0, r4
    e100:	f000 fb1e 	bl	e740 <bsec_Bsec_setHyperConfiguration>
    e104:	4620      	mov	r0, r4
    e106:	bd10      	pop	{r4, pc}

0000e108 <bsec_Bsec_applyUpdateSubscription.part.0>:
    e108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e10c:	4606      	mov	r6, r0
    e10e:	4f32      	ldr	r7, [pc, #200]	; (e1d8 <bsec_Bsec_applyUpdateSubscription.part.0+0xd0>)
    e110:	4d32      	ldr	r5, [pc, #200]	; (e1dc <bsec_Bsec_applyUpdateSubscription.part.0+0xd4>)
    e112:	f001 fb23 	bl	f75c <bsec_ChannelHub_resetSamplIntvls>
    e116:	2300      	movs	r3, #0
    e118:	e002      	b.n	e120 <bsec_Bsec_applyUpdateSubscription.part.0+0x18>
    e11a:	2c15      	cmp	r4, #21
    e11c:	4623      	mov	r3, r4
    e11e:	d010      	beq.n	e142 <bsec_Bsec_applyUpdateSubscription.part.0+0x3a>
    e120:	fa47 f203 	asr.w	r2, r7, r3
    e124:	1c5c      	adds	r4, r3, #1
    e126:	07d0      	lsls	r0, r2, #31
    e128:	b2e1      	uxtb	r1, r4
    e12a:	d5f6      	bpl.n	e11a <bsec_Bsec_applyUpdateSubscription.part.0+0x12>
    e12c:	5d5b      	ldrb	r3, [r3, r5]
    e12e:	eb06 0343 	add.w	r3, r6, r3, lsl #1
    e132:	4630      	mov	r0, r6
    e134:	f8b3 2428 	ldrh.w	r2, [r3, #1064]	; 0x428
    e138:	f001 fbca 	bl	f8d0 <bsec_ChannelHub_updateOutputSamplIntvl>
    e13c:	2c15      	cmp	r4, #21
    e13e:	4623      	mov	r3, r4
    e140:	d1ee      	bne.n	e120 <bsec_Bsec_applyUpdateSubscription.part.0+0x18>
    e142:	4630      	mov	r0, r6
    e144:	f001 fa98 	bl	f678 <bsec_ChannelHub_recalculateDownsampling>
    e148:	4f23      	ldr	r7, [pc, #140]	; (e1d8 <bsec_Bsec_applyUpdateSubscription.part.0+0xd0>)
    e14a:	f8df 8090 	ldr.w	r8, [pc, #144]	; e1dc <bsec_Bsec_applyUpdateSubscription.part.0+0xd4>
    e14e:	f8df 9094 	ldr.w	r9, [pc, #148]	; e1e4 <bsec_Bsec_applyUpdateSubscription.part.0+0xdc>
    e152:	2500      	movs	r5, #0
    e154:	e002      	b.n	e15c <bsec_Bsec_applyUpdateSubscription.part.0+0x54>
    e156:	3501      	adds	r5, #1
    e158:	2d15      	cmp	r5, #21
    e15a:	d01b      	beq.n	e194 <bsec_Bsec_applyUpdateSubscription.part.0+0x8c>
    e15c:	fa47 f305 	asr.w	r3, r7, r5
    e160:	07da      	lsls	r2, r3, #31
    e162:	d5f8      	bpl.n	e156 <bsec_Bsec_applyUpdateSubscription.part.0+0x4e>
    e164:	f815 3008 	ldrb.w	r3, [r5, r8]
    e168:	4433      	add	r3, r6
    e16a:	f893 3445 	ldrb.w	r3, [r3, #1093]	; 0x445
    e16e:	2b00      	cmp	r3, #0
    e170:	d0f1      	beq.n	e156 <bsec_Bsec_applyUpdateSubscription.part.0+0x4e>
    e172:	f939 a015 	ldrsh.w	sl, [r9, r5, lsl #1]
    e176:	2300      	movs	r3, #0
    e178:	e002      	b.n	e180 <bsec_Bsec_applyUpdateSubscription.part.0+0x78>
    e17a:	2c0a      	cmp	r4, #10
    e17c:	4623      	mov	r3, r4
    e17e:	d0ea      	beq.n	e156 <bsec_Bsec_applyUpdateSubscription.part.0+0x4e>
    e180:	1c5c      	adds	r4, r3, #1
    e182:	fa4a f303 	asr.w	r3, sl, r3
    e186:	07db      	lsls	r3, r3, #31
    e188:	b2e1      	uxtb	r1, r4
    e18a:	d5f6      	bpl.n	e17a <bsec_Bsec_applyUpdateSubscription.part.0+0x72>
    e18c:	4630      	mov	r0, r6
    e18e:	f001 fb67 	bl	f860 <bsec_ChannelHub_updateChannelInterfaceDependency>
    e192:	e7f2      	b.n	e17a <bsec_Bsec_applyUpdateSubscription.part.0+0x72>
    e194:	2400      	movs	r4, #0
    e196:	4621      	mov	r1, r4
    e198:	f886 445a 	strb.w	r4, [r6, #1114]	; 0x45a
    e19c:	220e      	movs	r2, #14
    e19e:	f206 4046 	addw	r0, r6, #1094	; 0x446
    e1a2:	f02a ff53 	bl	3904c <memset>
    e1a6:	4b0e      	ldr	r3, [pc, #56]	; (e1e0 <bsec_Bsec_applyUpdateSubscription.part.0+0xd8>)
    e1a8:	f886 4456 	strb.w	r4, [r6, #1110]	; 0x456
    e1ac:	78db      	ldrb	r3, [r3, #3]
    e1ae:	f203 1353 	addw	r3, r3, #339	; 0x153
    e1b2:	4621      	mov	r1, r4
    e1b4:	f836 0013 	ldrh.w	r0, [r6, r3, lsl #1]
    e1b8:	f206 4312 	addw	r3, r6, #1042	; 0x412
    e1bc:	f833 2b02 	ldrh.w	r2, [r3], #2
    e1c0:	4290      	cmp	r0, r2
    e1c2:	f101 0101 	add.w	r1, r1, #1
    e1c6:	d003      	beq.n	e1d0 <bsec_Bsec_applyUpdateSubscription.part.0+0xc8>
    e1c8:	2904      	cmp	r1, #4
    e1ca:	d1f7      	bne.n	e1bc <bsec_Bsec_applyUpdateSubscription.part.0+0xb4>
    e1cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e1d0:	f886 1456 	strb.w	r1, [r6, #1110]	; 0x456
    e1d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e1d8:	001279ef 	.word	0x001279ef
    e1dc:	0003ad68 	.word	0x0003ad68
    e1e0:	0003ad80 	.word	0x0003ad80
    e1e4:	0003ace8 	.word	0x0003ace8

0000e1e8 <bsec_Bsec_append>:
    e1e8:	b4f0      	push	{r4, r5, r6, r7}
    e1ea:	6816      	ldr	r6, [r2, #0]
    e1ec:	18f4      	adds	r4, r6, r3
    e1ee:	428c      	cmp	r4, r1
    e1f0:	d818      	bhi.n	e224 <bsec_Bsec_append+0x3c>
    e1f2:	9905      	ldr	r1, [sp, #20]
    e1f4:	428b      	cmp	r3, r1
    e1f6:	d818      	bhi.n	e22a <bsec_Bsec_append+0x42>
    e1f8:	b183      	cbz	r3, e21c <bsec_Bsec_append+0x34>
    e1fa:	9904      	ldr	r1, [sp, #16]
    e1fc:	1c5f      	adds	r7, r3, #1
    e1fe:	1e4d      	subs	r5, r1, #1
    e200:	2101      	movs	r1, #1
    e202:	e000      	b.n	e206 <bsec_Bsec_append+0x1e>
    e204:	6816      	ldr	r6, [r2, #0]
    e206:	1844      	adds	r4, r0, r1
    e208:	4434      	add	r4, r6
    e20a:	3101      	adds	r1, #1
    e20c:	f815 6f01 	ldrb.w	r6, [r5, #1]!
    e210:	f804 6c01 	strb.w	r6, [r4, #-1]
    e214:	428f      	cmp	r7, r1
    e216:	d1f5      	bne.n	e204 <bsec_Bsec_append+0x1c>
    e218:	6814      	ldr	r4, [r2, #0]
    e21a:	441c      	add	r4, r3
    e21c:	6014      	str	r4, [r2, #0]
    e21e:	2000      	movs	r0, #0
    e220:	bcf0      	pop	{r4, r5, r6, r7}
    e222:	4770      	bx	lr
    e224:	f06f 0028 	mvn.w	r0, #40	; 0x28
    e228:	e7fa      	b.n	e220 <bsec_Bsec_append+0x38>
    e22a:	f06f 0025 	mvn.w	r0, #37	; 0x25
    e22e:	e7f7      	b.n	e220 <bsec_Bsec_append+0x38>

0000e230 <bsec_Bsec_applyUpdateSubscription>:
    e230:	f890 345a 	ldrb.w	r3, [r0, #1114]	; 0x45a
    e234:	b903      	cbnz	r3, e238 <bsec_Bsec_applyUpdateSubscription+0x8>
    e236:	4770      	bx	lr
    e238:	e766      	b.n	e108 <bsec_Bsec_applyUpdateSubscription.part.0>
    e23a:	bf00      	nop

0000e23c <bsec_Bsec_checkIfSensorRequired>:
    e23c:	b470      	push	{r4, r5, r6}
    e23e:	3901      	subs	r1, #1
    e240:	4c13      	ldr	r4, [pc, #76]	; (e290 <bsec_Bsec_checkIfSensorRequired+0x54>)
    e242:	9d03      	ldr	r5, [sp, #12]
    e244:	5c64      	ldrb	r4, [r4, r1]
    e246:	f204 1453 	addw	r4, r4, #339	; 0x153
    e24a:	2600      	movs	r6, #0
    e24c:	f830 4014 	ldrh.w	r4, [r0, r4, lsl #1]
    e250:	701e      	strb	r6, [r3, #0]
    e252:	f64f 76ff 	movw	r6, #65535	; 0xffff
    e256:	42b4      	cmp	r4, r6
    e258:	802c      	strh	r4, [r5, #0]
    e25a:	d010      	beq.n	e27e <bsec_Bsec_checkIfSensorRequired+0x42>
    e25c:	f8b0 6454 	ldrh.w	r6, [r0, #1108]	; 0x454
    e260:	fbb6 f5f4 	udiv	r5, r6, r4
    e264:	fb04 6415 	mls	r4, r4, r5, r6
    e268:	b2a4      	uxth	r4, r4
    e26a:	b954      	cbnz	r4, e282 <bsec_Bsec_checkIfSensorRequired+0x46>
    e26c:	2401      	movs	r4, #1
    e26e:	6890      	ldr	r0, [r2, #8]
    e270:	701c      	strb	r4, [r3, #0]
    e272:	b2c9      	uxtb	r1, r1
    e274:	fa04 f101 	lsl.w	r1, r4, r1
    e278:	4301      	orrs	r1, r0
    e27a:	7514      	strb	r4, [r2, #20]
    e27c:	6091      	str	r1, [r2, #8]
    e27e:	bc70      	pop	{r4, r5, r6}
    e280:	4770      	bx	lr
    e282:	f890 045b 	ldrb.w	r0, [r0, #1115]	; 0x45b
    e286:	2800      	cmp	r0, #0
    e288:	d1f0      	bne.n	e26c <bsec_Bsec_checkIfSensorRequired+0x30>
    e28a:	bc70      	pop	{r4, r5, r6}
    e28c:	4770      	bx	lr
    e28e:	bf00      	nop
    e290:	0003ad80 	.word	0x0003ad80

0000e294 <bsec_Bsec_checkSamplIntvlCompatibilty>:
    e294:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e298:	4c6a      	ldr	r4, [pc, #424]	; (e444 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b0>)
    e29a:	4e6b      	ldr	r6, [pc, #428]	; (e448 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b4>)
    e29c:	2300      	movs	r3, #0
    e29e:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
    e2a2:	f64f 77ff 	movw	r7, #65535	; 0xffff
    e2a6:	fa44 f203 	asr.w	r2, r4, r3
    e2aa:	07d2      	lsls	r2, r2, #31
    e2ac:	f140 80b0 	bpl.w	e410 <bsec_Bsec_checkSamplIntvlCompatibilty+0x17c>
    e2b0:	5cf2      	ldrb	r2, [r6, r3]
    e2b2:	442a      	add	r2, r5
    e2b4:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
    e2b8:	f5b2 6fe1 	cmp.w	r2, #1800	; 0x708
    e2bc:	f000 80a8 	beq.w	e410 <bsec_Bsec_checkSamplIntvlCompatibilty+0x17c>
    e2c0:	42ba      	cmp	r2, r7
    e2c2:	f000 80a5 	beq.w	e410 <bsec_Bsec_checkSamplIntvlCompatibilty+0x17c>
    e2c6:	f8b0 c40e 	ldrh.w	ip, [r0, #1038]	; 0x40e
    e2ca:	4d5e      	ldr	r5, [pc, #376]	; (e444 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b0>)
    e2cc:	4664      	mov	r4, ip
    e2ce:	2300      	movs	r3, #0
    e2d0:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
    e2d4:	fa45 f203 	asr.w	r2, r5, r3
    e2d8:	07d2      	lsls	r2, r2, #31
    e2da:	d506      	bpl.n	e2ea <bsec_Bsec_checkSamplIntvlCompatibilty+0x56>
    e2dc:	5cf2      	ldrb	r2, [r6, r3]
    e2de:	443a      	add	r2, r7
    e2e0:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
    e2e4:	4294      	cmp	r4, r2
    e2e6:	bf28      	it	cs
    e2e8:	4614      	movcs	r4, r2
    e2ea:	3301      	adds	r3, #1
    e2ec:	2b15      	cmp	r3, #21
    e2ee:	d1f1      	bne.n	e2d4 <bsec_Bsec_checkSamplIntvlCompatibilty+0x40>
    e2f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e2f4:	4294      	cmp	r4, r2
    e2f6:	d01f      	beq.n	e338 <bsec_Bsec_checkSamplIntvlCompatibilty+0xa4>
    e2f8:	fbbc f3f4 	udiv	r3, ip, r4
    e2fc:	fb04 c313 	mls	r3, r4, r3, ip
    e300:	b29b      	uxth	r3, r3
    e302:	2b00      	cmp	r3, #0
    e304:	f040 809b 	bne.w	e43e <bsec_Bsec_checkSamplIntvlCompatibilty+0x1aa>
    e308:	4f4e      	ldr	r7, [pc, #312]	; (e444 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b0>)
    e30a:	f06f 4c00 	mvn.w	ip, #2147483648	; 0x80000000
    e30e:	fa47 f503 	asr.w	r5, r7, r3
    e312:	07ed      	lsls	r5, r5, #31
    e314:	d50d      	bpl.n	e332 <bsec_Bsec_checkSamplIntvlCompatibilty+0x9e>
    e316:	5cf5      	ldrb	r5, [r6, r3]
    e318:	4465      	add	r5, ip
    e31a:	f831 e015 	ldrh.w	lr, [r1, r5, lsl #1]
    e31e:	4596      	cmp	lr, r2
    e320:	d007      	beq.n	e332 <bsec_Bsec_checkSamplIntvlCompatibilty+0x9e>
    e322:	fbbe f5f4 	udiv	r5, lr, r4
    e326:	fb04 e515 	mls	r5, r4, r5, lr
    e32a:	b2ad      	uxth	r5, r5
    e32c:	2d00      	cmp	r5, #0
    e32e:	f040 8086 	bne.w	e43e <bsec_Bsec_checkSamplIntvlCompatibilty+0x1aa>
    e332:	3301      	adds	r3, #1
    e334:	2b15      	cmp	r3, #21
    e336:	d1ea      	bne.n	e30e <bsec_Bsec_checkSamplIntvlCompatibilty+0x7a>
    e338:	f64f 75ff 	movw	r5, #65535	; 0xffff
    e33c:	4a43      	ldr	r2, [pc, #268]	; (e44c <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b8>)
    e33e:	4f41      	ldr	r7, [pc, #260]	; (e444 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b0>)
    e340:	46ae      	mov	lr, r5
    e342:	2300      	movs	r3, #0
    e344:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
    e348:	f852 4b04 	ldr.w	r4, [r2], #4
    e34c:	0724      	lsls	r4, r4, #28
    e34e:	fa47 fc03 	asr.w	ip, r7, r3
    e352:	d502      	bpl.n	e35a <bsec_Bsec_checkSamplIntvlCompatibilty+0xc6>
    e354:	f01c 0f01 	tst.w	ip, #1
    e358:	d15f      	bne.n	e41a <bsec_Bsec_checkSamplIntvlCompatibilty+0x186>
    e35a:	3301      	adds	r3, #1
    e35c:	2b15      	cmp	r3, #21
    e35e:	d1f3      	bne.n	e348 <bsec_Bsec_checkSamplIntvlCompatibilty+0xb4>
    e360:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e364:	429d      	cmp	r5, r3
    e366:	d066      	beq.n	e436 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1a2>
    e368:	f200 4212 	addw	r2, r0, #1042	; 0x412
    e36c:	2300      	movs	r3, #0
    e36e:	e002      	b.n	e376 <bsec_Bsec_checkSamplIntvlCompatibilty+0xe2>
    e370:	3301      	adds	r3, #1
    e372:	2b04      	cmp	r3, #4
    e374:	d009      	beq.n	e38a <bsec_Bsec_checkSamplIntvlCompatibilty+0xf6>
    e376:	f832 4b02 	ldrh.w	r4, [r2], #2
    e37a:	42ac      	cmp	r4, r5
    e37c:	d1f8      	bne.n	e370 <bsec_Bsec_checkSamplIntvlCompatibilty+0xdc>
    e37e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    e382:	f8b3 341a 	ldrh.w	r3, [r3, #1050]	; 0x41a
    e386:	3304      	adds	r3, #4
    e388:	b29b      	uxth	r3, r3
    e38a:	4d2e      	ldr	r5, [pc, #184]	; (e444 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1b0>)
    e38c:	ed9f 6a30 	vldr	s12, [pc, #192]	; e450 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1bc>
    e390:	eddf 6a30 	vldr	s13, [pc, #192]	; e454 <bsec_Bsec_checkSamplIntvlCompatibilty+0x1c0>
    e394:	2400      	movs	r4, #0
    e396:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
    e39a:	f64f 7cff 	movw	ip, #65535	; 0xffff
    e39e:	fa45 f204 	asr.w	r2, r5, r4
    e3a2:	07d2      	lsls	r2, r2, #31
    e3a4:	d52e      	bpl.n	e404 <bsec_Bsec_checkSamplIntvlCompatibilty+0x170>
    e3a6:	f890 e457 	ldrb.w	lr, [r0, #1111]	; 0x457
    e3aa:	f890 8459 	ldrb.w	r8, [r0, #1113]	; 0x459
    e3ae:	f890 2458 	ldrb.w	r2, [r0, #1112]	; 0x458
    e3b2:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    e3b6:	ea4f 0848 	mov.w	r8, r8, lsl #1
    e3ba:	fa5f fe8e 	uxtb.w	lr, lr
    e3be:	fa5f f888 	uxtb.w	r8, r8
    e3c2:	0052      	lsls	r2, r2, #1
    e3c4:	44c6      	add	lr, r8
    e3c6:	b2d2      	uxtb	r2, r2
    e3c8:	4472      	add	r2, lr
    e3ca:	441a      	add	r2, r3
    e3cc:	b292      	uxth	r2, r2
    e3ce:	ee07 2a90 	vmov	s15, r2
    e3d2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    e3d6:	5d32      	ldrb	r2, [r6, r4]
    e3d8:	ee67 7a86 	vmul.f32	s15, s15, s12
    e3dc:	443a      	add	r2, r7
    e3de:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    e3e2:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
    e3e6:	ee07 2a90 	vmov	s15, r2
    e3ea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    e3ee:	eef4 7ac7 	vcmpe.f32	s15, s14
    e3f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    e3f6:	d505      	bpl.n	e404 <bsec_Bsec_checkSamplIntvlCompatibilty+0x170>
    e3f8:	4562      	cmp	r2, ip
    e3fa:	d003      	beq.n	e404 <bsec_Bsec_checkSamplIntvlCompatibilty+0x170>
    e3fc:	f06f 0011 	mvn.w	r0, #17
    e400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e404:	3401      	adds	r4, #1
    e406:	2c15      	cmp	r4, #21
    e408:	d1c9      	bne.n	e39e <bsec_Bsec_checkSamplIntvlCompatibilty+0x10a>
    e40a:	2000      	movs	r0, #0
    e40c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e410:	3301      	adds	r3, #1
    e412:	2b15      	cmp	r3, #21
    e414:	f47f af47 	bne.w	e2a6 <bsec_Bsec_checkSamplIntvlCompatibilty+0x12>
    e418:	e7f7      	b.n	e40a <bsec_Bsec_checkSamplIntvlCompatibilty+0x176>
    e41a:	5cf4      	ldrb	r4, [r6, r3]
    e41c:	4444      	add	r4, r8
    e41e:	f831 4014 	ldrh.w	r4, [r1, r4, lsl #1]
    e422:	4574      	cmp	r4, lr
    e424:	d099      	beq.n	e35a <bsec_Bsec_checkSamplIntvlCompatibilty+0xc6>
    e426:	4575      	cmp	r5, lr
    e428:	d007      	beq.n	e43a <bsec_Bsec_checkSamplIntvlCompatibilty+0x1a6>
    e42a:	42ac      	cmp	r4, r5
    e42c:	d095      	beq.n	e35a <bsec_Bsec_checkSamplIntvlCompatibilty+0xc6>
    e42e:	f06f 0010 	mvn.w	r0, #16
    e432:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e436:	2304      	movs	r3, #4
    e438:	e7a7      	b.n	e38a <bsec_Bsec_checkSamplIntvlCompatibilty+0xf6>
    e43a:	4625      	mov	r5, r4
    e43c:	e78d      	b.n	e35a <bsec_Bsec_checkSamplIntvlCompatibilty+0xc6>
    e43e:	f06f 000f 	mvn.w	r0, #15
    e442:	e7e3      	b.n	e40c <bsec_Bsec_checkSamplIntvlCompatibilty+0x178>
    e444:	001279ef 	.word	0x001279ef
    e448:	0003ad68 	.word	0x0003ad68
    e44c:	0003ad14 	.word	0x0003ad14
    e450:	42c80000 	.word	0x42c80000
    e454:	447a0000 	.word	0x447a0000

0000e458 <bsec_Bsec_frameSerializedData>:
    e458:	b570      	push	{r4, r5, r6, lr}
    e45a:	b088      	sub	sp, #32
    e45c:	ae08      	add	r6, sp, #32
    e45e:	4b28      	ldr	r3, [pc, #160]	; (e500 <bsec_Bsec_frameSerializedData+0xa8>)
    e460:	f846 3d18 	str.w	r3, [r6, #-24]!
    e464:	4604      	mov	r4, r0
    e466:	2204      	movs	r2, #4
    e468:	460d      	mov	r5, r1
    e46a:	a803      	add	r0, sp, #12
    e46c:	4631      	mov	r1, r6
    e46e:	f02a fdb3 	bl	38fd8 <memcpy>
    e472:	aa03      	add	r2, sp, #12
    e474:	1e63      	subs	r3, r4, #1
    e476:	1ce0      	adds	r0, r4, #3
    e478:	f812 1b01 	ldrb.w	r1, [r2], #1
    e47c:	f803 1f01 	strb.w	r1, [r3, #1]!
    e480:	4283      	cmp	r3, r0
    e482:	d1f9      	bne.n	e478 <bsec_Bsec_frameSerializedData+0x20>
    e484:	2300      	movs	r3, #0
    e486:	a908      	add	r1, sp, #32
    e488:	223d      	movs	r2, #61	; 0x3d
    e48a:	e961 2304 	strd	r2, r3, [r1, #-16]!
    e48e:	a806      	add	r0, sp, #24
    e490:	2208      	movs	r2, #8
    e492:	f02a fda1 	bl	38fd8 <memcpy>
    e496:	a906      	add	r1, sp, #24
    e498:	2208      	movs	r2, #8
    e49a:	1d20      	adds	r0, r4, #4
    e49c:	f02a fd9c 	bl	38fd8 <memcpy>
    e4a0:	682b      	ldr	r3, [r5, #0]
    e4a2:	4631      	mov	r1, r6
    e4a4:	3b10      	subs	r3, #16
    e4a6:	a803      	add	r0, sp, #12
    e4a8:	2204      	movs	r2, #4
    e4aa:	9302      	str	r3, [sp, #8]
    e4ac:	f02a fd94 	bl	38fd8 <memcpy>
    e4b0:	f89d 000c 	ldrb.w	r0, [sp, #12]
    e4b4:	f89d 100d 	ldrb.w	r1, [sp, #13]
    e4b8:	f89d 200e 	ldrb.w	r2, [sp, #14]
    e4bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    e4c0:	7320      	strb	r0, [r4, #12]
    e4c2:	73a2      	strb	r2, [r4, #14]
    e4c4:	73e3      	strb	r3, [r4, #15]
    e4c6:	7361      	strb	r1, [r4, #13]
    e4c8:	6829      	ldr	r1, [r5, #0]
    e4ca:	aa01      	add	r2, sp, #4
    e4cc:	4620      	mov	r0, r4
    e4ce:	f003 fb59 	bl	11b84 <bsec_crcCcitt2>
    e4d2:	682b      	ldr	r3, [r5, #0]
    e4d4:	f89d 0004 	ldrb.w	r0, [sp, #4]
    e4d8:	f89d 1005 	ldrb.w	r1, [sp, #5]
    e4dc:	4423      	add	r3, r4
    e4de:	2200      	movs	r2, #0
    e4e0:	7118      	strb	r0, [r3, #4]
    e4e2:	682b      	ldr	r3, [r5, #0]
    e4e4:	4423      	add	r3, r4
    e4e6:	7159      	strb	r1, [r3, #5]
    e4e8:	682b      	ldr	r3, [r5, #0]
    e4ea:	4423      	add	r3, r4
    e4ec:	719a      	strb	r2, [r3, #6]
    e4ee:	682b      	ldr	r3, [r5, #0]
    e4f0:	441c      	add	r4, r3
    e4f2:	71e2      	strb	r2, [r4, #7]
    e4f4:	682b      	ldr	r3, [r5, #0]
    e4f6:	3308      	adds	r3, #8
    e4f8:	602b      	str	r3, [r5, #0]
    e4fa:	b008      	add	sp, #32
    e4fc:	bd70      	pop	{r4, r5, r6, pc}
    e4fe:	bf00      	nop
    e500:	01040704 	.word	0x01040704

0000e504 <bsec_Bsec_getHyperConfiguration>:
    e504:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e508:	b085      	sub	sp, #20
    e50a:	ac04      	add	r4, sp, #16
    e50c:	2507      	movs	r5, #7
    e50e:	f804 5d09 	strb.w	r5, [r4, #-9]!
    e512:	4606      	mov	r6, r0
    e514:	4617      	mov	r7, r2
    e516:	20fe      	movs	r0, #254	; 0xfe
    e518:	4622      	mov	r2, r4
    e51a:	460d      	mov	r5, r1
    e51c:	f003 fab6 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
    e520:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e524:	9003      	str	r0, [sp, #12]
    e526:	b1da      	cbz	r2, e560 <bsec_Bsec_getHyperConfiguration+0x5c>
    e528:	2401      	movs	r4, #1
    e52a:	f506 797c 	add.w	r9, r6, #1008	; 0x3f0
    e52e:	f506 7852 	add.w	r8, r6, #840	; 0x348
    e532:	1e63      	subs	r3, r4, #1
    e534:	2b06      	cmp	r3, #6
    e536:	d80e      	bhi.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e538:	e8df f003 	tbb	[pc, r3]
    e53c:	4953353f 	.word	0x4953353f
    e540:	232c      	.short	0x232c
    e542:	04          	.byte	0x04
    e543:	00          	.byte	0x00
    e544:	463a      	mov	r2, r7
    e546:	ab03      	add	r3, sp, #12
    e548:	4629      	mov	r1, r5
    e54a:	f8b6 040e 	ldrh.w	r0, [r6, #1038]	; 0x40e
    e54e:	f001 fadd 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
    e552:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e556:	3401      	adds	r4, #1
    e558:	b2e4      	uxtb	r4, r4
    e55a:	42a2      	cmp	r2, r4
    e55c:	d2e9      	bcs.n	e532 <bsec_Bsec_getHyperConfiguration+0x2e>
    e55e:	9803      	ldr	r0, [sp, #12]
    e560:	a904      	add	r1, sp, #16
    e562:	2202      	movs	r2, #2
    e564:	f821 0d06 	strh.w	r0, [r1, #-6]!
    e568:	a802      	add	r0, sp, #8
    e56a:	f02a fd35 	bl	38fd8 <memcpy>
    e56e:	f89d 2008 	ldrb.w	r2, [sp, #8]
    e572:	f89d 3009 	ldrb.w	r3, [sp, #9]
    e576:	9803      	ldr	r0, [sp, #12]
    e578:	702a      	strb	r2, [r5, #0]
    e57a:	706b      	strb	r3, [r5, #1]
    e57c:	b005      	add	sp, #20
    e57e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e582:	463a      	mov	r2, r7
    e584:	ab03      	add	r3, sp, #12
    e586:	4629      	mov	r1, r5
    e588:	4648      	mov	r0, r9
    e58a:	f001 fdd5 	bl	10138 <bsec_q_Entity_serializeAndAdd>
    e58e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e592:	e7e0      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e594:	463a      	mov	r2, r7
    e596:	ab03      	add	r3, sp, #12
    e598:	4629      	mov	r1, r5
    e59a:	4640      	mov	r0, r8
    e59c:	f001 fd8a 	bl	100b4 <bsec_p_Entity_serializeAndAdd>
    e5a0:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e5a4:	e7d7      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e5a6:	463a      	mov	r2, r7
    e5a8:	ab03      	add	r3, sp, #12
    e5aa:	4629      	mov	r1, r5
    e5ac:	f896 0458 	ldrb.w	r0, [r6, #1112]	; 0x458
    e5b0:	f001 fb5c 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
    e5b4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e5b8:	e7cd      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e5ba:	463a      	mov	r2, r7
    e5bc:	ab03      	add	r3, sp, #12
    e5be:	4629      	mov	r1, r5
    e5c0:	f896 0457 	ldrb.w	r0, [r6, #1111]	; 0x457
    e5c4:	f001 fb52 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
    e5c8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e5cc:	e7c3      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e5ce:	463a      	mov	r2, r7
    e5d0:	ab03      	add	r3, sp, #12
    e5d2:	4629      	mov	r1, r5
    e5d4:	f206 4012 	addw	r0, r6, #1042	; 0x412
    e5d8:	f001 fd42 	bl	10060 <bsec_o_Entity_serializeAndAdd>
    e5dc:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e5e0:	e7b9      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e5e2:	463a      	mov	r2, r7
    e5e4:	ab03      	add	r3, sp, #12
    e5e6:	4629      	mov	r1, r5
    e5e8:	f896 0459 	ldrb.w	r0, [r6, #1113]	; 0x459
    e5ec:	f001 fb3e 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
    e5f0:	f89d 2007 	ldrb.w	r2, [sp, #7]
    e5f4:	e7af      	b.n	e556 <bsec_Bsec_getHyperConfiguration+0x52>
    e5f6:	bf00      	nop

0000e5f8 <bsec_Bsec_getHyperState>:
    e5f8:	2000      	movs	r0, #0
    e5fa:	4770      	bx	lr

0000e5fc <bsec_Bsec_getModHeatingDuration>:
    e5fc:	b508      	push	{r3, lr}
    e5fe:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
    e602:	ed2d 8b02 	vpush	{d8}
    e606:	eef0 8a40 	vmov.f32	s17, s0
    e60a:	f021 f871 	bl	2f6f0 <powf>
    e60e:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
    e612:	eeb0 8a40 	vmov.f32	s16, s0
    e616:	eeb0 0a68 	vmov.f32	s0, s17
    e61a:	f021 f869 	bl	2f6f0 <powf>
    e61e:	ed9f 5a15 	vldr	s10, [pc, #84]	; e674 <bsec_Bsec_getModHeatingDuration+0x78>
    e622:	eddf 7a15 	vldr	s15, [pc, #84]	; e678 <bsec_Bsec_getModHeatingDuration+0x7c>
    e626:	eddf 5a15 	vldr	s11, [pc, #84]	; e67c <bsec_Bsec_getModHeatingDuration+0x80>
    e62a:	ed9f 6a15 	vldr	s12, [pc, #84]	; e680 <bsec_Bsec_getModHeatingDuration+0x84>
    e62e:	eddf 6a15 	vldr	s13, [pc, #84]	; e684 <bsec_Bsec_getModHeatingDuration+0x88>
    e632:	ed9f 7a15 	vldr	s14, [pc, #84]	; e688 <bsec_Bsec_getModHeatingDuration+0x8c>
    e636:	ee60 7a27 	vmul.f32	s15, s0, s15
    e63a:	ee28 8a05 	vmul.f32	s16, s16, s10
    e63e:	ee28 0aa8 	vmul.f32	s0, s17, s17
    e642:	ee38 8a27 	vadd.f32	s16, s16, s15
    e646:	ee20 0a25 	vmul.f32	s0, s0, s11
    e64a:	ee68 8a86 	vmul.f32	s17, s17, s12
    e64e:	ee38 0a00 	vadd.f32	s0, s16, s0
    e652:	ee30 0a28 	vadd.f32	s0, s0, s17
    e656:	ee30 0a26 	vadd.f32	s0, s0, s13
    e65a:	ee20 0a07 	vmul.f32	s0, s0, s14
    e65e:	f020 ff4f 	bl	2f500 <roundf>
    e662:	ecbd 8b02 	vpop	{d8}
    e666:	eebc 0ac0 	vcvt.u32.f32	s0, s0
    e66a:	ee10 3a10 	vmov	r3, s0
    e66e:	b298      	uxth	r0, r3
    e670:	bd08      	pop	{r3, pc}
    e672:	bf00      	nop
    e674:	b0078259 	.word	0xb0078259
    e678:	34c2e0df 	.word	0x34c2e0df
    e67c:	b8d96737 	.word	0xb8d96737
    e680:	3c868e5a 	.word	0x3c868e5a
    e684:	3ee4926a 	.word	0x3ee4926a
    e688:	447a0000 	.word	0x447a0000

0000e68c <bsec_Bsec_parse>:
    e68c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e690:	b082      	sub	sp, #8
    e692:	e9dd 790a 	ldrd	r7, r9, [sp, #40]	; 0x28
    e696:	460c      	mov	r4, r1
    e698:	2100      	movs	r1, #0
    e69a:	7039      	strb	r1, [r7, #0]
    e69c:	f889 1000 	strb.w	r1, [r9]
    e6a0:	6821      	ldr	r1, [r4, #0]
    e6a2:	4605      	mov	r5, r0
    e6a4:	4408      	add	r0, r1
    e6a6:	4690      	mov	r8, r2
    e6a8:	7842      	ldrb	r2, [r0, #1]
    e6aa:	f815 c001 	ldrb.w	ip, [r5, r1]
    e6ae:	f88d 2005 	strb.w	r2, [sp, #5]
    e6b2:	a901      	add	r1, sp, #4
    e6b4:	2202      	movs	r2, #2
    e6b6:	f10d 0006 	add.w	r0, sp, #6
    e6ba:	469a      	mov	sl, r3
    e6bc:	f88d c004 	strb.w	ip, [sp, #4]
    e6c0:	f02a fc8a 	bl	38fd8 <memcpy>
    e6c4:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    e6c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    e6ca:	4550      	cmp	r0, sl
    e6cc:	6018      	str	r0, [r3, #0]
    e6ce:	d818      	bhi.n	e702 <bsec_Bsec_parse+0x76>
    e6d0:	b168      	cbz	r0, e6ee <bsec_Bsec_parse+0x62>
    e6d2:	f108 31ff 	add.w	r1, r8, #4294967295	; 0xffffffff
    e6d6:	1c47      	adds	r7, r0, #1
    e6d8:	2301      	movs	r3, #1
    e6da:	6826      	ldr	r6, [r4, #0]
    e6dc:	18ea      	adds	r2, r5, r3
    e6de:	4432      	add	r2, r6
    e6e0:	3301      	adds	r3, #1
    e6e2:	f812 2c01 	ldrb.w	r2, [r2, #-1]
    e6e6:	f801 2f01 	strb.w	r2, [r1, #1]!
    e6ea:	429f      	cmp	r7, r3
    e6ec:	d1f5      	bne.n	e6da <bsec_Bsec_parse+0x4e>
    e6ee:	f898 3002 	ldrb.w	r3, [r8, #2]
    e6f2:	f889 3000 	strb.w	r3, [r9]
    e6f6:	6823      	ldr	r3, [r4, #0]
    e6f8:	4403      	add	r3, r0
    e6fa:	6023      	str	r3, [r4, #0]
    e6fc:	b002      	add	sp, #8
    e6fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    e702:	23e0      	movs	r3, #224	; 0xe0
    e704:	703b      	strb	r3, [r7, #0]
    e706:	b002      	add	sp, #8
    e708:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000e70c <bsec_Bsec_requestOutput>:
    e70c:	4b0b      	ldr	r3, [pc, #44]	; (e73c <bsec_Bsec_requestOutput+0x30>)
    e70e:	4419      	add	r1, r3
    e710:	b410      	push	{r4}
    e712:	f811 3c01 	ldrb.w	r3, [r1, #-1]
    e716:	eb00 0143 	add.w	r1, r0, r3, lsl #1
    e71a:	f8b1 4428 	ldrh.w	r4, [r1, #1064]	; 0x428
    e71e:	4294      	cmp	r4, r2
    e720:	d004      	beq.n	e72c <bsec_Bsec_requestOutput+0x20>
    e722:	3b01      	subs	r3, #1
    e724:	4403      	add	r3, r0
    e726:	2401      	movs	r4, #1
    e728:	f883 4446 	strb.w	r4, [r3, #1094]	; 0x446
    e72c:	2301      	movs	r3, #1
    e72e:	f8a1 2428 	strh.w	r2, [r1, #1064]	; 0x428
    e732:	f85d 4b04 	ldr.w	r4, [sp], #4
    e736:	f880 345a 	strb.w	r3, [r0, #1114]	; 0x45a
    e73a:	4770      	bx	lr
    e73c:	0003ad68 	.word	0x0003ad68

0000e740 <bsec_Bsec_setHyperConfiguration>:
    e740:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e744:	2305      	movs	r3, #5
    e746:	4606      	mov	r6, r0
    e748:	2102      	movs	r1, #2
    e74a:	2201      	movs	r2, #1
    e74c:	f880 1457 	strb.w	r1, [r0, #1111]	; 0x457
    e750:	f880 2458 	strb.w	r2, [r0, #1112]	; 0x458
    e754:	f880 3459 	strb.w	r3, [r0, #1113]	; 0x459
    e758:	2218      	movs	r2, #24
    e75a:	f200 4012 	addw	r0, r0, #1042	; 0x412
    e75e:	4975      	ldr	r1, [pc, #468]	; (e934 <bsec_Bsec_setHyperConfiguration+0x1f4>)
    e760:	f206 3546 	addw	r5, r6, #838	; 0x346
    e764:	f02a fc38 	bl	38fd8 <memcpy>
    e768:	462c      	mov	r4, r5
    e76a:	f206 32ee 	addw	r2, r6, #1006	; 0x3ee
    e76e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    e772:	f824 3f02 	strh.w	r3, [r4, #2]!
    e776:	42a2      	cmp	r2, r4
    e778:	d1fb      	bne.n	e772 <bsec_Bsec_setHyperConfiguration+0x32>
    e77a:	f240 51dc 	movw	r1, #1500	; 0x5dc
    e77e:	4b6e      	ldr	r3, [pc, #440]	; (e938 <bsec_Bsec_setHyperConfiguration+0x1f8>)
    e780:	f8df c1e4 	ldr.w	ip, [pc, #484]	; e968 <bsec_Bsec_setHyperConfiguration+0x228>
    e784:	4f6d      	ldr	r7, [pc, #436]	; (e93c <bsec_Bsec_setHyperConfiguration+0x1fc>)
    e786:	486e      	ldr	r0, [pc, #440]	; (e940 <bsec_Bsec_setHyperConfiguration+0x200>)
    e788:	f8df e1e0 	ldr.w	lr, [pc, #480]	; e96c <bsec_Bsec_setHyperConfiguration+0x22c>
    e78c:	f8df 81e0 	ldr.w	r8, [pc, #480]	; e970 <bsec_Bsec_setHyperConfiguration+0x230>
    e790:	4a6c      	ldr	r2, [pc, #432]	; (e944 <bsec_Bsec_setHyperConfiguration+0x204>)
    e792:	f8a6 13e0 	strh.w	r1, [r6, #992]	; 0x3e0
    e796:	f04f 1164 	mov.w	r1, #6553700	; 0x640064
    e79a:	f8c6 e3dc 	str.w	lr, [r6, #988]	; 0x3dc
    e79e:	f8c6 c360 	str.w	ip, [r6, #864]	; 0x360
    e7a2:	f8c6 c36c 	str.w	ip, [r6, #876]	; 0x36c
    e7a6:	f8c6 c348 	str.w	ip, [r6, #840]	; 0x348
    e7aa:	f8c6 c34c 	str.w	ip, [r6, #844]	; 0x34c
    e7ae:	f8c6 c358 	str.w	ip, [r6, #856]	; 0x358
    e7b2:	f8c6 33b8 	str.w	r3, [r6, #952]	; 0x3b8
    e7b6:	f8c6 33bc 	str.w	r3, [r6, #956]	; 0x3bc
    e7ba:	f8c6 33c0 	str.w	r3, [r6, #960]	; 0x3c0
    e7be:	f8c6 33c4 	str.w	r3, [r6, #964]	; 0x3c4
    e7c2:	f8c6 33c8 	str.w	r3, [r6, #968]	; 0x3c8
    e7c6:	f8c6 33d0 	str.w	r3, [r6, #976]	; 0x3d0
    e7ca:	f8c6 1364 	str.w	r1, [r6, #868]	; 0x364
    e7ce:	f8c6 1368 	str.w	r1, [r6, #872]	; 0x368
    e7d2:	f8c6 1374 	str.w	r1, [r6, #884]	; 0x374
    e7d6:	f8c6 137c 	str.w	r1, [r6, #892]	; 0x37c
    e7da:	f8c6 1350 	str.w	r1, [r6, #848]	; 0x350
    e7de:	f8c6 8370 	str.w	r8, [r6, #880]	; 0x370
    e7e2:	f8c6 7380 	str.w	r7, [r6, #896]	; 0x380
    e7e6:	f8c6 7384 	str.w	r7, [r6, #900]	; 0x384
    e7ea:	f8c6 7388 	str.w	r7, [r6, #904]	; 0x388
    e7ee:	f8c6 738c 	str.w	r7, [r6, #908]	; 0x38c
    e7f2:	f8c6 7390 	str.w	r7, [r6, #912]	; 0x390
    e7f6:	f8c6 7398 	str.w	r7, [r6, #920]	; 0x398
    e7fa:	f8c6 039c 	str.w	r0, [r6, #924]	; 0x39c
    e7fe:	f8c6 03a0 	str.w	r0, [r6, #928]	; 0x3a0
    e802:	f8c6 03a4 	str.w	r0, [r6, #932]	; 0x3a4
    e806:	f8c6 03a8 	str.w	r0, [r6, #936]	; 0x3a8
    e80a:	f8c6 03ac 	str.w	r0, [r6, #940]	; 0x3ac
    e80e:	f8c6 03b4 	str.w	r0, [r6, #948]	; 0x3b4
    e812:	f8c6 2354 	str.w	r2, [r6, #852]	; 0x354
    e816:	f8c6 135c 	str.w	r1, [r6, #860]	; 0x35c
    e81a:	2240      	movs	r2, #64	; 0x40
    e81c:	494a      	ldr	r1, [pc, #296]	; (e948 <bsec_Bsec_setHyperConfiguration+0x208>)
    e81e:	f8c6 e3e8 	str.w	lr, [r6, #1000]	; 0x3e8
    e822:	f8c6 c378 	str.w	ip, [r6, #888]	; 0x378
    e826:	f8c6 7394 	str.w	r7, [r6, #916]	; 0x394
    e82a:	f8c6 03b0 	str.w	r0, [r6, #944]	; 0x3b0
    e82e:	f8c6 33cc 	str.w	r3, [r6, #972]	; 0x3cc
    e832:	f506 7042 	add.w	r0, r6, #776	; 0x308
    e836:	f02a fbcf 	bl	38fd8 <memcpy>
    e83a:	4a44      	ldr	r2, [pc, #272]	; (e94c <bsec_Bsec_setHyperConfiguration+0x20c>)
    e83c:	4944      	ldr	r1, [pc, #272]	; (e950 <bsec_Bsec_setHyperConfiguration+0x210>)
    e83e:	f8df 8134 	ldr.w	r8, [pc, #308]	; e974 <bsec_Bsec_setHyperConfiguration+0x234>
    e842:	f8df e134 	ldr.w	lr, [pc, #308]	; e978 <bsec_Bsec_setHyperConfiguration+0x238>
    e846:	f8df c134 	ldr.w	ip, [pc, #308]	; e97c <bsec_Bsec_setHyperConfiguration+0x23c>
    e84a:	4f42      	ldr	r7, [pc, #264]	; (e954 <bsec_Bsec_setHyperConfiguration+0x214>)
    e84c:	4842      	ldr	r0, [pc, #264]	; (e958 <bsec_Bsec_setHyperConfiguration+0x218>)
    e84e:	f8c6 2310 	str.w	r2, [r6, #784]	; 0x310
    e852:	2300      	movs	r3, #0
    e854:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    e858:	f8c6 330c 	str.w	r3, [r6, #780]	; 0x30c
    e85c:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
    e860:	f8c6 331c 	str.w	r3, [r6, #796]	; 0x31c
    e864:	f8c6 3320 	str.w	r3, [r6, #800]	; 0x320
    e868:	f8c6 3324 	str.w	r3, [r6, #804]	; 0x324
    e86c:	f8c6 233c 	str.w	r2, [r6, #828]	; 0x33c
    e870:	f8c6 2340 	str.w	r2, [r6, #832]	; 0x340
    e874:	f8c6 1344 	str.w	r1, [r6, #836]	; 0x344
    e878:	f8c6 8314 	str.w	r8, [r6, #788]	; 0x314
    e87c:	f8c6 e330 	str.w	lr, [r6, #816]	; 0x330
    e880:	f8c6 c32c 	str.w	ip, [r6, #812]	; 0x32c
    e884:	f8c6 7328 	str.w	r7, [r6, #808]	; 0x328
    e888:	f8c6 0334 	str.w	r0, [r6, #820]	; 0x334
    e88c:	4623      	mov	r3, r4
    e88e:	f206 410a 	addw	r1, r6, #1034	; 0x40a
    e892:	f64f 72ff 	movw	r2, #65535	; 0xffff
    e896:	f823 2f02 	strh.w	r2, [r3, #2]!
    e89a:	4299      	cmp	r1, r3
    e89c:	d1fb      	bne.n	e896 <bsec_Bsec_setHyperConfiguration+0x156>
    e89e:	f247 5230 	movw	r2, #30000	; 0x7530
    e8a2:	2300      	movs	r3, #0
    e8a4:	f8a6 240e 	strh.w	r2, [r6, #1038]	; 0x40e
    e8a8:	f8a6 3410 	strh.w	r3, [r6, #1040]	; 0x410
    e8ac:	f64f 71ff 	movw	r1, #65535	; 0xffff
    e8b0:	f835 3f02 	ldrh.w	r3, [r5, #2]!
    e8b4:	428b      	cmp	r3, r1
    e8b6:	d005      	beq.n	e8c4 <bsec_Bsec_setHyperConfiguration+0x184>
    e8b8:	f8b6 2410 	ldrh.w	r2, [r6, #1040]	; 0x410
    e8bc:	429a      	cmp	r2, r3
    e8be:	bf38      	it	cc
    e8c0:	f8a6 3410 	strhcc.w	r3, [r6, #1040]	; 0x410
    e8c4:	42a5      	cmp	r5, r4
    e8c6:	d1f3      	bne.n	e8b0 <bsec_Bsec_setHyperConfiguration+0x170>
    e8c8:	4824      	ldr	r0, [pc, #144]	; (e95c <bsec_Bsec_setHyperConfiguration+0x21c>)
    e8ca:	4c25      	ldr	r4, [pc, #148]	; (e960 <bsec_Bsec_setHyperConfiguration+0x220>)
    e8cc:	4f25      	ldr	r7, [pc, #148]	; (e964 <bsec_Bsec_setHyperConfiguration+0x224>)
    e8ce:	2300      	movs	r3, #0
    e8d0:	2501      	movs	r5, #1
    e8d2:	fa40 f203 	asr.w	r2, r0, r3
    e8d6:	07d2      	lsls	r2, r2, #31
    e8d8:	d516      	bpl.n	e908 <bsec_Bsec_setHyperConfiguration+0x1c8>
    e8da:	5dd9      	ldrb	r1, [r3, r7]
    e8dc:	5d1a      	ldrb	r2, [r3, r4]
    e8de:	4421      	add	r1, r4
    e8e0:	f202 12f7 	addw	r2, r2, #503	; 0x1f7
    e8e4:	f811 1c01 	ldrb.w	r1, [r1, #-1]
    e8e8:	f836 c012 	ldrh.w	ip, [r6, r2, lsl #1]
    e8ec:	eb06 0241 	add.w	r2, r6, r1, lsl #1
    e8f0:	3901      	subs	r1, #1
    e8f2:	f8b2 e428 	ldrh.w	lr, [r2, #1064]	; 0x428
    e8f6:	45e6      	cmp	lr, ip
    e8f8:	bf1c      	itt	ne
    e8fa:	1989      	addne	r1, r1, r6
    e8fc:	f881 5446 	strbne.w	r5, [r1, #1094]	; 0x446
    e900:	f8a2 c428 	strh.w	ip, [r2, #1064]	; 0x428
    e904:	f886 545a 	strb.w	r5, [r6, #1114]	; 0x45a
    e908:	3301      	adds	r3, #1
    e90a:	2b15      	cmp	r3, #21
    e90c:	d1e1      	bne.n	e8d2 <bsec_Bsec_setHyperConfiguration+0x192>
    e90e:	f206 4345 	addw	r3, r6, #1093	; 0x445
    e912:	f206 4153 	addw	r1, r6, #1107	; 0x453
    e916:	2201      	movs	r2, #1
    e918:	f803 2f01 	strb.w	r2, [r3, #1]!
    e91c:	428b      	cmp	r3, r1
    e91e:	d1fb      	bne.n	e918 <bsec_Bsec_setHyperConfiguration+0x1d8>
    e920:	f896 345a 	ldrb.w	r3, [r6, #1114]	; 0x45a
    e924:	b90b      	cbnz	r3, e92a <bsec_Bsec_setHyperConfiguration+0x1ea>
    e926:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e92a:	4630      	mov	r0, r6
    e92c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    e930:	f7ff bbea 	b.w	e108 <bsec_Bsec_applyUpdateSubscription.part.0>
    e934:	0003aca4 	.word	0x0003aca4
    e938:	17701770 	.word	0x17701770
    e93c:	012c012c 	.word	0x012c012c
    e940:	07080708 	.word	0x07080708
    e944:	75300064 	.word	0x75300064
    e948:	0003ac64 	.word	0x0003ac64
    e94c:	c2820000 	.word	0xc2820000
    e950:	41100000 	.word	0x41100000
    e954:	49f42400 	.word	0x49f42400
    e958:	4b496a80 	.word	0x4b496a80
    e95c:	001279ef 	.word	0x001279ef
    e960:	0003ad68 	.word	0x0003ad68
    e964:	0003ac4c 	.word	0x0003ac4c
    e968:	75307530 	.word	0x75307530
    e96c:	05dc05dc 	.word	0x05dc05dc
    e970:	00647530 	.word	0x00647530
    e974:	432a0000 	.word	0x432a0000
    e978:	42fa0000 	.word	0x42fa0000
    e97c:	42c80000 	.word	0x42c80000

0000e980 <bsec_Bsec_setHyperState>:
    e980:	b470      	push	{r4, r5, r6}
    e982:	2200      	movs	r2, #0
    e984:	2300      	movs	r3, #0
    e986:	f500 743c 	add.w	r4, r0, #752	; 0x2f0
    e98a:	2100      	movs	r1, #0
    e98c:	f880 1456 	strb.w	r1, [r0, #1110]	; 0x456
    e990:	f8a0 1454 	strh.w	r1, [r0, #1108]	; 0x454
    e994:	f500 7540 	add.w	r5, r0, #768	; 0x300
    e998:	e9c4 2300 	strd	r2, r3, [r4]
    e99c:	f500 763e 	add.w	r6, r0, #760	; 0x2f8
    e9a0:	f247 5430 	movw	r4, #30000	; 0x7530
    e9a4:	e9c6 2300 	strd	r2, r3, [r6]
    e9a8:	e9c5 2300 	strd	r2, r3, [r5]
    e9ac:	f8a0 440c 	strh.w	r4, [r0, #1036]	; 0x40c
    e9b0:	f500 6385 	add.w	r3, r0, #1064	; 0x428
    e9b4:	f200 4245 	addw	r2, r0, #1093	; 0x445
    e9b8:	f200 4544 	addw	r5, r0, #1092	; 0x444
    e9bc:	f64f 74ff 	movw	r4, #65535	; 0xffff
    e9c0:	f823 4f02 	strh.w	r4, [r3, #2]!
    e9c4:	42ab      	cmp	r3, r5
    e9c6:	f802 1f01 	strb.w	r1, [r2, #1]!
    e9ca:	d1f9      	bne.n	e9c0 <bsec_Bsec_setHyperState+0x40>
    e9cc:	2366      	movs	r3, #102	; 0x66
    e9ce:	f880 145a 	strb.w	r1, [r0, #1114]	; 0x45a
    e9d2:	f880 145b 	strb.w	r1, [r0, #1115]	; 0x45b
    e9d6:	f880 345c 	strb.w	r3, [r0, #1116]	; 0x45c
    e9da:	bc70      	pop	{r4, r5, r6}
    e9dc:	4770      	bx	lr
    e9de:	bf00      	nop

0000e9e0 <bsec_Bsec_validateSerialization>:
    e9e0:	b5f0      	push	{r4, r5, r6, r7, lr}
    e9e2:	b089      	sub	sp, #36	; 0x24
    e9e4:	2400      	movs	r4, #0
    e9e6:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    e9e8:	2917      	cmp	r1, #23
    e9ea:	602c      	str	r4, [r5, #0]
    e9ec:	d920      	bls.n	ea30 <bsec_Bsec_validateSerialization+0x50>
    e9ee:	4291      	cmp	r1, r2
    e9f0:	d81a      	bhi.n	ea28 <bsec_Bsec_validateSerialization+0x48>
    e9f2:	ac03      	add	r4, sp, #12
    e9f4:	1e42      	subs	r2, r0, #1
    e9f6:	1cc7      	adds	r7, r0, #3
    e9f8:	f812 6f01 	ldrb.w	r6, [r2, #1]!
    e9fc:	f804 6b01 	strb.w	r6, [r4], #1
    ea00:	42ba      	cmp	r2, r7
    ea02:	d1f9      	bne.n	e9f8 <bsec_Bsec_validateSerialization+0x18>
    ea04:	2204      	movs	r2, #4
    ea06:	4604      	mov	r4, r0
    ea08:	460f      	mov	r7, r1
    ea0a:	a802      	add	r0, sp, #8
    ea0c:	a903      	add	r1, sp, #12
    ea0e:	461e      	mov	r6, r3
    ea10:	f02a fae2 	bl	38fd8 <memcpy>
    ea14:	9b02      	ldr	r3, [sp, #8]
    ea16:	4a30      	ldr	r2, [pc, #192]	; (ead8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x78>)
    ea18:	4293      	cmp	r3, r2
    ea1a:	d00d      	beq.n	ea38 <bsec_Bsec_validateSerialization+0x58>
    ea1c:	3301      	adds	r3, #1
    ea1e:	d00b      	beq.n	ea38 <bsec_Bsec_validateSerialization+0x58>
    ea20:	23de      	movs	r3, #222	; 0xde
    ea22:	7033      	strb	r3, [r6, #0]
    ea24:	b009      	add	sp, #36	; 0x24
    ea26:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ea28:	22da      	movs	r2, #218	; 0xda
    ea2a:	701a      	strb	r2, [r3, #0]
    ea2c:	b009      	add	sp, #36	; 0x24
    ea2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ea30:	22db      	movs	r2, #219	; 0xdb
    ea32:	701a      	strb	r2, [r3, #0]
    ea34:	b009      	add	sp, #36	; 0x24
    ea36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ea38:	2208      	movs	r2, #8
    ea3a:	1d21      	adds	r1, r4, #4
    ea3c:	a806      	add	r0, sp, #24
    ea3e:	f02a facb 	bl	38fd8 <memcpy>
    ea42:	2208      	movs	r2, #8
    ea44:	a906      	add	r1, sp, #24
    ea46:	a804      	add	r0, sp, #16
    ea48:	f02a fac6 	bl	38fd8 <memcpy>
    ea4c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
    ea50:	2b00      	cmp	r3, #0
    ea52:	bf08      	it	eq
    ea54:	2a3d      	cmpeq	r2, #61	; 0x3d
    ea56:	d007      	beq.n	ea68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x8>
    ea58:	2b00      	cmp	r3, #0
    ea5a:	bf08      	it	eq
    ea5c:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
    ea60:	d002      	beq.n	ea68 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x8>
    ea62:	23dd      	movs	r3, #221	; 0xdd
    ea64:	7033      	strb	r3, [r6, #0]
    ea66:	e7e1      	b.n	ea2c <bsec_Bsec_validateSerialization+0x4c>
    ea68:	7b22      	ldrb	r2, [r4, #12]
    ea6a:	7b63      	ldrb	r3, [r4, #13]
    ea6c:	f88d 200c 	strb.w	r2, [sp, #12]
    ea70:	7ba2      	ldrb	r2, [r4, #14]
    ea72:	f88d 300d 	strb.w	r3, [sp, #13]
    ea76:	f88d 200e 	strb.w	r2, [sp, #14]
    ea7a:	7be3      	ldrb	r3, [r4, #15]
    ea7c:	f88d 300f 	strb.w	r3, [sp, #15]
    ea80:	a903      	add	r1, sp, #12
    ea82:	a802      	add	r0, sp, #8
    ea84:	2204      	movs	r2, #4
    ea86:	f02a faa7 	bl	38fd8 <memcpy>
    ea8a:	9d02      	ldr	r5, [sp, #8]
    ea8c:	f105 0318 	add.w	r3, r5, #24
    ea90:	42bb      	cmp	r3, r7
    ea92:	d002      	beq.n	ea9a <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x3a>
    ea94:	23d8      	movs	r3, #216	; 0xd8
    ea96:	7033      	strb	r3, [r6, #0]
    ea98:	e7c8      	b.n	ea2c <bsec_Bsec_validateSerialization+0x4c>
    ea9a:	aa01      	add	r2, sp, #4
    ea9c:	4620      	mov	r0, r4
    ea9e:	f105 0110 	add.w	r1, r5, #16
    eaa2:	f003 f86f 	bl	11b84 <bsec_crcCcitt2>
    eaa6:	1960      	adds	r0, r4, r5
    eaa8:	f89d 2004 	ldrb.w	r2, [sp, #4]
    eaac:	7d03      	ldrb	r3, [r0, #20]
    eaae:	429a      	cmp	r2, r3
    eab0:	d002      	beq.n	eab8 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x58>
    eab2:	23dc      	movs	r3, #220	; 0xdc
    eab4:	7033      	strb	r3, [r6, #0]
    eab6:	e7b9      	b.n	ea2c <bsec_Bsec_validateSerialization+0x4c>
    eab8:	f89d 2005 	ldrb.w	r2, [sp, #5]
    eabc:	7d43      	ldrb	r3, [r0, #21]
    eabe:	429a      	cmp	r2, r3
    eac0:	d1f7      	bne.n	eab2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x52>
    eac2:	7d83      	ldrb	r3, [r0, #22]
    eac4:	2b00      	cmp	r3, #0
    eac6:	d1f4      	bne.n	eab2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x52>
    eac8:	7dc3      	ldrb	r3, [r0, #23]
    eaca:	2b00      	cmp	r3, #0
    eacc:	d1f1      	bne.n	eab2 <CONFIG_SYS_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x52>
    eace:	990e      	ldr	r1, [sp, #56]	; 0x38
    ead0:	2210      	movs	r2, #16
    ead2:	600a      	str	r2, [r1, #0]
    ead4:	7033      	strb	r3, [r6, #0]
    ead6:	e7a9      	b.n	ea2c <bsec_Bsec_validateSerialization+0x4c>
    ead8:	01040704 	.word	0x01040704

0000eadc <bsec_b_Bsec_setHyperConfiguration>:
    eadc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    eae0:	b0bc      	sub	sp, #240	; 0xf0
    eae2:	ab03      	add	r3, sp, #12
    eae4:	ae04      	add	r6, sp, #16
    eae6:	e9cd 3600 	strd	r3, r6, [sp]
    eaea:	4604      	mov	r4, r0
    eaec:	f10d 030b 	add.w	r3, sp, #11
    eaf0:	20fe      	movs	r0, #254	; 0xfe
    eaf2:	460f      	mov	r7, r1
    eaf4:	f002 ff9c 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
    eaf8:	f99d 000b 	ldrsb.w	r0, [sp, #11]
    eafc:	2800      	cmp	r0, #0
    eafe:	d166      	bne.n	ebce <bsec_b_Bsec_setHyperConfiguration+0xf2>
    eb00:	2502      	movs	r5, #2
    eb02:	f504 787c 	add.w	r8, r4, #1008	; 0x3f0
    eb06:	1e6b      	subs	r3, r5, #1
    eb08:	b2db      	uxtb	r3, r3
    eb0a:	3b02      	subs	r3, #2
    eb0c:	2b05      	cmp	r3, #5
    eb0e:	d804      	bhi.n	eb1a <bsec_b_Bsec_setHyperConfiguration+0x3e>
    eb10:	e8df f003 	tbb	[pc, r3]
    eb14:	6b77838a 	.word	0x6b77838a
    eb18:	0e60      	.short	0x0e60
    eb1a:	4631      	mov	r1, r6
    eb1c:	4638      	mov	r0, r7
    eb1e:	f001 f891 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
    eb22:	2d08      	cmp	r5, #8
    eb24:	f884 0457 	strb.w	r0, [r4, #1111]	; 0x457
    eb28:	d008      	beq.n	eb3c <bsec_b_Bsec_setHyperConfiguration+0x60>
    eb2a:	3501      	adds	r5, #1
    eb2c:	b2ed      	uxtb	r5, r5
    eb2e:	e7ea      	b.n	eb06 <bsec_b_Bsec_setHyperConfiguration+0x2a>
    eb30:	4631      	mov	r1, r6
    eb32:	4638      	mov	r0, r7
    eb34:	f000 ffd2 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
    eb38:	f8a4 040e 	strh.w	r0, [r4, #1038]	; 0x40e
    eb3c:	2300      	movs	r3, #0
    eb3e:	f8a4 3410 	strh.w	r3, [r4, #1040]	; 0x410
    eb42:	f204 35ee 	addw	r5, r4, #1006	; 0x3ee
    eb46:	f204 3346 	addw	r3, r4, #838	; 0x346
    eb4a:	f64f 70ff 	movw	r0, #65535	; 0xffff
    eb4e:	f833 2f02 	ldrh.w	r2, [r3, #2]!
    eb52:	4282      	cmp	r2, r0
    eb54:	d005      	beq.n	eb62 <bsec_b_Bsec_setHyperConfiguration+0x86>
    eb56:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
    eb5a:	4291      	cmp	r1, r2
    eb5c:	bf38      	it	cc
    eb5e:	f8a4 2410 	strhcc.w	r2, [r4, #1040]	; 0x410
    eb62:	42ab      	cmp	r3, r5
    eb64:	d1f3      	bne.n	eb4e <bsec_b_Bsec_setHyperConfiguration+0x72>
    eb66:	4834      	ldr	r0, [pc, #208]	; (ec38 <bsec_b_Bsec_setHyperConfiguration+0x15c>)
    eb68:	4d34      	ldr	r5, [pc, #208]	; (ec3c <bsec_b_Bsec_setHyperConfiguration+0x160>)
    eb6a:	4f35      	ldr	r7, [pc, #212]	; (ec40 <bsec_b_Bsec_setHyperConfiguration+0x164>)
    eb6c:	2300      	movs	r3, #0
    eb6e:	2601      	movs	r6, #1
    eb70:	fa40 f203 	asr.w	r2, r0, r3
    eb74:	07d2      	lsls	r2, r2, #31
    eb76:	d516      	bpl.n	eba6 <bsec_b_Bsec_setHyperConfiguration+0xca>
    eb78:	5dd9      	ldrb	r1, [r3, r7]
    eb7a:	5d5a      	ldrb	r2, [r3, r5]
    eb7c:	4429      	add	r1, r5
    eb7e:	f202 12f7 	addw	r2, r2, #503	; 0x1f7
    eb82:	f811 1c01 	ldrb.w	r1, [r1, #-1]
    eb86:	f834 c012 	ldrh.w	ip, [r4, r2, lsl #1]
    eb8a:	eb04 0241 	add.w	r2, r4, r1, lsl #1
    eb8e:	3901      	subs	r1, #1
    eb90:	f8b2 e428 	ldrh.w	lr, [r2, #1064]	; 0x428
    eb94:	45e6      	cmp	lr, ip
    eb96:	bf1c      	itt	ne
    eb98:	1909      	addne	r1, r1, r4
    eb9a:	f881 6446 	strbne.w	r6, [r1, #1094]	; 0x446
    eb9e:	f8a2 c428 	strh.w	ip, [r2, #1064]	; 0x428
    eba2:	f884 645a 	strb.w	r6, [r4, #1114]	; 0x45a
    eba6:	3301      	adds	r3, #1
    eba8:	2b15      	cmp	r3, #21
    ebaa:	d1e1      	bne.n	eb70 <bsec_b_Bsec_setHyperConfiguration+0x94>
    ebac:	f204 4345 	addw	r3, r4, #1093	; 0x445
    ebb0:	f204 4153 	addw	r1, r4, #1107	; 0x453
    ebb4:	2201      	movs	r2, #1
    ebb6:	f803 2f01 	strb.w	r2, [r3, #1]!
    ebba:	428b      	cmp	r3, r1
    ebbc:	d1fb      	bne.n	ebb6 <bsec_b_Bsec_setHyperConfiguration+0xda>
    ebbe:	f894 345a 	ldrb.w	r3, [r4, #1114]	; 0x45a
    ebc2:	b113      	cbz	r3, ebca <bsec_b_Bsec_setHyperConfiguration+0xee>
    ebc4:	4620      	mov	r0, r4
    ebc6:	f7ff fa9f 	bl	e108 <bsec_Bsec_applyUpdateSubscription.part.0>
    ebca:	f99d 000b 	ldrsb.w	r0, [sp, #11]
    ebce:	b03c      	add	sp, #240	; 0xf0
    ebd0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ebd4:	aa0b      	add	r2, sp, #44	; 0x2c
    ebd6:	4631      	mov	r1, r6
    ebd8:	4638      	mov	r0, r7
    ebda:	f001 f93d 	bl	fe58 <bsec_k_Entity_parseAndDeserialize>
    ebde:	221c      	movs	r2, #28
    ebe0:	a90b      	add	r1, sp, #44	; 0x2c
    ebe2:	4640      	mov	r0, r8
    ebe4:	f02a f9f8 	bl	38fd8 <memcpy>
    ebe8:	e79f      	b.n	eb2a <bsec_b_Bsec_setHyperConfiguration+0x4e>
    ebea:	aa12      	add	r2, sp, #72	; 0x48
    ebec:	4631      	mov	r1, r6
    ebee:	4638      	mov	r0, r7
    ebf0:	f001 f8f0 	bl	fdd4 <bsec_j_Entity_parseAndDeserialize>
    ebf4:	a912      	add	r1, sp, #72	; 0x48
    ebf6:	22a8      	movs	r2, #168	; 0xa8
    ebf8:	f504 7052 	add.w	r0, r4, #840	; 0x348
    ebfc:	f02a f9ec 	bl	38fd8 <memcpy>
    ec00:	e793      	b.n	eb2a <bsec_b_Bsec_setHyperConfiguration+0x4e>
    ec02:	aa05      	add	r2, sp, #20
    ec04:	4631      	mov	r1, r6
    ec06:	4638      	mov	r0, r7
    ec08:	f001 f8a2 	bl	fd50 <bsec_i_Entity_parseAndDeserialize>
    ec0c:	a905      	add	r1, sp, #20
    ec0e:	2218      	movs	r2, #24
    ec10:	f204 4012 	addw	r0, r4, #1042	; 0x412
    ec14:	f02a f9e0 	bl	38fd8 <memcpy>
    ec18:	e787      	b.n	eb2a <bsec_b_Bsec_setHyperConfiguration+0x4e>
    ec1a:	4631      	mov	r1, r6
    ec1c:	4638      	mov	r0, r7
    ec1e:	f001 f811 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
    ec22:	f884 0459 	strb.w	r0, [r4, #1113]	; 0x459
    ec26:	e780      	b.n	eb2a <bsec_b_Bsec_setHyperConfiguration+0x4e>
    ec28:	4631      	mov	r1, r6
    ec2a:	4638      	mov	r0, r7
    ec2c:	f001 f80a 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
    ec30:	f884 0458 	strb.w	r0, [r4, #1112]	; 0x458
    ec34:	e779      	b.n	eb2a <bsec_b_Bsec_setHyperConfiguration+0x4e>
    ec36:	bf00      	nop
    ec38:	001279ef 	.word	0x001279ef
    ec3c:	0003ad68 	.word	0x0003ad68
    ec40:	0003ac4c 	.word	0x0003ac4c

0000ec44 <bsec_b_Bsec_setHyperState>:
    ec44:	2903      	cmp	r1, #3
    ec46:	d916      	bls.n	ec76 <bsec_b_Bsec_setHyperState+0x32>
    ec48:	b510      	push	{r4, lr}
    ec4a:	b082      	sub	sp, #8
    ec4c:	7802      	ldrb	r2, [r0, #0]
    ec4e:	7843      	ldrb	r3, [r0, #1]
    ec50:	f88d 2004 	strb.w	r2, [sp, #4]
    ec54:	4604      	mov	r4, r0
    ec56:	2202      	movs	r2, #2
    ec58:	a901      	add	r1, sp, #4
    ec5a:	f10d 0006 	add.w	r0, sp, #6
    ec5e:	f88d 3005 	strb.w	r3, [sp, #5]
    ec62:	f02a f9b9 	bl	38fd8 <memcpy>
    ec66:	78a3      	ldrb	r3, [r4, #2]
    ec68:	2bfe      	cmp	r3, #254	; 0xfe
    ec6a:	bf0c      	ite	eq
    ec6c:	2000      	moveq	r0, #0
    ec6e:	f06f 0063 	mvnne.w	r0, #99	; 0x63
    ec72:	b002      	add	sp, #8
    ec74:	bd10      	pop	{r4, pc}
    ec76:	f06f 0067 	mvn.w	r0, #103	; 0x67
    ec7a:	4770      	bx	lr

0000ec7c <bsec_ChannelHub_isChannelReady.part.0>:
    ec7c:	3901      	subs	r1, #1
    ec7e:	4b19      	ldr	r3, [pc, #100]	; (ece4 <bsec_ChannelHub_isChannelReady.part.0+0x68>)
    ec80:	5c5b      	ldrb	r3, [r3, r1]
    ec82:	eb00 0343 	add.w	r3, r0, r3, lsl #1
    ec86:	b470      	push	{r4, r5, r6}
    ec88:	f8b3 429a 	ldrh.w	r4, [r3, #666]	; 0x29a
    ec8c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ec90:	4294      	cmp	r4, r2
    ec92:	d006      	beq.n	eca2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
    ec94:	4a14      	ldr	r2, [pc, #80]	; (ece8 <bsec_ChannelHub_isChannelReady.part.0+0x6c>)
    ec96:	f8d0 4298 	ldr.w	r4, [r0, #664]	; 0x298
    ec9a:	f932 2011 	ldrsh.w	r2, [r2, r1, lsl #1]
    ec9e:	43a2      	bics	r2, r4
    eca0:	d002      	beq.n	eca8 <bsec_ChannelHub_isChannelReady.part.0+0x2c>
    eca2:	2000      	movs	r0, #0
    eca4:	bc70      	pop	{r4, r5, r6}
    eca6:	4770      	bx	lr
    eca8:	4a10      	ldr	r2, [pc, #64]	; (ecec <bsec_ChannelHub_isChannelReady.part.0+0x70>)
    ecaa:	f8d0 5280 	ldr.w	r5, [r0, #640]	; 0x280
    ecae:	5652      	ldrsb	r2, [r2, r1]
    ecb0:	43aa      	bics	r2, r5
    ecb2:	d1f6      	bne.n	eca2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
    ecb4:	f8b3 52de 	ldrh.w	r5, [r3, #734]	; 0x2de
    ecb8:	f8b3 62d2 	ldrh.w	r6, [r3, #722]	; 0x2d2
    ecbc:	1c6a      	adds	r2, r5, #1
    ecbe:	b295      	uxth	r5, r2
    ecc0:	fbb5 f2f6 	udiv	r2, r5, r6
    ecc4:	fb06 5212 	mls	r2, r6, r2, r5
    ecc8:	b292      	uxth	r2, r2
    ecca:	f8a3 22de 	strh.w	r2, [r3, #734]	; 0x2de
    ecce:	2a00      	cmp	r2, #0
    ecd0:	d1e7      	bne.n	eca2 <bsec_ChannelHub_isChannelReady.part.0+0x26>
    ecd2:	2201      	movs	r2, #1
    ecd4:	fa02 f301 	lsl.w	r3, r2, r1
    ecd8:	4323      	orrs	r3, r4
    ecda:	f8c0 3298 	str.w	r3, [r0, #664]	; 0x298
    ecde:	4610      	mov	r0, r2
    ece0:	e7e0      	b.n	eca4 <bsec_ChannelHub_isChannelReady.part.0+0x28>
    ece2:	bf00      	nop
    ece4:	0003acdc 	.word	0x0003acdc
    ece8:	0003acbc 	.word	0x0003acbc
    ecec:	0003acd0 	.word	0x0003acd0

0000ecf0 <bsec_ChannelHub_ChannelHub>:
    ecf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ecf2:	4604      	mov	r4, r0
    ecf4:	f001 fff6 	bl	10ce4 <bsec_GasHumidityPreProcessor_GasHumidityPreProcessor>
    ecf8:	f504 7098 	add.w	r0, r4, #304	; 0x130
    ecfc:	f002 fcbc 	bl	11678 <bsec_SensorStatusTracker_SensorStatusTracker>
    ed00:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    ed04:	f002 fa02 	bl	1110c <bsec_IaqEstimator_IaqEstimator>
    ed08:	f104 0068 	add.w	r0, r4, #104	; 0x68
    ed0c:	f001 faaa 	bl	10264 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker>
    ed10:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    ed14:	f7fd fdfc 	bl	c910 <bsec_SensorHeatCompensator_SensorHeatCompensator>
    ed18:	210a      	movs	r1, #10
    ed1a:	f504 70b0 	add.w	r0, r4, #352	; 0x160
    ed1e:	f002 f8b9 	bl	10e94 <bsec_HumidityTemperatureCorrector_HumidityTemperatureCorrector>
    ed22:	2600      	movs	r6, #0
    ed24:	f504 730a 	add.w	r3, r4, #552	; 0x228
    ed28:	f504 72bc 	add.w	r2, r4, #376	; 0x178
    ed2c:	f504 7512 	add.w	r5, r4, #584	; 0x248
    ed30:	2000      	movs	r0, #0
    ed32:	2100      	movs	r1, #0
    ed34:	f843 6b04 	str.w	r6, [r3], #4
    ed38:	42ab      	cmp	r3, r5
    ed3a:	e8e2 0102 	strd	r0, r1, [r2], #8
    ed3e:	d1f9      	bne.n	ed34 <bsec_ChannelHub_ChannelHub+0x44>
    ed40:	2000      	movs	r0, #0
    ed42:	f04f 0c00 	mov.w	ip, #0
    ed46:	f8c4 0280 	str.w	r0, [r4, #640]	; 0x280
    ed4a:	f504 71d8 	add.w	r1, r4, #432	; 0x1b0
    ed4e:	f204 2283 	addw	r2, r4, #643	; 0x283
    ed52:	f504 7520 	add.w	r5, r4, #640	; 0x280
    ed56:	2600      	movs	r6, #0
    ed58:	2700      	movs	r7, #0
    ed5a:	f843 cb04 	str.w	ip, [r3], #4
    ed5e:	42ab      	cmp	r3, r5
    ed60:	e9e1 6702 	strd	r6, r7, [r1, #8]!
    ed64:	f802 0f01 	strb.w	r0, [r2, #1]!
    ed68:	d1f7      	bne.n	ed5a <bsec_ChannelHub_ChannelHub+0x6a>
    ed6a:	f8c4 0294 	str.w	r0, [r4, #660]	; 0x294
    ed6e:	f8c4 0298 	str.w	r0, [r4, #664]	; 0x298
    ed72:	f504 7327 	add.w	r3, r4, #668	; 0x29c
    ed76:	f504 752a 	add.w	r5, r4, #680	; 0x2a8
    ed7a:	2001      	movs	r0, #1
    ed7c:	2100      	movs	r1, #0
    ed7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ed82:	8718      	strh	r0, [r3, #56]	; 0x38
    ed84:	f8a3 1044 	strh.w	r1, [r3, #68]	; 0x44
    ed88:	f823 2b02 	strh.w	r2, [r3], #2
    ed8c:	429d      	cmp	r5, r3
    ed8e:	d1f8      	bne.n	ed82 <bsec_ChannelHub_ChannelHub+0x92>
    ed90:	f8a4 22a8 	strh.w	r2, [r4, #680]	; 0x2a8
    ed94:	f8a4 22aa 	strh.w	r2, [r4, #682]	; 0x2aa
    ed98:	f8a4 22ac 	strh.w	r2, [r4, #684]	; 0x2ac
    ed9c:	f8a4 22ae 	strh.w	r2, [r4, #686]	; 0x2ae
    eda0:	f8a4 22b0 	strh.w	r2, [r4, #688]	; 0x2b0
    eda4:	f8a4 22b2 	strh.w	r2, [r4, #690]	; 0x2b2
    eda8:	f8a4 22b4 	strh.w	r2, [r4, #692]	; 0x2b4
    edac:	f8a4 22b6 	strh.w	r2, [r4, #694]	; 0x2b6
    edb0:	f204 23b6 	addw	r3, r4, #694	; 0x2b6
    edb4:	f204 21d2 	addw	r1, r4, #722	; 0x2d2
    edb8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    edbc:	f823 2f02 	strh.w	r2, [r3, #2]!
    edc0:	428b      	cmp	r3, r1
    edc2:	d1fb      	bne.n	edbc <bsec_ChannelHub_ChannelHub+0xcc>
    edc4:	4620      	mov	r0, r4
    edc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000edc8 <bsec_ChannelHub_configureChannel>:
    edc8:	b410      	push	{r4}
    edca:	1e4c      	subs	r4, r1, #1
    edcc:	4611      	mov	r1, r2
    edce:	2c09      	cmp	r4, #9
    edd0:	d82b      	bhi.n	ee2a <bsec_ChannelHub_configureChannel+0x62>
    edd2:	e8df f004 	tbb	[pc, r4]
    edd6:	110b      	.short	0x110b
    edd8:	2a232a17 	.word	0x2a232a17
    eddc:	1c052a2a 	.word	0x1c052a2a
    ede0:	461a      	mov	r2, r3
    ede2:	30c8      	adds	r0, #200	; 0xc8
    ede4:	f85d 4b04 	ldr.w	r4, [sp], #4
    ede8:	f7fd bdda 	b.w	c9a0 <bsec_SensorHeatCompensator_configure>
    edec:	461a      	mov	r2, r3
    edee:	3068      	adds	r0, #104	; 0x68
    edf0:	f85d 4b04 	ldr.w	r4, [sp], #4
    edf4:	f001 ba72 	b.w	102dc <bsec_GasHumidityBaselineTracker_configure>
    edf8:	461a      	mov	r2, r3
    edfa:	302c      	adds	r0, #44	; 0x2c
    edfc:	f85d 4b04 	ldr.w	r4, [sp], #4
    ee00:	f002 bbda 	b.w	115b8 <bsec_b_IaqEstimator_configure>
    ee04:	461a      	mov	r2, r3
    ee06:	f85d 4b04 	ldr.w	r4, [sp], #4
    ee0a:	f001 bf77 	b.w	10cfc <bsec_GasHumidityPreProcessor_configure>
    ee0e:	461a      	mov	r2, r3
    ee10:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    ee14:	f85d 4b04 	ldr.w	r4, [sp], #4
    ee18:	f002 b848 	b.w	10eac <bsec_HumidityTemperatureCorrector_configure>
    ee1c:	461a      	mov	r2, r3
    ee1e:	f500 7098 	add.w	r0, r0, #304	; 0x130
    ee22:	f85d 4b04 	ldr.w	r4, [sp], #4
    ee26:	f002 bde1 	b.w	119ec <bsec_b_SensorStatusTracker_configure>
    ee2a:	f06f 0063 	mvn.w	r0, #99	; 0x63
    ee2e:	f85d 4b04 	ldr.w	r4, [sp], #4
    ee32:	4770      	bx	lr

0000ee34 <bsec_ChannelHub_do>:
    ee34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    ee38:	ed2d 8b02 	vpush	{d8}
    ee3c:	2300      	movs	r3, #0
    ee3e:	b09b      	sub	sp, #108	; 0x6c
    ee40:	ed9f 8aae 	vldr	s16, [pc, #696]	; f0fc <bsec_ChannelHub_do+0x2c8>
    ee44:	f8c0 3298 	str.w	r3, [r0, #664]	; 0x298
    ee48:	2105      	movs	r1, #5
    ee4a:	4604      	mov	r4, r0
    ee4c:	f88d 3012 	strb.w	r3, [sp, #18]
    ee50:	f88d 3013 	strb.w	r3, [sp, #19]
    ee54:	ed8d 8a05 	vstr	s16, [sp, #20]
    ee58:	ed8d 8a06 	vstr	s16, [sp, #24]
    ee5c:	ed8d 8a07 	vstr	s16, [sp, #28]
    ee60:	ed8d 8a14 	vstr	s16, [sp, #80]	; 0x50
    ee64:	ed8d 8a15 	vstr	s16, [sp, #84]	; 0x54
    ee68:	ed8d 8a16 	vstr	s16, [sp, #88]	; 0x58
    ee6c:	ed8d 8a17 	vstr	s16, [sp, #92]	; 0x5c
    ee70:	ed8d 8a18 	vstr	s16, [sp, #96]	; 0x60
    ee74:	ed8d 8a19 	vstr	s16, [sp, #100]	; 0x64
    ee78:	ed8d 8a08 	vstr	s16, [sp, #32]
    ee7c:	ed8d 8a09 	vstr	s16, [sp, #36]	; 0x24
    ee80:	f7ff fefc 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    ee84:	2800      	cmp	r0, #0
    ee86:	f000 8090 	beq.w	efaa <bsec_ChannelHub_do+0x176>
    ee8a:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    ee8e:	eef4 7a48 	vcmp.f32	s15, s16
    ee92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ee96:	f000 8135 	beq.w	f104 <bsec_ChannelHub_do+0x2d0>
    ee9a:	2103      	movs	r1, #3
    ee9c:	4620      	mov	r0, r4
    ee9e:	4d98      	ldr	r5, [pc, #608]	; (f100 <bsec_ChannelHub_do+0x2cc>)
    eea0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    eea4:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
    eea8:	f7ff fee8 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    eeac:	2800      	cmp	r0, #0
    eeae:	f040 8088 	bne.w	efc2 <bsec_ChannelHub_do+0x18e>
    eeb2:	2101      	movs	r1, #1
    eeb4:	4620      	mov	r0, r4
    eeb6:	f7ff fee1 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    eeba:	b138      	cbz	r0, eecc <bsec_ChannelHub_do+0x98>
    eebc:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    eec0:	eef5 7a40 	vcmp.f32	s15, #0.0
    eec4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    eec8:	f000 8179 	beq.w	f1be <bsec_ChannelHub_do+0x38a>
    eecc:	2102      	movs	r1, #2
    eece:	4620      	mov	r0, r4
    eed0:	f7ff fed4 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    eed4:	b138      	cbz	r0, eee6 <bsec_ChannelHub_do+0xb2>
    eed6:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    eeda:	eef5 7a40 	vcmp.f32	s15, #0.0
    eede:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    eee2:	f000 81ab 	beq.w	f23c <bsec_ChannelHub_do+0x408>
    eee6:	2109      	movs	r1, #9
    eee8:	4620      	mov	r0, r4
    eeea:	f7ff fec7 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    eeee:	b138      	cbz	r0, ef00 <bsec_ChannelHub_do+0xcc>
    eef0:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    eef4:	eef5 7a40 	vcmp.f32	s15, #0.0
    eef8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    eefc:	f000 8250 	beq.w	f3a0 <bsec_ChannelHub_do+0x56c>
    ef00:	ed9f 8a7e 	vldr	s16, [pc, #504]	; f0fc <bsec_ChannelHub_do+0x2c8>
    ef04:	210a      	movs	r1, #10
    ef06:	4620      	mov	r0, r4
    ef08:	f7ff feb8 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    ef0c:	b138      	cbz	r0, ef1e <bsec_ChannelHub_do+0xea>
    ef0e:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    ef12:	eef5 7a40 	vcmp.f32	s15, #0.0
    ef16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    ef1a:	f000 8274 	beq.w	f406 <bsec_ChannelHub_do+0x5d2>
    ef1e:	796b      	ldrb	r3, [r5, #5]
    ef20:	f203 115b 	addw	r1, r3, #347	; 0x15b
    ef24:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ef28:	f834 1011 	ldrh.w	r1, [r4, r1, lsl #1]
    ef2c:	4291      	cmp	r1, r2
    ef2e:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
    ef32:	d004      	beq.n	ef3e <bsec_ChannelHub_do+0x10a>
    ef34:	f8d4 2280 	ldr.w	r2, [r4, #640]	; 0x280
    ef38:	0757      	lsls	r7, r2, #29
    ef3a:	f100 80bd 	bmi.w	f0b8 <bsec_ChannelHub_do+0x284>
    ef3e:	79ab      	ldrb	r3, [r5, #6]
    ef40:	f203 115b 	addw	r1, r3, #347	; 0x15b
    ef44:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ef48:	f834 1011 	ldrh.w	r1, [r4, r1, lsl #1]
    ef4c:	4291      	cmp	r1, r2
    ef4e:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
    ef52:	d004      	beq.n	ef5e <bsec_ChannelHub_do+0x12a>
    ef54:	f8d4 2280 	ldr.w	r2, [r4, #640]	; 0x280
    ef58:	07d0      	lsls	r0, r2, #31
    ef5a:	f100 808b 	bmi.w	f074 <bsec_ChannelHub_do+0x240>
    ef5e:	79eb      	ldrb	r3, [r5, #7]
    ef60:	f203 115b 	addw	r1, r3, #347	; 0x15b
    ef64:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ef68:	f834 1011 	ldrh.w	r1, [r4, r1, lsl #1]
    ef6c:	4291      	cmp	r1, r2
    ef6e:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
    ef72:	d003      	beq.n	ef7c <bsec_ChannelHub_do+0x148>
    ef74:	f8d4 2280 	ldr.w	r2, [r4, #640]	; 0x280
    ef78:	0791      	lsls	r1, r2, #30
    ef7a:	d459      	bmi.n	f030 <bsec_ChannelHub_do+0x1fc>
    ef7c:	7a2b      	ldrb	r3, [r5, #8]
    ef7e:	f203 115b 	addw	r1, r3, #347	; 0x15b
    ef82:	f64f 72ff 	movw	r2, #65535	; 0xffff
    ef86:	f834 1011 	ldrh.w	r1, [r4, r1, lsl #1]
    ef8a:	4291      	cmp	r1, r2
    ef8c:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
    ef90:	d003      	beq.n	ef9a <bsec_ChannelHub_do+0x166>
    ef92:	f8d4 2280 	ldr.w	r2, [r4, #640]	; 0x280
    ef96:	0712      	lsls	r2, r2, #28
    ef98:	d428      	bmi.n	efec <bsec_ChannelHub_do+0x1b8>
    ef9a:	2300      	movs	r3, #0
    ef9c:	f8c4 3280 	str.w	r3, [r4, #640]	; 0x280
    efa0:	b01b      	add	sp, #108	; 0x6c
    efa2:	ecbd 8b02 	vpop	{d8}
    efa6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    efaa:	4d55      	ldr	r5, [pc, #340]	; (f100 <bsec_ChannelHub_do+0x2cc>)
    efac:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
    efb0:	f06f 4700 	mvn.w	r7, #2147483648	; 0x80000000
    efb4:	2103      	movs	r1, #3
    efb6:	4620      	mov	r0, r4
    efb8:	f7ff fe60 	bl	ec7c <bsec_ChannelHub_isChannelReady.part.0>
    efbc:	2800      	cmp	r0, #0
    efbe:	f43f af78 	beq.w	eeb2 <bsec_ChannelHub_do+0x7e>
    efc2:	edd4 7a91 	vldr	s15, [r4, #580]	; 0x244
    efc6:	eef5 7a40 	vcmp.f32	s15, #0.0
    efca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    efce:	f47f af70 	bne.w	eeb2 <bsec_ChannelHub_do+0x7e>
    efd2:	ab07      	add	r3, sp, #28
    efd4:	aa06      	add	r2, sp, #24
    efd6:	a905      	add	r1, sp, #20
    efd8:	ed94 1a8b 	vldr	s2, [r4, #556]	; 0x22c
    efdc:	edd4 0a8c 	vldr	s1, [r4, #560]	; 0x230
    efe0:	ed94 0a8d 	vldr	s0, [r4, #564]	; 0x234
    efe4:	4620      	mov	r0, r4
    efe6:	f001 fea3 	bl	10d30 <bsec_GasHumidityPreProcessor_doStep>
    efea:	e762      	b.n	eeb2 <bsec_ChannelHub_do+0x7e>
    efec:	f504 72c8 	add.w	r2, r4, #400	; 0x190
    eff0:	e9d2 0100 	ldrd	r0, r1, [r2]
    eff4:	f103 0236 	add.w	r2, r3, #54	; 0x36
    eff8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    effc:	f8d4 6234 	ldr.w	r6, [r4, #564]	; 0x234
    f000:	f8c3 6244 	str.w	r6, [r3, #580]	; 0x244
    f004:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f008:	ed9f 0a3c 	vldr	s0, [pc, #240]	; f0fc <bsec_ChannelHub_do+0x2c8>
    f00c:	e9c2 0100 	strd	r0, r1, [r2]
    f010:	f020 fa76 	bl	2f500 <roundf>
    f014:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f018:	4425      	add	r5, r4
    f01a:	ee17 3a90 	vmov	r3, s15
    f01e:	f885 3284 	strb.w	r3, [r5, #644]	; 0x284
    f022:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f026:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    f02a:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f02e:	e7b4      	b.n	ef9a <bsec_ChannelHub_do+0x166>
    f030:	f504 72c0 	add.w	r2, r4, #384	; 0x180
    f034:	e9d2 0100 	ldrd	r0, r1, [r2]
    f038:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f03c:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    f040:	f8d4 722c 	ldr.w	r7, [r4, #556]	; 0x22c
    f044:	f8c3 7244 	str.w	r7, [r3, #580]	; 0x244
    f048:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f04c:	ed9f 0a2b 	vldr	s0, [pc, #172]	; f0fc <bsec_ChannelHub_do+0x2c8>
    f050:	e9c2 0100 	strd	r0, r1, [r2]
    f054:	f020 fa54 	bl	2f500 <roundf>
    f058:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f05c:	4426      	add	r6, r4
    f05e:	ee17 3a90 	vmov	r3, s15
    f062:	f886 3284 	strb.w	r3, [r6, #644]	; 0x284
    f066:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f06a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    f06e:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f072:	e783      	b.n	ef7c <bsec_ChannelHub_do+0x148>
    f074:	f504 72bc 	add.w	r2, r4, #376	; 0x178
    f078:	e9d2 0100 	ldrd	r0, r1, [r2]
    f07c:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f080:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    f084:	f8d4 7228 	ldr.w	r7, [r4, #552]	; 0x228
    f088:	f8c3 7244 	str.w	r7, [r3, #580]	; 0x244
    f08c:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f090:	ed9f 0a1a 	vldr	s0, [pc, #104]	; f0fc <bsec_ChannelHub_do+0x2c8>
    f094:	e9c2 0100 	strd	r0, r1, [r2]
    f098:	f020 fa32 	bl	2f500 <roundf>
    f09c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f0a0:	4426      	add	r6, r4
    f0a2:	ee17 3a90 	vmov	r3, s15
    f0a6:	f886 3284 	strb.w	r3, [r6, #644]	; 0x284
    f0aa:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f0ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    f0b2:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f0b6:	e752      	b.n	ef5e <bsec_ChannelHub_do+0x12a>
    f0b8:	f504 72c4 	add.w	r2, r4, #392	; 0x188
    f0bc:	e9d2 0100 	ldrd	r0, r1, [r2]
    f0c0:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f0c4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
    f0c8:	f8d4 7230 	ldr.w	r7, [r4, #560]	; 0x230
    f0cc:	f8c3 7244 	str.w	r7, [r3, #580]	; 0x244
    f0d0:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f0d4:	ed9f 0a09 	vldr	s0, [pc, #36]	; f0fc <bsec_ChannelHub_do+0x2c8>
    f0d8:	e9c2 0100 	strd	r0, r1, [r2]
    f0dc:	f020 fa10 	bl	2f500 <roundf>
    f0e0:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f0e4:	4426      	add	r6, r4
    f0e6:	ee17 3a90 	vmov	r3, s15
    f0ea:	f886 3284 	strb.w	r3, [r6, #644]	; 0x284
    f0ee:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f0f2:	f043 0320 	orr.w	r3, r3, #32
    f0f6:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f0fa:	e720      	b.n	ef3e <bsec_ChannelHub_do+0x10a>
    f0fc:	00000000 	.word	0x00000000
    f100:	0003ad68 	.word	0x0003ad68
    f104:	f504 73c8 	add.w	r3, r4, #400	; 0x190
    f108:	e9d3 6700 	ldrd	r6, r7, [r3]
    f10c:	f10d 0112 	add.w	r1, sp, #18
    f110:	ab09      	add	r3, sp, #36	; 0x24
    f112:	f10d 0013 	add.w	r0, sp, #19
    f116:	e9cd 1000 	strd	r1, r0, [sp]
    f11a:	9302      	str	r3, [sp, #8]
    f11c:	f504 7098 	add.w	r0, r4, #304	; 0x130
    f120:	4632      	mov	r2, r6
    f122:	463b      	mov	r3, r7
    f124:	f002 fac4 	bl	116b0 <bsec_SensorStatusTracker_doStep>
    f128:	4dcf      	ldr	r5, [pc, #828]	; (f468 <bsec_ChannelHub_do+0x634>)
    f12a:	f89d 2012 	ldrb.w	r2, [sp, #18]
    f12e:	7aeb      	ldrb	r3, [r5, #11]
    f130:	ee07 2a90 	vmov	s15, r2
    f134:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f138:	eef8 7a67 	vcvt.f32.u32	s15, s15
    f13c:	eb04 0183 	add.w	r1, r4, r3, lsl #2
    f140:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f144:	edc1 7a91 	vstr	s15, [r1, #580]	; 0x244
    f148:	eeb0 0a48 	vmov.f32	s0, s16
    f14c:	e9c2 6700 	strd	r6, r7, [r2]
    f150:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f154:	f020 f9d4 	bl	2f500 <roundf>
    f158:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f15c:	44a0      	add	r8, r4
    f15e:	ee17 2a90 	vmov	r2, s15
    f162:	f888 2284 	strb.w	r2, [r8, #644]	; 0x284
    f166:	f89d 2013 	ldrb.w	r2, [sp, #19]
    f16a:	7b2b      	ldrb	r3, [r5, #12]
    f16c:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
    f170:	ee07 2a90 	vmov	s15, r2
    f174:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f178:	eef8 7a67 	vcvt.f32.u32	s15, s15
    f17c:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f180:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    f184:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
    f188:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
    f18c:	eeb0 0a48 	vmov.f32	s0, s16
    f190:	edc0 7a91 	vstr	s15, [r0, #580]	; 0x244
    f194:	e9c2 6700 	strd	r6, r7, [r2]
    f198:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f19c:	f020 f9b0 	bl	2f500 <roundf>
    f1a0:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f1a4:	eb04 0308 	add.w	r3, r4, r8
    f1a8:	ee17 2a90 	vmov	r2, s15
    f1ac:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    f1b0:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f1b4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    f1b8:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f1bc:	e6fa      	b.n	efb4 <bsec_ChannelHub_do+0x180>
    f1be:	edd4 7a8f 	vldr	s15, [r4, #572]	; 0x23c
    f1c2:	edd4 1a90 	vldr	s3, [r4, #576]	; 0x240
    f1c6:	f89d 2013 	ldrb.w	r2, [sp, #19]
    f1ca:	f89d 1012 	ldrb.w	r1, [sp, #18]
    f1ce:	ed9d 1a07 	vldr	s2, [sp, #28]
    f1d2:	eddd 0a06 	vldr	s1, [sp, #24]
    f1d6:	ed9d 0a05 	vldr	s0, [sp, #20]
    f1da:	eef5 7a40 	vcmp.f32	s15, #0.0
    f1de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    f1e2:	f10d 0c20 	add.w	ip, sp, #32
    f1e6:	a814      	add	r0, sp, #80	; 0x50
    f1e8:	bf14      	ite	ne
    f1ea:	2301      	movne	r3, #1
    f1ec:	2300      	moveq	r3, #0
    f1ee:	e9cd 0c00 	strd	r0, ip, [sp]
    f1f2:	f104 0068 	add.w	r0, r4, #104	; 0x68
    f1f6:	f001 f8cd 	bl	10394 <bsec_GasHumidityBaselineTracker_doStep>
    f1fa:	7c6b      	ldrb	r3, [r5, #17]
    f1fc:	9808      	ldr	r0, [sp, #32]
    f1fe:	ed9f 0a9b 	vldr	s0, [pc, #620]	; f46c <bsec_ChannelHub_do+0x638>
    f202:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f206:	eb04 0183 	add.w	r1, r4, r3, lsl #2
    f20a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f20e:	f8c1 0244 	str.w	r0, [r1, #580]	; 0x244
    f212:	e9c2 6700 	strd	r6, r7, [r2]
    f216:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f21a:	f020 f971 	bl	2f500 <roundf>
    f21e:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f222:	eb04 0308 	add.w	r3, r4, r8
    f226:	ee17 2a90 	vmov	r2, s15
    f22a:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    f22e:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f232:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
    f236:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f23a:	e647      	b.n	eecc <bsec_ChannelHub_do+0x98>
    f23c:	a912      	add	r1, sp, #72	; 0x48
    f23e:	aa10      	add	r2, sp, #64	; 0x40
    f240:	ab0e      	add	r3, sp, #56	; 0x38
    f242:	eddd 0a09 	vldr	s1, [sp, #36]	; 0x24
    f246:	ed9d 0a08 	vldr	s0, [sp, #32]
    f24a:	9300      	str	r3, [sp, #0]
    f24c:	e9cd 2101 	strd	r2, r1, [sp, #4]
    f250:	ab0c      	add	r3, sp, #48	; 0x30
    f252:	aa0a      	add	r2, sp, #40	; 0x28
    f254:	a914      	add	r1, sp, #80	; 0x50
    f256:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    f25a:	f001 ff87 	bl	1116c <bsec_IaqEstimator_doStep>
    f25e:	782b      	ldrb	r3, [r5, #0]
    f260:	980a      	ldr	r0, [sp, #40]	; 0x28
    f262:	ed9d 0a0b 	vldr	s0, [sp, #44]	; 0x2c
    f266:	eb04 0183 	add.w	r1, r4, r3, lsl #2
    f26a:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f26e:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f272:	f8c1 0244 	str.w	r0, [r1, #580]	; 0x244
    f276:	e9c2 6700 	strd	r6, r7, [r2]
    f27a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f27e:	f020 f93f 	bl	2f500 <roundf>
    f282:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f286:	44a0      	add	r8, r4
    f288:	ee17 2a90 	vmov	r2, s15
    f28c:	786b      	ldrb	r3, [r5, #1]
    f28e:	f888 2284 	strb.w	r2, [r8, #644]	; 0x284
    f292:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
    f296:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    f29a:	ed9d 0a0d 	vldr	s0, [sp, #52]	; 0x34
    f29e:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    f2a2:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f2a6:	f041 0101 	orr.w	r1, r1, #1
    f2aa:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f2ae:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
    f2b2:	f8c0 c244 	str.w	ip, [r0, #580]	; 0x244
    f2b6:	e9c2 6700 	strd	r6, r7, [r2]
    f2ba:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f2be:	f020 f91f 	bl	2f500 <roundf>
    f2c2:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f2c6:	44a0      	add	r8, r4
    f2c8:	ee17 2a90 	vmov	r2, s15
    f2cc:	78ab      	ldrb	r3, [r5, #2]
    f2ce:	f888 2284 	strb.w	r2, [r8, #644]	; 0x284
    f2d2:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
    f2d6:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    f2da:	ed9d 0a0f 	vldr	s0, [sp, #60]	; 0x3c
    f2de:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    f2e2:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f2e6:	f041 0102 	orr.w	r1, r1, #2
    f2ea:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f2ee:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
    f2f2:	f8c0 c244 	str.w	ip, [r0, #580]	; 0x244
    f2f6:	e9c2 6700 	strd	r6, r7, [r2]
    f2fa:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f2fe:	f020 f8ff 	bl	2f500 <roundf>
    f302:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f306:	44a0      	add	r8, r4
    f308:	ee17 2a90 	vmov	r2, s15
    f30c:	78eb      	ldrb	r3, [r5, #3]
    f30e:	f888 2284 	strb.w	r2, [r8, #644]	; 0x284
    f312:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
    f316:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    f31a:	ed9d 0a11 	vldr	s0, [sp, #68]	; 0x44
    f31e:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    f322:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f326:	f041 0104 	orr.w	r1, r1, #4
    f32a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f32e:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
    f332:	f8c0 c244 	str.w	ip, [r0, #580]	; 0x244
    f336:	e9c2 6700 	strd	r6, r7, [r2]
    f33a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f33e:	f020 f8df 	bl	2f500 <roundf>
    f342:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f346:	44a0      	add	r8, r4
    f348:	ee17 2a90 	vmov	r2, s15
    f34c:	7d2b      	ldrb	r3, [r5, #20]
    f34e:	f888 2284 	strb.w	r2, [r8, #644]	; 0x284
    f352:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
    f356:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
    f35a:	ed9d 0a13 	vldr	s0, [sp, #76]	; 0x4c
    f35e:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f362:	eb04 0083 	add.w	r0, r4, r3, lsl #2
    f366:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f36a:	f041 0108 	orr.w	r1, r1, #8
    f36e:	f8c4 1294 	str.w	r1, [r4, #660]	; 0x294
    f372:	f8c0 c244 	str.w	ip, [r0, #580]	; 0x244
    f376:	e9c2 6700 	strd	r6, r7, [r2]
    f37a:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
    f37e:	f020 f8bf 	bl	2f500 <roundf>
    f382:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f386:	eb04 0308 	add.w	r3, r4, r8
    f38a:	ee17 2a90 	vmov	r2, s15
    f38e:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    f392:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f396:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    f39a:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f39e:	e5a2      	b.n	eee6 <bsec_ChannelHub_do+0xb2>
    f3a0:	f504 73c4 	add.w	r3, r4, #392	; 0x188
    f3a4:	e9d3 8900 	ldrd	r8, r9, [r3]
    f3a8:	f8b4 306a 	ldrh.w	r3, [r4, #106]	; 0x6a
    f3ac:	edd4 0a8e 	vldr	s1, [r4, #568]	; 0x238
    f3b0:	ed94 0a8c 	vldr	s0, [r4, #560]	; 0x230
    f3b4:	9302      	str	r3, [sp, #8]
    f3b6:	4632      	mov	r2, r6
    f3b8:	463b      	mov	r3, r7
    f3ba:	f104 00c8 	add.w	r0, r4, #200	; 0xc8
    f3be:	e9cd 8900 	strd	r8, r9, [sp]
    f3c2:	f7fd fb37 	bl	ca34 <bsec_SensorHeatCompensator_doStep>
    f3c6:	7b6b      	ldrb	r3, [r5, #13]
    f3c8:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f3cc:	eb04 0183 	add.w	r1, r4, r3, lsl #2
    f3d0:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f3d4:	eeb0 8a40 	vmov.f32	s16, s0
    f3d8:	ed81 8a91 	vstr	s16, [r1, #580]	; 0x244
    f3dc:	ed9f 0a23 	vldr	s0, [pc, #140]	; f46c <bsec_ChannelHub_do+0x638>
    f3e0:	e9c2 8900 	strd	r8, r9, [r2]
    f3e4:	1e5e      	subs	r6, r3, #1
    f3e6:	f020 f88b 	bl	2f500 <roundf>
    f3ea:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f3ee:	19a3      	adds	r3, r4, r6
    f3f0:	ee17 2a90 	vmov	r2, s15
    f3f4:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    f3f8:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f3fc:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    f400:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f404:	e57e      	b.n	ef04 <bsec_ChannelHub_do+0xd0>
    f406:	f504 73c4 	add.w	r3, r4, #392	; 0x188
    f40a:	eef0 0a48 	vmov.f32	s1, s16
    f40e:	ed94 1a8b 	vldr	s2, [r4, #556]	; 0x22c
    f412:	ed94 0a8c 	vldr	s0, [r4, #560]	; 0x230
    f416:	f504 70b0 	add.w	r0, r4, #352	; 0x160
    f41a:	e9d3 6700 	ldrd	r6, r7, [r3]
    f41e:	f001 fd5f 	bl	10ee0 <bsec_HumidityTemperatureCorrector_doStep>
    f422:	7bab      	ldrb	r3, [r5, #14]
    f424:	f103 0236 	add.w	r2, r3, #54	; 0x36
    f428:	eef0 7a40 	vmov.f32	s15, s0
    f42c:	eb04 0183 	add.w	r1, r4, r3, lsl #2
    f430:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    f434:	edc1 7a91 	vstr	s15, [r1, #580]	; 0x244
    f438:	ed9f 0a0c 	vldr	s0, [pc, #48]	; f46c <bsec_ChannelHub_do+0x638>
    f43c:	edcd 7a05 	vstr	s15, [sp, #20]
    f440:	e9c2 6700 	strd	r6, r7, [r2]
    f444:	1e5e      	subs	r6, r3, #1
    f446:	f020 f85b 	bl	2f500 <roundf>
    f44a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
    f44e:	19a3      	adds	r3, r4, r6
    f450:	ee17 2a90 	vmov	r2, s15
    f454:	f883 2284 	strb.w	r2, [r3, #644]	; 0x284
    f458:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
    f45c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    f460:	f8c4 3294 	str.w	r3, [r4, #660]	; 0x294
    f464:	e55b      	b.n	ef1e <bsec_ChannelHub_do+0xea>
    f466:	bf00      	nop
    f468:	0003ad68 	.word	0x0003ad68
    f46c:	00000000 	.word	0x00000000

0000f470 <bsec_ChannelHub_getChannelConfiguration>:
    f470:	b5f0      	push	{r4, r5, r6, r7, lr}
    f472:	b085      	sub	sp, #20
    f474:	2400      	movs	r4, #0
    f476:	3901      	subs	r1, #1
    f478:	461f      	mov	r7, r3
    f47a:	4606      	mov	r6, r0
    f47c:	4615      	mov	r5, r2
    f47e:	9403      	str	r4, [sp, #12]
    f480:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    f484:	2909      	cmp	r1, #9
    f486:	d85c      	bhi.n	f542 <bsec_ChannelHub_getChannelConfiguration+0xd2>
    f488:	e8df f001 	tbb	[pc, r1]
    f48c:	5b1a130c 	.word	0x5b1a130c
    f490:	5b5b5b53 	.word	0x5b5b5b53
    f494:	4b05      	.short	0x4b05
    f496:	463a      	mov	r2, r7
    f498:	4629      	mov	r1, r5
    f49a:	30c8      	adds	r0, #200	; 0xc8
    f49c:	f7fd fb4e 	bl	cb3c <bsec_SensorHeatCompensator_getConfiguration>
    f4a0:	b005      	add	sp, #20
    f4a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f4a4:	463a      	mov	r2, r7
    f4a6:	4629      	mov	r1, r5
    f4a8:	3068      	adds	r0, #104	; 0x68
    f4aa:	f001 f9bf 	bl	1082c <bsec_GasHumidityBaselineTracker_getConfiguration>
    f4ae:	b005      	add	sp, #20
    f4b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f4b2:	463a      	mov	r2, r7
    f4b4:	4629      	mov	r1, r5
    f4b6:	302c      	adds	r0, #44	; 0x2c
    f4b8:	f001 ff3e 	bl	11338 <bsec_IaqEstimator_getConfiguration>
    f4bc:	b005      	add	sp, #20
    f4be:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f4c0:	aa04      	add	r2, sp, #16
    f4c2:	2401      	movs	r4, #1
    f4c4:	f802 4d09 	strb.w	r4, [r2, #-9]!
    f4c8:	4629      	mov	r1, r5
    f4ca:	7800      	ldrb	r0, [r0, #0]
    f4cc:	f002 fade 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
    f4d0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f4d4:	9003      	str	r0, [sp, #12]
    f4d6:	b1a3      	cbz	r3, f502 <bsec_ChannelHub_getChannelConfiguration+0x92>
    f4d8:	3620      	adds	r6, #32
    f4da:	e003      	b.n	f4e4 <bsec_ChannelHub_getChannelConfiguration+0x74>
    f4dc:	3401      	adds	r4, #1
    f4de:	b2e4      	uxtb	r4, r4
    f4e0:	42a3      	cmp	r3, r4
    f4e2:	d30d      	bcc.n	f500 <bsec_ChannelHub_getChannelConfiguration+0x90>
    f4e4:	2c01      	cmp	r4, #1
    f4e6:	d1f9      	bne.n	f4dc <bsec_ChannelHub_getChannelConfiguration+0x6c>
    f4e8:	ab03      	add	r3, sp, #12
    f4ea:	463a      	mov	r2, r7
    f4ec:	4629      	mov	r1, r5
    f4ee:	4630      	mov	r0, r6
    f4f0:	f000 fa8e 	bl	fa10 <bsec_Entity_serializeAndAdd>
    f4f4:	3401      	adds	r4, #1
    f4f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f4fa:	b2e4      	uxtb	r4, r4
    f4fc:	42a3      	cmp	r3, r4
    f4fe:	d2f1      	bcs.n	f4e4 <bsec_ChannelHub_getChannelConfiguration+0x74>
    f500:	9803      	ldr	r0, [sp, #12]
    f502:	a904      	add	r1, sp, #16
    f504:	2202      	movs	r2, #2
    f506:	f821 0d06 	strh.w	r0, [r1, #-6]!
    f50a:	a802      	add	r0, sp, #8
    f50c:	f029 fd64 	bl	38fd8 <memcpy>
    f510:	f89d 2008 	ldrb.w	r2, [sp, #8]
    f514:	f89d 3009 	ldrb.w	r3, [sp, #9]
    f518:	9803      	ldr	r0, [sp, #12]
    f51a:	702a      	strb	r2, [r5, #0]
    f51c:	706b      	strb	r3, [r5, #1]
    f51e:	b005      	add	sp, #20
    f520:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f522:	463a      	mov	r2, r7
    f524:	4629      	mov	r1, r5
    f526:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    f52a:	f001 fd23 	bl	10f74 <bsec_HumidityTemperatureCorrector_getConfiguration>
    f52e:	b005      	add	sp, #20
    f530:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f532:	463a      	mov	r2, r7
    f534:	4629      	mov	r1, r5
    f536:	f500 7098 	add.w	r0, r0, #304	; 0x130
    f53a:	f002 f93f 	bl	117bc <bsec_SensorStatusTracker_getConfiguration>
    f53e:	b005      	add	sp, #20
    f540:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f542:	2000      	movs	r0, #0
    f544:	e7ac      	b.n	f4a0 <bsec_ChannelHub_getChannelConfiguration+0x30>
    f546:	bf00      	nop

0000f548 <bsec_ChannelHub_getChannelState>:
    f548:	b5f0      	push	{r4, r5, r6, r7, lr}
    f54a:	b085      	sub	sp, #20
    f54c:	2400      	movs	r4, #0
    f54e:	3901      	subs	r1, #1
    f550:	461f      	mov	r7, r3
    f552:	4606      	mov	r6, r0
    f554:	4615      	mov	r5, r2
    f556:	9403      	str	r4, [sp, #12]
    f558:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    f55c:	2909      	cmp	r1, #9
    f55e:	d85c      	bhi.n	f61a <bsec_ChannelHub_getChannelState+0xd2>
    f560:	e8df f001 	tbb	[pc, r1]
    f564:	5b1a130c 	.word	0x5b1a130c
    f568:	5b5b5b53 	.word	0x5b5b5b53
    f56c:	4b05      	.short	0x4b05
    f56e:	463a      	mov	r2, r7
    f570:	4629      	mov	r1, r5
    f572:	30c8      	adds	r0, #200	; 0xc8
    f574:	f7fd fb46 	bl	cc04 <bsec_SensorHeatCompensator_getState>
    f578:	b005      	add	sp, #20
    f57a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f57c:	463a      	mov	r2, r7
    f57e:	4629      	mov	r1, r5
    f580:	3068      	adds	r0, #104	; 0x68
    f582:	f001 f9cd 	bl	10920 <bsec_GasHumidityBaselineTracker_getState>
    f586:	b005      	add	sp, #20
    f588:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f58a:	463a      	mov	r2, r7
    f58c:	4629      	mov	r1, r5
    f58e:	302c      	adds	r0, #44	; 0x2c
    f590:	f001 ff50 	bl	11434 <bsec_IaqEstimator_getState>
    f594:	b005      	add	sp, #20
    f596:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f598:	aa04      	add	r2, sp, #16
    f59a:	2401      	movs	r4, #1
    f59c:	f802 4d09 	strb.w	r4, [r2, #-9]!
    f5a0:	4629      	mov	r1, r5
    f5a2:	7800      	ldrb	r0, [r0, #0]
    f5a4:	f002 fa72 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
    f5a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f5ac:	9003      	str	r0, [sp, #12]
    f5ae:	b1a3      	cbz	r3, f5da <bsec_ChannelHub_getChannelState+0x92>
    f5b0:	3610      	adds	r6, #16
    f5b2:	e003      	b.n	f5bc <bsec_ChannelHub_getChannelState+0x74>
    f5b4:	3401      	adds	r4, #1
    f5b6:	b2e4      	uxtb	r4, r4
    f5b8:	42a3      	cmp	r3, r4
    f5ba:	d30d      	bcc.n	f5d8 <bsec_ChannelHub_getChannelState+0x90>
    f5bc:	2c01      	cmp	r4, #1
    f5be:	d1f9      	bne.n	f5b4 <bsec_ChannelHub_getChannelState+0x6c>
    f5c0:	ab03      	add	r3, sp, #12
    f5c2:	463a      	mov	r2, r7
    f5c4:	4629      	mov	r1, r5
    f5c6:	4630      	mov	r0, r6
    f5c8:	f000 fa22 	bl	fa10 <bsec_Entity_serializeAndAdd>
    f5cc:	3401      	adds	r4, #1
    f5ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f5d2:	b2e4      	uxtb	r4, r4
    f5d4:	42a3      	cmp	r3, r4
    f5d6:	d2f1      	bcs.n	f5bc <bsec_ChannelHub_getChannelState+0x74>
    f5d8:	9803      	ldr	r0, [sp, #12]
    f5da:	a904      	add	r1, sp, #16
    f5dc:	2202      	movs	r2, #2
    f5de:	f821 0d06 	strh.w	r0, [r1, #-6]!
    f5e2:	a802      	add	r0, sp, #8
    f5e4:	f029 fcf8 	bl	38fd8 <memcpy>
    f5e8:	f89d 2008 	ldrb.w	r2, [sp, #8]
    f5ec:	f89d 3009 	ldrb.w	r3, [sp, #9]
    f5f0:	9803      	ldr	r0, [sp, #12]
    f5f2:	702a      	strb	r2, [r5, #0]
    f5f4:	706b      	strb	r3, [r5, #1]
    f5f6:	b005      	add	sp, #20
    f5f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f5fa:	463a      	mov	r2, r7
    f5fc:	4629      	mov	r1, r5
    f5fe:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    f602:	f001 fced 	bl	10fe0 <bsec_HumidityTemperatureCorrector_getState>
    f606:	b005      	add	sp, #20
    f608:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f60a:	463a      	mov	r2, r7
    f60c:	4629      	mov	r1, r5
    f60e:	f500 7098 	add.w	r0, r0, #304	; 0x130
    f612:	f002 f915 	bl	11840 <bsec_SensorStatusTracker_getState>
    f616:	b005      	add	sp, #20
    f618:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f61a:	2000      	movs	r0, #0
    f61c:	e7ac      	b.n	f578 <bsec_ChannelHub_getChannelState+0x30>
    f61e:	bf00      	nop

0000f620 <bsec_ChannelHub_getOutput>:
    f620:	b4f0      	push	{r4, r5, r6, r7}
    f622:	3901      	subs	r1, #1
    f624:	4c0f      	ldr	r4, [pc, #60]	; (f664 <bsec_ChannelHub_getOutput+0x44>)
    f626:	9d04      	ldr	r5, [sp, #16]
    f628:	5c64      	ldrb	r4, [r4, r1]
    f62a:	eb00 0784 	add.w	r7, r0, r4, lsl #2
    f62e:	f104 0636 	add.w	r6, r4, #54	; 0x36
    f632:	f8d7 7244 	ldr.w	r7, [r7, #580]	; 0x244
    f636:	6017      	str	r7, [r2, #0]
    f638:	eb00 06c6 	add.w	r6, r0, r6, lsl #3
    f63c:	e9d6 6700 	ldrd	r6, r7, [r6]
    f640:	e9c3 6700 	strd	r6, r7, [r3]
    f644:	4404      	add	r4, r0
    f646:	2201      	movs	r2, #1
    f648:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
    f64c:	702b      	strb	r3, [r5, #0]
    f64e:	f8d0 3294 	ldr.w	r3, [r0, #660]	; 0x294
    f652:	fa02 f101 	lsl.w	r1, r2, r1
    f656:	ea23 0301 	bic.w	r3, r3, r1
    f65a:	f8c0 3294 	str.w	r3, [r0, #660]	; 0x294
    f65e:	bcf0      	pop	{r4, r5, r6, r7}
    f660:	4770      	bx	lr
    f662:	bf00      	nop
    f664:	0003ad68 	.word	0x0003ad68

0000f668 <bsec_ChannelHub_isOutputValid>:
    f668:	f8d0 0294 	ldr.w	r0, [r0, #660]	; 0x294
    f66c:	3901      	subs	r1, #1
    f66e:	b2c9      	uxtb	r1, r1
    f670:	4108      	asrs	r0, r1
    f672:	f000 0001 	and.w	r0, r0, #1
    f676:	4770      	bx	lr

0000f678 <bsec_ChannelHub_recalculateDownsampling>:
    f678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f67c:	4932      	ldr	r1, [pc, #200]	; (f748 <bsec_ChannelHub_recalculateDownsampling+0xd0>)
    f67e:	f8df a0d4 	ldr.w	sl, [pc, #212]	; f754 <bsec_ChannelHub_recalculateDownsampling+0xdc>
    f682:	4a32      	ldr	r2, [pc, #200]	; (f74c <bsec_ChannelHub_recalculateDownsampling+0xd4>)
    f684:	f8df 90d0 	ldr.w	r9, [pc, #208]	; f758 <bsec_ChannelHub_recalculateDownsampling+0xe0>
    f688:	2500      	movs	r5, #0
    f68a:	f240 3717 	movw	r7, #791	; 0x317
    f68e:	f64f 7cff 	movw	ip, #65535	; 0xffff
    f692:	fa47 f305 	asr.w	r3, r7, r5
    f696:	07de      	lsls	r6, r3, #31
    f698:	d54e      	bpl.n	f738 <bsec_ChannelHub_recalculateDownsampling+0xc0>
    f69a:	4b2d      	ldr	r3, [pc, #180]	; (f750 <bsec_ChannelHub_recalculateDownsampling+0xd8>)
    f69c:	f813 e005 	ldrb.w	lr, [r3, r5]
    f6a0:	eb00 0e4e 	add.w	lr, r0, lr, lsl #1
    f6a4:	f8be 829a 	ldrh.w	r8, [lr, #666]	; 0x29a
    f6a8:	45e0      	cmp	r8, ip
    f6aa:	d045      	beq.n	f738 <bsec_ChannelHub_recalculateDownsampling+0xc0>
    f6ac:	2300      	movs	r3, #0
    f6ae:	461e      	mov	r6, r3
    f6b0:	ea4f 0b45 	mov.w	fp, r5, lsl #1
    f6b4:	fa47 f403 	asr.w	r4, r7, r3
    f6b8:	07e4      	lsls	r4, r4, #31
    f6ba:	d50f      	bpl.n	f6dc <bsec_ChannelHub_recalculateDownsampling+0x64>
    f6bc:	f93b 400a 	ldrsh.w	r4, [fp, sl]
    f6c0:	411c      	asrs	r4, r3
    f6c2:	07e4      	lsls	r4, r4, #31
    f6c4:	d50a      	bpl.n	f6dc <bsec_ChannelHub_recalculateDownsampling+0x64>
    f6c6:	4c22      	ldr	r4, [pc, #136]	; (f750 <bsec_ChannelHub_recalculateDownsampling+0xd8>)
    f6c8:	5ce4      	ldrb	r4, [r4, r3]
    f6ca:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    f6ce:	f8b4 429a 	ldrh.w	r4, [r4, #666]	; 0x29a
    f6d2:	4564      	cmp	r4, ip
    f6d4:	d002      	beq.n	f6dc <bsec_ChannelHub_recalculateDownsampling+0x64>
    f6d6:	42a6      	cmp	r6, r4
    f6d8:	bf38      	it	cc
    f6da:	4626      	movcc	r6, r4
    f6dc:	3301      	adds	r3, #1
    f6de:	2b0a      	cmp	r3, #10
    f6e0:	d1e8      	bne.n	f6b4 <bsec_ChannelHub_recalculateDownsampling+0x3c>
    f6e2:	2300      	movs	r3, #0
    f6e4:	fa42 f403 	asr.w	r4, r2, r3
    f6e8:	07e4      	lsls	r4, r4, #31
    f6ea:	d50f      	bpl.n	f70c <bsec_ChannelHub_recalculateDownsampling+0x94>
    f6ec:	f991 4000 	ldrsb.w	r4, [r1]
    f6f0:	411c      	asrs	r4, r3
    f6f2:	07e4      	lsls	r4, r4, #31
    f6f4:	d50a      	bpl.n	f70c <bsec_ChannelHub_recalculateDownsampling+0x94>
    f6f6:	f813 4009 	ldrb.w	r4, [r3, r9]
    f6fa:	f204 1453 	addw	r4, r4, #339	; 0x153
    f6fe:	f830 4014 	ldrh.w	r4, [r0, r4, lsl #1]
    f702:	4564      	cmp	r4, ip
    f704:	d002      	beq.n	f70c <bsec_ChannelHub_recalculateDownsampling+0x94>
    f706:	42a6      	cmp	r6, r4
    f708:	bf38      	it	cc
    f70a:	4626      	movcc	r6, r4
    f70c:	3301      	adds	r3, #1
    f70e:	2b18      	cmp	r3, #24
    f710:	d1e8      	bne.n	f6e4 <bsec_ChannelHub_recalculateDownsampling+0x6c>
    f712:	b18e      	cbz	r6, f738 <bsec_ChannelHub_recalculateDownsampling+0xc0>
    f714:	fbb8 f4f6 	udiv	r4, r8, r6
    f718:	fb06 8814 	mls	r8, r6, r4, r8
    f71c:	fa1f f388 	uxth.w	r3, r8
    f720:	b2a4      	uxth	r4, r4
    f722:	b13b      	cbz	r3, f734 <bsec_ChannelHub_recalculateDownsampling+0xbc>
    f724:	f006 0801 	and.w	r8, r6, #1
    f728:	eb08 0656 	add.w	r6, r8, r6, lsr #1
    f72c:	42b3      	cmp	r3, r6
    f72e:	bfa4      	itt	ge
    f730:	3401      	addge	r4, #1
    f732:	b2a4      	uxthge	r4, r4
    f734:	f8ae 42d2 	strh.w	r4, [lr, #722]	; 0x2d2
    f738:	3501      	adds	r5, #1
    f73a:	2d0a      	cmp	r5, #10
    f73c:	f101 0101 	add.w	r1, r1, #1
    f740:	d1a7      	bne.n	f692 <bsec_ChannelHub_recalculateDownsampling+0x1a>
    f742:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f746:	bf00      	nop
    f748:	0003acd0 	.word	0x0003acd0
    f74c:	00e0200f 	.word	0x00e0200f
    f750:	0003acdc 	.word	0x0003acdc
    f754:	0003acbc 	.word	0x0003acbc
    f758:	0003ad80 	.word	0x0003ad80

0000f75c <bsec_ChannelHub_resetSamplIntvls>:
    f75c:	b430      	push	{r4, r5}
    f75e:	f500 7327 	add.w	r3, r0, #668	; 0x29c
    f762:	f500 752a 	add.w	r5, r0, #680	; 0x2a8
    f766:	2401      	movs	r4, #1
    f768:	2100      	movs	r1, #0
    f76a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    f76e:	871c      	strh	r4, [r3, #56]	; 0x38
    f770:	f8a3 1044 	strh.w	r1, [r3, #68]	; 0x44
    f774:	f823 2b02 	strh.w	r2, [r3], #2
    f778:	429d      	cmp	r5, r3
    f77a:	d1f8      	bne.n	f76e <bsec_ChannelHub_resetSamplIntvls+0x12>
    f77c:	f8a0 22a8 	strh.w	r2, [r0, #680]	; 0x2a8
    f780:	f8a0 22aa 	strh.w	r2, [r0, #682]	; 0x2aa
    f784:	f8a0 22ac 	strh.w	r2, [r0, #684]	; 0x2ac
    f788:	f8a0 22ae 	strh.w	r2, [r0, #686]	; 0x2ae
    f78c:	f8a0 22b0 	strh.w	r2, [r0, #688]	; 0x2b0
    f790:	f8a0 22b2 	strh.w	r2, [r0, #690]	; 0x2b2
    f794:	f8a0 22b4 	strh.w	r2, [r0, #692]	; 0x2b4
    f798:	f8a0 22b6 	strh.w	r2, [r0, #694]	; 0x2b6
    f79c:	f200 23b6 	addw	r3, r0, #694	; 0x2b6
    f7a0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    f7a4:	f200 20d2 	addw	r0, r0, #722	; 0x2d2
    f7a8:	f823 2f02 	strh.w	r2, [r3, #2]!
    f7ac:	4283      	cmp	r3, r0
    f7ae:	d1fb      	bne.n	f7a8 <bsec_ChannelHub_resetSamplIntvls+0x4c>
    f7b0:	bc30      	pop	{r4, r5}
    f7b2:	4770      	bx	lr

0000f7b4 <bsec_ChannelHub_setChannelState>:
    f7b4:	b410      	push	{r4}
    f7b6:	1e4c      	subs	r4, r1, #1
    f7b8:	4611      	mov	r1, r2
    f7ba:	2c09      	cmp	r4, #9
    f7bc:	d82b      	bhi.n	f816 <bsec_ChannelHub_setChannelState+0x62>
    f7be:	e8df f004 	tbb	[pc, r4]
    f7c2:	110b      	.short	0x110b
    f7c4:	2a232a17 	.word	0x2a232a17
    f7c8:	1c052a2a 	.word	0x1c052a2a
    f7cc:	461a      	mov	r2, r3
    f7ce:	30c8      	adds	r0, #200	; 0xc8
    f7d0:	f85d 4b04 	ldr.w	r4, [sp], #4
    f7d4:	f7fd ba50 	b.w	cc78 <bsec_SensorHeatCompensator_setState>
    f7d8:	461a      	mov	r2, r3
    f7da:	3068      	adds	r0, #104	; 0x68
    f7dc:	f85d 4b04 	ldr.w	r4, [sp], #4
    f7e0:	f001 ba0c 	b.w	10bfc <bsec_b_GasHumidityBaselineTracker_setState>
    f7e4:	461a      	mov	r2, r3
    f7e6:	302c      	adds	r0, #44	; 0x2c
    f7e8:	f85d 4b04 	ldr.w	r4, [sp], #4
    f7ec:	f001 be64 	b.w	114b8 <bsec_IaqEstimator_setState>
    f7f0:	461a      	mov	r2, r3
    f7f2:	f85d 4b04 	ldr.w	r4, [sp], #4
    f7f6:	f001 baff 	b.w	10df8 <bsec_GasHumidityPreProcessor_setState>
    f7fa:	461a      	mov	r2, r3
    f7fc:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    f800:	f85d 4b04 	ldr.w	r4, [sp], #4
    f804:	f001 bc22 	b.w	1104c <bsec_HumidityTemperatureCorrector_setState>
    f808:	461a      	mov	r2, r3
    f80a:	f500 7098 	add.w	r0, r0, #304	; 0x130
    f80e:	f85d 4b04 	ldr.w	r4, [sp], #4
    f812:	f002 b877 	b.w	11904 <bsec_SensorStatusTracker_setState>
    f816:	f06f 0063 	mvn.w	r0, #99	; 0x63
    f81a:	f85d 4b04 	ldr.w	r4, [sp], #4
    f81e:	4770      	bx	lr

0000f820 <bsec_ChannelHub_setInput>:
    f820:	b4f0      	push	{r4, r5, r6, r7}
    f822:	3901      	subs	r1, #1
    f824:	4c0d      	ldr	r4, [pc, #52]	; (f85c <bsec_ChannelHub_setInput+0x3c>)
    f826:	5c65      	ldrb	r5, [r4, r1]
    f828:	eb00 04c5 	add.w	r4, r0, r5, lsl #3
    f82c:	f504 74b8 	add.w	r4, r4, #368	; 0x170
    f830:	e9d4 6700 	ldrd	r6, r7, [r4]
    f834:	429f      	cmp	r7, r3
    f836:	bf08      	it	eq
    f838:	4296      	cmpeq	r6, r2
    f83a:	d00d      	beq.n	f858 <bsec_ChannelHub_setInput+0x38>
    f83c:	eb00 0585 	add.w	r5, r0, r5, lsl #2
    f840:	ed85 0a89 	vstr	s0, [r5, #548]	; 0x224
    f844:	e9c4 2300 	strd	r2, r3, [r4]
    f848:	2201      	movs	r2, #1
    f84a:	f8d0 3280 	ldr.w	r3, [r0, #640]	; 0x280
    f84e:	fa02 f101 	lsl.w	r1, r2, r1
    f852:	430b      	orrs	r3, r1
    f854:	f8c0 3280 	str.w	r3, [r0, #640]	; 0x280
    f858:	bcf0      	pop	{r4, r5, r6, r7}
    f85a:	4770      	bx	lr
    f85c:	0003ad80 	.word	0x0003ad80

0000f860 <bsec_ChannelHub_updateChannelInterfaceDependency>:
    f860:	1e4b      	subs	r3, r1, #1
    f862:	b2da      	uxtb	r2, r3
    f864:	2a09      	cmp	r2, #9
    f866:	d900      	bls.n	f86a <bsec_ChannelHub_updateChannelInterfaceDependency+0xa>
    f868:	4770      	bx	lr
    f86a:	4a18      	ldr	r2, [pc, #96]	; (f8cc <bsec_ChannelHub_updateChannelInterfaceDependency+0x6c>)
    f86c:	4411      	add	r1, r2
    f86e:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    f872:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    f876:	f8b2 129a 	ldrh.w	r1, [r2, #666]	; 0x29a
    f87a:	2b09      	cmp	r3, #9
    f87c:	d8f4      	bhi.n	f868 <bsec_ChannelHub_updateChannelInterfaceDependency+0x8>
    f87e:	a201      	add	r2, pc, #4	; (adr r2, f884 <bsec_ChannelHub_updateChannelInterfaceDependency+0x24>)
    f880:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    f884:	0000f8b5 	.word	0x0000f8b5
    f888:	0000f8bb 	.word	0x0000f8bb
    f88c:	0000f8c1 	.word	0x0000f8c1
    f890:	0000f869 	.word	0x0000f869
    f894:	0000f8ad 	.word	0x0000f8ad
    f898:	0000f869 	.word	0x0000f869
    f89c:	0000f869 	.word	0x0000f869
    f8a0:	0000f869 	.word	0x0000f869
    f8a4:	0000f869 	.word	0x0000f869
    f8a8:	0000f8c5 	.word	0x0000f8c5
    f8ac:	f500 7098 	add.w	r0, r0, #304	; 0x130
    f8b0:	f002 b866 	b.w	11980 <bsec_SensorStatusTracker_updateInterfaceDependency>
    f8b4:	3068      	adds	r0, #104	; 0x68
    f8b6:	f001 b915 	b.w	10ae4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>
    f8ba:	302c      	adds	r0, #44	; 0x2c
    f8bc:	f001 be1c 	b.w	114f8 <bsec_IaqEstimator_updateInterfaceDependency>
    f8c0:	f001 baba 	b.w	10e38 <bsec_GasHumidityPreProcessor_updateInterfaceDependency>
    f8c4:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    f8c8:	f001 bbda 	b.w	11080 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>
    f8cc:	0003acdc 	.word	0x0003acdc

0000f8d0 <bsec_ChannelHub_updateOutputSamplIntvl>:
    f8d0:	3901      	subs	r1, #1
    f8d2:	4b1f      	ldr	r3, [pc, #124]	; (f950 <bsec_ChannelHub_updateOutputSamplIntvl+0x80>)
    f8d4:	5c5b      	ldrb	r3, [r3, r1]
    f8d6:	f203 135b 	addw	r3, r3, #347	; 0x15b
    f8da:	b4f0      	push	{r4, r5, r6, r7}
    f8dc:	4e1d      	ldr	r6, [pc, #116]	; (f954 <bsec_ChannelHub_updateOutputSamplIntvl+0x84>)
    f8de:	4f1e      	ldr	r7, [pc, #120]	; (f958 <bsec_ChannelHub_updateOutputSamplIntvl+0x88>)
    f8e0:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
    f8e4:	f240 3517 	movw	r5, #791	; 0x317
    f8e8:	2300      	movs	r3, #0
    f8ea:	fa45 f403 	asr.w	r4, r5, r3
    f8ee:	07e4      	lsls	r4, r4, #31
    f8f0:	d50d      	bpl.n	f90e <bsec_ChannelHub_updateOutputSamplIntvl+0x3e>
    f8f2:	f936 4011 	ldrsh.w	r4, [r6, r1, lsl #1]
    f8f6:	411c      	asrs	r4, r3
    f8f8:	07e4      	lsls	r4, r4, #31
    f8fa:	d508      	bpl.n	f90e <bsec_ChannelHub_updateOutputSamplIntvl+0x3e>
    f8fc:	5cfc      	ldrb	r4, [r7, r3]
    f8fe:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    f902:	f8b4 c29a 	ldrh.w	ip, [r4, #666]	; 0x29a
    f906:	4594      	cmp	ip, r2
    f908:	bf88      	it	hi
    f90a:	f8a4 229a 	strhhi.w	r2, [r4, #666]	; 0x29a
    f90e:	3301      	adds	r3, #1
    f910:	2b0a      	cmp	r3, #10
    f912:	d1ea      	bne.n	f8ea <bsec_ChannelHub_updateOutputSamplIntvl+0x1a>
    f914:	4d11      	ldr	r5, [pc, #68]	; (f95c <bsec_ChannelHub_updateOutputSamplIntvl+0x8c>)
    f916:	4e12      	ldr	r6, [pc, #72]	; (f960 <bsec_ChannelHub_updateOutputSamplIntvl+0x90>)
    f918:	f8df c048 	ldr.w	ip, [pc, #72]	; f964 <bsec_ChannelHub_updateOutputSamplIntvl+0x94>
    f91c:	2300      	movs	r3, #0
    f91e:	fa45 f403 	asr.w	r4, r5, r3
    f922:	07e7      	lsls	r7, r4, #31
    f924:	d50e      	bpl.n	f944 <bsec_ChannelHub_updateOutputSamplIntvl+0x74>
    f926:	f856 4021 	ldr.w	r4, [r6, r1, lsl #2]
    f92a:	411c      	asrs	r4, r3
    f92c:	07e4      	lsls	r4, r4, #31
    f92e:	d509      	bpl.n	f944 <bsec_ChannelHub_updateOutputSamplIntvl+0x74>
    f930:	f81c 4003 	ldrb.w	r4, [ip, r3]
    f934:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    f938:	f8b4 72a6 	ldrh.w	r7, [r4, #678]	; 0x2a6
    f93c:	4297      	cmp	r7, r2
    f93e:	bf88      	it	hi
    f940:	f8a4 22a6 	strhhi.w	r2, [r4, #678]	; 0x2a6
    f944:	3301      	adds	r3, #1
    f946:	2b18      	cmp	r3, #24
    f948:	d1e9      	bne.n	f91e <bsec_ChannelHub_updateOutputSamplIntvl+0x4e>
    f94a:	bcf0      	pop	{r4, r5, r6, r7}
    f94c:	4770      	bx	lr
    f94e:	bf00      	nop
    f950:	0003ad68 	.word	0x0003ad68
    f954:	0003ace8 	.word	0x0003ace8
    f958:	0003acdc 	.word	0x0003acdc
    f95c:	00e0200f 	.word	0x00e0200f
    f960:	0003ad14 	.word	0x0003ad14
    f964:	0003ad80 	.word	0x0003ad80

0000f968 <bsec_b_ChannelHub_updateChannelInterfaceDependency>:
    f968:	1e4b      	subs	r3, r1, #1
    f96a:	b2da      	uxtb	r2, r3
    f96c:	2a09      	cmp	r2, #9
    f96e:	d900      	bls.n	f972 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0xa>
    f970:	4770      	bx	lr
    f972:	4a18      	ldr	r2, [pc, #96]	; (f9d4 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x6c>)
    f974:	4411      	add	r1, r2
    f976:	f811 2c01 	ldrb.w	r2, [r1, #-1]
    f97a:	eb00 0242 	add.w	r2, r0, r2, lsl #1
    f97e:	f8b2 129a 	ldrh.w	r1, [r2, #666]	; 0x29a
    f982:	2b09      	cmp	r3, #9
    f984:	d8f4      	bhi.n	f970 <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x8>
    f986:	a201      	add	r2, pc, #4	; (adr r2, f98c <bsec_b_ChannelHub_updateChannelInterfaceDependency+0x24>)
    f988:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    f98c:	0000f9bd 	.word	0x0000f9bd
    f990:	0000f9c3 	.word	0x0000f9c3
    f994:	0000f9c9 	.word	0x0000f9c9
    f998:	0000f971 	.word	0x0000f971
    f99c:	0000f9b5 	.word	0x0000f9b5
    f9a0:	0000f971 	.word	0x0000f971
    f9a4:	0000f971 	.word	0x0000f971
    f9a8:	0000f971 	.word	0x0000f971
    f9ac:	0000f971 	.word	0x0000f971
    f9b0:	0000f9cd 	.word	0x0000f9cd
    f9b4:	f500 7098 	add.w	r0, r0, #304	; 0x130
    f9b8:	f001 bfe2 	b.w	11980 <bsec_SensorStatusTracker_updateInterfaceDependency>
    f9bc:	3068      	adds	r0, #104	; 0x68
    f9be:	f001 b891 	b.w	10ae4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>
    f9c2:	302c      	adds	r0, #44	; 0x2c
    f9c4:	f001 bd98 	b.w	114f8 <bsec_IaqEstimator_updateInterfaceDependency>
    f9c8:	f001 ba36 	b.w	10e38 <bsec_GasHumidityPreProcessor_updateInterfaceDependency>
    f9cc:	f500 70b0 	add.w	r0, r0, #352	; 0x160
    f9d0:	f001 bb56 	b.w	11080 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>
    f9d4:	0003acdc 	.word	0x0003acdc

0000f9d8 <bsec_Entity_parseAndDeserialize>:
    f9d8:	b570      	push	{r4, r5, r6, lr}
    f9da:	460e      	mov	r6, r1
    f9dc:	6809      	ldr	r1, [r1, #0]
    f9de:	4603      	mov	r3, r0
    f9e0:	f100 050b 	add.w	r5, r0, #11
    f9e4:	b084      	sub	sp, #16
    f9e6:	1e48      	subs	r0, r1, #1
    f9e8:	440d      	add	r5, r1
    f9ea:	4403      	add	r3, r0
    f9ec:	a901      	add	r1, sp, #4
    f9ee:	f813 4f01 	ldrb.w	r4, [r3, #1]!
    f9f2:	f801 4b01 	strb.w	r4, [r1], #1
    f9f6:	42ab      	cmp	r3, r5
    f9f8:	d1f9      	bne.n	f9ee <bsec_Entity_parseAndDeserialize+0x16>
    f9fa:	a901      	add	r1, sp, #4
    f9fc:	4610      	mov	r0, r2
    f9fe:	220c      	movs	r2, #12
    fa00:	f029 faea 	bl	38fd8 <memcpy>
    fa04:	6833      	ldr	r3, [r6, #0]
    fa06:	330c      	adds	r3, #12
    fa08:	6033      	str	r3, [r6, #0]
    fa0a:	b004      	add	sp, #16
    fa0c:	bd70      	pop	{r4, r5, r6, pc}
    fa0e:	bf00      	nop

0000fa10 <bsec_Entity_serializeAndAdd>:
    fa10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fa14:	681c      	ldr	r4, [r3, #0]
    fa16:	340c      	adds	r4, #12
    fa18:	4294      	cmp	r4, r2
    fa1a:	b084      	sub	sp, #16
    fa1c:	d904      	bls.n	fa28 <bsec_Entity_serializeAndAdd+0x18>
    fa1e:	3201      	adds	r2, #1
    fa20:	601a      	str	r2, [r3, #0]
    fa22:	b004      	add	sp, #16
    fa24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    fa28:	220c      	movs	r2, #12
    fa2a:	4688      	mov	r8, r1
    fa2c:	4601      	mov	r1, r0
    fa2e:	a801      	add	r0, sp, #4
    fa30:	461f      	mov	r7, r3
    fa32:	f029 fad1 	bl	38fd8 <memcpy>
    fa36:	a801      	add	r0, sp, #4
    fa38:	2200      	movs	r2, #0
    fa3a:	eb08 0502 	add.w	r5, r8, r2
    fa3e:	683c      	ldr	r4, [r7, #0]
    fa40:	f810 6b01 	ldrb.w	r6, [r0], #1
    fa44:	552e      	strb	r6, [r5, r4]
    fa46:	3201      	adds	r2, #1
    fa48:	2a0c      	cmp	r2, #12
    fa4a:	d1f6      	bne.n	fa3a <bsec_Entity_serializeAndAdd+0x2a>
    fa4c:	683b      	ldr	r3, [r7, #0]
    fa4e:	330c      	adds	r3, #12
    fa50:	603b      	str	r3, [r7, #0]
    fa52:	b004      	add	sp, #16
    fa54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0000fa58 <bsec_b_Entity_parseAndDeserialize>:
    fa58:	b530      	push	{r4, r5, lr}
    fa5a:	460d      	mov	r5, r1
    fa5c:	6809      	ldr	r1, [r1, #0]
    fa5e:	b083      	sub	sp, #12
    fa60:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
    fa64:	4408      	add	r0, r1
    fa66:	f10d 0407 	add.w	r4, sp, #7
    fa6a:	f810 1b01 	ldrb.w	r1, [r0], #1
    fa6e:	f803 1f01 	strb.w	r1, [r3, #1]!
    fa72:	42a3      	cmp	r3, r4
    fa74:	d1f9      	bne.n	fa6a <bsec_b_Entity_parseAndDeserialize+0x12>
    fa76:	4610      	mov	r0, r2
    fa78:	4669      	mov	r1, sp
    fa7a:	2208      	movs	r2, #8
    fa7c:	f029 faac 	bl	38fd8 <memcpy>
    fa80:	682b      	ldr	r3, [r5, #0]
    fa82:	3308      	adds	r3, #8
    fa84:	602b      	str	r3, [r5, #0]
    fa86:	b003      	add	sp, #12
    fa88:	bd30      	pop	{r4, r5, pc}
    fa8a:	bf00      	nop

0000fa8c <bsec_b_Entity_serializeAndAdd>:
    fa8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    fa8e:	681d      	ldr	r5, [r3, #0]
    fa90:	3508      	adds	r5, #8
    fa92:	4295      	cmp	r5, r2
    fa94:	b085      	sub	sp, #20
    fa96:	d903      	bls.n	faa0 <bsec_b_Entity_serializeAndAdd+0x14>
    fa98:	3201      	adds	r2, #1
    fa9a:	601a      	str	r2, [r3, #0]
    fa9c:	b005      	add	sp, #20
    fa9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    faa0:	2208      	movs	r2, #8
    faa2:	460f      	mov	r7, r1
    faa4:	4601      	mov	r1, r0
    faa6:	4668      	mov	r0, sp
    faa8:	461c      	mov	r4, r3
    faaa:	f029 fa95 	bl	38fd8 <memcpy>
    faae:	2208      	movs	r2, #8
    fab0:	eb0d 0002 	add.w	r0, sp, r2
    fab4:	4669      	mov	r1, sp
    fab6:	f029 fa8f 	bl	38fd8 <memcpy>
    faba:	f10d 0307 	add.w	r3, sp, #7
    fabe:	2200      	movs	r2, #0
    fac0:	18bd      	adds	r5, r7, r2
    fac2:	6820      	ldr	r0, [r4, #0]
    fac4:	f813 6f01 	ldrb.w	r6, [r3, #1]!
    fac8:	542e      	strb	r6, [r5, r0]
    faca:	3201      	adds	r2, #1
    facc:	2a08      	cmp	r2, #8
    face:	d1f7      	bne.n	fac0 <bsec_b_Entity_serializeAndAdd+0x34>
    fad0:	6823      	ldr	r3, [r4, #0]
    fad2:	3308      	adds	r3, #8
    fad4:	6023      	str	r3, [r4, #0]
    fad6:	b005      	add	sp, #20
    fad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fada:	bf00      	nop

0000fadc <bsec_c_Entity_parseAndDeserialize>:
    fadc:	b510      	push	{r4, lr}
    fade:	680b      	ldr	r3, [r1, #0]
    fae0:	18c2      	adds	r2, r0, r3
    fae2:	b082      	sub	sp, #8
    fae4:	460c      	mov	r4, r1
    fae6:	7852      	ldrb	r2, [r2, #1]
    fae8:	5cc3      	ldrb	r3, [r0, r3]
    faea:	f88d 2005 	strb.w	r2, [sp, #5]
    faee:	a901      	add	r1, sp, #4
    faf0:	2202      	movs	r2, #2
    faf2:	f10d 0006 	add.w	r0, sp, #6
    faf6:	f88d 3004 	strb.w	r3, [sp, #4]
    fafa:	f029 fa6d 	bl	38fd8 <memcpy>
    fafe:	6823      	ldr	r3, [r4, #0]
    fb00:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    fb04:	3302      	adds	r3, #2
    fb06:	6023      	str	r3, [r4, #0]
    fb08:	b002      	add	sp, #8
    fb0a:	bd10      	pop	{r4, pc}

0000fb0c <bsec_c_Entity_serializeAndAdd>:
    fb0c:	b530      	push	{r4, r5, lr}
    fb0e:	681c      	ldr	r4, [r3, #0]
    fb10:	b085      	sub	sp, #20
    fb12:	3402      	adds	r4, #2
    fb14:	4294      	cmp	r4, r2
    fb16:	f8ad 0006 	strh.w	r0, [sp, #6]
    fb1a:	d903      	bls.n	fb24 <bsec_c_Entity_serializeAndAdd+0x18>
    fb1c:	3201      	adds	r2, #1
    fb1e:	601a      	str	r2, [r3, #0]
    fb20:	b005      	add	sp, #20
    fb22:	bd30      	pop	{r4, r5, pc}
    fb24:	461c      	mov	r4, r3
    fb26:	460d      	mov	r5, r1
    fb28:	2202      	movs	r2, #2
    fb2a:	f10d 0106 	add.w	r1, sp, #6
    fb2e:	a803      	add	r0, sp, #12
    fb30:	f029 fa52 	bl	38fd8 <memcpy>
    fb34:	6823      	ldr	r3, [r4, #0]
    fb36:	f89d 200c 	ldrb.w	r2, [sp, #12]
    fb3a:	54ea      	strb	r2, [r5, r3]
    fb3c:	6821      	ldr	r1, [r4, #0]
    fb3e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    fb42:	4429      	add	r1, r5
    fb44:	704b      	strb	r3, [r1, #1]
    fb46:	6823      	ldr	r3, [r4, #0]
    fb48:	3302      	adds	r3, #2
    fb4a:	6023      	str	r3, [r4, #0]
    fb4c:	b005      	add	sp, #20
    fb4e:	bd30      	pop	{r4, r5, pc}

0000fb50 <bsec_d_Entity_parseAndDeserialize>:
    fb50:	b530      	push	{r4, r5, lr}
    fb52:	460c      	mov	r4, r1
    fb54:	b083      	sub	sp, #12
    fb56:	6823      	ldr	r3, [r4, #0]
    fb58:	18c5      	adds	r5, r0, r3
    fb5a:	4601      	mov	r1, r0
    fb5c:	4610      	mov	r0, r2
    fb5e:	786a      	ldrb	r2, [r5, #1]
    fb60:	5ccb      	ldrb	r3, [r1, r3]
    fb62:	f88d 2005 	strb.w	r2, [sp, #5]
    fb66:	a901      	add	r1, sp, #4
    fb68:	2202      	movs	r2, #2
    fb6a:	f88d 3004 	strb.w	r3, [sp, #4]
    fb6e:	f029 fa33 	bl	38fd8 <memcpy>
    fb72:	6823      	ldr	r3, [r4, #0]
    fb74:	3302      	adds	r3, #2
    fb76:	6023      	str	r3, [r4, #0]
    fb78:	b003      	add	sp, #12
    fb7a:	bd30      	pop	{r4, r5, pc}

0000fb7c <bsec_d_Entity_serializeAndAdd>:
    fb7c:	b530      	push	{r4, r5, lr}
    fb7e:	681c      	ldr	r4, [r3, #0]
    fb80:	3402      	adds	r4, #2
    fb82:	4294      	cmp	r4, r2
    fb84:	b083      	sub	sp, #12
    fb86:	d81a      	bhi.n	fbbe <bsec_d_Entity_serializeAndAdd+0x42>
    fb88:	461c      	mov	r4, r3
    fb8a:	7802      	ldrb	r2, [r0, #0]
    fb8c:	7843      	ldrb	r3, [r0, #1]
    fb8e:	f88d 2004 	strb.w	r2, [sp, #4]
    fb92:	460d      	mov	r5, r1
    fb94:	2202      	movs	r2, #2
    fb96:	a901      	add	r1, sp, #4
    fb98:	4668      	mov	r0, sp
    fb9a:	f88d 3005 	strb.w	r3, [sp, #5]
    fb9e:	f029 fa1b 	bl	38fd8 <memcpy>
    fba2:	6823      	ldr	r3, [r4, #0]
    fba4:	f89d 2000 	ldrb.w	r2, [sp]
    fba8:	54ea      	strb	r2, [r5, r3]
    fbaa:	6821      	ldr	r1, [r4, #0]
    fbac:	f89d 3001 	ldrb.w	r3, [sp, #1]
    fbb0:	440d      	add	r5, r1
    fbb2:	706b      	strb	r3, [r5, #1]
    fbb4:	6823      	ldr	r3, [r4, #0]
    fbb6:	3302      	adds	r3, #2
    fbb8:	6023      	str	r3, [r4, #0]
    fbba:	b003      	add	sp, #12
    fbbc:	bd30      	pop	{r4, r5, pc}
    fbbe:	3201      	adds	r2, #1
    fbc0:	601a      	str	r2, [r3, #0]
    fbc2:	b003      	add	sp, #12
    fbc4:	bd30      	pop	{r4, r5, pc}
    fbc6:	bf00      	nop

0000fbc8 <bsec_e_Entity_parseAndDeserialize>:
    fbc8:	b510      	push	{r4, lr}
    fbca:	680b      	ldr	r3, [r1, #0]
    fbcc:	b082      	sub	sp, #8
    fbce:	460c      	mov	r4, r1
    fbd0:	1d01      	adds	r1, r0, #4
    fbd2:	4419      	add	r1, r3
    fbd4:	4418      	add	r0, r3
    fbd6:	ab01      	add	r3, sp, #4
    fbd8:	f810 2b01 	ldrb.w	r2, [r0], #1
    fbdc:	f803 2b01 	strb.w	r2, [r3], #1
    fbe0:	4288      	cmp	r0, r1
    fbe2:	d1f9      	bne.n	fbd8 <bsec_e_Entity_parseAndDeserialize+0x10>
    fbe4:	a901      	add	r1, sp, #4
    fbe6:	2204      	movs	r2, #4
    fbe8:	4668      	mov	r0, sp
    fbea:	f029 f9f5 	bl	38fd8 <memcpy>
    fbee:	6823      	ldr	r3, [r4, #0]
    fbf0:	ed9d 0a00 	vldr	s0, [sp]
    fbf4:	3304      	adds	r3, #4
    fbf6:	6023      	str	r3, [r4, #0]
    fbf8:	b002      	add	sp, #8
    fbfa:	bd10      	pop	{r4, pc}

0000fbfc <bsec_e_Entity_serializeAndAdd>:
    fbfc:	b570      	push	{r4, r5, r6, lr}
    fbfe:	6813      	ldr	r3, [r2, #0]
    fc00:	3304      	adds	r3, #4
    fc02:	b084      	sub	sp, #16
    fc04:	428b      	cmp	r3, r1
    fc06:	ed8d 0a01 	vstr	s0, [sp, #4]
    fc0a:	d903      	bls.n	fc14 <bsec_e_Entity_serializeAndAdd+0x18>
    fc0c:	3101      	adds	r1, #1
    fc0e:	6011      	str	r1, [r2, #0]
    fc10:	b004      	add	sp, #16
    fc12:	bd70      	pop	{r4, r5, r6, pc}
    fc14:	4614      	mov	r4, r2
    fc16:	2204      	movs	r2, #4
    fc18:	eb0d 0102 	add.w	r1, sp, r2
    fc1c:	4605      	mov	r5, r0
    fc1e:	a803      	add	r0, sp, #12
    fc20:	f029 f9da 	bl	38fd8 <memcpy>
    fc24:	aa03      	add	r2, sp, #12
    fc26:	2300      	movs	r3, #0
    fc28:	18e8      	adds	r0, r5, r3
    fc2a:	6821      	ldr	r1, [r4, #0]
    fc2c:	f812 6b01 	ldrb.w	r6, [r2], #1
    fc30:	5446      	strb	r6, [r0, r1]
    fc32:	3301      	adds	r3, #1
    fc34:	2b04      	cmp	r3, #4
    fc36:	d1f7      	bne.n	fc28 <bsec_e_Entity_serializeAndAdd+0x2c>
    fc38:	6823      	ldr	r3, [r4, #0]
    fc3a:	3304      	adds	r3, #4
    fc3c:	6023      	str	r3, [r4, #0]
    fc3e:	b004      	add	sp, #16
    fc40:	bd70      	pop	{r4, r5, r6, pc}
    fc42:	bf00      	nop

0000fc44 <bsec_f_Entity_parseAndDeserialize>:
    fc44:	b510      	push	{r4, lr}
    fc46:	460c      	mov	r4, r1
    fc48:	b082      	sub	sp, #8
    fc4a:	6823      	ldr	r3, [r4, #0]
    fc4c:	a902      	add	r1, sp, #8
    fc4e:	5cc3      	ldrb	r3, [r0, r3]
    fc50:	f801 3d01 	strb.w	r3, [r1, #-1]!
    fc54:	2201      	movs	r2, #1
    fc56:	f10d 0006 	add.w	r0, sp, #6
    fc5a:	f029 f9bd 	bl	38fd8 <memcpy>
    fc5e:	6823      	ldr	r3, [r4, #0]
    fc60:	f89d 0006 	ldrb.w	r0, [sp, #6]
    fc64:	3301      	adds	r3, #1
    fc66:	6023      	str	r3, [r4, #0]
    fc68:	b002      	add	sp, #8
    fc6a:	bd10      	pop	{r4, pc}

0000fc6c <bsec_f_Entity_serializeAndAdd>:
    fc6c:	b530      	push	{r4, r5, lr}
    fc6e:	681c      	ldr	r4, [r3, #0]
    fc70:	b085      	sub	sp, #20
    fc72:	3401      	adds	r4, #1
    fc74:	4294      	cmp	r4, r2
    fc76:	f88d 0007 	strb.w	r0, [sp, #7]
    fc7a:	d903      	bls.n	fc84 <bsec_f_Entity_serializeAndAdd+0x18>
    fc7c:	3201      	adds	r2, #1
    fc7e:	601a      	str	r2, [r3, #0]
    fc80:	b005      	add	sp, #20
    fc82:	bd30      	pop	{r4, r5, pc}
    fc84:	461c      	mov	r4, r3
    fc86:	460d      	mov	r5, r1
    fc88:	2201      	movs	r2, #1
    fc8a:	f10d 0107 	add.w	r1, sp, #7
    fc8e:	f10d 000f 	add.w	r0, sp, #15
    fc92:	f029 f9a1 	bl	38fd8 <memcpy>
    fc96:	6823      	ldr	r3, [r4, #0]
    fc98:	f89d 200f 	ldrb.w	r2, [sp, #15]
    fc9c:	54ea      	strb	r2, [r5, r3]
    fc9e:	6823      	ldr	r3, [r4, #0]
    fca0:	3301      	adds	r3, #1
    fca2:	6023      	str	r3, [r4, #0]
    fca4:	b005      	add	sp, #20
    fca6:	bd30      	pop	{r4, r5, pc}

0000fca8 <bsec_g_Entity_parseAndDeserialize>:
    fca8:	b510      	push	{r4, lr}
    fcaa:	680a      	ldr	r2, [r1, #0]
    fcac:	b084      	sub	sp, #16
    fcae:	460c      	mov	r4, r1
    fcb0:	f10d 0307 	add.w	r3, sp, #7
    fcb4:	f10d 010f 	add.w	r1, sp, #15
    fcb8:	4410      	add	r0, r2
    fcba:	f810 2b01 	ldrb.w	r2, [r0], #1
    fcbe:	f803 2f01 	strb.w	r2, [r3, #1]!
    fcc2:	428b      	cmp	r3, r1
    fcc4:	d1f9      	bne.n	fcba <bsec_g_Entity_parseAndDeserialize+0x12>
    fcc6:	2208      	movs	r2, #8
    fcc8:	eb0d 0102 	add.w	r1, sp, r2
    fccc:	4668      	mov	r0, sp
    fcce:	f029 f983 	bl	38fd8 <memcpy>
    fcd2:	6823      	ldr	r3, [r4, #0]
    fcd4:	e9dd 0100 	ldrd	r0, r1, [sp]
    fcd8:	3308      	adds	r3, #8
    fcda:	6023      	str	r3, [r4, #0]
    fcdc:	b004      	add	sp, #16
    fcde:	bd10      	pop	{r4, pc}

0000fce0 <bsec_g_Entity_serializeAndAdd>:
    fce0:	b5f0      	push	{r4, r5, r6, r7, lr}
    fce2:	b085      	sub	sp, #20
    fce4:	e9cd 0100 	strd	r0, r1, [sp]
    fce8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    fcea:	6825      	ldr	r5, [r4, #0]
    fcec:	3508      	adds	r5, #8
    fcee:	429d      	cmp	r5, r3
    fcf0:	d903      	bls.n	fcfa <bsec_g_Entity_serializeAndAdd+0x1a>
    fcf2:	3301      	adds	r3, #1
    fcf4:	6023      	str	r3, [r4, #0]
    fcf6:	b005      	add	sp, #20
    fcf8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fcfa:	4617      	mov	r7, r2
    fcfc:	2208      	movs	r2, #8
    fcfe:	4669      	mov	r1, sp
    fd00:	eb0d 0002 	add.w	r0, sp, r2
    fd04:	f029 f968 	bl	38fd8 <memcpy>
    fd08:	f10d 0107 	add.w	r1, sp, #7
    fd0c:	2300      	movs	r3, #0
    fd0e:	18fd      	adds	r5, r7, r3
    fd10:	6820      	ldr	r0, [r4, #0]
    fd12:	f811 6f01 	ldrb.w	r6, [r1, #1]!
    fd16:	542e      	strb	r6, [r5, r0]
    fd18:	3301      	adds	r3, #1
    fd1a:	2b08      	cmp	r3, #8
    fd1c:	d1f7      	bne.n	fd0e <bsec_g_Entity_serializeAndAdd+0x2e>
    fd1e:	6823      	ldr	r3, [r4, #0]
    fd20:	3308      	adds	r3, #8
    fd22:	6023      	str	r3, [r4, #0]
    fd24:	b005      	add	sp, #20
    fd26:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000fd28 <bsec_h_Entity_parseAndDeserialize>:
    fd28:	680b      	ldr	r3, [r1, #0]
    fd2a:	5cc0      	ldrb	r0, [r0, r3]
    fd2c:	3301      	adds	r3, #1
    fd2e:	3000      	adds	r0, #0
    fd30:	600b      	str	r3, [r1, #0]
    fd32:	bf18      	it	ne
    fd34:	2001      	movne	r0, #1
    fd36:	4770      	bx	lr

0000fd38 <bsec_h_Entity_serializeAndAdd>:
    fd38:	b430      	push	{r4, r5}
    fd3a:	681c      	ldr	r4, [r3, #0]
    fd3c:	1c65      	adds	r5, r4, #1
    fd3e:	4295      	cmp	r5, r2
    fd40:	bf9c      	itt	ls
    fd42:	5508      	strbls	r0, [r1, r4]
    fd44:	681a      	ldrls	r2, [r3, #0]
    fd46:	3201      	adds	r2, #1
    fd48:	601a      	str	r2, [r3, #0]
    fd4a:	bc30      	pop	{r4, r5}
    fd4c:	4770      	bx	lr
    fd4e:	bf00      	nop

0000fd50 <bsec_i_Entity_parseAndDeserialize>:
    fd50:	b530      	push	{r4, r5, lr}
    fd52:	680b      	ldr	r3, [r1, #0]
    fd54:	b087      	sub	sp, #28
    fd56:	3b01      	subs	r3, #1
    fd58:	4418      	add	r0, r3
    fd5a:	460d      	mov	r5, r1
    fd5c:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
    fd60:	f10d 0417 	add.w	r4, sp, #23
    fd64:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    fd68:	f803 1f01 	strb.w	r1, [r3, #1]!
    fd6c:	42a3      	cmp	r3, r4
    fd6e:	d1f9      	bne.n	fd64 <bsec_i_Entity_parseAndDeserialize+0x14>
    fd70:	4610      	mov	r0, r2
    fd72:	4669      	mov	r1, sp
    fd74:	2218      	movs	r2, #24
    fd76:	f029 f92f 	bl	38fd8 <memcpy>
    fd7a:	682b      	ldr	r3, [r5, #0]
    fd7c:	3318      	adds	r3, #24
    fd7e:	602b      	str	r3, [r5, #0]
    fd80:	b007      	add	sp, #28
    fd82:	bd30      	pop	{r4, r5, pc}

0000fd84 <bsec_i_Entity_serializeAndAdd>:
    fd84:	b5f0      	push	{r4, r5, r6, r7, lr}
    fd86:	681c      	ldr	r4, [r3, #0]
    fd88:	3410      	adds	r4, #16
    fd8a:	4294      	cmp	r4, r2
    fd8c:	b089      	sub	sp, #36	; 0x24
    fd8e:	d903      	bls.n	fd98 <bsec_i_Entity_serializeAndAdd+0x14>
    fd90:	3201      	adds	r2, #1
    fd92:	601a      	str	r2, [r3, #0]
    fd94:	b009      	add	sp, #36	; 0x24
    fd96:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fd98:	2210      	movs	r2, #16
    fd9a:	eb0d 0702 	add.w	r7, sp, r2
    fd9e:	460e      	mov	r6, r1
    fda0:	4601      	mov	r1, r0
    fda2:	4668      	mov	r0, sp
    fda4:	461d      	mov	r5, r3
    fda6:	f029 f917 	bl	38fd8 <memcpy>
    fdaa:	2210      	movs	r2, #16
    fdac:	4669      	mov	r1, sp
    fdae:	4638      	mov	r0, r7
    fdb0:	f029 f912 	bl	38fd8 <memcpy>
    fdb4:	ab08      	add	r3, sp, #32
    fdb6:	463a      	mov	r2, r7
    fdb8:	682c      	ldr	r4, [r5, #0]
    fdba:	1bd0      	subs	r0, r2, r7
    fdbc:	4420      	add	r0, r4
    fdbe:	f812 4b01 	ldrb.w	r4, [r2], #1
    fdc2:	5434      	strb	r4, [r6, r0]
    fdc4:	429a      	cmp	r2, r3
    fdc6:	d1f7      	bne.n	fdb8 <bsec_i_Entity_serializeAndAdd+0x34>
    fdc8:	682b      	ldr	r3, [r5, #0]
    fdca:	3310      	adds	r3, #16
    fdcc:	602b      	str	r3, [r5, #0]
    fdce:	b009      	add	sp, #36	; 0x24
    fdd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fdd2:	bf00      	nop

0000fdd4 <bsec_j_Entity_parseAndDeserialize>:
    fdd4:	b530      	push	{r4, r5, lr}
    fdd6:	680b      	ldr	r3, [r1, #0]
    fdd8:	b0ab      	sub	sp, #172	; 0xac
    fdda:	3b01      	subs	r3, #1
    fddc:	4418      	add	r0, r3
    fdde:	460d      	mov	r5, r1
    fde0:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
    fde4:	f10d 04a7 	add.w	r4, sp, #167	; 0xa7
    fde8:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    fdec:	f803 1f01 	strb.w	r1, [r3, #1]!
    fdf0:	42a3      	cmp	r3, r4
    fdf2:	d1f9      	bne.n	fde8 <bsec_j_Entity_parseAndDeserialize+0x14>
    fdf4:	4610      	mov	r0, r2
    fdf6:	4669      	mov	r1, sp
    fdf8:	22a8      	movs	r2, #168	; 0xa8
    fdfa:	f029 f8ed 	bl	38fd8 <memcpy>
    fdfe:	682b      	ldr	r3, [r5, #0]
    fe00:	33a8      	adds	r3, #168	; 0xa8
    fe02:	602b      	str	r3, [r5, #0]
    fe04:	b02b      	add	sp, #172	; 0xac
    fe06:	bd30      	pop	{r4, r5, pc}

0000fe08 <bsec_j_Entity_serializeAndAdd>:
    fe08:	b5f0      	push	{r4, r5, r6, r7, lr}
    fe0a:	681d      	ldr	r5, [r3, #0]
    fe0c:	3504      	adds	r5, #4
    fe0e:	4295      	cmp	r5, r2
    fe10:	b083      	sub	sp, #12
    fe12:	d81d      	bhi.n	fe50 <bsec_j_Entity_serializeAndAdd+0x48>
    fe14:	4602      	mov	r2, r0
    fe16:	460f      	mov	r7, r1
    fe18:	461c      	mov	r4, r3
    fe1a:	8811      	ldrh	r1, [r2, #0]
    fe1c:	8853      	ldrh	r3, [r2, #2]
    fe1e:	f8ad 1004 	strh.w	r1, [sp, #4]
    fe22:	2204      	movs	r2, #4
    fe24:	eb0d 0102 	add.w	r1, sp, r2
    fe28:	4668      	mov	r0, sp
    fe2a:	f8ad 3006 	strh.w	r3, [sp, #6]
    fe2e:	f029 f8d3 	bl	38fd8 <memcpy>
    fe32:	466b      	mov	r3, sp
    fe34:	2200      	movs	r2, #0
    fe36:	18bd      	adds	r5, r7, r2
    fe38:	6820      	ldr	r0, [r4, #0]
    fe3a:	f813 6b01 	ldrb.w	r6, [r3], #1
    fe3e:	542e      	strb	r6, [r5, r0]
    fe40:	3201      	adds	r2, #1
    fe42:	2a04      	cmp	r2, #4
    fe44:	d1f7      	bne.n	fe36 <bsec_j_Entity_serializeAndAdd+0x2e>
    fe46:	6823      	ldr	r3, [r4, #0]
    fe48:	3304      	adds	r3, #4
    fe4a:	6023      	str	r3, [r4, #0]
    fe4c:	b003      	add	sp, #12
    fe4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fe50:	3201      	adds	r2, #1
    fe52:	601a      	str	r2, [r3, #0]
    fe54:	b003      	add	sp, #12
    fe56:	bdf0      	pop	{r4, r5, r6, r7, pc}

0000fe58 <bsec_k_Entity_parseAndDeserialize>:
    fe58:	b530      	push	{r4, r5, lr}
    fe5a:	680b      	ldr	r3, [r1, #0]
    fe5c:	b089      	sub	sp, #36	; 0x24
    fe5e:	3b01      	subs	r3, #1
    fe60:	4418      	add	r0, r3
    fe62:	460d      	mov	r5, r1
    fe64:	f10d 0303 	add.w	r3, sp, #3
    fe68:	f10d 041f 	add.w	r4, sp, #31
    fe6c:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    fe70:	f803 1f01 	strb.w	r1, [r3, #1]!
    fe74:	42a3      	cmp	r3, r4
    fe76:	d1f9      	bne.n	fe6c <bsec_k_Entity_parseAndDeserialize+0x14>
    fe78:	4610      	mov	r0, r2
    fe7a:	a901      	add	r1, sp, #4
    fe7c:	221c      	movs	r2, #28
    fe7e:	f029 f8ab 	bl	38fd8 <memcpy>
    fe82:	682b      	ldr	r3, [r5, #0]
    fe84:	331c      	adds	r3, #28
    fe86:	602b      	str	r3, [r5, #0]
    fe88:	b009      	add	sp, #36	; 0x24
    fe8a:	bd30      	pop	{r4, r5, pc}

0000fe8c <bsec_k_Entity_serializeAndAdd>:
    fe8c:	b530      	push	{r4, r5, lr}
    fe8e:	681c      	ldr	r4, [r3, #0]
    fe90:	3402      	adds	r4, #2
    fe92:	4294      	cmp	r4, r2
    fe94:	b083      	sub	sp, #12
    fe96:	d81a      	bhi.n	fece <bsec_k_Entity_serializeAndAdd+0x42>
    fe98:	461c      	mov	r4, r3
    fe9a:	7802      	ldrb	r2, [r0, #0]
    fe9c:	7843      	ldrb	r3, [r0, #1]
    fe9e:	f88d 2004 	strb.w	r2, [sp, #4]
    fea2:	460d      	mov	r5, r1
    fea4:	2202      	movs	r2, #2
    fea6:	a901      	add	r1, sp, #4
    fea8:	4668      	mov	r0, sp
    feaa:	f88d 3005 	strb.w	r3, [sp, #5]
    feae:	f029 f893 	bl	38fd8 <memcpy>
    feb2:	6823      	ldr	r3, [r4, #0]
    feb4:	f89d 2000 	ldrb.w	r2, [sp]
    feb8:	54ea      	strb	r2, [r5, r3]
    feba:	6821      	ldr	r1, [r4, #0]
    febc:	f89d 3001 	ldrb.w	r3, [sp, #1]
    fec0:	440d      	add	r5, r1
    fec2:	706b      	strb	r3, [r5, #1]
    fec4:	6823      	ldr	r3, [r4, #0]
    fec6:	3302      	adds	r3, #2
    fec8:	6023      	str	r3, [r4, #0]
    feca:	b003      	add	sp, #12
    fecc:	bd30      	pop	{r4, r5, pc}
    fece:	3201      	adds	r2, #1
    fed0:	601a      	str	r2, [r3, #0]
    fed2:	b003      	add	sp, #12
    fed4:	bd30      	pop	{r4, r5, pc}
    fed6:	bf00      	nop

0000fed8 <bsec_l_Entity_parseAndDeserialize>:
    fed8:	b530      	push	{r4, r5, lr}
    feda:	680b      	ldr	r3, [r1, #0]
    fedc:	b085      	sub	sp, #20
    fede:	3b01      	subs	r3, #1
    fee0:	4418      	add	r0, r3
    fee2:	460d      	mov	r5, r1
    fee4:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
    fee8:	f10d 040f 	add.w	r4, sp, #15
    feec:	f810 1f01 	ldrb.w	r1, [r0, #1]!
    fef0:	f803 1f01 	strb.w	r1, [r3, #1]!
    fef4:	42a3      	cmp	r3, r4
    fef6:	d1f9      	bne.n	feec <bsec_l_Entity_parseAndDeserialize+0x14>
    fef8:	4610      	mov	r0, r2
    fefa:	4669      	mov	r1, sp
    fefc:	2210      	movs	r2, #16
    fefe:	f029 f86b 	bl	38fd8 <memcpy>
    ff02:	682b      	ldr	r3, [r5, #0]
    ff04:	3310      	adds	r3, #16
    ff06:	602b      	str	r3, [r5, #0]
    ff08:	b005      	add	sp, #20
    ff0a:	bd30      	pop	{r4, r5, pc}

0000ff0c <bsec_l_Entity_serializeAndAdd>:
    ff0c:	b530      	push	{r4, r5, lr}
    ff0e:	681c      	ldr	r4, [r3, #0]
    ff10:	b085      	sub	sp, #20
    ff12:	3401      	adds	r4, #1
    ff14:	4294      	cmp	r4, r2
    ff16:	f88d 0007 	strb.w	r0, [sp, #7]
    ff1a:	d903      	bls.n	ff24 <bsec_l_Entity_serializeAndAdd+0x18>
    ff1c:	3201      	adds	r2, #1
    ff1e:	601a      	str	r2, [r3, #0]
    ff20:	b005      	add	sp, #20
    ff22:	bd30      	pop	{r4, r5, pc}
    ff24:	461c      	mov	r4, r3
    ff26:	460d      	mov	r5, r1
    ff28:	2201      	movs	r2, #1
    ff2a:	f10d 0107 	add.w	r1, sp, #7
    ff2e:	f10d 000f 	add.w	r0, sp, #15
    ff32:	f029 f851 	bl	38fd8 <memcpy>
    ff36:	6823      	ldr	r3, [r4, #0]
    ff38:	f89d 200f 	ldrb.w	r2, [sp, #15]
    ff3c:	54ea      	strb	r2, [r5, r3]
    ff3e:	6823      	ldr	r3, [r4, #0]
    ff40:	3301      	adds	r3, #1
    ff42:	6023      	str	r3, [r4, #0]
    ff44:	b005      	add	sp, #20
    ff46:	bd30      	pop	{r4, r5, pc}

0000ff48 <bsec_m_Entity_parseAndDeserialize>:
    ff48:	b570      	push	{r4, r5, r6, lr}
    ff4a:	460e      	mov	r6, r1
    ff4c:	6809      	ldr	r1, [r1, #0]
    ff4e:	b082      	sub	sp, #8
    ff50:	1d05      	adds	r5, r0, #4
    ff52:	1843      	adds	r3, r0, r1
    ff54:	440d      	add	r5, r1
    ff56:	a901      	add	r1, sp, #4
    ff58:	f813 4b01 	ldrb.w	r4, [r3], #1
    ff5c:	f801 4b01 	strb.w	r4, [r1], #1
    ff60:	42ab      	cmp	r3, r5
    ff62:	d1f9      	bne.n	ff58 <bsec_m_Entity_parseAndDeserialize+0x10>
    ff64:	a901      	add	r1, sp, #4
    ff66:	4610      	mov	r0, r2
    ff68:	2204      	movs	r2, #4
    ff6a:	f029 f835 	bl	38fd8 <memcpy>
    ff6e:	6833      	ldr	r3, [r6, #0]
    ff70:	3304      	adds	r3, #4
    ff72:	6033      	str	r3, [r6, #0]
    ff74:	b002      	add	sp, #8
    ff76:	bd70      	pop	{r4, r5, r6, pc}

0000ff78 <bsec_m_Entity_serializeAndAdd>:
    ff78:	b5f0      	push	{r4, r5, r6, r7, lr}
    ff7a:	681d      	ldr	r5, [r3, #0]
    ff7c:	3508      	adds	r5, #8
    ff7e:	4295      	cmp	r5, r2
    ff80:	b083      	sub	sp, #12
    ff82:	d903      	bls.n	ff8c <bsec_m_Entity_serializeAndAdd+0x14>
    ff84:	3201      	adds	r2, #1
    ff86:	601a      	str	r2, [r3, #0]
    ff88:	b003      	add	sp, #12
    ff8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ff8c:	2208      	movs	r2, #8
    ff8e:	460f      	mov	r7, r1
    ff90:	4601      	mov	r1, r0
    ff92:	4668      	mov	r0, sp
    ff94:	461c      	mov	r4, r3
    ff96:	f029 f81f 	bl	38fd8 <memcpy>
    ff9a:	f10d 33ff 	add.w	r3, sp, #4294967295	; 0xffffffff
    ff9e:	2200      	movs	r2, #0
    ffa0:	18bd      	adds	r5, r7, r2
    ffa2:	6820      	ldr	r0, [r4, #0]
    ffa4:	f813 6f01 	ldrb.w	r6, [r3, #1]!
    ffa8:	542e      	strb	r6, [r5, r0]
    ffaa:	3201      	adds	r2, #1
    ffac:	2a08      	cmp	r2, #8
    ffae:	d1f7      	bne.n	ffa0 <bsec_m_Entity_serializeAndAdd+0x28>
    ffb0:	6823      	ldr	r3, [r4, #0]
    ffb2:	3308      	adds	r3, #8
    ffb4:	6023      	str	r3, [r4, #0]
    ffb6:	b003      	add	sp, #12
    ffb8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ffba:	bf00      	nop

0000ffbc <bsec_n_Entity_parseAndDeserialize>:
    ffbc:	b530      	push	{r4, r5, lr}
    ffbe:	460c      	mov	r4, r1
    ffc0:	b083      	sub	sp, #12
    ffc2:	6823      	ldr	r3, [r4, #0]
    ffc4:	18c5      	adds	r5, r0, r3
    ffc6:	4601      	mov	r1, r0
    ffc8:	4610      	mov	r0, r2
    ffca:	786a      	ldrb	r2, [r5, #1]
    ffcc:	5ccb      	ldrb	r3, [r1, r3]
    ffce:	f88d 2005 	strb.w	r2, [sp, #5]
    ffd2:	a901      	add	r1, sp, #4
    ffd4:	2202      	movs	r2, #2
    ffd6:	f88d 3004 	strb.w	r3, [sp, #4]
    ffda:	f028 fffd 	bl	38fd8 <memcpy>
    ffde:	6823      	ldr	r3, [r4, #0]
    ffe0:	3302      	adds	r3, #2
    ffe2:	6023      	str	r3, [r4, #0]
    ffe4:	b003      	add	sp, #12
    ffe6:	bd30      	pop	{r4, r5, pc}

0000ffe8 <bsec_n_Entity_serializeAndAdd>:
    ffe8:	b5f0      	push	{r4, r5, r6, r7, lr}
    ffea:	681c      	ldr	r4, [r3, #0]
    ffec:	3414      	adds	r4, #20
    ffee:	4294      	cmp	r4, r2
    fff0:	b08b      	sub	sp, #44	; 0x2c
    fff2:	d903      	bls.n	fffc <bsec_n_Entity_serializeAndAdd+0x14>
    fff4:	3201      	adds	r2, #1
    fff6:	601a      	str	r2, [r3, #0]
    fff8:	b00b      	add	sp, #44	; 0x2c
    fffa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    fffc:	2214      	movs	r2, #20
    fffe:	eb0d 0702 	add.w	r7, sp, r2
   10002:	460e      	mov	r6, r1
   10004:	4601      	mov	r1, r0
   10006:	4668      	mov	r0, sp
   10008:	461d      	mov	r5, r3
   1000a:	f028 ffe5 	bl	38fd8 <memcpy>
   1000e:	2214      	movs	r2, #20
   10010:	4669      	mov	r1, sp
   10012:	4638      	mov	r0, r7
   10014:	f028 ffe0 	bl	38fd8 <memcpy>
   10018:	ab0a      	add	r3, sp, #40	; 0x28
   1001a:	463a      	mov	r2, r7
   1001c:	682c      	ldr	r4, [r5, #0]
   1001e:	1bd0      	subs	r0, r2, r7
   10020:	4420      	add	r0, r4
   10022:	f812 4b01 	ldrb.w	r4, [r2], #1
   10026:	5434      	strb	r4, [r6, r0]
   10028:	429a      	cmp	r2, r3
   1002a:	d1f7      	bne.n	1001c <bsec_n_Entity_serializeAndAdd+0x34>
   1002c:	682b      	ldr	r3, [r5, #0]
   1002e:	3314      	adds	r3, #20
   10030:	602b      	str	r3, [r5, #0]
   10032:	b00b      	add	sp, #44	; 0x2c
   10034:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10036:	bf00      	nop

00010038 <bsec_o_Entity_parseAndDeserialize>:
   10038:	b510      	push	{r4, lr}
   1003a:	460c      	mov	r4, r1
   1003c:	b082      	sub	sp, #8
   1003e:	6823      	ldr	r3, [r4, #0]
   10040:	a902      	add	r1, sp, #8
   10042:	5cc3      	ldrb	r3, [r0, r3]
   10044:	f801 3d01 	strb.w	r3, [r1, #-1]!
   10048:	2201      	movs	r2, #1
   1004a:	f10d 0006 	add.w	r0, sp, #6
   1004e:	f028 ffc3 	bl	38fd8 <memcpy>
   10052:	6823      	ldr	r3, [r4, #0]
   10054:	f99d 0006 	ldrsb.w	r0, [sp, #6]
   10058:	3301      	adds	r3, #1
   1005a:	6023      	str	r3, [r4, #0]
   1005c:	b002      	add	sp, #8
   1005e:	bd10      	pop	{r4, pc}

00010060 <bsec_o_Entity_serializeAndAdd>:
   10060:	b5f0      	push	{r4, r5, r6, r7, lr}
   10062:	681c      	ldr	r4, [r3, #0]
   10064:	3418      	adds	r4, #24
   10066:	4294      	cmp	r4, r2
   10068:	b08d      	sub	sp, #52	; 0x34
   1006a:	d903      	bls.n	10074 <bsec_o_Entity_serializeAndAdd+0x14>
   1006c:	3201      	adds	r2, #1
   1006e:	601a      	str	r2, [r3, #0]
   10070:	b00d      	add	sp, #52	; 0x34
   10072:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10074:	2218      	movs	r2, #24
   10076:	eb0d 0702 	add.w	r7, sp, r2
   1007a:	460e      	mov	r6, r1
   1007c:	4601      	mov	r1, r0
   1007e:	4668      	mov	r0, sp
   10080:	461d      	mov	r5, r3
   10082:	f028 ffa9 	bl	38fd8 <memcpy>
   10086:	2218      	movs	r2, #24
   10088:	4669      	mov	r1, sp
   1008a:	4638      	mov	r0, r7
   1008c:	f028 ffa4 	bl	38fd8 <memcpy>
   10090:	ab0c      	add	r3, sp, #48	; 0x30
   10092:	463a      	mov	r2, r7
   10094:	682c      	ldr	r4, [r5, #0]
   10096:	1bd0      	subs	r0, r2, r7
   10098:	4420      	add	r0, r4
   1009a:	f812 4b01 	ldrb.w	r4, [r2], #1
   1009e:	5434      	strb	r4, [r6, r0]
   100a0:	429a      	cmp	r2, r3
   100a2:	d1f7      	bne.n	10094 <bsec_o_Entity_serializeAndAdd+0x34>
   100a4:	682b      	ldr	r3, [r5, #0]
   100a6:	3318      	adds	r3, #24
   100a8:	602b      	str	r3, [r5, #0]
   100aa:	b00d      	add	sp, #52	; 0x34
   100ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
   100ae:	bf00      	nop

000100b0 <bsec_p_Entity_parseAndDeserialize>:
   100b0:	f7ff bcd2 	b.w	fa58 <bsec_b_Entity_parseAndDeserialize>

000100b4 <bsec_p_Entity_serializeAndAdd>:
   100b4:	b5f0      	push	{r4, r5, r6, r7, lr}
   100b6:	681c      	ldr	r4, [r3, #0]
   100b8:	34a8      	adds	r4, #168	; 0xa8
   100ba:	4294      	cmp	r4, r2
   100bc:	b0d5      	sub	sp, #340	; 0x154
   100be:	d903      	bls.n	100c8 <bsec_p_Entity_serializeAndAdd+0x14>
   100c0:	3201      	adds	r2, #1
   100c2:	601a      	str	r2, [r3, #0]
   100c4:	b055      	add	sp, #340	; 0x154
   100c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   100c8:	22a8      	movs	r2, #168	; 0xa8
   100ca:	eb0d 0702 	add.w	r7, sp, r2
   100ce:	460e      	mov	r6, r1
   100d0:	4601      	mov	r1, r0
   100d2:	4668      	mov	r0, sp
   100d4:	461d      	mov	r5, r3
   100d6:	f028 ff7f 	bl	38fd8 <memcpy>
   100da:	22a8      	movs	r2, #168	; 0xa8
   100dc:	4669      	mov	r1, sp
   100de:	4638      	mov	r0, r7
   100e0:	f028 ff7a 	bl	38fd8 <memcpy>
   100e4:	ab54      	add	r3, sp, #336	; 0x150
   100e6:	463a      	mov	r2, r7
   100e8:	682c      	ldr	r4, [r5, #0]
   100ea:	1bd0      	subs	r0, r2, r7
   100ec:	4420      	add	r0, r4
   100ee:	f812 4b01 	ldrb.w	r4, [r2], #1
   100f2:	5434      	strb	r4, [r6, r0]
   100f4:	429a      	cmp	r2, r3
   100f6:	d1f7      	bne.n	100e8 <bsec_p_Entity_serializeAndAdd+0x34>
   100f8:	682b      	ldr	r3, [r5, #0]
   100fa:	33a8      	adds	r3, #168	; 0xa8
   100fc:	602b      	str	r3, [r5, #0]
   100fe:	b055      	add	sp, #340	; 0x154
   10100:	bdf0      	pop	{r4, r5, r6, r7, pc}
   10102:	bf00      	nop

00010104 <bsec_q_Entity_parseAndDeserialize>:
   10104:	b530      	push	{r4, r5, lr}
   10106:	680b      	ldr	r3, [r1, #0]
   10108:	b087      	sub	sp, #28
   1010a:	3b01      	subs	r3, #1
   1010c:	4418      	add	r0, r3
   1010e:	460d      	mov	r5, r1
   10110:	f10d 0303 	add.w	r3, sp, #3
   10114:	f10d 0417 	add.w	r4, sp, #23
   10118:	f810 1f01 	ldrb.w	r1, [r0, #1]!
   1011c:	f803 1f01 	strb.w	r1, [r3, #1]!
   10120:	42a3      	cmp	r3, r4
   10122:	d1f9      	bne.n	10118 <bsec_q_Entity_parseAndDeserialize+0x14>
   10124:	4610      	mov	r0, r2
   10126:	a901      	add	r1, sp, #4
   10128:	2214      	movs	r2, #20
   1012a:	f028 ff55 	bl	38fd8 <memcpy>
   1012e:	682b      	ldr	r3, [r5, #0]
   10130:	3314      	adds	r3, #20
   10132:	602b      	str	r3, [r5, #0]
   10134:	b007      	add	sp, #28
   10136:	bd30      	pop	{r4, r5, pc}

00010138 <bsec_q_Entity_serializeAndAdd>:
   10138:	b5f0      	push	{r4, r5, r6, r7, lr}
   1013a:	681c      	ldr	r4, [r3, #0]
   1013c:	341c      	adds	r4, #28
   1013e:	4294      	cmp	r4, r2
   10140:	b089      	sub	sp, #36	; 0x24
   10142:	d903      	bls.n	1014c <bsec_q_Entity_serializeAndAdd+0x14>
   10144:	3201      	adds	r2, #1
   10146:	601a      	str	r2, [r3, #0]
   10148:	b009      	add	sp, #36	; 0x24
   1014a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1014c:	af01      	add	r7, sp, #4
   1014e:	221c      	movs	r2, #28
   10150:	460e      	mov	r6, r1
   10152:	4601      	mov	r1, r0
   10154:	4638      	mov	r0, r7
   10156:	461d      	mov	r5, r3
   10158:	f028 ff3e 	bl	38fd8 <memcpy>
   1015c:	ab08      	add	r3, sp, #32
   1015e:	463a      	mov	r2, r7
   10160:	682c      	ldr	r4, [r5, #0]
   10162:	1bd0      	subs	r0, r2, r7
   10164:	4420      	add	r0, r4
   10166:	f812 4b01 	ldrb.w	r4, [r2], #1
   1016a:	5434      	strb	r4, [r6, r0]
   1016c:	429a      	cmp	r2, r3
   1016e:	d1f7      	bne.n	10160 <bsec_q_Entity_serializeAndAdd+0x28>
   10170:	682b      	ldr	r3, [r5, #0]
   10172:	331c      	adds	r3, #28
   10174:	602b      	str	r3, [r5, #0]
   10176:	b009      	add	sp, #36	; 0x24
   10178:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1017a:	bf00      	nop

0001017c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>:
   1017c:	b538      	push	{r3, r4, r5, lr}
   1017e:	460c      	mov	r4, r1
   10180:	ed2d 8b02 	vpush	{d8}
   10184:	1e59      	subs	r1, r3, #1
   10186:	edd4 7a00 	vldr	s15, [r4]
   1018a:	4615      	mov	r5, r2
   1018c:	bbea      	cbnz	r2, 1020a <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x8e>
   1018e:	ed90 7a01 	vldr	s14, [r0, #4]
   10192:	ed9f 8a31 	vldr	s16, [pc, #196]	; 10258 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xdc>
   10196:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1019a:	edd3 6a03 	vldr	s13, [r3, #12]
   1019e:	ee27 8a08 	vmul.f32	s16, s14, s16
   101a2:	ee38 8a26 	vadd.f32	s16, s16, s13
   101a6:	8843      	ldrh	r3, [r0, #2]
   101a8:	eddf 5a2c 	vldr	s11, [pc, #176]	; 1025c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xe0>
   101ac:	ee06 3a90 	vmov	s13, r3
   101b0:	ee70 8a67 	vsub.f32	s17, s0, s15
   101b4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
   101b8:	eef5 8ac0 	vcmpe.f32	s17, #0.0
   101bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   101c0:	ee86 6aa5 	vdiv.f32	s12, s13, s11
   101c4:	dd34      	ble.n	10230 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xb4>
   101c6:	eddf 5a26 	vldr	s11, [pc, #152]	; 10260 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xe4>
   101ca:	edd0 6a10 	vldr	s13, [r0, #64]	; 0x40
   101ce:	ee27 7a25 	vmul.f32	s14, s14, s11
   101d2:	ee87 0a26 	vdiv.f32	s0, s14, s13
   101d6:	ee20 0a06 	vmul.f32	s0, s0, s12
   101da:	eef4 8ac0 	vcmpe.f32	s17, s0
   101de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   101e2:	bfd8      	it	le
   101e4:	eeb0 0a68 	vmovle.f32	s0, s17
   101e8:	ee30 0a27 	vadd.f32	s0, s0, s15
   101ec:	eeb4 0a48 	vcmp.f32	s0, s16
   101f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   101f4:	bf48      	it	mi
   101f6:	eeb0 0a48 	vmovmi.f32	s0, s16
   101fa:	b10d      	cbz	r5, 10200 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x84>
   101fc:	eeb1 0a40 	vneg.f32	s0, s0
   10200:	ecbd 8b02 	vpop	{d8}
   10204:	ed84 0a00 	vstr	s0, [r4]
   10208:	bd38      	pop	{r3, r4, r5, pc}
   1020a:	eef1 7a67 	vneg.f32	s15, s15
   1020e:	edc4 7a00 	vstr	s15, [r4]
   10212:	ed90 7a01 	vldr	s14, [r0, #4]
   10216:	ed9f 8a10 	vldr	s16, [pc, #64]	; 10258 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0xdc>
   1021a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
   1021e:	ee27 8a08 	vmul.f32	s16, s14, s16
   10222:	edd3 6a01 	vldr	s13, [r3, #4]
   10226:	eeb1 0a40 	vneg.f32	s0, s0
   1022a:	ee38 8a66 	vsub.f32	s16, s16, s13
   1022e:	e7ba      	b.n	101a6 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x2a>
   10230:	eb00 0081 	add.w	r0, r0, r1, lsl #2
   10234:	edd0 7a11 	vldr	s15, [r0, #68]	; 0x44
   10238:	eeb1 0a46 	vneg.f32	s0, s12
   1023c:	ee80 0a27 	vdiv.f32	s0, s0, s15
   10240:	f01f f9ac 	bl	2f59c <expf>
   10244:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   10248:	ee37 0ac0 	vsub.f32	s0, s15, s0
   1024c:	edd4 7a00 	vldr	s15, [r4]
   10250:	ee20 0a28 	vmul.f32	s0, s0, s17
   10254:	e7c8      	b.n	101e8 <bsec_GasHumidityBaselineTracker_filterRobustMaxMin+0x6c>
   10256:	bf00      	nop
   10258:	3dc678c1 	.word	0x3dc678c1
   1025c:	42c80000 	.word	0x42c80000
   10260:	3ecbbecb 	.word	0x3ecbbecb

00010264 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker>:
   10264:	b430      	push	{r4, r5}
   10266:	4917      	ldr	r1, [pc, #92]	; (102c4 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x60>)
   10268:	4d17      	ldr	r5, [pc, #92]	; (102c8 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x64>)
   1026a:	62c1      	str	r1, [r0, #44]	; 0x2c
   1026c:	2401      	movs	r4, #1
   1026e:	f64f 71ff 	movw	r1, #65535	; 0xffff
   10272:	7004      	strb	r4, [r0, #0]
   10274:	f04f 547d 	mov.w	r4, #1061158912	; 0x3f400000
   10278:	8041      	strh	r1, [r0, #2]
   1027a:	6344      	str	r4, [r0, #52]	; 0x34
   1027c:	4913      	ldr	r1, [pc, #76]	; (102cc <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x68>)
   1027e:	4c14      	ldr	r4, [pc, #80]	; (102d0 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x6c>)
   10280:	63c5      	str	r5, [r0, #60]	; 0x3c
   10282:	4d14      	ldr	r5, [pc, #80]	; (102d4 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x70>)
   10284:	6401      	str	r1, [r0, #64]	; 0x40
   10286:	2200      	movs	r2, #0
   10288:	2100      	movs	r1, #0
   1028a:	6444      	str	r4, [r0, #68]	; 0x44
   1028c:	6485      	str	r5, [r0, #72]	; 0x48
   1028e:	2402      	movs	r4, #2
   10290:	4d11      	ldr	r5, [pc, #68]	; (102d8 <bsec_GasHumidityBaselineTracker_GasHumidityBaselineTracker+0x74>)
   10292:	7704      	strb	r4, [r0, #28]
   10294:	7744      	strb	r4, [r0, #29]
   10296:	f880 404c 	strb.w	r4, [r0, #76]	; 0x4c
   1029a:	6305      	str	r5, [r0, #48]	; 0x30
   1029c:	6385      	str	r5, [r0, #56]	; 0x38
   1029e:	f8a0 104e 	strh.w	r1, [r0, #78]	; 0x4e
   102a2:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
   102a6:	8301      	strh	r1, [r0, #24]
   102a8:	8341      	strh	r1, [r0, #26]
   102aa:	e9c0 1108 	strd	r1, r1, [r0, #32]
   102ae:	6281      	str	r1, [r0, #40]	; 0x28
   102b0:	6542      	str	r2, [r0, #84]	; 0x54
   102b2:	6582      	str	r2, [r0, #88]	; 0x58
   102b4:	6082      	str	r2, [r0, #8]
   102b6:	6102      	str	r2, [r0, #16]
   102b8:	60c2      	str	r2, [r0, #12]
   102ba:	6142      	str	r2, [r0, #20]
   102bc:	6042      	str	r2, [r0, #4]
   102be:	bc30      	pop	{r4, r5}
   102c0:	4770      	bx	lr
   102c2:	bf00      	nop
   102c4:	3f004189 	.word	0x3f004189
   102c8:	640055d8 	.word	0x640055d8
   102cc:	44e10000 	.word	0x44e10000
   102d0:	47a8c000 	.word	0x47a8c000
   102d4:	4c773140 	.word	0x4c773140
   102d8:	3ecccccd 	.word	0x3ecccccd

000102dc <bsec_GasHumidityBaselineTracker_configure>:
   102dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   102e0:	b087      	sub	sp, #28
   102e2:	ab04      	add	r3, sp, #16
   102e4:	ae05      	add	r6, sp, #20
   102e6:	4605      	mov	r5, r0
   102e8:	7800      	ldrb	r0, [r0, #0]
   102ea:	9300      	str	r3, [sp, #0]
   102ec:	9601      	str	r6, [sp, #4]
   102ee:	f10d 030f 	add.w	r3, sp, #15
   102f2:	460f      	mov	r7, r1
   102f4:	f001 fb9c 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   102f8:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   102fc:	bb30      	cbnz	r0, 1034c <bsec_GasHumidityBaselineTracker_configure+0x70>
   102fe:	4604      	mov	r4, r0
   10300:	f105 0a3e 	add.w	sl, r5, #62	; 0x3e
   10304:	f105 093c 	add.w	r9, r5, #60	; 0x3c
   10308:	f105 084e 	add.w	r8, r5, #78	; 0x4e
   1030c:	fa5f fb84 	uxtb.w	fp, r4
   10310:	f10b 0301 	add.w	r3, fp, #1
   10314:	b2db      	uxtb	r3, r3
   10316:	3b02      	subs	r3, #2
   10318:	2b05      	cmp	r3, #5
   1031a:	d804      	bhi.n	10326 <bsec_GasHumidityBaselineTracker_configure+0x4a>
   1031c:	e8df f003 	tbb	[pc, r3]
   10320:	1f252b32 	.word	0x1f252b32
   10324:	0e19      	.short	0x0e19
   10326:	f105 0244 	add.w	r2, r5, #68	; 0x44
   1032a:	4631      	mov	r1, r6
   1032c:	4638      	mov	r0, r7
   1032e:	f7ff fb93 	bl	fa58 <bsec_b_Entity_parseAndDeserialize>
   10332:	f1bb 0f06 	cmp.w	fp, #6
   10336:	d007      	beq.n	10348 <bsec_GasHumidityBaselineTracker_configure+0x6c>
   10338:	3401      	adds	r4, #1
   1033a:	e7e7      	b.n	1030c <bsec_GasHumidityBaselineTracker_configure+0x30>
   1033c:	f105 0254 	add.w	r2, r5, #84	; 0x54
   10340:	4631      	mov	r1, r6
   10342:	4638      	mov	r0, r7
   10344:	f7ff fb88 	bl	fa58 <bsec_b_Entity_parseAndDeserialize>
   10348:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   1034c:	b007      	add	sp, #28
   1034e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10352:	4652      	mov	r2, sl
   10354:	4631      	mov	r1, r6
   10356:	4638      	mov	r0, r7
   10358:	f7ff fbfa 	bl	fb50 <bsec_d_Entity_parseAndDeserialize>
   1035c:	e7ec      	b.n	10338 <bsec_GasHumidityBaselineTracker_configure+0x5c>
   1035e:	464a      	mov	r2, r9
   10360:	4631      	mov	r1, r6
   10362:	4638      	mov	r0, r7
   10364:	f7ff fe2a 	bl	ffbc <bsec_n_Entity_parseAndDeserialize>
   10368:	e7e6      	b.n	10338 <bsec_GasHumidityBaselineTracker_configure+0x5c>
   1036a:	4642      	mov	r2, r8
   1036c:	4631      	mov	r1, r6
   1036e:	4638      	mov	r0, r7
   10370:	f7ff fdea 	bl	ff48 <bsec_m_Entity_parseAndDeserialize>
   10374:	e7e0      	b.n	10338 <bsec_GasHumidityBaselineTracker_configure+0x5c>
   10376:	f105 022c 	add.w	r2, r5, #44	; 0x2c
   1037a:	4631      	mov	r1, r6
   1037c:	4638      	mov	r0, r7
   1037e:	f7ff fdab 	bl	fed8 <bsec_l_Entity_parseAndDeserialize>
   10382:	e7d9      	b.n	10338 <bsec_GasHumidityBaselineTracker_configure+0x5c>
   10384:	4631      	mov	r1, r6
   10386:	4638      	mov	r0, r7
   10388:	f7ff fc1e 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   1038c:	ed85 0a10 	vstr	s0, [r5, #64]	; 0x40
   10390:	e7d2      	b.n	10338 <bsec_GasHumidityBaselineTracker_configure+0x5c>
   10392:	bf00      	nop

00010394 <bsec_GasHumidityBaselineTracker_doStep>:
   10394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10398:	ed9f 7adc 	vldr	s14, [pc, #880]	; 1070c <bsec_GasHumidityBaselineTracker_doStep+0x378>
   1039c:	eddf 7adc 	vldr	s15, [pc, #880]	; 10710 <bsec_GasHumidityBaselineTracker_doStep+0x37c>
   103a0:	eddf 6adc 	vldr	s13, [pc, #880]	; 10714 <bsec_GasHumidityBaselineTracker_doStep+0x380>
   103a4:	ed2d 8b0a 	vpush	{d8-d12}
   103a8:	ee20 7a87 	vmul.f32	s14, s1, s14
   103ac:	ee70 7aa7 	vadd.f32	s15, s1, s15
   103b0:	edd0 8a01 	vldr	s17, [r0, #4]
   103b4:	b089      	sub	sp, #36	; 0x24
   103b6:	eeb0 aa40 	vmov.f32	s20, s0
   103ba:	ee87 0a27 	vdiv.f32	s0, s14, s15
   103be:	461d      	mov	r5, r3
   103c0:	4604      	mov	r4, r0
   103c2:	468a      	mov	sl, r1
   103c4:	4693      	mov	fp, r2
   103c6:	e9dd 761c 	ldrd	r7, r6, [sp, #112]	; 0x70
   103ca:	eeb0 8a60 	vmov.f32	s16, s1
   103ce:	eeb0 9a41 	vmov.f32	s18, s2
   103d2:	eef0 9a61 	vmov.f32	s19, s3
   103d6:	ee68 8aa6 	vmul.f32	s17, s17, s13
   103da:	f01f f8df 	bl	2f59c <expf>
   103de:	ed9f 6ace 	vldr	s12, [pc, #824]	; 10718 <bsec_GasHumidityBaselineTracker_doStep+0x384>
   103e2:	eddf 7ace 	vldr	s15, [pc, #824]	; 1071c <bsec_GasHumidityBaselineTracker_doStep+0x388>
   103e6:	ed9f 7ace 	vldr	s14, [pc, #824]	; 10720 <bsec_GasHumidityBaselineTracker_doStep+0x38c>
   103ea:	ed9f 5ace 	vldr	s10, [pc, #824]	; 10724 <bsec_GasHumidityBaselineTracker_doStep+0x390>
   103ee:	eddf 5ace 	vldr	s11, [pc, #824]	; 10728 <bsec_GasHumidityBaselineTracker_doStep+0x394>
   103f2:	ee29 6a06 	vmul.f32	s12, s18, s12
   103f6:	ee38 7a07 	vadd.f32	s14, s16, s14
   103fa:	eec6 6a27 	vdiv.f32	s13, s12, s15
   103fe:	ee26 0a80 	vmul.f32	s0, s13, s0
   10402:	eec0 7a07 	vdiv.f32	s15, s0, s14
   10406:	ee67 7a85 	vmul.f32	s15, s15, s10
   1040a:	eef4 7ae5 	vcmpe.f32	s15, s11
   1040e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10412:	bfdc      	itt	le
   10414:	f10d 0820 	addle.w	r8, sp, #32
   10418:	ee15 3a90 	vmovle	r3, s11
   1041c:	edcd 7a06 	vstr	s15, [sp, #24]
   10420:	bfd4      	ite	le
   10422:	f848 3d08 	strle.w	r3, [r8, #-8]!
   10426:	f10d 0818 	addgt.w	r8, sp, #24
   1042a:	4640      	mov	r0, r8
   1042c:	f001 fbd8 	bl	11be0 <bsec_log10>
   10430:	8863      	ldrh	r3, [r4, #2]
   10432:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   10436:	f000 8142 	beq.w	106be <bsec_GasHumidityBaselineTracker_doStep+0x32a>
   1043a:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
   1043e:	f000 813b 	beq.w	106b8 <bsec_GasHumidityBaselineTracker_doStep+0x324>
   10442:	2b64      	cmp	r3, #100	; 0x64
   10444:	f000 809f 	beq.w	10586 <bsec_GasHumidityBaselineTracker_doStep+0x1f2>
   10448:	ed94 0a0b 	vldr	s0, [r4, #44]	; 0x2c
   1044c:	eddd 7a06 	vldr	s15, [sp, #24]
   10450:	ee20 0a27 	vmul.f32	s0, s0, s15
   10454:	ee30 0a0a 	vadd.f32	s0, s0, s20
   10458:	ed86 0a00 	vstr	s0, [r6]
   1045c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
   10460:	ee07 3a90 	vmov	s15, r3
   10464:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10468:	eeb4 8ae7 	vcmpe.f32	s16, s15
   1046c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10470:	d836      	bhi.n	104e0 <bsec_GasHumidityBaselineTracker_doStep+0x14c>
   10472:	f994 303c 	ldrsb.w	r3, [r4, #60]	; 0x3c
   10476:	ee07 3a90 	vmov	s15, r3
   1047a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   1047e:	eeb4 8ae7 	vcmpe.f32	s16, s15
   10482:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10486:	f2c0 8081 	blt.w	1058c <bsec_GasHumidityBaselineTracker_doStep+0x1f8>
   1048a:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   1048e:	ee07 3a90 	vmov	s15, r3
   10492:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   10496:	eeb4 9ae7 	vcmpe.f32	s18, s15
   1049a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1049e:	d875      	bhi.n	1058c <bsec_GasHumidityBaselineTracker_doStep+0x1f8>
   104a0:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
   104a4:	ee07 3a90 	vmov	s15, r3
   104a8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   104ac:	eeb4 9ae7 	vcmpe.f32	s18, s15
   104b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   104b4:	db6a      	blt.n	1058c <bsec_GasHumidityBaselineTracker_doStep+0x1f8>
   104b6:	f1bb 0f00 	cmp.w	fp, #0
   104ba:	d011      	beq.n	104e0 <bsec_GasHumidityBaselineTracker_doStep+0x14c>
   104bc:	b995      	cbnz	r5, 104e4 <bsec_GasHumidityBaselineTracker_doStep+0x150>
   104be:	eef5 9a40 	vcmp.f32	s19, #0.0
   104c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   104c6:	8d25      	ldrh	r5, [r4, #40]	; 0x28
   104c8:	f040 8189 	bne.w	107de <bsec_GasHumidityBaselineTracker_doStep+0x44a>
   104cc:	2d00      	cmp	r5, #0
   104ce:	f000 813d 	beq.w	1074c <bsec_GasHumidityBaselineTracker_doStep+0x3b8>
   104d2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
   104d4:	1aed      	subs	r5, r5, r3
   104d6:	f104 0308 	add.w	r3, r4, #8
   104da:	8525      	strh	r5, [r4, #40]	; 0x28
   104dc:	9301      	str	r3, [sp, #4]
   104de:	e05d      	b.n	1059c <bsec_GasHumidityBaselineTracker_doStep+0x208>
   104e0:	2d00      	cmp	r5, #0
   104e2:	d058      	beq.n	10596 <bsec_GasHumidityBaselineTracker_doStep+0x202>
   104e4:	edd4 7a02 	vldr	s15, [r4, #8]
   104e8:	eef5 7a40 	vcmp.f32	s15, #0.0
   104ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   104f0:	bf18      	it	ne
   104f2:	edcd 7a02 	vstrne	s15, [sp, #8]
   104f6:	edd4 7a04 	vldr	s15, [r4, #16]
   104fa:	bf04      	itt	eq
   104fc:	6833      	ldreq	r3, [r6, #0]
   104fe:	9302      	streq	r3, [sp, #8]
   10500:	eef5 7a40 	vcmp.f32	s15, #0.0
   10504:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10508:	bf08      	it	eq
   1050a:	eddd 7a02 	vldreq	s15, [sp, #8]
   1050e:	6a23      	ldr	r3, [r4, #32]
   10510:	9306      	str	r3, [sp, #24]
   10512:	bf08      	it	eq
   10514:	ee77 7ae8 	vsubeq.f32	s15, s15, s17
   10518:	2208      	movs	r2, #8
   1051a:	edcd 7a04 	vstr	s15, [sp, #16]
   1051e:	edd4 7a03 	vldr	s15, [r4, #12]
   10522:	eef5 7a40 	vcmp.f32	s15, #0.0
   10526:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1052a:	bf18      	it	ne
   1052c:	edcd 7a03 	vstrne	s15, [sp, #12]
   10530:	edd4 7a05 	vldr	s15, [r4, #20]
   10534:	bf04      	itt	eq
   10536:	6833      	ldreq	r3, [r6, #0]
   10538:	9303      	streq	r3, [sp, #12]
   1053a:	eef5 7a40 	vcmp.f32	s15, #0.0
   1053e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10542:	bf08      	it	eq
   10544:	eddd 7a03 	vldreq	s15, [sp, #12]
   10548:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1054a:	bf14      	ite	ne
   1054c:	edcd 7a05 	vstrne	s15, [sp, #20]
   10550:	ee77 8ae8 	vsubeq.f32	s17, s15, s17
   10554:	eb0d 0102 	add.w	r1, sp, r2
   10558:	4638      	mov	r0, r7
   1055a:	bf08      	it	eq
   1055c:	edcd 8a05 	vstreq	s17, [sp, #20]
   10560:	9307      	str	r3, [sp, #28]
   10562:	f028 fd39 	bl	38fd8 <memcpy>
   10566:	2208      	movs	r2, #8
   10568:	a904      	add	r1, sp, #16
   1056a:	18b8      	adds	r0, r7, r2
   1056c:	f028 fd34 	bl	38fd8 <memcpy>
   10570:	4641      	mov	r1, r8
   10572:	f107 0010 	add.w	r0, r7, #16
   10576:	2208      	movs	r2, #8
   10578:	f028 fd2e 	bl	38fd8 <memcpy>
   1057c:	b009      	add	sp, #36	; 0x24
   1057e:	ecbd 8b0a 	vpop	{d8-d12}
   10582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10586:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
   1058a:	e75f      	b.n	1044c <bsec_GasHumidityBaselineTracker_doStep+0xb8>
   1058c:	f1bb 0f00 	cmp.w	fp, #0
   10590:	d0a6      	beq.n	104e0 <bsec_GasHumidityBaselineTracker_doStep+0x14c>
   10592:	2d00      	cmp	r5, #0
   10594:	d1a6      	bne.n	104e4 <bsec_GasHumidityBaselineTracker_doStep+0x150>
   10596:	f104 0308 	add.w	r3, r4, #8
   1059a:	9301      	str	r3, [sp, #4]
   1059c:	9d01      	ldr	r5, [sp, #4]
   1059e:	eddf 9a63 	vldr	s19, [pc, #396]	; 1072c <bsec_GasHumidityBaselineTracker_doStep+0x398>
   105a2:	ed9f ba63 	vldr	s22, [pc, #396]	; 10730 <bsec_GasHumidityBaselineTracker_doStep+0x39c>
   105a6:	eddf aa63 	vldr	s21, [pc, #396]	; 10734 <bsec_GasHumidityBaselineTracker_doStep+0x3a0>
   105aa:	ed9f aa63 	vldr	s20, [pc, #396]	; 10738 <bsec_GasHumidityBaselineTracker_doStep+0x3a4>
   105ae:	971c      	str	r7, [sp, #112]	; 0x70
   105b0:	f104 091c 	add.w	r9, r4, #28
   105b4:	f104 0310 	add.w	r3, r4, #16
   105b8:	464f      	mov	r7, r9
   105ba:	9301      	str	r3, [sp, #4]
   105bc:	eef7 ba00 	vmov.f32	s23, #112	; 0x3f800000  1.0
   105c0:	46a9      	mov	r9, r5
   105c2:	ed99 7a00 	vldr	s14, [r9]
   105c6:	edd9 7a02 	vldr	s15, [r9, #8]
   105ca:	eeb4 7ac0 	vcmpe.f32	s14, s0
   105ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   105d2:	f240 8088 	bls.w	106e6 <bsec_GasHumidityBaselineTracker_doStep+0x352>
   105d6:	eef4 7ac0 	vcmpe.f32	s15, s0
   105da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   105de:	bfac      	ite	ge
   105e0:	2501      	movge	r5, #1
   105e2:	2500      	movlt	r5, #0
   105e4:	ee37 9a40 	vsub.f32	s18, s14, s0
   105e8:	ee30 8a67 	vsub.f32	s16, s0, s15
   105ec:	eeb5 9ac0 	vcmpe.f32	s18, #0.0
   105f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   105f4:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   105f8:	bf48      	it	mi
   105fa:	eeb0 9a69 	vmovmi.f32	s18, s19
   105fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10602:	eef5 7a40 	vcmp.f32	s15, #0.0
   10606:	bf48      	it	mi
   10608:	eeb0 8a69 	vmovmi.f32	s16, s19
   1060c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10610:	d16d      	bne.n	106ee <bsec_GasHumidityBaselineTracker_doStep+0x35a>
   10612:	eeb0 ca68 	vmov.f32	s24, s17
   10616:	eef0 0a48 	vmov.f32	s1, s16
   1061a:	eeb0 0a49 	vmov.f32	s0, s18
   1061e:	f01e ff35 	bl	2f48c <fminf>
   10622:	ee30 0a00 	vadd.f32	s0, s0, s0
   10626:	eec0 7a0c 	vdiv.f32	s15, s0, s24
   1062a:	eef4 7a6b 	vcmp.f32	s15, s23
   1062e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10632:	bfc8      	it	gt
   10634:	eef0 7a6b 	vmovgt.f32	s15, s23
   10638:	f1ba 0f00 	cmp.w	sl, #0
   1063c:	d042      	beq.n	106c4 <bsec_GasHumidityBaselineTracker_doStep+0x330>
   1063e:	f1bb 0f00 	cmp.w	fp, #0
   10642:	d03f      	beq.n	106c4 <bsec_GasHumidityBaselineTracker_doStep+0x330>
   10644:	edd9 6a06 	vldr	s13, [r9, #24]
   10648:	eeb0 7a08 	vmov.f32	s14, #8	; 0x40400000  3.0
   1064c:	eef4 6a47 	vcmp.f32	s13, s14
   10650:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10654:	d172      	bne.n	1073c <bsec_GasHumidityBaselineTracker_doStep+0x3a8>
   10656:	ee7b 7ae7 	vsub.f32	s15, s23, s15
   1065a:	eeb6 7a08 	vmov.f32	s14, #104	; 0x3f400000  0.750
   1065e:	ee67 7aa7 	vmul.f32	s15, s15, s15
   10662:	ee67 7a87 	vmul.f32	s15, s15, s14
   10666:	ee67 7aaa 	vmul.f32	s15, s15, s21
   1066a:	ee77 7a8a 	vadd.f32	s15, s15, s20
   1066e:	eef0 6a68 	vmov.f32	s13, s17
   10672:	ee48 6aa7 	vmla.f32	s13, s17, s15
   10676:	ed99 7a02 	vldr	s14, [r9, #8]
   1067a:	edd9 7a00 	vldr	s15, [r9]
   1067e:	ee77 7ac7 	vsub.f32	s15, s15, s14
   10682:	eef4 6ae7 	vcmpe.f32	s13, s15
   10686:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1068a:	dc39      	bgt.n	10700 <bsec_GasHumidityBaselineTracker_doStep+0x36c>
   1068c:	eeb5 7a40 	vcmp.f32	s14, #0.0
   10690:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10694:	d034      	beq.n	10700 <bsec_GasHumidityBaselineTracker_doStep+0x36c>
   10696:	2d00      	cmp	r5, #0
   10698:	d153      	bne.n	10742 <bsec_GasHumidityBaselineTracker_doStep+0x3ae>
   1069a:	7839      	ldrb	r1, [r7, #0]
   1069c:	29ff      	cmp	r1, #255	; 0xff
   1069e:	f000 80c2 	beq.w	10826 <bsec_GasHumidityBaselineTracker_doStep+0x492>
   106a2:	3101      	adds	r1, #1
   106a4:	b2c9      	uxtb	r1, r1
   106a6:	7039      	strb	r1, [r7, #0]
   106a8:	f894 004c 	ldrb.w	r0, [r4, #76]	; 0x4c
   106ac:	4288      	cmp	r0, r1
   106ae:	f240 80ba 	bls.w	10826 <bsec_GasHumidityBaselineTracker_doStep+0x492>
   106b2:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   106b6:	e00a      	b.n	106ce <bsec_GasHumidityBaselineTracker_doStep+0x33a>
   106b8:	ed94 0a0c 	vldr	s0, [r4, #48]	; 0x30
   106bc:	e6c6      	b.n	1044c <bsec_GasHumidityBaselineTracker_doStep+0xb8>
   106be:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
   106c2:	e6c3      	b.n	1044c <bsec_GasHumidityBaselineTracker_doStep+0xb8>
   106c4:	f894 104c 	ldrb.w	r1, [r4, #76]	; 0x4c
   106c8:	7039      	strb	r1, [r7, #0]
   106ca:	eef0 7a69 	vmov.f32	s15, s19
   106ce:	9b01      	ldr	r3, [sp, #4]
   106d0:	edc9 7a06 	vstr	s15, [r9, #24]
   106d4:	f109 0904 	add.w	r9, r9, #4
   106d8:	454b      	cmp	r3, r9
   106da:	f107 0701 	add.w	r7, r7, #1
   106de:	d004      	beq.n	106ea <bsec_GasHumidityBaselineTracker_doStep+0x356>
   106e0:	ed96 0a00 	vldr	s0, [r6]
   106e4:	e76d      	b.n	105c2 <bsec_GasHumidityBaselineTracker_doStep+0x22e>
   106e6:	2501      	movs	r5, #1
   106e8:	e77c      	b.n	105e4 <bsec_GasHumidityBaselineTracker_doStep+0x250>
   106ea:	9f1c      	ldr	r7, [sp, #112]	; 0x70
   106ec:	e6fa      	b.n	104e4 <bsec_GasHumidityBaselineTracker_doStep+0x150>
   106ee:	ee37 0a67 	vsub.f32	s0, s14, s15
   106f2:	eef0 0a68 	vmov.f32	s1, s17
   106f6:	f01e feab 	bl	2f450 <fmaxf>
   106fa:	eeb0 ca40 	vmov.f32	s24, s0
   106fe:	e78a      	b.n	10616 <bsec_GasHumidityBaselineTracker_doStep+0x282>
   10700:	f894 104c 	ldrb.w	r1, [r4, #76]	; 0x4c
   10704:	7039      	strb	r1, [r7, #0]
   10706:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1070a:	e7e0      	b.n	106ce <bsec_GasHumidityBaselineTracker_doStep+0x33a>
   1070c:	418cf5c3 	.word	0x418cf5c3
   10710:	43731eb8 	.word	0x43731eb8
   10714:	3dc678c1 	.word	0x3dc678c1
   10718:	40c39581 	.word	0x40c39581
   1071c:	42c80000 	.word	0x42c80000
   10720:	43889333 	.word	0x43889333
   10724:	4358b333 	.word	0x4358b333
   10728:	3c23d70a 	.word	0x3c23d70a
   1072c:	00000000 	.word	0x00000000
   10730:	3e99999a 	.word	0x3e99999a
   10734:	3e4ccccd 	.word	0x3e4ccccd
   10738:	3dcccccd 	.word	0x3dcccccd
   1073c:	eef0 7a4b 	vmov.f32	s15, s22
   10740:	e795      	b.n	1066e <bsec_GasHumidityBaselineTracker_doStep+0x2da>
   10742:	2100      	movs	r1, #0
   10744:	7039      	strb	r1, [r7, #0]
   10746:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   1074a:	e7c0      	b.n	106ce <bsec_GasHumidityBaselineTracker_doStep+0x33a>
   1074c:	f104 0308 	add.w	r3, r4, #8
   10750:	9301      	str	r3, [sp, #4]
   10752:	461d      	mov	r5, r3
   10754:	f04f 0901 	mov.w	r9, #1
   10758:	edd5 7a00 	vldr	s15, [r5]
   1075c:	eef5 7a40 	vcmp.f32	s15, #0.0
   10760:	edd5 7a02 	vldr	s15, [r5, #8]
   10764:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10768:	bf08      	it	eq
   1076a:	ed85 0a00 	vstreq	s0, [r5]
   1076e:	eef5 7a40 	vcmp.f32	s15, #0.0
   10772:	bf08      	it	eq
   10774:	ed96 0a00 	vldreq	s0, [r6]
   10778:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1077c:	464b      	mov	r3, r9
   1077e:	4629      	mov	r1, r5
   10780:	f04f 0200 	mov.w	r2, #0
   10784:	4620      	mov	r0, r4
   10786:	d10c      	bne.n	107a2 <bsec_GasHumidityBaselineTracker_doStep+0x40e>
   10788:	edd5 7a00 	vldr	s15, [r5]
   1078c:	ee77 7ae8 	vsub.f32	s15, s15, s17
   10790:	eef4 7ac0 	vcmpe.f32	s15, s0
   10794:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10798:	bfc4      	itt	gt
   1079a:	ed85 0a02 	vstrgt	s0, [r5, #8]
   1079e:	ed96 0a00 	vldrgt	s0, [r6]
   107a2:	f7ff fceb 	bl	1017c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
   107a6:	edd5 7a02 	vldr	s15, [r5, #8]
   107aa:	eef5 7a40 	vcmp.f32	s15, #0.0
   107ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   107b2:	d10a      	bne.n	107ca <bsec_GasHumidityBaselineTracker_doStep+0x436>
   107b4:	f1b9 0f02 	cmp.w	r9, #2
   107b8:	f105 0504 	add.w	r5, r5, #4
   107bc:	ed96 0a00 	vldr	s0, [r6]
   107c0:	f43f aeec 	beq.w	1059c <bsec_GasHumidityBaselineTracker_doStep+0x208>
   107c4:	f04f 0902 	mov.w	r9, #2
   107c8:	e7c6      	b.n	10758 <bsec_GasHumidityBaselineTracker_doStep+0x3c4>
   107ca:	464b      	mov	r3, r9
   107cc:	2201      	movs	r2, #1
   107ce:	f105 0108 	add.w	r1, r5, #8
   107d2:	ed96 0a00 	vldr	s0, [r6]
   107d6:	4620      	mov	r0, r4
   107d8:	f7ff fcd0 	bl	1017c <bsec_GasHumidityBaselineTracker_filterRobustMaxMin>
   107dc:	e7ea      	b.n	107b4 <bsec_GasHumidityBaselineTracker_doStep+0x420>
   107de:	eefd 7ae9 	vcvt.s32.f32	s15, s19
   107e2:	f104 0208 	add.w	r2, r4, #8
   107e6:	ee17 3a90 	vmov	r3, s15
   107ea:	9201      	str	r2, [sp, #4]
   107ec:	eb04 0243 	add.w	r2, r4, r3, lsl #1
   107f0:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   107f4:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
   107f8:	ed93 0a14 	vldr	s0, [r3, #80]	; 0x50
   107fc:	1aab      	subs	r3, r5, r2
   107fe:	b29b      	uxth	r3, r3
   10800:	ee07 3a90 	vmov	s15, r3
   10804:	eeb8 8a67 	vcvt.f32.u32	s16, s15
   10808:	f01e fec8 	bl	2f59c <expf>
   1080c:	ee88 0a00 	vdiv.f32	s0, s16, s0
   10810:	f01e fe76 	bl	2f500 <roundf>
   10814:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   10818:	ed96 0a00 	vldr	s0, [r6]
   1081c:	ee17 3a90 	vmov	r3, s15
   10820:	1aed      	subs	r5, r5, r3
   10822:	8525      	strh	r5, [r4, #40]	; 0x28
   10824:	e6ba      	b.n	1059c <bsec_GasHumidityBaselineTracker_doStep+0x208>
   10826:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   1082a:	e750      	b.n	106ce <bsec_GasHumidityBaselineTracker_doStep+0x33a>

0001082c <bsec_GasHumidityBaselineTracker_getConfiguration>:
   1082c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10830:	b085      	sub	sp, #20
   10832:	ac04      	add	r4, sp, #16
   10834:	2507      	movs	r5, #7
   10836:	f804 5d09 	strb.w	r5, [r4, #-9]!
   1083a:	4606      	mov	r6, r0
   1083c:	4617      	mov	r7, r2
   1083e:	7800      	ldrb	r0, [r0, #0]
   10840:	4622      	mov	r2, r4
   10842:	460d      	mov	r5, r1
   10844:	f001 f922 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   10848:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1084c:	9003      	str	r0, [sp, #12]
   1084e:	b1d2      	cbz	r2, 10886 <bsec_GasHumidityBaselineTracker_getConfiguration+0x5a>
   10850:	2401      	movs	r4, #1
   10852:	f106 0954 	add.w	r9, r6, #84	; 0x54
   10856:	f106 083e 	add.w	r8, r6, #62	; 0x3e
   1085a:	1e63      	subs	r3, r4, #1
   1085c:	2b06      	cmp	r3, #6
   1085e:	d80d      	bhi.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   10860:	e8df f003 	tbb	[pc, r3]
   10864:	4953353f 	.word	0x4953353f
   10868:	222b      	.short	0x222b
   1086a:	04          	.byte	0x04
   1086b:	00          	.byte	0x00
   1086c:	463a      	mov	r2, r7
   1086e:	ab03      	add	r3, sp, #12
   10870:	4629      	mov	r1, r5
   10872:	4648      	mov	r0, r9
   10874:	f7ff f90a 	bl	fa8c <bsec_b_Entity_serializeAndAdd>
   10878:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1087c:	3401      	adds	r4, #1
   1087e:	b2e4      	uxtb	r4, r4
   10880:	42a2      	cmp	r2, r4
   10882:	d2ea      	bcs.n	1085a <bsec_GasHumidityBaselineTracker_getConfiguration+0x2e>
   10884:	9803      	ldr	r0, [sp, #12]
   10886:	a904      	add	r1, sp, #16
   10888:	2202      	movs	r2, #2
   1088a:	f821 0d06 	strh.w	r0, [r1, #-6]!
   1088e:	a802      	add	r0, sp, #8
   10890:	f028 fba2 	bl	38fd8 <memcpy>
   10894:	f89d 2008 	ldrb.w	r2, [sp, #8]
   10898:	f89d 3009 	ldrb.w	r3, [sp, #9]
   1089c:	9803      	ldr	r0, [sp, #12]
   1089e:	702a      	strb	r2, [r5, #0]
   108a0:	706b      	strb	r3, [r5, #1]
   108a2:	b005      	add	sp, #20
   108a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   108a8:	463a      	mov	r2, r7
   108aa:	ab03      	add	r3, sp, #12
   108ac:	4629      	mov	r1, r5
   108ae:	4640      	mov	r0, r8
   108b0:	f7ff f964 	bl	fb7c <bsec_d_Entity_serializeAndAdd>
   108b4:	f89d 2007 	ldrb.w	r2, [sp, #7]
   108b8:	e7e0      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   108ba:	463a      	mov	r2, r7
   108bc:	ab03      	add	r3, sp, #12
   108be:	4629      	mov	r1, r5
   108c0:	f106 003c 	add.w	r0, r6, #60	; 0x3c
   108c4:	f7ff fae2 	bl	fe8c <bsec_k_Entity_serializeAndAdd>
   108c8:	f89d 2007 	ldrb.w	r2, [sp, #7]
   108cc:	e7d6      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   108ce:	aa03      	add	r2, sp, #12
   108d0:	4639      	mov	r1, r7
   108d2:	4628      	mov	r0, r5
   108d4:	ed96 0a10 	vldr	s0, [r6, #64]	; 0x40
   108d8:	f7ff f990 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   108dc:	f89d 2007 	ldrb.w	r2, [sp, #7]
   108e0:	e7cc      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   108e2:	463a      	mov	r2, r7
   108e4:	ab03      	add	r3, sp, #12
   108e6:	4629      	mov	r1, r5
   108e8:	f106 0044 	add.w	r0, r6, #68	; 0x44
   108ec:	f7ff f8ce 	bl	fa8c <bsec_b_Entity_serializeAndAdd>
   108f0:	f89d 2007 	ldrb.w	r2, [sp, #7]
   108f4:	e7c2      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   108f6:	463a      	mov	r2, r7
   108f8:	ab03      	add	r3, sp, #12
   108fa:	4629      	mov	r1, r5
   108fc:	f106 004e 	add.w	r0, r6, #78	; 0x4e
   10900:	f7ff fa82 	bl	fe08 <bsec_j_Entity_serializeAndAdd>
   10904:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10908:	e7b8      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   1090a:	463a      	mov	r2, r7
   1090c:	ab03      	add	r3, sp, #12
   1090e:	4629      	mov	r1, r5
   10910:	f106 002c 	add.w	r0, r6, #44	; 0x2c
   10914:	f7ff fa36 	bl	fd84 <bsec_i_Entity_serializeAndAdd>
   10918:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1091c:	e7ae      	b.n	1087c <bsec_GasHumidityBaselineTracker_getConfiguration+0x50>
   1091e:	bf00      	nop

00010920 <bsec_GasHumidityBaselineTracker_getState>:
   10920:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   10924:	b085      	sub	sp, #20
   10926:	ac04      	add	r4, sp, #16
   10928:	250b      	movs	r5, #11
   1092a:	f804 5d09 	strb.w	r5, [r4, #-9]!
   1092e:	4606      	mov	r6, r0
   10930:	4617      	mov	r7, r2
   10932:	7800      	ldrb	r0, [r0, #0]
   10934:	4622      	mov	r2, r4
   10936:	460d      	mov	r5, r1
   10938:	f001 f8a8 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   1093c:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10940:	9003      	str	r0, [sp, #12]
   10942:	b1ea      	cbz	r2, 10980 <bsec_GasHumidityBaselineTracker_getState+0x60>
   10944:	2401      	movs	r4, #1
   10946:	f106 0920 	add.w	r9, r6, #32
   1094a:	f106 081c 	add.w	r8, r6, #28
   1094e:	1e63      	subs	r3, r4, #1
   10950:	2b0a      	cmp	r3, #10
   10952:	d810      	bhi.n	10976 <bsec_GasHumidityBaselineTracker_getState+0x56>
   10954:	e8df f003 	tbb	[pc, r3]
   10958:	7482909f 	.word	0x7482909f
   1095c:	404d5a67 	.word	0x404d5a67
   10960:	2533      	.short	0x2533
   10962:	06          	.byte	0x06
   10963:	00          	.byte	0x00
   10964:	463a      	mov	r2, r7
   10966:	ab03      	add	r3, sp, #12
   10968:	4629      	mov	r1, r5
   1096a:	f896 004c 	ldrb.w	r0, [r6, #76]	; 0x4c
   1096e:	f7ff f97d 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
   10972:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10976:	3401      	adds	r4, #1
   10978:	b2e4      	uxtb	r4, r4
   1097a:	42a2      	cmp	r2, r4
   1097c:	d2e7      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   1097e:	9803      	ldr	r0, [sp, #12]
   10980:	a904      	add	r1, sp, #16
   10982:	2202      	movs	r2, #2
   10984:	f821 0d06 	strh.w	r0, [r1, #-6]!
   10988:	a802      	add	r0, sp, #8
   1098a:	f028 fb25 	bl	38fd8 <memcpy>
   1098e:	f89d 2008 	ldrb.w	r2, [sp, #8]
   10992:	f89d 3009 	ldrb.w	r3, [sp, #9]
   10996:	9803      	ldr	r0, [sp, #12]
   10998:	702a      	strb	r2, [r5, #0]
   1099a:	706b      	strb	r3, [r5, #1]
   1099c:	b005      	add	sp, #20
   1099e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   109a2:	aa03      	add	r2, sp, #12
   109a4:	4639      	mov	r1, r7
   109a6:	4628      	mov	r0, r5
   109a8:	ed96 0a01 	vldr	s0, [r6, #4]
   109ac:	f7ff f926 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   109b0:	3401      	adds	r4, #1
   109b2:	f89d 2007 	ldrb.w	r2, [sp, #7]
   109b6:	b2e4      	uxtb	r4, r4
   109b8:	42a2      	cmp	r2, r4
   109ba:	d2c8      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   109bc:	e7df      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   109be:	463a      	mov	r2, r7
   109c0:	ab03      	add	r3, sp, #12
   109c2:	4629      	mov	r1, r5
   109c4:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
   109c6:	f7ff f8a1 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   109ca:	3401      	adds	r4, #1
   109cc:	f89d 2007 	ldrb.w	r2, [sp, #7]
   109d0:	b2e4      	uxtb	r4, r4
   109d2:	42a2      	cmp	r2, r4
   109d4:	d2bb      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   109d6:	e7d2      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   109d8:	463a      	mov	r2, r7
   109da:	ab03      	add	r3, sp, #12
   109dc:	4629      	mov	r1, r5
   109de:	8d30      	ldrh	r0, [r6, #40]	; 0x28
   109e0:	f7ff f894 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   109e4:	3401      	adds	r4, #1
   109e6:	f89d 2007 	ldrb.w	r2, [sp, #7]
   109ea:	b2e4      	uxtb	r4, r4
   109ec:	42a2      	cmp	r2, r4
   109ee:	d2ae      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   109f0:	e7c5      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   109f2:	463a      	mov	r2, r7
   109f4:	ab03      	add	r3, sp, #12
   109f6:	4629      	mov	r1, r5
   109f8:	4648      	mov	r0, r9
   109fa:	f7ff f847 	bl	fa8c <bsec_b_Entity_serializeAndAdd>
   109fe:	3401      	adds	r4, #1
   10a00:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a04:	b2e4      	uxtb	r4, r4
   10a06:	42a2      	cmp	r2, r4
   10a08:	d2a1      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a0a:	e7b8      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a0c:	463a      	mov	r2, r7
   10a0e:	ab03      	add	r3, sp, #12
   10a10:	4629      	mov	r1, r5
   10a12:	4640      	mov	r0, r8
   10a14:	f7ff f8b2 	bl	fb7c <bsec_d_Entity_serializeAndAdd>
   10a18:	3401      	adds	r4, #1
   10a1a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a1e:	b2e4      	uxtb	r4, r4
   10a20:	42a2      	cmp	r2, r4
   10a22:	d294      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a24:	e7ab      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a26:	463a      	mov	r2, r7
   10a28:	ab03      	add	r3, sp, #12
   10a2a:	4629      	mov	r1, r5
   10a2c:	8870      	ldrh	r0, [r6, #2]
   10a2e:	f7ff f86d 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   10a32:	3401      	adds	r4, #1
   10a34:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a38:	b2e4      	uxtb	r4, r4
   10a3a:	42a2      	cmp	r2, r4
   10a3c:	d287      	bcs.n	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a3e:	e79e      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a40:	463a      	mov	r2, r7
   10a42:	ab03      	add	r3, sp, #12
   10a44:	4629      	mov	r1, r5
   10a46:	8b70      	ldrh	r0, [r6, #26]
   10a48:	f7ff f860 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   10a4c:	3401      	adds	r4, #1
   10a4e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a52:	b2e4      	uxtb	r4, r4
   10a54:	42a2      	cmp	r2, r4
   10a56:	f4bf af7a 	bcs.w	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a5a:	e790      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a5c:	463a      	mov	r2, r7
   10a5e:	ab03      	add	r3, sp, #12
   10a60:	4629      	mov	r1, r5
   10a62:	8b30      	ldrh	r0, [r6, #24]
   10a64:	f7ff f852 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   10a68:	3401      	adds	r4, #1
   10a6a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a6e:	b2e4      	uxtb	r4, r4
   10a70:	42a2      	cmp	r2, r4
   10a72:	f4bf af6c 	bcs.w	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a76:	e782      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a78:	463a      	mov	r2, r7
   10a7a:	ab03      	add	r3, sp, #12
   10a7c:	4629      	mov	r1, r5
   10a7e:	f106 0010 	add.w	r0, r6, #16
   10a82:	f7ff f803 	bl	fa8c <bsec_b_Entity_serializeAndAdd>
   10a86:	3401      	adds	r4, #1
   10a88:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10a8c:	b2e4      	uxtb	r4, r4
   10a8e:	42a2      	cmp	r2, r4
   10a90:	f4bf af5d 	bcs.w	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10a94:	e773      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>
   10a96:	463a      	mov	r2, r7
   10a98:	ab03      	add	r3, sp, #12
   10a9a:	4629      	mov	r1, r5
   10a9c:	f106 0008 	add.w	r0, r6, #8
   10aa0:	f7fe fff4 	bl	fa8c <bsec_b_Entity_serializeAndAdd>
   10aa4:	3401      	adds	r4, #1
   10aa6:	f89d 2007 	ldrb.w	r2, [sp, #7]
   10aaa:	b2e4      	uxtb	r4, r4
   10aac:	42a2      	cmp	r2, r4
   10aae:	f4bf af4e 	bcs.w	1094e <bsec_GasHumidityBaselineTracker_getState+0x2e>
   10ab2:	e764      	b.n	1097e <bsec_GasHumidityBaselineTracker_getState+0x5e>

00010ab4 <bsec_GasHumidityBaselineTracker_setState>:
   10ab4:	2300      	movs	r3, #0
   10ab6:	2200      	movs	r2, #0
   10ab8:	2102      	movs	r1, #2
   10aba:	b410      	push	{r4}
   10abc:	f64f 74ff 	movw	r4, #65535	; 0xffff
   10ac0:	8044      	strh	r4, [r0, #2]
   10ac2:	8302      	strh	r2, [r0, #24]
   10ac4:	8342      	strh	r2, [r0, #26]
   10ac6:	e9c0 2208 	strd	r2, r2, [r0, #32]
   10aca:	6282      	str	r2, [r0, #40]	; 0x28
   10acc:	6083      	str	r3, [r0, #8]
   10ace:	6103      	str	r3, [r0, #16]
   10ad0:	60c3      	str	r3, [r0, #12]
   10ad2:	6143      	str	r3, [r0, #20]
   10ad4:	6043      	str	r3, [r0, #4]
   10ad6:	7701      	strb	r1, [r0, #28]
   10ad8:	7741      	strb	r1, [r0, #29]
   10ada:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
   10ade:	f85d 4b04 	ldr.w	r4, [sp], #4
   10ae2:	4770      	bx	lr

00010ae4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency>:
   10ae4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   10ae8:	4299      	cmp	r1, r3
   10aea:	d04f      	beq.n	10b8c <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xa8>
   10aec:	8843      	ldrh	r3, [r0, #2]
   10aee:	428b      	cmp	r3, r1
   10af0:	d04c      	beq.n	10b8c <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xa8>
   10af2:	b570      	push	{r4, r5, r6, lr}
   10af4:	4b3b      	ldr	r3, [pc, #236]	; (10be4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x100>)
   10af6:	4605      	mov	r5, r0
   10af8:	fba3 2301 	umull	r2, r3, r3, r1
   10afc:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
   10b00:	b082      	sub	sp, #8
   10b02:	460c      	mov	r4, r1
   10b04:	8069      	strh	r1, [r5, #2]
   10b06:	ea4f 1353 	mov.w	r3, r3, lsr #5
   10b0a:	d067      	beq.n	10bdc <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xf8>
   10b0c:	d93f      	bls.n	10b8e <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xaa>
   10b0e:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
   10b12:	d03e      	beq.n	10b92 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xae>
   10b14:	f247 5230 	movw	r2, #30000	; 0x7530
   10b18:	4291      	cmp	r1, r2
   10b1a:	d150      	bne.n	10bbe <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xda>
   10b1c:	4a32      	ldr	r2, [pc, #200]	; (10be8 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x104>)
   10b1e:	9201      	str	r2, [sp, #4]
   10b20:	ae01      	add	r6, sp, #4
   10b22:	856b      	strh	r3, [r5, #42]	; 0x2a
   10b24:	4630      	mov	r0, r6
   10b26:	f001 f85b 	bl	11be0 <bsec_log10>
   10b2a:	ed9d 0a01 	vldr	s0, [sp, #4]
   10b2e:	f01e fc83 	bl	2f438 <fabsf>
   10b32:	eddf 7a2e 	vldr	s15, [pc, #184]	; 10bec <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x108>
   10b36:	ee80 0a27 	vdiv.f32	s0, s0, s15
   10b3a:	ed85 0a01 	vstr	s0, [r5, #4]
   10b3e:	f247 5230 	movw	r2, #30000	; 0x7530
   10b42:	fbb2 f3f4 	udiv	r3, r2, r4
   10b46:	fb04 2213 	mls	r2, r4, r3, r2
   10b4a:	b292      	uxth	r2, r2
   10b4c:	b29b      	uxth	r3, r3
   10b4e:	b132      	cbz	r2, 10b5e <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x7a>
   10b50:	f004 0101 	and.w	r1, r4, #1
   10b54:	eb01 0454 	add.w	r4, r1, r4, lsr #1
   10b58:	42a2      	cmp	r2, r4
   10b5a:	bfa8      	it	ge
   10b5c:	3301      	addge	r3, #1
   10b5e:	ee07 3a90 	vmov	s15, r3
   10b62:	eef8 7a67 	vcvt.f32.u32	s15, s15
   10b66:	4630      	mov	r0, r6
   10b68:	edcd 7a01 	vstr	s15, [sp, #4]
   10b6c:	f001 f84c 	bl	11c08 <bsec_b_sqrt>
   10b70:	ed9d 0a01 	vldr	s0, [sp, #4]
   10b74:	ee30 0a00 	vadd.f32	s0, s0, s0
   10b78:	f01e fc66 	bl	2f448 <floorf>
   10b7c:	eefc 7ac0 	vcvt.u32.f32	s15, s0
   10b80:	ee17 3a90 	vmov	r3, s15
   10b84:	f885 304c 	strb.w	r3, [r5, #76]	; 0x4c
   10b88:	b002      	add	sp, #8
   10b8a:	bd70      	pop	{r4, r5, r6, pc}
   10b8c:	4770      	bx	lr
   10b8e:	2964      	cmp	r1, #100	; 0x64
   10b90:	d115      	bne.n	10bbe <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xda>
   10b92:	4a17      	ldr	r2, [pc, #92]	; (10bf0 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x10c>)
   10b94:	9201      	str	r2, [sp, #4]
   10b96:	ae01      	add	r6, sp, #4
   10b98:	856b      	strh	r3, [r5, #42]	; 0x2a
   10b9a:	4630      	mov	r0, r6
   10b9c:	f001 f820 	bl	11be0 <bsec_log10>
   10ba0:	ed9d 0a01 	vldr	s0, [sp, #4]
   10ba4:	f01e fc48 	bl	2f438 <fabsf>
   10ba8:	eddf 7a10 	vldr	s15, [pc, #64]	; 10bec <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x108>
   10bac:	ee80 0a27 	vdiv.f32	s0, s0, s15
   10bb0:	ed85 0a01 	vstr	s0, [r5, #4]
   10bb4:	2c00      	cmp	r4, #0
   10bb6:	d1c2      	bne.n	10b3e <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x5a>
   10bb8:	eddf 7a0e 	vldr	s15, [pc, #56]	; 10bf4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x110>
   10bbc:	e7d3      	b.n	10b66 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x82>
   10bbe:	4a09      	ldr	r2, [pc, #36]	; (10be4 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x100>)
   10bc0:	4909      	ldr	r1, [pc, #36]	; (10be8 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x104>)
   10bc2:	9101      	str	r1, [sp, #4]
   10bc4:	fba2 0204 	umull	r0, r2, r2, r4
   10bc8:	0952      	lsrs	r2, r2, #5
   10bca:	2064      	movs	r0, #100	; 0x64
   10bcc:	fb00 4212 	mls	r2, r0, r2, r4
   10bd0:	b292      	uxth	r2, r2
   10bd2:	2a31      	cmp	r2, #49	; 0x31
   10bd4:	bf84      	itt	hi
   10bd6:	3301      	addhi	r3, #1
   10bd8:	b29b      	uxthhi	r3, r3
   10bda:	e7dc      	b.n	10b96 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0xb2>
   10bdc:	4a06      	ldr	r2, [pc, #24]	; (10bf8 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x114>)
   10bde:	9201      	str	r2, [sp, #4]
   10be0:	e79e      	b.n	10b20 <bsec_GasHumidityBaselineTracker_updateInterfaceDependency+0x3c>
   10be2:	bf00      	nop
   10be4:	51eb851f 	.word	0x51eb851f
   10be8:	3f464c30 	.word	0x3f464c30
   10bec:	3e632c50 	.word	0x3e632c50
   10bf0:	3f19999a 	.word	0x3f19999a
   10bf4:	477fff00 	.word	0x477fff00
   10bf8:	3f23d70a 	.word	0x3f23d70a

00010bfc <bsec_b_GasHumidityBaselineTracker_setState>:
   10bfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   10c00:	b086      	sub	sp, #24
   10c02:	ab04      	add	r3, sp, #16
   10c04:	ae05      	add	r6, sp, #20
   10c06:	4605      	mov	r5, r0
   10c08:	7800      	ldrb	r0, [r0, #0]
   10c0a:	9300      	str	r3, [sp, #0]
   10c0c:	9601      	str	r6, [sp, #4]
   10c0e:	f10d 030f 	add.w	r3, sp, #15
   10c12:	460f      	mov	r7, r1
   10c14:	f000 ff0c 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   10c18:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   10c1c:	bb1b      	cbnz	r3, 10c66 <bsec_b_GasHumidityBaselineTracker_setState+0x6a>
   10c1e:	2401      	movs	r4, #1
   10c20:	f105 0a20 	add.w	sl, r5, #32
   10c24:	f105 091c 	add.w	r9, r5, #28
   10c28:	f105 0810 	add.w	r8, r5, #16
   10c2c:	1ea3      	subs	r3, r4, #2
   10c2e:	2b09      	cmp	r3, #9
   10c30:	d806      	bhi.n	10c40 <bsec_b_GasHumidityBaselineTracker_setState+0x44>
   10c32:	e8df f003 	tbb	[pc, r3]
   10c36:	474d      	.short	0x474d
   10c38:	2f353b41 	.word	0x2f353b41
   10c3c:	101c2329 	.word	0x101c2329
   10c40:	f105 0208 	add.w	r2, r5, #8
   10c44:	4631      	mov	r1, r6
   10c46:	4638      	mov	r0, r7
   10c48:	f7fe ff06 	bl	fa58 <bsec_b_Entity_parseAndDeserialize>
   10c4c:	2c0b      	cmp	r4, #11
   10c4e:	d045      	beq.n	10cdc <bsec_b_GasHumidityBaselineTracker_setState+0xe0>
   10c50:	3401      	adds	r4, #1
   10c52:	b2e4      	uxtb	r4, r4
   10c54:	e7ea      	b.n	10c2c <bsec_b_GasHumidityBaselineTracker_setState+0x30>
   10c56:	4631      	mov	r1, r6
   10c58:	4638      	mov	r0, r7
   10c5a:	f7fe fff3 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
   10c5e:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   10c62:	f885 004c 	strb.w	r0, [r5, #76]	; 0x4c
   10c66:	4618      	mov	r0, r3
   10c68:	b006      	add	sp, #24
   10c6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   10c6e:	4631      	mov	r1, r6
   10c70:	4638      	mov	r0, r7
   10c72:	f7fe ffa9 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   10c76:	ed85 0a01 	vstr	s0, [r5, #4]
   10c7a:	e7e9      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10c7c:	4631      	mov	r1, r6
   10c7e:	4638      	mov	r0, r7
   10c80:	f7fe ff2c 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   10c84:	8568      	strh	r0, [r5, #42]	; 0x2a
   10c86:	e7e3      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10c88:	4631      	mov	r1, r6
   10c8a:	4638      	mov	r0, r7
   10c8c:	f7fe ff26 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   10c90:	8528      	strh	r0, [r5, #40]	; 0x28
   10c92:	e7dd      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10c94:	4652      	mov	r2, sl
   10c96:	4631      	mov	r1, r6
   10c98:	4638      	mov	r0, r7
   10c9a:	f7fe fedd 	bl	fa58 <bsec_b_Entity_parseAndDeserialize>
   10c9e:	e7d7      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10ca0:	464a      	mov	r2, r9
   10ca2:	4631      	mov	r1, r6
   10ca4:	4638      	mov	r0, r7
   10ca6:	f7fe ff53 	bl	fb50 <bsec_d_Entity_parseAndDeserialize>
   10caa:	e7d1      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10cac:	4631      	mov	r1, r6
   10cae:	4638      	mov	r0, r7
   10cb0:	f7fe ff14 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   10cb4:	8068      	strh	r0, [r5, #2]
   10cb6:	e7cb      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10cb8:	4631      	mov	r1, r6
   10cba:	4638      	mov	r0, r7
   10cbc:	f7fe ff0e 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   10cc0:	8368      	strh	r0, [r5, #26]
   10cc2:	e7c5      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10cc4:	4631      	mov	r1, r6
   10cc6:	4638      	mov	r0, r7
   10cc8:	f7fe ff08 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   10ccc:	8328      	strh	r0, [r5, #24]
   10cce:	e7bf      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10cd0:	4642      	mov	r2, r8
   10cd2:	4631      	mov	r1, r6
   10cd4:	4638      	mov	r0, r7
   10cd6:	f7fe febf 	bl	fa58 <bsec_b_Entity_parseAndDeserialize>
   10cda:	e7b9      	b.n	10c50 <bsec_b_GasHumidityBaselineTracker_setState+0x54>
   10cdc:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   10ce0:	e7c1      	b.n	10c66 <bsec_b_GasHumidityBaselineTracker_setState+0x6a>
   10ce2:	bf00      	nop

00010ce4 <bsec_GasHumidityPreProcessor_GasHumidityPreProcessor>:
   10ce4:	b510      	push	{r4, lr}
   10ce6:	2303      	movs	r3, #3
   10ce8:	4604      	mov	r4, r0
   10cea:	f800 3b04 	strb.w	r3, [r0], #4
   10cee:	f001 f80b 	bl	11d08 <bsec_ExpSmoothingBsec_ExpSmoothingBsec>
   10cf2:	4620      	mov	r0, r4
   10cf4:	f000 ff94 	bl	11c20 <bsec_Channel_reset>
   10cf8:	4620      	mov	r0, r4
   10cfa:	bd10      	pop	{r4, pc}

00010cfc <bsec_GasHumidityPreProcessor_configure>:
   10cfc:	b570      	push	{r4, r5, r6, lr}
   10cfe:	b086      	sub	sp, #24
   10d00:	ab04      	add	r3, sp, #16
   10d02:	ac05      	add	r4, sp, #20
   10d04:	4605      	mov	r5, r0
   10d06:	7800      	ldrb	r0, [r0, #0]
   10d08:	9300      	str	r3, [sp, #0]
   10d0a:	9401      	str	r4, [sp, #4]
   10d0c:	f10d 030f 	add.w	r3, sp, #15
   10d10:	460e      	mov	r6, r1
   10d12:	f000 fe8d 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   10d16:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   10d1a:	b938      	cbnz	r0, 10d2c <bsec_GasHumidityPreProcessor_configure+0x30>
   10d1c:	4630      	mov	r0, r6
   10d1e:	f105 0220 	add.w	r2, r5, #32
   10d22:	4621      	mov	r1, r4
   10d24:	f7fe fe58 	bl	f9d8 <bsec_Entity_parseAndDeserialize>
   10d28:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   10d2c:	b006      	add	sp, #24
   10d2e:	bd70      	pop	{r4, r5, r6, pc}

00010d30 <bsec_GasHumidityPreProcessor_doStep>:
   10d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10d34:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
   10d38:	ed90 7a04 	vldr	s14, [r0, #16]
   10d3c:	ed2d 8b04 	vpush	{d8-d9}
   10d40:	eeb4 0a67 	vcmp.f32	s0, s15
   10d44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10d48:	eeb0 8a40 	vmov.f32	s16, s0
   10d4c:	eeb5 7a40 	vcmp.f32	s14, #0.0
   10d50:	bf98      	it	ls
   10d52:	eeb0 8a67 	vmovls.f32	s16, s15
   10d56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10d5a:	b088      	sub	sp, #32
   10d5c:	4604      	mov	r4, r0
   10d5e:	eeb0 9a60 	vmov.f32	s18, s1
   10d62:	eef0 8a41 	vmov.f32	s17, s2
   10d66:	460f      	mov	r7, r1
   10d68:	4616      	mov	r6, r2
   10d6a:	461d      	mov	r5, r3
   10d6c:	d033      	beq.n	10dd6 <bsec_GasHumidityPreProcessor_doStep+0xa6>
   10d6e:	f10d 0804 	add.w	r8, sp, #4
   10d72:	4640      	mov	r0, r8
   10d74:	ed8d 8a01 	vstr	s16, [sp, #4]
   10d78:	f000 ff32 	bl	11be0 <bsec_log10>
   10d7c:	eddd 7a01 	vldr	s15, [sp, #4]
   10d80:	ed8d 9a03 	vstr	s18, [sp, #12]
   10d84:	1d20      	adds	r0, r4, #4
   10d86:	edcd 8a04 	vstr	s17, [sp, #16]
   10d8a:	edcd 7a02 	vstr	s15, [sp, #8]
   10d8e:	ab05      	add	r3, sp, #20
   10d90:	3410      	adds	r4, #16
   10d92:	a903      	add	r1, sp, #12
   10d94:	ed90 7a03 	vldr	s14, [r0, #12]
   10d98:	edd0 6a00 	vldr	s13, [r0]
   10d9c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   10da0:	3004      	adds	r0, #4
   10da2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   10da6:	42a0      	cmp	r0, r4
   10da8:	ee77 7a87 	vadd.f32	s15, s15, s14
   10dac:	ece3 7a01 	vstmia	r3!, {s15}
   10db0:	d002      	beq.n	10db8 <bsec_GasHumidityPreProcessor_doStep+0x88>
   10db2:	ecf1 7a01 	vldmia	r1!, {s15}
   10db6:	e7ed      	b.n	10d94 <bsec_GasHumidityPreProcessor_doStep+0x64>
   10db8:	a905      	add	r1, sp, #20
   10dba:	220c      	movs	r2, #12
   10dbc:	f028 f90c 	bl	38fd8 <memcpy>
   10dc0:	9905      	ldr	r1, [sp, #20]
   10dc2:	9a06      	ldr	r2, [sp, #24]
   10dc4:	9b07      	ldr	r3, [sp, #28]
   10dc6:	6039      	str	r1, [r7, #0]
   10dc8:	6032      	str	r2, [r6, #0]
   10dca:	602b      	str	r3, [r5, #0]
   10dcc:	b008      	add	sp, #32
   10dce:	ecbd 8b04 	vpop	{d8-d9}
   10dd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10dd6:	ee18 3a10 	vmov	r3, s16
   10dda:	f10d 0820 	add.w	r8, sp, #32
   10dde:	f848 3d1c 	str.w	r3, [r8, #-28]!
   10de2:	4640      	mov	r0, r8
   10de4:	f000 fefc 	bl	11be0 <bsec_log10>
   10de8:	9b01      	ldr	r3, [sp, #4]
   10dea:	ed84 9a05 	vstr	s18, [r4, #20]
   10dee:	edc4 8a06 	vstr	s17, [r4, #24]
   10df2:	6123      	str	r3, [r4, #16]
   10df4:	e7bd      	b.n	10d72 <bsec_GasHumidityPreProcessor_doStep+0x42>
   10df6:	bf00      	nop

00010df8 <bsec_GasHumidityPreProcessor_setState>:
   10df8:	b570      	push	{r4, r5, r6, lr}
   10dfa:	b088      	sub	sp, #32
   10dfc:	ab03      	add	r3, sp, #12
   10dfe:	ad04      	add	r5, sp, #16
   10e00:	4604      	mov	r4, r0
   10e02:	7800      	ldrb	r0, [r0, #0]
   10e04:	9300      	str	r3, [sp, #0]
   10e06:	9501      	str	r5, [sp, #4]
   10e08:	f10d 030b 	add.w	r3, sp, #11
   10e0c:	460e      	mov	r6, r1
   10e0e:	f000 fe0f 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   10e12:	f99d 000b 	ldrsb.w	r0, [sp, #11]
   10e16:	b960      	cbnz	r0, 10e32 <bsec_GasHumidityPreProcessor_setState+0x3a>
   10e18:	4629      	mov	r1, r5
   10e1a:	4630      	mov	r0, r6
   10e1c:	aa05      	add	r2, sp, #20
   10e1e:	f7fe fddb 	bl	f9d8 <bsec_Entity_parseAndDeserialize>
   10e22:	a905      	add	r1, sp, #20
   10e24:	f104 0010 	add.w	r0, r4, #16
   10e28:	220c      	movs	r2, #12
   10e2a:	f028 f8d5 	bl	38fd8 <memcpy>
   10e2e:	f99d 000b 	ldrsb.w	r0, [sp, #11]
   10e32:	b008      	add	sp, #32
   10e34:	bd70      	pop	{r4, r5, r6, pc}
   10e36:	bf00      	nop

00010e38 <bsec_GasHumidityPreProcessor_updateInterfaceDependency>:
   10e38:	ee07 1a90 	vmov	s15, r1
   10e3c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 10e90 <bsec_GasHumidityPreProcessor_updateInterfaceDependency+0x58>
   10e40:	eef8 7a67 	vcvt.f32.u32	s15, s15
   10e44:	b500      	push	{lr}
   10e46:	eec7 6a27 	vdiv.f32	s13, s14, s15
   10e4a:	b085      	sub	sp, #20
   10e4c:	f100 0320 	add.w	r3, r0, #32
   10e50:	f100 012c 	add.w	r1, r0, #44	; 0x2c
   10e54:	aa01      	add	r2, sp, #4
   10e56:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   10e5a:	ee66 6aa7 	vmul.f32	s13, s13, s15
   10e5e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   10e62:	ecb3 6a01 	vldmia	r3!, {s12}
   10e66:	eec6 7a26 	vdiv.f32	s15, s12, s13
   10e6a:	eef4 7a47 	vcmp.f32	s15, s14
   10e6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10e72:	bfc8      	it	gt
   10e74:	eef0 7a47 	vmovgt.f32	s15, s14
   10e78:	428b      	cmp	r3, r1
   10e7a:	ece2 7a01 	vstmia	r2!, {s15}
   10e7e:	d1f0      	bne.n	10e62 <bsec_GasHumidityPreProcessor_updateInterfaceDependency+0x2a>
   10e80:	a901      	add	r1, sp, #4
   10e82:	3004      	adds	r0, #4
   10e84:	f000 fef0 	bl	11c68 <bsec_ExpSmoothing_setCoeffFromBandwidth>
   10e88:	b005      	add	sp, #20
   10e8a:	f85d fb04 	ldr.w	pc, [sp], #4
   10e8e:	bf00      	nop
   10e90:	42c80000 	.word	0x42c80000

00010e94 <bsec_HumidityTemperatureCorrector_HumidityTemperatureCorrector>:
   10e94:	b510      	push	{r4, lr}
   10e96:	4604      	mov	r4, r0
   10e98:	f800 1b04 	strb.w	r1, [r0], #4
   10e9c:	f000 ff44 	bl	11d28 <bsec_b_ExpSmoothingBsec_ExpSmoothingBsec>
   10ea0:	4620      	mov	r0, r4
   10ea2:	f000 fed7 	bl	11c54 <bsec_b_Channel_reset>
   10ea6:	4620      	mov	r0, r4
   10ea8:	bd10      	pop	{r4, pc}
   10eaa:	bf00      	nop

00010eac <bsec_HumidityTemperatureCorrector_configure>:
   10eac:	b570      	push	{r4, r5, r6, lr}
   10eae:	b086      	sub	sp, #24
   10eb0:	ab04      	add	r3, sp, #16
   10eb2:	ac05      	add	r4, sp, #20
   10eb4:	4605      	mov	r5, r0
   10eb6:	7800      	ldrb	r0, [r0, #0]
   10eb8:	9300      	str	r3, [sp, #0]
   10eba:	9401      	str	r4, [sp, #4]
   10ebc:	f10d 030f 	add.w	r3, sp, #15
   10ec0:	460e      	mov	r6, r1
   10ec2:	f000 fdb5 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   10ec6:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   10eca:	b938      	cbnz	r0, 10edc <bsec_HumidityTemperatureCorrector_configure+0x30>
   10ecc:	4630      	mov	r0, r6
   10ece:	f105 0210 	add.w	r2, r5, #16
   10ed2:	4621      	mov	r1, r4
   10ed4:	f7ff f8ec 	bl	100b0 <bsec_p_Entity_parseAndDeserialize>
   10ed8:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   10edc:	b006      	add	sp, #24
   10ede:	bd70      	pop	{r4, r5, r6, pc}

00010ee0 <bsec_HumidityTemperatureCorrector_doStep>:
   10ee0:	b508      	push	{r3, lr}
   10ee2:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
   10ee6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10eea:	ed2d 8b04 	vpush	{d8-d9}
   10eee:	4603      	mov	r3, r0
   10ef0:	eeb0 9a60 	vmov.f32	s18, s1
   10ef4:	d937      	bls.n	10f66 <bsec_HumidityTemperatureCorrector_doStep+0x86>
   10ef6:	eddf 7a1d 	vldr	s15, [pc, #116]	; 10f6c <bsec_HumidityTemperatureCorrector_doStep+0x8c>
   10efa:	eeb4 1a67 	vcmp.f32	s2, s15
   10efe:	eef0 8a41 	vmov.f32	s17, s2
   10f02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10f06:	bfc8      	it	gt
   10f08:	eef0 8a67 	vmovgt.f32	s17, s15
   10f0c:	edd3 7a02 	vldr	s15, [r3, #8]
   10f10:	eef5 7a40 	vcmp.f32	s15, #0.0
   10f14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10f18:	bf08      	it	eq
   10f1a:	eef0 7a40 	vmoveq.f32	s15, s0
   10f1e:	ee30 8a67 	vsub.f32	s16, s0, s15
   10f22:	ed93 0a01 	vldr	s0, [r3, #4]
   10f26:	ee28 8a00 	vmul.f32	s16, s16, s0
   10f2a:	f103 0010 	add.w	r0, r3, #16
   10f2e:	ee38 8a27 	vadd.f32	s16, s16, s15
   10f32:	eeb0 0a68 	vmov.f32	s0, s17
   10f36:	ed83 8a02 	vstr	s16, [r3, #8]
   10f3a:	f000 fe5b 	bl	11bf4 <bsec_polyval>
   10f3e:	eef0 0a49 	vmov.f32	s1, s18
   10f42:	ee30 1a28 	vadd.f32	s2, s0, s17
   10f46:	eeb0 0a48 	vmov.f32	s0, s16
   10f4a:	f000 fdaf 	bl	11aac <bsec_convertHumidity>
   10f4e:	ecbd 8b04 	vpop	{d8-d9}
   10f52:	eddf 7a06 	vldr	s15, [pc, #24]	; 10f6c <bsec_HumidityTemperatureCorrector_doStep+0x8c>
   10f56:	eeb4 0a67 	vcmp.f32	s0, s15
   10f5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   10f5e:	bfc8      	it	gt
   10f60:	eeb0 0a67 	vmovgt.f32	s0, s15
   10f64:	bd08      	pop	{r3, pc}
   10f66:	eddf 8a02 	vldr	s17, [pc, #8]	; 10f70 <bsec_HumidityTemperatureCorrector_doStep+0x90>
   10f6a:	e7cf      	b.n	10f0c <bsec_HumidityTemperatureCorrector_doStep+0x2c>
   10f6c:	42c80000 	.word	0x42c80000
   10f70:	38d1b717 	.word	0x38d1b717

00010f74 <bsec_HumidityTemperatureCorrector_getConfiguration>:
   10f74:	b5f0      	push	{r4, r5, r6, r7, lr}
   10f76:	b085      	sub	sp, #20
   10f78:	ae04      	add	r6, sp, #16
   10f7a:	2401      	movs	r4, #1
   10f7c:	f806 4d09 	strb.w	r4, [r6, #-9]!
   10f80:	4605      	mov	r5, r0
   10f82:	4617      	mov	r7, r2
   10f84:	7800      	ldrb	r0, [r0, #0]
   10f86:	4632      	mov	r2, r6
   10f88:	460e      	mov	r6, r1
   10f8a:	f000 fd7f 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   10f8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10f92:	9003      	str	r0, [sp, #12]
   10f94:	b1a3      	cbz	r3, 10fc0 <bsec_HumidityTemperatureCorrector_getConfiguration+0x4c>
   10f96:	3510      	adds	r5, #16
   10f98:	e003      	b.n	10fa2 <bsec_HumidityTemperatureCorrector_getConfiguration+0x2e>
   10f9a:	3401      	adds	r4, #1
   10f9c:	b2e4      	uxtb	r4, r4
   10f9e:	42a3      	cmp	r3, r4
   10fa0:	d30d      	bcc.n	10fbe <bsec_HumidityTemperatureCorrector_getConfiguration+0x4a>
   10fa2:	2c01      	cmp	r4, #1
   10fa4:	d1f9      	bne.n	10f9a <bsec_HumidityTemperatureCorrector_getConfiguration+0x26>
   10fa6:	ab03      	add	r3, sp, #12
   10fa8:	463a      	mov	r2, r7
   10faa:	4631      	mov	r1, r6
   10fac:	4628      	mov	r0, r5
   10fae:	f7fe ffe3 	bl	ff78 <bsec_m_Entity_serializeAndAdd>
   10fb2:	3401      	adds	r4, #1
   10fb4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10fb8:	b2e4      	uxtb	r4, r4
   10fba:	42a3      	cmp	r3, r4
   10fbc:	d2f1      	bcs.n	10fa2 <bsec_HumidityTemperatureCorrector_getConfiguration+0x2e>
   10fbe:	9803      	ldr	r0, [sp, #12]
   10fc0:	a904      	add	r1, sp, #16
   10fc2:	2202      	movs	r2, #2
   10fc4:	f821 0d06 	strh.w	r0, [r1, #-6]!
   10fc8:	a802      	add	r0, sp, #8
   10fca:	f028 f805 	bl	38fd8 <memcpy>
   10fce:	f89d 2008 	ldrb.w	r2, [sp, #8]
   10fd2:	f89d 3009 	ldrb.w	r3, [sp, #9]
   10fd6:	9803      	ldr	r0, [sp, #12]
   10fd8:	7032      	strb	r2, [r6, #0]
   10fda:	7073      	strb	r3, [r6, #1]
   10fdc:	b005      	add	sp, #20
   10fde:	bdf0      	pop	{r4, r5, r6, r7, pc}

00010fe0 <bsec_HumidityTemperatureCorrector_getState>:
   10fe0:	b5f0      	push	{r4, r5, r6, r7, lr}
   10fe2:	b085      	sub	sp, #20
   10fe4:	ad04      	add	r5, sp, #16
   10fe6:	2401      	movs	r4, #1
   10fe8:	f805 4d09 	strb.w	r4, [r5, #-9]!
   10fec:	4606      	mov	r6, r0
   10fee:	4617      	mov	r7, r2
   10ff0:	7800      	ldrb	r0, [r0, #0]
   10ff2:	462a      	mov	r2, r5
   10ff4:	460d      	mov	r5, r1
   10ff6:	f000 fd49 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   10ffa:	f89d 3007 	ldrb.w	r3, [sp, #7]
   10ffe:	9003      	str	r0, [sp, #12]
   11000:	b923      	cbnz	r3, 1100c <bsec_HumidityTemperatureCorrector_getState+0x2c>
   11002:	e013      	b.n	1102c <bsec_HumidityTemperatureCorrector_getState+0x4c>
   11004:	3401      	adds	r4, #1
   11006:	b2e4      	uxtb	r4, r4
   11008:	42a3      	cmp	r3, r4
   1100a:	d30e      	bcc.n	1102a <bsec_HumidityTemperatureCorrector_getState+0x4a>
   1100c:	2c01      	cmp	r4, #1
   1100e:	d1f9      	bne.n	11004 <bsec_HumidityTemperatureCorrector_getState+0x24>
   11010:	aa03      	add	r2, sp, #12
   11012:	4639      	mov	r1, r7
   11014:	4628      	mov	r0, r5
   11016:	ed96 0a02 	vldr	s0, [r6, #8]
   1101a:	f7fe fdef 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   1101e:	3401      	adds	r4, #1
   11020:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11024:	b2e4      	uxtb	r4, r4
   11026:	42a3      	cmp	r3, r4
   11028:	d2f0      	bcs.n	1100c <bsec_HumidityTemperatureCorrector_getState+0x2c>
   1102a:	9803      	ldr	r0, [sp, #12]
   1102c:	a904      	add	r1, sp, #16
   1102e:	2202      	movs	r2, #2
   11030:	f821 0d06 	strh.w	r0, [r1, #-6]!
   11034:	a802      	add	r0, sp, #8
   11036:	f027 ffcf 	bl	38fd8 <memcpy>
   1103a:	f89d 2008 	ldrb.w	r2, [sp, #8]
   1103e:	f89d 3009 	ldrb.w	r3, [sp, #9]
   11042:	9803      	ldr	r0, [sp, #12]
   11044:	702a      	strb	r2, [r5, #0]
   11046:	706b      	strb	r3, [r5, #1]
   11048:	b005      	add	sp, #20
   1104a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0001104c <bsec_HumidityTemperatureCorrector_setState>:
   1104c:	b570      	push	{r4, r5, r6, lr}
   1104e:	b086      	sub	sp, #24
   11050:	ab04      	add	r3, sp, #16
   11052:	ad05      	add	r5, sp, #20
   11054:	4604      	mov	r4, r0
   11056:	7800      	ldrb	r0, [r0, #0]
   11058:	9300      	str	r3, [sp, #0]
   1105a:	9501      	str	r5, [sp, #4]
   1105c:	f10d 030f 	add.w	r3, sp, #15
   11060:	460e      	mov	r6, r1
   11062:	f000 fce5 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   11066:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   1106a:	b938      	cbnz	r0, 1107c <bsec_HumidityTemperatureCorrector_setState+0x30>
   1106c:	4630      	mov	r0, r6
   1106e:	4629      	mov	r1, r5
   11070:	f7fe fdaa 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   11074:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   11078:	ed84 0a02 	vstr	s0, [r4, #8]
   1107c:	b006      	add	sp, #24
   1107e:	bd70      	pop	{r4, r5, r6, pc}

00011080 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency>:
   11080:	ee07 1a90 	vmov	s15, r1
   11084:	eddf 6a1e 	vldr	s13, [pc, #120]	; 11100 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x80>
   11088:	ed9f 0a1e 	vldr	s0, [pc, #120]	; 11104 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x84>
   1108c:	eeb8 7a67 	vcvt.f32.u32	s14, s15
   11090:	b510      	push	{r4, lr}
   11092:	eec6 7a87 	vdiv.f32	s15, s13, s14
   11096:	4604      	mov	r4, r0
   11098:	ed2d 8b02 	vpush	{d8}
   1109c:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   110a0:	ee67 7a87 	vmul.f32	s15, s15, s14
   110a4:	b082      	sub	sp, #8
   110a6:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   110aa:	ee80 0a27 	vdiv.f32	s0, s0, s15
   110ae:	f01e f9ed 	bl	2f48c <fminf>
   110b2:	eef0 8a40 	vmov.f32	s17, s0
   110b6:	ed9f 0a14 	vldr	s0, [pc, #80]	; 11108 <bsec_HumidityTemperatureCorrector_updateInterfaceDependency+0x88>
   110ba:	ee28 0a80 	vmul.f32	s0, s17, s0
   110be:	f01e fa23 	bl	2f508 <sinf>
   110c2:	ee20 8a00 	vmul.f32	s16, s0, s0
   110c6:	a802      	add	r0, sp, #8
   110c8:	ee68 7a08 	vmul.f32	s15, s16, s16
   110cc:	ee77 7a88 	vadd.f32	s15, s15, s16
   110d0:	ed60 7a01 	vstmdb	r0!, {s15}
   110d4:	f000 fd98 	bl	11c08 <bsec_b_sqrt>
   110d8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   110dc:	eef4 8a67 	vcmp.f32	s17, s15
   110e0:	ed9d 0a01 	vldr	s0, [sp, #4]
   110e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   110e8:	bf1c      	itt	ne
   110ea:	ee70 7a48 	vsubne.f32	s15, s0, s16
   110ee:	ee77 7aa7 	vaddne.f32	s15, s15, s15
   110f2:	edc4 7a01 	vstr	s15, [r4, #4]
   110f6:	b002      	add	sp, #8
   110f8:	ecbd 8b02 	vpop	{d8}
   110fc:	bd10      	pop	{r4, pc}
   110fe:	bf00      	nop
   11100:	42c80000 	.word	0x42c80000
   11104:	3c50d499 	.word	0x3c50d499
   11108:	3fc90fdb 	.word	0x3fc90fdb

0001110c <bsec_IaqEstimator_IaqEstimator>:
   1110c:	b430      	push	{r4, r5}
   1110e:	4913      	ldr	r1, [pc, #76]	; (1115c <bsec_IaqEstimator_IaqEstimator+0x50>)
   11110:	6301      	str	r1, [r0, #48]	; 0x30
   11112:	2502      	movs	r5, #2
   11114:	2400      	movs	r4, #0
   11116:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
   1111a:	7005      	strb	r5, [r0, #0]
   1111c:	7104      	strb	r4, [r0, #4]
   1111e:	25e1      	movs	r5, #225	; 0xe1
   11120:	2419      	movs	r4, #25
   11122:	8041      	strh	r1, [r0, #2]
   11124:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
   11128:	80c5      	strh	r5, [r0, #6]
   1112a:	7204      	strb	r4, [r0, #8]
   1112c:	4d0c      	ldr	r5, [pc, #48]	; (11160 <bsec_IaqEstimator_IaqEstimator+0x54>)
   1112e:	6101      	str	r1, [r0, #16]
   11130:	f44f 74c8 	mov.w	r4, #400	; 0x190
   11134:	490b      	ldr	r1, [pc, #44]	; (11164 <bsec_IaqEstimator_IaqEstimator+0x58>)
   11136:	6145      	str	r5, [r0, #20]
   11138:	2200      	movs	r2, #0
   1113a:	f04f 557c 	mov.w	r5, #1056964608	; 0x3f000000
   1113e:	8304      	strh	r4, [r0, #24]
   11140:	61c1      	str	r1, [r0, #28]
   11142:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   11146:	4908      	ldr	r1, [pc, #32]	; (11168 <bsec_IaqEstimator_IaqEstimator+0x5c>)
   11148:	6205      	str	r5, [r0, #32]
   1114a:	8484      	strh	r4, [r0, #36]	; 0x24
   1114c:	60c2      	str	r2, [r0, #12]
   1114e:	6282      	str	r2, [r0, #40]	; 0x28
   11150:	62c2      	str	r2, [r0, #44]	; 0x2c
   11152:	6341      	str	r1, [r0, #52]	; 0x34
   11154:	6381      	str	r1, [r0, #56]	; 0x38
   11156:	bc30      	pop	{r4, r5}
   11158:	4770      	bx	lr
   1115a:	bf00      	nop
   1115c:	428551ec 	.word	0x428551ec
   11160:	41200000 	.word	0x41200000
   11164:	41700000 	.word	0x41700000
   11168:	41c80000 	.word	0x41c80000

0001116c <bsec_IaqEstimator_doStep>:
   1116c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11170:	ed91 7a00 	vldr	s14, [r1]
   11174:	edd1 6a02 	vldr	s13, [r1, #8]
   11178:	ed91 5a03 	vldr	s10, [r1, #12]
   1117c:	edd1 7a01 	vldr	s15, [r1, #4]
   11180:	ed2d 8b06 	vpush	{d8-d10}
   11184:	ee37 9a40 	vsub.f32	s18, s14, s0
   11188:	ee37 7a66 	vsub.f32	s14, s14, s13
   1118c:	460d      	mov	r5, r1
   1118e:	eec9 5a07 	vdiv.f32	s11, s18, s14
   11192:	88c1      	ldrh	r1, [r0, #6]
   11194:	9e10      	ldr	r6, [sp, #64]	; 0x40
   11196:	469a      	mov	sl, r3
   11198:	8843      	ldrh	r3, [r0, #2]
   1119a:	4604      	mov	r4, r0
   1119c:	4691      	mov	r9, r2
   1119e:	e9dd 870e 	ldrd	r8, r7, [sp, #56]	; 0x38
   111a2:	ee06 1a10 	vmov	s12, r1
   111a6:	7a01      	ldrb	r1, [r0, #8]
   111a8:	eeb8 6a46 	vcvt.f32.u32	s12, s12
   111ac:	ee06 1a90 	vmov	s13, r1
   111b0:	ee25 6a86 	vmul.f32	s12, s11, s12
   111b4:	eef8 6a66 	vcvt.f32.u32	s13, s13
   111b8:	ee09 3a90 	vmov	s19, r3
   111bc:	7903      	ldrb	r3, [r0, #4]
   111be:	eeb0 aa60 	vmov.f32	s20, s1
   111c2:	ee76 0a26 	vadd.f32	s1, s12, s13
   111c6:	ee06 3a90 	vmov	s13, r3
   111ca:	ee37 7ac0 	vsub.f32	s14, s15, s0
   111ce:	ee77 7ac5 	vsub.f32	s15, s15, s10
   111d2:	eeb8 0a66 	vcvt.f32.u32	s0, s13
   111d6:	eec7 8a27 	vdiv.f32	s17, s14, s15
   111da:	f01e f939 	bl	2f450 <fmaxf>
   111de:	eef8 9a69 	vcvt.f32.u32	s19, s19
   111e2:	eef0 0a40 	vmov.f32	s1, s0
   111e6:	eeb0 0a69 	vmov.f32	s0, s19
   111ea:	f01e f94f 	bl	2f48c <fminf>
   111ee:	7a23      	ldrb	r3, [r4, #8]
   111f0:	edd4 7a03 	vldr	s15, [r4, #12]
   111f4:	ee00 3a90 	vmov	s1, r3
   111f8:	7923      	ldrb	r3, [r4, #4]
   111fa:	ee29 9a27 	vmul.f32	s18, s18, s15
   111fe:	eef0 9a40 	vmov.f32	s19, s0
   11202:	eef8 0a60 	vcvt.f32.u32	s1, s1
   11206:	ee00 3a10 	vmov	s0, r3
   1120a:	ee79 0a20 	vadd.f32	s1, s18, s1
   1120e:	eeb8 0a40 	vcvt.f32.u32	s0, s0
   11212:	f01e f91d 	bl	2f450 <fmaxf>
   11216:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   1121a:	eeb4 aae7 	vcmpe.f32	s20, s15
   1121e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11222:	eeb0 8a40 	vmov.f32	s16, s0
   11226:	d45f      	bmi.n	112e8 <bsec_IaqEstimator_doStep+0x17c>
   11228:	edc4 9a0d 	vstr	s19, [r4, #52]	; 0x34
   1122c:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
   11230:	edc9 9a00 	vstr	s19, [r9]
   11234:	692b      	ldr	r3, [r5, #16]
   11236:	8b22      	ldrh	r2, [r4, #24]
   11238:	f8c9 3004 	str.w	r3, [r9, #4]
   1123c:	ed8a 8a00 	vstr	s16, [sl]
   11240:	692b      	ldr	r3, [r5, #16]
   11242:	f8ca 3004 	str.w	r3, [sl, #4]
   11246:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
   1124a:	ee00 2a10 	vmov	s0, r2
   1124e:	eef4 7ac8 	vcmpe.f32	s15, s16
   11252:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11256:	eeb8 0a40 	vcvt.f32.u32	s0, s0
   1125a:	db40      	blt.n	112de <bsec_IaqEstimator_doStep+0x172>
   1125c:	edd4 0a04 	vldr	s1, [r4, #16]
   11260:	ee68 0a20 	vmul.f32	s1, s16, s1
   11264:	ee70 0a80 	vadd.f32	s1, s1, s0
   11268:	f01e f8f2 	bl	2f450 <fmaxf>
   1126c:	ed88 0a00 	vstr	s0, [r8]
   11270:	692a      	ldr	r2, [r5, #16]
   11272:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
   11274:	f8c8 2004 	str.w	r2, [r8, #4]
   11278:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
   1127c:	edd4 0a0b 	vldr	s1, [r4, #44]	; 0x2c
   11280:	ee28 8a27 	vmul.f32	s16, s16, s15
   11284:	ee07 3a90 	vmov	s15, r3
   11288:	ee78 0a20 	vadd.f32	s1, s16, s1
   1128c:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
   11290:	eeb8 8a67 	vcvt.f32.u32	s16, s15
   11294:	f01e fa2c 	bl	2f6f0 <powf>
   11298:	eef0 0a40 	vmov.f32	s1, s0
   1129c:	ed9f 0a24 	vldr	s0, [pc, #144]	; 11330 <bsec_IaqEstimator_doStep+0x1c4>
   112a0:	f01e f8d6 	bl	2f450 <fmaxf>
   112a4:	eef0 0a40 	vmov.f32	s1, s0
   112a8:	eeb0 0a48 	vmov.f32	s0, s16
   112ac:	f01e f8ee 	bl	2f48c <fminf>
   112b0:	eddf 7a20 	vldr	s15, [pc, #128]	; 11334 <bsec_IaqEstimator_doStep+0x1c8>
   112b4:	ed87 0a00 	vstr	s0, [r7]
   112b8:	ee28 7aa7 	vmul.f32	s14, s17, s15
   112bc:	ecbd 8b06 	vpop	{d8-d10}
   112c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
   112c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   112c8:	692b      	ldr	r3, [r5, #16]
   112ca:	607b      	str	r3, [r7, #4]
   112cc:	bfd8      	it	le
   112ce:	eef0 7a47 	vmovle.f32	s15, s14
   112d2:	edc6 7a00 	vstr	s15, [r6]
   112d6:	696b      	ldr	r3, [r5, #20]
   112d8:	6073      	str	r3, [r6, #4]
   112da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   112de:	edd4 0a05 	vldr	s1, [r4, #20]
   112e2:	ee68 0a20 	vmul.f32	s1, s16, s1
   112e6:	e7bf      	b.n	11268 <bsec_IaqEstimator_doStep+0xfc>
   112e8:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
   112ec:	eeb4 7ae9 	vcmpe.f32	s14, s19
   112f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   112f4:	ee2a aa0a 	vmul.f32	s20, s20, s20
   112f8:	d507      	bpl.n	1130a <bsec_IaqEstimator_doStep+0x19e>
   112fa:	ee77 7aca 	vsub.f32	s15, s15, s20
   112fe:	ee69 9a8a 	vmul.f32	s19, s19, s20
   11302:	ee67 7a87 	vmul.f32	s15, s15, s14
   11306:	ee77 9aa9 	vadd.f32	s19, s15, s19
   1130a:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
   1130e:	eef4 7ac8 	vcmpe.f32	s15, s16
   11312:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11316:	d58b      	bpl.n	11230 <bsec_IaqEstimator_doStep+0xc4>
   11318:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
   1131c:	ee70 0aca 	vsub.f32	s1, s1, s20
   11320:	ee28 8a0a 	vmul.f32	s16, s16, s20
   11324:	ee60 0aa7 	vmul.f32	s1, s1, s15
   11328:	ee30 8a88 	vadd.f32	s16, s1, s16
   1132c:	e780      	b.n	11230 <bsec_IaqEstimator_doStep+0xc4>
   1132e:	bf00      	nop
   11330:	3dcccccd 	.word	0x3dcccccd
   11334:	42c80000 	.word	0x42c80000

00011338 <bsec_IaqEstimator_getConfiguration>:
   11338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1133c:	b084      	sub	sp, #16
   1133e:	ac04      	add	r4, sp, #16
   11340:	2508      	movs	r5, #8
   11342:	f804 5d09 	strb.w	r5, [r4, #-9]!
   11346:	4606      	mov	r6, r0
   11348:	4617      	mov	r7, r2
   1134a:	7800      	ldrb	r0, [r0, #0]
   1134c:	4622      	mov	r2, r4
   1134e:	460d      	mov	r5, r1
   11350:	f000 fb9c 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   11354:	f89d 2007 	ldrb.w	r2, [sp, #7]
   11358:	9003      	str	r0, [sp, #12]
   1135a:	b1ca      	cbz	r2, 11390 <bsec_IaqEstimator_getConfiguration+0x58>
   1135c:	2401      	movs	r4, #1
   1135e:	f106 0810 	add.w	r8, r6, #16
   11362:	1e63      	subs	r3, r4, #1
   11364:	2b07      	cmp	r3, #7
   11366:	d80e      	bhi.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   11368:	e8df f003 	tbb	[pc, r3]
   1136c:	515a3f48 	.word	0x515a3f48
   11370:	04232d36 	.word	0x04232d36
   11374:	aa03      	add	r2, sp, #12
   11376:	4639      	mov	r1, r7
   11378:	4628      	mov	r0, r5
   1137a:	ed96 0a08 	vldr	s0, [r6, #32]
   1137e:	f7fe fc3d 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   11382:	f89d 2007 	ldrb.w	r2, [sp, #7]
   11386:	3401      	adds	r4, #1
   11388:	b2e4      	uxtb	r4, r4
   1138a:	42a2      	cmp	r2, r4
   1138c:	d2e9      	bcs.n	11362 <bsec_IaqEstimator_getConfiguration+0x2a>
   1138e:	9803      	ldr	r0, [sp, #12]
   11390:	a904      	add	r1, sp, #16
   11392:	2202      	movs	r2, #2
   11394:	f821 0d06 	strh.w	r0, [r1, #-6]!
   11398:	a802      	add	r0, sp, #8
   1139a:	f027 fe1d 	bl	38fd8 <memcpy>
   1139e:	f89d 2008 	ldrb.w	r2, [sp, #8]
   113a2:	f89d 3009 	ldrb.w	r3, [sp, #9]
   113a6:	9803      	ldr	r0, [sp, #12]
   113a8:	702a      	strb	r2, [r5, #0]
   113aa:	706b      	strb	r3, [r5, #1]
   113ac:	b004      	add	sp, #16
   113ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   113b2:	aa03      	add	r2, sp, #12
   113b4:	4639      	mov	r1, r7
   113b6:	4628      	mov	r0, r5
   113b8:	ed96 0a07 	vldr	s0, [r6, #28]
   113bc:	f7fe fc1e 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   113c0:	f89d 2007 	ldrb.w	r2, [sp, #7]
   113c4:	e7df      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   113c6:	463a      	mov	r2, r7
   113c8:	ab03      	add	r3, sp, #12
   113ca:	4629      	mov	r1, r5
   113cc:	8b30      	ldrh	r0, [r6, #24]
   113ce:	f7fe fb9d 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   113d2:	f89d 2007 	ldrb.w	r2, [sp, #7]
   113d6:	e7d6      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   113d8:	463a      	mov	r2, r7
   113da:	ab03      	add	r3, sp, #12
   113dc:	4629      	mov	r1, r5
   113de:	4640      	mov	r0, r8
   113e0:	f7fe fdca 	bl	ff78 <bsec_m_Entity_serializeAndAdd>
   113e4:	f89d 2007 	ldrb.w	r2, [sp, #7]
   113e8:	e7cd      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   113ea:	463a      	mov	r2, r7
   113ec:	ab03      	add	r3, sp, #12
   113ee:	4629      	mov	r1, r5
   113f0:	8870      	ldrh	r0, [r6, #2]
   113f2:	f7fe fb8b 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   113f6:	f89d 2007 	ldrb.w	r2, [sp, #7]
   113fa:	e7c4      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   113fc:	463a      	mov	r2, r7
   113fe:	ab03      	add	r3, sp, #12
   11400:	4629      	mov	r1, r5
   11402:	7930      	ldrb	r0, [r6, #4]
   11404:	f7fe fc32 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
   11408:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1140c:	e7bb      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   1140e:	463a      	mov	r2, r7
   11410:	ab03      	add	r3, sp, #12
   11412:	4629      	mov	r1, r5
   11414:	7a30      	ldrb	r0, [r6, #8]
   11416:	f7fe fc29 	bl	fc6c <bsec_f_Entity_serializeAndAdd>
   1141a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1141e:	e7b2      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   11420:	463a      	mov	r2, r7
   11422:	ab03      	add	r3, sp, #12
   11424:	4629      	mov	r1, r5
   11426:	88f0      	ldrh	r0, [r6, #6]
   11428:	f7fe fb70 	bl	fb0c <bsec_c_Entity_serializeAndAdd>
   1142c:	f89d 2007 	ldrb.w	r2, [sp, #7]
   11430:	e7a9      	b.n	11386 <bsec_IaqEstimator_getConfiguration+0x4e>
   11432:	bf00      	nop

00011434 <bsec_IaqEstimator_getState>:
   11434:	b5f0      	push	{r4, r5, r6, r7, lr}
   11436:	b085      	sub	sp, #20
   11438:	ac04      	add	r4, sp, #16
   1143a:	2502      	movs	r5, #2
   1143c:	f804 5d09 	strb.w	r5, [r4, #-9]!
   11440:	4606      	mov	r6, r0
   11442:	4617      	mov	r7, r2
   11444:	7800      	ldrb	r0, [r0, #0]
   11446:	4622      	mov	r2, r4
   11448:	460d      	mov	r5, r1
   1144a:	f000 fb1f 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   1144e:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11452:	9003      	str	r0, [sp, #12]
   11454:	b303      	cbz	r3, 11498 <bsec_IaqEstimator_getState+0x64>
   11456:	2401      	movs	r4, #1
   11458:	e00e      	b.n	11478 <bsec_IaqEstimator_getState+0x44>
   1145a:	2c02      	cmp	r4, #2
   1145c:	d108      	bne.n	11470 <bsec_IaqEstimator_getState+0x3c>
   1145e:	aa03      	add	r2, sp, #12
   11460:	4639      	mov	r1, r7
   11462:	4628      	mov	r0, r5
   11464:	ed96 0a0e 	vldr	s0, [r6, #56]	; 0x38
   11468:	f7fe fbc8 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   1146c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11470:	3401      	adds	r4, #1
   11472:	b2e4      	uxtb	r4, r4
   11474:	42a3      	cmp	r3, r4
   11476:	d30e      	bcc.n	11496 <bsec_IaqEstimator_getState+0x62>
   11478:	2c01      	cmp	r4, #1
   1147a:	d1ee      	bne.n	1145a <bsec_IaqEstimator_getState+0x26>
   1147c:	aa03      	add	r2, sp, #12
   1147e:	4639      	mov	r1, r7
   11480:	4628      	mov	r0, r5
   11482:	ed96 0a0d 	vldr	s0, [r6, #52]	; 0x34
   11486:	f7fe fbb9 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   1148a:	3401      	adds	r4, #1
   1148c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11490:	b2e4      	uxtb	r4, r4
   11492:	42a3      	cmp	r3, r4
   11494:	d2f0      	bcs.n	11478 <bsec_IaqEstimator_getState+0x44>
   11496:	9803      	ldr	r0, [sp, #12]
   11498:	a904      	add	r1, sp, #16
   1149a:	2202      	movs	r2, #2
   1149c:	f821 0d06 	strh.w	r0, [r1, #-6]!
   114a0:	a802      	add	r0, sp, #8
   114a2:	f027 fd99 	bl	38fd8 <memcpy>
   114a6:	f89d 2008 	ldrb.w	r2, [sp, #8]
   114aa:	f89d 3009 	ldrb.w	r3, [sp, #9]
   114ae:	9803      	ldr	r0, [sp, #12]
   114b0:	702a      	strb	r2, [r5, #0]
   114b2:	706b      	strb	r3, [r5, #1]
   114b4:	b005      	add	sp, #20
   114b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

000114b8 <bsec_IaqEstimator_setState>:
   114b8:	b570      	push	{r4, r5, r6, lr}
   114ba:	b086      	sub	sp, #24
   114bc:	ab04      	add	r3, sp, #16
   114be:	ad05      	add	r5, sp, #20
   114c0:	4604      	mov	r4, r0
   114c2:	7800      	ldrb	r0, [r0, #0]
   114c4:	9300      	str	r3, [sp, #0]
   114c6:	9501      	str	r5, [sp, #4]
   114c8:	f10d 030f 	add.w	r3, sp, #15
   114cc:	460e      	mov	r6, r1
   114ce:	f000 faaf 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   114d2:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   114d6:	b968      	cbnz	r0, 114f4 <bsec_IaqEstimator_setState+0x3c>
   114d8:	4629      	mov	r1, r5
   114da:	4630      	mov	r0, r6
   114dc:	f7fe fb74 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   114e0:	4630      	mov	r0, r6
   114e2:	4629      	mov	r1, r5
   114e4:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
   114e8:	f7fe fb6e 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   114ec:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   114f0:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
   114f4:	b006      	add	sp, #24
   114f6:	bd70      	pop	{r4, r5, r6, pc}

000114f8 <bsec_IaqEstimator_updateInterfaceDependency>:
   114f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   114fc:	4299      	cmp	r1, r3
   114fe:	d04e      	beq.n	1159e <bsec_IaqEstimator_updateInterfaceDependency+0xa6>
   11500:	b5f0      	push	{r4, r5, r6, r7, lr}
   11502:	ed2d 8b02 	vpush	{d8}
   11506:	88c3      	ldrh	r3, [r0, #6]
   11508:	7a05      	ldrb	r5, [r0, #8]
   1150a:	69c6      	ldr	r6, [r0, #28]
   1150c:	6a07      	ldr	r7, [r0, #32]
   1150e:	442b      	add	r3, r5
   11510:	ee07 3a90 	vmov	s15, r3
   11514:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
   11518:	b083      	sub	sp, #12
   1151a:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   1151e:	d042      	beq.n	115a6 <bsec_IaqEstimator_updateInterfaceDependency+0xae>
   11520:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
   11524:	d03c      	beq.n	115a0 <bsec_IaqEstimator_updateInterfaceDependency+0xa8>
   11526:	2964      	cmp	r1, #100	; 0x64
   11528:	d03a      	beq.n	115a0 <bsec_IaqEstimator_updateInterfaceDependency+0xa8>
   1152a:	4b20      	ldr	r3, [pc, #128]	; (115ac <bsec_IaqEstimator_updateInterfaceDependency+0xb4>)
   1152c:	9300      	str	r3, [sp, #0]
   1152e:	4604      	mov	r4, r0
   11530:	4668      	mov	r0, sp
   11532:	f000 fb55 	bl	11be0 <bsec_log10>
   11536:	ee07 5a90 	vmov	s15, r5
   1153a:	ed9d 0a00 	vldr	s0, [sp]
   1153e:	eef8 8a67 	vcvt.f32.u32	s17, s15
   11542:	f01d ff79 	bl	2f438 <fabsf>
   11546:	ee78 8a68 	vsub.f32	s17, s16, s17
   1154a:	ad02      	add	r5, sp, #8
   1154c:	ee88 0a80 	vdiv.f32	s0, s17, s0
   11550:	f845 6d04 	str.w	r6, [r5, #-4]!
   11554:	4628      	mov	r0, r5
   11556:	ed84 0a03 	vstr	s0, [r4, #12]
   1155a:	f000 fb41 	bl	11be0 <bsec_log10>
   1155e:	4668      	mov	r0, sp
   11560:	9700      	str	r7, [sp, #0]
   11562:	f000 fb3d 	bl	11be0 <bsec_log10>
   11566:	eddd 7a01 	vldr	s15, [sp, #4]
   1156a:	ed9d 7a00 	vldr	s14, [sp]
   1156e:	9601      	str	r6, [sp, #4]
   11570:	ee77 7ac7 	vsub.f32	s15, s15, s14
   11574:	4628      	mov	r0, r5
   11576:	ee87 7aa8 	vdiv.f32	s14, s15, s17
   1157a:	ed84 7a0a 	vstr	s14, [r4, #40]	; 0x28
   1157e:	f000 fb2f 	bl	11be0 <bsec_log10>
   11582:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
   11586:	eddd 7a01 	vldr	s15, [sp, #4]
   1158a:	ee28 8a07 	vmul.f32	s16, s16, s14
   1158e:	ee37 8ac8 	vsub.f32	s16, s15, s16
   11592:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
   11596:	b003      	add	sp, #12
   11598:	ecbd 8b02 	vpop	{d8}
   1159c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1159e:	4770      	bx	lr
   115a0:	4b03      	ldr	r3, [pc, #12]	; (115b0 <bsec_IaqEstimator_updateInterfaceDependency+0xb8>)
   115a2:	9300      	str	r3, [sp, #0]
   115a4:	e7c3      	b.n	1152e <bsec_IaqEstimator_updateInterfaceDependency+0x36>
   115a6:	4b03      	ldr	r3, [pc, #12]	; (115b4 <bsec_IaqEstimator_updateInterfaceDependency+0xbc>)
   115a8:	9300      	str	r3, [sp, #0]
   115aa:	e7c0      	b.n	1152e <bsec_IaqEstimator_updateInterfaceDependency+0x36>
   115ac:	3f464c30 	.word	0x3f464c30
   115b0:	3f19999a 	.word	0x3f19999a
   115b4:	3f23d70a 	.word	0x3f23d70a

000115b8 <bsec_b_IaqEstimator_configure>:
   115b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   115bc:	b087      	sub	sp, #28
   115be:	ab04      	add	r3, sp, #16
   115c0:	ae05      	add	r6, sp, #20
   115c2:	4605      	mov	r5, r0
   115c4:	7800      	ldrb	r0, [r0, #0]
   115c6:	9300      	str	r3, [sp, #0]
   115c8:	9601      	str	r6, [sp, #4]
   115ca:	f10d 030f 	add.w	r3, sp, #15
   115ce:	460f      	mov	r7, r1
   115d0:	f000 fa2e 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   115d4:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   115d8:	bb10      	cbnz	r0, 11620 <bsec_b_IaqEstimator_configure+0x68>
   115da:	4604      	mov	r4, r0
   115dc:	f105 0810 	add.w	r8, r5, #16
   115e0:	fa5f f984 	uxtb.w	r9, r4
   115e4:	f109 0301 	add.w	r3, r9, #1
   115e8:	b2db      	uxtb	r3, r3
   115ea:	3b02      	subs	r3, #2
   115ec:	2b06      	cmp	r3, #6
   115ee:	d805      	bhi.n	115fc <bsec_b_IaqEstimator_configure+0x44>
   115f0:	e8df f003 	tbb	[pc, r3]
   115f4:	262c3238 	.word	0x262c3238
   115f8:	1920      	.short	0x1920
   115fa:	0e          	.byte	0x0e
   115fb:	00          	.byte	0x00
   115fc:	4631      	mov	r1, r6
   115fe:	4638      	mov	r0, r7
   11600:	f7fe fb20 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
   11604:	f1b9 0f07 	cmp.w	r9, #7
   11608:	7128      	strb	r0, [r5, #4]
   1160a:	d031      	beq.n	11670 <bsec_b_IaqEstimator_configure+0xb8>
   1160c:	3401      	adds	r4, #1
   1160e:	e7e7      	b.n	115e0 <bsec_b_IaqEstimator_configure+0x28>
   11610:	4638      	mov	r0, r7
   11612:	4631      	mov	r1, r6
   11614:	f7fe fad8 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   11618:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   1161c:	ed85 0a08 	vstr	s0, [r5, #32]
   11620:	b007      	add	sp, #28
   11622:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   11626:	4631      	mov	r1, r6
   11628:	4638      	mov	r0, r7
   1162a:	f7fe facd 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   1162e:	ed85 0a07 	vstr	s0, [r5, #28]
   11632:	e7eb      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   11634:	4631      	mov	r1, r6
   11636:	4638      	mov	r0, r7
   11638:	f7fe fa50 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   1163c:	8328      	strh	r0, [r5, #24]
   1163e:	e7e5      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   11640:	4642      	mov	r2, r8
   11642:	4631      	mov	r1, r6
   11644:	4638      	mov	r0, r7
   11646:	f7fe fd33 	bl	100b0 <bsec_p_Entity_parseAndDeserialize>
   1164a:	e7df      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   1164c:	4631      	mov	r1, r6
   1164e:	4638      	mov	r0, r7
   11650:	f7fe faf8 	bl	fc44 <bsec_f_Entity_parseAndDeserialize>
   11654:	7228      	strb	r0, [r5, #8]
   11656:	e7d9      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   11658:	4631      	mov	r1, r6
   1165a:	4638      	mov	r0, r7
   1165c:	f7fe fa3e 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   11660:	80e8      	strh	r0, [r5, #6]
   11662:	e7d3      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   11664:	4631      	mov	r1, r6
   11666:	4638      	mov	r0, r7
   11668:	f7fe fa38 	bl	fadc <bsec_c_Entity_parseAndDeserialize>
   1166c:	8068      	strh	r0, [r5, #2]
   1166e:	e7cd      	b.n	1160c <bsec_b_IaqEstimator_configure+0x54>
   11670:	f99d 000f 	ldrsb.w	r0, [sp, #15]
   11674:	e7d4      	b.n	11620 <bsec_b_IaqEstimator_configure+0x68>
   11676:	bf00      	nop

00011678 <bsec_SensorStatusTracker_SensorStatusTracker>:
   11678:	b430      	push	{r4, r5}
   1167a:	490c      	ldr	r1, [pc, #48]	; (116ac <bsec_SensorStatusTracker_SensorStatusTracker+0x34>)
   1167c:	61c1      	str	r1, [r0, #28]
   1167e:	2505      	movs	r5, #5
   11680:	2401      	movs	r4, #1
   11682:	2200      	movs	r2, #0
   11684:	2100      	movs	r1, #0
   11686:	7005      	strb	r5, [r0, #0]
   11688:	f880 4028 	strb.w	r4, [r0, #40]	; 0x28
   1168c:	2500      	movs	r5, #0
   1168e:	2400      	movs	r4, #0
   11690:	e9c0 4508 	strd	r4, r5, [r0, #32]
   11694:	e9c0 4502 	strd	r4, r5, [r0, #8]
   11698:	6182      	str	r2, [r0, #24]
   1169a:	6142      	str	r2, [r0, #20]
   1169c:	6102      	str	r2, [r0, #16]
   1169e:	f880 1029 	strb.w	r1, [r0, #41]	; 0x29
   116a2:	f880 102a 	strb.w	r1, [r0, #42]	; 0x2a
   116a6:	bc30      	pop	{r4, r5}
   116a8:	4770      	bx	lr
   116aa:	bf00      	nop
   116ac:	538bb2c9 	.word	0x538bb2c9

000116b0 <bsec_SensorStatusTracker_doStep>:
   116b0:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
   116b4:	e9d0 6702 	ldrd	r6, r7, [r0, #8]
   116b8:	4680      	mov	r8, r0
   116ba:	e9d0 0108 	ldrd	r0, r1, [r0, #32]
   116be:	4692      	mov	sl, r2
   116c0:	1b92      	subs	r2, r2, r6
   116c2:	469b      	mov	fp, r3
   116c4:	eb63 0307 	sbc.w	r3, r3, r7
   116c8:	4290      	cmp	r0, r2
   116ca:	eb71 0303 	sbcs.w	r3, r1, r3
   116ce:	9d08      	ldr	r5, [sp, #32]
   116d0:	db03      	blt.n	116da <bsec_SensorStatusTracker_doStep+0x2a>
   116d2:	45b2      	cmp	sl, r6
   116d4:	eb7b 0307 	sbcs.w	r3, fp, r7
   116d8:	da65      	bge.n	117a6 <bsec_SensorStatusTracker_doStep+0xf6>
   116da:	2300      	movs	r3, #0
   116dc:	2200      	movs	r2, #0
   116de:	f8c8 2010 	str.w	r2, [r8, #16]
   116e2:	f888 302a 	strb.w	r3, [r8, #42]	; 0x2a
   116e6:	461c      	mov	r4, r3
   116e8:	e9c8 ab02 	strd	sl, fp, [r8, #8]
   116ec:	f898 6029 	ldrb.w	r6, [r8, #41]	; 0x29
   116f0:	b9d6      	cbnz	r6, 11728 <bsec_SensorStatusTracker_doStep+0x78>
   116f2:	e9d8 2302 	ldrd	r2, r3, [r8, #8]
   116f6:	ebba 0002 	subs.w	r0, sl, r2
   116fa:	eb6b 0103 	sbc.w	r1, fp, r3
   116fe:	f000 fc41 	bl	11f84 <__aeabi_l2f>
   11702:	edd8 7a05 	vldr	s15, [r8, #20]
   11706:	ed98 7a06 	vldr	s14, [r8, #24]
   1170a:	ee06 0a90 	vmov	s13, r0
   1170e:	ee76 7aa7 	vadd.f32	s15, s13, s15
   11712:	eef4 7ac7 	vcmpe.f32	s15, s14
   11716:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1171a:	bfa8      	it	ge
   1171c:	2601      	movge	r6, #1
   1171e:	edc8 7a05 	vstr	s15, [r8, #20]
   11722:	bfa8      	it	ge
   11724:	f888 6029 	strbge.w	r6, [r8, #41]	; 0x29
   11728:	b9d4      	cbnz	r4, 11760 <bsec_SensorStatusTracker_doStep+0xb0>
   1172a:	e9d8 3402 	ldrd	r3, r4, [r8, #8]
   1172e:	ebba 0003 	subs.w	r0, sl, r3
   11732:	eb6b 0104 	sbc.w	r1, fp, r4
   11736:	f000 fc25 	bl	11f84 <__aeabi_l2f>
   1173a:	edd8 7a04 	vldr	s15, [r8, #16]
   1173e:	ed98 7a07 	vldr	s14, [r8, #28]
   11742:	ee06 0a90 	vmov	s13, r0
   11746:	ee76 7aa7 	vadd.f32	s15, s13, s15
   1174a:	eef4 7ac7 	vcmpe.f32	s15, s14
   1174e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11752:	bfa8      	it	ge
   11754:	2301      	movge	r3, #1
   11756:	edc8 7a04 	vstr	s15, [r8, #16]
   1175a:	bfa8      	it	ge
   1175c:	f888 302a 	strbge.w	r3, [r8, #42]	; 0x2a
   11760:	f1ba 0f01 	cmp.w	sl, #1
   11764:	f17b 0300 	sbcs.w	r3, fp, #0
   11768:	db23      	blt.n	117b2 <bsec_SensorStatusTracker_doStep+0x102>
   1176a:	e9c8 ab02 	strd	sl, fp, [r8, #8]
   1176e:	702e      	strb	r6, [r5, #0]
   11770:	f898 302a 	ldrb.w	r3, [r8, #42]	; 0x2a
   11774:	9a09      	ldr	r2, [sp, #36]	; 0x24
   11776:	7013      	strb	r3, [r2, #0]
   11778:	b933      	cbnz	r3, 11788 <bsec_SensorStatusTracker_doStep+0xd8>
   1177a:	edd8 7a07 	vldr	s15, [r8, #28]
   1177e:	eef5 7a40 	vcmp.f32	s15, #0.0
   11782:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11786:	d105      	bne.n	11794 <bsec_SensorStatusTracker_doStep+0xe4>
   11788:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   1178a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
   1178e:	6013      	str	r3, [r2, #0]
   11790:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
   11794:	edd8 6a04 	vldr	s13, [r8, #16]
   11798:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1179a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
   1179e:	ed83 7a00 	vstr	s14, [r3]
   117a2:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
   117a6:	ea56 0307 	orrs.w	r3, r6, r7
   117aa:	f898 402a 	ldrb.w	r4, [r8, #42]	; 0x2a
   117ae:	d19d      	bne.n	116ec <bsec_SensorStatusTracker_doStep+0x3c>
   117b0:	e79a      	b.n	116e8 <bsec_SensorStatusTracker_doStep+0x38>
   117b2:	2201      	movs	r2, #1
   117b4:	2300      	movs	r3, #0
   117b6:	e9c8 2302 	strd	r2, r3, [r8, #8]
   117ba:	e7d8      	b.n	1176e <bsec_SensorStatusTracker_doStep+0xbe>

000117bc <bsec_SensorStatusTracker_getConfiguration>:
   117bc:	b5f0      	push	{r4, r5, r6, r7, lr}
   117be:	b085      	sub	sp, #20
   117c0:	ac04      	add	r4, sp, #16
   117c2:	2502      	movs	r5, #2
   117c4:	f804 5d09 	strb.w	r5, [r4, #-9]!
   117c8:	4606      	mov	r6, r0
   117ca:	4617      	mov	r7, r2
   117cc:	7800      	ldrb	r0, [r0, #0]
   117ce:	4622      	mov	r2, r4
   117d0:	460d      	mov	r5, r1
   117d2:	f000 f95b 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   117d6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   117da:	9003      	str	r0, [sp, #12]
   117dc:	b303      	cbz	r3, 11820 <bsec_SensorStatusTracker_getConfiguration+0x64>
   117de:	2401      	movs	r4, #1
   117e0:	e00e      	b.n	11800 <bsec_SensorStatusTracker_getConfiguration+0x44>
   117e2:	2c02      	cmp	r4, #2
   117e4:	d108      	bne.n	117f8 <bsec_SensorStatusTracker_getConfiguration+0x3c>
   117e6:	ab03      	add	r3, sp, #12
   117e8:	463a      	mov	r2, r7
   117ea:	4629      	mov	r1, r5
   117ec:	f996 0028 	ldrsb.w	r0, [r6, #40]	; 0x28
   117f0:	f7fe fb8c 	bl	ff0c <bsec_l_Entity_serializeAndAdd>
   117f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   117f8:	3401      	adds	r4, #1
   117fa:	b2e4      	uxtb	r4, r4
   117fc:	42a3      	cmp	r3, r4
   117fe:	d30e      	bcc.n	1181e <bsec_SensorStatusTracker_getConfiguration+0x62>
   11800:	2c01      	cmp	r4, #1
   11802:	d1ee      	bne.n	117e2 <bsec_SensorStatusTracker_getConfiguration+0x26>
   11804:	aa03      	add	r2, sp, #12
   11806:	4639      	mov	r1, r7
   11808:	4628      	mov	r0, r5
   1180a:	ed96 0a06 	vldr	s0, [r6, #24]
   1180e:	f7fe f9f5 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   11812:	3401      	adds	r4, #1
   11814:	f89d 3007 	ldrb.w	r3, [sp, #7]
   11818:	b2e4      	uxtb	r4, r4
   1181a:	42a3      	cmp	r3, r4
   1181c:	d2f0      	bcs.n	11800 <bsec_SensorStatusTracker_getConfiguration+0x44>
   1181e:	9803      	ldr	r0, [sp, #12]
   11820:	a904      	add	r1, sp, #16
   11822:	2202      	movs	r2, #2
   11824:	f821 0d06 	strh.w	r0, [r1, #-6]!
   11828:	a802      	add	r0, sp, #8
   1182a:	f027 fbd5 	bl	38fd8 <memcpy>
   1182e:	f89d 2008 	ldrb.w	r2, [sp, #8]
   11832:	f89d 3009 	ldrb.w	r3, [sp, #9]
   11836:	9803      	ldr	r0, [sp, #12]
   11838:	702a      	strb	r2, [r5, #0]
   1183a:	706b      	strb	r3, [r5, #1]
   1183c:	b005      	add	sp, #20
   1183e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00011840 <bsec_SensorStatusTracker_getState>:
   11840:	b5f0      	push	{r4, r5, r6, r7, lr}
   11842:	b087      	sub	sp, #28
   11844:	ac06      	add	r4, sp, #24
   11846:	2505      	movs	r5, #5
   11848:	f804 5d09 	strb.w	r5, [r4, #-9]!
   1184c:	4606      	mov	r6, r0
   1184e:	4617      	mov	r7, r2
   11850:	7800      	ldrb	r0, [r0, #0]
   11852:	4622      	mov	r2, r4
   11854:	460d      	mov	r5, r1
   11856:	f000 f919 	bl	11a8c <bsec_Serialization_prepareSerializationHeader>
   1185a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1185e:	9005      	str	r0, [sp, #20]
   11860:	b1b2      	cbz	r2, 11890 <bsec_SensorStatusTracker_getState+0x50>
   11862:	2401      	movs	r4, #1
   11864:	1e63      	subs	r3, r4, #1
   11866:	2b04      	cmp	r3, #4
   11868:	d80d      	bhi.n	11886 <bsec_SensorStatusTracker_getState+0x46>
   1186a:	e8df f003 	tbb	[pc, r3]
   1186e:	213f      	.short	0x213f
   11870:	2b35      	.short	0x2b35
   11872:	03          	.byte	0x03
   11873:	00          	.byte	0x00
   11874:	463a      	mov	r2, r7
   11876:	ab05      	add	r3, sp, #20
   11878:	4629      	mov	r1, r5
   1187a:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
   1187e:	f7fe fa5b 	bl	fd38 <bsec_h_Entity_serializeAndAdd>
   11882:	f89d 200f 	ldrb.w	r2, [sp, #15]
   11886:	3401      	adds	r4, #1
   11888:	b2e4      	uxtb	r4, r4
   1188a:	42a2      	cmp	r2, r4
   1188c:	d2ea      	bcs.n	11864 <bsec_SensorStatusTracker_getState+0x24>
   1188e:	9805      	ldr	r0, [sp, #20]
   11890:	a906      	add	r1, sp, #24
   11892:	2202      	movs	r2, #2
   11894:	f821 0d06 	strh.w	r0, [r1, #-6]!
   11898:	a804      	add	r0, sp, #16
   1189a:	f027 fb9d 	bl	38fd8 <memcpy>
   1189e:	f89d 2010 	ldrb.w	r2, [sp, #16]
   118a2:	f89d 3011 	ldrb.w	r3, [sp, #17]
   118a6:	9805      	ldr	r0, [sp, #20]
   118a8:	702a      	strb	r2, [r5, #0]
   118aa:	706b      	strb	r3, [r5, #1]
   118ac:	b007      	add	sp, #28
   118ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   118b0:	aa05      	add	r2, sp, #20
   118b2:	4639      	mov	r1, r7
   118b4:	4628      	mov	r0, r5
   118b6:	ed96 0a05 	vldr	s0, [r6, #20]
   118ba:	f7fe f99f 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   118be:	f89d 200f 	ldrb.w	r2, [sp, #15]
   118c2:	e7e0      	b.n	11886 <bsec_SensorStatusTracker_getState+0x46>
   118c4:	463a      	mov	r2, r7
   118c6:	ab05      	add	r3, sp, #20
   118c8:	4629      	mov	r1, r5
   118ca:	f896 0029 	ldrb.w	r0, [r6, #41]	; 0x29
   118ce:	f7fe fa33 	bl	fd38 <bsec_h_Entity_serializeAndAdd>
   118d2:	f89d 200f 	ldrb.w	r2, [sp, #15]
   118d6:	e7d6      	b.n	11886 <bsec_SensorStatusTracker_getState+0x46>
   118d8:	aa05      	add	r2, sp, #20
   118da:	4639      	mov	r1, r7
   118dc:	4628      	mov	r0, r5
   118de:	ed96 0a04 	vldr	s0, [r6, #16]
   118e2:	f7fe f98b 	bl	fbfc <bsec_e_Entity_serializeAndAdd>
   118e6:	f89d 200f 	ldrb.w	r2, [sp, #15]
   118ea:	e7cc      	b.n	11886 <bsec_SensorStatusTracker_getState+0x46>
   118ec:	ab05      	add	r3, sp, #20
   118ee:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
   118f2:	462a      	mov	r2, r5
   118f4:	9300      	str	r3, [sp, #0]
   118f6:	463b      	mov	r3, r7
   118f8:	f7fe f9f2 	bl	fce0 <bsec_g_Entity_serializeAndAdd>
   118fc:	f89d 200f 	ldrb.w	r2, [sp, #15]
   11900:	e7c1      	b.n	11886 <bsec_SensorStatusTracker_getState+0x46>
   11902:	bf00      	nop

00011904 <bsec_SensorStatusTracker_setState>:
   11904:	b5f0      	push	{r4, r5, r6, r7, lr}
   11906:	b087      	sub	sp, #28
   11908:	ab04      	add	r3, sp, #16
   1190a:	ae05      	add	r6, sp, #20
   1190c:	4605      	mov	r5, r0
   1190e:	7800      	ldrb	r0, [r0, #0]
   11910:	9300      	str	r3, [sp, #0]
   11912:	9601      	str	r6, [sp, #4]
   11914:	f10d 030f 	add.w	r3, sp, #15
   11918:	460f      	mov	r7, r1
   1191a:	f000 f889 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   1191e:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   11922:	b9c3      	cbnz	r3, 11956 <bsec_SensorStatusTracker_setState+0x52>
   11924:	2401      	movs	r4, #1
   11926:	1ea3      	subs	r3, r4, #2
   11928:	4631      	mov	r1, r6
   1192a:	4638      	mov	r0, r7
   1192c:	2b03      	cmp	r3, #3
   1192e:	d803      	bhi.n	11938 <bsec_SensorStatusTracker_setState+0x34>
   11930:	e8df f003 	tbb	[pc, r3]
   11934:	0b14191e 	.word	0x0b14191e
   11938:	f7fe f9b6 	bl	fca8 <bsec_g_Entity_parseAndDeserialize>
   1193c:	2c05      	cmp	r4, #5
   1193e:	e9c5 0102 	strd	r0, r1, [r5, #8]
   11942:	d01a      	beq.n	1197a <bsec_SensorStatusTracker_setState+0x76>
   11944:	3401      	adds	r4, #1
   11946:	b2e4      	uxtb	r4, r4
   11948:	e7ed      	b.n	11926 <bsec_SensorStatusTracker_setState+0x22>
   1194a:	f7fe f9ed 	bl	fd28 <bsec_h_Entity_parseAndDeserialize>
   1194e:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   11952:	f885 002a 	strb.w	r0, [r5, #42]	; 0x2a
   11956:	4618      	mov	r0, r3
   11958:	b007      	add	sp, #28
   1195a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1195c:	f7fe f9e4 	bl	fd28 <bsec_h_Entity_parseAndDeserialize>
   11960:	f885 0029 	strb.w	r0, [r5, #41]	; 0x29
   11964:	e7ee      	b.n	11944 <bsec_SensorStatusTracker_setState+0x40>
   11966:	f7fe f92f 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   1196a:	ed85 0a04 	vstr	s0, [r5, #16]
   1196e:	e7e9      	b.n	11944 <bsec_SensorStatusTracker_setState+0x40>
   11970:	f7fe f92a 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   11974:	ed85 0a05 	vstr	s0, [r5, #20]
   11978:	e7e4      	b.n	11944 <bsec_SensorStatusTracker_setState+0x40>
   1197a:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   1197e:	e7ea      	b.n	11956 <bsec_SensorStatusTracker_setState+0x52>

00011980 <bsec_SensorStatusTracker_updateInterfaceDependency>:
   11980:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11984:	4299      	cmp	r1, r3
   11986:	d018      	beq.n	119ba <bsec_SensorStatusTracker_updateInterfaceDependency+0x3a>
   11988:	f990 2028 	ldrsb.w	r2, [r0, #40]	; 0x28
   1198c:	4b13      	ldr	r3, [pc, #76]	; (119dc <bsec_SensorStatusTracker_updateInterfaceDependency+0x5c>)
   1198e:	fb01 f202 	mul.w	r2, r1, r2
   11992:	eb02 0252 	add.w	r2, r2, r2, lsr #1
   11996:	fba2 2303 	umull	r2, r3, r2, r3
   1199a:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
   1199e:	e9c0 2308 	strd	r2, r3, [r0, #32]
   119a2:	d007      	beq.n	119b4 <bsec_SensorStatusTracker_updateInterfaceDependency+0x34>
   119a4:	f5b1 6fe1 	cmp.w	r1, #1800	; 0x708
   119a8:	d014      	beq.n	119d4 <bsec_SensorStatusTracker_updateInterfaceDependency+0x54>
   119aa:	2964      	cmp	r1, #100	; 0x64
   119ac:	d002      	beq.n	119b4 <bsec_SensorStatusTracker_updateInterfaceDependency+0x34>
   119ae:	4b0c      	ldr	r3, [pc, #48]	; (119e0 <bsec_SensorStatusTracker_updateInterfaceDependency+0x60>)
   119b0:	61c3      	str	r3, [r0, #28]
   119b2:	4770      	bx	lr
   119b4:	4b0b      	ldr	r3, [pc, #44]	; (119e4 <bsec_SensorStatusTracker_updateInterfaceDependency+0x64>)
   119b6:	61c3      	str	r3, [r0, #28]
   119b8:	4770      	bx	lr
   119ba:	b410      	push	{r4}
   119bc:	2100      	movs	r1, #0
   119be:	2400      	movs	r4, #0
   119c0:	2200      	movs	r2, #0
   119c2:	2300      	movs	r3, #0
   119c4:	6104      	str	r4, [r0, #16]
   119c6:	f880 102a 	strb.w	r1, [r0, #42]	; 0x2a
   119ca:	e9c0 2302 	strd	r2, r3, [r0, #8]
   119ce:	f85d 4b04 	ldr.w	r4, [sp], #4
   119d2:	4770      	bx	lr
   119d4:	4b04      	ldr	r3, [pc, #16]	; (119e8 <bsec_SensorStatusTracker_updateInterfaceDependency+0x68>)
   119d6:	61c3      	str	r3, [r0, #28]
   119d8:	4770      	bx	lr
   119da:	bf00      	nop
   119dc:	00989680 	.word	0x00989680
   119e0:	538bb2c9 	.word	0x538bb2c9
   119e4:	528bb2c9 	.word	0x528bb2c9
   119e8:	515f8476 	.word	0x515f8476

000119ec <bsec_b_SensorStatusTracker_configure>:
   119ec:	b570      	push	{r4, r5, r6, lr}
   119ee:	b086      	sub	sp, #24
   119f0:	ab04      	add	r3, sp, #16
   119f2:	ad05      	add	r5, sp, #20
   119f4:	4604      	mov	r4, r0
   119f6:	7800      	ldrb	r0, [r0, #0]
   119f8:	9300      	str	r3, [sp, #0]
   119fa:	9501      	str	r5, [sp, #4]
   119fc:	f10d 030f 	add.w	r3, sp, #15
   11a00:	460e      	mov	r6, r1
   11a02:	f000 f815 	bl	11a30 <bsec_Serialization_checkSerializationHeader>
   11a06:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   11a0a:	b96b      	cbnz	r3, 11a28 <bsec_b_SensorStatusTracker_configure+0x3c>
   11a0c:	4629      	mov	r1, r5
   11a0e:	4630      	mov	r0, r6
   11a10:	f7fe f8da 	bl	fbc8 <bsec_e_Entity_parseAndDeserialize>
   11a14:	4629      	mov	r1, r5
   11a16:	ed84 0a06 	vstr	s0, [r4, #24]
   11a1a:	4630      	mov	r0, r6
   11a1c:	f7fe fb0c 	bl	10038 <bsec_o_Entity_parseAndDeserialize>
   11a20:	f99d 300f 	ldrsb.w	r3, [sp, #15]
   11a24:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
   11a28:	4618      	mov	r0, r3
   11a2a:	b006      	add	sp, #24
   11a2c:	bd70      	pop	{r4, r5, r6, pc}
   11a2e:	bf00      	nop

00011a30 <bsec_Serialization_checkSerializationHeader>:
   11a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   11a34:	b082      	sub	sp, #8
   11a36:	e9dd 8608 	ldrd	r8, r6, [sp, #32]
   11a3a:	2400      	movs	r4, #0
   11a3c:	2a03      	cmp	r2, #3
   11a3e:	6034      	str	r4, [r6, #0]
   11a40:	701c      	strb	r4, [r3, #0]
   11a42:	f8c8 4000 	str.w	r4, [r8]
   11a46:	d91c      	bls.n	11a82 <bsec_Serialization_checkSerializationHeader+0x52>
   11a48:	461c      	mov	r4, r3
   11a4a:	2304      	movs	r3, #4
   11a4c:	6033      	str	r3, [r6, #0]
   11a4e:	780a      	ldrb	r2, [r1, #0]
   11a50:	784b      	ldrb	r3, [r1, #1]
   11a52:	f88d 2004 	strb.w	r2, [sp, #4]
   11a56:	460d      	mov	r5, r1
   11a58:	4607      	mov	r7, r0
   11a5a:	2202      	movs	r2, #2
   11a5c:	a901      	add	r1, sp, #4
   11a5e:	f10d 0006 	add.w	r0, sp, #6
   11a62:	f88d 3005 	strb.w	r3, [sp, #5]
   11a66:	f027 fab7 	bl	38fd8 <memcpy>
   11a6a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   11a6e:	f8c8 3000 	str.w	r3, [r8]
   11a72:	78ab      	ldrb	r3, [r5, #2]
   11a74:	42bb      	cmp	r3, r7
   11a76:	bf1c      	itt	ne
   11a78:	239c      	movne	r3, #156	; 0x9c
   11a7a:	7023      	strbne	r3, [r4, #0]
   11a7c:	b002      	add	sp, #8
   11a7e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11a82:	2298      	movs	r2, #152	; 0x98
   11a84:	701a      	strb	r2, [r3, #0]
   11a86:	b002      	add	sp, #8
   11a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00011a8c <bsec_Serialization_prepareSerializationHeader>:
   11a8c:	b410      	push	{r4}
   11a8e:	7814      	ldrb	r4, [r2, #0]
   11a90:	b10c      	cbz	r4, 11a96 <bsec_Serialization_prepareSerializationHeader+0xa>
   11a92:	429c      	cmp	r4, r3
   11a94:	d204      	bcs.n	11aa0 <bsec_Serialization_prepareSerializationHeader+0x14>
   11a96:	2000      	movs	r0, #0
   11a98:	7010      	strb	r0, [r2, #0]
   11a9a:	f85d 4b04 	ldr.w	r4, [sp], #4
   11a9e:	4770      	bx	lr
   11aa0:	7088      	strb	r0, [r1, #2]
   11aa2:	f85d 4b04 	ldr.w	r4, [sp], #4
   11aa6:	2004      	movs	r0, #4
   11aa8:	4770      	bx	lr
   11aaa:	bf00      	nop

00011aac <bsec_convertHumidity>:
   11aac:	b500      	push	{lr}
   11aae:	ed2d 8b02 	vpush	{d8}
   11ab2:	eeb5 1ac0 	vcmpe.f32	s2, #0.0
   11ab6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11aba:	b083      	sub	sp, #12
   11abc:	eef0 8a40 	vmov.f32	s17, s0
   11ac0:	eeb0 8a60 	vmov.f32	s16, s1
   11ac4:	d452      	bmi.n	11b6c <bsec_convertHumidity+0xc0>
   11ac6:	ed9f 7a2b 	vldr	s14, [pc, #172]	; 11b74 <bsec_convertHumidity+0xc8>
   11aca:	eeb4 1ac7 	vcmpe.f32	s2, s14
   11ace:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11ad2:	dc41      	bgt.n	11b58 <bsec_convertHumidity+0xac>
   11ad4:	eec1 7a07 	vdiv.f32	s15, s2, s14
   11ad8:	a802      	add	r0, sp, #8
   11ada:	ed60 7a01 	vstmdb	r0!, {s15}
   11ade:	f000 f875 	bl	11bcc <bsec_log>
   11ae2:	ed9f 7a25 	vldr	s14, [pc, #148]	; 11b78 <bsec_convertHumidity+0xcc>
   11ae6:	eddf 7a25 	vldr	s15, [pc, #148]	; 11b7c <bsec_convertHumidity+0xd0>
   11aea:	eddd 5a01 	vldr	s11, [sp, #4]
   11aee:	ee28 5a87 	vmul.f32	s10, s17, s14
   11af2:	ee78 8aa7 	vadd.f32	s17, s17, s15
   11af6:	ee28 6a07 	vmul.f32	s12, s16, s14
   11afa:	eec5 6a28 	vdiv.f32	s13, s10, s17
   11afe:	ee38 8a27 	vadd.f32	s16, s16, s15
   11b02:	ee76 6aa5 	vadd.f32	s13, s13, s11
   11b06:	eec6 5a08 	vdiv.f32	s11, s12, s16
   11b0a:	ee26 5aa7 	vmul.f32	s10, s13, s15
   11b0e:	ee77 6a66 	vsub.f32	s13, s14, s13
   11b12:	ee85 6a26 	vdiv.f32	s12, s10, s13
   11b16:	ee76 7a27 	vadd.f32	s15, s12, s15
   11b1a:	ee26 7a07 	vmul.f32	s14, s12, s14
   11b1e:	ed8d 6a01 	vstr	s12, [sp, #4]
   11b22:	ee87 0a27 	vdiv.f32	s0, s14, s15
   11b26:	ee30 0a65 	vsub.f32	s0, s0, s11
   11b2a:	f01d fd37 	bl	2f59c <expf>
   11b2e:	eddf 7a11 	vldr	s15, [pc, #68]	; 11b74 <bsec_convertHumidity+0xc8>
   11b32:	ee20 0a27 	vmul.f32	s0, s0, s15
   11b36:	eeb4 0ae7 	vcmpe.f32	s0, s15
   11b3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11b3e:	dc0e      	bgt.n	11b5e <bsec_convertHumidity+0xb2>
   11b40:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
   11b44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11b48:	dc01      	bgt.n	11b4e <bsec_convertHumidity+0xa2>
   11b4a:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 11b80 <bsec_convertHumidity+0xd4>
   11b4e:	b003      	add	sp, #12
   11b50:	ecbd 8b02 	vpop	{d8}
   11b54:	f85d fb04 	ldr.w	pc, [sp], #4
   11b58:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   11b5c:	e7bc      	b.n	11ad8 <bsec_convertHumidity+0x2c>
   11b5e:	eeb0 0a67 	vmov.f32	s0, s15
   11b62:	b003      	add	sp, #12
   11b64:	ecbd 8b02 	vpop	{d8}
   11b68:	f85d fb04 	ldr.w	pc, [sp], #4
   11b6c:	eddf 7a04 	vldr	s15, [pc, #16]	; 11b80 <bsec_convertHumidity+0xd4>
   11b70:	e7b2      	b.n	11ad8 <bsec_convertHumidity+0x2c>
   11b72:	bf00      	nop
   11b74:	42c80000 	.word	0x42c80000
   11b78:	418cf5c3 	.word	0x418cf5c3
   11b7c:	43731eb8 	.word	0x43731eb8
   11b80:	00000000 	.word	0x00000000

00011b84 <bsec_crcCcitt2>:
   11b84:	b1b9      	cbz	r1, 11bb6 <bsec_crcCcitt2+0x32>
   11b86:	b430      	push	{r4, r5}
   11b88:	3801      	subs	r0, #1
   11b8a:	4d0c      	ldr	r5, [pc, #48]	; (11bbc <bsec_crcCcitt2+0x38>)
   11b8c:	4401      	add	r1, r0
   11b8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   11b92:	f810 4f01 	ldrb.w	r4, [r0, #1]!
   11b96:	4063      	eors	r3, r4
   11b98:	b2dc      	uxtb	r4, r3
   11b9a:	4281      	cmp	r1, r0
   11b9c:	f835 4014 	ldrh.w	r4, [r5, r4, lsl #1]
   11ba0:	ea84 2313 	eor.w	r3, r4, r3, lsr #8
   11ba4:	d1f5      	bne.n	11b92 <bsec_crcCcitt2+0xe>
   11ba6:	43db      	mvns	r3, r3
   11ba8:	b29b      	uxth	r3, r3
   11baa:	b2d8      	uxtb	r0, r3
   11bac:	0a19      	lsrs	r1, r3, #8
   11bae:	7010      	strb	r0, [r2, #0]
   11bb0:	7051      	strb	r1, [r2, #1]
   11bb2:	bc30      	pop	{r4, r5}
   11bb4:	4770      	bx	lr
   11bb6:	7011      	strb	r1, [r2, #0]
   11bb8:	7051      	strb	r1, [r2, #1]
   11bba:	4770      	bx	lr
   11bbc:	0003ad98 	.word	0x0003ad98

00011bc0 <bsec_isequal>:
   11bc0:	4299      	cmp	r1, r3
   11bc2:	bf06      	itte	eq
   11bc4:	4290      	cmpeq	r0, r2
   11bc6:	2001      	moveq	r0, #1
   11bc8:	2000      	movne	r0, #0
   11bca:	4770      	bx	lr

00011bcc <bsec_log>:
   11bcc:	b510      	push	{r4, lr}
   11bce:	ed90 0a00 	vldr	s0, [r0]
   11bd2:	4604      	mov	r4, r0
   11bd4:	f01d fd20 	bl	2f618 <logf>
   11bd8:	ed84 0a00 	vstr	s0, [r4]
   11bdc:	bd10      	pop	{r4, pc}
   11bde:	bf00      	nop

00011be0 <bsec_log10>:
   11be0:	b510      	push	{r4, lr}
   11be2:	ed90 0a00 	vldr	s0, [r0]
   11be6:	4604      	mov	r4, r0
   11be8:	f01d fd4c 	bl	2f684 <log10f>
   11bec:	ed84 0a00 	vstr	s0, [r4]
   11bf0:	bd10      	pop	{r4, pc}
   11bf2:	bf00      	nop

00011bf4 <bsec_polyval>:
   11bf4:	edd0 7a00 	vldr	s15, [r0]
   11bf8:	ed90 7a01 	vldr	s14, [r0, #4]
   11bfc:	ee20 0a27 	vmul.f32	s0, s0, s15
   11c00:	ee30 0a07 	vadd.f32	s0, s0, s14
   11c04:	4770      	bx	lr
   11c06:	bf00      	nop

00011c08 <bsec_b_sqrt>:
   11c08:	b510      	push	{r4, lr}
   11c0a:	ed90 0a00 	vldr	s0, [r0]
   11c0e:	4604      	mov	r4, r0
   11c10:	f01d fe0e 	bl	2f830 <sqrtf>
   11c14:	ed84 0a00 	vstr	s0, [r4]
   11c18:	bd10      	pop	{r4, pc}
   11c1a:	bf00      	nop

00011c1c <bsec_sqrt>:
   11c1c:	f000 b890 	b.w	11d40 <bsec_applyScalarFunctionInPlace>

00011c20 <bsec_Channel_reset>:
   11c20:	7f01      	ldrb	r1, [r0, #28]
   11c22:	4b0a      	ldr	r3, [pc, #40]	; (11c4c <bsec_Channel_reset+0x2c>)
   11c24:	4a0a      	ldr	r2, [pc, #40]	; (11c50 <bsec_Channel_reset+0x30>)
   11c26:	6202      	str	r2, [r0, #32]
   11c28:	6243      	str	r3, [r0, #36]	; 0x24
   11c2a:	6283      	str	r3, [r0, #40]	; 0x28
   11c2c:	b161      	cbz	r1, 11c48 <bsec_Channel_reset+0x28>
   11c2e:	b410      	push	{r4}
   11c30:	2301      	movs	r3, #1
   11c32:	2400      	movs	r4, #0
   11c34:	3301      	adds	r3, #1
   11c36:	eb00 0283 	add.w	r2, r0, r3, lsl #2
   11c3a:	b2db      	uxtb	r3, r3
   11c3c:	4299      	cmp	r1, r3
   11c3e:	6094      	str	r4, [r2, #8]
   11c40:	d2f8      	bcs.n	11c34 <bsec_Channel_reset+0x14>
   11c42:	f85d 4b04 	ldr.w	r4, [sp], #4
   11c46:	4770      	bx	lr
   11c48:	4770      	bx	lr
   11c4a:	bf00      	nop
   11c4c:	3b23d70a 	.word	0x3b23d70a
   11c50:	3ca3d70a 	.word	0x3ca3d70a

00011c54 <bsec_b_Channel_reset>:
   11c54:	7b03      	ldrb	r3, [r0, #12]
   11c56:	2200      	movs	r2, #0
   11c58:	6102      	str	r2, [r0, #16]
   11c5a:	6142      	str	r2, [r0, #20]
   11c5c:	b11b      	cbz	r3, 11c66 <bsec_b_Channel_reset+0x12>
   11c5e:	2b01      	cmp	r3, #1
   11c60:	d8fd      	bhi.n	11c5e <bsec_b_Channel_reset+0xa>
   11c62:	2300      	movs	r3, #0
   11c64:	6083      	str	r3, [r0, #8]
   11c66:	4770      	bx	lr

00011c68 <bsec_ExpSmoothing_setCoeffFromBandwidth>:
   11c68:	b5f0      	push	{r4, r5, r6, r7, lr}
   11c6a:	ed9f 6a26 	vldr	s12, [pc, #152]	; 11d04 <bsec_ExpSmoothing_setCoeffFromBandwidth+0x9c>
   11c6e:	edd1 6a00 	vldr	s13, [r1]
   11c72:	ed91 7a01 	vldr	s14, [r1, #4]
   11c76:	edd1 7a02 	vldr	s15, [r1, #8]
   11c7a:	b087      	sub	sp, #28
   11c7c:	ee66 6a86 	vmul.f32	s13, s13, s12
   11c80:	ee27 7a06 	vmul.f32	s14, s14, s12
   11c84:	ee67 7a86 	vmul.f32	s15, s15, s12
   11c88:	4606      	mov	r6, r0
   11c8a:	466f      	mov	r7, sp
   11c8c:	4668      	mov	r0, sp
   11c8e:	ad03      	add	r5, sp, #12
   11c90:	460c      	mov	r4, r1
   11c92:	edcd 6a00 	vstr	s13, [sp]
   11c96:	ed8d 7a01 	vstr	s14, [sp, #4]
   11c9a:	edcd 7a02 	vstr	s15, [sp, #8]
   11c9e:	f000 f85d 	bl	11d5c <bsec_sin>
   11ca2:	463b      	mov	r3, r7
   11ca4:	462a      	mov	r2, r5
   11ca6:	edd3 7a00 	vldr	s15, [r3]
   11caa:	ee67 7aa7 	vmul.f32	s15, s15, s15
   11cae:	ee27 7aa7 	vmul.f32	s14, s15, s15
   11cb2:	ece3 7a01 	vstmia	r3!, {s15}
   11cb6:	ee77 7a27 	vadd.f32	s15, s14, s15
   11cba:	42ab      	cmp	r3, r5
   11cbc:	ece2 7a01 	vstmia	r2!, {s15}
   11cc0:	d1f1      	bne.n	11ca6 <bsec_ExpSmoothing_setCoeffFromBandwidth+0x3e>
   11cc2:	4628      	mov	r0, r5
   11cc4:	f7ff ffaa 	bl	11c1c <bsec_sqrt>
   11cc8:	4621      	mov	r1, r4
   11cca:	4630      	mov	r0, r6
   11ccc:	f104 030c 	add.w	r3, r4, #12
   11cd0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   11cd4:	ecb1 7a01 	vldmia	r1!, {s14}
   11cd8:	ecf5 7a01 	vldmia	r5!, {s15}
   11cdc:	ecf7 6a01 	vldmia	r7!, {s13}
   11ce0:	eeb4 7a46 	vcmp.f32	s14, s12
   11ce4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   11ce8:	bf16      	itet	ne
   11cea:	ee77 7ae6 	vsubne.f32	s15, s15, s13
   11cee:	eef7 7a00 	vmoveq.f32	s15, #112	; 0x3f800000  1.0
   11cf2:	ee77 7aa7 	vaddne.f32	s15, s15, s15
   11cf6:	428b      	cmp	r3, r1
   11cf8:	ece0 7a01 	vstmia	r0!, {s15}
   11cfc:	d1ea      	bne.n	11cd4 <bsec_ExpSmoothing_setCoeffFromBandwidth+0x6c>
   11cfe:	b007      	add	sp, #28
   11d00:	bdf0      	pop	{r4, r5, r6, r7, pc}
   11d02:	bf00      	nop
   11d04:	3fc90fdb 	.word	0x3fc90fdb

00011d08 <bsec_ExpSmoothingBsec_ExpSmoothingBsec>:
   11d08:	2200      	movs	r2, #0
   11d0a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   11d0e:	b410      	push	{r4}
   11d10:	2403      	movs	r4, #3
   11d12:	7604      	strb	r4, [r0, #24]
   11d14:	6001      	str	r1, [r0, #0]
   11d16:	6041      	str	r1, [r0, #4]
   11d18:	6081      	str	r1, [r0, #8]
   11d1a:	60c2      	str	r2, [r0, #12]
   11d1c:	6102      	str	r2, [r0, #16]
   11d1e:	6142      	str	r2, [r0, #20]
   11d20:	f85d 4b04 	ldr.w	r4, [sp], #4
   11d24:	4770      	bx	lr
   11d26:	bf00      	nop

00011d28 <bsec_b_ExpSmoothingBsec_ExpSmoothingBsec>:
   11d28:	b410      	push	{r4}
   11d2a:	2401      	movs	r4, #1
   11d2c:	2200      	movs	r2, #0
   11d2e:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
   11d32:	7204      	strb	r4, [r0, #8]
   11d34:	6001      	str	r1, [r0, #0]
   11d36:	6042      	str	r2, [r0, #4]
   11d38:	f85d 4b04 	ldr.w	r4, [sp], #4
   11d3c:	4770      	bx	lr
   11d3e:	bf00      	nop

00011d40 <bsec_applyScalarFunctionInPlace>:
   11d40:	b538      	push	{r3, r4, r5, lr}
   11d42:	4604      	mov	r4, r0
   11d44:	f100 050c 	add.w	r5, r0, #12
   11d48:	ed94 0a00 	vldr	s0, [r4]
   11d4c:	f01d fd70 	bl	2f830 <sqrtf>
   11d50:	eca4 0a01 	vstmia	r4!, {s0}
   11d54:	42ac      	cmp	r4, r5
   11d56:	d1f7      	bne.n	11d48 <bsec_applyScalarFunctionInPlace+0x8>
   11d58:	bd38      	pop	{r3, r4, r5, pc}
   11d5a:	bf00      	nop

00011d5c <bsec_sin>:
   11d5c:	b538      	push	{r3, r4, r5, lr}
   11d5e:	4604      	mov	r4, r0
   11d60:	f100 050c 	add.w	r5, r0, #12
   11d64:	ed94 0a00 	vldr	s0, [r4]
   11d68:	f01d fbce 	bl	2f508 <sinf>
   11d6c:	eca4 0a01 	vstmia	r4!, {s0}
   11d70:	42ac      	cmp	r4, r5
   11d72:	d1f7      	bne.n	11d64 <bsec_sin+0x8>
   11d74:	bd38      	pop	{r3, r4, r5, pc}
   11d76:	bf00      	nop

00011d78 <__aeabi_dcmpun>:
   11d78:	ea4f 0c41 	mov.w	ip, r1, lsl #1
   11d7c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   11d80:	d102      	bne.n	11d88 <__aeabi_dcmpun+0x10>
   11d82:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
   11d86:	d10a      	bne.n	11d9e <__aeabi_dcmpun+0x26>
   11d88:	ea4f 0c43 	mov.w	ip, r3, lsl #1
   11d8c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
   11d90:	d102      	bne.n	11d98 <__aeabi_dcmpun+0x20>
   11d92:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
   11d96:	d102      	bne.n	11d9e <__aeabi_dcmpun+0x26>
   11d98:	f04f 0000 	mov.w	r0, #0
   11d9c:	4770      	bx	lr
   11d9e:	f04f 0001 	mov.w	r0, #1
   11da2:	4770      	bx	lr

00011da4 <__aeabi_d2uiz>:
   11da4:	004a      	lsls	r2, r1, #1
   11da6:	d211      	bcs.n	11dcc <__aeabi_d2uiz+0x28>
   11da8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   11dac:	d211      	bcs.n	11dd2 <__aeabi_d2uiz+0x2e>
   11dae:	d50d      	bpl.n	11dcc <__aeabi_d2uiz+0x28>
   11db0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   11db4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   11db8:	d40e      	bmi.n	11dd8 <__aeabi_d2uiz+0x34>
   11dba:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   11dbe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   11dc2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   11dc6:	fa23 f002 	lsr.w	r0, r3, r2
   11dca:	4770      	bx	lr
   11dcc:	f04f 0000 	mov.w	r0, #0
   11dd0:	4770      	bx	lr
   11dd2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   11dd6:	d102      	bne.n	11dde <__aeabi_d2uiz+0x3a>
   11dd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   11ddc:	4770      	bx	lr
   11dde:	f04f 0000 	mov.w	r0, #0
   11de2:	4770      	bx	lr

00011de4 <__aeabi_frsub>:
   11de4:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   11de8:	e002      	b.n	11df0 <__addsf3>
   11dea:	bf00      	nop

00011dec <__aeabi_fsub>:
   11dec:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

00011df0 <__addsf3>:
   11df0:	0042      	lsls	r2, r0, #1
   11df2:	bf1f      	itttt	ne
   11df4:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   11df8:	ea92 0f03 	teqne	r2, r3
   11dfc:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   11e00:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   11e04:	d06a      	beq.n	11edc <__addsf3+0xec>
   11e06:	ea4f 6212 	mov.w	r2, r2, lsr #24
   11e0a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   11e0e:	bfc1      	itttt	gt
   11e10:	18d2      	addgt	r2, r2, r3
   11e12:	4041      	eorgt	r1, r0
   11e14:	4048      	eorgt	r0, r1
   11e16:	4041      	eorgt	r1, r0
   11e18:	bfb8      	it	lt
   11e1a:	425b      	neglt	r3, r3
   11e1c:	2b19      	cmp	r3, #25
   11e1e:	bf88      	it	hi
   11e20:	4770      	bxhi	lr
   11e22:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   11e26:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   11e2a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   11e2e:	bf18      	it	ne
   11e30:	4240      	negne	r0, r0
   11e32:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   11e36:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   11e3a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   11e3e:	bf18      	it	ne
   11e40:	4249      	negne	r1, r1
   11e42:	ea92 0f03 	teq	r2, r3
   11e46:	d03f      	beq.n	11ec8 <__addsf3+0xd8>
   11e48:	f1a2 0201 	sub.w	r2, r2, #1
   11e4c:	fa41 fc03 	asr.w	ip, r1, r3
   11e50:	eb10 000c 	adds.w	r0, r0, ip
   11e54:	f1c3 0320 	rsb	r3, r3, #32
   11e58:	fa01 f103 	lsl.w	r1, r1, r3
   11e5c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   11e60:	d502      	bpl.n	11e68 <__addsf3+0x78>
   11e62:	4249      	negs	r1, r1
   11e64:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   11e68:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   11e6c:	d313      	bcc.n	11e96 <__addsf3+0xa6>
   11e6e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   11e72:	d306      	bcc.n	11e82 <__addsf3+0x92>
   11e74:	0840      	lsrs	r0, r0, #1
   11e76:	ea4f 0131 	mov.w	r1, r1, rrx
   11e7a:	f102 0201 	add.w	r2, r2, #1
   11e7e:	2afe      	cmp	r2, #254	; 0xfe
   11e80:	d251      	bcs.n	11f26 <__addsf3+0x136>
   11e82:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   11e86:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   11e8a:	bf08      	it	eq
   11e8c:	f020 0001 	biceq.w	r0, r0, #1
   11e90:	ea40 0003 	orr.w	r0, r0, r3
   11e94:	4770      	bx	lr
   11e96:	0049      	lsls	r1, r1, #1
   11e98:	eb40 0000 	adc.w	r0, r0, r0
   11e9c:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   11ea0:	f1a2 0201 	sub.w	r2, r2, #1
   11ea4:	d1ed      	bne.n	11e82 <__addsf3+0x92>
   11ea6:	fab0 fc80 	clz	ip, r0
   11eaa:	f1ac 0c08 	sub.w	ip, ip, #8
   11eae:	ebb2 020c 	subs.w	r2, r2, ip
   11eb2:	fa00 f00c 	lsl.w	r0, r0, ip
   11eb6:	bfaa      	itet	ge
   11eb8:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   11ebc:	4252      	neglt	r2, r2
   11ebe:	4318      	orrge	r0, r3
   11ec0:	bfbc      	itt	lt
   11ec2:	40d0      	lsrlt	r0, r2
   11ec4:	4318      	orrlt	r0, r3
   11ec6:	4770      	bx	lr
   11ec8:	f092 0f00 	teq	r2, #0
   11ecc:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   11ed0:	bf06      	itte	eq
   11ed2:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   11ed6:	3201      	addeq	r2, #1
   11ed8:	3b01      	subne	r3, #1
   11eda:	e7b5      	b.n	11e48 <__addsf3+0x58>
   11edc:	ea4f 0341 	mov.w	r3, r1, lsl #1
   11ee0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   11ee4:	bf18      	it	ne
   11ee6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   11eea:	d021      	beq.n	11f30 <__addsf3+0x140>
   11eec:	ea92 0f03 	teq	r2, r3
   11ef0:	d004      	beq.n	11efc <__addsf3+0x10c>
   11ef2:	f092 0f00 	teq	r2, #0
   11ef6:	bf08      	it	eq
   11ef8:	4608      	moveq	r0, r1
   11efa:	4770      	bx	lr
   11efc:	ea90 0f01 	teq	r0, r1
   11f00:	bf1c      	itt	ne
   11f02:	2000      	movne	r0, #0
   11f04:	4770      	bxne	lr
   11f06:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   11f0a:	d104      	bne.n	11f16 <__addsf3+0x126>
   11f0c:	0040      	lsls	r0, r0, #1
   11f0e:	bf28      	it	cs
   11f10:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   11f14:	4770      	bx	lr
   11f16:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   11f1a:	bf3c      	itt	cc
   11f1c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   11f20:	4770      	bxcc	lr
   11f22:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   11f26:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   11f2a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   11f2e:	4770      	bx	lr
   11f30:	ea7f 6222 	mvns.w	r2, r2, asr #24
   11f34:	bf16      	itet	ne
   11f36:	4608      	movne	r0, r1
   11f38:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   11f3c:	4601      	movne	r1, r0
   11f3e:	0242      	lsls	r2, r0, #9
   11f40:	bf06      	itte	eq
   11f42:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   11f46:	ea90 0f01 	teqeq	r0, r1
   11f4a:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   11f4e:	4770      	bx	lr

00011f50 <__aeabi_ui2f>:
   11f50:	f04f 0300 	mov.w	r3, #0
   11f54:	e004      	b.n	11f60 <__aeabi_i2f+0x8>
   11f56:	bf00      	nop

00011f58 <__aeabi_i2f>:
   11f58:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   11f5c:	bf48      	it	mi
   11f5e:	4240      	negmi	r0, r0
   11f60:	ea5f 0c00 	movs.w	ip, r0
   11f64:	bf08      	it	eq
   11f66:	4770      	bxeq	lr
   11f68:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   11f6c:	4601      	mov	r1, r0
   11f6e:	f04f 0000 	mov.w	r0, #0
   11f72:	e01c      	b.n	11fae <__aeabi_l2f+0x2a>

00011f74 <__aeabi_ul2f>:
   11f74:	ea50 0201 	orrs.w	r2, r0, r1
   11f78:	bf08      	it	eq
   11f7a:	4770      	bxeq	lr
   11f7c:	f04f 0300 	mov.w	r3, #0
   11f80:	e00a      	b.n	11f98 <__aeabi_l2f+0x14>
   11f82:	bf00      	nop

00011f84 <__aeabi_l2f>:
   11f84:	ea50 0201 	orrs.w	r2, r0, r1
   11f88:	bf08      	it	eq
   11f8a:	4770      	bxeq	lr
   11f8c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   11f90:	d502      	bpl.n	11f98 <__aeabi_l2f+0x14>
   11f92:	4240      	negs	r0, r0
   11f94:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   11f98:	ea5f 0c01 	movs.w	ip, r1
   11f9c:	bf02      	ittt	eq
   11f9e:	4684      	moveq	ip, r0
   11fa0:	4601      	moveq	r1, r0
   11fa2:	2000      	moveq	r0, #0
   11fa4:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   11fa8:	bf08      	it	eq
   11faa:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   11fae:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   11fb2:	fabc f28c 	clz	r2, ip
   11fb6:	3a08      	subs	r2, #8
   11fb8:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   11fbc:	db10      	blt.n	11fe0 <__aeabi_l2f+0x5c>
   11fbe:	fa01 fc02 	lsl.w	ip, r1, r2
   11fc2:	4463      	add	r3, ip
   11fc4:	fa00 fc02 	lsl.w	ip, r0, r2
   11fc8:	f1c2 0220 	rsb	r2, r2, #32
   11fcc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   11fd0:	fa20 f202 	lsr.w	r2, r0, r2
   11fd4:	eb43 0002 	adc.w	r0, r3, r2
   11fd8:	bf08      	it	eq
   11fda:	f020 0001 	biceq.w	r0, r0, #1
   11fde:	4770      	bx	lr
   11fe0:	f102 0220 	add.w	r2, r2, #32
   11fe4:	fa01 fc02 	lsl.w	ip, r1, r2
   11fe8:	f1c2 0220 	rsb	r2, r2, #32
   11fec:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   11ff0:	fa21 f202 	lsr.w	r2, r1, r2
   11ff4:	eb43 0002 	adc.w	r0, r3, r2
   11ff8:	bf08      	it	eq
   11ffa:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   11ffe:	4770      	bx	lr

00012000 <__aeabi_d2lz>:
   12000:	b538      	push	{r3, r4, r5, lr}
   12002:	2200      	movs	r2, #0
   12004:	2300      	movs	r3, #0
   12006:	4604      	mov	r4, r0
   12008:	460d      	mov	r5, r1
   1200a:	f7fb fac1 	bl	d590 <__aeabi_dcmplt>
   1200e:	b928      	cbnz	r0, 1201c <__aeabi_d2lz+0x1c>
   12010:	4620      	mov	r0, r4
   12012:	4629      	mov	r1, r5
   12014:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   12018:	f000 b80a 	b.w	12030 <__aeabi_d2ulz>
   1201c:	4620      	mov	r0, r4
   1201e:	f105 4100 	add.w	r1, r5, #2147483648	; 0x80000000
   12022:	f000 f805 	bl	12030 <__aeabi_d2ulz>
   12026:	4240      	negs	r0, r0
   12028:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1202c:	bd38      	pop	{r3, r4, r5, pc}
   1202e:	bf00      	nop

00012030 <__aeabi_d2ulz>:
   12030:	b5d0      	push	{r4, r6, r7, lr}
   12032:	2200      	movs	r2, #0
   12034:	4b0b      	ldr	r3, [pc, #44]	; (12064 <__aeabi_d2ulz+0x34>)
   12036:	4606      	mov	r6, r0
   12038:	460f      	mov	r7, r1
   1203a:	f7fb f837 	bl	d0ac <__aeabi_dmul>
   1203e:	f7ff feb1 	bl	11da4 <__aeabi_d2uiz>
   12042:	4604      	mov	r4, r0
   12044:	f7fa ffb8 	bl	cfb8 <__aeabi_ui2d>
   12048:	2200      	movs	r2, #0
   1204a:	4b07      	ldr	r3, [pc, #28]	; (12068 <__aeabi_d2ulz+0x38>)
   1204c:	f7fb f82e 	bl	d0ac <__aeabi_dmul>
   12050:	4602      	mov	r2, r0
   12052:	460b      	mov	r3, r1
   12054:	4630      	mov	r0, r6
   12056:	4639      	mov	r1, r7
   12058:	f7fa fe70 	bl	cd3c <__aeabi_dsub>
   1205c:	f7ff fea2 	bl	11da4 <__aeabi_d2uiz>
   12060:	4621      	mov	r1, r4
   12062:	bdd0      	pop	{r4, r6, r7, pc}
   12064:	3df00000 	.word	0x3df00000
   12068:	41f00000 	.word	0x41f00000

0001206c <strcmp>:
   1206c:	f810 2b01 	ldrb.w	r2, [r0], #1
   12070:	f811 3b01 	ldrb.w	r3, [r1], #1
   12074:	2a01      	cmp	r2, #1
   12076:	bf28      	it	cs
   12078:	429a      	cmpcs	r2, r3
   1207a:	d0f7      	beq.n	1206c <strcmp>
   1207c:	1ad0      	subs	r0, r2, r3
   1207e:	4770      	bx	lr

00012080 <strlen>:
   12080:	4603      	mov	r3, r0
   12082:	f813 2b01 	ldrb.w	r2, [r3], #1
   12086:	2a00      	cmp	r2, #0
   12088:	d1fb      	bne.n	12082 <strlen+0x2>
   1208a:	1a18      	subs	r0, r3, r0
   1208c:	3801      	subs	r0, #1
   1208e:	4770      	bx	lr

00012090 <app_gc_iot>:
}


/**@brief Main Processing Thread */
void app_gc_iot(void)
{
   12090:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12094:	ed2d 8b02 	vpush	{d8}
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   12098:	4dc7      	ldr	r5, [pc, #796]	; (123b8 <app_gc_iot+0x328>)
    struct k_mbox_msg env_d_recv_msg;

    /* Block until time avail */
    while (!got_ntp) 
    {   
        LOG_INF("Waiting on Modem Time\n");
   1209a:	4bc8      	ldr	r3, [pc, #800]	; (123bc <app_gc_iot+0x32c>)
{
   1209c:	b0f1      	sub	sp, #452	; 0x1c4
        LOG_INF("Waiting on Modem Time\n");
   1209e:	1aed      	subs	r5, r5, r3
   120a0:	f3c5 05c9 	ubfx	r5, r5, #3, #10
	if (z_syscall_trap()) {
		return (s32_t) arch_syscall_invoke1(*(uintptr_t *)&timeout, K_SYSCALL_K_SLEEP);
	}
#endif
	compiler_barrier();
	return z_impl_k_sleep(timeout);
   120a4:	4bc6      	ldr	r3, [pc, #792]	; (123c0 <app_gc_iot+0x330>)
   120a6:	4ac7      	ldr	r2, [pc, #796]	; (123c4 <app_gc_iot+0x334>)
    while (!got_ntp) 
   120a8:	7819      	ldrb	r1, [r3, #0]
   120aa:	2900      	cmp	r1, #0
   120ac:	f000 8266 	beq.w	1257c <app_gc_iot+0x4ec>
            jQualCal = cJSON_CreateString("no");
        } else {
           jQualCal = cJSON_CreateString("yes"); 
        }
        
        jSampSz = cJSON_CreateNumber(DATA_ARRAY_SIZE);
   120b0:	ed9f 8bbd 	vldr	d8, [pc, #756]	; 123a8 <app_gc_iot+0x318>
        env_d_recv_msg.size = sizeof(pac_data);
   120b4:	2340      	movs	r3, #64	; 0x40
   120b6:	f44f 7280 	mov.w	r2, #256	; 0x100
   120ba:	e9cd 3220 	strd	r3, r2, [sp, #128]	; 0x80
        env_d_recv_msg.rx_source_thread = K_ANY; //TODO: Get producer thread id
   120be:	2300      	movs	r3, #0
   120c0:	9326      	str	r3, [sp, #152]	; 0x98
        LOG_DBG("App thread waiting for data from producer\n");
   120c2:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   120c6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
   120ca:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   120ce:	f043 0304 	orr.w	r3, r3, #4
   120d2:	f363 0207 	bfi	r2, r3, #0, #8
   120d6:	b293      	uxth	r3, r2
   120d8:	f365 138f 	bfi	r3, r5, #6, #10
   120dc:	b298      	uxth	r0, r3
   120de:	4aba      	ldr	r2, [pc, #744]	; (123c8 <app_gc_iot+0x338>)
   120e0:	49ba      	ldr	r1, [pc, #744]	; (123cc <app_gc_iot+0x33c>)
   120e2:	f8ad 3004 	strh.w	r3, [sp, #4]
   120e6:	f021 fd87 	bl	33bf8 <log_string_sync>
        k_mbox_get(&env_d_mailbox, &env_d_recv_msg, &pac_data, K_FOREVER);
   120ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   120ee:	aa2a      	add	r2, sp, #168	; 0xa8
   120f0:	a91f      	add	r1, sp, #124	; 0x7c
   120f2:	48b7      	ldr	r0, [pc, #732]	; (123d0 <app_gc_iot+0x340>)
   120f4:	f019 ff5a 	bl	2bfac <k_mbox_get>
        if (env_d_recv_msg.info != env_d_recv_msg.size) {
   120f8:	e9dd 3220 	ldrd	r3, r2, [sp, #128]	; 0x80
   120fc:	429a      	cmp	r2, r3
   120fe:	f000 824e 	beq.w	1259e <app_gc_iot+0x50e>
            LOG_INF("Sender tried to send [%d] bytes\n", env_d_recv_msg.info);
   12102:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   12106:	f8bd 1008 	ldrh.w	r1, [sp, #8]
   1210a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   1210e:	f043 0303 	orr.w	r3, r3, #3
   12112:	f363 0107 	bfi	r1, r3, #0, #8
   12116:	b28b      	uxth	r3, r1
   12118:	f365 138f 	bfi	r3, r5, #6, #10
   1211c:	49ad      	ldr	r1, [pc, #692]	; (123d4 <app_gc_iot+0x344>)
   1211e:	b298      	uxth	r0, r3
   12120:	f8ad 3008 	strh.w	r3, [sp, #8]
   12124:	f021 fd68 	bl	33bf8 <log_string_sync>
        get_modem_info(&info);
   12128:	a83a      	add	r0, sp, #232	; 0xe8
   1212a:	f002 fff5 	bl	15118 <get_modem_info>
        printk("CID: [%s]\n", info.cid);
   1212e:	a93a      	add	r1, sp, #232	; 0xe8
   12130:	48a9      	ldr	r0, [pc, #676]	; (123d8 <app_gc_iot+0x348>)
   12132:	f021 fa49 	bl	335c8 <printk>
        printk("TAC: [%s]\n", info.tac);
   12136:	f50d 7183 	add.w	r1, sp, #262	; 0x106
   1213a:	48a8      	ldr	r0, [pc, #672]	; (123dc <app_gc_iot+0x34c>)
   1213c:	f021 fa44 	bl	335c8 <printk>
        printk("RSSI: [%s]\n", info.rssi);
   12140:	a949      	add	r1, sp, #292	; 0x124
   12142:	48a7      	ldr	r0, [pc, #668]	; (123e0 <app_gc_iot+0x350>)
   12144:	f021 fa40 	bl	335c8 <printk>
        printk("APN: [%s]\n", info.apn);
   12148:	f50d 71a1 	add.w	r1, sp, #322	; 0x142
   1214c:	48a5      	ldr	r0, [pc, #660]	; (123e4 <app_gc_iot+0x354>)
   1214e:	f021 fa3b 	bl	335c8 <printk>
        printk("FWV: [%s]\n", info.fwv);
   12152:	f50d 71bf 	add.w	r1, sp, #382	; 0x17e
   12156:	48a4      	ldr	r0, [pc, #656]	; (123e8 <app_gc_iot+0x358>)
   12158:	f021 fa36 	bl	335c8 <printk>
        LOG_INF("Voltage: [%d]\n", info.vltg);
   1215c:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   12160:	f043 0303 	orr.w	r3, r3, #3
   12164:	f363 0607 	bfi	r6, r3, #0, #8
   12168:	f365 168f 	bfi	r6, r5, #6, #10
   1216c:	f8bd 21ba 	ldrh.w	r2, [sp, #442]	; 0x1ba
   12170:	499e      	ldr	r1, [pc, #632]	; (123ec <app_gc_iot+0x35c>)
   12172:	4630      	mov	r0, r6
   12174:	f021 fd40 	bl	33bf8 <log_string_sync>
        LOG_INF("Temp: [%d]\n", info.temp);
   12178:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   1217c:	f043 0303 	orr.w	r3, r3, #3
   12180:	f363 0707 	bfi	r7, r3, #0, #8
   12184:	f365 178f 	bfi	r7, r5, #6, #10
   12188:	f8bd 21bc 	ldrh.w	r2, [sp, #444]	; 0x1bc
   1218c:	4998      	ldr	r1, [pc, #608]	; (123f0 <app_gc_iot+0x360>)
   1218e:	4638      	mov	r0, r7
   12190:	f021 fd32 	bl	33bf8 <log_string_sync>
        cJSON * envSensObj = cJSON_CreateObject();
   12194:	f020 fe3d 	bl	32e12 <cJSON_CreateObject>
   12198:	4604      	mov	r4, r0
        jTempMax = cJSON_CreateNumber((s32_t)pac_data.ag_temp.max);
   1219a:	982a      	ldr	r0, [sp, #168]	; 0xa8
   1219c:	f7fa ff1c 	bl	cfd8 <__aeabi_i2d>
   121a0:	ec41 0b10 	vmov	d0, r0, r1
   121a4:	f020 fe12 	bl	32dcc <cJSON_CreateNumber>
   121a8:	9006      	str	r0, [sp, #24]
        jTempMin = cJSON_CreateNumber((s32_t)pac_data.ag_temp.min);
   121aa:	982b      	ldr	r0, [sp, #172]	; 0xac
   121ac:	f7fa ff14 	bl	cfd8 <__aeabi_i2d>
   121b0:	ec41 0b10 	vmov	d0, r0, r1
   121b4:	f020 fe0a 	bl	32dcc <cJSON_CreateNumber>
   121b8:	9007      	str	r0, [sp, #28]
        jTempAvg = cJSON_CreateNumber((s32_t)pac_data.ag_temp.avg);
   121ba:	982c      	ldr	r0, [sp, #176]	; 0xb0
   121bc:	f7fa ff0c 	bl	cfd8 <__aeabi_i2d>
   121c0:	ec41 0b10 	vmov	d0, r0, r1
   121c4:	f020 fe02 	bl	32dcc <cJSON_CreateNumber>
   121c8:	9008      	str	r0, [sp, #32]
        jHumiMax = cJSON_CreateNumber((s32_t)pac_data.ag_humi.max);
   121ca:	982e      	ldr	r0, [sp, #184]	; 0xb8
   121cc:	f7fa ff04 	bl	cfd8 <__aeabi_i2d>
   121d0:	ec41 0b10 	vmov	d0, r0, r1
   121d4:	f020 fdfa 	bl	32dcc <cJSON_CreateNumber>
   121d8:	9009      	str	r0, [sp, #36]	; 0x24
        jHumiMin = cJSON_CreateNumber((s32_t)pac_data.ag_humi.min);
   121da:	982f      	ldr	r0, [sp, #188]	; 0xbc
   121dc:	f7fa fefc 	bl	cfd8 <__aeabi_i2d>
   121e0:	ec41 0b10 	vmov	d0, r0, r1
   121e4:	f020 fdf2 	bl	32dcc <cJSON_CreateNumber>
   121e8:	900a      	str	r0, [sp, #40]	; 0x28
        jHumiAvg = cJSON_CreateNumber((s32_t)pac_data.ag_humi.avg);
   121ea:	9830      	ldr	r0, [sp, #192]	; 0xc0
   121ec:	f7fa fef4 	bl	cfd8 <__aeabi_i2d>
   121f0:	ec41 0b10 	vmov	d0, r0, r1
   121f4:	f020 fdea 	bl	32dcc <cJSON_CreateNumber>
   121f8:	900b      	str	r0, [sp, #44]	; 0x2c
        jPresMax = cJSON_CreateNumber((s32_t)pac_data.ag_pres.max);
   121fa:	9832      	ldr	r0, [sp, #200]	; 0xc8
   121fc:	f7fa feec 	bl	cfd8 <__aeabi_i2d>
   12200:	ec41 0b10 	vmov	d0, r0, r1
   12204:	f020 fde2 	bl	32dcc <cJSON_CreateNumber>
   12208:	900c      	str	r0, [sp, #48]	; 0x30
        jPresMin = cJSON_CreateNumber((s32_t)pac_data.ag_pres.min);
   1220a:	9833      	ldr	r0, [sp, #204]	; 0xcc
   1220c:	f7fa fee4 	bl	cfd8 <__aeabi_i2d>
   12210:	ec41 0b10 	vmov	d0, r0, r1
   12214:	f020 fdda 	bl	32dcc <cJSON_CreateNumber>
   12218:	900d      	str	r0, [sp, #52]	; 0x34
        jPresAvg = cJSON_CreateNumber((s32_t)pac_data.ag_pres.avg);
   1221a:	9834      	ldr	r0, [sp, #208]	; 0xd0
   1221c:	f7fa fedc 	bl	cfd8 <__aeabi_i2d>
   12220:	ec41 0b10 	vmov	d0, r0, r1
   12224:	f020 fdd2 	bl	32dcc <cJSON_CreateNumber>
   12228:	900e      	str	r0, [sp, #56]	; 0x38
        jQualMax = cJSON_CreateNumber((s32_t)pac_data.ag_qual.max);
   1222a:	9836      	ldr	r0, [sp, #216]	; 0xd8
   1222c:	f7fa fed4 	bl	cfd8 <__aeabi_i2d>
   12230:	ec41 0b10 	vmov	d0, r0, r1
   12234:	f020 fdca 	bl	32dcc <cJSON_CreateNumber>
   12238:	900f      	str	r0, [sp, #60]	; 0x3c
        jQualMin = cJSON_CreateNumber((s32_t)pac_data.ag_qual.min);
   1223a:	9837      	ldr	r0, [sp, #220]	; 0xdc
   1223c:	f7fa fecc 	bl	cfd8 <__aeabi_i2d>
   12240:	ec41 0b10 	vmov	d0, r0, r1
   12244:	f020 fdc2 	bl	32dcc <cJSON_CreateNumber>
   12248:	9010      	str	r0, [sp, #64]	; 0x40
        jQualAvg = cJSON_CreateNumber((s32_t)pac_data.ag_qual.avg);
   1224a:	9838      	ldr	r0, [sp, #224]	; 0xe0
   1224c:	f7fa fec4 	bl	cfd8 <__aeabi_i2d>
   12250:	ec41 0b10 	vmov	d0, r0, r1
   12254:	f020 fdba 	bl	32dcc <cJSON_CreateNumber>
        if (pac_data.ag_qual.avg == EXCLUDE) {
   12258:	f240 33e7 	movw	r3, #999	; 0x3e7
   1225c:	9a38      	ldr	r2, [sp, #224]	; 0xe0
        jQualAvg = cJSON_CreateNumber((s32_t)pac_data.ag_qual.avg);
   1225e:	9011      	str	r0, [sp, #68]	; 0x44
        if (pac_data.ag_qual.avg == EXCLUDE) {
   12260:	429a      	cmp	r2, r3
            jQualCal = cJSON_CreateString("no");
   12262:	bf0c      	ite	eq
   12264:	4863      	ldreq	r0, [pc, #396]	; (123f4 <app_gc_iot+0x364>)
           jQualCal = cJSON_CreateString("yes"); 
   12266:	4864      	ldrne	r0, [pc, #400]	; (123f8 <app_gc_iot+0x368>)
   12268:	f020 fdc5 	bl	32df6 <cJSON_CreateString>
        jSampSz = cJSON_CreateNumber(DATA_ARRAY_SIZE);
   1226c:	eeb0 0a48 	vmov.f32	s0, s16
   12270:	eef0 0a68 	vmov.f32	s1, s17
   12274:	901d      	str	r0, [sp, #116]	; 0x74
   12276:	f020 fda9 	bl	32dcc <cJSON_CreateNumber>
        jSampFrq = cJSON_CreateNumber(SAMP_FREQ);
   1227a:	ed9f 0b4d 	vldr	d0, [pc, #308]	; 123b0 <app_gc_iot+0x320>
        jSampSz = cJSON_CreateNumber(DATA_ARRAY_SIZE);
   1227e:	9012      	str	r0, [sp, #72]	; 0x48
        jSampFrq = cJSON_CreateNumber(SAMP_FREQ);
   12280:	f020 fda4 	bl	32dcc <cJSON_CreateNumber>
   12284:	9013      	str	r0, [sp, #76]	; 0x4c
        jQualCnt = cJSON_CreateNumber((u32_t)pac_data.ag_pres.cnt);
   12286:	9835      	ldr	r0, [sp, #212]	; 0xd4
   12288:	f7fa fe96 	bl	cfb8 <__aeabi_ui2d>
   1228c:	ec41 0b10 	vmov	d0, r0, r1
   12290:	f020 fd9c 	bl	32dcc <cJSON_CreateNumber>
   12294:	9014      	str	r0, [sp, #80]	; 0x50

        jCid = cJSON_CreateString((const char*)info.cid);
   12296:	a83a      	add	r0, sp, #232	; 0xe8
   12298:	f020 fdad 	bl	32df6 <cJSON_CreateString>
   1229c:	9015      	str	r0, [sp, #84]	; 0x54
        jTac = cJSON_CreateString((const char*)info.tac);
   1229e:	f50d 7083 	add.w	r0, sp, #262	; 0x106
   122a2:	f020 fda8 	bl	32df6 <cJSON_CreateString>
   122a6:	9016      	str	r0, [sp, #88]	; 0x58
        jRssi = cJSON_CreateString((const char*)info.rssi);
   122a8:	a849      	add	r0, sp, #292	; 0x124
   122aa:	f020 fda4 	bl	32df6 <cJSON_CreateString>
   122ae:	9017      	str	r0, [sp, #92]	; 0x5c
        jApn = cJSON_CreateString((const char*)info.apn);
   122b0:	f50d 70a1 	add.w	r0, sp, #322	; 0x142
   122b4:	f020 fd9f 	bl	32df6 <cJSON_CreateString>
   122b8:	9018      	str	r0, [sp, #96]	; 0x60
        jFwv = cJSON_CreateString((const char*)info.fwv);
   122ba:	f50d 70bf 	add.w	r0, sp, #382	; 0x17e
   122be:	f020 fd9a 	bl	32df6 <cJSON_CreateString>
   122c2:	9019      	str	r0, [sp, #100]	; 0x64
        jVltg = cJSON_CreateNumber((u16_t)info.vltg);
   122c4:	f8bd 01ba 	ldrh.w	r0, [sp, #442]	; 0x1ba
   122c8:	f7fa fe76 	bl	cfb8 <__aeabi_ui2d>
   122cc:	ec41 0b10 	vmov	d0, r0, r1
   122d0:	f020 fd7c 	bl	32dcc <cJSON_CreateNumber>
   122d4:	901a      	str	r0, [sp, #104]	; 0x68
        jTemp = cJSON_CreateNumber((u16_t)info.temp);
   122d6:	f8bd 01bc 	ldrh.w	r0, [sp, #444]	; 0x1bc
   122da:	f7fa fe6d 	bl	cfb8 <__aeabi_ui2d>
   122de:	ec41 0b10 	vmov	d0, r0, r1
   122e2:	f020 fd73 	bl	32dcc <cJSON_CreateNumber>
   122e6:	901b      	str	r0, [sp, #108]	; 0x6c

        jDvFwv = cJSON_CreateString((const char*)device_fw_ver);
   122e8:	4844      	ldr	r0, [pc, #272]	; (123fc <app_gc_iot+0x36c>)
   122ea:	f020 fd84 	bl	32df6 <cJSON_CreateString>

        /* Add cJSON items to object */
        cJSON_AddItemToObject(envSensObj, jTempMaxString, jTempMax);
   122ee:	9a06      	ldr	r2, [sp, #24]
        jDvFwv = cJSON_CreateString((const char*)device_fw_ver);
   122f0:	901c      	str	r0, [sp, #112]	; 0x70
        cJSON_AddItemToObject(envSensObj, jTempMaxString, jTempMax);
   122f2:	4943      	ldr	r1, [pc, #268]	; (12400 <app_gc_iot+0x370>)
   122f4:	4620      	mov	r0, r4
   122f6:	f004 fe9f 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jHumiMaxString, jHumiMax);
   122fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
   122fc:	4941      	ldr	r1, [pc, #260]	; (12404 <app_gc_iot+0x374>)
   122fe:	4620      	mov	r0, r4
   12300:	f004 fe9a 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jPresMaxString, jPresMax);
   12304:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   12306:	4940      	ldr	r1, [pc, #256]	; (12408 <app_gc_iot+0x378>)
   12308:	4620      	mov	r0, r4
   1230a:	f004 fe95 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jQualMaxString, jQualMax);
   1230e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   12310:	493e      	ldr	r1, [pc, #248]	; (1240c <app_gc_iot+0x37c>)
   12312:	4620      	mov	r0, r4
   12314:	f004 fe90 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jTempMinString, jTempMin);
   12318:	9a07      	ldr	r2, [sp, #28]
   1231a:	493d      	ldr	r1, [pc, #244]	; (12410 <app_gc_iot+0x380>)
   1231c:	4620      	mov	r0, r4
   1231e:	f004 fe8b 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jHumiMinString, jHumiMin);
   12322:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   12324:	493b      	ldr	r1, [pc, #236]	; (12414 <app_gc_iot+0x384>)
   12326:	4620      	mov	r0, r4
   12328:	f004 fe86 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jPresMinString, jPresMin);
   1232c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
   1232e:	493a      	ldr	r1, [pc, #232]	; (12418 <app_gc_iot+0x388>)
   12330:	4620      	mov	r0, r4
   12332:	f004 fe81 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jQualMinString, jQualMin);
   12336:	9a10      	ldr	r2, [sp, #64]	; 0x40
   12338:	4938      	ldr	r1, [pc, #224]	; (1241c <app_gc_iot+0x38c>)
   1233a:	4620      	mov	r0, r4
   1233c:	f004 fe7c 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jTempAvgString, jTempAvg);
   12340:	9a08      	ldr	r2, [sp, #32]
   12342:	4937      	ldr	r1, [pc, #220]	; (12420 <app_gc_iot+0x390>)
   12344:	4620      	mov	r0, r4
   12346:	f004 fe77 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jHumiAvgString, jHumiAvg);
   1234a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   1234c:	4935      	ldr	r1, [pc, #212]	; (12424 <app_gc_iot+0x394>)
   1234e:	4620      	mov	r0, r4
   12350:	f004 fe72 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jPresAvgString, jPresAvg);
   12354:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   12356:	4934      	ldr	r1, [pc, #208]	; (12428 <app_gc_iot+0x398>)
   12358:	4620      	mov	r0, r4
   1235a:	f004 fe6d 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jQualAvgString, jQualAvg);
   1235e:	9a11      	ldr	r2, [sp, #68]	; 0x44
   12360:	4932      	ldr	r1, [pc, #200]	; (1242c <app_gc_iot+0x39c>)
   12362:	4620      	mov	r0, r4
   12364:	f004 fe68 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jSampSzString, jSampSz);
   12368:	9a12      	ldr	r2, [sp, #72]	; 0x48
   1236a:	4931      	ldr	r1, [pc, #196]	; (12430 <app_gc_iot+0x3a0>)
   1236c:	4620      	mov	r0, r4
   1236e:	f004 fe63 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jSampFrqString, jSampFrq);
   12372:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   12374:	492f      	ldr	r1, [pc, #188]	; (12434 <app_gc_iot+0x3a4>)
   12376:	4620      	mov	r0, r4
   12378:	f004 fe5e 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jCidString, jCid);
   1237c:	9a15      	ldr	r2, [sp, #84]	; 0x54
   1237e:	492e      	ldr	r1, [pc, #184]	; (12438 <app_gc_iot+0x3a8>)
   12380:	4620      	mov	r0, r4
   12382:	f004 fe59 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jTacString, jTac);
   12386:	9a16      	ldr	r2, [sp, #88]	; 0x58
   12388:	492c      	ldr	r1, [pc, #176]	; (1243c <app_gc_iot+0x3ac>)
   1238a:	4620      	mov	r0, r4
   1238c:	f004 fe54 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jRssiString, jRssi);
   12390:	9a17      	ldr	r2, [sp, #92]	; 0x5c
   12392:	492b      	ldr	r1, [pc, #172]	; (12440 <app_gc_iot+0x3b0>)
   12394:	4620      	mov	r0, r4
   12396:	f004 fe4f 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jApnString, jApn);
   1239a:	9a18      	ldr	r2, [sp, #96]	; 0x60
   1239c:	4929      	ldr	r1, [pc, #164]	; (12444 <app_gc_iot+0x3b4>)
   1239e:	4620      	mov	r0, r4
   123a0:	f004 fe4a 	bl	17038 <cJSON_AddItemToObject>
   123a4:	e050      	b.n	12448 <app_gc_iot+0x3b8>
   123a6:	bf00      	nop
   123a8:	00000000 	.word	0x00000000
   123ac:	406e0000 	.word	0x406e0000
   123b0:	00000000 	.word	0x00000000
   123b4:	40408000 	.word	0x40408000
   123b8:	00039fa8 	.word	0x00039fa8
   123bc:	00039f60 	.word	0x00039f60
   123c0:	20027622 	.word	0x20027622
   123c4:	0003b44c 	.word	0x0003b44c
   123c8:	0003b441 	.word	0x0003b441
   123cc:	0003b463 	.word	0x0003b463
   123d0:	200210bc 	.word	0x200210bc
   123d4:	0003b492 	.word	0x0003b492
   123d8:	0003b4c4 	.word	0x0003b4c4
   123dc:	0003b4cf 	.word	0x0003b4cf
   123e0:	0003b4da 	.word	0x0003b4da
   123e4:	0003b4e6 	.word	0x0003b4e6
   123e8:	0003b4f1 	.word	0x0003b4f1
   123ec:	0003b4fc 	.word	0x0003b4fc
   123f0:	0003b50b 	.word	0x0003b50b
   123f4:	0003f4c8 	.word	0x0003f4c8
   123f8:	0003b517 	.word	0x0003b517
   123fc:	0003b51b 	.word	0x0003b51b
   12400:	0003b526 	.word	0x0003b526
   12404:	0003b52e 	.word	0x0003b52e
   12408:	0003b536 	.word	0x0003b536
   1240c:	0003b53e 	.word	0x0003b53e
   12410:	0003b546 	.word	0x0003b546
   12414:	0003b54e 	.word	0x0003b54e
   12418:	0003b556 	.word	0x0003b556
   1241c:	0003b55e 	.word	0x0003b55e
   12420:	0003b566 	.word	0x0003b566
   12424:	0003b56e 	.word	0x0003b56e
   12428:	0003b576 	.word	0x0003b576
   1242c:	0003b57e 	.word	0x0003b57e
   12430:	0003b586 	.word	0x0003b586
   12434:	0003b58f 	.word	0x0003b58f
   12438:	0003ef4d 	.word	0x0003ef4d
   1243c:	0003b599 	.word	0x0003b599
   12440:	0003b59d 	.word	0x0003b59d
   12444:	0003b5a2 	.word	0x0003b5a2
        cJSON_AddItemToObject(envSensObj, jFwvString, jFwv);
   12448:	9a19      	ldr	r2, [sp, #100]	; 0x64
   1244a:	4960      	ldr	r1, [pc, #384]	; (125cc <app_gc_iot+0x53c>)
   1244c:	4620      	mov	r0, r4
   1244e:	f004 fdf3 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jVltgString, jVltg);
   12452:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   12454:	495e      	ldr	r1, [pc, #376]	; (125d0 <app_gc_iot+0x540>)
   12456:	4620      	mov	r0, r4
   12458:	f004 fdee 	bl	17038 <cJSON_AddItemToObject>
        cJSON_AddItemToObject(envSensObj, jTempString, jTemp);
   1245c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   1245e:	495d      	ldr	r1, [pc, #372]	; (125d4 <app_gc_iot+0x544>)
   12460:	4620      	mov	r0, r4
   12462:	f004 fde9 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jQualCntString, jQualCnt);
   12466:	9a14      	ldr	r2, [sp, #80]	; 0x50
   12468:	495b      	ldr	r1, [pc, #364]	; (125d8 <app_gc_iot+0x548>)
   1246a:	4620      	mov	r0, r4
   1246c:	f004 fde4 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jQualCalString, jQualCal);
   12470:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   12472:	495a      	ldr	r1, [pc, #360]	; (125dc <app_gc_iot+0x54c>)
   12474:	461a      	mov	r2, r3
   12476:	4620      	mov	r0, r4
   12478:	f004 fdde 	bl	17038 <cJSON_AddItemToObject>

        cJSON_AddItemToObject(envSensObj, jDevFwvString, jDvFwv);
   1247c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   1247e:	4958      	ldr	r1, [pc, #352]	; (125e0 <app_gc_iot+0x550>)
   12480:	4620      	mov	r0, r4
   12482:	f004 fdd9 	bl	17038 <cJSON_AddItemToObject>

        /* Create JSON string from object */
        JSONEnvString = cJSON_Print(envSensObj);
   12486:	4620      	mov	r0, r4
   12488:	f020 fc8f 	bl	32daa <cJSON_Print>
        if (JSONEnvString == NULL) {
   1248c:	4603      	mov	r3, r0
   1248e:	b970      	cbnz	r0, 124ae <app_gc_iot+0x41e>
            LOG_DBG("Failed to print envSensObj\n");
   12490:	f028 023f 	bic.w	r2, r8, #63	; 0x3f
   12494:	f042 0204 	orr.w	r2, r2, #4
   12498:	f362 0807 	bfi	r8, r2, #0, #8
   1249c:	f365 188f 	bfi	r8, r5, #6, #10
   124a0:	9006      	str	r0, [sp, #24]
   124a2:	4a50      	ldr	r2, [pc, #320]	; (125e4 <app_gc_iot+0x554>)
   124a4:	4950      	ldr	r1, [pc, #320]	; (125e8 <app_gc_iot+0x558>)
   124a6:	4640      	mov	r0, r8
   124a8:	f021 fba6 	bl	33bf8 <log_string_sync>
   124ac:	9b06      	ldr	r3, [sp, #24]
        }

        /* Send JSON data */
        LOG_INF("Sending JSON data\n");
   124ae:	f029 023f 	bic.w	r2, r9, #63	; 0x3f
   124b2:	f042 0203 	orr.w	r2, r2, #3
   124b6:	f362 0907 	bfi	r9, r2, #0, #8
   124ba:	f365 198f 	bfi	r9, r5, #6, #10
   124be:	494b      	ldr	r1, [pc, #300]	; (125ec <app_gc_iot+0x55c>)
   124c0:	4648      	mov	r0, r9
   124c2:	9306      	str	r3, [sp, #24]
   124c4:	f021 fb98 	bl	33bf8 <log_string_sync>
	    int pub_success = gcloud_publish(JSONEnvString, strlens(JSONEnvString), MQTT_QOS_0_AT_MOST_ONCE);
   124c8:	9b06      	ldr	r3, [sp, #24]
   124ca:	2b00      	cmp	r3, #0
   124cc:	d07b      	beq.n	125c6 <app_gc_iot+0x536>
   124ce:	4618      	mov	r0, r3
   124d0:	f7ff fdd6 	bl	12080 <strlen>
   124d4:	4601      	mov	r1, r0
   124d6:	9b06      	ldr	r3, [sp, #24]
   124d8:	4618      	mov	r0, r3
   124da:	2200      	movs	r2, #0
   124dc:	f003 f8de 	bl	1569c <gcloud_publish>
        LOG_INF("Sent JSON data with code: [%d]\n", pub_success);
   124e0:	f02a 023f 	bic.w	r2, sl, #63	; 0x3f
   124e4:	f042 0203 	orr.w	r2, r2, #3
   124e8:	f362 0a07 	bfi	sl, r2, #0, #8
   124ec:	f365 1a8f 	bfi	sl, r5, #6, #10
   124f0:	4602      	mov	r2, r0
   124f2:	9006      	str	r0, [sp, #24]
   124f4:	493e      	ldr	r1, [pc, #248]	; (125f0 <app_gc_iot+0x560>)
   124f6:	4650      	mov	r0, sl
   124f8:	f021 fb7e 	bl	33bf8 <log_string_sync>
        if (pub_success != 0) {
   124fc:	9b06      	ldr	r3, [sp, #24]
   124fe:	b15b      	cbz	r3, 12518 <app_gc_iot+0x488>
            LOG_INF("JSON data Publish failed\n");
   12500:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
   12504:	f043 0303 	orr.w	r3, r3, #3
   12508:	f363 0b07 	bfi	fp, r3, #0, #8
   1250c:	f365 1b8f 	bfi	fp, r5, #6, #10
   12510:	4938      	ldr	r1, [pc, #224]	; (125f4 <app_gc_iot+0x564>)
   12512:	4658      	mov	r0, fp
   12514:	f021 fb70 	bl	33bf8 <log_string_sync>
        }

        /* Cleanup JSON obj - release memory */
        cJSON_Delete(envSensObj);
   12518:	4620      	mov	r0, r4
   1251a:	f004 fd35 	bl	16f88 <cJSON_Delete>

        /* Reboot */
        LOG_INF("Rebooting in [%d] seconds\n", REBOOT_TIMEOUT/1000);
   1251e:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   12522:	f8bd 2010 	ldrh.w	r2, [sp, #16]
   12526:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   1252a:	f043 0303 	orr.w	r3, r3, #3
   1252e:	f363 0207 	bfi	r2, r3, #0, #8
   12532:	b293      	uxth	r3, r2
   12534:	f365 138f 	bfi	r3, r5, #6, #10
   12538:	2214      	movs	r2, #20
   1253a:	492f      	ldr	r1, [pc, #188]	; (125f8 <app_gc_iot+0x568>)
   1253c:	b298      	uxth	r0, r3
   1253e:	f8ad 3010 	strh.w	r3, [sp, #16]
   12542:	f021 fb59 	bl	33bf8 <log_string_sync>
   12546:	f644 6020 	movw	r0, #20000	; 0x4e20
   1254a:	f01b fd0d 	bl	2df68 <z_impl_k_sleep>
        k_sleep(K_MSEC(REBOOT_TIMEOUT));
        LOG_INF("Rebooting\n");
   1254e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   12552:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   12556:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   1255a:	f043 0303 	orr.w	r3, r3, #3
   1255e:	f363 0207 	bfi	r2, r3, #0, #8
   12562:	b293      	uxth	r3, r2
   12564:	f365 138f 	bfi	r3, r5, #6, #10
   12568:	b298      	uxth	r0, r3
   1256a:	4924      	ldr	r1, [pc, #144]	; (125fc <app_gc_iot+0x56c>)
   1256c:	f8ad 3014 	strh.w	r3, [sp, #20]
   12570:	f021 fb42 	bl	33bf8 <log_string_sync>
        sys_reboot(0);
   12574:	2000      	movs	r0, #0
   12576:	f007 fc91 	bl	19e9c <sys_reboot>
    while(true) {
   1257a:	e59b      	b.n	120b4 <app_gc_iot+0x24>
        LOG_INF("Waiting on Modem Time\n");
   1257c:	f024 013f 	bic.w	r1, r4, #63	; 0x3f
   12580:	f041 0103 	orr.w	r1, r1, #3
   12584:	f361 0407 	bfi	r4, r1, #0, #8
   12588:	f365 148f 	bfi	r4, r5, #6, #10
   1258c:	4611      	mov	r1, r2
   1258e:	4620      	mov	r0, r4
   12590:	f021 fb32 	bl	33bf8 <log_string_sync>
   12594:	f242 7010 	movw	r0, #10000	; 0x2710
   12598:	f01b fce6 	bl	2df68 <z_impl_k_sleep>
   1259c:	e582      	b.n	120a4 <app_gc_iot+0x14>
            LOG_INF("Received k_mbox\n");
   1259e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   125a2:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   125a6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   125aa:	f043 0303 	orr.w	r3, r3, #3
   125ae:	f363 0207 	bfi	r2, r3, #0, #8
   125b2:	b293      	uxth	r3, r2
   125b4:	f365 138f 	bfi	r3, r5, #6, #10
   125b8:	4911      	ldr	r1, [pc, #68]	; (12600 <app_gc_iot+0x570>)
   125ba:	b298      	uxth	r0, r3
   125bc:	f8ad 300c 	strh.w	r3, [sp, #12]
   125c0:	f021 fb1a 	bl	33bf8 <log_string_sync>
   125c4:	e5b0      	b.n	12128 <app_gc_iot+0x98>
	    int pub_success = gcloud_publish(JSONEnvString, strlens(JSONEnvString), MQTT_QOS_0_AT_MOST_ONCE);
   125c6:	4619      	mov	r1, r3
   125c8:	e786      	b.n	124d8 <app_gc_iot+0x448>
   125ca:	bf00      	nop
   125cc:	0003b5a6 	.word	0x0003b5a6
   125d0:	0003b5ab 	.word	0x0003b5ab
   125d4:	0003b5b0 	.word	0x0003b5b0
   125d8:	0003b5b6 	.word	0x0003b5b6
   125dc:	0003b5be 	.word	0x0003b5be
   125e0:	0003b5c9 	.word	0x0003b5c9
   125e4:	0003b441 	.word	0x0003b441
   125e8:	0003b5ce 	.word	0x0003b5ce
   125ec:	0003b5ee 	.word	0x0003b5ee
   125f0:	0003b601 	.word	0x0003b601
   125f4:	0003b621 	.word	0x0003b621
   125f8:	0003b63b 	.word	0x0003b63b
   125fc:	0003b656 	.word	0x0003b656
   12600:	0003b4b3 	.word	0x0003b4b3
   12604:	00000000 	.word	0x00000000

00012608 <print_number>:
	return p->offset + strlens(str);
}

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item, printbuffer *p)
{
   12608:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	char *str = 0;
	double d = item->valuedouble;
   1260a:	e9d0 6706 	ldrd	r6, r7, [r0, #24]
{
   1260e:	4605      	mov	r5, r0
   12610:	460c      	mov	r4, r1
	if (d == 0) {
   12612:	2200      	movs	r2, #0
   12614:	2300      	movs	r3, #0
   12616:	4630      	mov	r0, r6
   12618:	4639      	mov	r1, r7
   1261a:	f7fa ffaf 	bl	d57c <__aeabi_dcmpeq>
   1261e:	b180      	cbz	r0, 12642 <print_number+0x3a>
		if (p)
   12620:	b154      	cbz	r4, 12638 <print_number+0x30>
			str = ensure(p, 2);
   12622:	2102      	movs	r1, #2
   12624:	4620      	mov	r0, r4
   12626:	f004 f857 	bl	166d8 <ensure>
		else
			str = (char *)cJSON_malloc(2); /* special case for 0. */
   1262a:	4604      	mov	r4, r0
		if (str)
   1262c:	b110      	cbz	r0, 12634 <print_number+0x2c>
__ssp_bos_icheck3(memset, void *, int)
__ssp_bos_icheck2_restrict(stpcpy, char *, const char *)
#if __GNUC_PREREQ__(4,8) || defined(__clang__)
__ssp_bos_icheck3_restrict(stpncpy, char *, const char *)
#endif
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   1262e:	4952      	ldr	r1, [pc, #328]	; (12778 <print_number+0x170>)
   12630:	f026 fe60 	bl	392f4 <strcpy>
			else
				sprintf(str, "%f", d);
		}
	}
	return str;
}
   12634:	4620      	mov	r0, r4
   12636:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			str = (char *)cJSON_malloc(2); /* special case for 0. */
   12638:	4b50      	ldr	r3, [pc, #320]	; (1277c <print_number+0x174>)
   1263a:	2002      	movs	r0, #2
   1263c:	681b      	ldr	r3, [r3, #0]
   1263e:	4798      	blx	r3
   12640:	e7f3      	b.n	1262a <print_number+0x22>
	} else if (fabs(((double)item->valueint) - d) <= DBL_EPSILON &&
   12642:	6968      	ldr	r0, [r5, #20]
   12644:	f7fa fcc8 	bl	cfd8 <__aeabi_i2d>
   12648:	4632      	mov	r2, r6
   1264a:	463b      	mov	r3, r7
   1264c:	f7fa fb76 	bl	cd3c <__aeabi_dsub>
   12650:	ec41 0b10 	vmov	d0, r0, r1
   12654:	f01c fee6 	bl	2f424 <fabs>
   12658:	2200      	movs	r2, #0
   1265a:	4b49      	ldr	r3, [pc, #292]	; (12780 <print_number+0x178>)
   1265c:	ec51 0b10 	vmov	r0, r1, d0
   12660:	f7fa ffa0 	bl	d5a4 <__aeabi_dcmple>
   12664:	b300      	cbz	r0, 126a8 <print_number+0xa0>
   12666:	a33c      	add	r3, pc, #240	; (adr r3, 12758 <print_number+0x150>)
   12668:	e9d3 2300 	ldrd	r2, r3, [r3]
   1266c:	4630      	mov	r0, r6
   1266e:	4639      	mov	r1, r7
   12670:	f7fa ff98 	bl	d5a4 <__aeabi_dcmple>
   12674:	b1c0      	cbz	r0, 126a8 <print_number+0xa0>
		   d <= INT_MAX && d >= INT_MIN) {
   12676:	2200      	movs	r2, #0
   12678:	4b42      	ldr	r3, [pc, #264]	; (12784 <print_number+0x17c>)
   1267a:	4630      	mov	r0, r6
   1267c:	4639      	mov	r1, r7
   1267e:	f7fa ff9b 	bl	d5b8 <__aeabi_dcmpge>
   12682:	b188      	cbz	r0, 126a8 <print_number+0xa0>
		if (p)
   12684:	b15c      	cbz	r4, 1269e <print_number+0x96>
			str = ensure(p, 21);
   12686:	2115      	movs	r1, #21
   12688:	4620      	mov	r0, r4
   1268a:	f004 f825 	bl	166d8 <ensure>
			str = (char *)cJSON_malloc(
   1268e:	4604      	mov	r4, r0
		if (str)
   12690:	2800      	cmp	r0, #0
   12692:	d0cf      	beq.n	12634 <print_number+0x2c>
			sprintf(str, "%d", item->valueint);
   12694:	696a      	ldr	r2, [r5, #20]
   12696:	493c      	ldr	r1, [pc, #240]	; (12788 <print_number+0x180>)
   12698:	f01f fb26 	bl	31ce8 <siprintf>
   1269c:	e7ca      	b.n	12634 <print_number+0x2c>
			str = (char *)cJSON_malloc(
   1269e:	4b37      	ldr	r3, [pc, #220]	; (1277c <print_number+0x174>)
   126a0:	2015      	movs	r0, #21
   126a2:	681b      	ldr	r3, [r3, #0]
   126a4:	4798      	blx	r3
   126a6:	e7f2      	b.n	1268e <print_number+0x86>
		if (p)
   126a8:	b374      	cbz	r4, 12708 <print_number+0x100>
			str = ensure(p, 64);
   126aa:	2140      	movs	r1, #64	; 0x40
   126ac:	4620      	mov	r0, r4
   126ae:	f004 f813 	bl	166d8 <ensure>
			str = (char *)cJSON_malloc(
   126b2:	4604      	mov	r4, r0
		if (str) {
   126b4:	2800      	cmp	r0, #0
   126b6:	d0bd      	beq.n	12634 <print_number+0x2c>
			if (fabs(floor(d) - d) <= DBL_EPSILON &&
   126b8:	ec47 6b10 	vmov	d0, r6, r7
   126bc:	f000 fcc4 	bl	13048 <floor>
   126c0:	4632      	mov	r2, r6
   126c2:	463b      	mov	r3, r7
   126c4:	ec51 0b10 	vmov	r0, r1, d0
   126c8:	f7fa fb38 	bl	cd3c <__aeabi_dsub>
   126cc:	ec41 0b10 	vmov	d0, r0, r1
   126d0:	f01c fea8 	bl	2f424 <fabs>
   126d4:	2200      	movs	r2, #0
   126d6:	4b2a      	ldr	r3, [pc, #168]	; (12780 <print_number+0x178>)
   126d8:	ec51 0b10 	vmov	r0, r1, d0
   126dc:	f7fa ff62 	bl	d5a4 <__aeabi_dcmple>
   126e0:	b1b8      	cbz	r0, 12712 <print_number+0x10a>
			    fabs(d) < 1.0e60)
   126e2:	ec47 6b10 	vmov	d0, r6, r7
   126e6:	f01c fe9d 	bl	2f424 <fabs>
			if (fabs(floor(d) - d) <= DBL_EPSILON &&
   126ea:	a31d      	add	r3, pc, #116	; (adr r3, 12760 <print_number+0x158>)
   126ec:	e9d3 2300 	ldrd	r2, r3, [r3]
   126f0:	ec51 0b10 	vmov	r0, r1, d0
   126f4:	f7fa ff4c 	bl	d590 <__aeabi_dcmplt>
   126f8:	b158      	cbz	r0, 12712 <print_number+0x10a>
				sprintf(str, "%.0f", d);
   126fa:	4632      	mov	r2, r6
   126fc:	463b      	mov	r3, r7
   126fe:	4923      	ldr	r1, [pc, #140]	; (1278c <print_number+0x184>)
				sprintf(str, "%f", d);
   12700:	4620      	mov	r0, r4
   12702:	f01f faf1 	bl	31ce8 <siprintf>
	return str;
   12706:	e795      	b.n	12634 <print_number+0x2c>
			str = (char *)cJSON_malloc(
   12708:	4b1c      	ldr	r3, [pc, #112]	; (1277c <print_number+0x174>)
   1270a:	2040      	movs	r0, #64	; 0x40
   1270c:	681b      	ldr	r3, [r3, #0]
   1270e:	4798      	blx	r3
   12710:	e7cf      	b.n	126b2 <print_number+0xaa>
			else if (fabs(d) < 1.0e-6 || fabs(d) > 1.0e9)
   12712:	ec47 6b10 	vmov	d0, r6, r7
   12716:	f01c fe85 	bl	2f424 <fabs>
   1271a:	a313      	add	r3, pc, #76	; (adr r3, 12768 <print_number+0x160>)
   1271c:	e9d3 2300 	ldrd	r2, r3, [r3]
   12720:	ec51 0b10 	vmov	r0, r1, d0
   12724:	f7fa ff34 	bl	d590 <__aeabi_dcmplt>
   12728:	b118      	cbz	r0, 12732 <print_number+0x12a>
				sprintf(str, "%e", d);
   1272a:	4632      	mov	r2, r6
   1272c:	463b      	mov	r3, r7
   1272e:	4918      	ldr	r1, [pc, #96]	; (12790 <print_number+0x188>)
   12730:	e7e6      	b.n	12700 <print_number+0xf8>
			else if (fabs(d) < 1.0e-6 || fabs(d) > 1.0e9)
   12732:	ec47 6b10 	vmov	d0, r6, r7
   12736:	f01c fe75 	bl	2f424 <fabs>
   1273a:	a30d      	add	r3, pc, #52	; (adr r3, 12770 <print_number+0x168>)
   1273c:	e9d3 2300 	ldrd	r2, r3, [r3]
   12740:	ec51 0b10 	vmov	r0, r1, d0
   12744:	f7fa ff42 	bl	d5cc <__aeabi_dcmpgt>
   12748:	2800      	cmp	r0, #0
   1274a:	d1ee      	bne.n	1272a <print_number+0x122>
				sprintf(str, "%f", d);
   1274c:	4632      	mov	r2, r6
   1274e:	463b      	mov	r3, r7
   12750:	4910      	ldr	r1, [pc, #64]	; (12794 <print_number+0x18c>)
   12752:	e7d5      	b.n	12700 <print_number+0xf8>
   12754:	f3af 8000 	nop.w
   12758:	ffc00000 	.word	0xffc00000
   1275c:	41dfffff 	.word	0x41dfffff
   12760:	e4c2f344 	.word	0xe4c2f344
   12764:	4c63e9e4 	.word	0x4c63e9e4
   12768:	a0b5ed8d 	.word	0xa0b5ed8d
   1276c:	3eb0c6f7 	.word	0x3eb0c6f7
   12770:	00000000 	.word	0x00000000
   12774:	41cdcd65 	.word	0x41cdcd65
   12778:	0003fd3b 	.word	0x0003fd3b
   1277c:	20020080 	.word	0x20020080
   12780:	3cb00000 	.word	0x3cb00000
   12784:	c1e00000 	.word	0xc1e00000
   12788:	0003c661 	.word	0x0003c661
   1278c:	0003c50b 	.word	0x0003c50b
   12790:	0003c510 	.word	0x0003c510
   12794:	0003c513 	.word	0x0003c513

00012798 <sntp_query>:

	return res;
}

int sntp_query(struct sntp_ctx *ctx, u32_t timeout, struct sntp_time *time)
{
   12798:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1279c:	4605      	mov	r5, r0
   1279e:	b09b      	sub	sp, #108	; 0x6c
   127a0:	460f      	mov	r7, r1
   127a2:	4616      	mov	r6, r2
	struct sntp_pkt tx_pkt = { 0 };
   127a4:	2100      	movs	r1, #0
   127a6:	2230      	movs	r2, #48	; 0x30
   127a8:	a802      	add	r0, sp, #8
   127aa:	f026 fc4f 	bl	3904c <memset>
	int ret = 0;

	if (!ctx || !time) {
   127ae:	2d00      	cmp	r5, #0
   127b0:	f000 8087 	beq.w	128c2 <sntp_query+0x12a>
   127b4:	2e00      	cmp	r6, #0
   127b6:	f000 8084 	beq.w	128c2 <sntp_query+0x12a>
	}

	/* prepare request pkt */
	SNTP_SET_LI(tx_pkt.lvm, 0);
	SNTP_SET_VN(tx_pkt.lvm, SNTP_VERSION_NUMBER);
	SNTP_SET_MODE(tx_pkt.lvm, SNTP_MODE_CLIENT);
   127ba:	231b      	movs	r3, #27
   127bc:	f88d 3008 	strb.w	r3, [sp, #8]
		(void)arch_syscall_invoke1((uintptr_t)&ret64, K_SYSCALL_K_UPTIME_TICKS);
		return (s64_t)ret64;
	}
#endif
	compiler_barrier();
	return z_impl_k_uptime_ticks();
   127c0:	f026 fb3c 	bl	38e3c <z_impl_k_uptime_ticks>
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
		} else {
			return (t * to_hz + off) / from_hz;
   127c4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   127c8:	2400      	movs	r4, #0
   127ca:	fba0 8903 	umull	r8, r9, r0, r3
   127ce:	fb03 9901 	mla	r9, r3, r1, r9
   127d2:	ea4f 30d8 	mov.w	r0, r8, lsr #15
	return time / MSEC_PER_SEC;
   127d6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   127da:	2300      	movs	r3, #0
   127dc:	ea40 4049 	orr.w	r0, r0, r9, lsl #17
   127e0:	4621      	mov	r1, r4
   127e2:	f7fa ffc5 	bl	d770 <__aeabi_uldivmod>
	ctx->expected_orig_ts = get_uptime_in_sec() + OFFSET_1970_JAN_1;
   127e6:	4a3c      	ldr	r2, [pc, #240]	; (128d8 <sntp_query+0x140>)
   127e8:	4402      	add	r2, r0
	tx_pkt.tx_tm_s = htonl(ctx->expected_orig_ts);
   127ea:	0a13      	lsrs	r3, r2, #8
   127ec:	0211      	lsls	r1, r2, #8
   127ee:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
   127f2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   127f6:	430b      	orrs	r3, r1
   127f8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   127fc:	f043 0383 	orr.w	r3, r3, #131	; 0x83
	ctx->expected_orig_ts = get_uptime_in_sec() + OFFSET_1970_JAN_1;
   12800:	612a      	str	r2, [r5, #16]
	tx_pkt.tx_tm_s = htonl(ctx->expected_orig_ts);
   12802:	930c      	str	r3, [sp, #48]	; 0x30

	ret = send(ctx->sock.fd, (u8_t *)&tx_pkt, sizeof(tx_pkt), 0);
   12804:	68e8      	ldr	r0, [r5, #12]
	if (z_syscall_trap()) {
		return (ssize_t) arch_syscall_invoke6(*(uintptr_t *)&sock, *(uintptr_t *)&buf, *(uintptr_t *)&len, *(uintptr_t *)&flags, *(uintptr_t *)&dest_addr, *(uintptr_t *)&addrlen, K_SYSCALL_ZSOCK_SENDTO);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   12806:	2230      	movs	r2, #48	; 0x30
   12808:	e9cd 4400 	strd	r4, r4, [sp]
   1280c:	4623      	mov	r3, r4
   1280e:	a902      	add	r1, sp, #8
   12810:	f021 fb3e 	bl	33e90 <z_impl_zsock_sendto>
	if (ret < 0) {
   12814:	2800      	cmp	r0, #0
   12816:	db0f      	blt.n	12838 <sntp_query+0xa0>
	struct sntp_pkt buf = { 0 };
   12818:	4621      	mov	r1, r4
   1281a:	2230      	movs	r2, #48	; 0x30
   1281c:	a80e      	add	r0, sp, #56	; 0x38
   1281e:	f026 fc15 	bl	3904c <memset>
	status = poll(sntp->sock.fds, sntp->sock.nfds, timeout);
   12822:	68a9      	ldr	r1, [r5, #8]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&fds, *(uintptr_t *)&nfds, *(uintptr_t *)&timeout, K_SYSCALL_ZSOCK_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_poll(fds, nfds, timeout);
   12824:	463a      	mov	r2, r7
   12826:	4628      	mov	r0, r5
   12828:	f007 f8ca 	bl	199c0 <z_impl_zsock_poll>
	if (status < 0) {
   1282c:	42a0      	cmp	r0, r4
   1282e:	da06      	bge.n	1283e <sntp_query+0xa6>
		return -errno;
   12830:	f022 fe5a 	bl	354e8 <__errno>
   12834:	6800      	ldr	r0, [r0, #0]
   12836:	4240      	negs	r0, r0
		NET_ERR("Failed to send over UDP socket %d", ret);
		return ret;
	}

	return sntp_recv_response(ctx, timeout, time);
}
   12838:	b01b      	add	sp, #108	; 0x6c
   1283a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (status == 0) {
   1283e:	d037      	beq.n	128b0 <sntp_query+0x118>
	rcvd = recv(sntp->sock.fd, (u8_t *)&buf, sizeof(buf), 0);
   12840:	68e8      	ldr	r0, [r5, #12]
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   12842:	2230      	movs	r2, #48	; 0x30
   12844:	e9cd 4400 	strd	r4, r4, [sp]
   12848:	4623      	mov	r3, r4
   1284a:	a90e      	add	r1, sp, #56	; 0x38
   1284c:	f021 fb72 	bl	33f34 <z_impl_zsock_recvfrom>
	if (rcvd < 0) {
   12850:	2800      	cmp	r0, #0
   12852:	dbed      	blt.n	12830 <sntp_query+0x98>
	if (rcvd != sizeof(struct sntp_pkt)) {
   12854:	2830      	cmp	r0, #48	; 0x30
   12856:	d12e      	bne.n	128b6 <sntp_query+0x11e>
	if (ntohl(pkt->orig_tm_s) != orig_ts) {
   12858:	9b14      	ldr	r3, [sp, #80]	; 0x50
   1285a:	692a      	ldr	r2, [r5, #16]
   1285c:	ba1b      	rev	r3, r3
   1285e:	429a      	cmp	r2, r3
   12860:	d002      	beq.n	12868 <sntp_query+0xd0>
		return -EINVAL;
   12862:	f06f 0015 	mvn.w	r0, #21
   12866:	e7e7      	b.n	12838 <sntp_query+0xa0>
	if (SNTP_GET_MODE(pkt->lvm) != SNTP_MODE_SERVER) {
   12868:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
   1286c:	f003 0307 	and.w	r3, r3, #7
   12870:	2b04      	cmp	r3, #4
   12872:	d1f6      	bne.n	12862 <sntp_query+0xca>
	if (pkt->stratum == SNTP_STRATUM_KOD) {
   12874:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
   12878:	b303      	cbz	r3, 128bc <sntp_query+0x124>
	if (ntohl(pkt->tx_tm_s) == 0 && ntohl(pkt->tx_tm_f) == 0) {
   1287a:	9b18      	ldr	r3, [sp, #96]	; 0x60
   1287c:	9a19      	ldr	r2, [sp, #100]	; 0x64
   1287e:	ba1b      	rev	r3, r3
   12880:	ba12      	rev	r2, r2
   12882:	ea53 0102 	orrs.w	r1, r3, r2
   12886:	d0ec      	beq.n	12862 <sntp_query+0xca>
	if (ts & 0x80000000) {
   12888:	2b00      	cmp	r3, #0
	time->fraction = ntohl(pkt->tx_tm_f);
   1288a:	60b2      	str	r2, [r6, #8]
	if (ts & 0x80000000) {
   1288c:	da0c      	bge.n	128a8 <sntp_query+0x110>
		if (ts >= OFFSET_1970_JAN_1) {
   1288e:	4a13      	ldr	r2, [pc, #76]	; (128dc <sntp_query+0x144>)
   12890:	4293      	cmp	r3, r2
   12892:	d9e6      	bls.n	12862 <sntp_query+0xca>
			time->seconds = ts - OFFSET_1970_JAN_1;
   12894:	a10c      	add	r1, pc, #48	; (adr r1, 128c8 <sntp_query+0x130>)
   12896:	e9d1 0100 	ldrd	r0, r1, [r1]
		time->seconds = ts + 0x100000000ULL - OFFSET_1970_JAN_1;
   1289a:	18c4      	adds	r4, r0, r3
   1289c:	f141 0500 	adc.w	r5, r1, #0
   128a0:	e9c6 4500 	strd	r4, r5, [r6]
	return 0;
   128a4:	2000      	movs	r0, #0
   128a6:	e7c7      	b.n	12838 <sntp_query+0xa0>
		time->seconds = ts + 0x100000000ULL - OFFSET_1970_JAN_1;
   128a8:	a109      	add	r1, pc, #36	; (adr r1, 128d0 <sntp_query+0x138>)
   128aa:	e9d1 0100 	ldrd	r0, r1, [r1]
   128ae:	e7f4      	b.n	1289a <sntp_query+0x102>
		return -ETIMEDOUT;
   128b0:	f06f 0073 	mvn.w	r0, #115	; 0x73
   128b4:	e7c0      	b.n	12838 <sntp_query+0xa0>
		return -EMSGSIZE;
   128b6:	f06f 0079 	mvn.w	r0, #121	; 0x79
   128ba:	e7bd      	b.n	12838 <sntp_query+0xa0>
		return -EBUSY;
   128bc:	f06f 000f 	mvn.w	r0, #15
	return sntp_recv_response(ctx, timeout, time);
   128c0:	e7ba      	b.n	12838 <sntp_query+0xa0>
		return -EFAULT;
   128c2:	f06f 000d 	mvn.w	r0, #13
   128c6:	e7b7      	b.n	12838 <sntp_query+0xa0>
   128c8:	7c558180 	.word	0x7c558180
   128cc:	ffffffff 	.word	0xffffffff
   128d0:	7c558180 	.word	0x7c558180
   128d4:	00000000 	.word	0x00000000
   128d8:	83aa7e80 	.word	0x83aa7e80
   128dc:	83aa7e7f 	.word	0x83aa7e7f

000128e0 <at_handler>:

	return err;
}

static void at_handler(void *context, const char *response)
{
   128e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   128e4:	ed2d 8b02 	vpush	{d8}
	int err;
	bool notify = false;
	enum lte_lc_notif_type notif_type;
	struct lte_lc_evt evt;

	if (response == NULL) {
   128e8:	460e      	mov	r6, r1
{
   128ea:	b090      	sub	sp, #64	; 0x40
	if (response == NULL) {
   128ec:	b991      	cbnz	r1, 12914 <at_handler+0x34>
		LOG_ERR("Response buffer is NULL-pointer");
   128ee:	2301      	movs	r3, #1
   128f0:	f04f 0000 	mov.w	r0, #0
   128f4:	4ab8      	ldr	r2, [pc, #736]	; (12bd8 <at_handler+0x2f8>)
   128f6:	f363 0007 	bfi	r0, r3, #0, #8
   128fa:	4bb8      	ldr	r3, [pc, #736]	; (12bdc <at_handler+0x2fc>)
   128fc:	49b8      	ldr	r1, [pc, #736]	; (12be0 <at_handler+0x300>)
   128fe:	1a9b      	subs	r3, r3, r2
   12900:	08db      	lsrs	r3, r3, #3
   12902:	f363 108f 	bfi	r0, r3, #6, #10
   12906:	f021 f977 	bl	33bf8 <log_string_sync>
	}

	if (evt_handler && notify) {
		evt_handler(&evt);
	}
}
   1290a:	b010      	add	sp, #64	; 0x40
   1290c:	ecbd 8b02 	vpop	{d8}
   12910:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < ARRAY_SIZE(at_notifs); i++) {
   12914:	2400      	movs	r4, #0
   12916:	4db3      	ldr	r5, [pc, #716]	; (12be4 <at_handler+0x304>)
		if (strncmp(at_notifs[i], notif,
   12918:	f855 7b04 	ldr.w	r7, [r5], #4
   1291c:	4638      	mov	r0, r7
   1291e:	f7ff fbaf 	bl	12080 <strlen>
   12922:	4631      	mov	r1, r6
   12924:	4602      	mov	r2, r0
   12926:	4638      	mov	r0, r7
   12928:	f026 fcec 	bl	39304 <strncmp>
   1292c:	4680      	mov	r8, r0
   1292e:	2800      	cmp	r0, #0
   12930:	d140      	bne.n	129b4 <at_handler+0xd4>
			*type = i;
   12932:	b2e7      	uxtb	r7, r4
	switch (notif_type) {
   12934:	4ba8      	ldr	r3, [pc, #672]	; (12bd8 <at_handler+0x2f8>)
   12936:	4ca9      	ldr	r4, [pc, #676]	; (12bdc <at_handler+0x2fc>)
   12938:	2f01      	cmp	r7, #1
   1293a:	eba4 0403 	sub.w	r4, r4, r3
   1293e:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   12942:	f000 8102 	beq.w	12b4a <at_handler+0x26a>
   12946:	2f02      	cmp	r7, #2
   12948:	f000 8198 	beq.w	12c7c <at_handler+0x39c>
		LOG_DBG("+CEREG notification: %s", log_strdup(response));
   1294c:	2304      	movs	r3, #4
   1294e:	f04f 0500 	mov.w	r5, #0
   12952:	4630      	mov	r0, r6
   12954:	f363 0507 	bfi	r5, r3, #0, #8
   12958:	f021 f960 	bl	33c1c <log_strdup>
	size_t len = sizeof(str_buf) - 1;
   1295c:	2709      	movs	r7, #9
		LOG_DBG("+CEREG notification: %s", log_strdup(response));
   1295e:	f364 158f 	bfi	r5, r4, #6, #10
   12962:	4603      	mov	r3, r0
   12964:	4aa0      	ldr	r2, [pc, #640]	; (12be8 <at_handler+0x308>)
   12966:	4628      	mov	r0, r5
   12968:	49a0      	ldr	r1, [pc, #640]	; (12bec <at_handler+0x30c>)
   1296a:	f021 f945 	bl	33bf8 <log_string_sync>
	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
   1296e:	210a      	movs	r1, #10
   12970:	a80b      	add	r0, sp, #44	; 0x2c
	size_t len = sizeof(str_buf) - 1;
   12972:	9706      	str	r7, [sp, #24]
	err = at_params_list_init(&resp_list, AT_CEREG_PARAMS_COUNT_MAX);
   12974:	f025 ff34 	bl	387e0 <at_params_list_init>
	if (err) {
   12978:	4605      	mov	r5, r0
   1297a:	b1f8      	cbz	r0, 129bc <at_handler+0xdc>
		LOG_ERR("Could not init AT params list, error: %d", err);
   1297c:	f04f 0000 	mov.w	r0, #0
   12980:	2301      	movs	r3, #1
   12982:	f363 0007 	bfi	r0, r3, #0, #8
   12986:	f364 108f 	bfi	r0, r4, #6, #10
   1298a:	462a      	mov	r2, r5
   1298c:	4998      	ldr	r1, [pc, #608]	; (12bf0 <at_handler+0x310>)
   1298e:	f021 f933 	bl	33bf8 <log_string_sync>
			LOG_ERR("Failed to parse notification (error %d): %s",
   12992:	2301      	movs	r3, #1
   12994:	f04f 0700 	mov.w	r7, #0
   12998:	4630      	mov	r0, r6
   1299a:	f363 0707 	bfi	r7, r3, #0, #8
   1299e:	f021 f93d 	bl	33c1c <log_strdup>
   129a2:	f364 178f 	bfi	r7, r4, #6, #10
   129a6:	4603      	mov	r3, r0
   129a8:	462a      	mov	r2, r5
   129aa:	4992      	ldr	r1, [pc, #584]	; (12bf4 <at_handler+0x314>)
   129ac:	4638      	mov	r0, r7
   129ae:	f021 f923 	bl	33bf8 <log_string_sync>
			return;
   129b2:	e7aa      	b.n	1290a <at_handler+0x2a>
	for (size_t i = 0; i < ARRAY_SIZE(at_notifs); i++) {
   129b4:	3401      	adds	r4, #1
   129b6:	2c03      	cmp	r4, #3
   129b8:	d1ae      	bne.n	12918 <at_handler+0x38>
   129ba:	e7a6      	b.n	1290a <at_handler+0x2a>
	err = at_parser_params_from_str(notification,
   129bc:	4601      	mov	r1, r0
   129be:	aa0b      	add	r2, sp, #44	; 0x2c
   129c0:	4630      	mov	r0, r6
   129c2:	f025 ff0a 	bl	387da <at_parser_params_from_str>
	if (err) {
   129c6:	4605      	mov	r5, r0
   129c8:	2800      	cmp	r0, #0
   129ca:	d05d      	beq.n	12a88 <at_handler+0x1a8>
		LOG_ERR("Could not parse AT+CEREG response, error: %d", err);
   129cc:	f04f 0000 	mov.w	r0, #0
   129d0:	2301      	movs	r3, #1
   129d2:	462a      	mov	r2, r5
   129d4:	f363 0007 	bfi	r0, r3, #0, #8
   129d8:	4987      	ldr	r1, [pc, #540]	; (12bf8 <at_handler+0x318>)
   129da:	f364 108f 	bfi	r0, r4, #6, #10
		LOG_ERR("Failed to parse PSM configuration, error: %d", err);
   129de:	f021 f90b 	bl	33bf8 <log_string_sync>
	at_params_list_free(&resp_list);
   129e2:	a80b      	add	r0, sp, #44	; 0x2c
   129e4:	f025 ff0f 	bl	38806 <at_params_list_free>
		if (err) {
   129e8:	2d00      	cmp	r5, #0
   129ea:	d1d2      	bne.n	12992 <at_handler+0xb2>
		if ((reg_status == LTE_LC_NW_REG_REGISTERED_HOME) ||
   129ec:	f008 03fb 	and.w	r3, r8, #251	; 0xfb
   129f0:	2b01      	cmp	r3, #1
   129f2:	d102      	bne.n	129fa <at_handler+0x11a>
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   129f4:	4881      	ldr	r0, [pc, #516]	; (12bfc <at_handler+0x31c>)
   129f6:	f01b faf9 	bl	2dfec <z_impl_k_sem_give>
		if (!evt_handler) {
   129fa:	4d81      	ldr	r5, [pc, #516]	; (12c00 <at_handler+0x320>)
   129fc:	682b      	ldr	r3, [r5, #0]
   129fe:	2b00      	cmp	r3, #0
   12a00:	d083      	beq.n	1290a <at_handler+0x2a>
		if (reg_status != prev_reg_status) {
   12a02:	4a80      	ldr	r2, [pc, #512]	; (12c04 <at_handler+0x324>)
   12a04:	7811      	ldrb	r1, [r2, #0]
   12a06:	4541      	cmp	r1, r8
   12a08:	d008      	beq.n	12a1c <at_handler+0x13c>
			prev_reg_status = reg_status;
   12a0a:	f882 8000 	strb.w	r8, [r2]
			evt.type = LTE_LC_EVT_NW_REG_STATUS;
   12a0e:	2200      	movs	r2, #0
			evt.nw_reg_status = reg_status;
   12a10:	f88d 8038 	strb.w	r8, [sp, #56]	; 0x38
			evt.type = LTE_LC_EVT_NW_REG_STATUS;
   12a14:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
			evt_handler(&evt);
   12a18:	a80d      	add	r0, sp, #52	; 0x34
   12a1a:	4798      	blx	r3
		if (memcmp(&cell, &prev_cell, sizeof(struct lte_lc_cell))) {
   12a1c:	4e7a      	ldr	r6, [pc, #488]	; (12c08 <at_handler+0x328>)
   12a1e:	ac07      	add	r4, sp, #28
   12a20:	2208      	movs	r2, #8
   12a22:	4631      	mov	r1, r6
   12a24:	4620      	mov	r0, r4
   12a26:	f026 fac9 	bl	38fbc <memcmp>
   12a2a:	b160      	cbz	r0, 12a46 <at_handler+0x166>
			memcpy(&prev_cell, &cell, sizeof(struct lte_lc_cell));
   12a2c:	e894 0003 	ldmia.w	r4, {r0, r1}
			evt.type = LTE_LC_EVT_CELL_UPDATE;
   12a30:	2304      	movs	r3, #4
   12a32:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
			memcpy(&evt.cell, &cell, sizeof(struct lte_lc_cell));
   12a36:	ab10      	add	r3, sp, #64	; 0x40
   12a38:	e903 0003 	stmdb	r3, {r0, r1}
			memcpy(&prev_cell, &cell, sizeof(struct lte_lc_cell));
   12a3c:	e886 0003 	stmia.w	r6, {r0, r1}
			evt_handler(&evt);
   12a40:	682b      	ldr	r3, [r5, #0]
   12a42:	a80d      	add	r0, sp, #52	; 0x34
   12a44:	4798      	blx	r3
		if (memcmp(&psm_cfg, &prev_psm_cfg,
   12a46:	4e71      	ldr	r6, [pc, #452]	; (12c0c <at_handler+0x32c>)
   12a48:	ac09      	add	r4, sp, #36	; 0x24
   12a4a:	2208      	movs	r2, #8
   12a4c:	4631      	mov	r1, r6
   12a4e:	4620      	mov	r0, r4
   12a50:	f026 fab4 	bl	38fbc <memcmp>
   12a54:	b160      	cbz	r0, 12a70 <at_handler+0x190>
			memcpy(&prev_psm_cfg, &psm_cfg,
   12a56:	e894 0003 	ldmia.w	r4, {r0, r1}
			evt.type = LTE_LC_EVT_PSM_UPDATE;
   12a5a:	2301      	movs	r3, #1
   12a5c:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
			memcpy(&evt.psm_cfg, &psm_cfg,
   12a60:	ab10      	add	r3, sp, #64	; 0x40
   12a62:	e903 0003 	stmdb	r3, {r0, r1}
			memcpy(&prev_psm_cfg, &psm_cfg,
   12a66:	e886 0003 	stmia.w	r6, {r0, r1}
			evt_handler(&evt);
   12a6a:	682b      	ldr	r3, [r5, #0]
   12a6c:	a80d      	add	r0, sp, #52	; 0x34
   12a6e:	4798      	blx	r3
	bool notify = false;
   12a70:	2300      	movs	r3, #0
	if (evt_handler && notify) {
   12a72:	4a63      	ldr	r2, [pc, #396]	; (12c00 <at_handler+0x320>)
   12a74:	6812      	ldr	r2, [r2, #0]
   12a76:	2a00      	cmp	r2, #0
   12a78:	f43f af47 	beq.w	1290a <at_handler+0x2a>
   12a7c:	2b00      	cmp	r3, #0
   12a7e:	f43f af44 	beq.w	1290a <at_handler+0x2a>
		evt_handler(&evt);
   12a82:	a80d      	add	r0, sp, #52	; 0x34
   12a84:	4790      	blx	r2
   12a86:	e740      	b.n	1290a <at_handler+0x2a>
	err = at_params_int_get(&resp_list,
   12a88:	aa05      	add	r2, sp, #20
   12a8a:	2101      	movs	r1, #1
   12a8c:	a80b      	add	r0, sp, #44	; 0x2c
   12a8e:	f025 ff68 	bl	38962 <at_params_int_get>
	if (err) {
   12a92:	4605      	mov	r5, r0
   12a94:	b148      	cbz	r0, 12aaa <at_handler+0x1ca>
		LOG_ERR("Could not get registration status, error: %d", err);
   12a96:	f04f 0000 	mov.w	r0, #0
   12a9a:	2301      	movs	r3, #1
   12a9c:	f363 0007 	bfi	r0, r3, #0, #8
   12aa0:	f364 108f 	bfi	r0, r4, #6, #10
   12aa4:	462a      	mov	r2, r5
   12aa6:	495a      	ldr	r1, [pc, #360]	; (12c10 <at_handler+0x330>)
   12aa8:	e799      	b.n	129de <at_handler+0xfe>
	err = at_params_string_get(&resp_list,
   12aaa:	ab06      	add	r3, sp, #24
   12aac:	aa0d      	add	r2, sp, #52	; 0x34
   12aae:	2102      	movs	r1, #2
   12ab0:	a80b      	add	r0, sp, #44	; 0x2c
	*reg_status = status;
   12ab2:	f89d 8014 	ldrb.w	r8, [sp, #20]
	err = at_params_string_get(&resp_list,
   12ab6:	f025 ff6b 	bl	38990 <at_params_string_get>
	if (err) {
   12aba:	4605      	mov	r5, r0
   12abc:	b148      	cbz	r0, 12ad2 <at_handler+0x1f2>
		LOG_ERR("Could not get tracking area code, error: %d", err);
   12abe:	f04f 0000 	mov.w	r0, #0
   12ac2:	2301      	movs	r3, #1
   12ac4:	f363 0007 	bfi	r0, r3, #0, #8
   12ac8:	f364 108f 	bfi	r0, r4, #6, #10
   12acc:	462a      	mov	r2, r5
   12ace:	4951      	ldr	r1, [pc, #324]	; (12c14 <at_handler+0x334>)
   12ad0:	e785      	b.n	129de <at_handler+0xfe>
	str_buf[len] = '\0';
   12ad2:	9b06      	ldr	r3, [sp, #24]
   12ad4:	aa10      	add	r2, sp, #64	; 0x40
   12ad6:	4413      	add	r3, r2
   12ad8:	f803 0c0c 	strb.w	r0, [r3, #-12]
	cell->tac = strtoul(str_buf, NULL, 16);
   12adc:	4601      	mov	r1, r0
   12ade:	2210      	movs	r2, #16
   12ae0:	a80d      	add	r0, sp, #52	; 0x34
   12ae2:	f01f fc07 	bl	322f4 <strtoul>
	err = at_params_string_get(&resp_list,
   12ae6:	ab06      	add	r3, sp, #24
	cell->tac = strtoul(str_buf, NULL, 16);
   12ae8:	9008      	str	r0, [sp, #32]
	err = at_params_string_get(&resp_list,
   12aea:	aa0d      	add	r2, sp, #52	; 0x34
   12aec:	2103      	movs	r1, #3
   12aee:	a80b      	add	r0, sp, #44	; 0x2c
	len = sizeof(str_buf) - 1;
   12af0:	9706      	str	r7, [sp, #24]
	err = at_params_string_get(&resp_list,
   12af2:	f025 ff4d 	bl	38990 <at_params_string_get>
	if (err) {
   12af6:	4605      	mov	r5, r0
   12af8:	b148      	cbz	r0, 12b0e <at_handler+0x22e>
		LOG_ERR("Could not get cell ID, error: %d", err);
   12afa:	f04f 0000 	mov.w	r0, #0
   12afe:	2301      	movs	r3, #1
   12b00:	f363 0007 	bfi	r0, r3, #0, #8
   12b04:	f364 108f 	bfi	r0, r4, #6, #10
   12b08:	462a      	mov	r2, r5
   12b0a:	4943      	ldr	r1, [pc, #268]	; (12c18 <at_handler+0x338>)
   12b0c:	e767      	b.n	129de <at_handler+0xfe>
	str_buf[len] = '\0';
   12b0e:	9b06      	ldr	r3, [sp, #24]
   12b10:	aa10      	add	r2, sp, #64	; 0x40
   12b12:	4413      	add	r3, r2
   12b14:	f803 0c0c 	strb.w	r0, [r3, #-12]
	cell->id = strtoul(str_buf, NULL, 16);
   12b18:	4601      	mov	r1, r0
   12b1a:	2210      	movs	r2, #16
   12b1c:	a80d      	add	r0, sp, #52	; 0x34
   12b1e:	f01f fbe9 	bl	322f4 <strtoul>
	err = parse_psm_cfg(&resp_list, true, psm_cfg);
   12b22:	aa09      	add	r2, sp, #36	; 0x24
	cell->id = strtoul(str_buf, NULL, 16);
   12b24:	9007      	str	r0, [sp, #28]
	err = parse_psm_cfg(&resp_list, true, psm_cfg);
   12b26:	2101      	movs	r1, #1
   12b28:	a80b      	add	r0, sp, #44	; 0x2c
   12b2a:	f00e fb89 	bl	21240 <parse_psm_cfg>
	if (err) {
   12b2e:	4605      	mov	r5, r0
   12b30:	2800      	cmp	r0, #0
   12b32:	f43f af56 	beq.w	129e2 <at_handler+0x102>
		LOG_ERR("Failed to parse PSM configuration, error: %d", err);
   12b36:	f04f 0000 	mov.w	r0, #0
   12b3a:	2301      	movs	r3, #1
   12b3c:	f363 0007 	bfi	r0, r3, #0, #8
   12b40:	f364 108f 	bfi	r0, r4, #6, #10
   12b44:	462a      	mov	r2, r5
   12b46:	4935      	ldr	r1, [pc, #212]	; (12c1c <at_handler+0x33c>)
   12b48:	e749      	b.n	129de <at_handler+0xfe>
		LOG_DBG("+CSCON notification");
   12b4a:	2304      	movs	r3, #4
   12b4c:	f04f 0000 	mov.w	r0, #0
   12b50:	f363 0007 	bfi	r0, r3, #0, #8
   12b54:	f364 108f 	bfi	r0, r4, #6, #10
   12b58:	4a23      	ldr	r2, [pc, #140]	; (12be8 <at_handler+0x308>)
   12b5a:	4931      	ldr	r1, [pc, #196]	; (12c20 <at_handler+0x340>)
   12b5c:	f021 f84c 	bl	33bf8 <log_string_sync>
			  size_t mode_index)
{
	int err, temp_mode;
	struct at_param_list resp_list = {0};

	err = at_params_list_init(&resp_list, AT_CSCON_PARAMS_COUNT_MAX);
   12b60:	2104      	movs	r1, #4
   12b62:	a80b      	add	r0, sp, #44	; 0x2c
	struct at_param_list resp_list = {0};
   12b64:	e9cd 880b 	strd	r8, r8, [sp, #44]	; 0x2c
	err = at_params_list_init(&resp_list, AT_CSCON_PARAMS_COUNT_MAX);
   12b68:	f025 fe3a 	bl	387e0 <at_params_list_init>
	if (err) {
   12b6c:	4605      	mov	r5, r0
   12b6e:	b1b0      	cbz	r0, 12b9e <at_handler+0x2be>
		LOG_ERR("Could not init AT params list, error: %d", err);
   12b70:	f04f 0000 	mov.w	r0, #0
   12b74:	2301      	movs	r3, #1
   12b76:	f363 0007 	bfi	r0, r3, #0, #8
   12b7a:	f364 108f 	bfi	r0, r4, #6, #10
   12b7e:	462a      	mov	r2, r5
   12b80:	491b      	ldr	r1, [pc, #108]	; (12bf0 <at_handler+0x310>)
   12b82:	f021 f839 	bl	33bf8 <log_string_sync>
			LOG_ERR("Can't parse signalling mode, error: %d", err);
   12b86:	f04f 0000 	mov.w	r0, #0
   12b8a:	2301      	movs	r3, #1
   12b8c:	462a      	mov	r2, r5
   12b8e:	f363 0007 	bfi	r0, r3, #0, #8
   12b92:	4924      	ldr	r1, [pc, #144]	; (12c24 <at_handler+0x344>)
   12b94:	f364 108f 	bfi	r0, r4, #6, #10
			LOG_ERR("Can't parse eDRX, error: %d", err);
   12b98:	f021 f82e 	bl	33bf8 <log_string_sync>
			return;
   12b9c:	e6b5      	b.n	1290a <at_handler+0x2a>
		return err;
	}

	/* Parse CSCON response and populate AT parameter list */
	err = at_parser_params_from_str(at_response,
   12b9e:	4601      	mov	r1, r0
   12ba0:	aa0b      	add	r2, sp, #44	; 0x2c
   12ba2:	4630      	mov	r0, r6
   12ba4:	f025 fe19 	bl	387da <at_parser_params_from_str>
					NULL,
					&resp_list);
	if (err) {
   12ba8:	4605      	mov	r5, r0
   12baa:	2800      	cmp	r0, #0
   12bac:	d03e      	beq.n	12c2c <at_handler+0x34c>
		LOG_ERR("Could not parse +CSCON response, error: %d", err);
   12bae:	f04f 0000 	mov.w	r0, #0
   12bb2:	2301      	movs	r3, #1
   12bb4:	462a      	mov	r2, r5
   12bb6:	f363 0007 	bfi	r0, r3, #0, #8
   12bba:	491b      	ldr	r1, [pc, #108]	; (12c28 <at_handler+0x348>)
   12bbc:	f364 108f 	bfi	r0, r4, #6, #10
	}

	/* Get the RRC mode from the response */
	err = at_params_int_get(&resp_list, mode_index, &temp_mode);
	if (err) {
		LOG_ERR("Could not get signalling mode, error: %d", err);
   12bc0:	f021 f81a 	bl	33bf8 <log_string_sync>
		LOG_ERR("Invalid signalling mode: %d", temp_mode);
		err = -EINVAL;
	}

clean_exit:
	at_params_list_free(&resp_list);
   12bc4:	a80b      	add	r0, sp, #44	; 0x2c
   12bc6:	f025 fe1e 	bl	38806 <at_params_list_free>
		if (err) {
   12bca:	2d00      	cmp	r5, #0
   12bcc:	d1db      	bne.n	12b86 <at_handler+0x2a6>
		evt.type = LTE_LC_EVT_RRC_UPDATE;
   12bce:	2303      	movs	r3, #3
		evt.type = LTE_LC_EVT_EDRX_UPDATE;
   12bd0:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
		notify = true;
   12bd4:	2301      	movs	r3, #1
		break;
   12bd6:	e74c      	b.n	12a72 <at_handler+0x192>
   12bd8:	00039f60 	.word	0x00039f60
   12bdc:	00039fc0 	.word	0x00039fc0
   12be0:	0003e546 	.word	0x0003e546
   12be4:	0003a750 	.word	0x0003a750
   12be8:	0003e50b 	.word	0x0003e50b
   12bec:	0003e566 	.word	0x0003e566
   12bf0:	0003e9ba 	.word	0x0003e9ba
   12bf4:	0003e5fc 	.word	0x0003e5fc
   12bf8:	0003e9e3 	.word	0x0003e9e3
   12bfc:	20022378 	.word	0x20022378
   12c00:	20022374 	.word	0x20022374
   12c04:	2002807e 	.word	0x2002807e
   12c08:	20022390 	.word	0x20022390
   12c0c:	20022398 	.word	0x20022398
   12c10:	0003e8b8 	.word	0x0003e8b8
   12c14:	0003e582 	.word	0x0003e582
   12c18:	0003e5ae 	.word	0x0003e5ae
   12c1c:	0003e5cf 	.word	0x0003e5cf
   12c20:	0003e628 	.word	0x0003e628
   12c24:	0003e6b0 	.word	0x0003e6b0
   12c28:	0003e640 	.word	0x0003e640
	err = at_params_int_get(&resp_list, mode_index, &temp_mode);
   12c2c:	aa09      	add	r2, sp, #36	; 0x24
   12c2e:	4639      	mov	r1, r7
   12c30:	a80b      	add	r0, sp, #44	; 0x2c
   12c32:	f025 fe96 	bl	38962 <at_params_int_get>
	if (err) {
   12c36:	4605      	mov	r5, r0
   12c38:	b148      	cbz	r0, 12c4e <at_handler+0x36e>
		LOG_ERR("Could not get signalling mode, error: %d", err);
   12c3a:	f04f 0000 	mov.w	r0, #0
   12c3e:	2301      	movs	r3, #1
   12c40:	f363 0007 	bfi	r0, r3, #0, #8
   12c44:	f364 108f 	bfi	r0, r4, #6, #10
   12c48:	462a      	mov	r2, r5
   12c4a:	49a9      	ldr	r1, [pc, #676]	; (12ef0 <at_handler+0x610>)
   12c4c:	e7b8      	b.n	12bc0 <at_handler+0x2e0>
	if (temp_mode == 0) {
   12c4e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   12c50:	b912      	cbnz	r2, 12c58 <at_handler+0x378>
		*mode = LTE_LC_RRC_MODE_IDLE;
   12c52:	f88d 0038 	strb.w	r0, [sp, #56]	; 0x38
   12c56:	e7b5      	b.n	12bc4 <at_handler+0x2e4>
	} else if (temp_mode == 1) {
   12c58:	2a01      	cmp	r2, #1
   12c5a:	d102      	bne.n	12c62 <at_handler+0x382>
		*mode = LTE_LC_RRC_MODE_CONNECTED;
   12c5c:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
   12c60:	e7b0      	b.n	12bc4 <at_handler+0x2e4>
		LOG_ERR("Invalid signalling mode: %d", temp_mode);
   12c62:	2301      	movs	r3, #1
   12c64:	f04f 0000 	mov.w	r0, #0
   12c68:	f363 0007 	bfi	r0, r3, #0, #8
   12c6c:	f364 108f 	bfi	r0, r4, #6, #10
   12c70:	49a0      	ldr	r1, [pc, #640]	; (12ef4 <at_handler+0x614>)
   12c72:	f020 ffc1 	bl	33bf8 <log_string_sync>
		err = -EINVAL;
   12c76:	f06f 0515 	mvn.w	r5, #21
   12c7a:	e7a3      	b.n	12bc4 <at_handler+0x2e4>
		LOG_DBG("+CEDRXP notification");
   12c7c:	2304      	movs	r3, #4
   12c7e:	f04f 0000 	mov.w	r0, #0
   12c82:	f363 0007 	bfi	r0, r3, #0, #8
   12c86:	f364 108f 	bfi	r0, r4, #6, #10
   12c8a:	4a9b      	ldr	r2, [pc, #620]	; (12ef8 <at_handler+0x618>)
   12c8c:	499b      	ldr	r1, [pc, #620]	; (12efc <at_handler+0x61c>)
   12c8e:	f020 ffb3 	bl	33bf8 <log_string_sync>
{
	int err;
	u8_t idx;
	struct at_param_list resp_list = {0};
	char tmp_buf[5];
	size_t len = sizeof(tmp_buf) - 1;
   12c92:	2304      	movs	r3, #4
	err = lte_lc_system_mode_get(&sys_mode);
   12c94:	a80d      	add	r0, sp, #52	; 0x34
	struct at_param_list resp_list = {0};
   12c96:	e9cd 880b 	strd	r8, r8, [sp, #44]	; 0x2c
	size_t len = sizeof(tmp_buf) - 1;
   12c9a:	9307      	str	r3, [sp, #28]
	err = lte_lc_system_mode_get(&sys_mode);
   12c9c:	f00e fd3a 	bl	21714 <lte_lc_system_mode_get>
	if (err) {
   12ca0:	4605      	mov	r5, r0
   12ca2:	b158      	cbz	r0, 12cbc <at_handler+0x3dc>
		LOG_ERR("Failed to get system mode, error: %d", err);
   12ca4:	f04f 0000 	mov.w	r0, #0
   12ca8:	2301      	movs	r3, #1
   12caa:	462a      	mov	r2, r5
   12cac:	f363 0007 	bfi	r0, r3, #0, #8
   12cb0:	4993      	ldr	r1, [pc, #588]	; (12f00 <at_handler+0x620>)
   12cb2:	f364 108f 	bfi	r0, r4, #6, #10
		return err;
	}

	err = at_params_list_init(&resp_list, AT_CEDRXP_PARAMS_COUNT_MAX);
	if (err) {
		LOG_ERR("Could not init AT params list, error: %d", err);
   12cb6:	f020 ff9f 	bl	33bf8 <log_string_sync>
		return err;
   12cba:	e015      	b.n	12ce8 <at_handler+0x408>
	switch (sys_mode) {
   12cbc:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   12cc0:	3b01      	subs	r3, #1
   12cc2:	2b04      	cmp	r3, #4
   12cc4:	d804      	bhi.n	12cd0 <at_handler+0x3f0>
   12cc6:	e8df f003 	tbb	[pc, r3]
   12cca:	192b      	.short	0x192b
   12ccc:	2b03      	.short	0x2b03
   12cce:	19          	.byte	0x19
   12ccf:	00          	.byte	0x00
		LOG_ERR("No LTE connection available in this system mode");
   12cd0:	2301      	movs	r3, #1
   12cd2:	f04f 0000 	mov.w	r0, #0
   12cd6:	f363 0007 	bfi	r0, r3, #0, #8
   12cda:	f364 108f 	bfi	r0, r4, #6, #10
   12cde:	4989      	ldr	r1, [pc, #548]	; (12f04 <at_handler+0x624>)
   12ce0:	f020 ff8a 	bl	33bf8 <log_string_sync>
		return -ENOTCONN;
   12ce4:	f06f 057f 	mvn.w	r5, #127	; 0x7f
			LOG_ERR("Can't parse eDRX, error: %d", err);
   12ce8:	f04f 0000 	mov.w	r0, #0
   12cec:	2301      	movs	r3, #1
   12cee:	f363 0007 	bfi	r0, r3, #0, #8
   12cf2:	f364 108f 	bfi	r0, r4, #6, #10
   12cf6:	462a      	mov	r2, r5
   12cf8:	4983      	ldr	r1, [pc, #524]	; (12f08 <at_handler+0x628>)
   12cfa:	e74d      	b.n	12b98 <at_handler+0x2b8>
		*ptw_multiplier = 2.56;
   12cfc:	ed9f 8a83 	vldr	s16, [pc, #524]	; 12f0c <at_handler+0x62c>
	err = at_params_list_init(&resp_list, AT_CEDRXP_PARAMS_COUNT_MAX);
   12d00:	2105      	movs	r1, #5
   12d02:	a80b      	add	r0, sp, #44	; 0x2c
   12d04:	f025 fd6c 	bl	387e0 <at_params_list_init>
	if (err) {
   12d08:	4605      	mov	r5, r0
   12d0a:	b160      	cbz	r0, 12d26 <at_handler+0x446>
		LOG_ERR("Could not init AT params list, error: %d", err);
   12d0c:	f04f 0000 	mov.w	r0, #0
   12d10:	2301      	movs	r3, #1
   12d12:	f363 0007 	bfi	r0, r3, #0, #8
   12d16:	f364 108f 	bfi	r0, r4, #6, #10
   12d1a:	462a      	mov	r2, r5
   12d1c:	497c      	ldr	r1, [pc, #496]	; (12f10 <at_handler+0x630>)
   12d1e:	e7ca      	b.n	12cb6 <at_handler+0x3d6>
		*ptw_multiplier = 1.28;
   12d20:	ed9f 8a7c 	vldr	s16, [pc, #496]	; 12f14 <at_handler+0x634>
   12d24:	e7ec      	b.n	12d00 <at_handler+0x420>
	}

	/* Parse CEDRXP response and populate AT parameter list */
	err = at_parser_params_from_str(at_response,
   12d26:	4601      	mov	r1, r0
   12d28:	aa0b      	add	r2, sp, #44	; 0x2c
   12d2a:	4630      	mov	r0, r6
   12d2c:	f025 fd55 	bl	387da <at_parser_params_from_str>
					NULL,
					&resp_list);
	if (err) {
   12d30:	4605      	mov	r5, r0
   12d32:	b188      	cbz	r0, 12d58 <at_handler+0x478>
		LOG_ERR("Could not parse +CEDRXP response, error: %d", err);
   12d34:	f04f 0000 	mov.w	r0, #0
   12d38:	2301      	movs	r3, #1
   12d3a:	462a      	mov	r2, r5
   12d3c:	f363 0007 	bfi	r0, r3, #0, #8
   12d40:	4975      	ldr	r1, [pc, #468]	; (12f18 <at_handler+0x638>)
   12d42:	f364 108f 	bfi	r0, r4, #6, #10
	}

	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_EDRX_INDEX,
				   tmp_buf, &len);
	if (err) {
		LOG_ERR("Failed to get eDRX configuration, error: %d", err);
   12d46:	f020 ff57 	bl	33bf8 <log_string_sync>
		(int)(100 * (cfg->edrx - (int)cfg->edrx)),
		(int)cfg->ptw,
		(int)(100 * (cfg->ptw - (int)cfg->ptw)));

clean_exit:
	at_params_list_free(&resp_list);
   12d4a:	a80b      	add	r0, sp, #44	; 0x2c
   12d4c:	f025 fd5b 	bl	38806 <at_params_list_free>
		if (err) {
   12d50:	2d00      	cmp	r5, #0
   12d52:	d1c9      	bne.n	12ce8 <at_handler+0x408>
		evt.type = LTE_LC_EVT_EDRX_UPDATE;
   12d54:	2302      	movs	r3, #2
   12d56:	e73b      	b.n	12bd0 <at_handler+0x2f0>
	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_EDRX_INDEX,
   12d58:	ab07      	add	r3, sp, #28
   12d5a:	aa09      	add	r2, sp, #36	; 0x24
   12d5c:	2103      	movs	r1, #3
   12d5e:	a80b      	add	r0, sp, #44	; 0x2c
   12d60:	f025 fe16 	bl	38990 <at_params_string_get>
	if (err) {
   12d64:	4605      	mov	r5, r0
   12d66:	b148      	cbz	r0, 12d7c <at_handler+0x49c>
		LOG_ERR("Failed to get eDRX configuration, error: %d", err);
   12d68:	f04f 0000 	mov.w	r0, #0
   12d6c:	2301      	movs	r3, #1
   12d6e:	f363 0007 	bfi	r0, r3, #0, #8
   12d72:	f364 108f 	bfi	r0, r4, #6, #10
   12d76:	462a      	mov	r2, r5
   12d78:	4968      	ldr	r1, [pc, #416]	; (12f1c <at_handler+0x63c>)
   12d7a:	e7e4      	b.n	12d46 <at_handler+0x466>
	tmp_buf[len] = '\0';
   12d7c:	9b07      	ldr	r3, [sp, #28]
   12d7e:	aa10      	add	r2, sp, #64	; 0x40
   12d80:	4413      	add	r3, r2
   12d82:	f803 0c1c 	strb.w	r0, [r3, #-28]
	idx = strtoul(tmp_buf, NULL, 2);
   12d86:	4601      	mov	r1, r0
   12d88:	2202      	movs	r2, #2
   12d8a:	a809      	add	r0, sp, #36	; 0x24
   12d8c:	f01f fab2 	bl	322f4 <strtoul>
	if ((edrx_value == NULL) || (idx > ARRAY_SIZE(edrx_lookup_ltem) - 1)) {
   12d90:	b2c6      	uxtb	r6, r0
   12d92:	2e0f      	cmp	r6, #15
   12d94:	d90b      	bls.n	12dae <at_handler+0x4ce>
		return -EINVAL;
   12d96:	f06f 0515 	mvn.w	r5, #21
		LOG_ERR("Failed to get eDRX value, error; %d", err);
   12d9a:	f04f 0000 	mov.w	r0, #0
   12d9e:	2301      	movs	r3, #1
   12da0:	f363 0007 	bfi	r0, r3, #0, #8
   12da4:	f364 108f 	bfi	r0, r4, #6, #10
   12da8:	462a      	mov	r2, r5
   12daa:	495d      	ldr	r1, [pc, #372]	; (12f20 <at_handler+0x640>)
   12dac:	e7cb      	b.n	12d46 <at_handler+0x466>
	err = lte_lc_system_mode_get(&sys_mode);
   12dae:	a806      	add	r0, sp, #24
   12db0:	f00e fcb0 	bl	21714 <lte_lc_system_mode_get>
	if (err) {
   12db4:	4605      	mov	r5, r0
   12db6:	b158      	cbz	r0, 12dd0 <at_handler+0x4f0>
		LOG_ERR("Failed to get system mode, error: %d", err);
   12db8:	2301      	movs	r3, #1
   12dba:	f04f 0000 	mov.w	r0, #0
   12dbe:	f363 0007 	bfi	r0, r3, #0, #8
   12dc2:	f364 108f 	bfi	r0, r4, #6, #10
   12dc6:	462a      	mov	r2, r5
   12dc8:	494d      	ldr	r1, [pc, #308]	; (12f00 <at_handler+0x620>)
   12dca:	f020 ff15 	bl	33bf8 <log_string_sync>
	if (err) {
   12dce:	e7e4      	b.n	12d9a <at_handler+0x4ba>
	switch (sys_mode) {
   12dd0:	f89d 3018 	ldrb.w	r3, [sp, #24]
   12dd4:	3b01      	subs	r3, #1
   12dd6:	2b04      	cmp	r3, #4
   12dd8:	d827      	bhi.n	12e2a <at_handler+0x54a>
   12dda:	e8df f003 	tbb	[pc, r3]
   12dde:	2403      	.short	0x2403
   12de0:	0326      	.short	0x0326
   12de2:	24          	.byte	0x24
   12de3:	00          	.byte	0x00
		multiplier = edrx_lookup_ltem[idx];
   12de4:	4b4f      	ldr	r3, [pc, #316]	; (12f24 <at_handler+0x644>)
		multiplier = edrx_lookup_nbiot[idx];
   12de6:	f833 0016 	ldrh.w	r0, [r3, r6, lsl #1]
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
   12dea:	b358      	cbz	r0, 12e44 <at_handler+0x564>
   12dec:	f7fa f8f4 	bl	cfd8 <__aeabi_i2d>
   12df0:	a33d      	add	r3, pc, #244	; (adr r3, 12ee8 <at_handler+0x608>)
   12df2:	e9d3 2300 	ldrd	r2, r3, [r3]
   12df6:	f7fa f959 	bl	d0ac <__aeabi_dmul>
   12dfa:	f7fa fc19 	bl	d630 <__aeabi_d2f>
	len = sizeof(tmp_buf) - 1;
   12dfe:	2104      	movs	r1, #4
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
   12e00:	900e      	str	r0, [sp, #56]	; 0x38
	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_PTW_INDEX,
   12e02:	ab07      	add	r3, sp, #28
   12e04:	aa09      	add	r2, sp, #36	; 0x24
   12e06:	a80b      	add	r0, sp, #44	; 0x2c
	len = sizeof(tmp_buf) - 1;
   12e08:	9107      	str	r1, [sp, #28]
	err = at_params_string_get(&resp_list, AT_CEDRXP_NW_PTW_INDEX,
   12e0a:	f025 fdc1 	bl	38990 <at_params_string_get>
	if (err) {
   12e0e:	4605      	mov	r5, r0
   12e10:	b1d0      	cbz	r0, 12e48 <at_handler+0x568>
		LOG_ERR("Failed to get PTW configuration, error: %d", err);
   12e12:	f04f 0000 	mov.w	r0, #0
   12e16:	2301      	movs	r3, #1
   12e18:	f363 0007 	bfi	r0, r3, #0, #8
   12e1c:	f364 108f 	bfi	r0, r4, #6, #10
   12e20:	462a      	mov	r2, r5
   12e22:	4941      	ldr	r1, [pc, #260]	; (12f28 <at_handler+0x648>)
   12e24:	e78f      	b.n	12d46 <at_handler+0x466>
		multiplier = edrx_lookup_nbiot[idx];
   12e26:	4b41      	ldr	r3, [pc, #260]	; (12f2c <at_handler+0x64c>)
   12e28:	e7dd      	b.n	12de6 <at_handler+0x506>
		LOG_ERR("No LTE connection available in this system mode");
   12e2a:	2301      	movs	r3, #1
   12e2c:	f04f 0000 	mov.w	r0, #0
   12e30:	f363 0007 	bfi	r0, r3, #0, #8
   12e34:	f364 108f 	bfi	r0, r4, #6, #10
   12e38:	4932      	ldr	r1, [pc, #200]	; (12f04 <at_handler+0x624>)
   12e3a:	f020 fedd 	bl	33bf8 <log_string_sync>
		return -ENOTCONN;
   12e3e:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   12e42:	e7aa      	b.n	12d9a <at_handler+0x4ba>
	*edrx_value = multiplier == 0 ? 5.12 : multiplier * 10.24;
   12e44:	483a      	ldr	r0, [pc, #232]	; (12f30 <at_handler+0x650>)
   12e46:	e7da      	b.n	12dfe <at_handler+0x51e>
	tmp_buf[len] = '\0';
   12e48:	9b07      	ldr	r3, [sp, #28]
   12e4a:	aa10      	add	r2, sp, #64	; 0x40
   12e4c:	4413      	add	r3, r2
   12e4e:	f803 0c1c 	strb.w	r0, [r3, #-28]
	idx = strtoul(tmp_buf, NULL, 2);
   12e52:	2202      	movs	r2, #2
   12e54:	4601      	mov	r1, r0
   12e56:	a809      	add	r0, sp, #36	; 0x24
   12e58:	f01f fa4c 	bl	322f4 <strtoul>
	if (idx > 15) {
   12e5c:	b2c2      	uxtb	r2, r0
   12e5e:	2a0f      	cmp	r2, #15
   12e60:	d90c      	bls.n	12e7c <at_handler+0x59c>
		LOG_ERR("Invalid PTW lookup index: %d", idx);
   12e62:	2301      	movs	r3, #1
   12e64:	f04f 0000 	mov.w	r0, #0
   12e68:	f363 0007 	bfi	r0, r3, #0, #8
   12e6c:	f364 108f 	bfi	r0, r4, #6, #10
   12e70:	4930      	ldr	r1, [pc, #192]	; (12f34 <at_handler+0x654>)
   12e72:	f020 fec1 	bl	33bf8 <log_string_sync>
		err = -EINVAL;
   12e76:	f06f 0515 	mvn.w	r5, #21
   12e7a:	e766      	b.n	12d4a <at_handler+0x46a>
	idx += 1;
   12e7c:	3001      	adds	r0, #1
	cfg->ptw = idx * ptw_multiplier;
   12e7e:	b2c0      	uxtb	r0, r0
   12e80:	ee07 0a90 	vmov	s15, r0
   12e84:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   12e88:	ee67 7a88 	vmul.f32	s15, s15, s16
	LOG_DBG("eDRX value: %d.%02d, PTW: %d.%02d",
   12e8c:	eefd 5ae7 	vcvt.s32.f32	s11, s15
   12e90:	eeb8 6ae5 	vcvt.f32.s32	s12, s11
	cfg->ptw = idx * ptw_multiplier;
   12e94:	edcd 7a0f 	vstr	s15, [sp, #60]	; 0x3c
	LOG_DBG("eDRX value: %d.%02d, PTW: %d.%02d",
   12e98:	ee77 7ac6 	vsub.f32	s15, s15, s12
   12e9c:	ed9f 6a26 	vldr	s12, [pc, #152]	; 12f38 <at_handler+0x658>
   12ea0:	ed9d 7a0e 	vldr	s14, [sp, #56]	; 0x38
   12ea4:	ee67 7a86 	vmul.f32	s15, s15, s12
   12ea8:	eefd 6ac7 	vcvt.s32.f32	s13, s14
   12eac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   12eb0:	edcd 7a02 	vstr	s15, [sp, #8]
   12eb4:	eef8 7ae6 	vcvt.f32.s32	s15, s13
   12eb8:	ee37 7a67 	vsub.f32	s14, s14, s15
   12ebc:	ee27 7a06 	vmul.f32	s14, s14, s12
   12ec0:	2304      	movs	r3, #4
   12ec2:	f04f 0000 	mov.w	r0, #0
   12ec6:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   12eca:	f363 0007 	bfi	r0, r3, #0, #8
   12ece:	f364 108f 	bfi	r0, r4, #6, #10
   12ed2:	edcd 5a01 	vstr	s11, [sp, #4]
   12ed6:	ed8d 7a00 	vstr	s14, [sp]
   12eda:	ee16 3a90 	vmov	r3, s13
   12ede:	4a17      	ldr	r2, [pc, #92]	; (12f3c <at_handler+0x65c>)
   12ee0:	4917      	ldr	r1, [pc, #92]	; (12f40 <at_handler+0x660>)
   12ee2:	f020 fe89 	bl	33bf8 <log_string_sync>
   12ee6:	e730      	b.n	12d4a <at_handler+0x46a>
   12ee8:	47ae147b 	.word	0x47ae147b
   12eec:	40247ae1 	.word	0x40247ae1
   12ef0:	0003e66b 	.word	0x0003e66b
   12ef4:	0003e694 	.word	0x0003e694
   12ef8:	0003e50b 	.word	0x0003e50b
   12efc:	0003e6d7 	.word	0x0003e6d7
   12f00:	0003e6f0 	.word	0x0003e6f0
   12f04:	0003e715 	.word	0x0003e715
   12f08:	0003e82f 	.word	0x0003e82f
   12f0c:	4023d70a 	.word	0x4023d70a
   12f10:	0003e9ba 	.word	0x0003e9ba
   12f14:	3fa3d70a 	.word	0x3fa3d70a
   12f18:	0003e745 	.word	0x0003e745
   12f1c:	0003e771 	.word	0x0003e771
   12f20:	0003e79d 	.word	0x0003e79d
   12f24:	0003b3f0 	.word	0x0003b3f0
   12f28:	0003e7c1 	.word	0x0003e7c1
   12f2c:	0003b410 	.word	0x0003b410
   12f30:	40a3d70a 	.word	0x40a3d70a
   12f34:	0003e7ec 	.word	0x0003e7ec
   12f38:	42c80000 	.word	0x42c80000
   12f3c:	0003e524 	.word	0x0003e524
   12f40:	0003e809 	.word	0x0003e809
   12f44:	00000000 	.word	0x00000000

00012f48 <ceil>:
   12f48:	ec51 0b10 	vmov	r0, r1, d0
   12f4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   12f4e:	f3c1 530a 	ubfx	r3, r1, #20, #11
   12f52:	460c      	mov	r4, r1
   12f54:	ee10 6a10 	vmov	r6, s0
   12f58:	f2a3 35ff 	subw	r5, r3, #1023	; 0x3ff
   12f5c:	2d13      	cmp	r5, #19
   12f5e:	dc32      	bgt.n	12fc6 <ceil+0x7e>
   12f60:	2d00      	cmp	r5, #0
   12f62:	db1e      	blt.n	12fa2 <ceil+0x5a>
   12f64:	4f36      	ldr	r7, [pc, #216]	; (13040 <ceil+0xf8>)
   12f66:	412f      	asrs	r7, r5
   12f68:	ea07 0301 	and.w	r3, r7, r1
   12f6c:	4303      	orrs	r3, r0
   12f6e:	d02f      	beq.n	12fd0 <ceil+0x88>
   12f70:	a331      	add	r3, pc, #196	; (adr r3, 13038 <ceil+0xf0>)
   12f72:	e9d3 2300 	ldrd	r2, r3, [r3]
   12f76:	f7f9 fee3 	bl	cd40 <__adddf3>
   12f7a:	2200      	movs	r2, #0
   12f7c:	2300      	movs	r3, #0
   12f7e:	f7fa fb25 	bl	d5cc <__aeabi_dcmpgt>
   12f82:	b148      	cbz	r0, 12f98 <ceil+0x50>
   12f84:	2c00      	cmp	r4, #0
   12f86:	dd04      	ble.n	12f92 <ceil+0x4a>
   12f88:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   12f8c:	fa43 f505 	asr.w	r5, r3, r5
   12f90:	442c      	add	r4, r5
   12f92:	ea24 0407 	bic.w	r4, r4, r7
   12f96:	2600      	movs	r6, #0
   12f98:	4623      	mov	r3, r4
   12f9a:	4632      	mov	r2, r6
   12f9c:	ec43 2b10 	vmov	d0, r2, r3
   12fa0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12fa2:	a325      	add	r3, pc, #148	; (adr r3, 13038 <ceil+0xf0>)
   12fa4:	e9d3 2300 	ldrd	r2, r3, [r3]
   12fa8:	f7f9 feca 	bl	cd40 <__adddf3>
   12fac:	2200      	movs	r2, #0
   12fae:	2300      	movs	r3, #0
   12fb0:	f7fa fb0c 	bl	d5cc <__aeabi_dcmpgt>
   12fb4:	2800      	cmp	r0, #0
   12fb6:	d0ef      	beq.n	12f98 <ceil+0x50>
   12fb8:	2c00      	cmp	r4, #0
   12fba:	db39      	blt.n	13030 <ceil+0xe8>
   12fbc:	4326      	orrs	r6, r4
   12fbe:	d033      	beq.n	13028 <ceil+0xe0>
   12fc0:	2600      	movs	r6, #0
   12fc2:	4c20      	ldr	r4, [pc, #128]	; (13044 <ceil+0xfc>)
   12fc4:	e7e8      	b.n	12f98 <ceil+0x50>
   12fc6:	2d33      	cmp	r5, #51	; 0x33
   12fc8:	dd05      	ble.n	12fd6 <ceil+0x8e>
   12fca:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
   12fce:	d023      	beq.n	13018 <ceil+0xd0>
   12fd0:	ec41 0b10 	vmov	d0, r0, r1
   12fd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   12fd6:	f2a3 4313 	subw	r3, r3, #1043	; 0x413
   12fda:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   12fde:	40df      	lsrs	r7, r3
   12fe0:	4207      	tst	r7, r0
   12fe2:	d0f5      	beq.n	12fd0 <ceil+0x88>
   12fe4:	a314      	add	r3, pc, #80	; (adr r3, 13038 <ceil+0xf0>)
   12fe6:	e9d3 2300 	ldrd	r2, r3, [r3]
   12fea:	f7f9 fea9 	bl	cd40 <__adddf3>
   12fee:	2200      	movs	r2, #0
   12ff0:	2300      	movs	r3, #0
   12ff2:	f7fa faeb 	bl	d5cc <__aeabi_dcmpgt>
   12ff6:	2800      	cmp	r0, #0
   12ff8:	d0ce      	beq.n	12f98 <ceil+0x50>
   12ffa:	2c00      	cmp	r4, #0
   12ffc:	dd09      	ble.n	13012 <ceil+0xca>
   12ffe:	2d14      	cmp	r5, #20
   13000:	d014      	beq.n	1302c <ceil+0xe4>
   13002:	2301      	movs	r3, #1
   13004:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
   13008:	fa03 f505 	lsl.w	r5, r3, r5
   1300c:	19ae      	adds	r6, r5, r6
   1300e:	bf28      	it	cs
   13010:	18e4      	addcs	r4, r4, r3
   13012:	ea26 0607 	bic.w	r6, r6, r7
   13016:	e7bf      	b.n	12f98 <ceil+0x50>
   13018:	ee10 2a10 	vmov	r2, s0
   1301c:	460b      	mov	r3, r1
   1301e:	f7f9 fe8f 	bl	cd40 <__adddf3>
   13022:	ec41 0b10 	vmov	d0, r0, r1
   13026:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13028:	4634      	mov	r4, r6
   1302a:	e7b5      	b.n	12f98 <ceil+0x50>
   1302c:	3401      	adds	r4, #1
   1302e:	e7f0      	b.n	13012 <ceil+0xca>
   13030:	2600      	movs	r6, #0
   13032:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
   13036:	e7af      	b.n	12f98 <ceil+0x50>
   13038:	8800759c 	.word	0x8800759c
   1303c:	7e37e43c 	.word	0x7e37e43c
   13040:	000fffff 	.word	0x000fffff
   13044:	3ff00000 	.word	0x3ff00000

00013048 <floor>:
   13048:	ec51 0b10 	vmov	r0, r1, d0
   1304c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1304e:	f3c1 530a 	ubfx	r3, r1, #20, #11
   13052:	460c      	mov	r4, r1
   13054:	ee10 6a10 	vmov	r6, s0
   13058:	f2a3 35ff 	subw	r5, r3, #1023	; 0x3ff
   1305c:	2d13      	cmp	r5, #19
   1305e:	dc30      	bgt.n	130c2 <floor+0x7a>
   13060:	2d00      	cmp	r5, #0
   13062:	db1e      	blt.n	130a2 <floor+0x5a>
   13064:	4f38      	ldr	r7, [pc, #224]	; (13148 <floor+0x100>)
   13066:	412f      	asrs	r7, r5
   13068:	ea07 0301 	and.w	r3, r7, r1
   1306c:	4303      	orrs	r3, r0
   1306e:	d02d      	beq.n	130cc <floor+0x84>
   13070:	a333      	add	r3, pc, #204	; (adr r3, 13140 <floor+0xf8>)
   13072:	e9d3 2300 	ldrd	r2, r3, [r3]
   13076:	f7f9 fe63 	bl	cd40 <__adddf3>
   1307a:	2200      	movs	r2, #0
   1307c:	2300      	movs	r3, #0
   1307e:	f7fa faa5 	bl	d5cc <__aeabi_dcmpgt>
   13082:	b148      	cbz	r0, 13098 <floor+0x50>
   13084:	2c00      	cmp	r4, #0
   13086:	da04      	bge.n	13092 <floor+0x4a>
   13088:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   1308c:	fa43 f505 	asr.w	r5, r3, r5
   13090:	442c      	add	r4, r5
   13092:	ea24 0407 	bic.w	r4, r4, r7
   13096:	2600      	movs	r6, #0
   13098:	4623      	mov	r3, r4
   1309a:	4632      	mov	r2, r6
   1309c:	ec43 2b10 	vmov	d0, r2, r3
   130a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   130a2:	a327      	add	r3, pc, #156	; (adr r3, 13140 <floor+0xf8>)
   130a4:	e9d3 2300 	ldrd	r2, r3, [r3]
   130a8:	f7f9 fe4a 	bl	cd40 <__adddf3>
   130ac:	2200      	movs	r2, #0
   130ae:	2300      	movs	r3, #0
   130b0:	f7fa fa8c 	bl	d5cc <__aeabi_dcmpgt>
   130b4:	2800      	cmp	r0, #0
   130b6:	d0ef      	beq.n	13098 <floor+0x50>
   130b8:	2c00      	cmp	r4, #0
   130ba:	db29      	blt.n	13110 <floor+0xc8>
   130bc:	2600      	movs	r6, #0
   130be:	4634      	mov	r4, r6
   130c0:	e7ea      	b.n	13098 <floor+0x50>
   130c2:	2d33      	cmp	r5, #51	; 0x33
   130c4:	dd05      	ble.n	130d2 <floor+0x8a>
   130c6:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
   130ca:	d019      	beq.n	13100 <floor+0xb8>
   130cc:	ec41 0b10 	vmov	d0, r0, r1
   130d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   130d2:	f2a3 4313 	subw	r3, r3, #1043	; 0x413
   130d6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   130da:	40df      	lsrs	r7, r3
   130dc:	4207      	tst	r7, r0
   130de:	d0f5      	beq.n	130cc <floor+0x84>
   130e0:	a317      	add	r3, pc, #92	; (adr r3, 13140 <floor+0xf8>)
   130e2:	e9d3 2300 	ldrd	r2, r3, [r3]
   130e6:	f7f9 fe2b 	bl	cd40 <__adddf3>
   130ea:	2200      	movs	r2, #0
   130ec:	2300      	movs	r3, #0
   130ee:	f7fa fa6d 	bl	d5cc <__aeabi_dcmpgt>
   130f2:	2800      	cmp	r0, #0
   130f4:	d0d0      	beq.n	13098 <floor+0x50>
   130f6:	2c00      	cmp	r4, #0
   130f8:	db13      	blt.n	13122 <floor+0xda>
   130fa:	ea26 0607 	bic.w	r6, r6, r7
   130fe:	e7cb      	b.n	13098 <floor+0x50>
   13100:	ee10 2a10 	vmov	r2, s0
   13104:	460b      	mov	r3, r1
   13106:	f7f9 fe1b 	bl	cd40 <__adddf3>
   1310a:	ec41 0b10 	vmov	d0, r0, r1
   1310e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   13110:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
   13114:	4a0d      	ldr	r2, [pc, #52]	; (1314c <floor+0x104>)
   13116:	4333      	orrs	r3, r6
   13118:	2600      	movs	r6, #0
   1311a:	42b3      	cmp	r3, r6
   1311c:	bf18      	it	ne
   1311e:	4614      	movne	r4, r2
   13120:	e7ba      	b.n	13098 <floor+0x50>
   13122:	2d14      	cmp	r5, #20
   13124:	d008      	beq.n	13138 <floor+0xf0>
   13126:	2301      	movs	r3, #1
   13128:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
   1312c:	fa03 f505 	lsl.w	r5, r3, r5
   13130:	19ae      	adds	r6, r5, r6
   13132:	bf28      	it	cs
   13134:	18e4      	addcs	r4, r4, r3
   13136:	e7e0      	b.n	130fa <floor+0xb2>
   13138:	3401      	adds	r4, #1
   1313a:	e7de      	b.n	130fa <floor+0xb2>
   1313c:	f3af 8000 	nop.w
   13140:	8800759c 	.word	0x8800759c
   13144:	7e37e43c 	.word	0x7e37e43c
   13148:	000fffff 	.word	0x000fffff
   1314c:	bff00000 	.word	0xbff00000

00013150 <pow>:
   13150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   13152:	ed2d 8b02 	vpush	{d8}
   13156:	ec57 6b10 	vmov	r6, r7, d0
   1315a:	ec55 4b11 	vmov	r4, r5, d1
   1315e:	f000 f8c7 	bl	132f0 <__ieee754_pow>
   13162:	4b61      	ldr	r3, [pc, #388]	; (132e8 <pow+0x198>)
   13164:	eeb0 8a40 	vmov.f32	s16, s0
   13168:	eef0 8a60 	vmov.f32	s17, s1
   1316c:	f993 3000 	ldrsb.w	r3, [r3]
   13170:	3301      	adds	r3, #1
   13172:	d02a      	beq.n	131ca <pow+0x7a>
   13174:	4622      	mov	r2, r4
   13176:	462b      	mov	r3, r5
   13178:	4620      	mov	r0, r4
   1317a:	4629      	mov	r1, r5
   1317c:	f7fe fdfc 	bl	11d78 <__aeabi_dcmpun>
   13180:	bb18      	cbnz	r0, 131ca <pow+0x7a>
   13182:	4632      	mov	r2, r6
   13184:	463b      	mov	r3, r7
   13186:	4630      	mov	r0, r6
   13188:	4639      	mov	r1, r7
   1318a:	f7fe fdf5 	bl	11d78 <__aeabi_dcmpun>
   1318e:	2800      	cmp	r0, #0
   13190:	d144      	bne.n	1321c <pow+0xcc>
   13192:	2200      	movs	r2, #0
   13194:	2300      	movs	r3, #0
   13196:	4630      	mov	r0, r6
   13198:	4639      	mov	r1, r7
   1319a:	f7fa f9ef 	bl	d57c <__aeabi_dcmpeq>
   1319e:	b1d8      	cbz	r0, 131d8 <pow+0x88>
   131a0:	2200      	movs	r2, #0
   131a2:	2300      	movs	r3, #0
   131a4:	4620      	mov	r0, r4
   131a6:	4629      	mov	r1, r5
   131a8:	f7fa f9e8 	bl	d57c <__aeabi_dcmpeq>
   131ac:	2800      	cmp	r0, #0
   131ae:	d13d      	bne.n	1322c <pow+0xdc>
   131b0:	ec45 4b10 	vmov	d0, r4, r5
   131b4:	f01d fed2 	bl	30f5c <finite>
   131b8:	b138      	cbz	r0, 131ca <pow+0x7a>
   131ba:	4620      	mov	r0, r4
   131bc:	4629      	mov	r1, r5
   131be:	2200      	movs	r2, #0
   131c0:	2300      	movs	r3, #0
   131c2:	f7fa f9e5 	bl	d590 <__aeabi_dcmplt>
   131c6:	2800      	cmp	r0, #0
   131c8:	d15b      	bne.n	13282 <pow+0x132>
   131ca:	eeb0 0a48 	vmov.f32	s0, s16
   131ce:	eef0 0a68 	vmov.f32	s1, s17
   131d2:	ecbd 8b02 	vpop	{d8}
   131d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   131d8:	eeb0 0a48 	vmov.f32	s0, s16
   131dc:	eef0 0a68 	vmov.f32	s1, s17
   131e0:	f01d febc 	bl	30f5c <finite>
   131e4:	b358      	cbz	r0, 1323e <pow+0xee>
   131e6:	2200      	movs	r2, #0
   131e8:	2300      	movs	r3, #0
   131ea:	ec51 0b18 	vmov	r0, r1, d8
   131ee:	f7fa f9c5 	bl	d57c <__aeabi_dcmpeq>
   131f2:	2800      	cmp	r0, #0
   131f4:	d0e9      	beq.n	131ca <pow+0x7a>
   131f6:	ec47 6b10 	vmov	d0, r6, r7
   131fa:	f01d feaf 	bl	30f5c <finite>
   131fe:	2800      	cmp	r0, #0
   13200:	d0e3      	beq.n	131ca <pow+0x7a>
   13202:	ec45 4b10 	vmov	d0, r4, r5
   13206:	f01d fea9 	bl	30f5c <finite>
   1320a:	2800      	cmp	r0, #0
   1320c:	d0dd      	beq.n	131ca <pow+0x7a>
   1320e:	f022 f96b 	bl	354e8 <__errno>
   13212:	2322      	movs	r3, #34	; 0x22
   13214:	ed9f 8b2c 	vldr	d8, [pc, #176]	; 132c8 <pow+0x178>
   13218:	6003      	str	r3, [r0, #0]
   1321a:	e7d6      	b.n	131ca <pow+0x7a>
   1321c:	4620      	mov	r0, r4
   1321e:	4629      	mov	r1, r5
   13220:	2200      	movs	r2, #0
   13222:	2300      	movs	r3, #0
   13224:	f7fa f9aa 	bl	d57c <__aeabi_dcmpeq>
   13228:	2800      	cmp	r0, #0
   1322a:	d0ce      	beq.n	131ca <pow+0x7a>
   1322c:	ed9f 8b28 	vldr	d8, [pc, #160]	; 132d0 <pow+0x180>
   13230:	eeb0 0a48 	vmov.f32	s0, s16
   13234:	eef0 0a68 	vmov.f32	s1, s17
   13238:	ecbd 8b02 	vpop	{d8}
   1323c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1323e:	ec47 6b10 	vmov	d0, r6, r7
   13242:	f01d fe8b 	bl	30f5c <finite>
   13246:	2800      	cmp	r0, #0
   13248:	d0cd      	beq.n	131e6 <pow+0x96>
   1324a:	ec45 4b10 	vmov	d0, r4, r5
   1324e:	f01d fe85 	bl	30f5c <finite>
   13252:	2800      	cmp	r0, #0
   13254:	d0c7      	beq.n	131e6 <pow+0x96>
   13256:	ee18 0a10 	vmov	r0, s16
   1325a:	ec53 2b18 	vmov	r2, r3, d8
   1325e:	4619      	mov	r1, r3
   13260:	f7fe fd8a 	bl	11d78 <__aeabi_dcmpun>
   13264:	bb18      	cbnz	r0, 132ae <pow+0x15e>
   13266:	f022 f93f 	bl	354e8 <__errno>
   1326a:	2322      	movs	r3, #34	; 0x22
   1326c:	2200      	movs	r2, #0
   1326e:	4639      	mov	r1, r7
   13270:	6003      	str	r3, [r0, #0]
   13272:	2300      	movs	r3, #0
   13274:	4630      	mov	r0, r6
   13276:	f7fa f98b 	bl	d590 <__aeabi_dcmplt>
   1327a:	b948      	cbnz	r0, 13290 <pow+0x140>
   1327c:	ed9f 8b16 	vldr	d8, [pc, #88]	; 132d8 <pow+0x188>
   13280:	e7a3      	b.n	131ca <pow+0x7a>
   13282:	f022 f931 	bl	354e8 <__errno>
   13286:	2321      	movs	r3, #33	; 0x21
   13288:	ed9f 8b15 	vldr	d8, [pc, #84]	; 132e0 <pow+0x190>
   1328c:	6003      	str	r3, [r0, #0]
   1328e:	e79c      	b.n	131ca <pow+0x7a>
   13290:	ec45 4b10 	vmov	d0, r4, r5
   13294:	f01d fe6c 	bl	30f70 <rint>
   13298:	4622      	mov	r2, r4
   1329a:	462b      	mov	r3, r5
   1329c:	ec51 0b10 	vmov	r0, r1, d0
   132a0:	f7fa f96c 	bl	d57c <__aeabi_dcmpeq>
   132a4:	2800      	cmp	r0, #0
   132a6:	d1e9      	bne.n	1327c <pow+0x12c>
   132a8:	ed9f 8b0d 	vldr	d8, [pc, #52]	; 132e0 <pow+0x190>
   132ac:	e78d      	b.n	131ca <pow+0x7a>
   132ae:	f022 f91b 	bl	354e8 <__errno>
   132b2:	2121      	movs	r1, #33	; 0x21
   132b4:	2200      	movs	r2, #0
   132b6:	2300      	movs	r3, #0
   132b8:	6001      	str	r1, [r0, #0]
   132ba:	4610      	mov	r0, r2
   132bc:	4619      	mov	r1, r3
   132be:	f7fa f81f 	bl	d300 <__aeabi_ddiv>
   132c2:	ec41 0b18 	vmov	d8, r0, r1
   132c6:	e780      	b.n	131ca <pow+0x7a>
	...
   132d4:	3ff00000 	.word	0x3ff00000
   132d8:	00000000 	.word	0x00000000
   132dc:	7ff00000 	.word	0x7ff00000
   132e0:	00000000 	.word	0x00000000
   132e4:	fff00000 	.word	0xfff00000
   132e8:	20020502 	.word	0x20020502
   132ec:	00000000 	.word	0x00000000

000132f0 <__ieee754_pow>:
   132f0:	ec51 0b11 	vmov	r0, r1, d1
   132f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   132f8:	f021 4800 	bic.w	r8, r1, #2147483648	; 0x80000000
   132fc:	b093      	sub	sp, #76	; 0x4c
   132fe:	ea58 0400 	orrs.w	r4, r8, r0
   13302:	d020      	beq.n	13346 <__ieee754_pow+0x56>
   13304:	4c5c      	ldr	r4, [pc, #368]	; (13478 <__ieee754_pow+0x188>)
   13306:	ee10 aa10 	vmov	sl, s0
   1330a:	ec53 2b10 	vmov	r2, r3, d0
   1330e:	f023 4600 	bic.w	r6, r3, #2147483648	; 0x80000000
   13312:	461f      	mov	r7, r3
   13314:	42a6      	cmp	r6, r4
   13316:	dc11      	bgt.n	1333c <__ieee754_pow+0x4c>
   13318:	4689      	mov	r9, r1
   1331a:	ee11 ca10 	vmov	ip, s2
   1331e:	d106      	bne.n	1332e <__ieee754_pow+0x3e>
   13320:	b12a      	cbz	r2, 1332e <__ieee754_pow+0x3e>
   13322:	4856      	ldr	r0, [pc, #344]	; (1347c <__ieee754_pow+0x18c>)
   13324:	b013      	add	sp, #76	; 0x4c
   13326:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1332a:	f000 bd61 	b.w	13df0 <nan>
   1332e:	4c52      	ldr	r4, [pc, #328]	; (13478 <__ieee754_pow+0x188>)
   13330:	45a0      	cmp	r8, r4
   13332:	dc03      	bgt.n	1333c <__ieee754_pow+0x4c>
   13334:	d10e      	bne.n	13354 <__ieee754_pow+0x64>
   13336:	f1bc 0f00 	cmp.w	ip, #0
   1333a:	d00b      	beq.n	13354 <__ieee754_pow+0x64>
   1333c:	4b50      	ldr	r3, [pc, #320]	; (13480 <__ieee754_pow+0x190>)
   1333e:	4433      	add	r3, r6
   13340:	ea53 030a 	orrs.w	r3, r3, sl
   13344:	d1ed      	bne.n	13322 <__ieee754_pow+0x32>
   13346:	2000      	movs	r0, #0
   13348:	494e      	ldr	r1, [pc, #312]	; (13484 <__ieee754_pow+0x194>)
   1334a:	ec41 0b10 	vmov	d0, r0, r1
   1334e:	b013      	add	sp, #76	; 0x4c
   13350:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13354:	2f00      	cmp	r7, #0
   13356:	4614      	mov	r4, r2
   13358:	461d      	mov	r5, r3
   1335a:	e9cd 0100 	strd	r0, r1, [sp]
   1335e:	db44      	blt.n	133ea <__ieee754_pow+0xfa>
   13360:	f04f 0b00 	mov.w	fp, #0
   13364:	f1bc 0f00 	cmp.w	ip, #0
   13368:	d10f      	bne.n	1338a <__ieee754_pow+0x9a>
   1336a:	4b43      	ldr	r3, [pc, #268]	; (13478 <__ieee754_pow+0x188>)
   1336c:	4598      	cmp	r8, r3
   1336e:	d057      	beq.n	13420 <__ieee754_pow+0x130>
   13370:	4b44      	ldr	r3, [pc, #272]	; (13484 <__ieee754_pow+0x194>)
   13372:	4598      	cmp	r8, r3
   13374:	d067      	beq.n	13446 <__ieee754_pow+0x156>
   13376:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
   1337a:	f000 84a9 	beq.w	13cd0 <__ieee754_pow+0x9e0>
   1337e:	4b42      	ldr	r3, [pc, #264]	; (13488 <__ieee754_pow+0x198>)
   13380:	4599      	cmp	r9, r3
   13382:	d102      	bne.n	1338a <__ieee754_pow+0x9a>
   13384:	2f00      	cmp	r7, #0
   13386:	f280 84f1 	bge.w	13d6c <__ieee754_pow+0xa7c>
   1338a:	ec45 4b10 	vmov	d0, r4, r5
   1338e:	f01c f849 	bl	2f424 <fabs>
   13392:	ec51 0b10 	vmov	r0, r1, d0
   13396:	f1ba 0f00 	cmp.w	sl, #0
   1339a:	d108      	bne.n	133ae <__ieee754_pow+0xbe>
   1339c:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
   133a0:	4a38      	ldr	r2, [pc, #224]	; (13484 <__ieee754_pow+0x194>)
   133a2:	4293      	cmp	r3, r2
   133a4:	f000 8395 	beq.w	13ad2 <__ieee754_pow+0x7e2>
   133a8:	2e00      	cmp	r6, #0
   133aa:	f000 8392 	beq.w	13ad2 <__ieee754_pow+0x7e2>
   133ae:	0ffb      	lsrs	r3, r7, #31
   133b0:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
   133b4:	ea5b 030a 	orrs.w	r3, fp, sl
   133b8:	d04c      	beq.n	13454 <__ieee754_pow+0x164>
   133ba:	4b34      	ldr	r3, [pc, #208]	; (1348c <__ieee754_pow+0x19c>)
   133bc:	4598      	cmp	r8, r3
   133be:	dd6b      	ble.n	13498 <__ieee754_pow+0x1a8>
   133c0:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
   133c4:	4598      	cmp	r8, r3
   133c6:	f340 8411 	ble.w	13bec <__ieee754_pow+0x8fc>
   133ca:	4b31      	ldr	r3, [pc, #196]	; (13490 <__ieee754_pow+0x1a0>)
   133cc:	429e      	cmp	r6, r3
   133ce:	f340 8395 	ble.w	13afc <__ieee754_pow+0x80c>
   133d2:	f1b9 0f00 	cmp.w	r9, #0
   133d6:	f340 8395 	ble.w	13b04 <__ieee754_pow+0x814>
   133da:	a325      	add	r3, pc, #148	; (adr r3, 13470 <__ieee754_pow+0x180>)
   133dc:	e9d3 2300 	ldrd	r2, r3, [r3]
   133e0:	4610      	mov	r0, r2
   133e2:	4619      	mov	r1, r3
   133e4:	f7f9 fe62 	bl	d0ac <__aeabi_dmul>
   133e8:	e7af      	b.n	1334a <__ieee754_pow+0x5a>
   133ea:	4b2a      	ldr	r3, [pc, #168]	; (13494 <__ieee754_pow+0x1a4>)
   133ec:	4598      	cmp	r8, r3
   133ee:	dc27      	bgt.n	13440 <__ieee754_pow+0x150>
   133f0:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
   133f4:	4598      	cmp	r8, r3
   133f6:	ddb3      	ble.n	13360 <__ieee754_pow+0x70>
   133f8:	ea4f 5328 	mov.w	r3, r8, asr #20
   133fc:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   13400:	2b14      	cmp	r3, #20
   13402:	f340 846d 	ble.w	13ce0 <__ieee754_pow+0x9f0>
   13406:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
   1340a:	fa2c f203 	lsr.w	r2, ip, r3
   1340e:	fa02 f303 	lsl.w	r3, r2, r3
   13412:	4563      	cmp	r3, ip
   13414:	d1a4      	bne.n	13360 <__ieee754_pow+0x70>
   13416:	f002 0201 	and.w	r2, r2, #1
   1341a:	f1c2 0b02 	rsb	fp, r2, #2
   1341e:	e7a1      	b.n	13364 <__ieee754_pow+0x74>
   13420:	4b17      	ldr	r3, [pc, #92]	; (13480 <__ieee754_pow+0x190>)
   13422:	4433      	add	r3, r6
   13424:	ea53 030a 	orrs.w	r3, r3, sl
   13428:	d08d      	beq.n	13346 <__ieee754_pow+0x56>
   1342a:	4b19      	ldr	r3, [pc, #100]	; (13490 <__ieee754_pow+0x1a0>)
   1342c:	429e      	cmp	r6, r3
   1342e:	f340 8394 	ble.w	13b5a <__ieee754_pow+0x86a>
   13432:	f1b9 0f00 	cmp.w	r9, #0
   13436:	f2c0 8365 	blt.w	13b04 <__ieee754_pow+0x814>
   1343a:	e9dd 0100 	ldrd	r0, r1, [sp]
   1343e:	e784      	b.n	1334a <__ieee754_pow+0x5a>
   13440:	f04f 0b02 	mov.w	fp, #2
   13444:	e78e      	b.n	13364 <__ieee754_pow+0x74>
   13446:	f1b9 0f00 	cmp.w	r9, #0
   1344a:	f2c0 8439 	blt.w	13cc0 <__ieee754_pow+0x9d0>
   1344e:	4620      	mov	r0, r4
   13450:	4629      	mov	r1, r5
   13452:	e77a      	b.n	1334a <__ieee754_pow+0x5a>
   13454:	4622      	mov	r2, r4
   13456:	462b      	mov	r3, r5
   13458:	4610      	mov	r0, r2
   1345a:	4619      	mov	r1, r3
   1345c:	f7f9 fc6e 	bl	cd3c <__aeabi_dsub>
   13460:	4602      	mov	r2, r0
   13462:	460b      	mov	r3, r1
   13464:	f7f9 ff4c 	bl	d300 <__aeabi_ddiv>
   13468:	e76f      	b.n	1334a <__ieee754_pow+0x5a>
   1346a:	bf00      	nop
   1346c:	f3af 8000 	nop.w
   13470:	8800759c 	.word	0x8800759c
   13474:	7e37e43c 	.word	0x7e37e43c
   13478:	7ff00000 	.word	0x7ff00000
   1347c:	0003aa18 	.word	0x0003aa18
   13480:	c0100000 	.word	0xc0100000
   13484:	3ff00000 	.word	0x3ff00000
   13488:	3fe00000 	.word	0x3fe00000
   1348c:	41e00000 	.word	0x41e00000
   13490:	3fefffff 	.word	0x3fefffff
   13494:	433fffff 	.word	0x433fffff
   13498:	4bd3      	ldr	r3, [pc, #844]	; (137e8 <__ieee754_pow+0x4f8>)
   1349a:	403b      	ands	r3, r7
   1349c:	2b00      	cmp	r3, #0
   1349e:	f040 840c 	bne.w	13cba <__ieee754_pow+0x9ca>
   134a2:	2200      	movs	r2, #0
   134a4:	4bd1      	ldr	r3, [pc, #836]	; (137ec <__ieee754_pow+0x4fc>)
   134a6:	f7f9 fe01 	bl	d0ac <__aeabi_dmul>
   134aa:	f06f 0534 	mvn.w	r5, #52	; 0x34
   134ae:	460e      	mov	r6, r1
   134b0:	1533      	asrs	r3, r6, #20
   134b2:	4acf      	ldr	r2, [pc, #828]	; (137f0 <__ieee754_pow+0x500>)
   134b4:	f3c6 0613 	ubfx	r6, r6, #0, #20
   134b8:	4cce      	ldr	r4, [pc, #824]	; (137f4 <__ieee754_pow+0x504>)
   134ba:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
   134be:	4296      	cmp	r6, r2
   134c0:	ea44 0406 	orr.w	r4, r4, r6
   134c4:	441d      	add	r5, r3
   134c6:	950b      	str	r5, [sp, #44]	; 0x2c
   134c8:	f340 83eb 	ble.w	13ca2 <__ieee754_pow+0x9b2>
   134cc:	4bca      	ldr	r3, [pc, #808]	; (137f8 <__ieee754_pow+0x508>)
   134ce:	429e      	cmp	r6, r3
   134d0:	f340 842b 	ble.w	13d2a <__ieee754_pow+0xa3a>
   134d4:	3501      	adds	r5, #1
   134d6:	f5a4 1480 	sub.w	r4, r4, #1048576	; 0x100000
   134da:	ed9f 7bad 	vldr	d7, [pc, #692]	; 13790 <__ieee754_pow+0x4a0>
   134de:	950b      	str	r5, [sp, #44]	; 0x2c
   134e0:	2500      	movs	r5, #0
   134e2:	ed8d 7b08 	vstr	d7, [sp, #32]
   134e6:	ed9f 7bac 	vldr	d7, [pc, #688]	; 13798 <__ieee754_pow+0x4a8>
   134ea:	ed8d 7b06 	vstr	d7, [sp, #24]
   134ee:	ed9f 7ba8 	vldr	d7, [pc, #672]	; 13790 <__ieee754_pow+0x4a0>
   134f2:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   134f6:	4680      	mov	r8, r0
   134f8:	46a1      	mov	r9, r4
   134fa:	4621      	mov	r1, r4
   134fc:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   13500:	f7f9 fc1c 	bl	cd3c <__aeabi_dsub>
   13504:	4606      	mov	r6, r0
   13506:	460f      	mov	r7, r1
   13508:	4640      	mov	r0, r8
   1350a:	4621      	mov	r1, r4
   1350c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   13510:	e9cd 890c 	strd	r8, r9, [sp, #48]	; 0x30
   13514:	f7f9 fc14 	bl	cd40 <__adddf3>
   13518:	4602      	mov	r2, r0
   1351a:	460b      	mov	r3, r1
   1351c:	2000      	movs	r0, #0
   1351e:	49b5      	ldr	r1, [pc, #724]	; (137f4 <__ieee754_pow+0x504>)
   13520:	f7f9 feee 	bl	d300 <__aeabi_ddiv>
   13524:	460a      	mov	r2, r1
   13526:	4601      	mov	r1, r0
   13528:	4613      	mov	r3, r2
   1352a:	e9cd 120e 	strd	r1, r2, [sp, #56]	; 0x38
   1352e:	4602      	mov	r2, r0
   13530:	4639      	mov	r1, r7
   13532:	4630      	mov	r0, r6
   13534:	f7f9 fdba 	bl	d0ac <__aeabi_dmul>
   13538:	4680      	mov	r8, r0
   1353a:	1063      	asrs	r3, r4, #1
   1353c:	4689      	mov	r9, r1
   1353e:	2400      	movs	r4, #0
   13540:	2000      	movs	r0, #0
   13542:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   13546:	4602      	mov	r2, r0
   13548:	f503 2300 	add.w	r3, r3, #524288	; 0x80000
   1354c:	e9cd 8902 	strd	r8, r9, [sp, #8]
   13550:	9402      	str	r4, [sp, #8]
   13552:	1959      	adds	r1, r3, r5
   13554:	4604      	mov	r4, r0
   13556:	460d      	mov	r5, r1
   13558:	460b      	mov	r3, r1
   1355a:	e9cd 8904 	strd	r8, r9, [sp, #16]
   1355e:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
   13562:	4640      	mov	r0, r8
   13564:	4649      	mov	r1, r9
   13566:	f7f9 fda1 	bl	d0ac <__aeabi_dmul>
   1356a:	4602      	mov	r2, r0
   1356c:	460b      	mov	r3, r1
   1356e:	4630      	mov	r0, r6
   13570:	4639      	mov	r1, r7
   13572:	f7f9 fbe3 	bl	cd3c <__aeabi_dsub>
   13576:	4606      	mov	r6, r0
   13578:	460f      	mov	r7, r1
   1357a:	4620      	mov	r0, r4
   1357c:	4629      	mov	r1, r5
   1357e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   13582:	f7f9 fbdb 	bl	cd3c <__aeabi_dsub>
   13586:	4602      	mov	r2, r0
   13588:	460b      	mov	r3, r1
   1358a:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
   1358e:	f7f9 fbd5 	bl	cd3c <__aeabi_dsub>
   13592:	4642      	mov	r2, r8
   13594:	464b      	mov	r3, r9
   13596:	f7f9 fd89 	bl	d0ac <__aeabi_dmul>
   1359a:	4602      	mov	r2, r0
   1359c:	460b      	mov	r3, r1
   1359e:	4630      	mov	r0, r6
   135a0:	4639      	mov	r1, r7
   135a2:	f7f9 fbcb 	bl	cd3c <__aeabi_dsub>
   135a6:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
   135aa:	f7f9 fd7f 	bl	d0ac <__aeabi_dmul>
   135ae:	e9dd 4504 	ldrd	r4, r5, [sp, #16]
   135b2:	e9cd 0106 	strd	r0, r1, [sp, #24]
   135b6:	4622      	mov	r2, r4
   135b8:	462b      	mov	r3, r5
   135ba:	4620      	mov	r0, r4
   135bc:	4629      	mov	r1, r5
   135be:	f7f9 fd75 	bl	d0ac <__aeabi_dmul>
   135c2:	4604      	mov	r4, r0
   135c4:	460d      	mov	r5, r1
   135c6:	a376      	add	r3, pc, #472	; (adr r3, 137a0 <__ieee754_pow+0x4b0>)
   135c8:	e9d3 2300 	ldrd	r2, r3, [r3]
   135cc:	f7f9 fd6e 	bl	d0ac <__aeabi_dmul>
   135d0:	a375      	add	r3, pc, #468	; (adr r3, 137a8 <__ieee754_pow+0x4b8>)
   135d2:	e9d3 2300 	ldrd	r2, r3, [r3]
   135d6:	f7f9 fbb3 	bl	cd40 <__adddf3>
   135da:	4622      	mov	r2, r4
   135dc:	462b      	mov	r3, r5
   135de:	f7f9 fd65 	bl	d0ac <__aeabi_dmul>
   135e2:	a373      	add	r3, pc, #460	; (adr r3, 137b0 <__ieee754_pow+0x4c0>)
   135e4:	e9d3 2300 	ldrd	r2, r3, [r3]
   135e8:	f7f9 fbaa 	bl	cd40 <__adddf3>
   135ec:	4622      	mov	r2, r4
   135ee:	462b      	mov	r3, r5
   135f0:	f7f9 fd5c 	bl	d0ac <__aeabi_dmul>
   135f4:	a370      	add	r3, pc, #448	; (adr r3, 137b8 <__ieee754_pow+0x4c8>)
   135f6:	e9d3 2300 	ldrd	r2, r3, [r3]
   135fa:	f7f9 fba1 	bl	cd40 <__adddf3>
   135fe:	4622      	mov	r2, r4
   13600:	462b      	mov	r3, r5
   13602:	f7f9 fd53 	bl	d0ac <__aeabi_dmul>
   13606:	a36e      	add	r3, pc, #440	; (adr r3, 137c0 <__ieee754_pow+0x4d0>)
   13608:	e9d3 2300 	ldrd	r2, r3, [r3]
   1360c:	f7f9 fb98 	bl	cd40 <__adddf3>
   13610:	4622      	mov	r2, r4
   13612:	462b      	mov	r3, r5
   13614:	f7f9 fd4a 	bl	d0ac <__aeabi_dmul>
   13618:	a36b      	add	r3, pc, #428	; (adr r3, 137c8 <__ieee754_pow+0x4d8>)
   1361a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1361e:	f7f9 fb8f 	bl	cd40 <__adddf3>
   13622:	4606      	mov	r6, r0
   13624:	460f      	mov	r7, r1
   13626:	4622      	mov	r2, r4
   13628:	462b      	mov	r3, r5
   1362a:	4620      	mov	r0, r4
   1362c:	4629      	mov	r1, r5
   1362e:	f7f9 fd3d 	bl	d0ac <__aeabi_dmul>
   13632:	4602      	mov	r2, r0
   13634:	460b      	mov	r3, r1
   13636:	4630      	mov	r0, r6
   13638:	4639      	mov	r1, r7
   1363a:	f7f9 fd37 	bl	d0ac <__aeabi_dmul>
   1363e:	4642      	mov	r2, r8
   13640:	4604      	mov	r4, r0
   13642:	460d      	mov	r5, r1
   13644:	464b      	mov	r3, r9
   13646:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1364a:	f7f9 fb79 	bl	cd40 <__adddf3>
   1364e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   13652:	f7f9 fd2b 	bl	d0ac <__aeabi_dmul>
   13656:	4622      	mov	r2, r4
   13658:	462b      	mov	r3, r5
   1365a:	f7f9 fb71 	bl	cd40 <__adddf3>
   1365e:	4642      	mov	r2, r8
   13660:	4604      	mov	r4, r0
   13662:	460d      	mov	r5, r1
   13664:	464b      	mov	r3, r9
   13666:	4640      	mov	r0, r8
   13668:	4649      	mov	r1, r9
   1366a:	f7f9 fd1f 	bl	d0ac <__aeabi_dmul>
   1366e:	2200      	movs	r2, #0
   13670:	4b62      	ldr	r3, [pc, #392]	; (137fc <__ieee754_pow+0x50c>)
   13672:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
   13676:	f7f9 fb63 	bl	cd40 <__adddf3>
   1367a:	4622      	mov	r2, r4
   1367c:	462b      	mov	r3, r5
   1367e:	f7f9 fb5f 	bl	cd40 <__adddf3>
   13682:	9802      	ldr	r0, [sp, #8]
   13684:	460f      	mov	r7, r1
   13686:	4649      	mov	r1, r9
   13688:	4606      	mov	r6, r0
   1368a:	4640      	mov	r0, r8
   1368c:	463b      	mov	r3, r7
   1368e:	4632      	mov	r2, r6
   13690:	f7f9 fd0c 	bl	d0ac <__aeabi_dmul>
   13694:	2200      	movs	r2, #0
   13696:	4680      	mov	r8, r0
   13698:	4689      	mov	r9, r1
   1369a:	4b58      	ldr	r3, [pc, #352]	; (137fc <__ieee754_pow+0x50c>)
   1369c:	4630      	mov	r0, r6
   1369e:	4639      	mov	r1, r7
   136a0:	f7f9 fb4c 	bl	cd3c <__aeabi_dsub>
   136a4:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
   136a8:	f7f9 fb48 	bl	cd3c <__aeabi_dsub>
   136ac:	4602      	mov	r2, r0
   136ae:	460b      	mov	r3, r1
   136b0:	4620      	mov	r0, r4
   136b2:	4629      	mov	r1, r5
   136b4:	f7f9 fb42 	bl	cd3c <__aeabi_dsub>
   136b8:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   136bc:	f7f9 fcf6 	bl	d0ac <__aeabi_dmul>
   136c0:	4604      	mov	r4, r0
   136c2:	460d      	mov	r5, r1
   136c4:	4632      	mov	r2, r6
   136c6:	463b      	mov	r3, r7
   136c8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
   136cc:	f7f9 fcee 	bl	d0ac <__aeabi_dmul>
   136d0:	4602      	mov	r2, r0
   136d2:	460b      	mov	r3, r1
   136d4:	4620      	mov	r0, r4
   136d6:	4629      	mov	r1, r5
   136d8:	f7f9 fb32 	bl	cd40 <__adddf3>
   136dc:	4604      	mov	r4, r0
   136de:	460d      	mov	r5, r1
   136e0:	4602      	mov	r2, r0
   136e2:	460b      	mov	r3, r1
   136e4:	4640      	mov	r0, r8
   136e6:	4649      	mov	r1, r9
   136e8:	f7f9 fb2a 	bl	cd40 <__adddf3>
   136ec:	9802      	ldr	r0, [sp, #8]
   136ee:	460f      	mov	r7, r1
   136f0:	4606      	mov	r6, r0
   136f2:	a337      	add	r3, pc, #220	; (adr r3, 137d0 <__ieee754_pow+0x4e0>)
   136f4:	e9d3 2300 	ldrd	r2, r3, [r3]
   136f8:	f7f9 fcd8 	bl	d0ac <__aeabi_dmul>
   136fc:	4642      	mov	r2, r8
   136fe:	464b      	mov	r3, r9
   13700:	e9cd 0104 	strd	r0, r1, [sp, #16]
   13704:	4630      	mov	r0, r6
   13706:	4639      	mov	r1, r7
   13708:	f7f9 fb18 	bl	cd3c <__aeabi_dsub>
   1370c:	4602      	mov	r2, r0
   1370e:	460b      	mov	r3, r1
   13710:	4620      	mov	r0, r4
   13712:	4629      	mov	r1, r5
   13714:	f7f9 fb12 	bl	cd3c <__aeabi_dsub>
   13718:	a32f      	add	r3, pc, #188	; (adr r3, 137d8 <__ieee754_pow+0x4e8>)
   1371a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1371e:	f7f9 fcc5 	bl	d0ac <__aeabi_dmul>
   13722:	4604      	mov	r4, r0
   13724:	460d      	mov	r5, r1
   13726:	4630      	mov	r0, r6
   13728:	4639      	mov	r1, r7
   1372a:	a32d      	add	r3, pc, #180	; (adr r3, 137e0 <__ieee754_pow+0x4f0>)
   1372c:	e9d3 2300 	ldrd	r2, r3, [r3]
   13730:	f7f9 fcbc 	bl	d0ac <__aeabi_dmul>
   13734:	4602      	mov	r2, r0
   13736:	460b      	mov	r3, r1
   13738:	4620      	mov	r0, r4
   1373a:	4629      	mov	r1, r5
   1373c:	f7f9 fb00 	bl	cd40 <__adddf3>
   13740:	e9dd 2310 	ldrd	r2, r3, [sp, #64]	; 0x40
   13744:	f7f9 fafc 	bl	cd40 <__adddf3>
   13748:	4606      	mov	r6, r0
   1374a:	460f      	mov	r7, r1
   1374c:	980b      	ldr	r0, [sp, #44]	; 0x2c
   1374e:	f7f9 fc43 	bl	cfd8 <__aeabi_i2d>
   13752:	4632      	mov	r2, r6
   13754:	4680      	mov	r8, r0
   13756:	4689      	mov	r9, r1
   13758:	463b      	mov	r3, r7
   1375a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   1375e:	f7f9 faef 	bl	cd40 <__adddf3>
   13762:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   13766:	f7f9 faeb 	bl	cd40 <__adddf3>
   1376a:	4642      	mov	r2, r8
   1376c:	464b      	mov	r3, r9
   1376e:	f7f9 fae7 	bl	cd40 <__adddf3>
   13772:	9802      	ldr	r0, [sp, #8]
   13774:	4642      	mov	r2, r8
   13776:	464b      	mov	r3, r9
   13778:	4604      	mov	r4, r0
   1377a:	460d      	mov	r5, r1
   1377c:	f7f9 fade 	bl	cd3c <__aeabi_dsub>
   13780:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   13784:	f7f9 fada 	bl	cd3c <__aeabi_dsub>
   13788:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   1378c:	e038      	b.n	13800 <__ieee754_pow+0x510>
   1378e:	bf00      	nop
	...
   1379c:	3ff00000 	.word	0x3ff00000
   137a0:	4a454eef 	.word	0x4a454eef
   137a4:	3fca7e28 	.word	0x3fca7e28
   137a8:	93c9db65 	.word	0x93c9db65
   137ac:	3fcd864a 	.word	0x3fcd864a
   137b0:	a91d4101 	.word	0xa91d4101
   137b4:	3fd17460 	.word	0x3fd17460
   137b8:	518f264d 	.word	0x518f264d
   137bc:	3fd55555 	.word	0x3fd55555
   137c0:	db6fabff 	.word	0xdb6fabff
   137c4:	3fdb6db6 	.word	0x3fdb6db6
   137c8:	33333303 	.word	0x33333303
   137cc:	3fe33333 	.word	0x3fe33333
   137d0:	e0000000 	.word	0xe0000000
   137d4:	3feec709 	.word	0x3feec709
   137d8:	dc3a03fd 	.word	0xdc3a03fd
   137dc:	3feec709 	.word	0x3feec709
   137e0:	145b01f5 	.word	0x145b01f5
   137e4:	be3e2fe0 	.word	0xbe3e2fe0
   137e8:	7ff00000 	.word	0x7ff00000
   137ec:	43400000 	.word	0x43400000
   137f0:	0003988e 	.word	0x0003988e
   137f4:	3ff00000 	.word	0x3ff00000
   137f8:	000bb679 	.word	0x000bb679
   137fc:	40080000 	.word	0x40080000
   13800:	f7f9 fa9c 	bl	cd3c <__aeabi_dsub>
   13804:	460b      	mov	r3, r1
   13806:	4602      	mov	r2, r0
   13808:	4639      	mov	r1, r7
   1380a:	4630      	mov	r0, r6
   1380c:	f7f9 fa96 	bl	cd3c <__aeabi_dsub>
   13810:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   13814:	ea53 030a 	orrs.w	r3, r3, sl
   13818:	e9cd 0102 	strd	r0, r1, [sp, #8]
   1381c:	f040 8175 	bne.w	13b0a <__ieee754_pow+0x81a>
   13820:	ed9f 7bd3 	vldr	d7, [pc, #844]	; 13b70 <__ieee754_pow+0x880>
   13824:	ed8d 7b04 	vstr	d7, [sp, #16]
   13828:	e9dd ab00 	ldrd	sl, fp, [sp]
   1382c:	4652      	mov	r2, sl
   1382e:	465b      	mov	r3, fp
   13830:	4650      	mov	r0, sl
   13832:	4659      	mov	r1, fp
   13834:	e9cd 2300 	strd	r2, r3, [sp]
   13838:	2300      	movs	r3, #0
   1383a:	9300      	str	r3, [sp, #0]
   1383c:	e9dd 6700 	ldrd	r6, r7, [sp]
   13840:	4632      	mov	r2, r6
   13842:	463b      	mov	r3, r7
   13844:	f7f9 fa7a 	bl	cd3c <__aeabi_dsub>
   13848:	4622      	mov	r2, r4
   1384a:	462b      	mov	r3, r5
   1384c:	f7f9 fc2e 	bl	d0ac <__aeabi_dmul>
   13850:	4680      	mov	r8, r0
   13852:	4689      	mov	r9, r1
   13854:	4652      	mov	r2, sl
   13856:	465b      	mov	r3, fp
   13858:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   1385c:	f7f9 fc26 	bl	d0ac <__aeabi_dmul>
   13860:	4602      	mov	r2, r0
   13862:	460b      	mov	r3, r1
   13864:	4640      	mov	r0, r8
   13866:	4649      	mov	r1, r9
   13868:	f7f9 fa6a 	bl	cd40 <__adddf3>
   1386c:	468b      	mov	fp, r1
   1386e:	4682      	mov	sl, r0
   13870:	4632      	mov	r2, r6
   13872:	463b      	mov	r3, r7
   13874:	4620      	mov	r0, r4
   13876:	4629      	mov	r1, r5
   13878:	e9cd ab02 	strd	sl, fp, [sp, #8]
   1387c:	f7f9 fc16 	bl	d0ac <__aeabi_dmul>
   13880:	460b      	mov	r3, r1
   13882:	4602      	mov	r2, r0
   13884:	4680      	mov	r8, r0
   13886:	4689      	mov	r9, r1
   13888:	4650      	mov	r0, sl
   1388a:	4659      	mov	r1, fp
   1388c:	f7f9 fa58 	bl	cd40 <__adddf3>
   13890:	4bcf      	ldr	r3, [pc, #828]	; (13bd0 <__ieee754_pow+0x8e0>)
   13892:	4604      	mov	r4, r0
   13894:	460d      	mov	r5, r1
   13896:	4299      	cmp	r1, r3
   13898:	468b      	mov	fp, r1
   1389a:	f340 813b 	ble.w	13b14 <__ieee754_pow+0x824>
   1389e:	4bcd      	ldr	r3, [pc, #820]	; (13bd4 <__ieee754_pow+0x8e4>)
   138a0:	440b      	add	r3, r1
   138a2:	4303      	orrs	r3, r0
   138a4:	f040 8233 	bne.w	13d0e <__ieee754_pow+0xa1e>
   138a8:	a3b3      	add	r3, pc, #716	; (adr r3, 13b78 <__ieee754_pow+0x888>)
   138aa:	e9d3 2300 	ldrd	r2, r3, [r3]
   138ae:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   138b2:	f7f9 fa45 	bl	cd40 <__adddf3>
   138b6:	4606      	mov	r6, r0
   138b8:	460f      	mov	r7, r1
   138ba:	4642      	mov	r2, r8
   138bc:	464b      	mov	r3, r9
   138be:	4620      	mov	r0, r4
   138c0:	4629      	mov	r1, r5
   138c2:	f7f9 fa3b 	bl	cd3c <__aeabi_dsub>
   138c6:	4602      	mov	r2, r0
   138c8:	460b      	mov	r3, r1
   138ca:	4630      	mov	r0, r6
   138cc:	4639      	mov	r1, r7
   138ce:	f7f9 fe7d 	bl	d5cc <__aeabi_dcmpgt>
   138d2:	2800      	cmp	r0, #0
   138d4:	f040 821b 	bne.w	13d0e <__ieee754_pow+0xa1e>
   138d8:	f3cb 530a 	ubfx	r3, fp, #20, #11
   138dc:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
   138e0:	f2a3 33fe 	subw	r3, r3, #1022	; 0x3fe
   138e4:	4cbc      	ldr	r4, [pc, #752]	; (13bd8 <__ieee754_pow+0x8e8>)
   138e6:	f1bb 0f00 	cmp.w	fp, #0
   138ea:	fa42 f303 	asr.w	r3, r2, r3
   138ee:	f04f 0000 	mov.w	r0, #0
   138f2:	445b      	add	r3, fp
   138f4:	f3c3 520a 	ubfx	r2, r3, #20, #11
   138f8:	f3c3 0a13 	ubfx	sl, r3, #0, #20
   138fc:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
   13900:	f44a 1a80 	orr.w	sl, sl, #1048576	; 0x100000
   13904:	fa44 f402 	asr.w	r4, r4, r2
   13908:	f1c2 0214 	rsb	r2, r2, #20
   1390c:	ea23 0104 	bic.w	r1, r3, r4
   13910:	fa4a fa02 	asr.w	sl, sl, r2
   13914:	4602      	mov	r2, r0
   13916:	4640      	mov	r0, r8
   13918:	460b      	mov	r3, r1
   1391a:	bfb8      	it	lt
   1391c:	f1ca 0a00 	rsblt	sl, sl, #0
   13920:	4649      	mov	r1, r9
   13922:	f7f9 fa0b 	bl	cd3c <__aeabi_dsub>
   13926:	4602      	mov	r2, r0
   13928:	460b      	mov	r3, r1
   1392a:	4680      	mov	r8, r0
   1392c:	4689      	mov	r9, r1
   1392e:	ea4f 5b0a 	mov.w	fp, sl, lsl #20
   13932:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   13936:	f7f9 fa03 	bl	cd40 <__adddf3>
   1393a:	460d      	mov	r5, r1
   1393c:	2400      	movs	r4, #0
   1393e:	4629      	mov	r1, r5
   13940:	a38f      	add	r3, pc, #572	; (adr r3, 13b80 <__ieee754_pow+0x890>)
   13942:	e9d3 2300 	ldrd	r2, r3, [r3]
   13946:	4620      	mov	r0, r4
   13948:	f7f9 fbb0 	bl	d0ac <__aeabi_dmul>
   1394c:	4642      	mov	r2, r8
   1394e:	4606      	mov	r6, r0
   13950:	460f      	mov	r7, r1
   13952:	464b      	mov	r3, r9
   13954:	4620      	mov	r0, r4
   13956:	4629      	mov	r1, r5
   13958:	f7f9 f9f0 	bl	cd3c <__aeabi_dsub>
   1395c:	4602      	mov	r2, r0
   1395e:	460b      	mov	r3, r1
   13960:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   13964:	f7f9 f9ea 	bl	cd3c <__aeabi_dsub>
   13968:	a387      	add	r3, pc, #540	; (adr r3, 13b88 <__ieee754_pow+0x898>)
   1396a:	e9d3 2300 	ldrd	r2, r3, [r3]
   1396e:	f7f9 fb9d 	bl	d0ac <__aeabi_dmul>
   13972:	4680      	mov	r8, r0
   13974:	4689      	mov	r9, r1
   13976:	4620      	mov	r0, r4
   13978:	4629      	mov	r1, r5
   1397a:	a385      	add	r3, pc, #532	; (adr r3, 13b90 <__ieee754_pow+0x8a0>)
   1397c:	e9d3 2300 	ldrd	r2, r3, [r3]
   13980:	f7f9 fb94 	bl	d0ac <__aeabi_dmul>
   13984:	4602      	mov	r2, r0
   13986:	460b      	mov	r3, r1
   13988:	4640      	mov	r0, r8
   1398a:	4649      	mov	r1, r9
   1398c:	f7f9 f9d8 	bl	cd40 <__adddf3>
   13990:	4604      	mov	r4, r0
   13992:	460d      	mov	r5, r1
   13994:	4602      	mov	r2, r0
   13996:	460b      	mov	r3, r1
   13998:	4630      	mov	r0, r6
   1399a:	4639      	mov	r1, r7
   1399c:	f7f9 f9d0 	bl	cd40 <__adddf3>
   139a0:	4632      	mov	r2, r6
   139a2:	4680      	mov	r8, r0
   139a4:	4689      	mov	r9, r1
   139a6:	463b      	mov	r3, r7
   139a8:	f7f9 f9c8 	bl	cd3c <__aeabi_dsub>
   139ac:	4602      	mov	r2, r0
   139ae:	460b      	mov	r3, r1
   139b0:	4620      	mov	r0, r4
   139b2:	4629      	mov	r1, r5
   139b4:	f7f9 f9c2 	bl	cd3c <__aeabi_dsub>
   139b8:	4642      	mov	r2, r8
   139ba:	4606      	mov	r6, r0
   139bc:	460f      	mov	r7, r1
   139be:	464b      	mov	r3, r9
   139c0:	4640      	mov	r0, r8
   139c2:	4649      	mov	r1, r9
   139c4:	f7f9 fb72 	bl	d0ac <__aeabi_dmul>
   139c8:	4604      	mov	r4, r0
   139ca:	460d      	mov	r5, r1
   139cc:	a372      	add	r3, pc, #456	; (adr r3, 13b98 <__ieee754_pow+0x8a8>)
   139ce:	e9d3 2300 	ldrd	r2, r3, [r3]
   139d2:	f7f9 fb6b 	bl	d0ac <__aeabi_dmul>
   139d6:	a372      	add	r3, pc, #456	; (adr r3, 13ba0 <__ieee754_pow+0x8b0>)
   139d8:	e9d3 2300 	ldrd	r2, r3, [r3]
   139dc:	f7f9 f9ae 	bl	cd3c <__aeabi_dsub>
   139e0:	4622      	mov	r2, r4
   139e2:	462b      	mov	r3, r5
   139e4:	f7f9 fb62 	bl	d0ac <__aeabi_dmul>
   139e8:	a36f      	add	r3, pc, #444	; (adr r3, 13ba8 <__ieee754_pow+0x8b8>)
   139ea:	e9d3 2300 	ldrd	r2, r3, [r3]
   139ee:	f7f9 f9a7 	bl	cd40 <__adddf3>
   139f2:	4622      	mov	r2, r4
   139f4:	462b      	mov	r3, r5
   139f6:	f7f9 fb59 	bl	d0ac <__aeabi_dmul>
   139fa:	a36d      	add	r3, pc, #436	; (adr r3, 13bb0 <__ieee754_pow+0x8c0>)
   139fc:	e9d3 2300 	ldrd	r2, r3, [r3]
   13a00:	f7f9 f99c 	bl	cd3c <__aeabi_dsub>
   13a04:	4622      	mov	r2, r4
   13a06:	462b      	mov	r3, r5
   13a08:	f7f9 fb50 	bl	d0ac <__aeabi_dmul>
   13a0c:	a36a      	add	r3, pc, #424	; (adr r3, 13bb8 <__ieee754_pow+0x8c8>)
   13a0e:	e9d3 2300 	ldrd	r2, r3, [r3]
   13a12:	f7f9 f995 	bl	cd40 <__adddf3>
   13a16:	4622      	mov	r2, r4
   13a18:	462b      	mov	r3, r5
   13a1a:	f7f9 fb47 	bl	d0ac <__aeabi_dmul>
   13a1e:	4602      	mov	r2, r0
   13a20:	460b      	mov	r3, r1
   13a22:	4640      	mov	r0, r8
   13a24:	4649      	mov	r1, r9
   13a26:	f7f9 f989 	bl	cd3c <__aeabi_dsub>
   13a2a:	4604      	mov	r4, r0
   13a2c:	460d      	mov	r5, r1
   13a2e:	4602      	mov	r2, r0
   13a30:	460b      	mov	r3, r1
   13a32:	4640      	mov	r0, r8
   13a34:	4649      	mov	r1, r9
   13a36:	f7f9 fb39 	bl	d0ac <__aeabi_dmul>
   13a3a:	2200      	movs	r2, #0
   13a3c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   13a40:	e9cd 0100 	strd	r0, r1, [sp]
   13a44:	4620      	mov	r0, r4
   13a46:	4629      	mov	r1, r5
   13a48:	f7f9 f978 	bl	cd3c <__aeabi_dsub>
   13a4c:	4602      	mov	r2, r0
   13a4e:	460b      	mov	r3, r1
   13a50:	e9dd 0100 	ldrd	r0, r1, [sp]
   13a54:	f7f9 fc54 	bl	d300 <__aeabi_ddiv>
   13a58:	4632      	mov	r2, r6
   13a5a:	4604      	mov	r4, r0
   13a5c:	460d      	mov	r5, r1
   13a5e:	463b      	mov	r3, r7
   13a60:	4640      	mov	r0, r8
   13a62:	4649      	mov	r1, r9
   13a64:	f7f9 fb22 	bl	d0ac <__aeabi_dmul>
   13a68:	4632      	mov	r2, r6
   13a6a:	463b      	mov	r3, r7
   13a6c:	f7f9 f968 	bl	cd40 <__adddf3>
   13a70:	4602      	mov	r2, r0
   13a72:	460b      	mov	r3, r1
   13a74:	4620      	mov	r0, r4
   13a76:	4629      	mov	r1, r5
   13a78:	f7f9 f960 	bl	cd3c <__aeabi_dsub>
   13a7c:	4642      	mov	r2, r8
   13a7e:	464b      	mov	r3, r9
   13a80:	f7f9 f95c 	bl	cd3c <__aeabi_dsub>
   13a84:	4602      	mov	r2, r0
   13a86:	460b      	mov	r3, r1
   13a88:	2000      	movs	r0, #0
   13a8a:	4954      	ldr	r1, [pc, #336]	; (13bdc <__ieee754_pow+0x8ec>)
   13a8c:	f7f9 f956 	bl	cd3c <__aeabi_dsub>
   13a90:	448b      	add	fp, r1
   13a92:	4602      	mov	r2, r0
   13a94:	460b      	mov	r3, r1
   13a96:	f5bb 1f80 	cmp.w	fp, #1048576	; 0x100000
   13a9a:	f2c0 815f 	blt.w	13d5c <__ieee754_pow+0xa6c>
   13a9e:	4659      	mov	r1, fp
   13aa0:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   13aa4:	f7f9 fb02 	bl	d0ac <__aeabi_dmul>
   13aa8:	e44f      	b.n	1334a <__ieee754_pow+0x5a>
   13aaa:	ec45 4b10 	vmov	d0, r4, r5
   13aae:	f01b fcb9 	bl	2f424 <fabs>
   13ab2:	ec51 0b10 	vmov	r0, r1, d0
   13ab6:	f1ba 0f00 	cmp.w	sl, #0
   13aba:	f47f accb 	bne.w	13454 <__ieee754_pow+0x164>
   13abe:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
   13ac2:	4a46      	ldr	r2, [pc, #280]	; (13bdc <__ieee754_pow+0x8ec>)
   13ac4:	4293      	cmp	r3, r2
   13ac6:	d002      	beq.n	13ace <__ieee754_pow+0x7de>
   13ac8:	2e00      	cmp	r6, #0
   13aca:	f47f acc3 	bne.w	13454 <__ieee754_pow+0x164>
   13ace:	f04f 0b00 	mov.w	fp, #0
   13ad2:	f1b9 0f00 	cmp.w	r9, #0
   13ad6:	da05      	bge.n	13ae4 <__ieee754_pow+0x7f4>
   13ad8:	4602      	mov	r2, r0
   13ada:	460b      	mov	r3, r1
   13adc:	2000      	movs	r0, #0
   13ade:	493f      	ldr	r1, [pc, #252]	; (13bdc <__ieee754_pow+0x8ec>)
   13ae0:	f7f9 fc0e 	bl	d300 <__aeabi_ddiv>
   13ae4:	2f00      	cmp	r7, #0
   13ae6:	f6bf ac30 	bge.w	1334a <__ieee754_pow+0x5a>
   13aea:	4b3d      	ldr	r3, [pc, #244]	; (13be0 <__ieee754_pow+0x8f0>)
   13aec:	4433      	add	r3, r6
   13aee:	ea53 030b 	orrs.w	r3, r3, fp
   13af2:	f040 812a 	bne.w	13d4a <__ieee754_pow+0xa5a>
   13af6:	4602      	mov	r2, r0
   13af8:	460b      	mov	r3, r1
   13afa:	e4ad      	b.n	13458 <__ieee754_pow+0x168>
   13afc:	f1b9 0f00 	cmp.w	r9, #0
   13b00:	f6ff ac6b 	blt.w	133da <__ieee754_pow+0xea>
   13b04:	2000      	movs	r0, #0
   13b06:	2100      	movs	r1, #0
   13b08:	e41f      	b.n	1334a <__ieee754_pow+0x5a>
   13b0a:	ed9f 7b2d 	vldr	d7, [pc, #180]	; 13bc0 <__ieee754_pow+0x8d0>
   13b0e:	ed8d 7b04 	vstr	d7, [sp, #16]
   13b12:	e689      	b.n	13828 <__ieee754_pow+0x538>
   13b14:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   13b18:	4e32      	ldr	r6, [pc, #200]	; (13be4 <__ieee754_pow+0x8f4>)
   13b1a:	42b3      	cmp	r3, r6
   13b1c:	f340 80ef 	ble.w	13cfe <__ieee754_pow+0xa0e>
   13b20:	4b31      	ldr	r3, [pc, #196]	; (13be8 <__ieee754_pow+0x8f8>)
   13b22:	440b      	add	r3, r1
   13b24:	4303      	orrs	r3, r0
   13b26:	d10a      	bne.n	13b3e <__ieee754_pow+0x84e>
   13b28:	4642      	mov	r2, r8
   13b2a:	464b      	mov	r3, r9
   13b2c:	f7f9 f906 	bl	cd3c <__aeabi_dsub>
   13b30:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   13b34:	f7f9 fd40 	bl	d5b8 <__aeabi_dcmpge>
   13b38:	2800      	cmp	r0, #0
   13b3a:	f43f aecd 	beq.w	138d8 <__ieee754_pow+0x5e8>
   13b3e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   13b42:	a321      	add	r3, pc, #132	; (adr r3, 13bc8 <__ieee754_pow+0x8d8>)
   13b44:	e9d3 2300 	ldrd	r2, r3, [r3]
   13b48:	f7f9 fab0 	bl	d0ac <__aeabi_dmul>
   13b4c:	a31e      	add	r3, pc, #120	; (adr r3, 13bc8 <__ieee754_pow+0x8d8>)
   13b4e:	e9d3 2300 	ldrd	r2, r3, [r3]
   13b52:	f7f9 faab 	bl	d0ac <__aeabi_dmul>
   13b56:	f7ff bbf8 	b.w	1334a <__ieee754_pow+0x5a>
   13b5a:	f1b9 0f00 	cmp.w	r9, #0
   13b5e:	dad1      	bge.n	13b04 <__ieee754_pow+0x814>
   13b60:	e9dd 3400 	ldrd	r3, r4, [sp]
   13b64:	4618      	mov	r0, r3
   13b66:	f104 4100 	add.w	r1, r4, #2147483648	; 0x80000000
   13b6a:	f7ff bbee 	b.w	1334a <__ieee754_pow+0x5a>
   13b6e:	bf00      	nop
   13b70:	00000000 	.word	0x00000000
   13b74:	bff00000 	.word	0xbff00000
   13b78:	652b82fe 	.word	0x652b82fe
   13b7c:	3c971547 	.word	0x3c971547
   13b80:	00000000 	.word	0x00000000
   13b84:	3fe62e43 	.word	0x3fe62e43
   13b88:	fefa39ef 	.word	0xfefa39ef
   13b8c:	3fe62e42 	.word	0x3fe62e42
   13b90:	0ca86c39 	.word	0x0ca86c39
   13b94:	be205c61 	.word	0xbe205c61
   13b98:	72bea4d0 	.word	0x72bea4d0
   13b9c:	3e663769 	.word	0x3e663769
   13ba0:	c5d26bf1 	.word	0xc5d26bf1
   13ba4:	3ebbbd41 	.word	0x3ebbbd41
   13ba8:	af25de2c 	.word	0xaf25de2c
   13bac:	3f11566a 	.word	0x3f11566a
   13bb0:	16bebd93 	.word	0x16bebd93
   13bb4:	3f66c16c 	.word	0x3f66c16c
   13bb8:	5555553e 	.word	0x5555553e
   13bbc:	3fc55555 	.word	0x3fc55555
   13bc0:	00000000 	.word	0x00000000
   13bc4:	3ff00000 	.word	0x3ff00000
   13bc8:	c2f8f359 	.word	0xc2f8f359
   13bcc:	01a56e1f 	.word	0x01a56e1f
   13bd0:	408fffff 	.word	0x408fffff
   13bd4:	bf700000 	.word	0xbf700000
   13bd8:	000fffff 	.word	0x000fffff
   13bdc:	3ff00000 	.word	0x3ff00000
   13be0:	c0100000 	.word	0xc0100000
   13be4:	4090cbff 	.word	0x4090cbff
   13be8:	3f6f3400 	.word	0x3f6f3400
   13bec:	4b7c      	ldr	r3, [pc, #496]	; (13de0 <__ieee754_pow+0xaf0>)
   13bee:	429e      	cmp	r6, r3
   13bf0:	dd84      	ble.n	13afc <__ieee754_pow+0x80c>
   13bf2:	4b7c      	ldr	r3, [pc, #496]	; (13de4 <__ieee754_pow+0xaf4>)
   13bf4:	429e      	cmp	r6, r3
   13bf6:	f73f abec 	bgt.w	133d2 <__ieee754_pow+0xe2>
   13bfa:	2200      	movs	r2, #0
   13bfc:	4b79      	ldr	r3, [pc, #484]	; (13de4 <__ieee754_pow+0xaf4>)
   13bfe:	f7f9 f89d 	bl	cd3c <__aeabi_dsub>
   13c02:	4604      	mov	r4, r0
   13c04:	460d      	mov	r5, r1
   13c06:	a362      	add	r3, pc, #392	; (adr r3, 13d90 <__ieee754_pow+0xaa0>)
   13c08:	e9d3 2300 	ldrd	r2, r3, [r3]
   13c0c:	f7f9 fa4e 	bl	d0ac <__aeabi_dmul>
   13c10:	4680      	mov	r8, r0
   13c12:	4689      	mov	r9, r1
   13c14:	4620      	mov	r0, r4
   13c16:	4629      	mov	r1, r5
   13c18:	a35f      	add	r3, pc, #380	; (adr r3, 13d98 <__ieee754_pow+0xaa8>)
   13c1a:	e9d3 2300 	ldrd	r2, r3, [r3]
   13c1e:	f7f9 fa45 	bl	d0ac <__aeabi_dmul>
   13c22:	2200      	movs	r2, #0
   13c24:	4b70      	ldr	r3, [pc, #448]	; (13de8 <__ieee754_pow+0xaf8>)
   13c26:	e9cd 0102 	strd	r0, r1, [sp, #8]
   13c2a:	4620      	mov	r0, r4
   13c2c:	4629      	mov	r1, r5
   13c2e:	f7f9 fa3d 	bl	d0ac <__aeabi_dmul>
   13c32:	4602      	mov	r2, r0
   13c34:	460b      	mov	r3, r1
   13c36:	a15a      	add	r1, pc, #360	; (adr r1, 13da0 <__ieee754_pow+0xab0>)
   13c38:	e9d1 0100 	ldrd	r0, r1, [r1]
   13c3c:	f7f9 f87e 	bl	cd3c <__aeabi_dsub>
   13c40:	4622      	mov	r2, r4
   13c42:	462b      	mov	r3, r5
   13c44:	f7f9 fa32 	bl	d0ac <__aeabi_dmul>
   13c48:	4602      	mov	r2, r0
   13c4a:	460b      	mov	r3, r1
   13c4c:	2000      	movs	r0, #0
   13c4e:	4967      	ldr	r1, [pc, #412]	; (13dec <__ieee754_pow+0xafc>)
   13c50:	f7f9 f874 	bl	cd3c <__aeabi_dsub>
   13c54:	4606      	mov	r6, r0
   13c56:	460f      	mov	r7, r1
   13c58:	4622      	mov	r2, r4
   13c5a:	462b      	mov	r3, r5
   13c5c:	4620      	mov	r0, r4
   13c5e:	4629      	mov	r1, r5
   13c60:	f7f9 fa24 	bl	d0ac <__aeabi_dmul>
   13c64:	4602      	mov	r2, r0
   13c66:	460b      	mov	r3, r1
   13c68:	4630      	mov	r0, r6
   13c6a:	4639      	mov	r1, r7
   13c6c:	f7f9 fa1e 	bl	d0ac <__aeabi_dmul>
   13c70:	a34d      	add	r3, pc, #308	; (adr r3, 13da8 <__ieee754_pow+0xab8>)
   13c72:	e9d3 2300 	ldrd	r2, r3, [r3]
   13c76:	f7f9 fa19 	bl	d0ac <__aeabi_dmul>
   13c7a:	4602      	mov	r2, r0
   13c7c:	460b      	mov	r3, r1
   13c7e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   13c82:	f7f9 f85b 	bl	cd3c <__aeabi_dsub>
   13c86:	4602      	mov	r2, r0
   13c88:	460b      	mov	r3, r1
   13c8a:	4606      	mov	r6, r0
   13c8c:	460f      	mov	r7, r1
   13c8e:	4640      	mov	r0, r8
   13c90:	4649      	mov	r1, r9
   13c92:	f7f9 f855 	bl	cd40 <__adddf3>
   13c96:	2000      	movs	r0, #0
   13c98:	460d      	mov	r5, r1
   13c9a:	4642      	mov	r2, r8
   13c9c:	4604      	mov	r4, r0
   13c9e:	464b      	mov	r3, r9
   13ca0:	e5ae      	b.n	13800 <__ieee754_pow+0x510>
   13ca2:	ed9f 7b43 	vldr	d7, [pc, #268]	; 13db0 <__ieee754_pow+0xac0>
   13ca6:	2500      	movs	r5, #0
   13ca8:	ed8d 7b08 	vstr	d7, [sp, #32]
   13cac:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   13cb0:	ed9f 7b41 	vldr	d7, [pc, #260]	; 13db8 <__ieee754_pow+0xac8>
   13cb4:	ed8d 7b06 	vstr	d7, [sp, #24]
   13cb8:	e41d      	b.n	134f6 <__ieee754_pow+0x206>
   13cba:	2500      	movs	r5, #0
   13cbc:	f7ff bbf8 	b.w	134b0 <__ieee754_pow+0x1c0>
   13cc0:	4622      	mov	r2, r4
   13cc2:	462b      	mov	r3, r5
   13cc4:	2000      	movs	r0, #0
   13cc6:	4947      	ldr	r1, [pc, #284]	; (13de4 <__ieee754_pow+0xaf4>)
   13cc8:	f7f9 fb1a 	bl	d300 <__aeabi_ddiv>
   13ccc:	f7ff bb3d 	b.w	1334a <__ieee754_pow+0x5a>
   13cd0:	4622      	mov	r2, r4
   13cd2:	462b      	mov	r3, r5
   13cd4:	4620      	mov	r0, r4
   13cd6:	4629      	mov	r1, r5
   13cd8:	f7f9 f9e8 	bl	d0ac <__aeabi_dmul>
   13cdc:	f7ff bb35 	b.w	1334a <__ieee754_pow+0x5a>
   13ce0:	f1bc 0f00 	cmp.w	ip, #0
   13ce4:	f47f aee1 	bne.w	13aaa <__ieee754_pow+0x7ba>
   13ce8:	f1c3 0314 	rsb	r3, r3, #20
   13cec:	fa48 f203 	asr.w	r2, r8, r3
   13cf0:	fa02 f303 	lsl.w	r3, r2, r3
   13cf4:	4543      	cmp	r3, r8
   13cf6:	d040      	beq.n	13d7a <__ieee754_pow+0xa8a>
   13cf8:	46e3      	mov	fp, ip
   13cfa:	f7ff bb39 	b.w	13370 <__ieee754_pow+0x80>
   13cfe:	4a3b      	ldr	r2, [pc, #236]	; (13dec <__ieee754_pow+0xafc>)
   13d00:	4293      	cmp	r3, r2
   13d02:	dc40      	bgt.n	13d86 <__ieee754_pow+0xa96>
   13d04:	e9dd 2300 	ldrd	r2, r3, [sp]
   13d08:	4693      	mov	fp, r2
   13d0a:	4692      	mov	sl, r2
   13d0c:	e616      	b.n	1393c <__ieee754_pow+0x64c>
   13d0e:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   13d12:	a32b      	add	r3, pc, #172	; (adr r3, 13dc0 <__ieee754_pow+0xad0>)
   13d14:	e9d3 2300 	ldrd	r2, r3, [r3]
   13d18:	f7f9 f9c8 	bl	d0ac <__aeabi_dmul>
   13d1c:	a328      	add	r3, pc, #160	; (adr r3, 13dc0 <__ieee754_pow+0xad0>)
   13d1e:	e9d3 2300 	ldrd	r2, r3, [r3]
   13d22:	f7f9 f9c3 	bl	d0ac <__aeabi_dmul>
   13d26:	f7ff bb10 	b.w	1334a <__ieee754_pow+0x5a>
   13d2a:	ed9f 7b27 	vldr	d7, [pc, #156]	; 13dc8 <__ieee754_pow+0xad8>
   13d2e:	f44f 2580 	mov.w	r5, #262144	; 0x40000
   13d32:	ed8d 7b08 	vstr	d7, [sp, #32]
   13d36:	ed9f 7b26 	vldr	d7, [pc, #152]	; 13dd0 <__ieee754_pow+0xae0>
   13d3a:	ed8d 7b10 	vstr	d7, [sp, #64]	; 0x40
   13d3e:	ed9f 7b26 	vldr	d7, [pc, #152]	; 13dd8 <__ieee754_pow+0xae8>
   13d42:	ed8d 7b06 	vstr	d7, [sp, #24]
   13d46:	f7ff bbd6 	b.w	134f6 <__ieee754_pow+0x206>
   13d4a:	f1bb 0f01 	cmp.w	fp, #1
   13d4e:	f47f aafc 	bne.w	1334a <__ieee754_pow+0x5a>
   13d52:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
   13d56:	4619      	mov	r1, r3
   13d58:	f7ff baf7 	b.w	1334a <__ieee754_pow+0x5a>
   13d5c:	4650      	mov	r0, sl
   13d5e:	ec43 2b10 	vmov	d0, r2, r3
   13d62:	f000 f84d 	bl	13e00 <scalbn>
   13d66:	ec51 0b10 	vmov	r0, r1, d0
   13d6a:	e699      	b.n	13aa0 <__ieee754_pow+0x7b0>
   13d6c:	ec45 4b10 	vmov	d0, r4, r5
   13d70:	b013      	add	sp, #76	; 0x4c
   13d72:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13d76:	f01b bd83 	b.w	2f880 <__ieee754_sqrt>
   13d7a:	f002 0201 	and.w	r2, r2, #1
   13d7e:	f1c2 0b02 	rsb	fp, r2, #2
   13d82:	f7ff baf5 	b.w	13370 <__ieee754_pow+0x80>
   13d86:	151b      	asrs	r3, r3, #20
   13d88:	e5a8      	b.n	138dc <__ieee754_pow+0x5ec>
   13d8a:	bf00      	nop
   13d8c:	f3af 8000 	nop.w
   13d90:	60000000 	.word	0x60000000
   13d94:	3ff71547 	.word	0x3ff71547
   13d98:	f85ddf44 	.word	0xf85ddf44
   13d9c:	3e54ae0b 	.word	0x3e54ae0b
   13da0:	55555555 	.word	0x55555555
   13da4:	3fd55555 	.word	0x3fd55555
   13da8:	652b82fe 	.word	0x652b82fe
   13dac:	3ff71547 	.word	0x3ff71547
	...
   13dbc:	3ff00000 	.word	0x3ff00000
   13dc0:	8800759c 	.word	0x8800759c
   13dc4:	7e37e43c 	.word	0x7e37e43c
   13dc8:	40000000 	.word	0x40000000
   13dcc:	3fe2b803 	.word	0x3fe2b803
   13dd0:	43cfd006 	.word	0x43cfd006
   13dd4:	3e4cfdeb 	.word	0x3e4cfdeb
   13dd8:	00000000 	.word	0x00000000
   13ddc:	3ff80000 	.word	0x3ff80000
   13de0:	3feffffe 	.word	0x3feffffe
   13de4:	3ff00000 	.word	0x3ff00000
   13de8:	3fd00000 	.word	0x3fd00000
   13dec:	3fe00000 	.word	0x3fe00000

00013df0 <nan>:
   13df0:	ed9f 0b01 	vldr	d0, [pc, #4]	; 13df8 <nan+0x8>
   13df4:	4770      	bx	lr
   13df6:	bf00      	nop
   13df8:	00000000 	.word	0x00000000
   13dfc:	7ff80000 	.word	0x7ff80000

00013e00 <scalbn>:
   13e00:	b538      	push	{r3, r4, r5, lr}
   13e02:	ec53 2b10 	vmov	r2, r3, d0
   13e06:	f3c3 510a 	ubfx	r1, r3, #20, #11
   13e0a:	461c      	mov	r4, r3
   13e0c:	4605      	mov	r5, r0
   13e0e:	bb81      	cbnz	r1, 13e72 <scalbn+0x72>
   13e10:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   13e14:	ee10 1a10 	vmov	r1, s0
   13e18:	4321      	orrs	r1, r4
   13e1a:	d029      	beq.n	13e70 <scalbn+0x70>
   13e1c:	4c3c      	ldr	r4, [pc, #240]	; (13f10 <scalbn+0x110>)
   13e1e:	4619      	mov	r1, r3
   13e20:	2200      	movs	r2, #0
   13e22:	4b3c      	ldr	r3, [pc, #240]	; (13f14 <scalbn+0x114>)
   13e24:	ee10 0a10 	vmov	r0, s0
   13e28:	f7f9 f940 	bl	d0ac <__aeabi_dmul>
   13e2c:	42a5      	cmp	r5, r4
   13e2e:	4602      	mov	r2, r0
   13e30:	460b      	mov	r3, r1
   13e32:	db16      	blt.n	13e62 <scalbn+0x62>
   13e34:	460c      	mov	r4, r1
   13e36:	f3c1 510a 	ubfx	r1, r1, #20, #11
   13e3a:	3936      	subs	r1, #54	; 0x36
   13e3c:	4429      	add	r1, r5
   13e3e:	f240 70fe 	movw	r0, #2046	; 0x7fe
   13e42:	4281      	cmp	r1, r0
   13e44:	dc21      	bgt.n	13e8a <scalbn+0x8a>
   13e46:	2900      	cmp	r1, #0
   13e48:	dc45      	bgt.n	13ed6 <scalbn+0xd6>
   13e4a:	f111 0f35 	cmn.w	r1, #53	; 0x35
   13e4e:	da34      	bge.n	13eba <scalbn+0xba>
   13e50:	f24c 3150 	movw	r1, #50000	; 0xc350
   13e54:	428d      	cmp	r5, r1
   13e56:	dc18      	bgt.n	13e8a <scalbn+0x8a>
   13e58:	2b00      	cmp	r3, #0
   13e5a:	a125      	add	r1, pc, #148	; (adr r1, 13ef0 <scalbn+0xf0>)
   13e5c:	e9d1 0100 	ldrd	r0, r1, [r1]
   13e60:	db40      	blt.n	13ee4 <scalbn+0xe4>
   13e62:	a323      	add	r3, pc, #140	; (adr r3, 13ef0 <scalbn+0xf0>)
   13e64:	e9d3 2300 	ldrd	r2, r3, [r3]
   13e68:	f7f9 f920 	bl	d0ac <__aeabi_dmul>
   13e6c:	ec41 0b10 	vmov	d0, r0, r1
   13e70:	bd38      	pop	{r3, r4, r5, pc}
   13e72:	f240 70ff 	movw	r0, #2047	; 0x7ff
   13e76:	4281      	cmp	r1, r0
   13e78:	d1e0      	bne.n	13e3c <scalbn+0x3c>
   13e7a:	ee10 0a10 	vmov	r0, s0
   13e7e:	4619      	mov	r1, r3
   13e80:	f7f8 ff5e 	bl	cd40 <__adddf3>
   13e84:	ec41 0b10 	vmov	d0, r0, r1
   13e88:	bd38      	pop	{r3, r4, r5, pc}
   13e8a:	2b00      	cmp	r3, #0
   13e8c:	a11a      	add	r1, pc, #104	; (adr r1, 13ef8 <scalbn+0xf8>)
   13e8e:	e9d1 0100 	ldrd	r0, r1, [r1]
   13e92:	db07      	blt.n	13ea4 <scalbn+0xa4>
   13e94:	a318      	add	r3, pc, #96	; (adr r3, 13ef8 <scalbn+0xf8>)
   13e96:	e9d3 2300 	ldrd	r2, r3, [r3]
   13e9a:	f7f9 f907 	bl	d0ac <__aeabi_dmul>
   13e9e:	ec41 0b10 	vmov	d0, r0, r1
   13ea2:	bd38      	pop	{r3, r4, r5, pc}
   13ea4:	a116      	add	r1, pc, #88	; (adr r1, 13f00 <scalbn+0x100>)
   13ea6:	e9d1 0100 	ldrd	r0, r1, [r1]
   13eaa:	a313      	add	r3, pc, #76	; (adr r3, 13ef8 <scalbn+0xf8>)
   13eac:	e9d3 2300 	ldrd	r2, r3, [r3]
   13eb0:	f7f9 f8fc 	bl	d0ac <__aeabi_dmul>
   13eb4:	ec41 0b10 	vmov	d0, r0, r1
   13eb8:	e7f3      	b.n	13ea2 <scalbn+0xa2>
   13eba:	4817      	ldr	r0, [pc, #92]	; (13f18 <scalbn+0x118>)
   13ebc:	3136      	adds	r1, #54	; 0x36
   13ebe:	4020      	ands	r0, r4
   13ec0:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
   13ec4:	4610      	mov	r0, r2
   13ec6:	2200      	movs	r2, #0
   13ec8:	4619      	mov	r1, r3
   13eca:	4b14      	ldr	r3, [pc, #80]	; (13f1c <scalbn+0x11c>)
   13ecc:	f7f9 f8ee 	bl	d0ac <__aeabi_dmul>
   13ed0:	ec41 0b10 	vmov	d0, r0, r1
   13ed4:	bd38      	pop	{r3, r4, r5, pc}
   13ed6:	4810      	ldr	r0, [pc, #64]	; (13f18 <scalbn+0x118>)
   13ed8:	4020      	ands	r0, r4
   13eda:	ea40 5301 	orr.w	r3, r0, r1, lsl #20
   13ede:	ec43 2b10 	vmov	d0, r2, r3
   13ee2:	bd38      	pop	{r3, r4, r5, pc}
   13ee4:	a108      	add	r1, pc, #32	; (adr r1, 13f08 <scalbn+0x108>)
   13ee6:	e9d1 0100 	ldrd	r0, r1, [r1]
   13eea:	e7ba      	b.n	13e62 <scalbn+0x62>
   13eec:	f3af 8000 	nop.w
   13ef0:	c2f8f359 	.word	0xc2f8f359
   13ef4:	01a56e1f 	.word	0x01a56e1f
   13ef8:	8800759c 	.word	0x8800759c
   13efc:	7e37e43c 	.word	0x7e37e43c
   13f00:	8800759c 	.word	0x8800759c
   13f04:	fe37e43c 	.word	0xfe37e43c
   13f08:	c2f8f359 	.word	0xc2f8f359
   13f0c:	81a56e1f 	.word	0x81a56e1f
   13f10:	ffff3cb0 	.word	0xffff3cb0
   13f14:	43500000 	.word	0x43500000
   13f18:	800fffff 	.word	0x800fffff
   13f1c:	3c900000 	.word	0x3c900000

00013f20 <_dtoa_r>:
   13f20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   13f24:	6a47      	ldr	r7, [r0, #36]	; 0x24
   13f26:	b099      	sub	sp, #100	; 0x64
   13f28:	4683      	mov	fp, r0
   13f2a:	9108      	str	r1, [sp, #32]
   13f2c:	920d      	str	r2, [sp, #52]	; 0x34
   13f2e:	9314      	str	r3, [sp, #80]	; 0x50
   13f30:	9e22      	ldr	r6, [sp, #136]	; 0x88
   13f32:	ec55 4b10 	vmov	r4, r5, d0
   13f36:	e9cd 4500 	strd	r4, r5, [sp]
   13f3a:	b947      	cbnz	r7, 13f4e <_dtoa_r+0x2e>
   13f3c:	2010      	movs	r0, #16
   13f3e:	f01d f971 	bl	31224 <malloc>
   13f42:	f8cb 0024 	str.w	r0, [fp, #36]	; 0x24
   13f46:	6007      	str	r7, [r0, #0]
   13f48:	60c7      	str	r7, [r0, #12]
   13f4a:	e9c0 7701 	strd	r7, r7, [r0, #4]
   13f4e:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   13f52:	6819      	ldr	r1, [r3, #0]
   13f54:	b159      	cbz	r1, 13f6e <_dtoa_r+0x4e>
   13f56:	685a      	ldr	r2, [r3, #4]
   13f58:	2301      	movs	r3, #1
   13f5a:	4658      	mov	r0, fp
   13f5c:	4093      	lsls	r3, r2
   13f5e:	604a      	str	r2, [r1, #4]
   13f60:	608b      	str	r3, [r1, #8]
   13f62:	f025 fb1e 	bl	395a2 <_Bfree>
   13f66:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   13f6a:	2200      	movs	r2, #0
   13f6c:	601a      	str	r2, [r3, #0]
   13f6e:	1e2b      	subs	r3, r5, #0
   13f70:	bfb7      	itett	lt
   13f72:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
   13f76:	2300      	movge	r3, #0
   13f78:	2201      	movlt	r2, #1
   13f7a:	9301      	strlt	r3, [sp, #4]
   13f7c:	bfa8      	it	ge
   13f7e:	6033      	strge	r3, [r6, #0]
   13f80:	9c01      	ldr	r4, [sp, #4]
   13f82:	4bb1      	ldr	r3, [pc, #708]	; (14248 <_dtoa_r+0x328>)
   13f84:	bfb8      	it	lt
   13f86:	6032      	strlt	r2, [r6, #0]
   13f88:	43a3      	bics	r3, r4
   13f8a:	d11a      	bne.n	13fc2 <_dtoa_r+0xa2>
   13f8c:	f242 730f 	movw	r3, #9999	; 0x270f
   13f90:	9a14      	ldr	r2, [sp, #80]	; 0x50
   13f92:	6013      	str	r3, [r2, #0]
   13f94:	f3c4 0313 	ubfx	r3, r4, #0, #20
   13f98:	9a00      	ldr	r2, [sp, #0]
   13f9a:	4313      	orrs	r3, r2
   13f9c:	f000 8547 	beq.w	14a2e <_dtoa_r+0xb0e>
   13fa0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   13fa2:	b953      	cbnz	r3, 13fba <_dtoa_r+0x9a>
   13fa4:	4ba9      	ldr	r3, [pc, #676]	; (1424c <_dtoa_r+0x32c>)
   13fa6:	e023      	b.n	13ff0 <_dtoa_r+0xd0>
   13fa8:	4ba9      	ldr	r3, [pc, #676]	; (14250 <_dtoa_r+0x330>)
   13faa:	9303      	str	r3, [sp, #12]
   13fac:	3308      	adds	r3, #8
   13fae:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   13fb0:	6013      	str	r3, [r2, #0]
   13fb2:	9803      	ldr	r0, [sp, #12]
   13fb4:	b019      	add	sp, #100	; 0x64
   13fb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13fba:	4ba4      	ldr	r3, [pc, #656]	; (1424c <_dtoa_r+0x32c>)
   13fbc:	9303      	str	r3, [sp, #12]
   13fbe:	3303      	adds	r3, #3
   13fc0:	e7f5      	b.n	13fae <_dtoa_r+0x8e>
   13fc2:	ed9d 7b00 	vldr	d7, [sp]
   13fc6:	2200      	movs	r2, #0
   13fc8:	2300      	movs	r3, #0
   13fca:	ec51 0b17 	vmov	r0, r1, d7
   13fce:	ed8d 7b0e 	vstr	d7, [sp, #56]	; 0x38
   13fd2:	f7f9 fad3 	bl	d57c <__aeabi_dcmpeq>
   13fd6:	4607      	mov	r7, r0
   13fd8:	b160      	cbz	r0, 13ff4 <_dtoa_r+0xd4>
   13fda:	2301      	movs	r3, #1
   13fdc:	9a14      	ldr	r2, [sp, #80]	; 0x50
   13fde:	6013      	str	r3, [r2, #0]
   13fe0:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   13fe2:	2b00      	cmp	r3, #0
   13fe4:	f000 8520 	beq.w	14a28 <_dtoa_r+0xb08>
   13fe8:	4b9a      	ldr	r3, [pc, #616]	; (14254 <_dtoa_r+0x334>)
   13fea:	9a23      	ldr	r2, [sp, #140]	; 0x8c
   13fec:	6013      	str	r3, [r2, #0]
   13fee:	3b01      	subs	r3, #1
   13ff0:	9303      	str	r3, [sp, #12]
   13ff2:	e7de      	b.n	13fb2 <_dtoa_r+0x92>
   13ff4:	f3c4 560a 	ubfx	r6, r4, #20, #11
   13ff8:	aa16      	add	r2, sp, #88	; 0x58
   13ffa:	a917      	add	r1, sp, #92	; 0x5c
   13ffc:	4658      	mov	r0, fp
   13ffe:	ed9d 0b0e 	vldr	d0, [sp, #56]	; 0x38
   14002:	f025 fcd7 	bl	399b4 <__d2b>
   14006:	4680      	mov	r8, r0
   14008:	2e00      	cmp	r6, #0
   1400a:	d07d      	beq.n	14108 <_dtoa_r+0x1e8>
   1400c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   1400e:	f2a6 36ff 	subw	r6, r6, #1023	; 0x3ff
   14012:	9715      	str	r7, [sp, #84]	; 0x54
   14014:	f3c3 0313 	ubfx	r3, r3, #0, #20
   14018:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
   1401c:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
   14020:	f445 1540 	orr.w	r5, r5, #3145728	; 0x300000
   14024:	2200      	movs	r2, #0
   14026:	4b8c      	ldr	r3, [pc, #560]	; (14258 <_dtoa_r+0x338>)
   14028:	4620      	mov	r0, r4
   1402a:	4629      	mov	r1, r5
   1402c:	f7f8 fe86 	bl	cd3c <__aeabi_dsub>
   14030:	a37f      	add	r3, pc, #508	; (adr r3, 14230 <_dtoa_r+0x310>)
   14032:	e9d3 2300 	ldrd	r2, r3, [r3]
   14036:	f7f9 f839 	bl	d0ac <__aeabi_dmul>
   1403a:	a37f      	add	r3, pc, #508	; (adr r3, 14238 <_dtoa_r+0x318>)
   1403c:	e9d3 2300 	ldrd	r2, r3, [r3]
   14040:	f7f8 fe7e 	bl	cd40 <__adddf3>
   14044:	4604      	mov	r4, r0
   14046:	460d      	mov	r5, r1
   14048:	4630      	mov	r0, r6
   1404a:	f7f8 ffc5 	bl	cfd8 <__aeabi_i2d>
   1404e:	a37c      	add	r3, pc, #496	; (adr r3, 14240 <_dtoa_r+0x320>)
   14050:	e9d3 2300 	ldrd	r2, r3, [r3]
   14054:	f7f9 f82a 	bl	d0ac <__aeabi_dmul>
   14058:	4602      	mov	r2, r0
   1405a:	460b      	mov	r3, r1
   1405c:	4620      	mov	r0, r4
   1405e:	4629      	mov	r1, r5
   14060:	f7f8 fe6e 	bl	cd40 <__adddf3>
   14064:	4604      	mov	r4, r0
   14066:	460d      	mov	r5, r1
   14068:	f7f9 faba 	bl	d5e0 <__aeabi_d2iz>
   1406c:	2200      	movs	r2, #0
   1406e:	4682      	mov	sl, r0
   14070:	2300      	movs	r3, #0
   14072:	4620      	mov	r0, r4
   14074:	4629      	mov	r1, r5
   14076:	f7f9 fa8b 	bl	d590 <__aeabi_dcmplt>
   1407a:	b148      	cbz	r0, 14090 <_dtoa_r+0x170>
   1407c:	4650      	mov	r0, sl
   1407e:	f7f8 ffab 	bl	cfd8 <__aeabi_i2d>
   14082:	4622      	mov	r2, r4
   14084:	462b      	mov	r3, r5
   14086:	f7f9 fa79 	bl	d57c <__aeabi_dcmpeq>
   1408a:	b908      	cbnz	r0, 14090 <_dtoa_r+0x170>
   1408c:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   14090:	f1ba 0f16 	cmp.w	sl, #22
   14094:	d857      	bhi.n	14146 <_dtoa_r+0x226>
   14096:	4b71      	ldr	r3, [pc, #452]	; (1425c <_dtoa_r+0x33c>)
   14098:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1409c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   140a0:	e9d3 2300 	ldrd	r2, r3, [r3]
   140a4:	f7f9 fa74 	bl	d590 <__aeabi_dcmplt>
   140a8:	2800      	cmp	r0, #0
   140aa:	d04e      	beq.n	1414a <_dtoa_r+0x22a>
   140ac:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   140b0:	2300      	movs	r3, #0
   140b2:	9311      	str	r3, [sp, #68]	; 0x44
   140b4:	9b16      	ldr	r3, [sp, #88]	; 0x58
   140b6:	1b9e      	subs	r6, r3, r6
   140b8:	1e73      	subs	r3, r6, #1
   140ba:	9307      	str	r3, [sp, #28]
   140bc:	bf49      	itett	mi
   140be:	f1c6 0301 	rsbmi	r3, r6, #1
   140c2:	2300      	movpl	r3, #0
   140c4:	9306      	strmi	r3, [sp, #24]
   140c6:	2300      	movmi	r3, #0
   140c8:	bf54      	ite	pl
   140ca:	9306      	strpl	r3, [sp, #24]
   140cc:	9307      	strmi	r3, [sp, #28]
   140ce:	f1ba 0f00 	cmp.w	sl, #0
   140d2:	db3c      	blt.n	1414e <_dtoa_r+0x22e>
   140d4:	9b07      	ldr	r3, [sp, #28]
   140d6:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
   140da:	4453      	add	r3, sl
   140dc:	9307      	str	r3, [sp, #28]
   140de:	2300      	movs	r3, #0
   140e0:	9309      	str	r3, [sp, #36]	; 0x24
   140e2:	9b08      	ldr	r3, [sp, #32]
   140e4:	2b09      	cmp	r3, #9
   140e6:	f200 808d 	bhi.w	14204 <_dtoa_r+0x2e4>
   140ea:	2b05      	cmp	r3, #5
   140ec:	bfc5      	ittet	gt
   140ee:	3b04      	subgt	r3, #4
   140f0:	2400      	movgt	r4, #0
   140f2:	2401      	movle	r4, #1
   140f4:	9308      	strgt	r3, [sp, #32]
   140f6:	9b08      	ldr	r3, [sp, #32]
   140f8:	3b02      	subs	r3, #2
   140fa:	2b03      	cmp	r3, #3
   140fc:	f200 808d 	bhi.w	1421a <_dtoa_r+0x2fa>
   14100:	e8df f003 	tbb	[pc, r3]
   14104:	7e3a3c2f 	.word	0x7e3a3c2f
   14108:	e9dd 6316 	ldrd	r6, r3, [sp, #88]	; 0x58
   1410c:	441e      	add	r6, r3
   1410e:	f206 4032 	addw	r0, r6, #1074	; 0x432
   14112:	2820      	cmp	r0, #32
   14114:	dd11      	ble.n	1413a <_dtoa_r+0x21a>
   14116:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
   1411a:	9b00      	ldr	r3, [sp, #0]
   1411c:	4084      	lsls	r4, r0
   1411e:	f206 4012 	addw	r0, r6, #1042	; 0x412
   14122:	fa23 f000 	lsr.w	r0, r3, r0
   14126:	4320      	orrs	r0, r4
   14128:	f7f8 ff46 	bl	cfb8 <__aeabi_ui2d>
   1412c:	2301      	movs	r3, #1
   1412e:	4604      	mov	r4, r0
   14130:	f1a1 75f8 	sub.w	r5, r1, #32505856	; 0x1f00000
   14134:	3e01      	subs	r6, #1
   14136:	9315      	str	r3, [sp, #84]	; 0x54
   14138:	e774      	b.n	14024 <_dtoa_r+0x104>
   1413a:	f1c0 0020 	rsb	r0, r0, #32
   1413e:	9b00      	ldr	r3, [sp, #0]
   14140:	fa03 f000 	lsl.w	r0, r3, r0
   14144:	e7f0      	b.n	14128 <_dtoa_r+0x208>
   14146:	2301      	movs	r3, #1
   14148:	e7b3      	b.n	140b2 <_dtoa_r+0x192>
   1414a:	9011      	str	r0, [sp, #68]	; 0x44
   1414c:	e7b2      	b.n	140b4 <_dtoa_r+0x194>
   1414e:	9b06      	ldr	r3, [sp, #24]
   14150:	eba3 030a 	sub.w	r3, r3, sl
   14154:	9306      	str	r3, [sp, #24]
   14156:	f1ca 0300 	rsb	r3, sl, #0
   1415a:	9309      	str	r3, [sp, #36]	; 0x24
   1415c:	2300      	movs	r3, #0
   1415e:	9310      	str	r3, [sp, #64]	; 0x40
   14160:	e7bf      	b.n	140e2 <_dtoa_r+0x1c2>
   14162:	2300      	movs	r3, #0
   14164:	930c      	str	r3, [sp, #48]	; 0x30
   14166:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14168:	2b00      	cmp	r3, #0
   1416a:	dc59      	bgt.n	14220 <_dtoa_r+0x300>
   1416c:	2301      	movs	r3, #1
   1416e:	4699      	mov	r9, r3
   14170:	461a      	mov	r2, r3
   14172:	9304      	str	r3, [sp, #16]
   14174:	920d      	str	r2, [sp, #52]	; 0x34
   14176:	e00c      	b.n	14192 <_dtoa_r+0x272>
   14178:	2301      	movs	r3, #1
   1417a:	e7f3      	b.n	14164 <_dtoa_r+0x244>
   1417c:	2300      	movs	r3, #0
   1417e:	930c      	str	r3, [sp, #48]	; 0x30
   14180:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14182:	4453      	add	r3, sl
   14184:	f103 0901 	add.w	r9, r3, #1
   14188:	9304      	str	r3, [sp, #16]
   1418a:	464b      	mov	r3, r9
   1418c:	2b01      	cmp	r3, #1
   1418e:	bfb8      	it	lt
   14190:	2301      	movlt	r3, #1
   14192:	2200      	movs	r2, #0
   14194:	f8db 5024 	ldr.w	r5, [fp, #36]	; 0x24
   14198:	606a      	str	r2, [r5, #4]
   1419a:	2204      	movs	r2, #4
   1419c:	f102 0014 	add.w	r0, r2, #20
   141a0:	6869      	ldr	r1, [r5, #4]
   141a2:	4298      	cmp	r0, r3
   141a4:	d940      	bls.n	14228 <_dtoa_r+0x308>
   141a6:	4658      	mov	r0, fp
   141a8:	f025 f9c7 	bl	3953a <_Balloc>
   141ac:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   141b0:	6028      	str	r0, [r5, #0]
   141b2:	f1b9 0f0e 	cmp.w	r9, #14
   141b6:	681b      	ldr	r3, [r3, #0]
   141b8:	9303      	str	r3, [sp, #12]
   141ba:	f200 80d4 	bhi.w	14366 <_dtoa_r+0x446>
   141be:	2c00      	cmp	r4, #0
   141c0:	f000 80d1 	beq.w	14366 <_dtoa_r+0x446>
   141c4:	f1ba 0f00 	cmp.w	sl, #0
   141c8:	dd66      	ble.n	14298 <_dtoa_r+0x378>
   141ca:	4a24      	ldr	r2, [pc, #144]	; (1425c <_dtoa_r+0x33c>)
   141cc:	f00a 030f 	and.w	r3, sl, #15
   141d0:	ea4f 142a 	mov.w	r4, sl, asr #4
   141d4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   141d8:	06e2      	lsls	r2, r4, #27
   141da:	ed93 7b00 	vldr	d7, [r3]
   141de:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
   141e2:	d557      	bpl.n	14294 <_dtoa_r+0x374>
   141e4:	4b1e      	ldr	r3, [pc, #120]	; (14260 <_dtoa_r+0x340>)
   141e6:	f004 040f 	and.w	r4, r4, #15
   141ea:	2603      	movs	r6, #3
   141ec:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
   141f0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   141f4:	f7f9 f884 	bl	d300 <__aeabi_ddiv>
   141f8:	e9cd 0100 	strd	r0, r1, [sp]
   141fc:	4d18      	ldr	r5, [pc, #96]	; (14260 <_dtoa_r+0x340>)
   141fe:	e03e      	b.n	1427e <_dtoa_r+0x35e>
   14200:	2301      	movs	r3, #1
   14202:	e7bc      	b.n	1417e <_dtoa_r+0x25e>
   14204:	2401      	movs	r4, #1
   14206:	2300      	movs	r3, #0
   14208:	940c      	str	r4, [sp, #48]	; 0x30
   1420a:	9308      	str	r3, [sp, #32]
   1420c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   14210:	2200      	movs	r2, #0
   14212:	9304      	str	r3, [sp, #16]
   14214:	4699      	mov	r9, r3
   14216:	2312      	movs	r3, #18
   14218:	e7ac      	b.n	14174 <_dtoa_r+0x254>
   1421a:	2301      	movs	r3, #1
   1421c:	930c      	str	r3, [sp, #48]	; 0x30
   1421e:	e7f5      	b.n	1420c <_dtoa_r+0x2ec>
   14220:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14222:	9304      	str	r3, [sp, #16]
   14224:	4699      	mov	r9, r3
   14226:	e7b4      	b.n	14192 <_dtoa_r+0x272>
   14228:	3101      	adds	r1, #1
   1422a:	0052      	lsls	r2, r2, #1
   1422c:	6069      	str	r1, [r5, #4]
   1422e:	e7b5      	b.n	1419c <_dtoa_r+0x27c>
   14230:	636f4361 	.word	0x636f4361
   14234:	3fd287a7 	.word	0x3fd287a7
   14238:	8b60c8b3 	.word	0x8b60c8b3
   1423c:	3fc68a28 	.word	0x3fc68a28
   14240:	509f79fb 	.word	0x509f79fb
   14244:	3fd34413 	.word	0x3fd34413
   14248:	7ff00000 	.word	0x7ff00000
   1424c:	00040994 	.word	0x00040994
   14250:	0004098b 	.word	0x0004098b
   14254:	0003fd3c 	.word	0x0003fd3c
   14258:	3ff80000 	.word	0x3ff80000
   1425c:	0003a170 	.word	0x0003a170
   14260:	0003a148 	.word	0x0003a148
   14264:	07e3      	lsls	r3, r4, #31
   14266:	d508      	bpl.n	1427a <_dtoa_r+0x35a>
   14268:	3601      	adds	r6, #1
   1426a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
   1426e:	e9d5 2300 	ldrd	r2, r3, [r5]
   14272:	f7f8 ff1b 	bl	d0ac <__aeabi_dmul>
   14276:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
   1427a:	1064      	asrs	r4, r4, #1
   1427c:	3508      	adds	r5, #8
   1427e:	2c00      	cmp	r4, #0
   14280:	d1f0      	bne.n	14264 <_dtoa_r+0x344>
   14282:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   14286:	e9dd 0100 	ldrd	r0, r1, [sp]
   1428a:	f7f9 f839 	bl	d300 <__aeabi_ddiv>
   1428e:	e9cd 0100 	strd	r0, r1, [sp]
   14292:	e01a      	b.n	142ca <_dtoa_r+0x3aa>
   14294:	2602      	movs	r6, #2
   14296:	e7b1      	b.n	141fc <_dtoa_r+0x2dc>
   14298:	f000 809f 	beq.w	143da <_dtoa_r+0x4ba>
   1429c:	f1ca 0400 	rsb	r4, sl, #0
   142a0:	4b9e      	ldr	r3, [pc, #632]	; (1451c <_dtoa_r+0x5fc>)
   142a2:	4d9f      	ldr	r5, [pc, #636]	; (14520 <_dtoa_r+0x600>)
   142a4:	2602      	movs	r6, #2
   142a6:	f004 020f 	and.w	r2, r4, #15
   142aa:	1124      	asrs	r4, r4, #4
   142ac:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
   142b0:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   142b4:	e9d3 2300 	ldrd	r2, r3, [r3]
   142b8:	f7f8 fef8 	bl	d0ac <__aeabi_dmul>
   142bc:	2300      	movs	r3, #0
   142be:	e9cd 0100 	strd	r0, r1, [sp]
   142c2:	2c00      	cmp	r4, #0
   142c4:	d17e      	bne.n	143c4 <_dtoa_r+0x4a4>
   142c6:	2b00      	cmp	r3, #0
   142c8:	d1e1      	bne.n	1428e <_dtoa_r+0x36e>
   142ca:	9b11      	ldr	r3, [sp, #68]	; 0x44
   142cc:	2b00      	cmp	r3, #0
   142ce:	f000 8086 	beq.w	143de <_dtoa_r+0x4be>
   142d2:	2200      	movs	r2, #0
   142d4:	4b93      	ldr	r3, [pc, #588]	; (14524 <_dtoa_r+0x604>)
   142d6:	e9dd 4500 	ldrd	r4, r5, [sp]
   142da:	4620      	mov	r0, r4
   142dc:	4629      	mov	r1, r5
   142de:	f7f9 f957 	bl	d590 <__aeabi_dcmplt>
   142e2:	2800      	cmp	r0, #0
   142e4:	d07b      	beq.n	143de <_dtoa_r+0x4be>
   142e6:	f1b9 0f00 	cmp.w	r9, #0
   142ea:	d078      	beq.n	143de <_dtoa_r+0x4be>
   142ec:	9b04      	ldr	r3, [sp, #16]
   142ee:	2b00      	cmp	r3, #0
   142f0:	dd35      	ble.n	1435e <_dtoa_r+0x43e>
   142f2:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   142f6:	4620      	mov	r0, r4
   142f8:	2200      	movs	r2, #0
   142fa:	4629      	mov	r1, r5
   142fc:	930a      	str	r3, [sp, #40]	; 0x28
   142fe:	3601      	adds	r6, #1
   14300:	4b89      	ldr	r3, [pc, #548]	; (14528 <_dtoa_r+0x608>)
   14302:	f7f8 fed3 	bl	d0ac <__aeabi_dmul>
   14306:	9c04      	ldr	r4, [sp, #16]
   14308:	e9cd 0100 	strd	r0, r1, [sp]
   1430c:	4630      	mov	r0, r6
   1430e:	f7f8 fe63 	bl	cfd8 <__aeabi_i2d>
   14312:	e9dd 2300 	ldrd	r2, r3, [sp]
   14316:	f7f8 fec9 	bl	d0ac <__aeabi_dmul>
   1431a:	2200      	movs	r2, #0
   1431c:	4b83      	ldr	r3, [pc, #524]	; (1452c <_dtoa_r+0x60c>)
   1431e:	f7f8 fd0f 	bl	cd40 <__adddf3>
   14322:	4606      	mov	r6, r0
   14324:	f1a1 7750 	sub.w	r7, r1, #54525952	; 0x3400000
   14328:	2c00      	cmp	r4, #0
   1432a:	d15c      	bne.n	143e6 <_dtoa_r+0x4c6>
   1432c:	2200      	movs	r2, #0
   1432e:	4b80      	ldr	r3, [pc, #512]	; (14530 <_dtoa_r+0x610>)
   14330:	e9dd 0100 	ldrd	r0, r1, [sp]
   14334:	f7f8 fd02 	bl	cd3c <__aeabi_dsub>
   14338:	4632      	mov	r2, r6
   1433a:	463b      	mov	r3, r7
   1433c:	e9cd 0100 	strd	r0, r1, [sp]
   14340:	f7f9 f944 	bl	d5cc <__aeabi_dcmpgt>
   14344:	2800      	cmp	r0, #0
   14346:	f040 8289 	bne.w	1485c <_dtoa_r+0x93c>
   1434a:	4632      	mov	r2, r6
   1434c:	f107 4300 	add.w	r3, r7, #2147483648	; 0x80000000
   14350:	e9dd 0100 	ldrd	r0, r1, [sp]
   14354:	f7f9 f91c 	bl	d590 <__aeabi_dcmplt>
   14358:	2800      	cmp	r0, #0
   1435a:	f040 827d 	bne.w	14858 <_dtoa_r+0x938>
   1435e:	e9dd 340e 	ldrd	r3, r4, [sp, #56]	; 0x38
   14362:	e9cd 3400 	strd	r3, r4, [sp]
   14366:	9b17      	ldr	r3, [sp, #92]	; 0x5c
   14368:	2b00      	cmp	r3, #0
   1436a:	f2c0 814c 	blt.w	14606 <_dtoa_r+0x6e6>
   1436e:	f1ba 0f0e 	cmp.w	sl, #14
   14372:	f300 8148 	bgt.w	14606 <_dtoa_r+0x6e6>
   14376:	4b69      	ldr	r3, [pc, #420]	; (1451c <_dtoa_r+0x5fc>)
   14378:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
   1437c:	ed93 7b00 	vldr	d7, [r3]
   14380:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14382:	2b00      	cmp	r3, #0
   14384:	ed8d 7b04 	vstr	d7, [sp, #16]
   14388:	f280 80d6 	bge.w	14538 <_dtoa_r+0x618>
   1438c:	f1b9 0f00 	cmp.w	r9, #0
   14390:	f300 80d2 	bgt.w	14538 <_dtoa_r+0x618>
   14394:	f040 825f 	bne.w	14856 <_dtoa_r+0x936>
   14398:	2200      	movs	r2, #0
   1439a:	4b65      	ldr	r3, [pc, #404]	; (14530 <_dtoa_r+0x610>)
   1439c:	464c      	mov	r4, r9
   1439e:	464e      	mov	r6, r9
   143a0:	ec51 0b17 	vmov	r0, r1, d7
   143a4:	f7f8 fe82 	bl	d0ac <__aeabi_dmul>
   143a8:	e9dd 2300 	ldrd	r2, r3, [sp]
   143ac:	f7f9 f904 	bl	d5b8 <__aeabi_dcmpge>
   143b0:	2800      	cmp	r0, #0
   143b2:	f040 8238 	bne.w	14826 <_dtoa_r+0x906>
   143b6:	9d03      	ldr	r5, [sp, #12]
   143b8:	2331      	movs	r3, #49	; 0x31
   143ba:	f10a 0a01 	add.w	sl, sl, #1
   143be:	f805 3b01 	strb.w	r3, [r5], #1
   143c2:	e234      	b.n	1482e <_dtoa_r+0x90e>
   143c4:	07e7      	lsls	r7, r4, #31
   143c6:	d505      	bpl.n	143d4 <_dtoa_r+0x4b4>
   143c8:	3601      	adds	r6, #1
   143ca:	e9d5 2300 	ldrd	r2, r3, [r5]
   143ce:	f7f8 fe6d 	bl	d0ac <__aeabi_dmul>
   143d2:	2301      	movs	r3, #1
   143d4:	1064      	asrs	r4, r4, #1
   143d6:	3508      	adds	r5, #8
   143d8:	e773      	b.n	142c2 <_dtoa_r+0x3a2>
   143da:	2602      	movs	r6, #2
   143dc:	e775      	b.n	142ca <_dtoa_r+0x3aa>
   143de:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   143e2:	464c      	mov	r4, r9
   143e4:	e792      	b.n	1430c <_dtoa_r+0x3ec>
   143e6:	4b4d      	ldr	r3, [pc, #308]	; (1451c <_dtoa_r+0x5fc>)
   143e8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   143ec:	e953 0102 	ldrd	r0, r1, [r3, #-8]
   143f0:	9b03      	ldr	r3, [sp, #12]
   143f2:	441c      	add	r4, r3
   143f4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   143f6:	2b00      	cmp	r3, #0
   143f8:	d046      	beq.n	14488 <_dtoa_r+0x568>
   143fa:	4602      	mov	r2, r0
   143fc:	460b      	mov	r3, r1
   143fe:	2000      	movs	r0, #0
   14400:	494c      	ldr	r1, [pc, #304]	; (14534 <_dtoa_r+0x614>)
   14402:	f7f8 ff7d 	bl	d300 <__aeabi_ddiv>
   14406:	4632      	mov	r2, r6
   14408:	463b      	mov	r3, r7
   1440a:	f7f8 fc97 	bl	cd3c <__aeabi_dsub>
   1440e:	9d03      	ldr	r5, [sp, #12]
   14410:	4606      	mov	r6, r0
   14412:	460f      	mov	r7, r1
   14414:	e9dd 0100 	ldrd	r0, r1, [sp]
   14418:	f7f9 f8e2 	bl	d5e0 <__aeabi_d2iz>
   1441c:	9012      	str	r0, [sp, #72]	; 0x48
   1441e:	f7f8 fddb 	bl	cfd8 <__aeabi_i2d>
   14422:	4602      	mov	r2, r0
   14424:	460b      	mov	r3, r1
   14426:	e9dd 0100 	ldrd	r0, r1, [sp]
   1442a:	f7f8 fc87 	bl	cd3c <__aeabi_dsub>
   1442e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   14430:	4632      	mov	r2, r6
   14432:	3330      	adds	r3, #48	; 0x30
   14434:	f805 3b01 	strb.w	r3, [r5], #1
   14438:	463b      	mov	r3, r7
   1443a:	e9cd 0100 	strd	r0, r1, [sp]
   1443e:	f7f9 f8a7 	bl	d590 <__aeabi_dcmplt>
   14442:	2800      	cmp	r0, #0
   14444:	d15f      	bne.n	14506 <_dtoa_r+0x5e6>
   14446:	2000      	movs	r0, #0
   14448:	4936      	ldr	r1, [pc, #216]	; (14524 <_dtoa_r+0x604>)
   1444a:	e9dd 2300 	ldrd	r2, r3, [sp]
   1444e:	f7f8 fc75 	bl	cd3c <__aeabi_dsub>
   14452:	4632      	mov	r2, r6
   14454:	463b      	mov	r3, r7
   14456:	f7f9 f89b 	bl	d590 <__aeabi_dcmplt>
   1445a:	2800      	cmp	r0, #0
   1445c:	f040 80b2 	bne.w	145c4 <_dtoa_r+0x6a4>
   14460:	42a5      	cmp	r5, r4
   14462:	f43f af7c 	beq.w	1435e <_dtoa_r+0x43e>
   14466:	2200      	movs	r2, #0
   14468:	4b2f      	ldr	r3, [pc, #188]	; (14528 <_dtoa_r+0x608>)
   1446a:	4630      	mov	r0, r6
   1446c:	4639      	mov	r1, r7
   1446e:	f7f8 fe1d 	bl	d0ac <__aeabi_dmul>
   14472:	2200      	movs	r2, #0
   14474:	4606      	mov	r6, r0
   14476:	460f      	mov	r7, r1
   14478:	4b2b      	ldr	r3, [pc, #172]	; (14528 <_dtoa_r+0x608>)
   1447a:	e9dd 0100 	ldrd	r0, r1, [sp]
   1447e:	f7f8 fe15 	bl	d0ac <__aeabi_dmul>
   14482:	e9cd 0100 	strd	r0, r1, [sp]
   14486:	e7c5      	b.n	14414 <_dtoa_r+0x4f4>
   14488:	4632      	mov	r2, r6
   1448a:	463b      	mov	r3, r7
   1448c:	f7f8 fe0e 	bl	d0ac <__aeabi_dmul>
   14490:	4625      	mov	r5, r4
   14492:	9e03      	ldr	r6, [sp, #12]
   14494:	e9cd 0112 	strd	r0, r1, [sp, #72]	; 0x48
   14498:	e9dd 0100 	ldrd	r0, r1, [sp]
   1449c:	f7f9 f8a0 	bl	d5e0 <__aeabi_d2iz>
   144a0:	4607      	mov	r7, r0
   144a2:	f7f8 fd99 	bl	cfd8 <__aeabi_i2d>
   144a6:	4602      	mov	r2, r0
   144a8:	3730      	adds	r7, #48	; 0x30
   144aa:	460b      	mov	r3, r1
   144ac:	e9dd 0100 	ldrd	r0, r1, [sp]
   144b0:	f7f8 fc44 	bl	cd3c <__aeabi_dsub>
   144b4:	f806 7b01 	strb.w	r7, [r6], #1
   144b8:	42a6      	cmp	r6, r4
   144ba:	f04f 0200 	mov.w	r2, #0
   144be:	e9cd 0100 	strd	r0, r1, [sp]
   144c2:	d125      	bne.n	14510 <_dtoa_r+0x5f0>
   144c4:	4b1b      	ldr	r3, [pc, #108]	; (14534 <_dtoa_r+0x614>)
   144c6:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
   144ca:	f7f8 fc39 	bl	cd40 <__adddf3>
   144ce:	4602      	mov	r2, r0
   144d0:	460b      	mov	r3, r1
   144d2:	e9dd 0100 	ldrd	r0, r1, [sp]
   144d6:	f7f9 f879 	bl	d5cc <__aeabi_dcmpgt>
   144da:	2800      	cmp	r0, #0
   144dc:	d172      	bne.n	145c4 <_dtoa_r+0x6a4>
   144de:	2000      	movs	r0, #0
   144e0:	4914      	ldr	r1, [pc, #80]	; (14534 <_dtoa_r+0x614>)
   144e2:	e9dd 2312 	ldrd	r2, r3, [sp, #72]	; 0x48
   144e6:	f7f8 fc29 	bl	cd3c <__aeabi_dsub>
   144ea:	4602      	mov	r2, r0
   144ec:	460b      	mov	r3, r1
   144ee:	e9dd 0100 	ldrd	r0, r1, [sp]
   144f2:	f7f9 f84d 	bl	d590 <__aeabi_dcmplt>
   144f6:	2800      	cmp	r0, #0
   144f8:	f43f af31 	beq.w	1435e <_dtoa_r+0x43e>
   144fc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   14500:	1e6a      	subs	r2, r5, #1
   14502:	2b30      	cmp	r3, #48	; 0x30
   14504:	d002      	beq.n	1450c <_dtoa_r+0x5ec>
   14506:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   1450a:	e049      	b.n	145a0 <_dtoa_r+0x680>
   1450c:	4615      	mov	r5, r2
   1450e:	e7f5      	b.n	144fc <_dtoa_r+0x5dc>
   14510:	4b05      	ldr	r3, [pc, #20]	; (14528 <_dtoa_r+0x608>)
   14512:	f7f8 fdcb 	bl	d0ac <__aeabi_dmul>
   14516:	e9cd 0100 	strd	r0, r1, [sp]
   1451a:	e7bd      	b.n	14498 <_dtoa_r+0x578>
   1451c:	0003a170 	.word	0x0003a170
   14520:	0003a148 	.word	0x0003a148
   14524:	3ff00000 	.word	0x3ff00000
   14528:	40240000 	.word	0x40240000
   1452c:	401c0000 	.word	0x401c0000
   14530:	40140000 	.word	0x40140000
   14534:	3fe00000 	.word	0x3fe00000
   14538:	e9dd 6700 	ldrd	r6, r7, [sp]
   1453c:	9d03      	ldr	r5, [sp, #12]
   1453e:	4630      	mov	r0, r6
   14540:	4639      	mov	r1, r7
   14542:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   14546:	f7f8 fedb 	bl	d300 <__aeabi_ddiv>
   1454a:	f7f9 f849 	bl	d5e0 <__aeabi_d2iz>
   1454e:	4604      	mov	r4, r0
   14550:	f7f8 fd42 	bl	cfd8 <__aeabi_i2d>
   14554:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   14558:	f7f8 fda8 	bl	d0ac <__aeabi_dmul>
   1455c:	4602      	mov	r2, r0
   1455e:	4630      	mov	r0, r6
   14560:	f104 0630 	add.w	r6, r4, #48	; 0x30
   14564:	460b      	mov	r3, r1
   14566:	4639      	mov	r1, r7
   14568:	f7f8 fbe8 	bl	cd3c <__aeabi_dsub>
   1456c:	f805 6b01 	strb.w	r6, [r5], #1
   14570:	9e03      	ldr	r6, [sp, #12]
   14572:	4602      	mov	r2, r0
   14574:	460b      	mov	r3, r1
   14576:	1bae      	subs	r6, r5, r6
   14578:	45b1      	cmp	r9, r6
   1457a:	d137      	bne.n	145ec <_dtoa_r+0x6cc>
   1457c:	f7f8 fbe0 	bl	cd40 <__adddf3>
   14580:	4606      	mov	r6, r0
   14582:	460f      	mov	r7, r1
   14584:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   14588:	f7f9 f820 	bl	d5cc <__aeabi_dcmpgt>
   1458c:	b9c0      	cbnz	r0, 145c0 <_dtoa_r+0x6a0>
   1458e:	4630      	mov	r0, r6
   14590:	4639      	mov	r1, r7
   14592:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   14596:	f7f8 fff1 	bl	d57c <__aeabi_dcmpeq>
   1459a:	b108      	cbz	r0, 145a0 <_dtoa_r+0x680>
   1459c:	07e1      	lsls	r1, r4, #31
   1459e:	d40f      	bmi.n	145c0 <_dtoa_r+0x6a0>
   145a0:	4641      	mov	r1, r8
   145a2:	4658      	mov	r0, fp
   145a4:	f024 fffd 	bl	395a2 <_Bfree>
   145a8:	2300      	movs	r3, #0
   145aa:	9a14      	ldr	r2, [sp, #80]	; 0x50
   145ac:	702b      	strb	r3, [r5, #0]
   145ae:	f10a 0301 	add.w	r3, sl, #1
   145b2:	6013      	str	r3, [r2, #0]
   145b4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   145b6:	2b00      	cmp	r3, #0
   145b8:	f43f acfb 	beq.w	13fb2 <_dtoa_r+0x92>
   145bc:	601d      	str	r5, [r3, #0]
   145be:	e4f8      	b.n	13fb2 <_dtoa_r+0x92>
   145c0:	f8cd a028 	str.w	sl, [sp, #40]	; 0x28
   145c4:	f815 2c01 	ldrb.w	r2, [r5, #-1]
   145c8:	1e6b      	subs	r3, r5, #1
   145ca:	2a39      	cmp	r2, #57	; 0x39
   145cc:	d108      	bne.n	145e0 <_dtoa_r+0x6c0>
   145ce:	9a03      	ldr	r2, [sp, #12]
   145d0:	429a      	cmp	r2, r3
   145d2:	d109      	bne.n	145e8 <_dtoa_r+0x6c8>
   145d4:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   145d6:	9903      	ldr	r1, [sp, #12]
   145d8:	3201      	adds	r2, #1
   145da:	920a      	str	r2, [sp, #40]	; 0x28
   145dc:	2230      	movs	r2, #48	; 0x30
   145de:	700a      	strb	r2, [r1, #0]
   145e0:	781a      	ldrb	r2, [r3, #0]
   145e2:	3201      	adds	r2, #1
   145e4:	701a      	strb	r2, [r3, #0]
   145e6:	e78e      	b.n	14506 <_dtoa_r+0x5e6>
   145e8:	461d      	mov	r5, r3
   145ea:	e7eb      	b.n	145c4 <_dtoa_r+0x6a4>
   145ec:	2200      	movs	r2, #0
   145ee:	4b9d      	ldr	r3, [pc, #628]	; (14864 <_dtoa_r+0x944>)
   145f0:	f7f8 fd5c 	bl	d0ac <__aeabi_dmul>
   145f4:	2200      	movs	r2, #0
   145f6:	2300      	movs	r3, #0
   145f8:	4606      	mov	r6, r0
   145fa:	460f      	mov	r7, r1
   145fc:	f7f8 ffbe 	bl	d57c <__aeabi_dcmpeq>
   14600:	2800      	cmp	r0, #0
   14602:	d09c      	beq.n	1453e <_dtoa_r+0x61e>
   14604:	e7cc      	b.n	145a0 <_dtoa_r+0x680>
   14606:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14608:	2a00      	cmp	r2, #0
   1460a:	f000 80cb 	beq.w	147a4 <_dtoa_r+0x884>
   1460e:	9a08      	ldr	r2, [sp, #32]
   14610:	2a01      	cmp	r2, #1
   14612:	f300 80ae 	bgt.w	14772 <_dtoa_r+0x852>
   14616:	9a15      	ldr	r2, [sp, #84]	; 0x54
   14618:	2a00      	cmp	r2, #0
   1461a:	f000 80a6 	beq.w	1476a <_dtoa_r+0x84a>
   1461e:	f203 4333 	addw	r3, r3, #1075	; 0x433
   14622:	9c09      	ldr	r4, [sp, #36]	; 0x24
   14624:	9d06      	ldr	r5, [sp, #24]
   14626:	9a06      	ldr	r2, [sp, #24]
   14628:	2101      	movs	r1, #1
   1462a:	4658      	mov	r0, fp
   1462c:	441a      	add	r2, r3
   1462e:	9206      	str	r2, [sp, #24]
   14630:	9a07      	ldr	r2, [sp, #28]
   14632:	441a      	add	r2, r3
   14634:	9207      	str	r2, [sp, #28]
   14636:	f025 f858 	bl	396ea <__i2b>
   1463a:	4606      	mov	r6, r0
   1463c:	2d00      	cmp	r5, #0
   1463e:	dd0c      	ble.n	1465a <_dtoa_r+0x73a>
   14640:	9b07      	ldr	r3, [sp, #28]
   14642:	2b00      	cmp	r3, #0
   14644:	dd09      	ble.n	1465a <_dtoa_r+0x73a>
   14646:	42ab      	cmp	r3, r5
   14648:	9a06      	ldr	r2, [sp, #24]
   1464a:	bfa8      	it	ge
   1464c:	462b      	movge	r3, r5
   1464e:	1ad2      	subs	r2, r2, r3
   14650:	1aed      	subs	r5, r5, r3
   14652:	9206      	str	r2, [sp, #24]
   14654:	9a07      	ldr	r2, [sp, #28]
   14656:	1ad3      	subs	r3, r2, r3
   14658:	9307      	str	r3, [sp, #28]
   1465a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1465c:	b1f3      	cbz	r3, 1469c <_dtoa_r+0x77c>
   1465e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   14660:	2b00      	cmp	r3, #0
   14662:	f000 80a3 	beq.w	147ac <_dtoa_r+0x88c>
   14666:	2c00      	cmp	r4, #0
   14668:	dd10      	ble.n	1468c <_dtoa_r+0x76c>
   1466a:	4631      	mov	r1, r6
   1466c:	4622      	mov	r2, r4
   1466e:	4658      	mov	r0, fp
   14670:	f01e f8fe 	bl	32870 <__pow5mult>
   14674:	4642      	mov	r2, r8
   14676:	4601      	mov	r1, r0
   14678:	4606      	mov	r6, r0
   1467a:	4658      	mov	r0, fp
   1467c:	f025 f83e 	bl	396fc <__multiply>
   14680:	4607      	mov	r7, r0
   14682:	4641      	mov	r1, r8
   14684:	4658      	mov	r0, fp
   14686:	46b8      	mov	r8, r7
   14688:	f024 ff8b 	bl	395a2 <_Bfree>
   1468c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1468e:	1b1a      	subs	r2, r3, r4
   14690:	d004      	beq.n	1469c <_dtoa_r+0x77c>
   14692:	4641      	mov	r1, r8
   14694:	4658      	mov	r0, fp
   14696:	f01e f8eb 	bl	32870 <__pow5mult>
   1469a:	4680      	mov	r8, r0
   1469c:	2101      	movs	r1, #1
   1469e:	4658      	mov	r0, fp
   146a0:	f025 f823 	bl	396ea <__i2b>
   146a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
   146a6:	4604      	mov	r4, r0
   146a8:	2b00      	cmp	r3, #0
   146aa:	f340 8081 	ble.w	147b0 <_dtoa_r+0x890>
   146ae:	461a      	mov	r2, r3
   146b0:	4601      	mov	r1, r0
   146b2:	4658      	mov	r0, fp
   146b4:	f01e f8dc 	bl	32870 <__pow5mult>
   146b8:	9b08      	ldr	r3, [sp, #32]
   146ba:	4604      	mov	r4, r0
   146bc:	2b01      	cmp	r3, #1
   146be:	dd7a      	ble.n	147b6 <_dtoa_r+0x896>
   146c0:	2700      	movs	r7, #0
   146c2:	6923      	ldr	r3, [r4, #16]
   146c4:	eb04 0383 	add.w	r3, r4, r3, lsl #2
   146c8:	6918      	ldr	r0, [r3, #16]
   146ca:	f024 ffbe 	bl	3964a <__hi0bits>
   146ce:	f1c0 0020 	rsb	r0, r0, #32
   146d2:	9b07      	ldr	r3, [sp, #28]
   146d4:	4418      	add	r0, r3
   146d6:	f010 001f 	ands.w	r0, r0, #31
   146da:	f000 808b 	beq.w	147f4 <_dtoa_r+0x8d4>
   146de:	f1c0 0320 	rsb	r3, r0, #32
   146e2:	2b04      	cmp	r3, #4
   146e4:	f340 8084 	ble.w	147f0 <_dtoa_r+0x8d0>
   146e8:	f1c0 001c 	rsb	r0, r0, #28
   146ec:	9b06      	ldr	r3, [sp, #24]
   146ee:	4405      	add	r5, r0
   146f0:	4403      	add	r3, r0
   146f2:	9306      	str	r3, [sp, #24]
   146f4:	9b07      	ldr	r3, [sp, #28]
   146f6:	4403      	add	r3, r0
   146f8:	9307      	str	r3, [sp, #28]
   146fa:	9b06      	ldr	r3, [sp, #24]
   146fc:	2b00      	cmp	r3, #0
   146fe:	dd05      	ble.n	1470c <_dtoa_r+0x7ec>
   14700:	4641      	mov	r1, r8
   14702:	461a      	mov	r2, r3
   14704:	4658      	mov	r0, fp
   14706:	f025 f888 	bl	3981a <__lshift>
   1470a:	4680      	mov	r8, r0
   1470c:	9b07      	ldr	r3, [sp, #28]
   1470e:	2b00      	cmp	r3, #0
   14710:	dd05      	ble.n	1471e <_dtoa_r+0x7fe>
   14712:	4621      	mov	r1, r4
   14714:	461a      	mov	r2, r3
   14716:	4658      	mov	r0, fp
   14718:	f025 f87f 	bl	3981a <__lshift>
   1471c:	4604      	mov	r4, r0
   1471e:	9b11      	ldr	r3, [sp, #68]	; 0x44
   14720:	2b00      	cmp	r3, #0
   14722:	d069      	beq.n	147f8 <_dtoa_r+0x8d8>
   14724:	4621      	mov	r1, r4
   14726:	4640      	mov	r0, r8
   14728:	f025 f8ca 	bl	398c0 <__mcmp>
   1472c:	2800      	cmp	r0, #0
   1472e:	da63      	bge.n	147f8 <_dtoa_r+0x8d8>
   14730:	2300      	movs	r3, #0
   14732:	4641      	mov	r1, r8
   14734:	220a      	movs	r2, #10
   14736:	4658      	mov	r0, fp
   14738:	f024 ff4a 	bl	395d0 <__multadd>
   1473c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1473e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   14742:	4680      	mov	r8, r0
   14744:	2b00      	cmp	r3, #0
   14746:	f000 8179 	beq.w	14a3c <_dtoa_r+0xb1c>
   1474a:	2300      	movs	r3, #0
   1474c:	4631      	mov	r1, r6
   1474e:	220a      	movs	r2, #10
   14750:	4658      	mov	r0, fp
   14752:	f024 ff3d 	bl	395d0 <__multadd>
   14756:	9b04      	ldr	r3, [sp, #16]
   14758:	4606      	mov	r6, r0
   1475a:	2b00      	cmp	r3, #0
   1475c:	f300 808a 	bgt.w	14874 <_dtoa_r+0x954>
   14760:	9b08      	ldr	r3, [sp, #32]
   14762:	2b02      	cmp	r3, #2
   14764:	f340 8086 	ble.w	14874 <_dtoa_r+0x954>
   14768:	e04e      	b.n	14808 <_dtoa_r+0x8e8>
   1476a:	9b16      	ldr	r3, [sp, #88]	; 0x58
   1476c:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
   14770:	e757      	b.n	14622 <_dtoa_r+0x702>
   14772:	9b09      	ldr	r3, [sp, #36]	; 0x24
   14774:	f109 34ff 	add.w	r4, r9, #4294967295	; 0xffffffff
   14778:	42a3      	cmp	r3, r4
   1477a:	bfb7      	itett	lt
   1477c:	9b09      	ldrlt	r3, [sp, #36]	; 0x24
   1477e:	1b1c      	subge	r4, r3, r4
   14780:	9409      	strlt	r4, [sp, #36]	; 0x24
   14782:	1ae2      	sublt	r2, r4, r3
   14784:	bfbf      	itttt	lt
   14786:	9b10      	ldrlt	r3, [sp, #64]	; 0x40
   14788:	2400      	movlt	r4, #0
   1478a:	189b      	addlt	r3, r3, r2
   1478c:	9310      	strlt	r3, [sp, #64]	; 0x40
   1478e:	f1b9 0f00 	cmp.w	r9, #0
   14792:	bfb3      	iteet	lt
   14794:	9b06      	ldrlt	r3, [sp, #24]
   14796:	464b      	movge	r3, r9
   14798:	9d06      	ldrge	r5, [sp, #24]
   1479a:	eba3 0509 	sublt.w	r5, r3, r9
   1479e:	bfb8      	it	lt
   147a0:	2300      	movlt	r3, #0
   147a2:	e740      	b.n	14626 <_dtoa_r+0x706>
   147a4:	9c09      	ldr	r4, [sp, #36]	; 0x24
   147a6:	9d06      	ldr	r5, [sp, #24]
   147a8:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   147aa:	e747      	b.n	1463c <_dtoa_r+0x71c>
   147ac:	9a09      	ldr	r2, [sp, #36]	; 0x24
   147ae:	e770      	b.n	14692 <_dtoa_r+0x772>
   147b0:	9b08      	ldr	r3, [sp, #32]
   147b2:	2b01      	cmp	r3, #1
   147b4:	dc18      	bgt.n	147e8 <_dtoa_r+0x8c8>
   147b6:	9b00      	ldr	r3, [sp, #0]
   147b8:	b9b3      	cbnz	r3, 147e8 <_dtoa_r+0x8c8>
   147ba:	9b01      	ldr	r3, [sp, #4]
   147bc:	f3c3 0313 	ubfx	r3, r3, #0, #20
   147c0:	b9a3      	cbnz	r3, 147ec <_dtoa_r+0x8cc>
   147c2:	9b01      	ldr	r3, [sp, #4]
   147c4:	f023 4700 	bic.w	r7, r3, #2147483648	; 0x80000000
   147c8:	0d3f      	lsrs	r7, r7, #20
   147ca:	053f      	lsls	r7, r7, #20
   147cc:	b137      	cbz	r7, 147dc <_dtoa_r+0x8bc>
   147ce:	9b06      	ldr	r3, [sp, #24]
   147d0:	2701      	movs	r7, #1
   147d2:	3301      	adds	r3, #1
   147d4:	9306      	str	r3, [sp, #24]
   147d6:	9b07      	ldr	r3, [sp, #28]
   147d8:	3301      	adds	r3, #1
   147da:	9307      	str	r3, [sp, #28]
   147dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
   147de:	2b00      	cmp	r3, #0
   147e0:	f47f af6f 	bne.w	146c2 <_dtoa_r+0x7a2>
   147e4:	2001      	movs	r0, #1
   147e6:	e774      	b.n	146d2 <_dtoa_r+0x7b2>
   147e8:	2700      	movs	r7, #0
   147ea:	e7f7      	b.n	147dc <_dtoa_r+0x8bc>
   147ec:	9f00      	ldr	r7, [sp, #0]
   147ee:	e7f5      	b.n	147dc <_dtoa_r+0x8bc>
   147f0:	d083      	beq.n	146fa <_dtoa_r+0x7da>
   147f2:	4618      	mov	r0, r3
   147f4:	301c      	adds	r0, #28
   147f6:	e779      	b.n	146ec <_dtoa_r+0x7cc>
   147f8:	f1b9 0f00 	cmp.w	r9, #0
   147fc:	dc34      	bgt.n	14868 <_dtoa_r+0x948>
   147fe:	9b08      	ldr	r3, [sp, #32]
   14800:	2b02      	cmp	r3, #2
   14802:	dd31      	ble.n	14868 <_dtoa_r+0x948>
   14804:	f8cd 9010 	str.w	r9, [sp, #16]
   14808:	9b04      	ldr	r3, [sp, #16]
   1480a:	b963      	cbnz	r3, 14826 <_dtoa_r+0x906>
   1480c:	4621      	mov	r1, r4
   1480e:	2205      	movs	r2, #5
   14810:	4658      	mov	r0, fp
   14812:	f024 fedd 	bl	395d0 <__multadd>
   14816:	4601      	mov	r1, r0
   14818:	4604      	mov	r4, r0
   1481a:	4640      	mov	r0, r8
   1481c:	f025 f850 	bl	398c0 <__mcmp>
   14820:	2800      	cmp	r0, #0
   14822:	f73f adc8 	bgt.w	143b6 <_dtoa_r+0x496>
   14826:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   14828:	9d03      	ldr	r5, [sp, #12]
   1482a:	ea6f 0a03 	mvn.w	sl, r3
   1482e:	2700      	movs	r7, #0
   14830:	4621      	mov	r1, r4
   14832:	4658      	mov	r0, fp
   14834:	f024 feb5 	bl	395a2 <_Bfree>
   14838:	2e00      	cmp	r6, #0
   1483a:	f43f aeb1 	beq.w	145a0 <_dtoa_r+0x680>
   1483e:	b12f      	cbz	r7, 1484c <_dtoa_r+0x92c>
   14840:	42b7      	cmp	r7, r6
   14842:	d003      	beq.n	1484c <_dtoa_r+0x92c>
   14844:	4639      	mov	r1, r7
   14846:	4658      	mov	r0, fp
   14848:	f024 feab 	bl	395a2 <_Bfree>
   1484c:	4631      	mov	r1, r6
   1484e:	4658      	mov	r0, fp
   14850:	f024 fea7 	bl	395a2 <_Bfree>
   14854:	e6a4      	b.n	145a0 <_dtoa_r+0x680>
   14856:	2400      	movs	r4, #0
   14858:	4626      	mov	r6, r4
   1485a:	e7e4      	b.n	14826 <_dtoa_r+0x906>
   1485c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
   14860:	4626      	mov	r6, r4
   14862:	e5a8      	b.n	143b6 <_dtoa_r+0x496>
   14864:	40240000 	.word	0x40240000
   14868:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   1486a:	f8cd 9010 	str.w	r9, [sp, #16]
   1486e:	2b00      	cmp	r3, #0
   14870:	f000 80eb 	beq.w	14a4a <_dtoa_r+0xb2a>
   14874:	2d00      	cmp	r5, #0
   14876:	dd05      	ble.n	14884 <_dtoa_r+0x964>
   14878:	4631      	mov	r1, r6
   1487a:	462a      	mov	r2, r5
   1487c:	4658      	mov	r0, fp
   1487e:	f024 ffcc 	bl	3981a <__lshift>
   14882:	4606      	mov	r6, r0
   14884:	2f00      	cmp	r7, #0
   14886:	d056      	beq.n	14936 <_dtoa_r+0xa16>
   14888:	6871      	ldr	r1, [r6, #4]
   1488a:	4658      	mov	r0, fp
   1488c:	f024 fe55 	bl	3953a <_Balloc>
   14890:	6932      	ldr	r2, [r6, #16]
   14892:	4605      	mov	r5, r0
   14894:	f106 010c 	add.w	r1, r6, #12
   14898:	3202      	adds	r2, #2
   1489a:	300c      	adds	r0, #12
   1489c:	0092      	lsls	r2, r2, #2
   1489e:	f024 fb9b 	bl	38fd8 <memcpy>
   148a2:	2201      	movs	r2, #1
   148a4:	4629      	mov	r1, r5
   148a6:	4658      	mov	r0, fp
   148a8:	f024 ffb7 	bl	3981a <__lshift>
   148ac:	9b03      	ldr	r3, [sp, #12]
   148ae:	4637      	mov	r7, r6
   148b0:	4606      	mov	r6, r0
   148b2:	f103 0901 	add.w	r9, r3, #1
   148b6:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
   148ba:	4413      	add	r3, r2
   148bc:	9309      	str	r3, [sp, #36]	; 0x24
   148be:	9b00      	ldr	r3, [sp, #0]
   148c0:	f003 0301 	and.w	r3, r3, #1
   148c4:	9307      	str	r3, [sp, #28]
   148c6:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
   148ca:	4621      	mov	r1, r4
   148cc:	4640      	mov	r0, r8
   148ce:	9300      	str	r3, [sp, #0]
   148d0:	f024 fd4a 	bl	39368 <quorem>
   148d4:	4603      	mov	r3, r0
   148d6:	9004      	str	r0, [sp, #16]
   148d8:	4639      	mov	r1, r7
   148da:	4640      	mov	r0, r8
   148dc:	3330      	adds	r3, #48	; 0x30
   148de:	930a      	str	r3, [sp, #40]	; 0x28
   148e0:	f024 ffee 	bl	398c0 <__mcmp>
   148e4:	4632      	mov	r2, r6
   148e6:	9006      	str	r0, [sp, #24]
   148e8:	4621      	mov	r1, r4
   148ea:	4658      	mov	r0, fp
   148ec:	f025 f802 	bl	398f4 <__mdiff>
   148f0:	68c2      	ldr	r2, [r0, #12]
   148f2:	4605      	mov	r5, r0
   148f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   148f6:	bb02      	cbnz	r2, 1493a <_dtoa_r+0xa1a>
   148f8:	4601      	mov	r1, r0
   148fa:	4640      	mov	r0, r8
   148fc:	f024 ffe0 	bl	398c0 <__mcmp>
   14900:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14902:	4602      	mov	r2, r0
   14904:	4629      	mov	r1, r5
   14906:	4658      	mov	r0, fp
   14908:	920c      	str	r2, [sp, #48]	; 0x30
   1490a:	464d      	mov	r5, r9
   1490c:	930a      	str	r3, [sp, #40]	; 0x28
   1490e:	f024 fe48 	bl	395a2 <_Bfree>
   14912:	9b08      	ldr	r3, [sp, #32]
   14914:	9a0c      	ldr	r2, [sp, #48]	; 0x30
   14916:	ea43 0102 	orr.w	r1, r3, r2
   1491a:	9b07      	ldr	r3, [sp, #28]
   1491c:	430b      	orrs	r3, r1
   1491e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   14920:	d10d      	bne.n	1493e <_dtoa_r+0xa1e>
   14922:	2b39      	cmp	r3, #57	; 0x39
   14924:	d027      	beq.n	14976 <_dtoa_r+0xa56>
   14926:	9a06      	ldr	r2, [sp, #24]
   14928:	2a00      	cmp	r2, #0
   1492a:	dd01      	ble.n	14930 <_dtoa_r+0xa10>
   1492c:	9b04      	ldr	r3, [sp, #16]
   1492e:	3331      	adds	r3, #49	; 0x31
   14930:	9a00      	ldr	r2, [sp, #0]
   14932:	7013      	strb	r3, [r2, #0]
   14934:	e77c      	b.n	14830 <_dtoa_r+0x910>
   14936:	4630      	mov	r0, r6
   14938:	e7b8      	b.n	148ac <_dtoa_r+0x98c>
   1493a:	2201      	movs	r2, #1
   1493c:	e7e2      	b.n	14904 <_dtoa_r+0x9e4>
   1493e:	9906      	ldr	r1, [sp, #24]
   14940:	2900      	cmp	r1, #0
   14942:	db04      	blt.n	1494e <_dtoa_r+0xa2e>
   14944:	9808      	ldr	r0, [sp, #32]
   14946:	4301      	orrs	r1, r0
   14948:	9807      	ldr	r0, [sp, #28]
   1494a:	4301      	orrs	r1, r0
   1494c:	d11d      	bne.n	1498a <_dtoa_r+0xa6a>
   1494e:	2a00      	cmp	r2, #0
   14950:	ddee      	ble.n	14930 <_dtoa_r+0xa10>
   14952:	4641      	mov	r1, r8
   14954:	2201      	movs	r2, #1
   14956:	4658      	mov	r0, fp
   14958:	9306      	str	r3, [sp, #24]
   1495a:	f024 ff5e 	bl	3981a <__lshift>
   1495e:	4621      	mov	r1, r4
   14960:	4680      	mov	r8, r0
   14962:	f024 ffad 	bl	398c0 <__mcmp>
   14966:	2800      	cmp	r0, #0
   14968:	9b06      	ldr	r3, [sp, #24]
   1496a:	dc02      	bgt.n	14972 <_dtoa_r+0xa52>
   1496c:	d1e0      	bne.n	14930 <_dtoa_r+0xa10>
   1496e:	07da      	lsls	r2, r3, #31
   14970:	d5de      	bpl.n	14930 <_dtoa_r+0xa10>
   14972:	2b39      	cmp	r3, #57	; 0x39
   14974:	d1da      	bne.n	1492c <_dtoa_r+0xa0c>
   14976:	2339      	movs	r3, #57	; 0x39
   14978:	9a00      	ldr	r2, [sp, #0]
   1497a:	7013      	strb	r3, [r2, #0]
   1497c:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   14980:	1e6a      	subs	r2, r5, #1
   14982:	2b39      	cmp	r3, #57	; 0x39
   14984:	d046      	beq.n	14a14 <_dtoa_r+0xaf4>
   14986:	3301      	adds	r3, #1
   14988:	e7d3      	b.n	14932 <_dtoa_r+0xa12>
   1498a:	2a00      	cmp	r2, #0
   1498c:	dd03      	ble.n	14996 <_dtoa_r+0xa76>
   1498e:	2b39      	cmp	r3, #57	; 0x39
   14990:	d0f1      	beq.n	14976 <_dtoa_r+0xa56>
   14992:	3301      	adds	r3, #1
   14994:	e7cc      	b.n	14930 <_dtoa_r+0xa10>
   14996:	9a09      	ldr	r2, [sp, #36]	; 0x24
   14998:	f809 3c01 	strb.w	r3, [r9, #-1]
   1499c:	4591      	cmp	r9, r2
   1499e:	d021      	beq.n	149e4 <_dtoa_r+0xac4>
   149a0:	4641      	mov	r1, r8
   149a2:	2300      	movs	r3, #0
   149a4:	220a      	movs	r2, #10
   149a6:	4658      	mov	r0, fp
   149a8:	f024 fe12 	bl	395d0 <__multadd>
   149ac:	42b7      	cmp	r7, r6
   149ae:	4680      	mov	r8, r0
   149b0:	f04f 0300 	mov.w	r3, #0
   149b4:	f04f 020a 	mov.w	r2, #10
   149b8:	4639      	mov	r1, r7
   149ba:	4658      	mov	r0, fp
   149bc:	d106      	bne.n	149cc <_dtoa_r+0xaac>
   149be:	f024 fe07 	bl	395d0 <__multadd>
   149c2:	4607      	mov	r7, r0
   149c4:	4606      	mov	r6, r0
   149c6:	f109 0901 	add.w	r9, r9, #1
   149ca:	e77c      	b.n	148c6 <_dtoa_r+0x9a6>
   149cc:	f024 fe00 	bl	395d0 <__multadd>
   149d0:	4631      	mov	r1, r6
   149d2:	4607      	mov	r7, r0
   149d4:	2300      	movs	r3, #0
   149d6:	220a      	movs	r2, #10
   149d8:	4658      	mov	r0, fp
   149da:	f024 fdf9 	bl	395d0 <__multadd>
   149de:	4606      	mov	r6, r0
   149e0:	e7f1      	b.n	149c6 <_dtoa_r+0xaa6>
   149e2:	2700      	movs	r7, #0
   149e4:	4641      	mov	r1, r8
   149e6:	2201      	movs	r2, #1
   149e8:	4658      	mov	r0, fp
   149ea:	9300      	str	r3, [sp, #0]
   149ec:	f024 ff15 	bl	3981a <__lshift>
   149f0:	4621      	mov	r1, r4
   149f2:	4680      	mov	r8, r0
   149f4:	f024 ff64 	bl	398c0 <__mcmp>
   149f8:	2800      	cmp	r0, #0
   149fa:	dcbf      	bgt.n	1497c <_dtoa_r+0xa5c>
   149fc:	d102      	bne.n	14a04 <_dtoa_r+0xae4>
   149fe:	9b00      	ldr	r3, [sp, #0]
   14a00:	07db      	lsls	r3, r3, #31
   14a02:	d4bb      	bmi.n	1497c <_dtoa_r+0xa5c>
   14a04:	f815 3c01 	ldrb.w	r3, [r5, #-1]
   14a08:	1e6a      	subs	r2, r5, #1
   14a0a:	2b30      	cmp	r3, #48	; 0x30
   14a0c:	f47f af10 	bne.w	14830 <_dtoa_r+0x910>
   14a10:	4615      	mov	r5, r2
   14a12:	e7f7      	b.n	14a04 <_dtoa_r+0xae4>
   14a14:	9b03      	ldr	r3, [sp, #12]
   14a16:	4293      	cmp	r3, r2
   14a18:	d104      	bne.n	14a24 <_dtoa_r+0xb04>
   14a1a:	f10a 0a01 	add.w	sl, sl, #1
   14a1e:	2331      	movs	r3, #49	; 0x31
   14a20:	9a03      	ldr	r2, [sp, #12]
   14a22:	e786      	b.n	14932 <_dtoa_r+0xa12>
   14a24:	4615      	mov	r5, r2
   14a26:	e7a9      	b.n	1497c <_dtoa_r+0xa5c>
   14a28:	4b13      	ldr	r3, [pc, #76]	; (14a78 <_dtoa_r+0xb58>)
   14a2a:	f7ff bae1 	b.w	13ff0 <_dtoa_r+0xd0>
   14a2e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
   14a30:	2b00      	cmp	r3, #0
   14a32:	f47f aab9 	bne.w	13fa8 <_dtoa_r+0x88>
   14a36:	4b11      	ldr	r3, [pc, #68]	; (14a7c <_dtoa_r+0xb5c>)
   14a38:	f7ff bada 	b.w	13ff0 <_dtoa_r+0xd0>
   14a3c:	9b04      	ldr	r3, [sp, #16]
   14a3e:	2b00      	cmp	r3, #0
   14a40:	dc03      	bgt.n	14a4a <_dtoa_r+0xb2a>
   14a42:	9b08      	ldr	r3, [sp, #32]
   14a44:	2b02      	cmp	r3, #2
   14a46:	f73f aedf 	bgt.w	14808 <_dtoa_r+0x8e8>
   14a4a:	9d03      	ldr	r5, [sp, #12]
   14a4c:	4621      	mov	r1, r4
   14a4e:	4640      	mov	r0, r8
   14a50:	f024 fc8a 	bl	39368 <quorem>
   14a54:	9a03      	ldr	r2, [sp, #12]
   14a56:	f100 0330 	add.w	r3, r0, #48	; 0x30
   14a5a:	9904      	ldr	r1, [sp, #16]
   14a5c:	f805 3b01 	strb.w	r3, [r5], #1
   14a60:	1aaa      	subs	r2, r5, r2
   14a62:	4291      	cmp	r1, r2
   14a64:	ddbd      	ble.n	149e2 <_dtoa_r+0xac2>
   14a66:	4641      	mov	r1, r8
   14a68:	2300      	movs	r3, #0
   14a6a:	220a      	movs	r2, #10
   14a6c:	4658      	mov	r0, fp
   14a6e:	f024 fdaf 	bl	395d0 <__multadd>
   14a72:	4680      	mov	r8, r0
   14a74:	e7ea      	b.n	14a4c <_dtoa_r+0xb2c>
   14a76:	bf00      	nop
   14a78:	0003fd3b 	.word	0x0003fd3b
   14a7c:	0004098b 	.word	0x0004098b

00014a80 <env_data_ready>:
    LOG_INF("env sens data ready");
   14a80:	2303      	movs	r3, #3
   14a82:	f04f 0000 	mov.w	r0, #0
{
   14a86:	b500      	push	{lr}
    LOG_INF("env sens data ready");
   14a88:	f363 0007 	bfi	r0, r3, #0, #8
   14a8c:	4a1c      	ldr	r2, [pc, #112]	; (14b00 <env_data_ready+0x80>)
   14a8e:	4b1d      	ldr	r3, [pc, #116]	; (14b04 <env_data_ready+0x84>)
{
   14a90:	b09f      	sub	sp, #124	; 0x7c
   14a92:	1a9b      	subs	r3, r3, r2
   14a94:	08db      	lsrs	r3, r3, #3
    LOG_INF("env sens data ready");
   14a96:	f363 108f 	bfi	r0, r3, #6, #10
   14a9a:	491b      	ldr	r1, [pc, #108]	; (14b08 <env_data_ready+0x88>)
   14a9c:	f01f f8ac 	bl	33bf8 <log_string_sync>
    if (! env_sensors_get_temperature(&temp)) {
   14aa0:	a806      	add	r0, sp, #24
   14aa2:	f002 fe01 	bl	176a8 <env_sensors_get_temperature>
   14aa6:	b920      	cbnz	r0, 14ab2 <env_data_ready+0x32>
        (env_data.t) = (s32_t)temp.value;
   14aa8:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
   14aac:	f7f8 fd98 	bl	d5e0 <__aeabi_d2iz>
   14ab0:	9001      	str	r0, [sp, #4]
    if (! env_sensors_get_humidity(&humi)) {
   14ab2:	a80c      	add	r0, sp, #48	; 0x30
   14ab4:	f002 fe50 	bl	17758 <env_sensors_get_humidity>
   14ab8:	b920      	cbnz	r0, 14ac4 <env_data_ready+0x44>
        (env_data.h) = (s32_t)humi.value;
   14aba:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
   14abe:	f7f8 fd8f 	bl	d5e0 <__aeabi_d2iz>
   14ac2:	9002      	str	r0, [sp, #8]
    if (! env_sensors_get_pressure(&pres)) {
   14ac4:	a812      	add	r0, sp, #72	; 0x48
   14ac6:	f002 fe9f 	bl	17808 <env_sensors_get_pressure>
   14aca:	b920      	cbnz	r0, 14ad6 <env_data_ready+0x56>
        (env_data.p) = (s32_t)pres.value;
   14acc:	e9dd 0114 	ldrd	r0, r1, [sp, #80]	; 0x50
   14ad0:	f7f8 fd86 	bl	d5e0 <__aeabi_d2iz>
   14ad4:	9003      	str	r0, [sp, #12]
    if (! env_sensors_get_air_quality(&qual)) {
   14ad6:	a818      	add	r0, sp, #96	; 0x60
   14ad8:	f002 feee 	bl	178b8 <env_sensors_get_air_quality>
   14adc:	b940      	cbnz	r0, 14af0 <env_data_ready+0x70>
        (env_data.q) = (s32_t)qual.value;
   14ade:	e9dd 011a 	ldrd	r0, r1, [sp, #104]	; 0x68
   14ae2:	f7f8 fd7d 	bl	d5e0 <__aeabi_d2iz>
        (env_data.a) = (u8_t)qual.accuracy;
   14ae6:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
        (env_data.q) = (s32_t)qual.value;
   14aea:	9004      	str	r0, [sp, #16]
        (env_data.a) = (u8_t)qual.accuracy;
   14aec:	f88d 3014 	strb.w	r3, [sp, #20]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_PUT);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_put(msgq, data, timeout);
   14af0:	2200      	movs	r2, #0
   14af2:	a901      	add	r1, sp, #4
   14af4:	4805      	ldr	r0, [pc, #20]	; (14b0c <env_data_ready+0x8c>)
   14af6:	f017 fc0b 	bl	2c310 <z_impl_k_msgq_put>
}
   14afa:	b01f      	add	sp, #124	; 0x7c
   14afc:	f85d fb04 	ldr.w	pc, [sp], #4
   14b00:	00039f60 	.word	0x00039f60
   14b04:	00039fa8 	.word	0x00039fa8
   14b08:	0003b661 	.word	0x0003b661
   14b0c:	200210d0 	.word	0x200210d0

00014b10 <ntp_poll>:
{
   14b10:	b573      	push	{r0, r1, r4, r5, r6, lr}
        LOG_ERR("Couldn't get time\n");
   14b12:	4b10      	ldr	r3, [pc, #64]	; (14b54 <ntp_poll+0x44>)
   14b14:	4c10      	ldr	r4, [pc, #64]	; (14b58 <ntp_poll+0x48>)
   14b16:	4e11      	ldr	r6, [pc, #68]	; (14b5c <ntp_poll+0x4c>)
   14b18:	1ae4      	subs	r4, r4, r3
   14b1a:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    while (date_time_now(&date_time_stamp) != 0)
   14b1e:	4668      	mov	r0, sp
   14b20:	f023 ffa0 	bl	38a64 <date_time_now>
   14b24:	b920      	cbnz	r0, 14b30 <ntp_poll+0x20>
    got_ntp = true;
   14b26:	2201      	movs	r2, #1
   14b28:	4b0d      	ldr	r3, [pc, #52]	; (14b60 <ntp_poll+0x50>)
   14b2a:	701a      	strb	r2, [r3, #0]
}
   14b2c:	b002      	add	sp, #8
   14b2e:	bd70      	pop	{r4, r5, r6, pc}
        LOG_ERR("Couldn't get time\n");
   14b30:	f025 033f 	bic.w	r3, r5, #63	; 0x3f
   14b34:	f043 0301 	orr.w	r3, r3, #1
   14b38:	f363 0507 	bfi	r5, r3, #0, #8
   14b3c:	f364 158f 	bfi	r5, r4, #6, #10
   14b40:	4631      	mov	r1, r6
   14b42:	4628      	mov	r0, r5
   14b44:	f01f f858 	bl	33bf8 <log_string_sync>
	return z_impl_k_sleep(timeout);
   14b48:	f242 7010 	movw	r0, #10000	; 0x2710
   14b4c:	f019 fa0c 	bl	2df68 <z_impl_k_sleep>
   14b50:	e7e5      	b.n	14b1e <ntp_poll+0xe>
   14b52:	bf00      	nop
   14b54:	00039f60 	.word	0x00039f60
   14b58:	00039fa8 	.word	0x00039fa8
   14b5c:	0003b831 	.word	0x0003b831
   14b60:	20027622 	.word	0x20027622

00014b64 <process_env_data>:
{
   14b64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    u32_t run_count = 0;
   14b68:	2700      	movs	r7, #0
   14b6a:	4cd3      	ldr	r4, [pc, #844]	; (14eb8 <process_env_data+0x354>)
            LOG_DBG("Getting environmental data: [%d] of [%d]", i, DATA_ARRAY_SIZE);
   14b6c:	4bd3      	ldr	r3, [pc, #844]	; (14ebc <process_env_data+0x358>)
{
   14b6e:	f6ad 7dec 	subw	sp, sp, #4076	; 0xfec
            LOG_DBG("Getting environmental data: [%d] of [%d]", i, DATA_ARRAY_SIZE);
   14b72:	1ae4      	subs	r4, r4, r3
   14b74:	f3c4 04c9 	ubfx	r4, r4, #3, #10
    bool thread_started = false;
   14b78:	9718      	str	r7, [sp, #96]	; 0x60
        for (int i = 0; i < DATA_ARRAY_SIZE; i++)
   14b7a:	2600      	movs	r6, #0
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&msgq, *(uintptr_t *)&data, *(uintptr_t *)&timeout, K_SYSCALL_K_MSGQ_GET);
	}
#endif
	compiler_barrier();
	return z_impl_k_msgq_get(msgq, data, timeout);
   14b7c:	4dd0      	ldr	r5, [pc, #832]	; (14ec0 <process_env_data+0x35c>)
            LOG_DBG("Getting environmental data: [%d] of [%d]", i, DATA_ARRAY_SIZE);
   14b7e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   14b82:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   14b86:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14b8a:	f043 0304 	orr.w	r3, r3, #4
   14b8e:	f363 0207 	bfi	r2, r3, #0, #8
   14b92:	b293      	uxth	r3, r2
   14b94:	f364 138f 	bfi	r3, r4, #6, #10
   14b98:	f8ad 3008 	strh.w	r3, [sp, #8]
   14b9c:	23f0      	movs	r3, #240	; 0xf0
   14b9e:	4ac9      	ldr	r2, [pc, #804]	; (14ec4 <process_env_data+0x360>)
   14ba0:	9300      	str	r3, [sp, #0]
   14ba2:	49c9      	ldr	r1, [pc, #804]	; (14ec8 <process_env_data+0x364>)
   14ba4:	4633      	mov	r3, r6
   14ba6:	f8bd 0008 	ldrh.w	r0, [sp, #8]
   14baa:	f01f f825 	bl	33bf8 <log_string_sync>
   14bae:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   14bb2:	a91a      	add	r1, sp, #104	; 0x68
   14bb4:	4628      	mov	r0, r5
   14bb6:	f017 fc45 	bl	2c444 <z_impl_k_msgq_get>
            tempArray[i] = (s32_t)d_temp.t;
   14bba:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   14bbc:	ab3a      	add	r3, sp, #232	; 0xe8
   14bbe:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
            humiArray[i] = (s32_t)d_temp.h;
   14bc2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
   14bc4:	f50d 6395 	add.w	r3, sp, #1192	; 0x4a8
   14bc8:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
            presArray[i] = (s32_t)d_temp.p;
   14bcc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
   14bce:	f60d 0368 	addw	r3, sp, #2152	; 0x868
   14bd2:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
            if (d_temp.a != IAQ_STABILISING) {
   14bd6:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
   14bda:	2b00      	cmp	r3, #0
   14bdc:	f000 8257 	beq.w	1508e <process_env_data+0x52a>
                qualArray[i] = (s32_t)d_temp.q; // fill array with valid readings
   14be0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   14be2:	f60d 4228 	addw	r2, sp, #3112	; 0xc28
   14be6:	f842 3026 	str.w	r3, [r2, r6, lsl #2]
            LOG_INF("Run Count: [%d]\n", run_count);
   14bea:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   14bee:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   14bf2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14bf6:	f043 0303 	orr.w	r3, r3, #3
   14bfa:	f363 0207 	bfi	r2, r3, #0, #8
   14bfe:	b293      	uxth	r3, r2
   14c00:	f364 138f 	bfi	r3, r4, #6, #10
            run_count +=1;
   14c04:	3701      	adds	r7, #1
            LOG_INF("Run Count: [%d]\n", run_count);
   14c06:	b298      	uxth	r0, r3
   14c08:	463a      	mov	r2, r7
   14c0a:	49b0      	ldr	r1, [pc, #704]	; (14ecc <process_env_data+0x368>)
   14c0c:	f8ad 300c 	strh.w	r3, [sp, #12]
   14c10:	f01e fff2 	bl	33bf8 <log_string_sync>
            if (!thread_started) {
   14c14:	9b18      	ldr	r3, [sp, #96]	; 0x60
   14c16:	2b00      	cmp	r3, #0
   14c18:	d179      	bne.n	14d0e <process_env_data+0x1aa>
                LOG_INF("[%d] samples to Google thread entry\n", ((THREAD_INDEX) - run_count));
   14c1a:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   14c1e:	f8bd 2010 	ldrh.w	r2, [sp, #16]
   14c22:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14c26:	f043 0303 	orr.w	r3, r3, #3
   14c2a:	f363 0207 	bfi	r2, r3, #0, #8
   14c2e:	b293      	uxth	r3, r2
   14c30:	f364 138f 	bfi	r3, r4, #6, #10
   14c34:	f1c7 02ee 	rsb	r2, r7, #238	; 0xee
   14c38:	49a5      	ldr	r1, [pc, #660]	; (14ed0 <process_env_data+0x36c>)
   14c3a:	b298      	uxth	r0, r3
   14c3c:	f8ad 3010 	strh.w	r3, [sp, #16]
   14c40:	f01e ffda 	bl	33bf8 <log_string_sync>
            if ((run_count == (THREAD_INDEX)) && (!thread_started))
   14c44:	2fee      	cmp	r7, #238	; 0xee
   14c46:	d162      	bne.n	14d0e <process_env_data+0x1aa>
                LOG_INF("Provisioning\n");
   14c48:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   14c4c:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   14c50:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14c54:	f043 0303 	orr.w	r3, r3, #3
   14c58:	f363 0207 	bfi	r2, r3, #0, #8
   14c5c:	b293      	uxth	r3, r2
   14c5e:	f364 138f 	bfi	r3, r4, #6, #10
   14c62:	499c      	ldr	r1, [pc, #624]	; (14ed4 <process_env_data+0x370>)
   14c64:	b298      	uxth	r0, r3
   14c66:	f8ad 3014 	strh.w	r3, [sp, #20]
   14c6a:	f01e ffc5 	bl	33bf8 <log_string_sync>
                err = gcloud_provision();
   14c6e:	f000 fcb1 	bl	155d4 <gcloud_provision>
                if (err) {
   14c72:	4602      	mov	r2, r0
   14c74:	2800      	cmp	r0, #0
   14c76:	f000 820d 	beq.w	15094 <process_env_data+0x530>
                    LOG_ERR("Failed to provision: %d\n", err);
   14c7a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   14c7e:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   14c82:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14c86:	f043 0301 	orr.w	r3, r3, #1
   14c8a:	f363 0107 	bfi	r1, r3, #0, #8
   14c8e:	b28b      	uxth	r3, r1
   14c90:	f364 138f 	bfi	r3, r4, #6, #10
   14c94:	b298      	uxth	r0, r3
   14c96:	4990      	ldr	r1, [pc, #576]	; (14ed8 <process_env_data+0x374>)
   14c98:	f8ad 3018 	strh.w	r3, [sp, #24]
   14c9c:	f01e ffac 	bl	33bf8 <log_string_sync>
                    sys_reboot(0); //TODO: Handle error
   14ca0:	9818      	ldr	r0, [sp, #96]	; 0x60
   14ca2:	f005 f8fb 	bl	19e9c <sys_reboot>
                LOG_INF("Connecting to Google Cloud\n");
   14ca6:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   14caa:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   14cae:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14cb2:	f043 0303 	orr.w	r3, r3, #3
   14cb6:	f363 0207 	bfi	r2, r3, #0, #8
   14cba:	b293      	uxth	r3, r2
   14cbc:	f364 138f 	bfi	r3, r4, #6, #10
   14cc0:	b298      	uxth	r0, r3
   14cc2:	4986      	ldr	r1, [pc, #536]	; (14edc <process_env_data+0x378>)
   14cc4:	f8ad 3020 	strh.w	r3, [sp, #32]
   14cc8:	f01e ff96 	bl	33bf8 <log_string_sync>
                err = gcloud_connect(received_config_handler);
   14ccc:	4884      	ldr	r0, [pc, #528]	; (14ee0 <process_env_data+0x37c>)
   14cce:	f000 fccf 	bl	15670 <gcloud_connect>
                if (err) {
   14cd2:	4607      	mov	r7, r0
   14cd4:	2800      	cmp	r0, #0
   14cd6:	f000 81f1 	beq.w	150bc <process_env_data+0x558>
                    LOG_ERR("Failed to connect to Google Cloud, error: %d\n", err);
   14cda:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   14cde:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   14ce2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14ce6:	f043 0301 	orr.w	r3, r3, #1
   14cea:	f363 0207 	bfi	r2, r3, #0, #8
   14cee:	b293      	uxth	r3, r2
   14cf0:	f364 138f 	bfi	r3, r4, #6, #10
   14cf4:	4602      	mov	r2, r0
   14cf6:	497b      	ldr	r1, [pc, #492]	; (14ee4 <process_env_data+0x380>)
   14cf8:	b298      	uxth	r0, r3
   14cfa:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
   14cfe:	f01e ff7b 	bl	33bf8 <log_string_sync>
                    sys_reboot(0); //TODO: Handle error
   14d02:	2000      	movs	r0, #0
   14d04:	f005 f8ca 	bl	19e9c <sys_reboot>
                run_count = 0;
   14d08:	2700      	movs	r7, #0
                thread_started = true;
   14d0a:	2301      	movs	r3, #1
   14d0c:	9318      	str	r3, [sp, #96]	; 0x60
        for (int i = 0; i < DATA_ARRAY_SIZE; i++)
   14d0e:	3601      	adds	r6, #1
   14d10:	2ef0      	cmp	r6, #240	; 0xf0
   14d12:	f47f af34 	bne.w	14b7e <process_env_data+0x1a>
        LOG_INF("Calculating environmental data type avg");
   14d16:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   14d1a:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   14d1e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14d22:	f043 0303 	orr.w	r3, r3, #3
   14d26:	f363 0207 	bfi	r2, r3, #0, #8
   14d2a:	b293      	uxth	r3, r2
   14d2c:	f364 138f 	bfi	r3, r4, #6, #10
   14d30:	b298      	uxth	r0, r3
   14d32:	496d      	ldr	r1, [pc, #436]	; (14ee8 <process_env_data+0x384>)
   14d34:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
   14d38:	f01e ff5e 	bl	33bf8 <log_string_sync>
        pac_data.ag_temp.avg = calculate_avg_val(tempArray, DATA_ARRAY_SIZE, false, NULL);
   14d3c:	2300      	movs	r3, #0
   14d3e:	4631      	mov	r1, r6
   14d40:	461a      	mov	r2, r3
   14d42:	a83a      	add	r0, sp, #232	; 0xe8
   14d44:	f01d ff64 	bl	32c10 <calculate_avg_val>
        pac_data.ag_humi.avg = calculate_avg_val(humiArray, DATA_ARRAY_SIZE, false, NULL);
   14d48:	2300      	movs	r3, #0
        pac_data.ag_temp.avg = calculate_avg_val(tempArray, DATA_ARRAY_SIZE, false, NULL);
   14d4a:	ad2a      	add	r5, sp, #168	; 0xa8
        pac_data.ag_humi.avg = calculate_avg_val(humiArray, DATA_ARRAY_SIZE, false, NULL);
   14d4c:	461a      	mov	r2, r3
        pac_data.ag_temp.avg = calculate_avg_val(tempArray, DATA_ARRAY_SIZE, false, NULL);
   14d4e:	60a8      	str	r0, [r5, #8]
        pac_data.ag_humi.avg = calculate_avg_val(humiArray, DATA_ARRAY_SIZE, false, NULL);
   14d50:	f50d 6095 	add.w	r0, sp, #1192	; 0x4a8
   14d54:	f01d ff5c 	bl	32c10 <calculate_avg_val>
        pac_data.ag_pres.avg = calculate_avg_val(presArray, DATA_ARRAY_SIZE, false, NULL);
   14d58:	2300      	movs	r3, #0
        pac_data.ag_humi.avg = calculate_avg_val(humiArray, DATA_ARRAY_SIZE, false, NULL);
   14d5a:	61a8      	str	r0, [r5, #24]
        pac_data.ag_pres.avg = calculate_avg_val(presArray, DATA_ARRAY_SIZE, false, NULL);
   14d5c:	461a      	mov	r2, r3
   14d5e:	f60d 0068 	addw	r0, sp, #2152	; 0x868
   14d62:	f01d ff55 	bl	32c10 <calculate_avg_val>
        pac_data.ag_qual.avg = calculate_avg_val(qualArray, DATA_ARRAY_SIZE, true, &pac_data.ag_qual.cnt);
   14d66:	ab39      	add	r3, sp, #228	; 0xe4
        pac_data.ag_pres.avg = calculate_avg_val(presArray, DATA_ARRAY_SIZE, false, NULL);
   14d68:	62a8      	str	r0, [r5, #40]	; 0x28
        pac_data.ag_qual.avg = calculate_avg_val(qualArray, DATA_ARRAY_SIZE, true, &pac_data.ag_qual.cnt);
   14d6a:	2201      	movs	r2, #1
   14d6c:	f60d 4028 	addw	r0, sp, #3112	; 0xc28
   14d70:	f01d ff4e 	bl	32c10 <calculate_avg_val>
        LOG_INF("Mean temp: %d", (s32_t)pac_data.ag_temp.avg);
   14d74:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   14d78:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   14d7c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14d80:	f043 0303 	orr.w	r3, r3, #3
   14d84:	f363 0207 	bfi	r2, r3, #0, #8
   14d88:	b293      	uxth	r3, r2
   14d8a:	f364 138f 	bfi	r3, r4, #6, #10
        pac_data.ag_qual.avg = calculate_avg_val(qualArray, DATA_ARRAY_SIZE, true, &pac_data.ag_qual.cnt);
   14d8e:	63a8      	str	r0, [r5, #56]	; 0x38
        LOG_INF("Mean temp: %d", (s32_t)pac_data.ag_temp.avg);
   14d90:	68aa      	ldr	r2, [r5, #8]
   14d92:	b298      	uxth	r0, r3
   14d94:	4955      	ldr	r1, [pc, #340]	; (14eec <process_env_data+0x388>)
   14d96:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
   14d9a:	f01e ff2d 	bl	33bf8 <log_string_sync>
        LOG_INF("Mean humi: %d", (s32_t)pac_data.ag_humi.avg);
   14d9e:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   14da2:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
   14da6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14daa:	f043 0303 	orr.w	r3, r3, #3
   14dae:	f363 0207 	bfi	r2, r3, #0, #8
   14db2:	b293      	uxth	r3, r2
   14db4:	f364 138f 	bfi	r3, r4, #6, #10
   14db8:	b298      	uxth	r0, r3
   14dba:	69aa      	ldr	r2, [r5, #24]
   14dbc:	494c      	ldr	r1, [pc, #304]	; (14ef0 <process_env_data+0x38c>)
   14dbe:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
   14dc2:	f01e ff19 	bl	33bf8 <log_string_sync>
        LOG_INF("Mean pres: %d", (s32_t)pac_data.ag_pres.avg);
   14dc6:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   14dca:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
   14dce:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14dd2:	f043 0303 	orr.w	r3, r3, #3
   14dd6:	f363 0207 	bfi	r2, r3, #0, #8
   14dda:	b293      	uxth	r3, r2
   14ddc:	f364 138f 	bfi	r3, r4, #6, #10
   14de0:	b298      	uxth	r0, r3
   14de2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   14de4:	4943      	ldr	r1, [pc, #268]	; (14ef4 <process_env_data+0x390>)
   14de6:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
   14dea:	f01e ff05 	bl	33bf8 <log_string_sync>
        LOG_INF("Mean qual: %d", (s32_t)pac_data.ag_qual.avg);
   14dee:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
   14df2:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
   14df6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14dfa:	f043 0303 	orr.w	r3, r3, #3
   14dfe:	f363 0207 	bfi	r2, r3, #0, #8
   14e02:	b293      	uxth	r3, r2
   14e04:	f364 138f 	bfi	r3, r4, #6, #10
   14e08:	b298      	uxth	r0, r3
   14e0a:	6baa      	ldr	r2, [r5, #56]	; 0x38
   14e0c:	493a      	ldr	r1, [pc, #232]	; (14ef8 <process_env_data+0x394>)
   14e0e:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
   14e12:	f01e fef1 	bl	33bf8 <log_string_sync>
        LOG_INF("Calculating environmental data type min");
   14e16:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   14e1a:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   14e1e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14e22:	f043 0303 	orr.w	r3, r3, #3
   14e26:	f363 0207 	bfi	r2, r3, #0, #8
   14e2a:	b293      	uxth	r3, r2
   14e2c:	f364 138f 	bfi	r3, r4, #6, #10
   14e30:	b298      	uxth	r0, r3
   14e32:	4932      	ldr	r1, [pc, #200]	; (14efc <process_env_data+0x398>)
   14e34:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
   14e38:	f01e fede 	bl	33bf8 <log_string_sync>
        pac_data.ag_temp.min = calculate_min_val(tempArray, DATA_ARRAY_SIZE);
   14e3c:	4631      	mov	r1, r6
   14e3e:	a83a      	add	r0, sp, #232	; 0xe8
   14e40:	f01d ff01 	bl	32c46 <calculate_min_val>
   14e44:	6068      	str	r0, [r5, #4]
   14e46:	9019      	str	r0, [sp, #100]	; 0x64
        pac_data.ag_humi.min = calculate_min_val(humiArray, DATA_ARRAY_SIZE);
   14e48:	f50d 6095 	add.w	r0, sp, #1192	; 0x4a8
   14e4c:	f01d fefb 	bl	32c46 <calculate_min_val>
   14e50:	6168      	str	r0, [r5, #20]
        pac_data.ag_pres.min = calculate_min_val(presArray, DATA_ARRAY_SIZE);
   14e52:	f60d 0068 	addw	r0, sp, #2152	; 0x868
   14e56:	f01d fef6 	bl	32c46 <calculate_min_val>
   14e5a:	6268      	str	r0, [r5, #36]	; 0x24
        pac_data.ag_qual.min = calculate_min_val(qualArray, DATA_ARRAY_SIZE);
   14e5c:	f60d 4028 	addw	r0, sp, #3112	; 0xc28
   14e60:	f01d fef1 	bl	32c46 <calculate_min_val>
        LOG_INF("Min temp: %d", (s32_t)pac_data.ag_temp.min);
   14e64:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
   14e68:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
   14e6c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14e70:	f043 0303 	orr.w	r3, r3, #3
   14e74:	f363 0207 	bfi	r2, r3, #0, #8
   14e78:	b293      	uxth	r3, r2
   14e7a:	f364 138f 	bfi	r3, r4, #6, #10
        pac_data.ag_qual.min = calculate_min_val(qualArray, DATA_ARRAY_SIZE);
   14e7e:	6368      	str	r0, [r5, #52]	; 0x34
        LOG_INF("Min temp: %d", (s32_t)pac_data.ag_temp.min);
   14e80:	9a19      	ldr	r2, [sp, #100]	; 0x64
   14e82:	b298      	uxth	r0, r3
   14e84:	491e      	ldr	r1, [pc, #120]	; (14f00 <process_env_data+0x39c>)
   14e86:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
   14e8a:	f01e feb5 	bl	33bf8 <log_string_sync>
        LOG_INF("Min humi: %d", (s32_t)pac_data.ag_humi.min);
   14e8e:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   14e92:	f8bd 2048 	ldrh.w	r2, [sp, #72]	; 0x48
   14e96:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14e9a:	f043 0303 	orr.w	r3, r3, #3
   14e9e:	f363 0207 	bfi	r2, r3, #0, #8
   14ea2:	b293      	uxth	r3, r2
   14ea4:	f364 138f 	bfi	r3, r4, #6, #10
   14ea8:	b298      	uxth	r0, r3
   14eaa:	696a      	ldr	r2, [r5, #20]
   14eac:	4915      	ldr	r1, [pc, #84]	; (14f04 <process_env_data+0x3a0>)
   14eae:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   14eb2:	f01e fea1 	bl	33bf8 <log_string_sync>
   14eb6:	e027      	b.n	14f08 <process_env_data+0x3a4>
   14eb8:	00039fa8 	.word	0x00039fa8
   14ebc:	00039f60 	.word	0x00039f60
   14ec0:	200210d0 	.word	0x200210d0
   14ec4:	0003b430 	.word	0x0003b430
   14ec8:	0003b844 	.word	0x0003b844
   14ecc:	0003b871 	.word	0x0003b871
   14ed0:	0003b882 	.word	0x0003b882
   14ed4:	0003b8a7 	.word	0x0003b8a7
   14ed8:	0003b8b5 	.word	0x0003b8b5
   14edc:	0003b8e5 	.word	0x0003b8e5
   14ee0:	00032c01 	.word	0x00032c01
   14ee4:	0003b901 	.word	0x0003b901
   14ee8:	0003b94a 	.word	0x0003b94a
   14eec:	0003b972 	.word	0x0003b972
   14ef0:	0003b980 	.word	0x0003b980
   14ef4:	0003b98e 	.word	0x0003b98e
   14ef8:	0003b99c 	.word	0x0003b99c
   14efc:	0003b9aa 	.word	0x0003b9aa
   14f00:	0003b9d2 	.word	0x0003b9d2
   14f04:	0003b9df 	.word	0x0003b9df
        LOG_INF("Min pres: %d", (s32_t)pac_data.ag_pres.min);
   14f08:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
   14f0c:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   14f10:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14f14:	f043 0303 	orr.w	r3, r3, #3
   14f18:	f363 0207 	bfi	r2, r3, #0, #8
   14f1c:	b293      	uxth	r3, r2
   14f1e:	f364 138f 	bfi	r3, r4, #6, #10
   14f22:	b298      	uxth	r0, r3
   14f24:	6a6a      	ldr	r2, [r5, #36]	; 0x24
   14f26:	496f      	ldr	r1, [pc, #444]	; (150e4 <process_env_data+0x580>)
   14f28:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
   14f2c:	f01e fe64 	bl	33bf8 <log_string_sync>
        LOG_INF("Min qual: %d", (s32_t)pac_data.ag_qual.min);
   14f30:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   14f34:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
   14f38:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14f3c:	f043 0303 	orr.w	r3, r3, #3
   14f40:	f363 0207 	bfi	r2, r3, #0, #8
   14f44:	b293      	uxth	r3, r2
   14f46:	f364 138f 	bfi	r3, r4, #6, #10
   14f4a:	b298      	uxth	r0, r3
   14f4c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
   14f4e:	4966      	ldr	r1, [pc, #408]	; (150e8 <process_env_data+0x584>)
   14f50:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
   14f54:	f01e fe50 	bl	33bf8 <log_string_sync>
        LOG_INF("Calculating environmental data type max");
   14f58:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
   14f5c:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
   14f60:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   14f64:	f043 0303 	orr.w	r3, r3, #3
   14f68:	f363 0207 	bfi	r2, r3, #0, #8
   14f6c:	b293      	uxth	r3, r2
   14f6e:	f364 138f 	bfi	r3, r4, #6, #10
   14f72:	b298      	uxth	r0, r3
   14f74:	495d      	ldr	r1, [pc, #372]	; (150ec <process_env_data+0x588>)
   14f76:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
   14f7a:	f01e fe3d 	bl	33bf8 <log_string_sync>
        pac_data.ag_temp.max = calculate_max_val(tempArray, DATA_ARRAY_SIZE, false);
   14f7e:	4631      	mov	r1, r6
   14f80:	2200      	movs	r2, #0
   14f82:	a83a      	add	r0, sp, #232	; 0xe8
   14f84:	f01d fe6d 	bl	32c62 <calculate_max_val>
        pac_data.ag_humi.max = calculate_max_val(humiArray, DATA_ARRAY_SIZE, false);
   14f88:	2200      	movs	r2, #0
        pac_data.ag_temp.max = calculate_max_val(tempArray, DATA_ARRAY_SIZE, false);
   14f8a:	6028      	str	r0, [r5, #0]
   14f8c:	9019      	str	r0, [sp, #100]	; 0x64
        pac_data.ag_humi.max = calculate_max_val(humiArray, DATA_ARRAY_SIZE, false);
   14f8e:	f50d 6095 	add.w	r0, sp, #1192	; 0x4a8
   14f92:	f01d fe66 	bl	32c62 <calculate_max_val>
        pac_data.ag_pres.max = calculate_max_val(presArray, DATA_ARRAY_SIZE, false);
   14f96:	2200      	movs	r2, #0
        pac_data.ag_humi.max = calculate_max_val(humiArray, DATA_ARRAY_SIZE, false);
   14f98:	6128      	str	r0, [r5, #16]
        pac_data.ag_pres.max = calculate_max_val(presArray, DATA_ARRAY_SIZE, false);
   14f9a:	f60d 0068 	addw	r0, sp, #2152	; 0x868
   14f9e:	f01d fe60 	bl	32c62 <calculate_max_val>
        pac_data.ag_qual.max = calculate_max_val(qualArray, DATA_ARRAY_SIZE, true);
   14fa2:	2201      	movs	r2, #1
        pac_data.ag_pres.max = calculate_max_val(presArray, DATA_ARRAY_SIZE, false);
   14fa4:	6228      	str	r0, [r5, #32]
        pac_data.ag_qual.max = calculate_max_val(qualArray, DATA_ARRAY_SIZE, true);
   14fa6:	f60d 4028 	addw	r0, sp, #3112	; 0xc28
   14faa:	f01d fe5a 	bl	32c62 <calculate_max_val>
        LOG_INF("Max temp: %d", (s32_t)pac_data.ag_temp.max);
   14fae:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
        pac_data.ag_qual.max = calculate_max_val(qualArray, DATA_ARRAY_SIZE, true);
   14fb2:	6328      	str	r0, [r5, #48]	; 0x30
        LOG_INF("Max temp: %d", (s32_t)pac_data.ag_temp.max);
   14fb4:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
   14fb8:	f042 0203 	orr.w	r2, r2, #3
   14fbc:	f362 0307 	bfi	r3, r2, #0, #8
   14fc0:	b29b      	uxth	r3, r3
   14fc2:	f364 138f 	bfi	r3, r4, #6, #10
   14fc6:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
   14fca:	9b19      	ldr	r3, [sp, #100]	; 0x64
   14fcc:	4948      	ldr	r1, [pc, #288]	; (150f0 <process_env_data+0x58c>)
   14fce:	461a      	mov	r2, r3
   14fd0:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
   14fd4:	f01e fe10 	bl	33bf8 <log_string_sync>
        LOG_INF("Max humi: %d", (s32_t)pac_data.ag_humi.max);
   14fd8:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   14fdc:	f043 0303 	orr.w	r3, r3, #3
   14fe0:	f363 0807 	bfi	r8, r3, #0, #8
   14fe4:	f364 188f 	bfi	r8, r4, #6, #10
   14fe8:	692a      	ldr	r2, [r5, #16]
   14fea:	4942      	ldr	r1, [pc, #264]	; (150f4 <process_env_data+0x590>)
   14fec:	4640      	mov	r0, r8
   14fee:	f01e fe03 	bl	33bf8 <log_string_sync>
        LOG_INF("Max pres: %d", (s32_t)pac_data.ag_pres.max);
   14ff2:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   14ff6:	f043 0303 	orr.w	r3, r3, #3
   14ffa:	f363 0907 	bfi	r9, r3, #0, #8
   14ffe:	f364 198f 	bfi	r9, r4, #6, #10
   15002:	6a2a      	ldr	r2, [r5, #32]
   15004:	493c      	ldr	r1, [pc, #240]	; (150f8 <process_env_data+0x594>)
   15006:	4648      	mov	r0, r9
   15008:	f01e fdf6 	bl	33bf8 <log_string_sync>
        LOG_INF("Max qual: %d", (s32_t)pac_data.ag_qual.max);
   1500c:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   15010:	f043 0303 	orr.w	r3, r3, #3
   15014:	f363 0a07 	bfi	sl, r3, #0, #8
   15018:	f364 1a8f 	bfi	sl, r4, #6, #10
   1501c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
   1501e:	4937      	ldr	r1, [pc, #220]	; (150fc <process_env_data+0x598>)
   15020:	4650      	mov	r0, sl
   15022:	f01e fde9 	bl	33bf8 <log_string_sync>
        LOG_INF("Sending data to google iot thread");
   15026:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
   1502a:	f043 0303 	orr.w	r3, r3, #3
   1502e:	f363 0b07 	bfi	fp, r3, #0, #8
   15032:	f364 1b8f 	bfi	fp, r4, #6, #10
   15036:	4932      	ldr	r1, [pc, #200]	; (15100 <process_env_data+0x59c>)
   15038:	4658      	mov	r0, fp
   1503a:	f01e fddd 	bl	33bf8 <log_string_sync>
        send_env_msg.info = buffer_bytes_used;
   1503e:	2340      	movs	r3, #64	; 0x40
        send_env_msg.size = buffer_bytes_used;
   15040:	e9cd 3320 	strd	r3, r3, [sp, #128]	; 0x80
        send_env_msg.tx_block.data = NULL;
   15044:	2300      	movs	r3, #0
        k_mbox_put(&env_d_mailbox, &send_env_msg, K_FOREVER);
   15046:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1504a:	a91f      	add	r1, sp, #124	; 0x7c
   1504c:	482d      	ldr	r0, [pc, #180]	; (15104 <process_env_data+0x5a0>)
        send_env_msg.tx_block.data = NULL;
   1504e:	9324      	str	r3, [sp, #144]	; 0x90
        send_env_msg.tx_target_thread = K_ANY;
   15050:	9327      	str	r3, [sp, #156]	; 0x9c
        send_env_msg.tx_data = &pac_data;
   15052:	9522      	str	r5, [sp, #136]	; 0x88
        k_mbox_put(&env_d_mailbox, &send_env_msg, K_FOREVER);
   15054:	f016 ffa2 	bl	2bf9c <k_mbox_put>
        if (send_env_msg.size < buffer_bytes_used) {
   15058:	9b20      	ldr	r3, [sp, #128]	; 0x80
   1505a:	2b3f      	cmp	r3, #63	; 0x3f
   1505c:	f63f ad8d 	bhi.w	14b7a <process_env_data+0x16>
            LOG_DBG("env msg RXer only had room for [%d] bytes", send_env_msg.info);
   15060:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
   15064:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
   15068:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   1506c:	f043 0304 	orr.w	r3, r3, #4
   15070:	f363 0207 	bfi	r2, r3, #0, #8
   15074:	b293      	uxth	r3, r2
   15076:	f364 138f 	bfi	r3, r4, #6, #10
   1507a:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
   1507e:	4a22      	ldr	r2, [pc, #136]	; (15108 <process_env_data+0x5a4>)
   15080:	9b21      	ldr	r3, [sp, #132]	; 0x84
   15082:	4922      	ldr	r1, [pc, #136]	; (1510c <process_env_data+0x5a8>)
   15084:	f8bd 005c 	ldrh.w	r0, [sp, #92]	; 0x5c
   15088:	f01e fdb6 	bl	33bf8 <log_string_sync>
   1508c:	e575      	b.n	14b7a <process_env_data+0x16>
               qualArray[i] = EXCLUDE;  // fill array with magic number
   1508e:	f240 33e7 	movw	r3, #999	; 0x3e7
   15092:	e5a6      	b.n	14be2 <process_env_data+0x7e>
                    LOG_INF("Provisioning complete\n");
   15094:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   15098:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   1509c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   150a0:	f043 0303 	orr.w	r3, r3, #3
   150a4:	f363 0207 	bfi	r2, r3, #0, #8
   150a8:	b293      	uxth	r3, r2
   150aa:	f364 138f 	bfi	r3, r4, #6, #10
   150ae:	4918      	ldr	r1, [pc, #96]	; (15110 <process_env_data+0x5ac>)
   150b0:	b298      	uxth	r0, r3
   150b2:	f8ad 301c 	strh.w	r3, [sp, #28]
   150b6:	f01e fd9f 	bl	33bf8 <log_string_sync>
   150ba:	e5f4      	b.n	14ca6 <process_env_data+0x142>
                    LOG_INF("Connected to Google Cloud\n");
   150bc:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   150c0:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   150c4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   150c8:	f043 0303 	orr.w	r3, r3, #3
   150cc:	f363 0207 	bfi	r2, r3, #0, #8
   150d0:	b293      	uxth	r3, r2
   150d2:	f364 138f 	bfi	r3, r4, #6, #10
   150d6:	490f      	ldr	r1, [pc, #60]	; (15114 <process_env_data+0x5b0>)
   150d8:	b298      	uxth	r0, r3
   150da:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
   150de:	f01e fd8b 	bl	33bf8 <log_string_sync>
   150e2:	e612      	b.n	14d0a <process_env_data+0x1a6>
   150e4:	0003b9ec 	.word	0x0003b9ec
   150e8:	0003b9f9 	.word	0x0003b9f9
   150ec:	0003ba06 	.word	0x0003ba06
   150f0:	0003ba2e 	.word	0x0003ba2e
   150f4:	0003ba3b 	.word	0x0003ba3b
   150f8:	0003ba48 	.word	0x0003ba48
   150fc:	0003ba55 	.word	0x0003ba55
   15100:	0003ba62 	.word	0x0003ba62
   15104:	200210bc 	.word	0x200210bc
   15108:	0003b430 	.word	0x0003b430
   1510c:	0003ba84 	.word	0x0003ba84
   15110:	0003b8ce 	.word	0x0003b8ce
   15114:	0003b92f 	.word	0x0003b92f

00015118 <get_modem_info>:
{
   15118:	b510      	push	{r4, lr}
    LOG_INF("Getting modem info\n");
   1511a:	2303      	movs	r3, #3
{
   1511c:	4604      	mov	r4, r0
    LOG_INF("Getting modem info\n");
   1511e:	f04f 0000 	mov.w	r0, #0
   15122:	4a19      	ldr	r2, [pc, #100]	; (15188 <get_modem_info+0x70>)
   15124:	f363 0007 	bfi	r0, r3, #0, #8
   15128:	4b18      	ldr	r3, [pc, #96]	; (1518c <get_modem_info+0x74>)
   1512a:	4919      	ldr	r1, [pc, #100]	; (15190 <get_modem_info+0x78>)
   1512c:	1a9b      	subs	r3, r3, r2
   1512e:	08db      	lsrs	r3, r3, #3
   15130:	f363 108f 	bfi	r0, r3, #6, #10
   15134:	f01e fd60 	bl	33bf8 <log_string_sync>
    modem_info_string_get(MODEM_INFO_CELLID, info->cid, sizeof(info->cid));
   15138:	4621      	mov	r1, r4
   1513a:	221e      	movs	r2, #30
   1513c:	2008      	movs	r0, #8
   1513e:	f00c fc3d 	bl	219bc <modem_info_string_get>
    modem_info_string_get(MODEM_INFO_AREA_CODE, info->tac, sizeof(info->tac));
   15142:	221e      	movs	r2, #30
   15144:	2003      	movs	r0, #3
   15146:	18a1      	adds	r1, r4, r2
   15148:	f00c fc38 	bl	219bc <modem_info_string_get>
    modem_info_string_get(MODEM_INFO_RSRP, info->rssi, sizeof(info->rssi));
   1514c:	f104 013c 	add.w	r1, r4, #60	; 0x3c
   15150:	221e      	movs	r2, #30
   15152:	2000      	movs	r0, #0
   15154:	f00c fc32 	bl	219bc <modem_info_string_get>
    modem_info_string_get(MODEM_INFO_APN, info->apn, sizeof(info->apn));
   15158:	f104 015a 	add.w	r1, r4, #90	; 0x5a
   1515c:	223c      	movs	r2, #60	; 0x3c
   1515e:	2015      	movs	r0, #21
   15160:	f00c fc2c 	bl	219bc <modem_info_string_get>
    modem_info_string_get(MODEM_INFO_FW_VERSION, info->fwv, sizeof(info->fwv));
   15164:	f104 0196 	add.w	r1, r4, #150	; 0x96
   15168:	223c      	movs	r2, #60	; 0x3c
   1516a:	200d      	movs	r0, #13
   1516c:	f00c fc26 	bl	219bc <modem_info_string_get>
	modem_info_short_get(MODEM_INFO_BATTERY, &info->vltg);
   15170:	f104 01d2 	add.w	r1, r4, #210	; 0xd2
   15174:	200b      	movs	r0, #11
   15176:	f00c fbf1 	bl	2195c <modem_info_short_get>
    modem_info_short_get(MODEM_INFO_TEMP, &info->temp);
   1517a:	f104 01d4 	add.w	r1, r4, #212	; 0xd4
   1517e:	200c      	movs	r0, #12
}
   15180:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    modem_info_short_get(MODEM_INFO_TEMP, &info->temp);
   15184:	f00c bbea 	b.w	2195c <modem_info_short_get>
   15188:	00039f60 	.word	0x00039f60
   1518c:	00039fa8 	.word	0x00039fa8
   15190:	0003b675 	.word	0x0003b675

00015194 <init_env_sensor>:
    LOG_INF("Sensor workqueue started\n");
   15194:	2303      	movs	r3, #3
   15196:	f04f 0000 	mov.w	r0, #0
{
   1519a:	b510      	push	{r4, lr}
    LOG_INF("Sensor workqueue started\n");
   1519c:	f363 0007 	bfi	r0, r3, #0, #8
   151a0:	4c1b      	ldr	r4, [pc, #108]	; (15210 <init_env_sensor+0x7c>)
   151a2:	4b1c      	ldr	r3, [pc, #112]	; (15214 <init_env_sensor+0x80>)
   151a4:	491c      	ldr	r1, [pc, #112]	; (15218 <init_env_sensor+0x84>)
   151a6:	1ae4      	subs	r4, r4, r3
   151a8:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   151ac:	f364 108f 	bfi	r0, r4, #6, #10
   151b0:	f01e fd22 	bl	33bf8 <log_string_sync>
	k_work_q_start(&env_sens_q, env_sens_stack_area,
   151b4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   151b8:	2307      	movs	r3, #7
   151ba:	4918      	ldr	r1, [pc, #96]	; (1521c <init_env_sensor+0x88>)
   151bc:	4818      	ldr	r0, [pc, #96]	; (15220 <init_env_sensor+0x8c>)
   151be:	f019 f9b5 	bl	2e52c <k_work_q_start>
    LOG_INF("Initializing environmental sensor\n");
   151c2:	2303      	movs	r3, #3
   151c4:	f04f 0000 	mov.w	r0, #0
   151c8:	f363 0007 	bfi	r0, r3, #0, #8
   151cc:	f364 108f 	bfi	r0, r4, #6, #10
   151d0:	4914      	ldr	r1, [pc, #80]	; (15224 <init_env_sensor+0x90>)
   151d2:	f01e fd11 	bl	33bf8 <log_string_sync>
    err = env_sensors_init_and_start(&env_sens_q, env_data_ready);
   151d6:	4914      	ldr	r1, [pc, #80]	; (15228 <init_env_sensor+0x94>)
   151d8:	4811      	ldr	r0, [pc, #68]	; (15220 <init_env_sensor+0x8c>)
   151da:	f002 fbc5 	bl	17968 <env_sensors_init_and_start>
    if (err) {
   151de:	4602      	mov	r2, r0
        LOG_INF("environmental sensor initialization failed [%d]\n", err);
   151e0:	f04f 0000 	mov.w	r0, #0
    if (err) {
   151e4:	b14a      	cbz	r2, 151fa <init_env_sensor+0x66>
        LOG_INF("environmental sensor initialization failed [%d]\n", err);
   151e6:	2103      	movs	r1, #3
   151e8:	f361 0007 	bfi	r0, r1, #0, #8
   151ec:	f364 108f 	bfi	r0, r4, #6, #10
   151f0:	490e      	ldr	r1, [pc, #56]	; (1522c <init_env_sensor+0x98>)
}
   151f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LOG_INF("environmental sensor initialization failed [%d]\n", err);
   151f6:	f01e bcff 	b.w	33bf8 <log_string_sync>
        LOG_INF("environmental sensor initialized\n");
   151fa:	2303      	movs	r3, #3
   151fc:	f363 0007 	bfi	r0, r3, #0, #8
   15200:	f364 108f 	bfi	r0, r4, #6, #10
   15204:	490a      	ldr	r1, [pc, #40]	; (15230 <init_env_sensor+0x9c>)
}
   15206:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LOG_INF("environmental sensor initialized\n");
   1520a:	f01e bcf5 	b.w	33bf8 <log_string_sync>
   1520e:	bf00      	nop
   15210:	00039fa8 	.word	0x00039fa8
   15214:	00039f60 	.word	0x00039f60
   15218:	0003b689 	.word	0x0003b689
   1521c:	2002b208 	.word	0x2002b208
   15220:	20021264 	.word	0x20021264
   15224:	0003b6a3 	.word	0x0003b6a3
   15228:	00014a81 	.word	0x00014a81
   1522c:	0003b6c6 	.word	0x0003b6c6
   15230:	0003b6f7 	.word	0x0003b6f7

00015234 <main>:


/**@brief Thread initialisation */
void main(void)
{
    LOG_INF("Google Cloud env sensor app started");
   15234:	2303      	movs	r3, #3
   15236:	f04f 0000 	mov.w	r0, #0
{
   1523a:	b530      	push	{r4, r5, lr}
    LOG_INF("Google Cloud env sensor app started");
   1523c:	f363 0007 	bfi	r0, r3, #0, #8
   15240:	4c58      	ldr	r4, [pc, #352]	; (153a4 <main+0x170>)
   15242:	4b59      	ldr	r3, [pc, #356]	; (153a8 <main+0x174>)
{
   15244:	b087      	sub	sp, #28
    LOG_INF("Google Cloud env sensor app started");
   15246:	1ae4      	subs	r4, r4, r3
   15248:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1524c:	f364 108f 	bfi	r0, r4, #6, #10
   15250:	4956      	ldr	r1, [pc, #344]	; (153ac <main+0x178>)
   15252:	f01e fcd1 	bl	33bf8 <log_string_sync>

	k_work_q_start(&app_work_q, wdt_stack_area,
   15256:	f44f 7200 	mov.w	r2, #512	; 0x200
   1525a:	2307      	movs	r3, #7
   1525c:	4954      	ldr	r1, [pc, #336]	; (153b0 <main+0x17c>)
   1525e:	4855      	ldr	r0, [pc, #340]	; (153b4 <main+0x180>)
   15260:	f019 f964 	bl	2e52c <k_work_q_start>
		       K_THREAD_STACK_SIZEOF(wdt_stack_area),
		       CONFIG_APPLICATION_WORKQUEUE_PRIORITY);
	if (IS_ENABLED(CONFIG_WATCHDOG)) {
		watchdog_init_and_start(&app_work_q);
   15264:	4853      	ldr	r0, [pc, #332]	; (153b4 <main+0x180>)
   15266:	f003 fa53 	bl	18710 <watchdog_init_and_start>
	}

	LOG_INF("Initializing modem\n");
   1526a:	2303      	movs	r3, #3
   1526c:	f04f 0000 	mov.w	r0, #0
   15270:	f363 0007 	bfi	r0, r3, #0, #8
   15274:	f364 108f 	bfi	r0, r4, #6, #10
   15278:	494f      	ldr	r1, [pc, #316]	; (153b8 <main+0x184>)
   1527a:	f01e fcbd 	bl	33bf8 <log_string_sync>
        LOG_INF("Establishing LTE link\n");
   1527e:	2303      	movs	r3, #3
   15280:	f04f 0000 	mov.w	r0, #0
   15284:	f363 0007 	bfi	r0, r3, #0, #8
   15288:	f364 108f 	bfi	r0, r4, #6, #10
   1528c:	494b      	ldr	r1, [pc, #300]	; (153bc <main+0x188>)
   1528e:	f01e fcb3 	bl	33bf8 <log_string_sync>
        err = lte_lc_init_and_connect();
   15292:	f023 fbcf 	bl	38a34 <lte_lc_init_and_connect>
        __ASSERT(err == 0, "LTE link could not be established. Rebooting\n");
   15296:	b160      	cbz	r0, 152b2 <main+0x7e>
   15298:	4949      	ldr	r1, [pc, #292]	; (153c0 <main+0x18c>)
   1529a:	23de      	movs	r3, #222	; 0xde
   1529c:	4a49      	ldr	r2, [pc, #292]	; (153c4 <main+0x190>)
   1529e:	484a      	ldr	r0, [pc, #296]	; (153c8 <main+0x194>)
   152a0:	f01e f992 	bl	335c8 <printk>
   152a4:	4849      	ldr	r0, [pc, #292]	; (153cc <main+0x198>)
   152a6:	f01e f98f 	bl	335c8 <printk>
   152aa:	21de      	movs	r1, #222	; 0xde
   152ac:	4845      	ldr	r0, [pc, #276]	; (153c4 <main+0x190>)
   152ae:	f01e fc8c 	bl	33bca <assert_post_action>
    lte_lc_psm_req(true);
   152b2:	2001      	movs	r0, #1
   152b4:	f00c f87c 	bl	213b0 <lte_lc_psm_req>
    modem_configure();

    LOG_INF("Initializing modem info\n");
   152b8:	2303      	movs	r3, #3
   152ba:	f04f 0000 	mov.w	r0, #0
   152be:	f363 0007 	bfi	r0, r3, #0, #8
   152c2:	f364 108f 	bfi	r0, r4, #6, #10
   152c6:	4942      	ldr	r1, [pc, #264]	; (153d0 <main+0x19c>)
   152c8:	f01e fc96 	bl	33bf8 <log_string_sync>
    modem_info_init();
   152cc:	f00c fc9c 	bl	21c08 <modem_info_init>

    LOG_INF("Initializing environmental sensor\n");
   152d0:	2303      	movs	r3, #3
   152d2:	f04f 0000 	mov.w	r0, #0
   152d6:	f363 0007 	bfi	r0, r3, #0, #8
   152da:	f364 108f 	bfi	r0, r4, #6, #10
   152de:	493d      	ldr	r1, [pc, #244]	; (153d4 <main+0x1a0>)
   152e0:	f01e fc8a 	bl	33bf8 <log_string_sync>
    init_env_sensor();
   152e4:	f7ff ff56 	bl	15194 <init_env_sensor>

    LOG_INF("Initializing bsec data message queue\n");
   152e8:	2303      	movs	r3, #3
   152ea:	f04f 0000 	mov.w	r0, #0
   152ee:	f363 0007 	bfi	r0, r3, #0, #8
   152f2:	f364 108f 	bfi	r0, r4, #6, #10
   152f6:	4938      	ldr	r1, [pc, #224]	; (153d8 <main+0x1a4>)
   152f8:	f01e fc7e 	bl	33bf8 <log_string_sync>
    k_msgq_init(&env_msg_q, env_msgq_buffer, sizeof(env_d), 10);
   152fc:	2214      	movs	r2, #20
   152fe:	230a      	movs	r3, #10
   15300:	4936      	ldr	r1, [pc, #216]	; (153dc <main+0x1a8>)
   15302:	4837      	ldr	r0, [pc, #220]	; (153e0 <main+0x1ac>)
   15304:	f023 fc9e 	bl	38c44 <k_msgq_init>

    LOG_INF("Initializing aggregated data mailbox\n");
   15308:	2303      	movs	r3, #3
   1530a:	f04f 0000 	mov.w	r0, #0
   1530e:	f363 0007 	bfi	r0, r3, #0, #8
   15312:	f364 108f 	bfi	r0, r4, #6, #10
   15316:	4933      	ldr	r1, [pc, #204]	; (153e4 <main+0x1b0>)
   15318:	f01e fc6e 	bl	33bf8 <log_string_sync>
    k_mbox_init(&env_d_mailbox);
   1531c:	4832      	ldr	r0, [pc, #200]	; (153e8 <main+0x1b4>)
   1531e:	f023 fc45 	bl	38bac <k_mbox_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   15322:	2400      	movs	r4, #0
   15324:	2507      	movs	r5, #7
   15326:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1532a:	e9cd 4502 	strd	r4, r5, [sp, #8]
   1532e:	e9cd 4400 	strd	r4, r4, [sp]
   15332:	4b2e      	ldr	r3, [pc, #184]	; (153ec <main+0x1b8>)
   15334:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   15338:	492d      	ldr	r1, [pc, #180]	; (153f0 <main+0x1bc>)
   1533a:	482e      	ldr	r0, [pc, #184]	; (153f4 <main+0x1c0>)
   1533c:	f018 fff2 	bl	2e324 <z_impl_k_thread_create>

    /* Initialise data aggregation thread */
    d_ag_tid = k_thread_create(&data_ag_thread, data_ag_stack_area, K_THREAD_STACK_SIZEOF(data_ag_stack_area),
   15340:	4b2d      	ldr	r3, [pc, #180]	; (153f8 <main+0x1c4>)
   15342:	6018      	str	r0, [r3, #0]
   15344:	4b2d      	ldr	r3, [pc, #180]	; (153fc <main+0x1c8>)
   15346:	e9cd 4404 	strd	r4, r4, [sp, #16]
   1534a:	e9cd 4502 	strd	r4, r5, [sp, #8]
   1534e:	e9cd 4400 	strd	r4, r4, [sp]
   15352:	f44f 7200 	mov.w	r2, #512	; 0x200
   15356:	492a      	ldr	r1, [pc, #168]	; (15400 <main+0x1cc>)
   15358:	482a      	ldr	r0, [pc, #168]	; (15404 <main+0x1d0>)
   1535a:	f018 ffe3 	bl	2e324 <z_impl_k_thread_create>
        (k_thread_entry_t)process_env_data, NULL, NULL, NULL,
        7, 0, K_NO_WAIT);

    /* Initialise time pool poll thread */
    ntp_tid = k_thread_create(&ntp_thread, ntp_stack_area, K_THREAD_STACK_SIZEOF(ntp_stack_area),
   1535e:	4b2a      	ldr	r3, [pc, #168]	; (15408 <main+0x1d4>)
   15360:	6018      	str	r0, [r3, #0]
   15362:	4b2a      	ldr	r3, [pc, #168]	; (1540c <main+0x1d8>)
   15364:	e9cd 4404 	strd	r4, r4, [sp, #16]
   15368:	e9cd 4502 	strd	r4, r5, [sp, #8]
   1536c:	e9cd 4400 	strd	r4, r4, [sp]
   15370:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   15374:	4926      	ldr	r1, [pc, #152]	; (15410 <main+0x1dc>)
   15376:	4827      	ldr	r0, [pc, #156]	; (15414 <main+0x1e0>)
   15378:	f018 ffd4 	bl	2e324 <z_impl_k_thread_create>
        (k_thread_entry_t)ntp_poll, NULL, NULL, NULL,
        7, 0, K_NO_WAIT);

    /* Initialise Google Cloud thread */
    gc_tid = k_thread_create(&gc_thread, gc_stack_area, K_THREAD_STACK_SIZEOF(gc_stack_area),
   1537c:	4b26      	ldr	r3, [pc, #152]	; (15418 <main+0x1e4>)
   1537e:	6018      	str	r0, [r3, #0]
   15380:	4b26      	ldr	r3, [pc, #152]	; (1541c <main+0x1e8>)
   15382:	e9cd 4404 	strd	r4, r4, [sp, #16]
   15386:	e9cd 4502 	strd	r4, r5, [sp, #8]
   1538a:	e9cd 4400 	strd	r4, r4, [sp]
   1538e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   15392:	4923      	ldr	r1, [pc, #140]	; (15420 <main+0x1ec>)
   15394:	4823      	ldr	r0, [pc, #140]	; (15424 <main+0x1f0>)
   15396:	f018 ffc5 	bl	2e324 <z_impl_k_thread_create>
        (k_thread_entry_t)gcloud_thread, NULL, NULL, NULL,
        7, 0, K_NO_WAIT);

    /* Initialise App thread */
    app_tid = k_thread_create(&app_thread, app_stack_area, K_THREAD_STACK_SIZEOF(app_stack_area),
   1539a:	4b23      	ldr	r3, [pc, #140]	; (15428 <main+0x1f4>)
   1539c:	6018      	str	r0, [r3, #0]
        (k_thread_entry_t)app_gc_iot, NULL, NULL, NULL,
        7, 0, K_NO_WAIT);
   1539e:	b007      	add	sp, #28
   153a0:	bd30      	pop	{r4, r5, pc}
   153a2:	bf00      	nop
   153a4:	00039fa8 	.word	0x00039fa8
   153a8:	00039f60 	.word	0x00039f60
   153ac:	0003b719 	.word	0x0003b719
   153b0:	20030408 	.word	0x20030408
   153b4:	20020f2c 	.word	0x20020f2c
   153b8:	0003b73d 	.word	0x0003b73d
   153bc:	0003b751 	.word	0x0003b751
   153c0:	0003b776 	.word	0x0003b776
   153c4:	0003b768 	.word	0x0003b768
   153c8:	0003b77f 	.word	0x0003b77f
   153cc:	0003b79c 	.word	0x0003b79c
   153d0:	0003b7cc 	.word	0x0003b7cc
   153d4:	0003b6a3 	.word	0x0003b6a3
   153d8:	0003b7e5 	.word	0x0003b7e5
   153dc:	200210fc 	.word	0x200210fc
   153e0:	200210d0 	.word	0x200210d0
   153e4:	0003b80b 	.word	0x0003b80b
   153e8:	200210bc 	.word	0x200210bc
   153ec:	00014b65 	.word	0x00014b65
   153f0:	2002d208 	.word	0x2002d208
   153f4:	20021004 	.word	0x20021004
   153f8:	20021000 	.word	0x20021000
   153fc:	00014b11 	.word	0x00014b11
   15400:	20030208 	.word	0x20030208
   15404:	200213f4 	.word	0x200213f4
   15408:	200214ac 	.word	0x200214ac
   1540c:	00015b69 	.word	0x00015b69
   15410:	2002f208 	.word	0x2002f208
   15414:	20021338 	.word	0x20021338
   15418:	200213f0 	.word	0x200213f0
   1541c:	00012091 	.word	0x00012091
   15420:	20029208 	.word	0x20029208
   15424:	20020e70 	.word	0x20020e70
   15428:	20020f28 	.word	0x20020f28

0001542c <input_timer_handler>:
    int temp = k_msgq_put(q,data, timeout);
    irq_unlock(key);
    return temp;
}

void input_timer_handler(struct k_timer *timer_id) {
   1542c:	b530      	push	{r4, r5, lr}
   1542e:	b087      	sub	sp, #28
    struct gcloud_event cmd = {
   15430:	2218      	movs	r2, #24
   15432:	2100      	movs	r1, #0
   15434:	4668      	mov	r0, sp
   15436:	f023 fe09 	bl	3904c <memset>
   1543a:	2301      	movs	r3, #1
   1543c:	f88d 3000 	strb.w	r3, [sp]
	return z_impl_k_msgq_put(msgq, data, timeout);
   15440:	2200      	movs	r2, #0
   15442:	4669      	mov	r1, sp
   15444:	480d      	ldr	r0, [pc, #52]	; (1547c <input_timer_handler+0x50>)
   15446:	f016 ff63 	bl	2c310 <z_impl_k_msgq_put>
        .type = INPUT_TIMEOUT,
        .param = {}
    };
    int err = k_msgq_put(&gcloud_msgq, &cmd, K_NO_WAIT);
    if (err) {
   1544a:	4605      	mov	r5, r0
   1544c:	b198      	cbz	r0, 15476 <input_timer_handler+0x4a>
        LOG_ERR("k_msgq_put (input_timeout) failed: [%d] %s", err, strerror(-err));
   1544e:	2301      	movs	r3, #1
   15450:	f04f 0400 	mov.w	r4, #0
   15454:	4a0a      	ldr	r2, [pc, #40]	; (15480 <input_timer_handler+0x54>)
   15456:	f363 0407 	bfi	r4, r3, #0, #8
   1545a:	4b0a      	ldr	r3, [pc, #40]	; (15484 <input_timer_handler+0x58>)
   1545c:	4240      	negs	r0, r0
   1545e:	1a9b      	subs	r3, r3, r2
   15460:	08db      	lsrs	r3, r3, #3
   15462:	f363 148f 	bfi	r4, r3, #6, #10
   15466:	f01c fe45 	bl	320f4 <strerror>
   1546a:	462a      	mov	r2, r5
   1546c:	4603      	mov	r3, r0
   1546e:	4906      	ldr	r1, [pc, #24]	; (15488 <input_timer_handler+0x5c>)
   15470:	4620      	mov	r0, r4
   15472:	f01e fbc1 	bl	33bf8 <log_string_sync>
        // TODO: Find a way to report this error to the application.
    }
}
   15476:	b007      	add	sp, #28
   15478:	bd30      	pop	{r4, r5, pc}
   1547a:	bf00      	nop
   1547c:	200207a0 	.word	0x200207a0
   15480:	00039f60 	.word	0x00039f60
   15484:	00039fa0 	.word	0x00039fa0
   15488:	0003c151 	.word	0x0003c151

0001548c <make_jwt.constprop.0>:
static int make_jwt(char *buffer, size_t buffer_size) {
   1548c:	b510      	push	{r4, lr}
   1548e:	b088      	sub	sp, #32
    err = jwt_init_builder(&jb, buffer, buffer_size);
   15490:	f44f 7280 	mov.w	r2, #256	; 0x100
   15494:	492e      	ldr	r1, [pc, #184]	; (15550 <make_jwt.constprop.0+0xc4>)
   15496:	a803      	add	r0, sp, #12
   15498:	f009 fcec 	bl	1ee74 <jwt_init_builder>
    if (err != 0) {
   1549c:	4604      	mov	r4, r0
   1549e:	b188      	cbz	r0, 154c4 <make_jwt.constprop.0+0x38>
        LOG_ERR("Unable to init JWT builder: %d", err);
   154a0:	2301      	movs	r3, #1
   154a2:	f04f 0000 	mov.w	r0, #0
   154a6:	4a2b      	ldr	r2, [pc, #172]	; (15554 <make_jwt.constprop.0+0xc8>)
   154a8:	f363 0007 	bfi	r0, r3, #0, #8
   154ac:	4b2a      	ldr	r3, [pc, #168]	; (15558 <make_jwt.constprop.0+0xcc>)
   154ae:	492b      	ldr	r1, [pc, #172]	; (1555c <make_jwt.constprop.0+0xd0>)
   154b0:	1a9b      	subs	r3, r3, r2
   154b2:	4622      	mov	r2, r4
   154b4:	08db      	lsrs	r3, r3, #3
   154b6:	f363 108f 	bfi	r0, r3, #6, #10
        LOG_ERR("Unable to add JWT payload: %d", err);
   154ba:	f01e fb9d 	bl	33bf8 <log_string_sync>
}
   154be:	4620      	mov	r0, r4
   154c0:	b008      	add	sp, #32
   154c2:	bd10      	pop	{r4, pc}
    date_time_now(&ntp);
   154c4:	4668      	mov	r0, sp
   154c6:	f023 facd 	bl	38a64 <date_time_now>
    s64_t unixtime = (ntp/1000);    //TODO: Is unix time valid as jwt timestamp?
   154ca:	e9dd 0100 	ldrd	r0, r1, [sp]
   154ce:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   154d2:	2300      	movs	r3, #0
   154d4:	f7f8 f8fc 	bl	d6d0 <__aeabi_ldivmod>
   154d8:	4604      	mov	r4, r0
    printk("UNIX TIMESTAMP: %d\n", y);
   154da:	4601      	mov	r1, r0
   154dc:	4820      	ldr	r0, [pc, #128]	; (15560 <make_jwt.constprop.0+0xd4>)
   154de:	f01e f873 	bl	335c8 <printk>
    err = jwt_add_payload(&jb, expiry_time, issue_time, CONFIG_GCLOUD_PROJECT_NAME);
   154e2:	f504 4128 	add.w	r1, r4, #43008	; 0xa800
   154e6:	4622      	mov	r2, r4
   154e8:	4b1e      	ldr	r3, [pc, #120]	; (15564 <make_jwt.constprop.0+0xd8>)
   154ea:	31c0      	adds	r1, #192	; 0xc0
   154ec:	a803      	add	r0, sp, #12
   154ee:	f009 fc53 	bl	1ed98 <jwt_add_payload>
    if (err != 0) {
   154f2:	4604      	mov	r4, r0
   154f4:	b168      	cbz	r0, 15512 <make_jwt.constprop.0+0x86>
        LOG_ERR("Unable to add JWT payload: %d", err);
   154f6:	2301      	movs	r3, #1
   154f8:	f04f 0000 	mov.w	r0, #0
   154fc:	4a15      	ldr	r2, [pc, #84]	; (15554 <make_jwt.constprop.0+0xc8>)
   154fe:	f363 0007 	bfi	r0, r3, #0, #8
   15502:	4b15      	ldr	r3, [pc, #84]	; (15558 <make_jwt.constprop.0+0xcc>)
   15504:	4918      	ldr	r1, [pc, #96]	; (15568 <make_jwt.constprop.0+0xdc>)
   15506:	1a9b      	subs	r3, r3, r2
   15508:	08db      	lsrs	r3, r3, #3
   1550a:	f363 108f 	bfi	r0, r3, #6, #10
   1550e:	4622      	mov	r2, r4
   15510:	e7d3      	b.n	154ba <make_jwt.constprop.0+0x2e>
    err = jwt_sign(&jb, zepfull_private_der, zepfull_private_der_len);
   15512:	4b16      	ldr	r3, [pc, #88]	; (1556c <make_jwt.constprop.0+0xe0>)
   15514:	4916      	ldr	r1, [pc, #88]	; (15570 <make_jwt.constprop.0+0xe4>)
   15516:	681a      	ldr	r2, [r3, #0]
   15518:	a803      	add	r0, sp, #12
   1551a:	f009 fc59 	bl	1edd0 <jwt_sign>
    if (err != 0) {
   1551e:	4604      	mov	r4, r0
   15520:	2800      	cmp	r0, #0
   15522:	d1e8      	bne.n	154f6 <make_jwt.constprop.0+0x6a>
    if (jb.overflowed != 0) {
   15524:	f89d 3018 	ldrb.w	r3, [sp, #24]
   15528:	2b00      	cmp	r3, #0
   1552a:	d0c8      	beq.n	154be <make_jwt.constprop.0+0x32>
        LOG_ERR("JWT buffer overflowed");
   1552c:	2301      	movs	r3, #1
   1552e:	f04f 0000 	mov.w	r0, #0
   15532:	4a08      	ldr	r2, [pc, #32]	; (15554 <make_jwt.constprop.0+0xc8>)
   15534:	f363 0007 	bfi	r0, r3, #0, #8
   15538:	4b07      	ldr	r3, [pc, #28]	; (15558 <make_jwt.constprop.0+0xcc>)
   1553a:	490e      	ldr	r1, [pc, #56]	; (15574 <make_jwt.constprop.0+0xe8>)
   1553c:	1a9b      	subs	r3, r3, r2
   1553e:	08db      	lsrs	r3, r3, #3
   15540:	f363 108f 	bfi	r0, r3, #6, #10
   15544:	f01e fb58 	bl	33bf8 <log_string_sync>
        return -ENOMEM;
   15548:	f06f 040b 	mvn.w	r4, #11
   1554c:	e7b7      	b.n	154be <make_jwt.constprop.0+0x32>
   1554e:	bf00      	nop
   15550:	20027625 	.word	0x20027625
   15554:	00039f60 	.word	0x00039f60
   15558:	00039fa0 	.word	0x00039fa0
   1555c:	0003c17c 	.word	0x0003c17c
   15560:	0003c19b 	.word	0x0003c19b
   15564:	0003c1af 	.word	0x0003c1af
   15568:	0003c1c2 	.word	0x0003c1c2
   1556c:	20020084 	.word	0x20020084
   15570:	20020404 	.word	0x20020404
   15574:	0003c1e0 	.word	0x0003c1e0

00015578 <reconnect_timer_handler>:

void reconnect_timer_handler(struct k_timer *timer_id) {
   15578:	b530      	push	{r4, r5, lr}
   1557a:	b087      	sub	sp, #28
    struct gcloud_event cmd = {
   1557c:	2218      	movs	r2, #24
   1557e:	2100      	movs	r1, #0
   15580:	4668      	mov	r0, sp
   15582:	f023 fd63 	bl	3904c <memset>
   15586:	2305      	movs	r3, #5
   15588:	f88d 3000 	strb.w	r3, [sp]
   1558c:	2200      	movs	r2, #0
   1558e:	4669      	mov	r1, sp
   15590:	480c      	ldr	r0, [pc, #48]	; (155c4 <reconnect_timer_handler+0x4c>)
   15592:	f016 febd 	bl	2c310 <z_impl_k_msgq_put>
        .type = RECONNECT_TIMEOUT,
        .param = {}
    };
    int err = k_msgq_put(&gcloud_msgq, &cmd, K_NO_WAIT);

    if (err) {
   15596:	4605      	mov	r5, r0
   15598:	b190      	cbz	r0, 155c0 <reconnect_timer_handler+0x48>
        LOG_ERR("k_msgq_put (reconnect_timeout) failed: [%d] %s", err, strerror(err));
   1559a:	2301      	movs	r3, #1
   1559c:	f04f 0400 	mov.w	r4, #0
   155a0:	4a09      	ldr	r2, [pc, #36]	; (155c8 <reconnect_timer_handler+0x50>)
   155a2:	f363 0407 	bfi	r4, r3, #0, #8
   155a6:	4b09      	ldr	r3, [pc, #36]	; (155cc <reconnect_timer_handler+0x54>)
   155a8:	1a9b      	subs	r3, r3, r2
   155aa:	08db      	lsrs	r3, r3, #3
   155ac:	f363 148f 	bfi	r4, r3, #6, #10
   155b0:	f01c fda0 	bl	320f4 <strerror>
   155b4:	462a      	mov	r2, r5
   155b6:	4603      	mov	r3, r0
   155b8:	4905      	ldr	r1, [pc, #20]	; (155d0 <reconnect_timer_handler+0x58>)
   155ba:	4620      	mov	r0, r4
   155bc:	f01e fb1c 	bl	33bf8 <log_string_sync>
        // TODO: Find a way to report this error to the application.
    }
}
   155c0:	b007      	add	sp, #28
   155c2:	bd30      	pop	{r4, r5, pc}
   155c4:	200207a0 	.word	0x200207a0
   155c8:	00039f60 	.word	0x00039f60
   155cc:	00039fa0 	.word	0x00039fa0
   155d0:	0003c496 	.word	0x0003c496

000155d4 <gcloud_provision>:
int gcloud_provision(void) {
   155d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            LOG_ERR("key delete err: [%d] %s", err, strerror(err));
   155d8:	2500      	movs	r5, #0
   155da:	4c1f      	ldr	r4, [pc, #124]	; (15658 <gcloud_provision+0x84>)
   155dc:	4b1f      	ldr	r3, [pc, #124]	; (1565c <gcloud_provision+0x88>)
        err = modem_key_mgmt_delete(sec_tag, type);
   155de:	4f20      	ldr	r7, [pc, #128]	; (15660 <gcloud_provision+0x8c>)
            LOG_ERR("key delete err: [%d] %s", err, strerror(err));
   155e0:	1ae4      	subs	r4, r4, r3
   155e2:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1566c <gcloud_provision+0x98>
   155e6:	f3c4 04c9 	ubfx	r4, r4, #3, #10
        err = modem_key_mgmt_delete(sec_tag, type);
   155ea:	b2e9      	uxtb	r1, r5
   155ec:	4638      	mov	r0, r7
   155ee:	f00c fbd1 	bl	21d94 <modem_key_mgmt_delete>
        if (err) {
   155f2:	4681      	mov	r9, r0
   155f4:	b178      	cbz	r0, 15616 <gcloud_provision+0x42>
            LOG_ERR("key delete err: [%d] %s", err, strerror(err));
   155f6:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   155fa:	f043 0301 	orr.w	r3, r3, #1
   155fe:	f363 0607 	bfi	r6, r3, #0, #8
   15602:	f01c fd77 	bl	320f4 <strerror>
   15606:	f364 168f 	bfi	r6, r4, #6, #10
   1560a:	4603      	mov	r3, r0
   1560c:	464a      	mov	r2, r9
   1560e:	4641      	mov	r1, r8
   15610:	4630      	mov	r0, r6
   15612:	f01e faf1 	bl	33bf8 <log_string_sync>
   15616:	3501      	adds	r5, #1
    for (enum modem_key_mgnt_cred_type type = 0; type < 5; type++) {
   15618:	2d05      	cmp	r5, #5
   1561a:	d1e6      	bne.n	155ea <gcloud_provision+0x16>
    err = modem_key_mgmt_write(
   1561c:	4811      	ldr	r0, [pc, #68]	; (15664 <gcloud_provision+0x90>)
   1561e:	f7fc fd2f 	bl	12080 <strlen>
   15622:	4a10      	ldr	r2, [pc, #64]	; (15664 <gcloud_provision+0x90>)
   15624:	4603      	mov	r3, r0
   15626:	2100      	movs	r1, #0
   15628:	480d      	ldr	r0, [pc, #52]	; (15660 <gcloud_provision+0x8c>)
   1562a:	f00c fb7b 	bl	21d24 <modem_key_mgmt_write>
    if (err != 0) {
   1562e:	4606      	mov	r6, r0
   15630:	b170      	cbz	r0, 15650 <gcloud_provision+0x7c>
        LOG_ERR("GCLOUD_CA_CERTIFICATE err: [%d] %s\n", err, strerror(err));
   15632:	2301      	movs	r3, #1
   15634:	f04f 0500 	mov.w	r5, #0
   15638:	f363 0507 	bfi	r5, r3, #0, #8
   1563c:	f01c fd5a 	bl	320f4 <strerror>
   15640:	f364 158f 	bfi	r5, r4, #6, #10
   15644:	4603      	mov	r3, r0
   15646:	4632      	mov	r2, r6
   15648:	4907      	ldr	r1, [pc, #28]	; (15668 <gcloud_provision+0x94>)
   1564a:	4628      	mov	r0, r5
   1564c:	f01e fad4 	bl	33bf8 <log_string_sync>
}
   15650:	4630      	mov	r0, r6
   15652:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   15656:	bf00      	nop
   15658:	00039fa0 	.word	0x00039fa0
   1565c:	00039f60 	.word	0x00039f60
   15660:	01010000 	.word	0x01010000
   15664:	0003bb0f 	.word	0x0003bb0f
   15668:	0003bd45 	.word	0x0003bd45
   1566c:	0003baf7 	.word	0x0003baf7

00015670 <gcloud_connect>:
int gcloud_connect(received_config_handler_t received_config_cb) {
   15670:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    received_config_handler = received_config_cb;
   15672:	4b08      	ldr	r3, [pc, #32]	; (15694 <gcloud_connect+0x24>)
    struct gcloud_event msg = {
   15674:	2218      	movs	r2, #24
    received_config_handler = received_config_cb;
   15676:	6018      	str	r0, [r3, #0]
    struct gcloud_event msg = {
   15678:	2100      	movs	r1, #0
   1567a:	4668      	mov	r0, sp
   1567c:	f023 fce6 	bl	3904c <memset>
    err = k_msgq_put_atomic(&gcloud_msgq, &msg, K_FOREVER);
   15680:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15684:	4669      	mov	r1, sp
   15686:	4804      	ldr	r0, [pc, #16]	; (15698 <gcloud_connect+0x28>)
   15688:	f01d fb0f 	bl	32caa <k_msgq_put_atomic>
}
   1568c:	b007      	add	sp, #28
   1568e:	f85d fb04 	ldr.w	pc, [sp], #4
   15692:	bf00      	nop
   15694:	20021530 	.word	0x20021530
   15698:	200207a0 	.word	0x200207a0

0001569c <gcloud_publish>:
{
   1569c:	b570      	push	{r4, r5, r6, lr}
    if (!connected) {
   1569e:	4b16      	ldr	r3, [pc, #88]	; (156f8 <gcloud_publish+0x5c>)
{
   156a0:	b086      	sub	sp, #24
    if (!connected) {
   156a2:	781b      	ldrb	r3, [r3, #0]
{
   156a4:	4605      	mov	r5, r0
   156a6:	460c      	mov	r4, r1
   156a8:	4616      	mov	r6, r2
    if (!connected) {
   156aa:	b98b      	cbnz	r3, 156d0 <gcloud_publish+0x34>
        LOG_WRN("Cannot publish data while not connected to Google Cloud");
   156ac:	2302      	movs	r3, #2
   156ae:	f04f 0000 	mov.w	r0, #0
   156b2:	4a12      	ldr	r2, [pc, #72]	; (156fc <gcloud_publish+0x60>)
   156b4:	f363 0007 	bfi	r0, r3, #0, #8
   156b8:	4b11      	ldr	r3, [pc, #68]	; (15700 <gcloud_publish+0x64>)
   156ba:	4912      	ldr	r1, [pc, #72]	; (15704 <gcloud_publish+0x68>)
   156bc:	1a9b      	subs	r3, r3, r2
   156be:	08db      	lsrs	r3, r3, #3
   156c0:	f363 108f 	bfi	r0, r3, #6, #10
   156c4:	f01e fa98 	bl	33bf8 <log_string_sync>
        return -ENOTCONN;
   156c8:	f06f 007f 	mvn.w	r0, #127	; 0x7f
}
   156cc:	b006      	add	sp, #24
   156ce:	bd70      	pop	{r4, r5, r6, pc}
    struct gcloud_event cmd = {
   156d0:	2304      	movs	r3, #4
   156d2:	480d      	ldr	r0, [pc, #52]	; (15708 <gcloud_publish+0x6c>)
   156d4:	f88d 3000 	strb.w	r3, [sp]
   156d8:	9001      	str	r0, [sp, #4]
                    .size = strlen(GCLOUD_TOPIC)
   156da:	f7fc fcd1 	bl	12080 <strlen>
    err = k_msgq_put_atomic(&gcloud_msgq, &cmd, K_FOREVER);
   156de:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    struct gcloud_event cmd = {
   156e2:	9002      	str	r0, [sp, #8]
    err = k_msgq_put_atomic(&gcloud_msgq, &cmd, K_FOREVER);
   156e4:	4669      	mov	r1, sp
   156e6:	4809      	ldr	r0, [pc, #36]	; (1570c <gcloud_publish+0x70>)
    struct gcloud_event cmd = {
   156e8:	f88d 600c 	strb.w	r6, [sp, #12]
   156ec:	e9cd 5404 	strd	r5, r4, [sp, #16]
    err = k_msgq_put_atomic(&gcloud_msgq, &cmd, K_FOREVER);
   156f0:	f01d fadb 	bl	32caa <k_msgq_put_atomic>
    return err;
   156f4:	e7ea      	b.n	156cc <gcloud_publish+0x30>
   156f6:	bf00      	nop
   156f8:	20027623 	.word	0x20027623
   156fc:	00039f60 	.word	0x00039f60
   15700:	00039fa0 	.word	0x00039fa0
   15704:	0003bd69 	.word	0x0003bd69
   15708:	0003bda1 	.word	0x0003bda1
   1570c:	200207a0 	.word	0x200207a0

00015710 <mqtt_event_handler>:

static void mqtt_event_handler(struct mqtt_client *client,
                const struct mqtt_evt *evt)
{
   15710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int err;
    LOG_INF("MQTT event: %d", evt->type);
   15714:	2303      	movs	r3, #3
{
   15716:	4680      	mov	r8, r0
    LOG_INF("MQTT event: %d", evt->type);
   15718:	f04f 0000 	mov.w	r0, #0
{
   1571c:	460d      	mov	r5, r1
    LOG_INF("MQTT event: %d", evt->type);
   1571e:	f363 0007 	bfi	r0, r3, #0, #8
   15722:	4cb7      	ldr	r4, [pc, #732]	; (15a00 <mqtt_event_handler+0x2f0>)
   15724:	4bb7      	ldr	r3, [pc, #732]	; (15a04 <mqtt_event_handler+0x2f4>)
   15726:	780a      	ldrb	r2, [r1, #0]
   15728:	1ae4      	subs	r4, r4, r3
   1572a:	f3c4 04c9 	ubfx	r4, r4, #3, #10
{
   1572e:	b08a      	sub	sp, #40	; 0x28
    LOG_INF("MQTT event: %d", evt->type);
   15730:	f364 108f 	bfi	r0, r4, #6, #10
   15734:	49b4      	ldr	r1, [pc, #720]	; (15a08 <mqtt_event_handler+0x2f8>)
   15736:	f01e fa5f 	bl	33bf8 <log_string_sync>

    switch (evt->type) {
   1573a:	782b      	ldrb	r3, [r5, #0]
   1573c:	2b08      	cmp	r3, #8
   1573e:	f200 81f5 	bhi.w	15b2c <mqtt_event_handler+0x41c>
   15742:	e8df f013 	tbh	[pc, r3, lsl #1]
   15746:	0009      	.short	0x0009
   15748:	005800e2 	.word	0x005800e2
   1574c:	0130011a 	.word	0x0130011a
   15750:	01af0197 	.word	0x01af0197
   15754:	01db01c3 	.word	0x01db01c3
        /* Response to connack request */
        case MQTT_EVT_CONNACK:
            LOG_DBG("Got CONNACK");
   15758:	2304      	movs	r3, #4
   1575a:	f04f 0000 	mov.w	r0, #0
   1575e:	f363 0007 	bfi	r0, r3, #0, #8
   15762:	f364 108f 	bfi	r0, r4, #6, #10
   15766:	4aa9      	ldr	r2, [pc, #676]	; (15a0c <mqtt_event_handler+0x2fc>)
   15768:	49a9      	ldr	r1, [pc, #676]	; (15a10 <mqtt_event_handler+0x300>)
   1576a:	f01e fa45 	bl	33bf8 <log_string_sync>
            if (evt->result != 0) {
   1576e:	69ed      	ldr	r5, [r5, #28]
   15770:	b1b5      	cbz	r5, 157a0 <mqtt_event_handler+0x90>
                LOG_ERR("MQTT connect failed: [%d] %s", err, strerror(err));
   15772:	2301      	movs	r3, #1
   15774:	f04f 0500 	mov.w	r5, #0
   15778:	f363 0507 	bfi	r5, r3, #0, #8
   1577c:	f364 158f 	bfi	r5, r4, #6, #10
   15780:	2400      	movs	r4, #0
   15782:	4620      	mov	r0, r4
   15784:	f01c fcb6 	bl	320f4 <strerror>
   15788:	4622      	mov	r2, r4
   1578a:	4603      	mov	r3, r0
   1578c:	49a1      	ldr	r1, [pc, #644]	; (15a14 <mqtt_event_handler+0x304>)
   1578e:	4628      	mov	r0, r5
   15790:	f01e fa32 	bl	33bf8 <log_string_sync>
                sys_reboot(0); //TODO: Handle error
   15794:	4620      	mov	r0, r4
   15796:	f004 fb81 	bl	19e9c <sys_reboot>
        
        default:
            LOG_ERR("Unknown mqtt event type");
            break;
    }
}
   1579a:	b00a      	add	sp, #40	; 0x28
   1579c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            connected = true;
   157a0:	2201      	movs	r2, #1
   157a2:	4b9d      	ldr	r3, [pc, #628]	; (15a18 <mqtt_event_handler+0x308>)
   157a4:	701a      	strb	r2, [r3, #0]
            connecting = false;
   157a6:	4b9d      	ldr	r3, [pc, #628]	; (15a1c <mqtt_event_handler+0x30c>)
   157a8:	701d      	strb	r5, [r3, #0]
	z_impl_k_timer_start(timer, duration, period);
   157aa:	4a9d      	ldr	r2, [pc, #628]	; (15a20 <mqtt_event_handler+0x310>)
   157ac:	489d      	ldr	r0, [pc, #628]	; (15a24 <mqtt_event_handler+0x314>)
   157ae:	4611      	mov	r1, r2
   157b0:	f019 fb16 	bl	2ede0 <z_impl_k_timer_start>
            struct gcloud_event cmd = {
   157b4:	2218      	movs	r2, #24
   157b6:	4629      	mov	r1, r5
   157b8:	a802      	add	r0, sp, #8
   157ba:	f023 fc47 	bl	3904c <memset>
   157be:	2307      	movs	r3, #7
            err = k_msgq_put_atomic(&gcloud_msgq, &cmd, K_FOREVER);
   157c0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   157c4:	a902      	add	r1, sp, #8
   157c6:	4898      	ldr	r0, [pc, #608]	; (15a28 <mqtt_event_handler+0x318>)
            struct gcloud_event cmd = {
   157c8:	f88d 3008 	strb.w	r3, [sp, #8]
            err = k_msgq_put_atomic(&gcloud_msgq, &cmd, K_FOREVER);
   157cc:	f01d fa6d 	bl	32caa <k_msgq_put_atomic>
            if (err) {
   157d0:	4606      	mov	r6, r0
   157d2:	2800      	cmp	r0, #0
   157d4:	d0e1      	beq.n	1579a <mqtt_event_handler+0x8a>
                LOG_ERR("k_msgq_put_atomic (subscribe) failed: [%d] %s", err, strerror(err));
   157d6:	2301      	movs	r3, #1
   157d8:	f04f 0500 	mov.w	r5, #0
   157dc:	f363 0507 	bfi	r5, r3, #0, #8
   157e0:	f01c fc88 	bl	320f4 <strerror>
   157e4:	4632      	mov	r2, r6
   157e6:	4603      	mov	r3, r0
   157e8:	4990      	ldr	r1, [pc, #576]	; (15a2c <mqtt_event_handler+0x31c>)
   157ea:	f364 158f 	bfi	r5, r4, #6, #10
                    LOG_ERR("k_msgq_put_atomic (reconnect) [%d] %s", err, strerror(err));
   157ee:	4628      	mov	r0, r5
   157f0:	f01e fa02 	bl	33bf8 <log_string_sync>
   157f4:	e7d1      	b.n	1579a <mqtt_event_handler+0x8a>
            LOG_DBG("MQTT PUBLISH event");
   157f6:	2304      	movs	r3, #4
   157f8:	f04f 0000 	mov.w	r0, #0
   157fc:	f363 0007 	bfi	r0, r3, #0, #8
   15800:	f364 108f 	bfi	r0, r4, #6, #10
   15804:	4a81      	ldr	r2, [pc, #516]	; (15a0c <mqtt_event_handler+0x2fc>)
   15806:	498a      	ldr	r1, [pc, #552]	; (15a30 <mqtt_event_handler+0x320>)
   15808:	f01e f9f6 	bl	33bf8 <log_string_sync>
            if (evt->result != 0) {
   1580c:	69ef      	ldr	r7, [r5, #28]
   1580e:	b17f      	cbz	r7, 15830 <mqtt_event_handler+0x120>
                LOG_ERR("Publish event error: [%d] %s", evt->result, strerror(-evt->result));
   15810:	2301      	movs	r3, #1
   15812:	f04f 0600 	mov.w	r6, #0
   15816:	4278      	negs	r0, r7
   15818:	f363 0607 	bfi	r6, r3, #0, #8
   1581c:	f01c fc6a 	bl	320f4 <strerror>
   15820:	f364 168f 	bfi	r6, r4, #6, #10
   15824:	4603      	mov	r3, r0
   15826:	463a      	mov	r2, r7
   15828:	4982      	ldr	r1, [pc, #520]	; (15a34 <mqtt_event_handler+0x324>)
   1582a:	4630      	mov	r0, r6
   1582c:	f01e f9e4 	bl	33bf8 <log_string_sync>
            if (evt->param.publish.message.topic.qos == MQTT_QOS_1_AT_LEAST_ONCE) {
   15830:	7b2b      	ldrb	r3, [r5, #12]
   15832:	2b01      	cmp	r3, #1
   15834:	d110      	bne.n	15858 <mqtt_event_handler+0x148>
                const struct mqtt_puback_param ack = {
   15836:	8b2b      	ldrh	r3, [r5, #24]
                mqtt_publish_qos1_ack(client, &ack);
   15838:	a902      	add	r1, sp, #8
   1583a:	4640      	mov	r0, r8
                const struct mqtt_puback_param ack = {
   1583c:	f8ad 3008 	strh.w	r3, [sp, #8]
                mqtt_publish_qos1_ack(client, &ack);
   15840:	f022 f878 	bl	37934 <mqtt_publish_qos1_ack>
                LOG_INF("Send acknowledgement");
   15844:	f04f 0000 	mov.w	r0, #0
   15848:	2303      	movs	r3, #3
   1584a:	f363 0007 	bfi	r0, r3, #0, #8
   1584e:	f364 108f 	bfi	r0, r4, #6, #10
   15852:	4979      	ldr	r1, [pc, #484]	; (15a38 <mqtt_event_handler+0x328>)
   15854:	f01e f9d0 	bl	33bf8 <log_string_sync>
            if(evt->param.publish.message.payload.len <= 2) {
   15858:	696b      	ldr	r3, [r5, #20]
                LOG_WRN("Received empty payload");
   1585a:	f04f 0000 	mov.w	r0, #0
            if(evt->param.publish.message.payload.len <= 2) {
   1585e:	2b02      	cmp	r3, #2
   15860:	d808      	bhi.n	15874 <mqtt_event_handler+0x164>
                LOG_WRN("Received empty payload");
   15862:	2302      	movs	r3, #2
   15864:	4975      	ldr	r1, [pc, #468]	; (15a3c <mqtt_event_handler+0x32c>)
   15866:	f363 0007 	bfi	r0, r3, #0, #8
   1586a:	f364 108f 	bfi	r0, r4, #6, #10
            LOG_ERR("Unknown mqtt event type");
   1586e:	f01e f9c3 	bl	33bf8 <log_string_sync>
}
   15872:	e792      	b.n	1579a <mqtt_event_handler+0x8a>
            LOG_DBG("Length of payload: %d", evt->param.publish.message.payload.len);
   15874:	2204      	movs	r2, #4
   15876:	f362 0007 	bfi	r0, r2, #0, #8
   1587a:	f364 108f 	bfi	r0, r4, #6, #10
   1587e:	4a63      	ldr	r2, [pc, #396]	; (15a0c <mqtt_event_handler+0x2fc>)
   15880:	496f      	ldr	r1, [pc, #444]	; (15a40 <mqtt_event_handler+0x330>)
   15882:	f01e f9b9 	bl	33bf8 <log_string_sync>
            LOG_DBG("Topic: %s", log_strdup(evt->param.publish.message.topic.topic.utf8));
   15886:	f04f 0600 	mov.w	r6, #0
   1588a:	2304      	movs	r3, #4
   1588c:	6868      	ldr	r0, [r5, #4]
   1588e:	f363 0607 	bfi	r6, r3, #0, #8
   15892:	f01e f9c3 	bl	33c1c <log_strdup>
   15896:	f364 168f 	bfi	r6, r4, #6, #10
   1589a:	4603      	mov	r3, r0
   1589c:	4a5b      	ldr	r2, [pc, #364]	; (15a0c <mqtt_event_handler+0x2fc>)
   1589e:	4630      	mov	r0, r6
   158a0:	4968      	ldr	r1, [pc, #416]	; (15a44 <mqtt_event_handler+0x334>)
   158a2:	f01e f9a9 	bl	33bf8 <log_string_sync>
            LOG_DBG("QoS: %d", evt->param.publish.message.topic.qos);
   158a6:	2304      	movs	r3, #4
   158a8:	f04f 0000 	mov.w	r0, #0
   158ac:	f363 0007 	bfi	r0, r3, #0, #8
   158b0:	f364 108f 	bfi	r0, r4, #6, #10
   158b4:	7b2b      	ldrb	r3, [r5, #12]
   158b6:	4a55      	ldr	r2, [pc, #340]	; (15a0c <mqtt_event_handler+0x2fc>)
   158b8:	4963      	ldr	r1, [pc, #396]	; (15a48 <mqtt_event_handler+0x338>)
   158ba:	f01e f99d 	bl	33bf8 <log_string_sync>
            LOG_DBG("Message:\n");
   158be:	2304      	movs	r3, #4
   158c0:	f04f 0000 	mov.w	r0, #0
            struct mqtt_evt event = *evt;
   158c4:	462e      	mov	r6, r5
            LOG_DBG("Message:\n");
   158c6:	f363 0007 	bfi	r0, r3, #0, #8
   158ca:	f364 108f 	bfi	r0, r4, #6, #10
   158ce:	4a4f      	ldr	r2, [pc, #316]	; (15a0c <mqtt_event_handler+0x2fc>)
   158d0:	495e      	ldr	r1, [pc, #376]	; (15a4c <mqtt_event_handler+0x33c>)
            struct mqtt_evt event = *evt;
   158d2:	ac02      	add	r4, sp, #8
            LOG_DBG("Message:\n");
   158d4:	f01e f990 	bl	33bf8 <log_string_sync>
            struct mqtt_evt event = *evt;
   158d8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   158da:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   158dc:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
   158e0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            char * str = calloc(evt->param.publish.message.payload.len, sizeof(char) + 1);
   158e4:	2102      	movs	r1, #2
   158e6:	6968      	ldr	r0, [r5, #20]
   158e8:	f01b fc82 	bl	311f0 <calloc>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   158ec:	e9d5 1204 	ldrd	r1, r2, [r5, #16]
   158f0:	4604      	mov	r4, r0
   158f2:	f023 fb71 	bl	38fd8 <memcpy>
            if (received_config_handler != NULL) {
   158f6:	4b56      	ldr	r3, [pc, #344]	; (15a50 <mqtt_event_handler+0x340>)
            event.param.publish.message.payload.data = str;
   158f8:	9406      	str	r4, [sp, #24]
            if (received_config_handler != NULL) {
   158fa:	681b      	ldr	r3, [r3, #0]
   158fc:	b10b      	cbz	r3, 15902 <mqtt_event_handler+0x1f2>
                received_config_handler(&event.param.publish.message);
   158fe:	a803      	add	r0, sp, #12
   15900:	4798      	blx	r3
            free(str);
   15902:	4620      	mov	r0, r4
   15904:	f01b fc96 	bl	31234 <free>
            break;
   15908:	e747      	b.n	1579a <mqtt_event_handler+0x8a>
            LOG_DBG("MQTT client disconnected: [%d] %s", evt->result, strerror(-evt->result));
   1590a:	2304      	movs	r3, #4
   1590c:	f04f 0600 	mov.w	r6, #0
   15910:	69ed      	ldr	r5, [r5, #28]
   15912:	f363 0607 	bfi	r6, r3, #0, #8
   15916:	4268      	negs	r0, r5
   15918:	f01c fbec 	bl	320f4 <strerror>
   1591c:	f364 168f 	bfi	r6, r4, #6, #10
   15920:	9000      	str	r0, [sp, #0]
   15922:	462b      	mov	r3, r5
   15924:	4a39      	ldr	r2, [pc, #228]	; (15a0c <mqtt_event_handler+0x2fc>)
   15926:	494b      	ldr	r1, [pc, #300]	; (15a54 <mqtt_event_handler+0x344>)
   15928:	4630      	mov	r0, r6
   1592a:	f01e f965 	bl	33bf8 <log_string_sync>
	z_impl_k_timer_stop(timer);
   1592e:	484a      	ldr	r0, [pc, #296]	; (15a58 <mqtt_event_handler+0x348>)
   15930:	f023 fab8 	bl	38ea4 <z_impl_k_timer_stop>
   15934:	483b      	ldr	r0, [pc, #236]	; (15a24 <mqtt_event_handler+0x314>)
   15936:	f023 fab5 	bl	38ea4 <z_impl_k_timer_stop>
		arch_syscall_invoke1(*(uintptr_t *)&msgq, K_SYSCALL_K_MSGQ_PURGE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_msgq_purge(msgq);
   1593a:	483b      	ldr	r0, [pc, #236]	; (15a28 <mqtt_event_handler+0x318>)
   1593c:	f016 fe28 	bl	2c590 <z_impl_k_msgq_purge>
            if (connected || connecting) {
   15940:	4b35      	ldr	r3, [pc, #212]	; (15a18 <mqtt_event_handler+0x308>)
   15942:	781b      	ldrb	r3, [r3, #0]
   15944:	b923      	cbnz	r3, 15950 <mqtt_event_handler+0x240>
   15946:	4b35      	ldr	r3, [pc, #212]	; (15a1c <mqtt_event_handler+0x30c>)
   15948:	781b      	ldrb	r3, [r3, #0]
   1594a:	2b00      	cmp	r3, #0
   1594c:	f43f af25 	beq.w	1579a <mqtt_event_handler+0x8a>
                err = gcloud_connect(received_config_handler);
   15950:	4b3f      	ldr	r3, [pc, #252]	; (15a50 <mqtt_event_handler+0x340>)
   15952:	6818      	ldr	r0, [r3, #0]
   15954:	f7ff fe8c 	bl	15670 <gcloud_connect>
                if (err) {
   15958:	4606      	mov	r6, r0
   1595a:	2800      	cmp	r0, #0
   1595c:	f43f af1d 	beq.w	1579a <mqtt_event_handler+0x8a>
                    LOG_ERR("k_msgq_put_atomic (reconnect) [%d] %s", err, strerror(err));
   15960:	2301      	movs	r3, #1
   15962:	f04f 0500 	mov.w	r5, #0
   15966:	f363 0507 	bfi	r5, r3, #0, #8
   1596a:	f01c fbc3 	bl	320f4 <strerror>
   1596e:	f364 158f 	bfi	r5, r4, #6, #10
   15972:	4603      	mov	r3, r0
   15974:	4632      	mov	r2, r6
   15976:	4939      	ldr	r1, [pc, #228]	; (15a5c <mqtt_event_handler+0x34c>)
   15978:	e739      	b.n	157ee <mqtt_event_handler+0xde>
            if (evt->result != 0) {
   1597a:	69ea      	ldr	r2, [r5, #28]
                LOG_ERR("MQTT PUBACK error: %d", evt->result);
   1597c:	f04f 0000 	mov.w	r0, #0
            if (evt->result != 0) {
   15980:	b142      	cbz	r2, 15994 <mqtt_event_handler+0x284>
                LOG_ERR("MQTT PUBACK error: %d", evt->result);
   15982:	2301      	movs	r3, #1
   15984:	4936      	ldr	r1, [pc, #216]	; (15a60 <mqtt_event_handler+0x350>)
   15986:	f363 0007 	bfi	r0, r3, #0, #8
   1598a:	f364 108f 	bfi	r0, r4, #6, #10
                LOG_ERR("MQTT UNSUBACK error: %d", evt->result);
   1598e:	f01e f933 	bl	33bf8 <log_string_sync>
   15992:	e702      	b.n	1579a <mqtt_event_handler+0x8a>
            LOG_DBG("PUBACK packet id: %d\n", evt->param.puback.message_id);
   15994:	2304      	movs	r3, #4
   15996:	f363 0007 	bfi	r0, r3, #0, #8
   1599a:	f364 108f 	bfi	r0, r4, #6, #10
   1599e:	88ab      	ldrh	r3, [r5, #4]
   159a0:	4a1a      	ldr	r2, [pc, #104]	; (15a0c <mqtt_event_handler+0x2fc>)
   159a2:	4930      	ldr	r1, [pc, #192]	; (15a64 <mqtt_event_handler+0x354>)
   159a4:	e724      	b.n	157f0 <mqtt_event_handler+0xe0>
            if (evt->result != 0) {
   159a6:	69ea      	ldr	r2, [r5, #28]
                LOG_ERR("MQTT PUBREC error: %d", evt->result);
   159a8:	f04f 0000 	mov.w	r0, #0
            if (evt->result != 0) {
   159ac:	b132      	cbz	r2, 159bc <mqtt_event_handler+0x2ac>
                LOG_ERR("MQTT PUBREC error: %d", evt->result);
   159ae:	2301      	movs	r3, #1
   159b0:	f363 0007 	bfi	r0, r3, #0, #8
   159b4:	f364 108f 	bfi	r0, r4, #6, #10
   159b8:	492b      	ldr	r1, [pc, #172]	; (15a68 <mqtt_event_handler+0x358>)
   159ba:	e7e8      	b.n	1598e <mqtt_event_handler+0x27e>
            LOG_DBG("PUBREC packet id: %u", evt->param.pubrec.message_id);
   159bc:	2304      	movs	r3, #4
   159be:	f363 0007 	bfi	r0, r3, #0, #8
   159c2:	f364 108f 	bfi	r0, r4, #6, #10
   159c6:	88ab      	ldrh	r3, [r5, #4]
   159c8:	4a10      	ldr	r2, [pc, #64]	; (15a0c <mqtt_event_handler+0x2fc>)
   159ca:	4928      	ldr	r1, [pc, #160]	; (15a6c <mqtt_event_handler+0x35c>)
   159cc:	f01e f914 	bl	33bf8 <log_string_sync>
            const struct mqtt_pubrel_param rel_param = {
   159d0:	88ab      	ldrh	r3, [r5, #4]
            err = mqtt_publish_qos2_release(client, &rel_param);
   159d2:	a902      	add	r1, sp, #8
   159d4:	4640      	mov	r0, r8
            const struct mqtt_pubrel_param rel_param = {
   159d6:	f8ad 3008 	strh.w	r3, [sp, #8]
            err = mqtt_publish_qos2_release(client, &rel_param);
   159da:	f021 ffd2 	bl	37982 <mqtt_publish_qos2_release>
            if (err != 0) {
   159de:	4606      	mov	r6, r0
   159e0:	2800      	cmp	r0, #0
   159e2:	f43f aeda 	beq.w	1579a <mqtt_event_handler+0x8a>
                LOG_ERR("Failed to send MQTT PUBREL: [%d] %s", err, strerror(err));
   159e6:	2301      	movs	r3, #1
   159e8:	f04f 0500 	mov.w	r5, #0
   159ec:	f363 0507 	bfi	r5, r3, #0, #8
   159f0:	f01c fb80 	bl	320f4 <strerror>
   159f4:	f364 158f 	bfi	r5, r4, #6, #10
   159f8:	4603      	mov	r3, r0
   159fa:	4632      	mov	r2, r6
   159fc:	491c      	ldr	r1, [pc, #112]	; (15a70 <mqtt_event_handler+0x360>)
   159fe:	e6f6      	b.n	157ee <mqtt_event_handler+0xde>
   15a00:	00039fa0 	.word	0x00039fa0
   15a04:	00039f60 	.word	0x00039f60
   15a08:	0003c1f6 	.word	0x0003c1f6
   15a0c:	0003bad6 	.word	0x0003bad6
   15a10:	0003c205 	.word	0x0003c205
   15a14:	0003c215 	.word	0x0003c215
   15a18:	20027623 	.word	0x20027623
   15a1c:	20027624 	.word	0x20027624
   15a20:	02932e00 	.word	0x02932e00
   15a24:	20020610 	.word	0x20020610
   15a28:	200207a0 	.word	0x200207a0
   15a2c:	0003c232 	.word	0x0003c232
   15a30:	0003c260 	.word	0x0003c260
   15a34:	0003c277 	.word	0x0003c277
   15a38:	0003c294 	.word	0x0003c294
   15a3c:	0003c2a9 	.word	0x0003c2a9
   15a40:	0003c2c0 	.word	0x0003c2c0
   15a44:	0003c2da 	.word	0x0003c2da
   15a48:	0003c2e8 	.word	0x0003c2e8
   15a4c:	0003c2f4 	.word	0x0003c2f4
   15a50:	20021530 	.word	0x20021530
   15a54:	0003c302 	.word	0x0003c302
   15a58:	200205e4 	.word	0x200205e4
   15a5c:	0003c328 	.word	0x0003c328
   15a60:	0003c34e 	.word	0x0003c34e
   15a64:	0003c364 	.word	0x0003c364
   15a68:	0003c37e 	.word	0x0003c37e
   15a6c:	0003c394 	.word	0x0003c394
   15a70:	0003c3ad 	.word	0x0003c3ad
            LOG_DBG("MQTT PUBREL event");
   15a74:	2304      	movs	r3, #4
   15a76:	f04f 0000 	mov.w	r0, #0
   15a7a:	f363 0007 	bfi	r0, r3, #0, #8
   15a7e:	4a30      	ldr	r2, [pc, #192]	; (15b40 <mqtt_event_handler+0x430>)
   15a80:	f364 108f 	bfi	r0, r4, #6, #10
   15a84:	492f      	ldr	r1, [pc, #188]	; (15b44 <mqtt_event_handler+0x434>)
   15a86:	f01e f8b7 	bl	33bf8 <log_string_sync>
            if (evt->result != 0) {
   15a8a:	69ea      	ldr	r2, [r5, #28]
   15a8c:	2a00      	cmp	r2, #0
   15a8e:	f43f ae84 	beq.w	1579a <mqtt_event_handler+0x8a>
                LOG_ERR("PUBREL error: %d", evt->result);
   15a92:	f04f 0000 	mov.w	r0, #0
   15a96:	2301      	movs	r3, #1
   15a98:	f363 0007 	bfi	r0, r3, #0, #8
   15a9c:	f364 108f 	bfi	r0, r4, #6, #10
   15aa0:	4929      	ldr	r1, [pc, #164]	; (15b48 <mqtt_event_handler+0x438>)
   15aa2:	e774      	b.n	1598e <mqtt_event_handler+0x27e>
            if (evt->result != 0) {
   15aa4:	69ea      	ldr	r2, [r5, #28]
                LOG_ERR("MQTT PUBCOMP error: %d", evt->result);
   15aa6:	f04f 0000 	mov.w	r0, #0
            if (evt->result != 0) {
   15aaa:	b132      	cbz	r2, 15aba <mqtt_event_handler+0x3aa>
                LOG_ERR("MQTT PUBCOMP error: %d", evt->result);
   15aac:	2301      	movs	r3, #1
   15aae:	f363 0007 	bfi	r0, r3, #0, #8
   15ab2:	f364 108f 	bfi	r0, r4, #6, #10
   15ab6:	4925      	ldr	r1, [pc, #148]	; (15b4c <mqtt_event_handler+0x43c>)
   15ab8:	e769      	b.n	1598e <mqtt_event_handler+0x27e>
            LOG_DBG("PUBCOMP packet id: %u", evt->param.pubcomp.message_id);
   15aba:	2304      	movs	r3, #4
   15abc:	f363 0007 	bfi	r0, r3, #0, #8
   15ac0:	f364 108f 	bfi	r0, r4, #6, #10
   15ac4:	88ab      	ldrh	r3, [r5, #4]
   15ac6:	4a1e      	ldr	r2, [pc, #120]	; (15b40 <mqtt_event_handler+0x430>)
   15ac8:	4921      	ldr	r1, [pc, #132]	; (15b50 <mqtt_event_handler+0x440>)
   15aca:	e691      	b.n	157f0 <mqtt_event_handler+0xe0>
            LOG_DBG("Got SUBACK");
   15acc:	2304      	movs	r3, #4
   15ace:	f04f 0000 	mov.w	r0, #0
   15ad2:	f363 0007 	bfi	r0, r3, #0, #8
   15ad6:	4a1a      	ldr	r2, [pc, #104]	; (15b40 <mqtt_event_handler+0x430>)
   15ad8:	f364 108f 	bfi	r0, r4, #6, #10
   15adc:	491d      	ldr	r1, [pc, #116]	; (15b54 <mqtt_event_handler+0x444>)
   15ade:	f01e f88b 	bl	33bf8 <log_string_sync>
            if (evt->result != 0) {
   15ae2:	69ea      	ldr	r2, [r5, #28]
   15ae4:	2a00      	cmp	r2, #0
   15ae6:	f43f ae58 	beq.w	1579a <mqtt_event_handler+0x8a>
                LOG_ERR("MQTT SUBACK error: %d", evt->result);
   15aea:	f04f 0000 	mov.w	r0, #0
   15aee:	2301      	movs	r3, #1
   15af0:	f363 0007 	bfi	r0, r3, #0, #8
   15af4:	f364 108f 	bfi	r0, r4, #6, #10
   15af8:	4917      	ldr	r1, [pc, #92]	; (15b58 <mqtt_event_handler+0x448>)
   15afa:	e748      	b.n	1598e <mqtt_event_handler+0x27e>
            LOG_DBG("MQTT UNSUBACK event");
   15afc:	2304      	movs	r3, #4
   15afe:	f04f 0000 	mov.w	r0, #0
   15b02:	f363 0007 	bfi	r0, r3, #0, #8
   15b06:	4a0e      	ldr	r2, [pc, #56]	; (15b40 <mqtt_event_handler+0x430>)
   15b08:	f364 108f 	bfi	r0, r4, #6, #10
   15b0c:	4913      	ldr	r1, [pc, #76]	; (15b5c <mqtt_event_handler+0x44c>)
   15b0e:	f01e f873 	bl	33bf8 <log_string_sync>
            if (evt->result != 0) {
   15b12:	69ea      	ldr	r2, [r5, #28]
   15b14:	2a00      	cmp	r2, #0
   15b16:	f43f ae40 	beq.w	1579a <mqtt_event_handler+0x8a>
                LOG_ERR("MQTT UNSUBACK error: %d", evt->result);
   15b1a:	f04f 0000 	mov.w	r0, #0
   15b1e:	2301      	movs	r3, #1
   15b20:	f363 0007 	bfi	r0, r3, #0, #8
   15b24:	f364 108f 	bfi	r0, r4, #6, #10
   15b28:	490d      	ldr	r1, [pc, #52]	; (15b60 <mqtt_event_handler+0x450>)
   15b2a:	e730      	b.n	1598e <mqtt_event_handler+0x27e>
            LOG_ERR("Unknown mqtt event type");
   15b2c:	f04f 0000 	mov.w	r0, #0
   15b30:	2301      	movs	r3, #1
   15b32:	f363 0007 	bfi	r0, r3, #0, #8
   15b36:	f364 108f 	bfi	r0, r4, #6, #10
   15b3a:	490a      	ldr	r1, [pc, #40]	; (15b64 <mqtt_event_handler+0x454>)
   15b3c:	e697      	b.n	1586e <mqtt_event_handler+0x15e>
   15b3e:	bf00      	nop
   15b40:	0003bad6 	.word	0x0003bad6
   15b44:	0003c3d1 	.word	0x0003c3d1
   15b48:	0003c3e7 	.word	0x0003c3e7
   15b4c:	0003c3f8 	.word	0x0003c3f8
   15b50:	0003c40f 	.word	0x0003c40f
   15b54:	0003c429 	.word	0x0003c429
   15b58:	0003c438 	.word	0x0003c438
   15b5c:	0003c44e 	.word	0x0003c44e
   15b60:	0003c466 	.word	0x0003c466
   15b64:	0003c47e 	.word	0x0003c47e

00015b68 <gcloud_thread>:

extern void gcloud_thread(void *unused1, void *unused2, void *unused3) 
{
   15b68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bool sent_flag = false;

    struct gcloud_event event;
    struct mqtt_publish_param msg;

    k_timer_init(&input_timer, input_timer_handler, NULL);
   15b6c:	2200      	movs	r2, #0
{
   15b6e:	b0b9      	sub	sp, #228	; 0xe4
    k_timer_init(&input_timer, input_timer_handler, NULL);
   15b70:	49a9      	ldr	r1, [pc, #676]	; (15e18 <gcloud_thread+0x2b0>)
   15b72:	48aa      	ldr	r0, [pc, #680]	; (15e1c <gcloud_thread+0x2b4>)
   15b74:	f023 f98a 	bl	38e8c <k_timer_init>
    k_timer_init(&reconnect_timer, reconnect_timer_handler, NULL);
   15b78:	2200      	movs	r2, #0
   15b7a:	49a9      	ldr	r1, [pc, #676]	; (15e20 <gcloud_thread+0x2b8>)
   15b7c:	48a9      	ldr	r0, [pc, #676]	; (15e24 <gcloud_thread+0x2bc>)
   15b7e:	f023 f985 	bl	38e8c <k_timer_init>
   15b82:	4ca9      	ldr	r4, [pc, #676]	; (15e28 <gcloud_thread+0x2c0>)

            };
            break;
            case SUBSCRIBE:
            if (connected) {
                LOG_INF("Got SUBSCRIBE command");
   15b84:	4ba9      	ldr	r3, [pc, #676]	; (15e2c <gcloud_thread+0x2c4>)
   15b86:	1ae4      	subs	r4, r4, r3
   15b88:	f3c4 04c9 	ubfx	r4, r4, #3, #10
        printk("Google Cloud Thread Running\n");
   15b8c:	48a8      	ldr	r0, [pc, #672]	; (15e30 <gcloud_thread+0x2c8>)
   15b8e:	f01d fd1b 	bl	335c8 <printk>
        k_msgq_get_atomic(&gcloud_msgq, &event, K_FOREVER);
   15b92:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15b96:	a91c      	add	r1, sp, #112	; 0x70
   15b98:	48a6      	ldr	r0, [pc, #664]	; (15e34 <gcloud_thread+0x2cc>)
   15b9a:	f01d f876 	bl	32c8a <k_msgq_get_atomic>
        switch (event.type) {
   15b9e:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   15ba2:	2b07      	cmp	r3, #7
   15ba4:	f200 8387 	bhi.w	162b6 <gcloud_thread+0x74e>
   15ba8:	e8df f013 	tbh	[pc, r3, lsl #1]
   15bac:	01c60008 	.word	0x01c60008
   15bb0:	022f01f8 	.word	0x022f01f8
   15bb4:	02f0027a 	.word	0x02f0027a
   15bb8:	03580303 	.word	0x03580303
    struct addrinfo hints = {
   15bbc:	2501      	movs	r5, #1
                LOG_INF("Got CONNECT command");
   15bbe:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   15bc2:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   15bc6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15bca:	f043 0303 	orr.w	r3, r3, #3
   15bce:	f363 0207 	bfi	r2, r3, #0, #8
   15bd2:	b293      	uxth	r3, r2
   15bd4:	f364 138f 	bfi	r3, r4, #6, #10
   15bd8:	b298      	uxth	r0, r3
   15bda:	4997      	ldr	r1, [pc, #604]	; (15e38 <gcloud_thread+0x2d0>)
   15bdc:	f8ad 3020 	strh.w	r3, [sp, #32]
   15be0:	f01e f80a 	bl	33bf8 <log_string_sync>
                LOG_DBG("Initiating broker");
   15be4:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   15be8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   15bec:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15bf0:	f043 0304 	orr.w	r3, r3, #4
   15bf4:	f363 0207 	bfi	r2, r3, #0, #8
   15bf8:	b293      	uxth	r3, r2
   15bfa:	f364 138f 	bfi	r3, r4, #6, #10
   15bfe:	b298      	uxth	r0, r3
   15c00:	4a8e      	ldr	r2, [pc, #568]	; (15e3c <gcloud_thread+0x2d4>)
   15c02:	498f      	ldr	r1, [pc, #572]	; (15e40 <gcloud_thread+0x2d8>)
   15c04:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
   15c08:	f01d fff6 	bl	33bf8 <log_string_sync>
    struct addrinfo hints = {
   15c0c:	2240      	movs	r2, #64	; 0x40
   15c0e:	2100      	movs	r1, #0
   15c10:	a828      	add	r0, sp, #160	; 0xa0
   15c12:	f023 fa1b 	bl	3904c <memset>

static inline int getaddrinfo(const char *host, const char *service,
			      const struct zsock_addrinfo *hints,
			      struct zsock_addrinfo **res)
{
	return zsock_getaddrinfo(host, service, hints, res);
   15c16:	ab1b      	add	r3, sp, #108	; 0x6c
   15c18:	aa28      	add	r2, sp, #160	; 0xa0
   15c1a:	2100      	movs	r1, #0
   15c1c:	4889      	ldr	r0, [pc, #548]	; (15e44 <gcloud_thread+0x2dc>)
   15c1e:	e9cd 552a 	strd	r5, r5, [sp, #168]	; 0xa8
   15c22:	f01e f866 	bl	33cf2 <zsock_getaddrinfo>
    if (err) {
   15c26:	2800      	cmp	r0, #0
   15c28:	f000 80b8 	beq.w	15d9c <gcloud_thread+0x234>
        LOG_ERR("ERROR: getaddrinfo failed [%d] %s", err, strerror(err));
   15c2c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
   15c30:	f8bd 2008 	ldrh.w	r2, [sp, #8]
   15c34:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15c38:	432b      	orrs	r3, r5
   15c3a:	f363 0207 	bfi	r2, r3, #0, #8
   15c3e:	b293      	uxth	r3, r2
   15c40:	f364 138f 	bfi	r3, r4, #6, #10
   15c44:	f8ad 3008 	strh.w	r3, [sp, #8]
   15c48:	9019      	str	r0, [sp, #100]	; 0x64
   15c4a:	f01c fa53 	bl	320f4 <strerror>
   15c4e:	9a19      	ldr	r2, [sp, #100]	; 0x64
   15c50:	4603      	mov	r3, r0
   15c52:	497d      	ldr	r1, [pc, #500]	; (15e48 <gcloud_thread+0x2e0>)
   15c54:	f8bd 0008 	ldrh.w	r0, [sp, #8]
   15c58:	f01d ffce 	bl	33bf8 <log_string_sync>
                LOG_DBG("Making JWT");
   15c5c:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   15c60:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   15c64:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15c68:	f043 0304 	orr.w	r3, r3, #4
   15c6c:	f363 0207 	bfi	r2, r3, #0, #8
   15c70:	b293      	uxth	r3, r2
   15c72:	f364 138f 	bfi	r3, r4, #6, #10
   15c76:	4a71      	ldr	r2, [pc, #452]	; (15e3c <gcloud_thread+0x2d4>)
   15c78:	4974      	ldr	r1, [pc, #464]	; (15e4c <gcloud_thread+0x2e4>)
   15c7a:	b298      	uxth	r0, r3
   15c7c:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
   15c80:	f01d ffba 	bl	33bf8 <log_string_sync>
                make_jwt(jwt_buffer, JWT_BUFFER_SIZE);
   15c84:	f7ff fc02 	bl	1548c <make_jwt.constprop.0>
                LOG_DBG("Initiating client");
   15c88:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   15c8c:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   15c90:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15c94:	f043 0304 	orr.w	r3, r3, #4
   15c98:	f363 0207 	bfi	r2, r3, #0, #8
   15c9c:	b293      	uxth	r3, r2
   15c9e:	f364 138f 	bfi	r3, r4, #6, #10
    mqtt_client_init(&client);
   15ca2:	4d6b      	ldr	r5, [pc, #428]	; (15e50 <gcloud_thread+0x2e8>)
                LOG_DBG("Initiating client");
   15ca4:	4a65      	ldr	r2, [pc, #404]	; (15e3c <gcloud_thread+0x2d4>)
   15ca6:	b298      	uxth	r0, r3
   15ca8:	496a      	ldr	r1, [pc, #424]	; (15e54 <gcloud_thread+0x2ec>)
   15caa:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
   15cae:	f01d ffa3 	bl	33bf8 <log_string_sync>
    mqtt_client_init(&client);
   15cb2:	4628      	mov	r0, r5
   15cb4:	f021 fd9c 	bl	377f0 <mqtt_client_init>
    int err = make_jwt(jwt_buffer, JWT_BUFFER_SIZE);
   15cb8:	f7ff fbe8 	bl	1548c <make_jwt.constprop.0>
    if (err != 0) {
   15cbc:	4602      	mov	r2, r0
   15cbe:	2800      	cmp	r0, #0
   15cc0:	f000 80dc 	beq.w	15e7c <gcloud_thread+0x314>
        LOG_ERR("Unable to make jwt: [%d] %s", err, strerror(-err));
   15cc4:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   15cc8:	f8bd 1014 	ldrh.w	r1, [sp, #20]
   15ccc:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15cd0:	f043 0301 	orr.w	r3, r3, #1
   15cd4:	f363 0107 	bfi	r1, r3, #0, #8
   15cd8:	b28b      	uxth	r3, r1
   15cda:	f364 138f 	bfi	r3, r4, #6, #10
   15cde:	4240      	negs	r0, r0
   15ce0:	f8ad 3014 	strh.w	r3, [sp, #20]
   15ce4:	9219      	str	r2, [sp, #100]	; 0x64
   15ce6:	f01c fa05 	bl	320f4 <strerror>
   15cea:	9a19      	ldr	r2, [sp, #100]	; 0x64
   15cec:	4603      	mov	r3, r0
   15cee:	495a      	ldr	r1, [pc, #360]	; (15e58 <gcloud_thread+0x2f0>)
   15cf0:	f8bd 0014 	ldrh.w	r0, [sp, #20]
   15cf4:	f01d ff80 	bl	33bf8 <log_string_sync>
                LOG_DBG("Starting input timer");
   15cf8:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   15cfc:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   15d00:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15d04:	f043 0304 	orr.w	r3, r3, #4
   15d08:	f363 0207 	bfi	r2, r3, #0, #8
   15d0c:	b293      	uxth	r3, r2
   15d0e:	f364 138f 	bfi	r3, r4, #6, #10
   15d12:	4a4a      	ldr	r2, [pc, #296]	; (15e3c <gcloud_thread+0x2d4>)
   15d14:	4951      	ldr	r1, [pc, #324]	; (15e5c <gcloud_thread+0x2f4>)
   15d16:	b298      	uxth	r0, r3
   15d18:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
   15d1c:	f01d ff6c 	bl	33bf8 <log_string_sync>
	z_impl_k_timer_start(timer, duration, period);
   15d20:	f242 7210 	movw	r2, #10000	; 0x2710
   15d24:	483d      	ldr	r0, [pc, #244]	; (15e1c <gcloud_thread+0x2b4>)
   15d26:	4611      	mov	r1, r2
   15d28:	f019 f85a 	bl	2ede0 <z_impl_k_timer_start>
                LOG_DBG("Connecting mqtt");
   15d2c:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   15d30:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
   15d34:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15d38:	f043 0304 	orr.w	r3, r3, #4
   15d3c:	f363 0207 	bfi	r2, r3, #0, #8
   15d40:	b293      	uxth	r3, r2
   15d42:	f364 138f 	bfi	r3, r4, #6, #10
   15d46:	b298      	uxth	r0, r3
   15d48:	4a3c      	ldr	r2, [pc, #240]	; (15e3c <gcloud_thread+0x2d4>)
   15d4a:	4945      	ldr	r1, [pc, #276]	; (15e60 <gcloud_thread+0x2f8>)
   15d4c:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
   15d50:	f01d ff52 	bl	33bf8 <log_string_sync>
                connecting = true;
   15d54:	2201      	movs	r2, #1
   15d56:	4b43      	ldr	r3, [pc, #268]	; (15e64 <gcloud_thread+0x2fc>)
                err = mqtt_connect(&client);
   15d58:	483d      	ldr	r0, [pc, #244]	; (15e50 <gcloud_thread+0x2e8>)
                connecting = true;
   15d5a:	701a      	strb	r2, [r3, #0]
                err = mqtt_connect(&client);
   15d5c:	f021 fd61 	bl	37822 <mqtt_connect>
                if (err) {
   15d60:	4605      	mov	r5, r0
   15d62:	2800      	cmp	r0, #0
   15d64:	f43f af12 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("mqtt_connect failed: [%d] %s", err, strerror(-err));
   15d68:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   15d6c:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
   15d70:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15d74:	f043 0301 	orr.w	r3, r3, #1
   15d78:	f363 0207 	bfi	r2, r3, #0, #8
   15d7c:	b293      	uxth	r3, r2
   15d7e:	f364 138f 	bfi	r3, r4, #6, #10
   15d82:	4240      	negs	r0, r0
   15d84:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
   15d88:	f01c f9b4 	bl	320f4 <strerror>
   15d8c:	462a      	mov	r2, r5
   15d8e:	4603      	mov	r3, r0
   15d90:	4935      	ldr	r1, [pc, #212]	; (15e68 <gcloud_thread+0x300>)
   15d92:	f8bd 0038 	ldrh.w	r0, [sp, #56]	; 0x38
                err = gcloud_subscribe();
                if (err) {
                    LOG_ERR("gcloud_subscribe failed: [%d] %s", err, strerror(-err));
   15d96:	f01d ff2f 	bl	33bf8 <log_string_sync>
   15d9a:	e6f7      	b.n	15b8c <gcloud_thread+0x24>
    addr = result;
   15d9c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    while (addr != NULL) {
   15d9e:	b1fb      	cbz	r3, 15de0 <gcloud_thread+0x278>
        if (addr->ai_addrlen == sizeof(struct sockaddr_in)) {
   15da0:	695a      	ldr	r2, [r3, #20]
   15da2:	2a08      	cmp	r2, #8
   15da4:	d120      	bne.n	15de8 <gcloud_thread+0x280>
            broker4->sin_port = htons(BROKER_PORT);
   15da6:	f24b 3122 	movw	r1, #45858	; 0xb322
                ->sin_addr.s_addr;
   15daa:	699b      	ldr	r3, [r3, #24]
            broker4->sin_addr.s_addr =
   15dac:	4a2f      	ldr	r2, [pc, #188]	; (15e6c <gcloud_thread+0x304>)
                ->sin_addr.s_addr;
   15dae:	685b      	ldr	r3, [r3, #4]
            broker4->sin_port = htons(BROKER_PORT);
   15db0:	8051      	strh	r1, [r2, #2]
            broker4->sin_addr.s_addr =
   15db2:	6053      	str	r3, [r2, #4]
            broker4->sin_family = AF_INET;
   15db4:	8015      	strh	r5, [r2, #0]
            LOG_DBG("IPv4 Address found 0x%08x",
   15db6:	f8bd 200c 	ldrh.w	r2, [sp, #12]
   15dba:	f8bd 100c 	ldrh.w	r1, [sp, #12]
   15dbe:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
   15dc2:	f042 0204 	orr.w	r2, r2, #4
   15dc6:	f362 0107 	bfi	r1, r2, #0, #8
   15dca:	b28a      	uxth	r2, r1
   15dcc:	f364 128f 	bfi	r2, r4, #6, #10
   15dd0:	f8ad 200c 	strh.w	r2, [sp, #12]
   15dd4:	4926      	ldr	r1, [pc, #152]	; (15e70 <gcloud_thread+0x308>)
   15dd6:	4a27      	ldr	r2, [pc, #156]	; (15e74 <gcloud_thread+0x30c>)
   15dd8:	f8bd 000c 	ldrh.w	r0, [sp, #12]
   15ddc:	f01d ff0c 	bl	33bf8 <log_string_sync>
}

static inline void freeaddrinfo(struct zsock_addrinfo *ai)
{
	zsock_freeaddrinfo(ai);
   15de0:	981b      	ldr	r0, [sp, #108]	; 0x6c
   15de2:	f01d ff88 	bl	33cf6 <zsock_freeaddrinfo>
   15de6:	e739      	b.n	15c5c <gcloud_thread+0xf4>
            LOG_ERR("ai_addrlen = %u should be %u or %u",
   15de8:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   15dec:	f8bd 1010 	ldrh.w	r1, [sp, #16]
   15df0:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15df4:	f043 0301 	orr.w	r3, r3, #1
   15df8:	f363 0107 	bfi	r1, r3, #0, #8
   15dfc:	b28b      	uxth	r3, r1
   15dfe:	f364 138f 	bfi	r3, r4, #6, #10
   15e02:	f8ad 3010 	strh.w	r3, [sp, #16]
   15e06:	2318      	movs	r3, #24
   15e08:	491b      	ldr	r1, [pc, #108]	; (15e78 <gcloud_thread+0x310>)
   15e0a:	9300      	str	r3, [sp, #0]
   15e0c:	f8bd 0010 	ldrh.w	r0, [sp, #16]
   15e10:	2308      	movs	r3, #8
   15e12:	f01d fef1 	bl	33bf8 <log_string_sync>
        break;
   15e16:	e7e3      	b.n	15de0 <gcloud_thread+0x278>
   15e18:	0001542d 	.word	0x0001542d
   15e1c:	200205e4 	.word	0x200205e4
   15e20:	00015579 	.word	0x00015579
   15e24:	20020610 	.word	0x20020610
   15e28:	00039fa0 	.word	0x00039fa0
   15e2c:	00039f60 	.word	0x00039f60
   15e30:	0003bdbf 	.word	0x0003bdbf
   15e34:	200207a0 	.word	0x200207a0
   15e38:	0003bddc 	.word	0x0003bddc
   15e3c:	0003bae9 	.word	0x0003bae9
   15e40:	0003bdf0 	.word	0x0003bdf0
   15e44:	0003be06 	.word	0x0003be06
   15e48:	0003be1a 	.word	0x0003be1a
   15e4c:	0003be7d 	.word	0x0003be7d
   15e50:	200214b0 	.word	0x200214b0
   15e54:	0003be8c 	.word	0x0003be8c
   15e58:	0003bea2 	.word	0x0003bea2
   15e5c:	0003bf44 	.word	0x0003bf44
   15e60:	0003bf5d 	.word	0x0003bf5d
   15e64:	20027624 	.word	0x20027624
   15e68:	0003bf71 	.word	0x0003bf71
   15e6c:	20027610 	.word	0x20027610
   15e70:	0003be3c 	.word	0x0003be3c
   15e74:	0003babe 	.word	0x0003babe
   15e78:	0003be5a 	.word	0x0003be5a
    LOG_DBG("JWT:\n%s\n", log_strdup(jwt_buffer));
   15e7c:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   15e80:	f8bd 2018 	ldrh.w	r2, [sp, #24]
   15e84:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15e88:	f043 0304 	orr.w	r3, r3, #4
   15e8c:	f363 0207 	bfi	r2, r3, #0, #8
   15e90:	b293      	uxth	r3, r2
   15e92:	f364 138f 	bfi	r3, r4, #6, #10
   15e96:	48a8      	ldr	r0, [pc, #672]	; (16138 <gcloud_thread+0x5d0>)
   15e98:	f8ad 3018 	strh.w	r3, [sp, #24]
   15e9c:	f01d febe 	bl	33c1c <log_strdup>
   15ea0:	49a6      	ldr	r1, [pc, #664]	; (1613c <gcloud_thread+0x5d4>)
   15ea2:	4603      	mov	r3, r0
   15ea4:	4aa6      	ldr	r2, [pc, #664]	; (16140 <gcloud_thread+0x5d8>)
   15ea6:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   15eaa:	f01d fea5 	bl	33bf8 <log_string_sync>
    LOG_DBG("JWT length: %d\n", strlen(jwt_buffer));
   15eae:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   15eb2:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   15eb6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15eba:	f043 0304 	orr.w	r3, r3, #4
   15ebe:	f363 0207 	bfi	r2, r3, #0, #8
   15ec2:	b293      	uxth	r3, r2
   15ec4:	f364 138f 	bfi	r3, r4, #6, #10
   15ec8:	489b      	ldr	r0, [pc, #620]	; (16138 <gcloud_thread+0x5d0>)
   15eca:	f8ad 301c 	strh.w	r3, [sp, #28]
   15ece:	f7fc f8d7 	bl	12080 <strlen>
   15ed2:	4a9b      	ldr	r2, [pc, #620]	; (16140 <gcloud_thread+0x5d8>)
   15ed4:	4603      	mov	r3, r0
   15ed6:	499b      	ldr	r1, [pc, #620]	; (16144 <gcloud_thread+0x5dc>)
   15ed8:	f8bd 001c 	ldrh.w	r0, [sp, #28]
   15edc:	f01d fe8c 	bl	33bf8 <log_string_sync>
    jwt_token.size = strlen(jwt_buffer);
   15ee0:	4895      	ldr	r0, [pc, #596]	; (16138 <gcloud_thread+0x5d0>)
   15ee2:	f7fc f8cd 	bl	12080 <strlen>
   15ee6:	4b98      	ldr	r3, [pc, #608]	; (16148 <gcloud_thread+0x5e0>)
    client.broker = &mqtt_broker;
   15ee8:	4a98      	ldr	r2, [pc, #608]	; (1614c <gcloud_thread+0x5e4>)
    jwt_token.size = strlen(jwt_buffer);
   15eea:	6058      	str	r0, [r3, #4]
    client.broker = &mqtt_broker;
   15eec:	652a      	str	r2, [r5, #80]	; 0x50
    client.client_id.utf8 = (u8_t *)GCLOUD_ID;
   15eee:	4898      	ldr	r0, [pc, #608]	; (16150 <gcloud_thread+0x5e8>)
    client.evt_cb = mqtt_event_handler;
   15ef0:	4a98      	ldr	r2, [pc, #608]	; (16154 <gcloud_thread+0x5ec>)
    client.client_id.utf8 = (u8_t *)GCLOUD_ID;
   15ef2:	64a8      	str	r0, [r5, #72]	; 0x48
    client.evt_cb = mqtt_event_handler;
   15ef4:	666a      	str	r2, [r5, #100]	; 0x64
    client.client_id.size = strlen(GCLOUD_ID);
   15ef6:	f7fc f8c3 	bl	12080 <strlen>
	client.password = &jwt_token;
   15efa:	4b93      	ldr	r3, [pc, #588]	; (16148 <gcloud_thread+0x5e0>)
    client.client_id.size = strlen(GCLOUD_ID);
   15efc:	64e8      	str	r0, [r5, #76]	; 0x4c
	client.password = &jwt_token;
   15efe:	65ab      	str	r3, [r5, #88]	; 0x58
	client.user_name = &username;
   15f00:	4b95      	ldr	r3, [pc, #596]	; (16158 <gcloud_thread+0x5f0>)
   15f02:	656b      	str	r3, [r5, #84]	; 0x54
    client.protocol_version = MQTT_VERSION_3_1_1;
   15f04:	2304      	movs	r3, #4
   15f06:	f885 307a 	strb.w	r3, [r5, #122]	; 0x7a
	client.rx_buf = rx_buffer;
   15f0a:	4b94      	ldr	r3, [pc, #592]	; (1615c <gcloud_thread+0x5f4>)
   15f0c:	66ab      	str	r3, [r5, #104]	; 0x68
    client.rx_buf_size = 512;
   15f0e:	f44f 7300 	mov.w	r3, #512	; 0x200
   15f12:	66eb      	str	r3, [r5, #108]	; 0x6c
	client.tx_buf = tx_buffer;
   15f14:	4b92      	ldr	r3, [pc, #584]	; (16160 <gcloud_thread+0x5f8>)
   15f16:	672b      	str	r3, [r5, #112]	; 0x70
    client.tx_buf_size = 1024;
   15f18:	f44f 6380 	mov.w	r3, #1024	; 0x400
   15f1c:	676b      	str	r3, [r5, #116]	; 0x74
	client.transport.type = MQTT_TRANSPORT_SECURE;
   15f1e:	2301      	movs	r3, #1
   15f20:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    client.clean_session = 1;
   15f24:	f895 307c 	ldrb.w	r3, [r5, #124]	; 0x7c
   15f28:	f043 0302 	orr.w	r3, r3, #2
   15f2c:	f885 307c 	strb.w	r3, [r5, #124]	; 0x7c
    client.keepalive = 120;
   15f30:	2378      	movs	r3, #120	; 0x78
   15f32:	f8a5 3078 	strh.w	r3, [r5, #120]	; 0x78
    return 0;
   15f36:	e6df      	b.n	15cf8 <gcloud_thread+0x190>
                LOG_INF("Got INPUT_TIMEOUT command");
   15f38:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
   15f3c:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
   15f40:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15f44:	f043 0303 	orr.w	r3, r3, #3
   15f48:	f363 0207 	bfi	r2, r3, #0, #8
   15f4c:	b293      	uxth	r3, r2
   15f4e:	f364 138f 	bfi	r3, r4, #6, #10
   15f52:	b298      	uxth	r0, r3
   15f54:	4983      	ldr	r1, [pc, #524]	; (16164 <gcloud_thread+0x5fc>)
   15f56:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
   15f5a:	f01d fe4d 	bl	33bf8 <log_string_sync>
                err = mqtt_input(&client);
   15f5e:	4882      	ldr	r0, [pc, #520]	; (16168 <gcloud_thread+0x600>)
   15f60:	f021 fdd8 	bl	37b14 <mqtt_input>
                if (err) {
   15f64:	4605      	mov	r5, r0
   15f66:	2800      	cmp	r0, #0
   15f68:	f43f ae10 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("mqtt_input failed: [%d] %s", err, strerror(-err));
   15f6c:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   15f70:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   15f74:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15f78:	f043 0301 	orr.w	r3, r3, #1
   15f7c:	f363 0207 	bfi	r2, r3, #0, #8
   15f80:	b293      	uxth	r3, r2
   15f82:	f364 138f 	bfi	r3, r4, #6, #10
   15f86:	4240      	negs	r0, r0
   15f88:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
   15f8c:	f01c f8b2 	bl	320f4 <strerror>
   15f90:	462a      	mov	r2, r5
   15f92:	4603      	mov	r3, r0
   15f94:	4975      	ldr	r1, [pc, #468]	; (1616c <gcloud_thread+0x604>)
   15f96:	f8bd 0040 	ldrh.w	r0, [sp, #64]	; 0x40
   15f9a:	e6fc      	b.n	15d96 <gcloud_thread+0x22e>
            if (connected) {
   15f9c:	4b74      	ldr	r3, [pc, #464]	; (16170 <gcloud_thread+0x608>)
   15f9e:	781b      	ldrb	r3, [r3, #0]
   15fa0:	2b00      	cmp	r3, #0
   15fa2:	f43f adf3 	beq.w	15b8c <gcloud_thread+0x24>
                LOG_INF("Got LIVE_TIMEOUT command");
   15fa6:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
   15faa:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
   15fae:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15fb2:	f043 0303 	orr.w	r3, r3, #3
   15fb6:	f363 0207 	bfi	r2, r3, #0, #8
   15fba:	b293      	uxth	r3, r2
   15fbc:	f364 138f 	bfi	r3, r4, #6, #10
   15fc0:	b298      	uxth	r0, r3
   15fc2:	496c      	ldr	r1, [pc, #432]	; (16174 <gcloud_thread+0x60c>)
   15fc4:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
   15fc8:	f01d fe16 	bl	33bf8 <log_string_sync>
                err = mqtt_live(&client);
   15fcc:	4866      	ldr	r0, [pc, #408]	; (16168 <gcloud_thread+0x600>)
   15fce:	f021 fd7a 	bl	37ac6 <mqtt_live>
                if (err) {
   15fd2:	4605      	mov	r5, r0
   15fd4:	2800      	cmp	r0, #0
   15fd6:	f43f add9 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("mqtt_live failed: [%d] %s", err, strerror(-err));
   15fda:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   15fde:	f8bd 2048 	ldrh.w	r2, [sp, #72]	; 0x48
   15fe2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   15fe6:	f043 0301 	orr.w	r3, r3, #1
   15fea:	f363 0207 	bfi	r2, r3, #0, #8
   15fee:	b293      	uxth	r3, r2
   15ff0:	f364 138f 	bfi	r3, r4, #6, #10
   15ff4:	4240      	negs	r0, r0
   15ff6:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   15ffa:	f01c f87b 	bl	320f4 <strerror>
   15ffe:	462a      	mov	r2, r5
   16000:	4603      	mov	r3, r0
   16002:	495d      	ldr	r1, [pc, #372]	; (16178 <gcloud_thread+0x610>)
   16004:	f8bd 0048 	ldrh.w	r0, [sp, #72]	; 0x48
   16008:	e6c5      	b.n	15d96 <gcloud_thread+0x22e>
            if (connected) {
   1600a:	4b59      	ldr	r3, [pc, #356]	; (16170 <gcloud_thread+0x608>)
   1600c:	781b      	ldrb	r3, [r3, #0]
   1600e:	2b00      	cmp	r3, #0
   16010:	f43f adbc 	beq.w	15b8c <gcloud_thread+0x24>
                LOG_INF("Got PUBLISH_STATE command");
   16014:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
   16018:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   1601c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   16020:	f043 0303 	orr.w	r3, r3, #3
   16024:	f363 0207 	bfi	r2, r3, #0, #8
   16028:	b293      	uxth	r3, r2
   1602a:	f364 138f 	bfi	r3, r4, #6, #10
   1602e:	4953      	ldr	r1, [pc, #332]	; (1617c <gcloud_thread+0x614>)
   16030:	b298      	uxth	r0, r3
   16032:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
                msg.message = event.param.publish_state;
   16036:	ad22      	add	r5, sp, #136	; 0x88
                LOG_INF("Got PUBLISH_STATE command");
   16038:	f01d fdde 	bl	33bf8 <log_string_sync>
                msg.message = event.param.publish_state;
   1603c:	f10d 0c74 	add.w	ip, sp, #116	; 0x74
   16040:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   16044:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   16046:	f8dc 3000 	ldr.w	r3, [ip]
   1604a:	602b      	str	r3, [r5, #0]
                msg.message_id = sys_rand32_get();
   1604c:	f008 fe64 	bl	1ed18 <sys_rand32_get>
                msg.dup_flag = 0;
   16050:	f89d 309e 	ldrb.w	r3, [sp, #158]	; 0x9e
                msg.message_id = sys_rand32_get();
   16054:	f8ad 009c 	strh.w	r0, [sp, #156]	; 0x9c
                msg.dup_flag = 0;
   16058:	f023 0303 	bic.w	r3, r3, #3
                err = mqtt_publish(&client, &msg);
   1605c:	a922      	add	r1, sp, #136	; 0x88
   1605e:	4842      	ldr	r0, [pc, #264]	; (16168 <gcloud_thread+0x600>)
                msg.dup_flag = 0;
   16060:	f88d 309e 	strb.w	r3, [sp, #158]	; 0x9e
                err = mqtt_publish(&client, &msg);
   16064:	f021 fc21 	bl	378aa <mqtt_publish>
                if (err) {
   16068:	4605      	mov	r5, r0
   1606a:	2800      	cmp	r0, #0
   1606c:	f43f ad8e 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("mqtt_publish (state) failed: [%d] %s", err, strerror(-err));
   16070:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   16074:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
   16078:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   1607c:	f043 0301 	orr.w	r3, r3, #1
   16080:	f363 0207 	bfi	r2, r3, #0, #8
   16084:	b293      	uxth	r3, r2
   16086:	f364 138f 	bfi	r3, r4, #6, #10
   1608a:	4240      	negs	r0, r0
   1608c:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
   16090:	f01c f830 	bl	320f4 <strerror>
   16094:	462a      	mov	r2, r5
   16096:	4603      	mov	r3, r0
   16098:	4939      	ldr	r1, [pc, #228]	; (16180 <gcloud_thread+0x618>)
   1609a:	f8bd 0050 	ldrh.w	r0, [sp, #80]	; 0x50
   1609e:	e67a      	b.n	15d96 <gcloud_thread+0x22e>
            if (connected) {
   160a0:	4b33      	ldr	r3, [pc, #204]	; (16170 <gcloud_thread+0x608>)
   160a2:	781b      	ldrb	r3, [r3, #0]
   160a4:	2b00      	cmp	r3, #0
   160a6:	f43f ad71 	beq.w	15b8c <gcloud_thread+0x24>
                LOG_INF("Got PUBLISH command");
   160aa:	f8bd 3054 	ldrh.w	r3, [sp, #84]	; 0x54
   160ae:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
   160b2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   160b6:	f043 0303 	orr.w	r3, r3, #3
   160ba:	f363 0207 	bfi	r2, r3, #0, #8
   160be:	b293      	uxth	r3, r2
   160c0:	f364 138f 	bfi	r3, r4, #6, #10
   160c4:	492f      	ldr	r1, [pc, #188]	; (16184 <gcloud_thread+0x61c>)
   160c6:	b298      	uxth	r0, r3
   160c8:	f8ad 3054 	strh.w	r3, [sp, #84]	; 0x54
                msg.message = event.param.publish;
   160cc:	ad22      	add	r5, sp, #136	; 0x88
                LOG_INF("Got PUBLISH command");
   160ce:	f01d fd93 	bl	33bf8 <log_string_sync>
                msg.message = event.param.publish;
   160d2:	f10d 0c74 	add.w	ip, sp, #116	; 0x74
   160d6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   160da:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   160dc:	f8dc 3000 	ldr.w	r3, [ip]
   160e0:	602b      	str	r3, [r5, #0]
                msg.message_id = sys_rand32_get();
   160e2:	f008 fe19 	bl	1ed18 <sys_rand32_get>
                msg.dup_flag = 0;
   160e6:	f89d 309e 	ldrb.w	r3, [sp, #158]	; 0x9e
                msg.message_id = sys_rand32_get();
   160ea:	f8ad 009c 	strh.w	r0, [sp, #156]	; 0x9c
                msg.dup_flag = 0;
   160ee:	f023 0303 	bic.w	r3, r3, #3
                err = mqtt_publish(&client, &msg);
   160f2:	a922      	add	r1, sp, #136	; 0x88
   160f4:	481c      	ldr	r0, [pc, #112]	; (16168 <gcloud_thread+0x600>)
                msg.dup_flag = 0;
   160f6:	f88d 309e 	strb.w	r3, [sp, #158]	; 0x9e
                err = mqtt_publish(&client, &msg);
   160fa:	f021 fbd6 	bl	378aa <mqtt_publish>
                if (err) {
   160fe:	4605      	mov	r5, r0
   16100:	2800      	cmp	r0, #0
   16102:	f43f ad43 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("mqtt_publish failed: [%d] %s", err, strerror(-err));
   16106:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
   1610a:	f8bd 2058 	ldrh.w	r2, [sp, #88]	; 0x58
   1610e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   16112:	f043 0301 	orr.w	r3, r3, #1
   16116:	f363 0207 	bfi	r2, r3, #0, #8
   1611a:	b293      	uxth	r3, r2
   1611c:	f364 138f 	bfi	r3, r4, #6, #10
   16120:	4240      	negs	r0, r0
   16122:	f8ad 3058 	strh.w	r3, [sp, #88]	; 0x58
   16126:	f01b ffe5 	bl	320f4 <strerror>
   1612a:	462a      	mov	r2, r5
   1612c:	4603      	mov	r3, r0
   1612e:	4916      	ldr	r1, [pc, #88]	; (16188 <gcloud_thread+0x620>)
   16130:	f8bd 0058 	ldrh.w	r0, [sp, #88]	; 0x58
   16134:	e62f      	b.n	15d96 <gcloud_thread+0x22e>
   16136:	bf00      	nop
   16138:	20027625 	.word	0x20027625
   1613c:	0003bebe 	.word	0x0003bebe
   16140:	0003baca 	.word	0x0003baca
   16144:	0003becb 	.word	0x0003becb
   16148:	2002006c 	.word	0x2002006c
   1614c:	20027610 	.word	0x20027610
   16150:	0003bedf 	.word	0x0003bedf
   16154:	00015711 	.word	0x00015711
   16158:	20020074 	.word	0x20020074
   1615c:	20027725 	.word	0x20027725
   16160:	20027b25 	.word	0x20027b25
   16164:	0003bf8e 	.word	0x0003bf8e
   16168:	200214b0 	.word	0x200214b0
   1616c:	0003bfa8 	.word	0x0003bfa8
   16170:	20027623 	.word	0x20027623
   16174:	0003bfc3 	.word	0x0003bfc3
   16178:	0003bfdc 	.word	0x0003bfdc
   1617c:	0003bff6 	.word	0x0003bff6
   16180:	0003c010 	.word	0x0003c010
   16184:	0003c035 	.word	0x0003c035
   16188:	0003c049 	.word	0x0003c049
                LOG_INF("Got RECONNECT_TIMEOUT command");
   1618c:	f8bd 305c 	ldrh.w	r3, [sp, #92]	; 0x5c
   16190:	f8bd 205c 	ldrh.w	r2, [sp, #92]	; 0x5c
   16194:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   16198:	f043 0303 	orr.w	r3, r3, #3
   1619c:	f363 0207 	bfi	r2, r3, #0, #8
   161a0:	b293      	uxth	r3, r2
   161a2:	f364 138f 	bfi	r3, r4, #6, #10
   161a6:	494e      	ldr	r1, [pc, #312]	; (162e0 <gcloud_thread+0x778>)
   161a8:	b298      	uxth	r0, r3
   161aa:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
   161ae:	f01d fd23 	bl	33bf8 <log_string_sync>
                LOG_INF("Got DISCONNECT command");
   161b2:	f026 033f 	bic.w	r3, r6, #63	; 0x3f
   161b6:	f043 0303 	orr.w	r3, r3, #3
   161ba:	f363 0607 	bfi	r6, r3, #0, #8
   161be:	f364 168f 	bfi	r6, r4, #6, #10
   161c2:	4948      	ldr	r1, [pc, #288]	; (162e4 <gcloud_thread+0x77c>)
   161c4:	4630      	mov	r0, r6
   161c6:	f01d fd17 	bl	33bf8 <log_string_sync>
            if (connected) {
   161ca:	4b47      	ldr	r3, [pc, #284]	; (162e8 <gcloud_thread+0x780>)
   161cc:	781b      	ldrb	r3, [r3, #0]
   161ce:	2b00      	cmp	r3, #0
   161d0:	f43f acdc 	beq.w	15b8c <gcloud_thread+0x24>
	z_impl_k_timer_stop(timer);
   161d4:	4845      	ldr	r0, [pc, #276]	; (162ec <gcloud_thread+0x784>)
   161d6:	f022 fe65 	bl	38ea4 <z_impl_k_timer_stop>
                LOG_DBG("Disconnecting mqtt");
   161da:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   161de:	f043 0304 	orr.w	r3, r3, #4
   161e2:	f363 0707 	bfi	r7, r3, #0, #8
   161e6:	f364 178f 	bfi	r7, r4, #6, #10
   161ea:	4a41      	ldr	r2, [pc, #260]	; (162f0 <gcloud_thread+0x788>)
   161ec:	4941      	ldr	r1, [pc, #260]	; (162f4 <gcloud_thread+0x78c>)
   161ee:	4638      	mov	r0, r7
   161f0:	f01d fd02 	bl	33bf8 <log_string_sync>
                err = mqtt_disconnect(&client);
   161f4:	4840      	ldr	r0, [pc, #256]	; (162f8 <gcloud_thread+0x790>)
   161f6:	f021 fbeb 	bl	379d0 <mqtt_disconnect>
                if (err) {
   161fa:	4605      	mov	r5, r0
   161fc:	b180      	cbz	r0, 16220 <gcloud_thread+0x6b8>
                    LOG_ERR("mqtt_disconnect (reconnect) failed: [%d] %s", err, strerror(-err));
   161fe:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   16202:	f043 0301 	orr.w	r3, r3, #1
   16206:	4240      	negs	r0, r0
   16208:	f363 0807 	bfi	r8, r3, #0, #8
   1620c:	f01b ff72 	bl	320f4 <strerror>
   16210:	f364 188f 	bfi	r8, r4, #6, #10
   16214:	4603      	mov	r3, r0
   16216:	462a      	mov	r2, r5
   16218:	4938      	ldr	r1, [pc, #224]	; (162fc <gcloud_thread+0x794>)
   1621a:	4640      	mov	r0, r8
   1621c:	f01d fcec 	bl	33bf8 <log_string_sync>
                connected = false;
   16220:	2500      	movs	r5, #0
	z_impl_k_msgq_purge(msgq);
   16222:	4837      	ldr	r0, [pc, #220]	; (16300 <gcloud_thread+0x798>)
   16224:	f016 f9b4 	bl	2c590 <z_impl_k_msgq_purge>
   16228:	4b2f      	ldr	r3, [pc, #188]	; (162e8 <gcloud_thread+0x780>)
   1622a:	701d      	strb	r5, [r3, #0]
                if (event.type == DISCONNECT) {
   1622c:	f89d 3070 	ldrb.w	r3, [sp, #112]	; 0x70
   16230:	2b06      	cmp	r3, #6
   16232:	d10f      	bne.n	16254 <gcloud_thread+0x6ec>
                    LOG_DBG("Not setting connecting flag");
   16234:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   16238:	f043 0304 	orr.w	r3, r3, #4
   1623c:	f363 0907 	bfi	r9, r3, #0, #8
   16240:	f364 198f 	bfi	r9, r4, #6, #10
   16244:	4a2a      	ldr	r2, [pc, #168]	; (162f0 <gcloud_thread+0x788>)
   16246:	492f      	ldr	r1, [pc, #188]	; (16304 <gcloud_thread+0x79c>)
   16248:	4648      	mov	r0, r9
   1624a:	f01d fcd5 	bl	33bf8 <log_string_sync>
                    connecting = false;
   1624e:	4b2e      	ldr	r3, [pc, #184]	; (16308 <gcloud_thread+0x7a0>)
   16250:	701d      	strb	r5, [r3, #0]
   16252:	e49b      	b.n	15b8c <gcloud_thread+0x24>
                    connecting = true;
   16254:	2201      	movs	r2, #1
   16256:	4b2c      	ldr	r3, [pc, #176]	; (16308 <gcloud_thread+0x7a0>)
   16258:	701a      	strb	r2, [r3, #0]
   1625a:	e497      	b.n	15b8c <gcloud_thread+0x24>
            if (connected) {
   1625c:	4b22      	ldr	r3, [pc, #136]	; (162e8 <gcloud_thread+0x780>)
   1625e:	781b      	ldrb	r3, [r3, #0]
   16260:	2b00      	cmp	r3, #0
   16262:	f43f ac93 	beq.w	15b8c <gcloud_thread+0x24>
                LOG_INF("Got SUBSCRIBE command");
   16266:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   1626a:	f043 0303 	orr.w	r3, r3, #3
   1626e:	f363 0a07 	bfi	sl, r3, #0, #8
   16272:	f364 1a8f 	bfi	sl, r4, #6, #10
   16276:	4925      	ldr	r1, [pc, #148]	; (1630c <gcloud_thread+0x7a4>)
   16278:	4650      	mov	r0, sl
   1627a:	f01d fcbd 	bl	33bf8 <log_string_sync>
    const struct mqtt_subscription_list subscriptions = {
   1627e:	4b24      	ldr	r3, [pc, #144]	; (16310 <gcloud_thread+0x7a8>)
    return mqtt_subscribe(&client, &subscriptions);
   16280:	a928      	add	r1, sp, #160	; 0xa0
    const struct mqtt_subscription_list subscriptions = {
   16282:	9328      	str	r3, [sp, #160]	; 0xa0
   16284:	4b23      	ldr	r3, [pc, #140]	; (16314 <gcloud_thread+0x7ac>)
    return mqtt_subscribe(&client, &subscriptions);
   16286:	481c      	ldr	r0, [pc, #112]	; (162f8 <gcloud_thread+0x790>)
    const struct mqtt_subscription_list subscriptions = {
   16288:	9329      	str	r3, [sp, #164]	; 0xa4
    return mqtt_subscribe(&client, &subscriptions);
   1628a:	f021 fbca 	bl	37a22 <mqtt_subscribe>
                if (err) {
   1628e:	4605      	mov	r5, r0
   16290:	2800      	cmp	r0, #0
   16292:	f43f ac7b 	beq.w	15b8c <gcloud_thread+0x24>
                    LOG_ERR("gcloud_subscribe failed: [%d] %s", err, strerror(-err));
   16296:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
   1629a:	f043 0301 	orr.w	r3, r3, #1
   1629e:	4240      	negs	r0, r0
   162a0:	f363 0b07 	bfi	fp, r3, #0, #8
   162a4:	f01b ff26 	bl	320f4 <strerror>
   162a8:	f364 1b8f 	bfi	fp, r4, #6, #10
   162ac:	4603      	mov	r3, r0
   162ae:	462a      	mov	r2, r5
   162b0:	4919      	ldr	r1, [pc, #100]	; (16318 <gcloud_thread+0x7b0>)
   162b2:	4658      	mov	r0, fp
   162b4:	e56f      	b.n	15d96 <gcloud_thread+0x22e>
                    // TODO: Find a way to report this error to the application.
                }
            };
            break;
            default:
                LOG_ERR("Unknown event type received");
   162b6:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
   162ba:	f8bd 2060 	ldrh.w	r2, [sp, #96]	; 0x60
   162be:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   162c2:	f043 0301 	orr.w	r3, r3, #1
   162c6:	f363 0207 	bfi	r2, r3, #0, #8
   162ca:	b293      	uxth	r3, r2
   162cc:	f364 138f 	bfi	r3, r4, #6, #10
   162d0:	4912      	ldr	r1, [pc, #72]	; (1631c <gcloud_thread+0x7b4>)
   162d2:	b298      	uxth	r0, r3
   162d4:	f8ad 3060 	strh.w	r3, [sp, #96]	; 0x60
   162d8:	f01d fc8e 	bl	33bf8 <log_string_sync>
   162dc:	e456      	b.n	15b8c <gcloud_thread+0x24>
   162de:	bf00      	nop
   162e0:	0003c066 	.word	0x0003c066
   162e4:	0003c084 	.word	0x0003c084
   162e8:	20027623 	.word	0x20027623
   162ec:	20020610 	.word	0x20020610
   162f0:	0003bae9 	.word	0x0003bae9
   162f4:	0003c09b 	.word	0x0003c09b
   162f8:	200214b0 	.word	0x200214b0
   162fc:	0003c0b2 	.word	0x0003c0b2
   16300:	200207a0 	.word	0x200207a0
   16304:	0003c0de 	.word	0x0003c0de
   16308:	20027624 	.word	0x20027624
   1630c:	0003c0fe 	.word	0x0003c0fe
   16310:	20020060 	.word	0x20020060
   16314:	002a0001 	.word	0x002a0001
   16318:	0003c114 	.word	0x0003c114
   1631c:	0003c135 	.word	0x0003c135

00016320 <parse_string>:

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = {0x00, 0x00, 0xC0, 0xE0,
					       0xF0, 0xF8, 0xFC};
static const char *parse_string(cJSON *item, const char *str)
{
   16320:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const char *ptr = str + 1;
	char *ptr2;
	char *out;
	int len = 0;
	unsigned uc, uc2;
	if (*str != '\"') {
   16324:	780b      	ldrb	r3, [r1, #0]
{
   16326:	4606      	mov	r6, r0
	if (*str != '\"') {
   16328:	2b22      	cmp	r3, #34	; 0x22
   1632a:	d12b      	bne.n	16384 <parse_string+0x64>
	const char *ptr = str + 1;
   1632c:	f101 0901 	add.w	r9, r1, #1
   16330:	464b      	mov	r3, r9
   16332:	2400      	movs	r4, #0
		ep = str;
		return 0;
	} /* not a string! */

	while (*ptr != '\"' && *ptr && ++len)
   16334:	781a      	ldrb	r2, [r3, #0]
   16336:	4620      	mov	r0, r4
   16338:	2a22      	cmp	r2, #34	; 0x22
   1633a:	d003      	beq.n	16344 <parse_string+0x24>
   1633c:	b112      	cbz	r2, 16344 <parse_string+0x24>
   1633e:	1c60      	adds	r0, r4, #1
   16340:	d126      	bne.n	16390 <parse_string+0x70>
   16342:	2000      	movs	r0, #0
		if (*ptr++ == '\\')
			ptr++; /* Skip escaped quotes. */

	out = (char *)cJSON_malloc(
   16344:	4b5b      	ldr	r3, [pc, #364]	; (164b4 <parse_string+0x194>)
   16346:	3001      	adds	r0, #1
   16348:	681b      	ldr	r3, [r3, #0]
   1634a:	4798      	blx	r3
		len +
		1); /* This is how long we need for the string, roughly. */
	if (!out)
   1634c:	4607      	mov	r7, r0
   1634e:	b1e0      	cbz	r0, 1638a <parse_string+0x6a>
   16350:	4604      	mov	r4, r0
				break;
			case 'f':
				*ptr2++ = '\f';
				break;
			case 'n':
				*ptr2++ = '\n';
   16352:	f04f 0a0a 	mov.w	sl, #10
				break;
			case 'r':
				*ptr2++ = '\r';
				break;
			case 't':
				*ptr2++ = '\t';
   16356:	f04f 0809 	mov.w	r8, #9
				*ptr2++ = '\r';
   1635a:	f04f 0b0d 	mov.w	fp, #13
	while (*ptr != '\"' && *ptr) {
   1635e:	f899 3000 	ldrb.w	r3, [r9]
   16362:	2b22      	cmp	r3, #34	; 0x22
   16364:	d000      	beq.n	16368 <parse_string+0x48>
   16366:	b9cb      	cbnz	r3, 1639c <parse_string+0x7c>
				break;
			}
			ptr++;
		}
	}
	*ptr2 = 0;
   16368:	2300      	movs	r3, #0
   1636a:	7023      	strb	r3, [r4, #0]
	if (*ptr == '\"')
   1636c:	f899 3000 	ldrb.w	r3, [r9]
		ptr++;
	item->valuestring = out;
   16370:	6137      	str	r7, [r6, #16]
	if (*ptr == '\"')
   16372:	2b22      	cmp	r3, #34	; 0x22
	item->type = cJSON_String;
   16374:	f04f 0304 	mov.w	r3, #4
		ptr++;
   16378:	bf08      	it	eq
   1637a:	f109 0901 	addeq.w	r9, r9, #1
	item->type = cJSON_String;
   1637e:	60f3      	str	r3, [r6, #12]
	return ptr;
   16380:	464f      	mov	r7, r9
   16382:	e002      	b.n	1638a <parse_string+0x6a>
		return 0;
   16384:	2700      	movs	r7, #0
		ep = str;
   16386:	4b4c      	ldr	r3, [pc, #304]	; (164b8 <parse_string+0x198>)
   16388:	6019      	str	r1, [r3, #0]
}
   1638a:	4638      	mov	r0, r7
   1638c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (*ptr++ == '\\')
   16390:	2a5c      	cmp	r2, #92	; 0x5c
   16392:	bf14      	ite	ne
   16394:	3301      	addne	r3, #1
			ptr++; /* Skip escaped quotes. */
   16396:	3302      	addeq	r3, #2
   16398:	3401      	adds	r4, #1
   1639a:	e7cb      	b.n	16334 <parse_string+0x14>
		if (*ptr != '\\')
   1639c:	2b5c      	cmp	r3, #92	; 0x5c
   1639e:	f109 0c01 	add.w	ip, r9, #1
   163a2:	d003      	beq.n	163ac <parse_string+0x8c>
			*ptr2++ = *ptr++;
   163a4:	f804 3b01 	strb.w	r3, [r4], #1
   163a8:	46e1      	mov	r9, ip
   163aa:	e7d8      	b.n	1635e <parse_string+0x3e>
			switch (*ptr) {
   163ac:	f899 3001 	ldrb.w	r3, [r9, #1]
   163b0:	2b6e      	cmp	r3, #110	; 0x6e
   163b2:	d01a      	beq.n	163ea <parse_string+0xca>
   163b4:	d808      	bhi.n	163c8 <parse_string+0xa8>
   163b6:	2b62      	cmp	r3, #98	; 0x62
   163b8:	f104 0101 	add.w	r1, r4, #1
   163bc:	d00d      	beq.n	163da <parse_string+0xba>
   163be:	2b66      	cmp	r3, #102	; 0x66
   163c0:	d011      	beq.n	163e6 <parse_string+0xc6>
				*ptr2++ = *ptr;
   163c2:	f804 3b01 	strb.w	r3, [r4], #1
				break;
   163c6:	e00b      	b.n	163e0 <parse_string+0xc0>
			switch (*ptr) {
   163c8:	2b74      	cmp	r3, #116	; 0x74
   163ca:	d011      	beq.n	163f0 <parse_string+0xd0>
   163cc:	2b75      	cmp	r3, #117	; 0x75
   163ce:	d012      	beq.n	163f6 <parse_string+0xd6>
   163d0:	2b72      	cmp	r3, #114	; 0x72
   163d2:	d1f6      	bne.n	163c2 <parse_string+0xa2>
				*ptr2++ = '\r';
   163d4:	f804 bb01 	strb.w	fp, [r4], #1
				break;
   163d8:	e002      	b.n	163e0 <parse_string+0xc0>
				*ptr2++ = '\b';
   163da:	2308      	movs	r3, #8
				*ptr2++ = '\f';
   163dc:	7023      	strb	r3, [r4, #0]
   163de:	460c      	mov	r4, r1
			ptr++;
   163e0:	f10c 0c01 	add.w	ip, ip, #1
   163e4:	e7e0      	b.n	163a8 <parse_string+0x88>
				*ptr2++ = '\f';
   163e6:	230c      	movs	r3, #12
   163e8:	e7f8      	b.n	163dc <parse_string+0xbc>
				*ptr2++ = '\n';
   163ea:	f804 ab01 	strb.w	sl, [r4], #1
				break;
   163ee:	e7f7      	b.n	163e0 <parse_string+0xc0>
				*ptr2++ = '\t';
   163f0:	f804 8b01 	strb.w	r8, [r4], #1
				break;
   163f4:	e7f4      	b.n	163e0 <parse_string+0xc0>
				uc = parse_hex4(ptr + 1);
   163f6:	f109 0002 	add.w	r0, r9, #2
   163fa:	f01c fc66 	bl	32cca <parse_hex4>
				if ((uc >= 0xDC00 && uc <= 0xDFFF) || uc == 0)
   163fe:	f5a0 435c 	sub.w	r3, r0, #56320	; 0xdc00
   16402:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
				uc = parse_hex4(ptr + 1);
   16406:	4605      	mov	r5, r0
				ptr += 4; /* get the unicode char. */
   16408:	f109 0c05 	add.w	ip, r9, #5
				if ((uc >= 0xDC00 && uc <= 0xDFFF) || uc == 0)
   1640c:	d3e8      	bcc.n	163e0 <parse_string+0xc0>
   1640e:	2800      	cmp	r0, #0
   16410:	d0e6      	beq.n	163e0 <parse_string+0xc0>
				if (uc >= 0xD800 &&
   16412:	f5a0 4358 	sub.w	r3, r0, #55296	; 0xd800
   16416:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   1641a:	d223      	bcs.n	16464 <parse_string+0x144>
					if (ptr[1] != '\\' || ptr[2] != 'u')
   1641c:	f899 3006 	ldrb.w	r3, [r9, #6]
   16420:	2b5c      	cmp	r3, #92	; 0x5c
   16422:	d1dd      	bne.n	163e0 <parse_string+0xc0>
   16424:	f899 3007 	ldrb.w	r3, [r9, #7]
   16428:	2b75      	cmp	r3, #117	; 0x75
   1642a:	d1d9      	bne.n	163e0 <parse_string+0xc0>
					uc2 = parse_hex4(ptr + 3);
   1642c:	f109 0008 	add.w	r0, r9, #8
   16430:	f01c fc4b 	bl	32cca <parse_hex4>
					if (uc2 < 0xDC00 || uc2 > 0xDFFF)
   16434:	f5a0 435c 	sub.w	r3, r0, #56320	; 0xdc00
   16438:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
					ptr += 6;
   1643c:	f109 0c0b 	add.w	ip, r9, #11
					if (uc2 < 0xDC00 || uc2 > 0xDFFF)
   16440:	d2ce      	bcs.n	163e0 <parse_string+0xc0>
					uc = 0x10000 + (((uc & 0x3FF) << 10) |
   16442:	4b1e      	ldr	r3, [pc, #120]	; (164bc <parse_string+0x19c>)
							(uc2 & 0x3FF));
   16444:	f3c0 0009 	ubfx	r0, r0, #0, #10
					uc = 0x10000 + (((uc & 0x3FF) << 10) |
   16448:	ea03 2585 	and.w	r5, r3, r5, lsl #10
   1644c:	4305      	orrs	r5, r0
   1644e:	f505 3580 	add.w	r5, r5, #65536	; 0x10000
					*--ptr2 = ((uc | 0x80) & 0xBF);
   16452:	f005 033f 	and.w	r3, r5, #63	; 0x3f
   16456:	f063 037f 	orn	r3, r3, #127	; 0x7f
   1645a:	70e3      	strb	r3, [r4, #3]
   1645c:	1ce0      	adds	r0, r4, #3
					uc >>= 6;
   1645e:	09ad      	lsrs	r5, r5, #6
				len = 4;
   16460:	2304      	movs	r3, #4
   16462:	e013      	b.n	1648c <parse_string+0x16c>
				if (uc < 0x80)
   16464:	287f      	cmp	r0, #127	; 0x7f
   16466:	d809      	bhi.n	1647c <parse_string+0x15c>
					len = 1;
   16468:	2301      	movs	r3, #1
				ptr2 += len;
   1646a:	3401      	adds	r4, #1
					*--ptr2 = (uc | firstByteMark[len]);
   1646c:	4a14      	ldr	r2, [pc, #80]	; (164c0 <parse_string+0x1a0>)
   1646e:	5cd1      	ldrb	r1, [r2, r3]
				ptr2 += len;
   16470:	3b01      	subs	r3, #1
					*--ptr2 = (uc | firstByteMark[len]);
   16472:	430d      	orrs	r5, r1
   16474:	f804 5c01 	strb.w	r5, [r4, #-1]
				ptr2 += len;
   16478:	441c      	add	r4, r3
				break;
   1647a:	e7b1      	b.n	163e0 <parse_string+0xc0>
				else if (uc < 0x800)
   1647c:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
   16480:	d30d      	bcc.n	1649e <parse_string+0x17e>
				else if (uc < 0x10000)
   16482:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
   16486:	d2e4      	bcs.n	16452 <parse_string+0x132>
					len = 3;
   16488:	2303      	movs	r3, #3
				ptr2 += len;
   1648a:	1ce0      	adds	r0, r4, #3
					*--ptr2 = ((uc | 0x80) & 0xBF);
   1648c:	f005 043f 	and.w	r4, r5, #63	; 0x3f
   16490:	f064 047f 	orn	r4, r4, #127	; 0x7f
   16494:	1e41      	subs	r1, r0, #1
   16496:	f800 4c01 	strb.w	r4, [r0, #-1]
					uc >>= 6;
   1649a:	09ad      	lsrs	r5, r5, #6
   1649c:	e001      	b.n	164a2 <parse_string+0x182>
					len = 2;
   1649e:	2302      	movs	r3, #2
				ptr2 += len;
   164a0:	1ca1      	adds	r1, r4, #2
					*--ptr2 = ((uc | 0x80) & 0xBF);
   164a2:	f005 003f 	and.w	r0, r5, #63	; 0x3f
   164a6:	f060 007f 	orn	r0, r0, #127	; 0x7f
   164aa:	1e4c      	subs	r4, r1, #1
   164ac:	f801 0c01 	strb.w	r0, [r1, #-1]
					uc >>= 6;
   164b0:	09ad      	lsrs	r5, r5, #6
   164b2:	e7db      	b.n	1646c <parse_string+0x14c>
   164b4:	20020080 	.word	0x20020080
   164b8:	20021534 	.word	0x20021534
   164bc:	000ffc00 	.word	0x000ffc00
   164c0:	0003c4f1 	.word	0x0003c4f1

000164c4 <cJSON_New_Item>:
	cJSON *node = (cJSON *)cJSON_malloc(sizeof(cJSON));
   164c4:	4b06      	ldr	r3, [pc, #24]	; (164e0 <cJSON_New_Item+0x1c>)
{
   164c6:	b510      	push	{r4, lr}
	cJSON *node = (cJSON *)cJSON_malloc(sizeof(cJSON));
   164c8:	681b      	ldr	r3, [r3, #0]
   164ca:	2028      	movs	r0, #40	; 0x28
   164cc:	4798      	blx	r3
	if (node)
   164ce:	4604      	mov	r4, r0
   164d0:	b118      	cbz	r0, 164da <cJSON_New_Item+0x16>
__ssp_bos_icheck3(memset, void *, int)
   164d2:	2228      	movs	r2, #40	; 0x28
   164d4:	2100      	movs	r1, #0
   164d6:	f022 fdb9 	bl	3904c <memset>
}
   164da:	4620      	mov	r0, r4
   164dc:	bd10      	pop	{r4, pc}
   164de:	bf00      	nop
   164e0:	20020080 	.word	0x20020080

000164e4 <parse_value>:
}


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item, const char *value)
{
   164e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   164e6:	4605      	mov	r5, r0
	if (!value)
   164e8:	460c      	mov	r4, r1
   164ea:	b909      	cbnz	r1, 164f0 <parse_value+0xc>
	if (*value == '{') {
		return parse_object(item, value);
	}

	ep = value;
	return 0; /* failure. */
   164ec:	2400      	movs	r4, #0
   164ee:	e011      	b.n	16514 <parse_value+0x30>
	if (!strncmp(value, "null", 4)) {
   164f0:	2204      	movs	r2, #4
   164f2:	4975      	ldr	r1, [pc, #468]	; (166c8 <parse_value+0x1e4>)
   164f4:	4620      	mov	r0, r4
   164f6:	f022 ff05 	bl	39304 <strncmp>
   164fa:	b918      	cbnz	r0, 16504 <parse_value+0x20>
		item->type = cJSON_NULL;
   164fc:	2302      	movs	r3, #2
   164fe:	60eb      	str	r3, [r5, #12]
		return value + 4;
   16500:	3404      	adds	r4, #4
   16502:	e007      	b.n	16514 <parse_value+0x30>
	if (!strncmp(value, "false", 5)) {
   16504:	2205      	movs	r2, #5
   16506:	4971      	ldr	r1, [pc, #452]	; (166cc <parse_value+0x1e8>)
   16508:	4620      	mov	r0, r4
   1650a:	f022 fefb 	bl	39304 <strncmp>
   1650e:	b918      	cbnz	r0, 16518 <parse_value+0x34>
		item->type = cJSON_False;
   16510:	60e8      	str	r0, [r5, #12]
		return value + 5;
   16512:	3405      	adds	r4, #5
}
   16514:	4620      	mov	r0, r4
   16516:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (!strncmp(value, "true", 4)) {
   16518:	2204      	movs	r2, #4
   1651a:	496d      	ldr	r1, [pc, #436]	; (166d0 <parse_value+0x1ec>)
   1651c:	4620      	mov	r0, r4
   1651e:	f022 fef1 	bl	39304 <strncmp>
   16522:	b918      	cbnz	r0, 1652c <parse_value+0x48>
		item->type = cJSON_True;
   16524:	2301      	movs	r3, #1
   16526:	60eb      	str	r3, [r5, #12]
		item->valueint = 1;
   16528:	616b      	str	r3, [r5, #20]
   1652a:	e7e9      	b.n	16500 <parse_value+0x1c>
	if (*value == '\"') {
   1652c:	7823      	ldrb	r3, [r4, #0]
   1652e:	2b22      	cmp	r3, #34	; 0x22
   16530:	d105      	bne.n	1653e <parse_value+0x5a>
		return parse_string(item, value);
   16532:	4621      	mov	r1, r4
   16534:	4628      	mov	r0, r5
}
   16536:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		return parse_string(item, value);
   1653a:	f7ff bef1 	b.w	16320 <parse_string>
	if (*value == '-' || (*value >= '0' && *value <= '9')) {
   1653e:	2b2d      	cmp	r3, #45	; 0x2d
   16540:	d005      	beq.n	1654e <parse_value+0x6a>
   16542:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   16546:	2a09      	cmp	r2, #9
   16548:	d81d      	bhi.n	16586 <parse_value+0xa2>
	int n = 0, sign = 1;
   1654a:	2201      	movs	r2, #1
   1654c:	e002      	b.n	16554 <parse_value+0x70>
		sign = -1, num++; /* Has sign? */
   1654e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   16552:	3401      	adds	r4, #1
	if (*num == '0')
   16554:	7823      	ldrb	r3, [r4, #0]
   16556:	2b30      	cmp	r3, #48	; 0x30
		num++; /* is zero */
   16558:	bf08      	it	eq
   1655a:	3401      	addeq	r4, #1
	if (*num >= '1' && *num <= '9')
   1655c:	7823      	ldrb	r3, [r4, #0]
   1655e:	3b31      	subs	r3, #49	; 0x31
   16560:	2b08      	cmp	r3, #8
	int n = 0, sign = 1;
   16562:	f04f 0300 	mov.w	r3, #0
	if (*num >= '1' && *num <= '9')
   16566:	d809      	bhi.n	1657c <parse_value+0x98>
			n = (n * 10) + (*num++ - '0');
   16568:	200a      	movs	r0, #10
   1656a:	4343      	muls	r3, r0
   1656c:	f814 1b01 	ldrb.w	r1, [r4], #1
   16570:	3b30      	subs	r3, #48	; 0x30
   16572:	440b      	add	r3, r1
		while (*num >= '0' && *num <= '9'); /* Number? */
   16574:	7821      	ldrb	r1, [r4, #0]
   16576:	3930      	subs	r1, #48	; 0x30
   16578:	2909      	cmp	r1, #9
   1657a:	d9f6      	bls.n	1656a <parse_value+0x86>
	n = sign * n;
   1657c:	4353      	muls	r3, r2
	item->valueint = (int)n;
   1657e:	616b      	str	r3, [r5, #20]
	item->type = cJSON_Number;
   16580:	2303      	movs	r3, #3
   16582:	60eb      	str	r3, [r5, #12]
	return num;
   16584:	e7c6      	b.n	16514 <parse_value+0x30>
	if (*value == '[') {
   16586:	2b5b      	cmp	r3, #91	; 0x5b
   16588:	d136      	bne.n	165f8 <parse_value+0x114>
	if (*value != '[') {
		ep = value;
		return 0;
	} /* not an array! */

	item->type = cJSON_Array;
   1658a:	2305      	movs	r3, #5
	value = skip(value + 1);
   1658c:	1c60      	adds	r0, r4, #1
	item->type = cJSON_Array;
   1658e:	60eb      	str	r3, [r5, #12]
	value = skip(value + 1);
   16590:	f01c fbf1 	bl	32d76 <skip>
	if (*value == ']')
   16594:	7803      	ldrb	r3, [r0, #0]
	value = skip(value + 1);
   16596:	4604      	mov	r4, r0
	if (*value == ']')
   16598:	2b5d      	cmp	r3, #93	; 0x5d
   1659a:	d101      	bne.n	165a0 <parse_value+0xbc>
	} /* not an object! */

	item->type = cJSON_Object;
	value = skip(value + 1);
	if (*value == '}')
		return value + 1; /* empty array. */
   1659c:	3401      	adds	r4, #1
   1659e:	e7b9      	b.n	16514 <parse_value+0x30>
	item->child = child = cJSON_New_Item();
   165a0:	f7ff ff90 	bl	164c4 <cJSON_New_Item>
   165a4:	4606      	mov	r6, r0
   165a6:	60a8      	str	r0, [r5, #8]
	if (!item->child)
   165a8:	2800      	cmp	r0, #0
   165aa:	d09f      	beq.n	164ec <parse_value+0x8>
	value = skip(parse_value(
   165ac:	4620      	mov	r0, r4
   165ae:	f01c fbe2 	bl	32d76 <skip>
   165b2:	4601      	mov	r1, r0
   165b4:	4630      	mov	r0, r6
   165b6:	f7ff ff95 	bl	164e4 <parse_value>
   165ba:	f01c fbdc 	bl	32d76 <skip>
		if (!value)
   165be:	4604      	mov	r4, r0
   165c0:	2800      	cmp	r0, #0
   165c2:	d093      	beq.n	164ec <parse_value+0x8>
	while (*value == ',') {
   165c4:	7803      	ldrb	r3, [r0, #0]
   165c6:	2b2c      	cmp	r3, #44	; 0x2c
   165c8:	d004      	beq.n	165d4 <parse_value+0xf0>
	if (*value == ']')
   165ca:	2b5d      	cmp	r3, #93	; 0x5d
   165cc:	d0e6      	beq.n	1659c <parse_value+0xb8>
	ep = value;
   165ce:	4b41      	ldr	r3, [pc, #260]	; (166d4 <parse_value+0x1f0>)
   165d0:	601c      	str	r4, [r3, #0]
   165d2:	e78b      	b.n	164ec <parse_value+0x8>
		new_item = cJSON_New_Item();
   165d4:	f7ff ff76 	bl	164c4 <cJSON_New_Item>
		if (!new_item)
   165d8:	4605      	mov	r5, r0
   165da:	2800      	cmp	r0, #0
   165dc:	d086      	beq.n	164ec <parse_value+0x8>
		child->next = new_item;
   165de:	6030      	str	r0, [r6, #0]
		new_item->prev = child;
   165e0:	6046      	str	r6, [r0, #4]
		value = skip(parse_value(child, skip(value + 1)));
   165e2:	1c60      	adds	r0, r4, #1
   165e4:	f01c fbc7 	bl	32d76 <skip>
   165e8:	4601      	mov	r1, r0
   165ea:	4628      	mov	r0, r5
   165ec:	f7ff ff7a 	bl	164e4 <parse_value>
   165f0:	f01c fbc1 	bl	32d76 <skip>
		if (!value)
   165f4:	462e      	mov	r6, r5
   165f6:	e7e2      	b.n	165be <parse_value+0xda>
	if (*value == '{') {
   165f8:	2b7b      	cmp	r3, #123	; 0x7b
   165fa:	d1e8      	bne.n	165ce <parse_value+0xea>
	item->type = cJSON_Object;
   165fc:	2306      	movs	r3, #6
	value = skip(value + 1);
   165fe:	1c60      	adds	r0, r4, #1
	item->type = cJSON_Object;
   16600:	60eb      	str	r3, [r5, #12]
	value = skip(value + 1);
   16602:	f01c fbb8 	bl	32d76 <skip>
	if (*value == '}')
   16606:	7803      	ldrb	r3, [r0, #0]
	value = skip(value + 1);
   16608:	4604      	mov	r4, r0
	if (*value == '}')
   1660a:	2b7d      	cmp	r3, #125	; 0x7d
   1660c:	d0c6      	beq.n	1659c <parse_value+0xb8>

	item->child = child = cJSON_New_Item();
   1660e:	f7ff ff59 	bl	164c4 <cJSON_New_Item>
   16612:	4606      	mov	r6, r0
   16614:	60a8      	str	r0, [r5, #8]
	if (!item->child)
   16616:	2800      	cmp	r0, #0
   16618:	f43f af68 	beq.w	164ec <parse_value+0x8>
		return 0;
	value = skip(parse_string(child, skip(value)));
   1661c:	4620      	mov	r0, r4
   1661e:	f01c fbaa 	bl	32d76 <skip>
   16622:	4601      	mov	r1, r0
   16624:	4630      	mov	r0, r6
   16626:	f7ff fe7b 	bl	16320 <parse_string>
   1662a:	f01c fba4 	bl	32d76 <skip>
	if (!value)
   1662e:	2800      	cmp	r0, #0
   16630:	f43f af5c 	beq.w	164ec <parse_value+0x8>
		return 0;
	child->string = child->valuestring;
	child->valuestring = 0;
   16634:	2400      	movs	r4, #0
	child->string = child->valuestring;
   16636:	6933      	ldr	r3, [r6, #16]
	child->valuestring = 0;
   16638:	6134      	str	r4, [r6, #16]
	child->string = child->valuestring;
   1663a:	6233      	str	r3, [r6, #32]
	if (*value != ':') {
   1663c:	7803      	ldrb	r3, [r0, #0]
   1663e:	2b3a      	cmp	r3, #58	; 0x3a
   16640:	d002      	beq.n	16648 <parse_value+0x164>
		ep = value;
   16642:	4b24      	ldr	r3, [pc, #144]	; (166d4 <parse_value+0x1f0>)
   16644:	6018      	str	r0, [r3, #0]
		return 0;
   16646:	e765      	b.n	16514 <parse_value+0x30>
	} /* fail! */
	value = skip(parse_value(
   16648:	3001      	adds	r0, #1
   1664a:	f01c fb94 	bl	32d76 <skip>
   1664e:	4601      	mov	r1, r0
   16650:	4630      	mov	r0, r6
   16652:	f7ff ff47 	bl	164e4 <parse_value>
   16656:	f01c fb8e 	bl	32d76 <skip>
			return 0;
		} /* fail! */
		value = skip(parse_value(
			child, skip(value +
				    1))); /* skip any spacing, get the value. */
		if (!value)
   1665a:	4607      	mov	r7, r0
   1665c:	2800      	cmp	r0, #0
   1665e:	f43f af45 	beq.w	164ec <parse_value+0x8>
	while (*value == ',') {
   16662:	7803      	ldrb	r3, [r0, #0]
   16664:	2b2c      	cmp	r3, #44	; 0x2c
   16666:	d003      	beq.n	16670 <parse_value+0x18c>
			return 0;
	}

	if (*value == '}')
   16668:	2b7d      	cmp	r3, #125	; 0x7d
   1666a:	d129      	bne.n	166c0 <parse_value+0x1dc>
		return value + 1; /* end of array */
   1666c:	1c44      	adds	r4, r0, #1
   1666e:	e751      	b.n	16514 <parse_value+0x30>
		new_item = cJSON_New_Item();
   16670:	f7ff ff28 	bl	164c4 <cJSON_New_Item>
		if (!(new_item))
   16674:	4605      	mov	r5, r0
   16676:	2800      	cmp	r0, #0
   16678:	f43f af38 	beq.w	164ec <parse_value+0x8>
		child->next = new_item;
   1667c:	6030      	str	r0, [r6, #0]
		new_item->prev = child;
   1667e:	6046      	str	r6, [r0, #4]
		value = skip(parse_string(child, skip(value + 1)));
   16680:	1c78      	adds	r0, r7, #1
   16682:	f01c fb78 	bl	32d76 <skip>
   16686:	4601      	mov	r1, r0
   16688:	4628      	mov	r0, r5
   1668a:	f7ff fe49 	bl	16320 <parse_string>
   1668e:	f01c fb72 	bl	32d76 <skip>
		if (!value)
   16692:	2800      	cmp	r0, #0
   16694:	f43f af2a 	beq.w	164ec <parse_value+0x8>
		child->string = child->valuestring;
   16698:	692b      	ldr	r3, [r5, #16]
		child->valuestring = 0;
   1669a:	612c      	str	r4, [r5, #16]
		child->string = child->valuestring;
   1669c:	622b      	str	r3, [r5, #32]
		if (*value != ':') {
   1669e:	7803      	ldrb	r3, [r0, #0]
   166a0:	2b3a      	cmp	r3, #58	; 0x3a
   166a2:	d002      	beq.n	166aa <parse_value+0x1c6>
			ep = value;
   166a4:	4b0b      	ldr	r3, [pc, #44]	; (166d4 <parse_value+0x1f0>)
   166a6:	6018      	str	r0, [r3, #0]
			return 0;
   166a8:	e720      	b.n	164ec <parse_value+0x8>
		value = skip(parse_value(
   166aa:	3001      	adds	r0, #1
   166ac:	f01c fb63 	bl	32d76 <skip>
   166b0:	4601      	mov	r1, r0
   166b2:	4628      	mov	r0, r5
   166b4:	f7ff ff16 	bl	164e4 <parse_value>
   166b8:	f01c fb5d 	bl	32d76 <skip>
		if (!value)
   166bc:	462e      	mov	r6, r5
   166be:	e7cc      	b.n	1665a <parse_value+0x176>
	ep = value;
   166c0:	4b04      	ldr	r3, [pc, #16]	; (166d4 <parse_value+0x1f0>)
   166c2:	6018      	str	r0, [r3, #0]
	return 0; /* malformed. */
   166c4:	e712      	b.n	164ec <parse_value+0x8>
   166c6:	bf00      	nop
   166c8:	0003c4f8 	.word	0x0003c4f8
   166cc:	0003c4fd 	.word	0x0003c4fd
   166d0:	0003c503 	.word	0x0003c503
   166d4:	20021534 	.word	0x20021534

000166d8 <ensure>:
{
   166d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!p || !p->buffer)
   166da:	4605      	mov	r5, r0
   166dc:	b368      	cbz	r0, 1673a <ensure+0x62>
   166de:	6806      	ldr	r6, [r0, #0]
   166e0:	b1f6      	cbz	r6, 16720 <ensure+0x48>
	needed += p->offset;
   166e2:	6883      	ldr	r3, [r0, #8]
	if (needed <= p->length)
   166e4:	6842      	ldr	r2, [r0, #4]
	needed += p->offset;
   166e6:	185c      	adds	r4, r3, r1
	if (needed <= p->length)
   166e8:	42a2      	cmp	r2, r4
   166ea:	db01      	blt.n	166f0 <ensure+0x18>
	return newbuffer + p->offset;
   166ec:	441e      	add	r6, r3
   166ee:	e017      	b.n	16720 <ensure+0x48>
	--x;
   166f0:	3c01      	subs	r4, #1
	x |= x >> 1;
   166f2:	ea44 0464 	orr.w	r4, r4, r4, asr #1
	x |= x >> 2;
   166f6:	ea44 04a4 	orr.w	r4, r4, r4, asr #2
	x |= x >> 4;
   166fa:	ea44 1424 	orr.w	r4, r4, r4, asr #4
	x |= x >> 8;
   166fe:	ea44 2424 	orr.w	r4, r4, r4, asr #8
	x |= x >> 16;
   16702:	ea44 4424 	orr.w	r4, r4, r4, asr #16
	newbuffer = (char *)cJSON_malloc(newsize);
   16706:	4b0e      	ldr	r3, [pc, #56]	; (16740 <ensure+0x68>)
	return x + 1;
   16708:	3401      	adds	r4, #1
	newbuffer = (char *)cJSON_malloc(newsize);
   1670a:	681b      	ldr	r3, [r3, #0]
   1670c:	4620      	mov	r0, r4
   1670e:	4798      	blx	r3
	if (!newbuffer) {
   16710:	4f0c      	ldr	r7, [pc, #48]	; (16744 <ensure+0x6c>)
   16712:	4606      	mov	r6, r0
   16714:	b930      	cbnz	r0, 16724 <ensure+0x4c>
		cJSON_free(p->buffer);
   16716:	683b      	ldr	r3, [r7, #0]
   16718:	6828      	ldr	r0, [r5, #0]
   1671a:	4798      	blx	r3
		p->length = 0, p->buffer = 0;
   1671c:	e9c5 6600 	strd	r6, r6, [r5]
}
   16720:	4630      	mov	r0, r6
   16722:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   16724:	e9d5 1200 	ldrd	r1, r2, [r5]
   16728:	f022 fc56 	bl	38fd8 <memcpy>
	cJSON_free(p->buffer);
   1672c:	683b      	ldr	r3, [r7, #0]
   1672e:	6828      	ldr	r0, [r5, #0]
   16730:	4798      	blx	r3
	p->buffer = newbuffer;
   16732:	e9c5 6400 	strd	r6, r4, [r5]
	return newbuffer + p->offset;
   16736:	68ab      	ldr	r3, [r5, #8]
   16738:	e7d8      	b.n	166ec <ensure+0x14>
		return 0;
   1673a:	4606      	mov	r6, r0
   1673c:	e7f0      	b.n	16720 <ensure+0x48>
   1673e:	bf00      	nop
   16740:	20020080 	.word	0x20020080
   16744:	2002007c 	.word	0x2002007c

00016748 <cJSON_strdup>:
{
   16748:	b570      	push	{r4, r5, r6, lr}
	len = strlens(str) + 1;
   1674a:	4606      	mov	r6, r0
   1674c:	b170      	cbz	r0, 1676c <cJSON_strdup+0x24>
   1674e:	f7fb fc97 	bl	12080 <strlen>
   16752:	1c44      	adds	r4, r0, #1
	copy = (char *)cJSON_malloc(len);
   16754:	4b06      	ldr	r3, [pc, #24]	; (16770 <cJSON_strdup+0x28>)
   16756:	4620      	mov	r0, r4
   16758:	681b      	ldr	r3, [r3, #0]
   1675a:	4798      	blx	r3
	if (!copy)
   1675c:	4605      	mov	r5, r0
   1675e:	b118      	cbz	r0, 16768 <cJSON_strdup+0x20>
   16760:	4622      	mov	r2, r4
   16762:	4631      	mov	r1, r6
   16764:	f022 fc38 	bl	38fd8 <memcpy>
}
   16768:	4628      	mov	r0, r5
   1676a:	bd70      	pop	{r4, r5, r6, pc}
	len = strlens(str) + 1;
   1676c:	2401      	movs	r4, #1
   1676e:	e7f1      	b.n	16754 <cJSON_strdup+0xc>
   16770:	20020080 	.word	0x20020080

00016774 <print_string_ptr>:
{
   16774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int len = 0, flag = 0;
   16778:	2200      	movs	r2, #0
{
   1677a:	460d      	mov	r5, r1
   1677c:	4606      	mov	r6, r0
   1677e:	4601      	mov	r1, r0
   16780:	460b      	mov	r3, r1
	for (ptr = str; *ptr; ptr++)
   16782:	f811 4b01 	ldrb.w	r4, [r1], #1
   16786:	b9c4      	cbnz	r4, 167ba <print_string_ptr+0x46>
	if (!flag) {
   16788:	bb4a      	cbnz	r2, 167de <print_string_ptr+0x6a>
		len = ptr - str;
   1678a:	1b9c      	subs	r4, r3, r6
		if (p)
   1678c:	1ce1      	adds	r1, r4, #3
   1678e:	b30d      	cbz	r5, 167d4 <print_string_ptr+0x60>
			out = ensure(p, len + 3);
   16790:	4628      	mov	r0, r5
   16792:	f7ff ffa1 	bl	166d8 <ensure>
			out = (char *)cJSON_malloc(len + 3);
   16796:	4605      	mov	r5, r0
		if (!out)
   16798:	b160      	cbz	r0, 167b4 <print_string_ptr+0x40>
		*ptr2++ = '\"';
   1679a:	4603      	mov	r3, r0
   1679c:	2722      	movs	r7, #34	; 0x22
   1679e:	f803 7b01 	strb.w	r7, [r3], #1
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   167a2:	4618      	mov	r0, r3
   167a4:	4631      	mov	r1, r6
   167a6:	f022 fda5 	bl	392f4 <strcpy>
   167aa:	4603      	mov	r3, r0
		ptr2[len + 1] = 0;
   167ac:	2200      	movs	r2, #0
   167ae:	4423      	add	r3, r4
		ptr2[len] = '\"';
   167b0:	5507      	strb	r7, [r0, r4]
		ptr2[len + 1] = 0;
   167b2:	705a      	strb	r2, [r3, #1]
}
   167b4:	4628      	mov	r0, r5
   167b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				: 0;
   167ba:	1e63      	subs	r3, r4, #1
   167bc:	2b1e      	cmp	r3, #30
   167be:	d907      	bls.n	167d0 <print_string_ptr+0x5c>
		flag |= ((*ptr > 0 && *ptr < 32) || (*ptr == '\"') ||
   167c0:	2c22      	cmp	r4, #34	; 0x22
   167c2:	d005      	beq.n	167d0 <print_string_ptr+0x5c>
				: 0;
   167c4:	f1a4 035c 	sub.w	r3, r4, #92	; 0x5c
   167c8:	425c      	negs	r4, r3
   167ca:	415c      	adcs	r4, r3
		flag |= ((*ptr > 0 && *ptr < 32) || (*ptr == '\"') ||
   167cc:	4322      	orrs	r2, r4
   167ce:	e7d7      	b.n	16780 <print_string_ptr+0xc>
				: 0;
   167d0:	2401      	movs	r4, #1
   167d2:	e7fb      	b.n	167cc <print_string_ptr+0x58>
			out = (char *)cJSON_malloc(len + 3);
   167d4:	4b41      	ldr	r3, [pc, #260]	; (168dc <print_string_ptr+0x168>)
   167d6:	4608      	mov	r0, r1
   167d8:	681b      	ldr	r3, [r3, #0]
   167da:	4798      	blx	r3
   167dc:	e7db      	b.n	16796 <print_string_ptr+0x22>
	if (!str) {
   167de:	b986      	cbnz	r6, 16802 <print_string_ptr+0x8e>
		if (p)
   167e0:	b155      	cbz	r5, 167f8 <print_string_ptr+0x84>
			out = ensure(p, 3);
   167e2:	2103      	movs	r1, #3
   167e4:	4628      	mov	r0, r5
   167e6:	f7ff ff77 	bl	166d8 <ensure>
			out = (char *)cJSON_malloc(3);
   167ea:	4605      	mov	r5, r0
		if (!out)
   167ec:	2800      	cmp	r0, #0
   167ee:	d0e1      	beq.n	167b4 <print_string_ptr+0x40>
   167f0:	493b      	ldr	r1, [pc, #236]	; (168e0 <print_string_ptr+0x16c>)
   167f2:	f022 fd7f 	bl	392f4 <strcpy>
		return out;
   167f6:	e7dd      	b.n	167b4 <print_string_ptr+0x40>
			out = (char *)cJSON_malloc(3);
   167f8:	4b38      	ldr	r3, [pc, #224]	; (168dc <print_string_ptr+0x168>)
   167fa:	2003      	movs	r0, #3
   167fc:	681b      	ldr	r3, [r3, #0]
   167fe:	4798      	blx	r3
   16800:	e7f3      	b.n	167ea <print_string_ptr+0x76>
	while ((token) && ++len) {
   16802:	46b1      	mov	r9, r6
	token = *ptr;
   16804:	f896 8000 	ldrb.w	r8, [r6]
		if (strchr("\"\\\b\f\n\r\t", token))
   16808:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 168e4 <print_string_ptr+0x170>
	while ((token) && ++len) {
   1680c:	f1b8 0f00 	cmp.w	r8, #0
   16810:	d002      	beq.n	16818 <print_string_ptr+0xa4>
   16812:	1c67      	adds	r7, r4, #1
   16814:	d119      	bne.n	1684a <print_string_ptr+0xd6>
   16816:	463c      	mov	r4, r7
	if (p)
   16818:	1ce1      	adds	r1, r4, #3
   1681a:	b32d      	cbz	r5, 16868 <print_string_ptr+0xf4>
		out = ensure(p, len + 3);
   1681c:	4628      	mov	r0, r5
   1681e:	f7ff ff5b 	bl	166d8 <ensure>
		out = (char *)cJSON_malloc(len + 3);
   16822:	4605      	mov	r5, r0
	if (!out)
   16824:	2800      	cmp	r0, #0
   16826:	d0c5      	beq.n	167b4 <print_string_ptr+0x40>
	*ptr2++ = '\"';
   16828:	4604      	mov	r4, r0
   1682a:	2322      	movs	r3, #34	; 0x22
			*ptr2++ = '\\';
   1682c:	275c      	movs	r7, #92	; 0x5c
				*ptr2++ = 'f';
   1682e:	f04f 0866 	mov.w	r8, #102	; 0x66
				sprintf(ptr2, "u%04x", token);
   16832:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 168e8 <print_string_ptr+0x174>
	*ptr2++ = '\"';
   16836:	f804 3b01 	strb.w	r3, [r4], #1
	while (*ptr) {
   1683a:	3e01      	subs	r6, #1
   1683c:	f816 3f01 	ldrb.w	r3, [r6, #1]!
   16840:	b9bb      	cbnz	r3, 16872 <print_string_ptr+0xfe>
	*ptr2++ = '\"';
   16842:	2222      	movs	r2, #34	; 0x22
	*ptr2++ = 0;
   16844:	7063      	strb	r3, [r4, #1]
	*ptr2++ = '\"';
   16846:	7022      	strb	r2, [r4, #0]
	return out;
   16848:	e7b4      	b.n	167b4 <print_string_ptr+0x40>
		if (strchr("\"\\\b\f\n\r\t", token))
   1684a:	4641      	mov	r1, r8
   1684c:	4650      	mov	r0, sl
   1684e:	f022 fd44 	bl	392da <strchr>
   16852:	b120      	cbz	r0, 1685e <print_string_ptr+0xea>
			len++;
   16854:	1ca7      	adds	r7, r4, #2
		token = *ptr;
   16856:	f819 8f01 	ldrb.w	r8, [r9, #1]!
   1685a:	463c      	mov	r4, r7
   1685c:	e7d6      	b.n	1680c <print_string_ptr+0x98>
		else if (token < 32)
   1685e:	f1b8 0f1f 	cmp.w	r8, #31
			len += 5;
   16862:	bf98      	it	ls
   16864:	1da7      	addls	r7, r4, #6
   16866:	e7f6      	b.n	16856 <print_string_ptr+0xe2>
		out = (char *)cJSON_malloc(len + 3);
   16868:	4b1c      	ldr	r3, [pc, #112]	; (168dc <print_string_ptr+0x168>)
   1686a:	4608      	mov	r0, r1
   1686c:	681b      	ldr	r3, [r3, #0]
   1686e:	4798      	blx	r3
   16870:	e7d7      	b.n	16822 <print_string_ptr+0xae>
		if ((unsigned char)*ptr > 31 && *ptr != '\"' && *ptr != '\\')
   16872:	2b1f      	cmp	r3, #31
   16874:	f104 0001 	add.w	r0, r4, #1
   16878:	d906      	bls.n	16888 <print_string_ptr+0x114>
   1687a:	2b22      	cmp	r3, #34	; 0x22
   1687c:	d004      	beq.n	16888 <print_string_ptr+0x114>
   1687e:	2b5c      	cmp	r3, #92	; 0x5c
   16880:	d002      	beq.n	16888 <print_string_ptr+0x114>
			*ptr2++ = *ptr++;
   16882:	7023      	strb	r3, [r4, #0]
   16884:	4604      	mov	r4, r0
   16886:	e7d9      	b.n	1683c <print_string_ptr+0xc8>
			*ptr2++ = '\\';
   16888:	7027      	strb	r7, [r4, #0]
			switch (token = *ptr++) {
   1688a:	7832      	ldrb	r2, [r6, #0]
   1688c:	2a0c      	cmp	r2, #12
   1688e:	d016      	beq.n	168be <print_string_ptr+0x14a>
   16890:	d809      	bhi.n	168a6 <print_string_ptr+0x132>
   16892:	2a09      	cmp	r2, #9
   16894:	d01a      	beq.n	168cc <print_string_ptr+0x158>
   16896:	2a0a      	cmp	r2, #10
   16898:	d015      	beq.n	168c6 <print_string_ptr+0x152>
   1689a:	2a08      	cmp	r2, #8
   1689c:	d119      	bne.n	168d2 <print_string_ptr+0x15e>
				*ptr2++ = 'b';
   1689e:	2362      	movs	r3, #98	; 0x62
   168a0:	1ca0      	adds	r0, r4, #2
				*ptr2++ = 't';
   168a2:	7063      	strb	r3, [r4, #1]
				break;
   168a4:	e7ee      	b.n	16884 <print_string_ptr+0x110>
			switch (token = *ptr++) {
   168a6:	2a22      	cmp	r2, #34	; 0x22
   168a8:	d006      	beq.n	168b8 <print_string_ptr+0x144>
   168aa:	2a5c      	cmp	r2, #92	; 0x5c
   168ac:	d004      	beq.n	168b8 <print_string_ptr+0x144>
   168ae:	2a0d      	cmp	r2, #13
   168b0:	d10f      	bne.n	168d2 <print_string_ptr+0x15e>
				*ptr2++ = 'r';
   168b2:	1ca0      	adds	r0, r4, #2
   168b4:	2372      	movs	r3, #114	; 0x72
   168b6:	e7f4      	b.n	168a2 <print_string_ptr+0x12e>
				*ptr2++ = '\"';
   168b8:	1ca0      	adds	r0, r4, #2
   168ba:	7062      	strb	r2, [r4, #1]
				break;
   168bc:	e7e2      	b.n	16884 <print_string_ptr+0x110>
				*ptr2++ = 'f';
   168be:	1ca0      	adds	r0, r4, #2
   168c0:	f884 8001 	strb.w	r8, [r4, #1]
				break;
   168c4:	e7de      	b.n	16884 <print_string_ptr+0x110>
				*ptr2++ = 'n';
   168c6:	1ca0      	adds	r0, r4, #2
   168c8:	236e      	movs	r3, #110	; 0x6e
   168ca:	e7ea      	b.n	168a2 <print_string_ptr+0x12e>
				*ptr2++ = 't';
   168cc:	1ca0      	adds	r0, r4, #2
   168ce:	2374      	movs	r3, #116	; 0x74
   168d0:	e7e7      	b.n	168a2 <print_string_ptr+0x12e>
				sprintf(ptr2, "u%04x", token);
   168d2:	4649      	mov	r1, r9
   168d4:	f01b fa08 	bl	31ce8 <siprintf>
				ptr2 += 5;
   168d8:	1da0      	adds	r0, r4, #6
				break; /* escape and print */
   168da:	e7d3      	b.n	16884 <print_string_ptr+0x110>
   168dc:	20020080 	.word	0x20020080
   168e0:	0003c516 	.word	0x0003c516
   168e4:	0003c519 	.word	0x0003c519
   168e8:	0003c521 	.word	0x0003c521

000168ec <print_array.isra.4>:
static char *print_array(cJSON *item, int depth, int fmt, printbuffer *p)
   168ec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   168f0:	4607      	mov	r7, r0
   168f2:	468a      	mov	sl, r1
   168f4:	4616      	mov	r6, r2
   168f6:	461c      	mov	r4, r3
	int numentries = 0, i = 0, fail = 0;
   168f8:	2500      	movs	r5, #0
	cJSON *child = item->child;
   168fa:	f8d0 9000 	ldr.w	r9, [r0]
	while (child)
   168fe:	f1b9 0f00 	cmp.w	r9, #0
   16902:	d10e      	bne.n	16922 <print_array.isra.4+0x36>
	if (!numentries) {
   16904:	b9b5      	cbnz	r5, 16934 <print_array.isra.4+0x48>
		if (p)
   16906:	b184      	cbz	r4, 1692a <print_array.isra.4+0x3e>
			out = ensure(p, 3);
   16908:	2103      	movs	r1, #3
   1690a:	4620      	mov	r0, r4
   1690c:	f7ff fee4 	bl	166d8 <ensure>
			out = (char *)cJSON_malloc(3);
   16910:	4681      	mov	r9, r0
		if (out)
   16912:	b110      	cbz	r0, 1691a <print_array.isra.4+0x2e>
   16914:	4971      	ldr	r1, [pc, #452]	; (16adc <print_array.isra.4+0x1f0>)
   16916:	f022 fced 	bl	392f4 <strcpy>
}
   1691a:	4648      	mov	r0, r9
   1691c:	b003      	add	sp, #12
   1691e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		numentries++, child = child->next;
   16922:	3501      	adds	r5, #1
   16924:	f8d9 9000 	ldr.w	r9, [r9]
   16928:	e7e9      	b.n	168fe <print_array.isra.4+0x12>
			out = (char *)cJSON_malloc(3);
   1692a:	4b6d      	ldr	r3, [pc, #436]	; (16ae0 <print_array.isra.4+0x1f4>)
   1692c:	2003      	movs	r0, #3
   1692e:	681b      	ldr	r3, [r3, #0]
   16930:	4798      	blx	r3
   16932:	e7ed      	b.n	16910 <print_array.isra.4+0x24>
	if (p) {
   16934:	2c00      	cmp	r4, #0
   16936:	d048      	beq.n	169ca <print_array.isra.4+0xde>
		i = p->offset;
   16938:	68a3      	ldr	r3, [r4, #8]
		ptr = ensure(p, 1);
   1693a:	2101      	movs	r1, #1
   1693c:	4620      	mov	r0, r4
		i = p->offset;
   1693e:	9300      	str	r3, [sp, #0]
		ptr = ensure(p, 1);
   16940:	f7ff feca 	bl	166d8 <ensure>
		if (!ptr)
   16944:	2800      	cmp	r0, #0
   16946:	d0e8      	beq.n	1691a <print_array.isra.4+0x2e>
		*ptr = '[';
   16948:	235b      	movs	r3, #91	; 0x5b
   1694a:	2e00      	cmp	r6, #0
   1694c:	7003      	strb	r3, [r0, #0]
		child = item->child;
   1694e:	683d      	ldr	r5, [r7, #0]
   16950:	bf14      	ite	ne
   16952:	2702      	movne	r7, #2
   16954:	2701      	moveq	r7, #1
				*ptr++ = ',';
   16956:	f04f 082c 	mov.w	r8, #44	; 0x2c
				*ptr = 0;
   1695a:	46cb      	mov	fp, r9
		p->offset++;
   1695c:	68a3      	ldr	r3, [r4, #8]
			print_value(child, depth + 1, fmt, p);
   1695e:	f10a 0a01 	add.w	sl, sl, #1
		p->offset++;
   16962:	3301      	adds	r3, #1
   16964:	60a3      	str	r3, [r4, #8]
				ptr = ensure(p, len + 1);
   16966:	1c7b      	adds	r3, r7, #1
   16968:	9301      	str	r3, [sp, #4]
		while (child && !fail) {
   1696a:	b96d      	cbnz	r5, 16988 <print_array.isra.4+0x9c>
		ptr = ensure(p, 2);
   1696c:	2102      	movs	r1, #2
   1696e:	4620      	mov	r0, r4
   16970:	f7ff feb2 	bl	166d8 <ensure>
		if (!ptr)
   16974:	2800      	cmp	r0, #0
   16976:	d0d0      	beq.n	1691a <print_array.isra.4+0x2e>
		*ptr++ = ']';
   16978:	235d      	movs	r3, #93	; 0x5d
		*ptr = 0;
   1697a:	7045      	strb	r5, [r0, #1]
		*ptr++ = ']';
   1697c:	7003      	strb	r3, [r0, #0]
		out = (p->buffer) + i;
   1697e:	6823      	ldr	r3, [r4, #0]
   16980:	9a00      	ldr	r2, [sp, #0]
   16982:	441a      	add	r2, r3
   16984:	4691      	mov	r9, r2
   16986:	e7c8      	b.n	1691a <print_array.isra.4+0x2e>
			print_value(child, depth + 1, fmt, p);
   16988:	4623      	mov	r3, r4
   1698a:	4632      	mov	r2, r6
   1698c:	4651      	mov	r1, sl
   1698e:	4628      	mov	r0, r5
   16990:	f000 f8aa 	bl	16ae8 <print_value>
			p->offset = update(p);
   16994:	4620      	mov	r0, r4
   16996:	f01c f9f7 	bl	32d88 <update>
			if (child->next) {
   1699a:	682b      	ldr	r3, [r5, #0]
			p->offset = update(p);
   1699c:	60a0      	str	r0, [r4, #8]
			if (child->next) {
   1699e:	b173      	cbz	r3, 169be <print_array.isra.4+0xd2>
				ptr = ensure(p, len + 1);
   169a0:	9901      	ldr	r1, [sp, #4]
   169a2:	4620      	mov	r0, r4
   169a4:	f7ff fe98 	bl	166d8 <ensure>
				if (!ptr)
   169a8:	2800      	cmp	r0, #0
   169aa:	d0b6      	beq.n	1691a <print_array.isra.4+0x2e>
				*ptr++ = ',';
   169ac:	f880 8000 	strb.w	r8, [r0]
				if (fmt)
   169b0:	b93e      	cbnz	r6, 169c2 <print_array.isra.4+0xd6>
				*ptr++ = ',';
   169b2:	1c43      	adds	r3, r0, #1
				*ptr = 0;
   169b4:	f883 b000 	strb.w	fp, [r3]
				p->offset += len;
   169b8:	68a3      	ldr	r3, [r4, #8]
   169ba:	443b      	add	r3, r7
   169bc:	60a3      	str	r3, [r4, #8]
			child = child->next;
   169be:	682d      	ldr	r5, [r5, #0]
   169c0:	e7d3      	b.n	1696a <print_array.isra.4+0x7e>
					*ptr++ = ' ';
   169c2:	2220      	movs	r2, #32
   169c4:	1c83      	adds	r3, r0, #2
   169c6:	7042      	strb	r2, [r0, #1]
   169c8:	e7f4      	b.n	169b4 <print_array.isra.4+0xc8>
		entries = (char **)cJSON_malloc(numentries * sizeof(char *));
   169ca:	4b45      	ldr	r3, [pc, #276]	; (16ae0 <print_array.isra.4+0x1f4>)
   169cc:	ea4f 0b85 	mov.w	fp, r5, lsl #2
   169d0:	681a      	ldr	r2, [r3, #0]
   169d2:	4658      	mov	r0, fp
   169d4:	4790      	blx	r2
		if (!entries)
   169d6:	4b42      	ldr	r3, [pc, #264]	; (16ae0 <print_array.isra.4+0x1f4>)
   169d8:	4680      	mov	r8, r0
   169da:	9301      	str	r3, [sp, #4]
   169dc:	2800      	cmp	r0, #0
   169de:	d09c      	beq.n	1691a <print_array.isra.4+0x2e>
__ssp_bos_icheck3(memset, void *, int)
   169e0:	465a      	mov	r2, fp
	int len = 5;
   169e2:	f04f 0b05 	mov.w	fp, #5
   169e6:	4621      	mov	r1, r4
   169e8:	f022 fb30 	bl	3904c <memset>
		child = item->child;
   169ec:	f8d7 9000 	ldr.w	r9, [r7]
		while (child && !fail) {
   169f0:	f1a8 0704 	sub.w	r7, r8, #4
		child = item->child;
   169f4:	9700      	str	r7, [sp, #0]
			ret = print_value(child, depth + 1, fmt, 0);
   169f6:	f10a 0a01 	add.w	sl, sl, #1
		while (child && !fail) {
   169fa:	f1b9 0f00 	cmp.w	r9, #0
   169fe:	d01b      	beq.n	16a38 <print_array.isra.4+0x14c>
   16a00:	b114      	cbz	r4, 16a08 <print_array.isra.4+0x11c>
	int len = 5;
   16a02:	2400      	movs	r4, #0
   16a04:	4e37      	ldr	r6, [pc, #220]	; (16ae4 <print_array.isra.4+0x1f8>)
   16a06:	e03b      	b.n	16a80 <print_array.isra.4+0x194>
			ret = print_value(child, depth + 1, fmt, 0);
   16a08:	4632      	mov	r2, r6
   16a0a:	4623      	mov	r3, r4
   16a0c:	4651      	mov	r1, sl
   16a0e:	4648      	mov	r0, r9
   16a10:	f000 f86a 	bl	16ae8 <print_value>
			entries[i++] = ret;
   16a14:	9a00      	ldr	r2, [sp, #0]
   16a16:	f842 0f04 	str.w	r0, [r2, #4]!
   16a1a:	9200      	str	r2, [sp, #0]
			if (ret)
   16a1c:	b150      	cbz	r0, 16a34 <print_array.isra.4+0x148>
				len += strlens(ret) + 2 + (fmt ? 1 : 0);
   16a1e:	f7fb fb2f 	bl	12080 <strlen>
   16a22:	1c33      	adds	r3, r6, #0
   16a24:	bf18      	it	ne
   16a26:	2301      	movne	r3, #1
   16a28:	3302      	adds	r3, #2
   16a2a:	449b      	add	fp, r3
   16a2c:	4483      	add	fp, r0
			child = child->next;
   16a2e:	f8d9 9000 	ldr.w	r9, [r9]
   16a32:	e7e2      	b.n	169fa <print_array.isra.4+0x10e>
				fail = 1;
   16a34:	2401      	movs	r4, #1
   16a36:	e7fa      	b.n	16a2e <print_array.isra.4+0x142>
		if (!fail)
   16a38:	2c00      	cmp	r4, #0
   16a3a:	d1e2      	bne.n	16a02 <print_array.isra.4+0x116>
			out = (char *)cJSON_malloc(len);
   16a3c:	9b01      	ldr	r3, [sp, #4]
   16a3e:	4658      	mov	r0, fp
   16a40:	681b      	ldr	r3, [r3, #0]
   16a42:	4798      	blx	r3
		if (!out)
   16a44:	4681      	mov	r9, r0
   16a46:	2800      	cmp	r0, #0
   16a48:	d0db      	beq.n	16a02 <print_array.isra.4+0x116>
		*out = '[';
   16a4a:	235b      	movs	r3, #91	; 0x5b
   16a4c:	4682      	mov	sl, r0
   16a4e:	f8df b094 	ldr.w	fp, [pc, #148]	; 16ae4 <print_array.isra.4+0x1f8>
   16a52:	f80a 3b01 	strb.w	r3, [sl], #1
			if (i != numentries - 1) {
   16a56:	1e6b      	subs	r3, r5, #1
		*ptr = 0;
   16a58:	7044      	strb	r4, [r0, #1]
			if (i != numentries - 1) {
   16a5a:	9300      	str	r3, [sp, #0]
		for (i = 0; i < numentries; i++) {
   16a5c:	42a5      	cmp	r5, r4
   16a5e:	dc17      	bgt.n	16a90 <print_array.isra.4+0x1a4>
		cJSON_free(entries);
   16a60:	f8db 3000 	ldr.w	r3, [fp]
   16a64:	4640      	mov	r0, r8
   16a66:	4798      	blx	r3
		*ptr++ = ']';
   16a68:	235d      	movs	r3, #93	; 0x5d
   16a6a:	f88a 3000 	strb.w	r3, [sl]
		*ptr++ = 0;
   16a6e:	2300      	movs	r3, #0
   16a70:	f88a 3001 	strb.w	r3, [sl, #1]
   16a74:	e751      	b.n	1691a <print_array.isra.4+0x2e>
				if (entries[i])
   16a76:	f858 0024 	ldr.w	r0, [r8, r4, lsl #2]
   16a7a:	b100      	cbz	r0, 16a7e <print_array.isra.4+0x192>
					cJSON_free(entries[i]);
   16a7c:	4798      	blx	r3
			for (i = 0; i < numentries; i++)
   16a7e:	3401      	adds	r4, #1
   16a80:	42a5      	cmp	r5, r4
   16a82:	6833      	ldr	r3, [r6, #0]
   16a84:	dcf7      	bgt.n	16a76 <print_array.isra.4+0x18a>
			cJSON_free(entries);
   16a86:	4640      	mov	r0, r8
   16a88:	4798      	blx	r3
			return 0;
   16a8a:	f04f 0900 	mov.w	r9, #0
   16a8e:	e744      	b.n	1691a <print_array.isra.4+0x2e>
			tmplen = strlens(entries[i]);
   16a90:	6878      	ldr	r0, [r7, #4]
   16a92:	b108      	cbz	r0, 16a98 <print_array.isra.4+0x1ac>
   16a94:	f7fb faf4 	bl	12080 <strlen>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   16a98:	4602      	mov	r2, r0
   16a9a:	9001      	str	r0, [sp, #4]
   16a9c:	6879      	ldr	r1, [r7, #4]
   16a9e:	4650      	mov	r0, sl
   16aa0:	f022 fa9a 	bl	38fd8 <memcpy>
			ptr += tmplen;
   16aa4:	9b01      	ldr	r3, [sp, #4]
   16aa6:	449a      	add	sl, r3
			if (i != numentries - 1) {
   16aa8:	9b00      	ldr	r3, [sp, #0]
   16aaa:	429c      	cmp	r4, r3
   16aac:	d009      	beq.n	16ac2 <print_array.isra.4+0x1d6>
				*ptr++ = ',';
   16aae:	232c      	movs	r3, #44	; 0x2c
   16ab0:	f88a 3000 	strb.w	r3, [sl]
				if (fmt)
   16ab4:	b966      	cbnz	r6, 16ad0 <print_array.isra.4+0x1e4>
				*ptr++ = ',';
   16ab6:	f10a 0a01 	add.w	sl, sl, #1
				*ptr = 0;
   16aba:	f04f 0300 	mov.w	r3, #0
   16abe:	f88a 3000 	strb.w	r3, [sl]
			cJSON_free(entries[i]);
   16ac2:	f8db 3000 	ldr.w	r3, [fp]
   16ac6:	f857 0f04 	ldr.w	r0, [r7, #4]!
   16aca:	4798      	blx	r3
		for (i = 0; i < numentries; i++) {
   16acc:	3401      	adds	r4, #1
   16ace:	e7c5      	b.n	16a5c <print_array.isra.4+0x170>
					*ptr++ = ' ';
   16ad0:	2320      	movs	r3, #32
   16ad2:	f10a 0a02 	add.w	sl, sl, #2
   16ad6:	f80a 3c01 	strb.w	r3, [sl, #-1]
   16ada:	e7ee      	b.n	16aba <print_array.isra.4+0x1ce>
   16adc:	0003c508 	.word	0x0003c508
   16ae0:	20020080 	.word	0x20020080
   16ae4:	2002007c 	.word	0x2002007c

00016ae8 <print_value>:
{
   16ae8:	b510      	push	{r4, lr}
	if (!item)
   16aea:	4604      	mov	r4, r0
   16aec:	b190      	cbz	r0, 16b14 <print_value+0x2c>
	if (p) {
   16aee:	7b00      	ldrb	r0, [r0, #12]
   16af0:	b383      	cbz	r3, 16b54 <print_value+0x6c>
		switch ((item->type) & 255) {
   16af2:	2806      	cmp	r0, #6
   16af4:	d851      	bhi.n	16b9a <print_value+0xb2>
   16af6:	e8df f000 	tbb	[pc, r0]
   16afa:	180f      	.short	0x180f
   16afc:	43272104 	.word	0x43272104
   16b00:	4a          	.byte	0x4a
   16b01:	00          	.byte	0x00
			out = ensure(p, 5);
   16b02:	2105      	movs	r1, #5
   16b04:	4618      	mov	r0, r3
   16b06:	f7ff fde7 	bl	166d8 <ensure>
			if (out)
   16b0a:	4604      	mov	r4, r0
   16b0c:	b110      	cbz	r0, 16b14 <print_value+0x2c>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   16b0e:	4924      	ldr	r1, [pc, #144]	; (16ba0 <print_value+0xb8>)
   16b10:	f022 fbf0 	bl	392f4 <strcpy>
}
   16b14:	4620      	mov	r0, r4
   16b16:	bd10      	pop	{r4, pc}
			out = ensure(p, 6);
   16b18:	2106      	movs	r1, #6
   16b1a:	4618      	mov	r0, r3
   16b1c:	f7ff fddc 	bl	166d8 <ensure>
			if (out)
   16b20:	4604      	mov	r4, r0
   16b22:	2800      	cmp	r0, #0
   16b24:	d0f6      	beq.n	16b14 <print_value+0x2c>
   16b26:	491f      	ldr	r1, [pc, #124]	; (16ba4 <print_value+0xbc>)
   16b28:	e7f2      	b.n	16b10 <print_value+0x28>
			out = ensure(p, 5);
   16b2a:	2105      	movs	r1, #5
   16b2c:	4618      	mov	r0, r3
   16b2e:	f7ff fdd3 	bl	166d8 <ensure>
			if (out)
   16b32:	4604      	mov	r4, r0
   16b34:	2800      	cmp	r0, #0
   16b36:	d0ed      	beq.n	16b14 <print_value+0x2c>
   16b38:	491b      	ldr	r1, [pc, #108]	; (16ba8 <print_value+0xc0>)
   16b3a:	e7e9      	b.n	16b10 <print_value+0x28>
			out = print_number(item, p);
   16b3c:	4619      	mov	r1, r3
			out = print_number(item, 0);
   16b3e:	4620      	mov	r0, r4
}
   16b40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			out = print_number(item, 0);
   16b44:	f7fb bd60 	b.w	12608 <print_number>
	return print_string_ptr(item->valuestring, p);
   16b48:	4619      	mov	r1, r3
   16b4a:	6920      	ldr	r0, [r4, #16]
}
   16b4c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return print_string_ptr(item->valuestring, p);
   16b50:	f7ff be10 	b.w	16774 <print_string_ptr>
		switch ((item->type) & 255) {
   16b54:	2806      	cmp	r0, #6
   16b56:	d820      	bhi.n	16b9a <print_value+0xb2>
   16b58:	e8df f000 	tbb	[pc, r0]
   16b5c:	0d040b09 	.word	0x0d040b09
   16b60:	110f      	.short	0x110f
   16b62:	18          	.byte	0x18
   16b63:	00          	.byte	0x00
			out = cJSON_strdup("null");
   16b64:	480e      	ldr	r0, [pc, #56]	; (16ba0 <print_value+0xb8>)
}
   16b66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			out = cJSON_strdup("false");
   16b6a:	f7ff bded 	b.w	16748 <cJSON_strdup>
   16b6e:	480d      	ldr	r0, [pc, #52]	; (16ba4 <print_value+0xbc>)
   16b70:	e7f9      	b.n	16b66 <print_value+0x7e>
			out = cJSON_strdup("true");
   16b72:	480d      	ldr	r0, [pc, #52]	; (16ba8 <print_value+0xc0>)
   16b74:	e7f7      	b.n	16b66 <print_value+0x7e>
			out = print_number(item, 0);
   16b76:	2100      	movs	r1, #0
   16b78:	e7e1      	b.n	16b3e <print_value+0x56>
	return print_string_ptr(item->valuestring, p);
   16b7a:	2100      	movs	r1, #0
   16b7c:	e7e5      	b.n	16b4a <print_value+0x62>
			out = print_array(item, depth, fmt, 0);
   16b7e:	2300      	movs	r3, #0
   16b80:	f104 0008 	add.w	r0, r4, #8
}
   16b84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			out = print_array(item, depth, fmt, 0);
   16b88:	f7ff beb0 	b.w	168ec <print_array.isra.4>
			out = print_object(item, depth, fmt, 0);
   16b8c:	2300      	movs	r3, #0
   16b8e:	f104 0008 	add.w	r0, r4, #8
}
   16b92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			out = print_object(item, depth, fmt, 0);
   16b96:	f000 b809 	b.w	16bac <print_object.isra.3>
	char *out = 0;
   16b9a:	2400      	movs	r4, #0
   16b9c:	e7ba      	b.n	16b14 <print_value+0x2c>
   16b9e:	bf00      	nop
   16ba0:	0003c4f8 	.word	0x0003c4f8
   16ba4:	0003c4fd 	.word	0x0003c4fd
   16ba8:	0003c503 	.word	0x0003c503

00016bac <print_object.isra.3>:
}

/* Render an object to text. */
static char *print_object(cJSON *item, int depth, int fmt, printbuffer *p)
   16bac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   16bb0:	4615      	mov	r5, r2
{
	char **entries = 0, **names = 0;
	char *out = 0, *ptr, *ret, *str;
	int len = 7, i = 0, j;
	cJSON *child = item->child;
	int numentries = 0, fail = 0;
   16bb2:	2200      	movs	r2, #0
static char *print_object(cJSON *item, int depth, int fmt, printbuffer *p)
   16bb4:	4680      	mov	r8, r0
   16bb6:	468b      	mov	fp, r1
   16bb8:	b089      	sub	sp, #36	; 0x24
   16bba:	461c      	mov	r4, r3
	cJSON *child = item->child;
   16bbc:	6803      	ldr	r3, [r0, #0]
	int numentries = 0, fail = 0;
   16bbe:	9200      	str	r2, [sp, #0]
	size_t tmplen = 0;
	/* Count the number of entries. */
	while (child)
   16bc0:	b96b      	cbnz	r3, 16bde <print_object.isra.3+0x32>
		numentries++, child = child->next;
	/* Explicitly handle empty object case */
	if (!numentries) {
   16bc2:	9b00      	ldr	r3, [sp, #0]
   16bc4:	2b00      	cmp	r3, #0
   16bc6:	d13a      	bne.n	16c3e <print_object.isra.3+0x92>
		if (p)
   16bc8:	b184      	cbz	r4, 16bec <print_object.isra.3+0x40>
			out = ensure(p, fmt ? depth + 4 : 3);
   16bca:	b16d      	cbz	r5, 16be8 <print_object.isra.3+0x3c>
   16bcc:	f10b 0104 	add.w	r1, fp, #4
   16bd0:	4620      	mov	r0, r4
   16bd2:	f7ff fd81 	bl	166d8 <ensure>
		else
			out = (char *)cJSON_malloc(fmt ? depth + 4 : 3);
   16bd6:	4604      	mov	r4, r0
		if (!out)
   16bd8:	b988      	cbnz	r0, 16bfe <print_object.isra.3+0x52>
				if (entries[i])
					cJSON_free(entries[i]);
			}
			cJSON_free(names);
			cJSON_free(entries);
			return 0;
   16bda:	2400      	movs	r4, #0
   16bdc:	e017      	b.n	16c0e <print_object.isra.3+0x62>
		numentries++, child = child->next;
   16bde:	9a00      	ldr	r2, [sp, #0]
   16be0:	681b      	ldr	r3, [r3, #0]
   16be2:	3201      	adds	r2, #1
   16be4:	9200      	str	r2, [sp, #0]
   16be6:	e7eb      	b.n	16bc0 <print_object.isra.3+0x14>
			out = ensure(p, fmt ? depth + 4 : 3);
   16be8:	2103      	movs	r1, #3
   16bea:	e7f1      	b.n	16bd0 <print_object.isra.3+0x24>
			out = (char *)cJSON_malloc(fmt ? depth + 4 : 3);
   16bec:	4b97      	ldr	r3, [pc, #604]	; (16e4c <print_object.isra.3+0x2a0>)
   16bee:	681b      	ldr	r3, [r3, #0]
   16bf0:	b11d      	cbz	r5, 16bfa <print_object.isra.3+0x4e>
   16bf2:	f10b 0004 	add.w	r0, fp, #4
   16bf6:	4798      	blx	r3
   16bf8:	e7ed      	b.n	16bd6 <print_object.isra.3+0x2a>
   16bfa:	2003      	movs	r0, #3
   16bfc:	e7fb      	b.n	16bf6 <print_object.isra.3+0x4a>
		*ptr++ = '{';
   16bfe:	237b      	movs	r3, #123	; 0x7b
   16c00:	7003      	strb	r3, [r0, #0]
		if (fmt) {
   16c02:	b945      	cbnz	r5, 16c16 <print_object.isra.3+0x6a>
		*ptr++ = '{';
   16c04:	1c43      	adds	r3, r0, #1
		*ptr++ = '}';
   16c06:	227d      	movs	r2, #125	; 0x7d
   16c08:	701a      	strb	r2, [r3, #0]
		*ptr++ = 0;
   16c0a:	2200      	movs	r2, #0
   16c0c:	705a      	strb	r2, [r3, #1]
				*ptr++ = '\t';
		*ptr++ = '}';
		*ptr++ = 0;
	}
	return out;
}
   16c0e:	4620      	mov	r0, r4
   16c10:	b009      	add	sp, #36	; 0x24
   16c12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*ptr++ = '\n';
   16c16:	220a      	movs	r2, #10
   16c18:	1c83      	adds	r3, r0, #2
			for (i = 0; i < depth - 1; i++)
   16c1a:	f06f 0501 	mvn.w	r5, #1
			*ptr++ = '\n';
   16c1e:	7042      	strb	r2, [r0, #1]
				*ptr++ = '\t';
   16c20:	2609      	movs	r6, #9
			*ptr++ = '\n';
   16c22:	461a      	mov	r2, r3
			for (i = 0; i < depth - 1; i++)
   16c24:	f10b 31ff 	add.w	r1, fp, #4294967295	; 0xffffffff
   16c28:	1a2d      	subs	r5, r5, r0
   16c2a:	1950      	adds	r0, r2, r5
   16c2c:	4281      	cmp	r1, r0
   16c2e:	dc03      	bgt.n	16c38 <print_object.isra.3+0x8c>
   16c30:	2900      	cmp	r1, #0
   16c32:	bfa8      	it	ge
   16c34:	185b      	addge	r3, r3, r1
   16c36:	e7e6      	b.n	16c06 <print_object.isra.3+0x5a>
				*ptr++ = '\t';
   16c38:	f802 6b01 	strb.w	r6, [r2], #1
   16c3c:	e7f5      	b.n	16c2a <print_object.isra.3+0x7e>
	if (p) {
   16c3e:	2c00      	cmp	r4, #0
   16c40:	f000 8092 	beq.w	16d68 <print_object.isra.3+0x1bc>
		len = fmt ? 2 : 1;
   16c44:	2d00      	cmp	r5, #0
   16c46:	bf14      	ite	ne
   16c48:	2702      	movne	r7, #2
   16c4a:	2701      	moveq	r7, #1
		ptr = ensure(p, len + 1);
   16c4c:	4620      	mov	r0, r4
   16c4e:	1c79      	adds	r1, r7, #1
		i = p->offset;
   16c50:	f8d4 9008 	ldr.w	r9, [r4, #8]
		ptr = ensure(p, len + 1);
   16c54:	f7ff fd40 	bl	166d8 <ensure>
		if (!ptr)
   16c58:	2800      	cmp	r0, #0
   16c5a:	d0be      	beq.n	16bda <print_object.isra.3+0x2e>
		*ptr++ = '{';
   16c5c:	237b      	movs	r3, #123	; 0x7b
   16c5e:	7003      	strb	r3, [r0, #0]
		if (fmt)
   16c60:	b9f5      	cbnz	r5, 16ca0 <print_object.isra.3+0xf4>
		*ptr++ = '{';
   16c62:	1c43      	adds	r3, r0, #1
		*ptr = 0;
   16c64:	2200      	movs	r2, #0
					*ptr++ = '\t';
   16c66:	f04f 0a09 	mov.w	sl, #9
		*ptr = 0;
   16c6a:	701a      	strb	r2, [r3, #0]
		p->offset += len;
   16c6c:	68a3      	ldr	r3, [r4, #8]
		child = item->child;
   16c6e:	f8d8 6000 	ldr.w	r6, [r8]
		p->offset += len;
   16c72:	443b      	add	r3, r7
   16c74:	60a3      	str	r3, [r4, #8]
		depth++;
   16c76:	f10b 0801 	add.w	r8, fp, #1
		while (child) {
   16c7a:	b9ae      	cbnz	r6, 16ca8 <print_object.isra.3+0xfc>
		ptr = ensure(p, fmt ? (depth + 1) : 2);
   16c7c:	2d00      	cmp	r5, #0
   16c7e:	d066      	beq.n	16d4e <print_object.isra.3+0x1a2>
   16c80:	f10b 0102 	add.w	r1, fp, #2
   16c84:	4620      	mov	r0, r4
   16c86:	f7ff fd27 	bl	166d8 <ensure>
		if (!ptr)
   16c8a:	2800      	cmp	r0, #0
   16c8c:	d0a5      	beq.n	16bda <print_object.isra.3+0x2e>
		if (fmt)
   16c8e:	2d00      	cmp	r5, #0
   16c90:	d167      	bne.n	16d62 <print_object.isra.3+0x1b6>
		*ptr++ = '}';
   16c92:	237d      	movs	r3, #125	; 0x7d
   16c94:	7003      	strb	r3, [r0, #0]
		*ptr = 0;
   16c96:	2300      	movs	r3, #0
   16c98:	7043      	strb	r3, [r0, #1]
		out = (p->buffer) + i;
   16c9a:	6824      	ldr	r4, [r4, #0]
   16c9c:	444c      	add	r4, r9
   16c9e:	e7b6      	b.n	16c0e <print_object.isra.3+0x62>
			*ptr++ = '\n';
   16ca0:	220a      	movs	r2, #10
   16ca2:	1c83      	adds	r3, r0, #2
   16ca4:	7042      	strb	r2, [r0, #1]
   16ca6:	e7dd      	b.n	16c64 <print_object.isra.3+0xb8>
			if (fmt) {
   16ca8:	b15d      	cbz	r5, 16cc2 <print_object.isra.3+0x116>
				ptr = ensure(p, depth);
   16caa:	4641      	mov	r1, r8
   16cac:	4620      	mov	r0, r4
   16cae:	f7ff fd13 	bl	166d8 <ensure>
				if (!ptr)
   16cb2:	2800      	cmp	r0, #0
   16cb4:	d091      	beq.n	16bda <print_object.isra.3+0x2e>
				for (j = 0; j < depth; j++)
   16cb6:	2300      	movs	r3, #0
   16cb8:	4598      	cmp	r8, r3
   16cba:	dc44      	bgt.n	16d46 <print_object.isra.3+0x19a>
				p->offset += depth;
   16cbc:	68a3      	ldr	r3, [r4, #8]
   16cbe:	4443      	add	r3, r8
   16cc0:	60a3      	str	r3, [r4, #8]
			print_string_ptr(child->string, p);
   16cc2:	4621      	mov	r1, r4
   16cc4:	6a30      	ldr	r0, [r6, #32]
   16cc6:	f7ff fd55 	bl	16774 <print_string_ptr>
			p->offset = update(p);
   16cca:	4620      	mov	r0, r4
   16ccc:	f01c f85c 	bl	32d88 <update>
			ptr = ensure(p, len);
   16cd0:	4639      	mov	r1, r7
			p->offset = update(p);
   16cd2:	60a0      	str	r0, [r4, #8]
			ptr = ensure(p, len);
   16cd4:	4620      	mov	r0, r4
   16cd6:	f7ff fcff 	bl	166d8 <ensure>
			if (!ptr)
   16cda:	2800      	cmp	r0, #0
   16cdc:	f43f af7d 	beq.w	16bda <print_object.isra.3+0x2e>
			*ptr++ = ':';
   16ce0:	f04f 033a 	mov.w	r3, #58	; 0x3a
   16ce4:	7003      	strb	r3, [r0, #0]
			if (fmt)
   16ce6:	b10d      	cbz	r5, 16cec <print_object.isra.3+0x140>
				*ptr++ = '\t';
   16ce8:	f880 a001 	strb.w	sl, [r0, #1]
			p->offset += len;
   16cec:	68a3      	ldr	r3, [r4, #8]
			print_value(child, depth, fmt, p);
   16cee:	462a      	mov	r2, r5
			p->offset += len;
   16cf0:	443b      	add	r3, r7
			print_value(child, depth, fmt, p);
   16cf2:	4641      	mov	r1, r8
			p->offset += len;
   16cf4:	60a3      	str	r3, [r4, #8]
			print_value(child, depth, fmt, p);
   16cf6:	4630      	mov	r0, r6
   16cf8:	4623      	mov	r3, r4
   16cfa:	f7ff fef5 	bl	16ae8 <print_value>
			p->offset = update(p);
   16cfe:	4620      	mov	r0, r4
   16d00:	f01c f842 	bl	32d88 <update>
			len = (fmt ? 1 : 0) + (child->next ? 1 : 0);
   16d04:	1c2b      	adds	r3, r5, #0
   16d06:	bf18      	it	ne
   16d08:	2301      	movne	r3, #1
   16d0a:	6832      	ldr	r2, [r6, #0]
			p->offset = update(p);
   16d0c:	60a0      	str	r0, [r4, #8]
			len = (fmt ? 1 : 0) + (child->next ? 1 : 0);
   16d0e:	2a00      	cmp	r2, #0
   16d10:	bf18      	it	ne
   16d12:	3301      	addne	r3, #1
			ptr = ensure(p, len + 1);
   16d14:	4620      	mov	r0, r4
   16d16:	1c59      	adds	r1, r3, #1
   16d18:	9300      	str	r3, [sp, #0]
   16d1a:	f7ff fcdd 	bl	166d8 <ensure>
			if (!ptr)
   16d1e:	2800      	cmp	r0, #0
   16d20:	f43f af5b 	beq.w	16bda <print_object.isra.3+0x2e>
			if (child->next)
   16d24:	6832      	ldr	r2, [r6, #0]
   16d26:	9b00      	ldr	r3, [sp, #0]
   16d28:	b112      	cbz	r2, 16d30 <print_object.isra.3+0x184>
				*ptr++ = ',';
   16d2a:	222c      	movs	r2, #44	; 0x2c
   16d2c:	f800 2b01 	strb.w	r2, [r0], #1
			if (fmt) {
   16d30:	b115      	cbz	r5, 16d38 <print_object.isra.3+0x18c>
				*ptr++ = '\n';
   16d32:	220a      	movs	r2, #10
   16d34:	f800 2b01 	strb.w	r2, [r0], #1
			*ptr = 0;
   16d38:	2200      	movs	r2, #0
   16d3a:	7002      	strb	r2, [r0, #0]
			p->offset += len;
   16d3c:	68a2      	ldr	r2, [r4, #8]
			child = child->next;
   16d3e:	6836      	ldr	r6, [r6, #0]
			p->offset += len;
   16d40:	4413      	add	r3, r2
   16d42:	60a3      	str	r3, [r4, #8]
			child = child->next;
   16d44:	e799      	b.n	16c7a <print_object.isra.3+0xce>
					*ptr++ = '\t';
   16d46:	f800 a003 	strb.w	sl, [r0, r3]
				for (j = 0; j < depth; j++)
   16d4a:	3301      	adds	r3, #1
   16d4c:	e7b4      	b.n	16cb8 <print_object.isra.3+0x10c>
		ptr = ensure(p, fmt ? (depth + 1) : 2);
   16d4e:	2102      	movs	r1, #2
   16d50:	e798      	b.n	16c84 <print_object.isra.3+0xd8>
				*ptr++ = '\t';
   16d52:	54c2      	strb	r2, [r0, r3]
			for (i = 0; i < depth - 1; i++)
   16d54:	3301      	adds	r3, #1
   16d56:	459b      	cmp	fp, r3
   16d58:	dcfb      	bgt.n	16d52 <print_object.isra.3+0x1a6>
   16d5a:	ea2b 79eb 	bic.w	r9, fp, fp, asr #31
   16d5e:	4448      	add	r0, r9
   16d60:	e797      	b.n	16c92 <print_object.isra.3+0xe6>
   16d62:	2300      	movs	r3, #0
				*ptr++ = '\t';
   16d64:	2209      	movs	r2, #9
   16d66:	e7f6      	b.n	16d56 <print_object.isra.3+0x1aa>
		entries = (char **)cJSON_malloc(numentries * sizeof(char *));
   16d68:	9b00      	ldr	r3, [sp, #0]
   16d6a:	f8df 90e0 	ldr.w	r9, [pc, #224]	; 16e4c <print_object.isra.3+0x2a0>
   16d6e:	009f      	lsls	r7, r3, #2
   16d70:	4638      	mov	r0, r7
   16d72:	f8d9 3000 	ldr.w	r3, [r9]
   16d76:	4798      	blx	r3
		if (!entries)
   16d78:	4606      	mov	r6, r0
   16d7a:	2800      	cmp	r0, #0
   16d7c:	f43f af2d 	beq.w	16bda <print_object.isra.3+0x2e>
		names = (char **)cJSON_malloc(numentries * sizeof(char *));
   16d80:	f8d9 3000 	ldr.w	r3, [r9]
   16d84:	4638      	mov	r0, r7
   16d86:	4798      	blx	r3
		if (!names) {
   16d88:	9001      	str	r0, [sp, #4]
   16d8a:	b920      	cbnz	r0, 16d96 <print_object.isra.3+0x1ea>
			cJSON_free(entries);
   16d8c:	4b30      	ldr	r3, [pc, #192]	; (16e50 <print_object.isra.3+0x2a4>)
   16d8e:	4630      	mov	r0, r6
   16d90:	681b      	ldr	r3, [r3, #0]
   16d92:	4798      	blx	r3
			return 0;
   16d94:	e73b      	b.n	16c0e <print_object.isra.3+0x62>
__ssp_bos_icheck3(memset, void *, int)
   16d96:	463a      	mov	r2, r7
   16d98:	4621      	mov	r1, r4
   16d9a:	4630      	mov	r0, r6
   16d9c:	f022 f956 	bl	3904c <memset>
   16da0:	463a      	mov	r2, r7
   16da2:	4621      	mov	r1, r4
   16da4:	9801      	ldr	r0, [sp, #4]
   16da6:	f022 f951 	bl	3904c <memset>
		depth++;
   16daa:	f10b 0301 	add.w	r3, fp, #1
		child = item->child;
   16dae:	f8d8 7000 	ldr.w	r7, [r8]
		depth++;
   16db2:	9304      	str	r3, [sp, #16]
		if (fmt)
   16db4:	b31d      	cbz	r5, 16dfe <print_object.isra.3+0x252>
			len += depth;
   16db6:	f10b 0408 	add.w	r4, fp, #8
   16dba:	2d00      	cmp	r5, #0
				       (fmt ? 2 + depth : 0);
   16dbc:	f10b 0303 	add.w	r3, fp, #3
   16dc0:	bf08      	it	eq
   16dc2:	2300      	moveq	r3, #0
   16dc4:	f04f 0a00 	mov.w	sl, #0
   16dc8:	9a01      	ldr	r2, [sp, #4]
				len += strlens(ret) + strlens(str) + 2 +
   16dca:	3302      	adds	r3, #2
   16dcc:	3a04      	subs	r2, #4
   16dce:	9203      	str	r2, [sp, #12]
   16dd0:	1f32      	subs	r2, r6, #4
   16dd2:	9202      	str	r2, [sp, #8]
				       (fmt ? 2 + depth : 0);
   16dd4:	4691      	mov	r9, r2
   16dd6:	9a03      	ldr	r2, [sp, #12]
				len += strlens(ret) + strlens(str) + 2 +
   16dd8:	9306      	str	r3, [sp, #24]
				       (fmt ? 2 + depth : 0);
   16dda:	9205      	str	r2, [sp, #20]
		while (child) {
   16ddc:	b98f      	cbnz	r7, 16e02 <print_object.isra.3+0x256>
		if (!fail)
   16dde:	f1ba 0f00 	cmp.w	sl, #0
   16de2:	d037      	beq.n	16e54 <print_object.isra.3+0x2a8>
   16de4:	4d1a      	ldr	r5, [pc, #104]	; (16e50 <print_object.isra.3+0x2a4>)
				       (fmt ? 2 + depth : 0);
   16de6:	2400      	movs	r4, #0
   16de8:	462f      	mov	r7, r5
			for (i = 0; i < numentries; i++) {
   16dea:	9a00      	ldr	r2, [sp, #0]
   16dec:	682b      	ldr	r3, [r5, #0]
   16dee:	42a2      	cmp	r2, r4
   16df0:	dc5d      	bgt.n	16eae <print_object.isra.3+0x302>
			cJSON_free(names);
   16df2:	9801      	ldr	r0, [sp, #4]
   16df4:	4798      	blx	r3
			cJSON_free(entries);
   16df6:	682b      	ldr	r3, [r5, #0]
   16df8:	4630      	mov	r0, r6
   16dfa:	4798      	blx	r3
   16dfc:	e6ed      	b.n	16bda <print_object.isra.3+0x2e>
	int len = 7, i = 0, j;
   16dfe:	2407      	movs	r4, #7
   16e00:	e7db      	b.n	16dba <print_object.isra.3+0x20e>
			names[i] = str = print_string_ptr(child->string, 0);
   16e02:	2100      	movs	r1, #0
   16e04:	6a38      	ldr	r0, [r7, #32]
   16e06:	f7ff fcb5 	bl	16774 <print_string_ptr>
   16e0a:	9b05      	ldr	r3, [sp, #20]
   16e0c:	4680      	mov	r8, r0
   16e0e:	f843 0f04 	str.w	r0, [r3, #4]!
   16e12:	9305      	str	r3, [sp, #20]
			entries[i++] = ret = print_value(child, depth, fmt, 0);
   16e14:	462a      	mov	r2, r5
   16e16:	2300      	movs	r3, #0
   16e18:	9904      	ldr	r1, [sp, #16]
   16e1a:	4638      	mov	r0, r7
   16e1c:	f7ff fe64 	bl	16ae8 <print_value>
   16e20:	f849 0f04 	str.w	r0, [r9, #4]!
			if (str && ret)
   16e24:	f1b8 0f00 	cmp.w	r8, #0
   16e28:	d00d      	beq.n	16e46 <print_object.isra.3+0x29a>
   16e2a:	b160      	cbz	r0, 16e46 <print_object.isra.3+0x29a>
				len += strlens(ret) + strlens(str) + 2 +
   16e2c:	f7fb f928 	bl	12080 <strlen>
   16e30:	9007      	str	r0, [sp, #28]
   16e32:	4640      	mov	r0, r8
   16e34:	f7fb f924 	bl	12080 <strlen>
   16e38:	9b06      	ldr	r3, [sp, #24]
   16e3a:	441c      	add	r4, r3
   16e3c:	9b07      	ldr	r3, [sp, #28]
   16e3e:	441c      	add	r4, r3
   16e40:	4404      	add	r4, r0
			child = child->next;
   16e42:	683f      	ldr	r7, [r7, #0]
   16e44:	e7ca      	b.n	16ddc <print_object.isra.3+0x230>
				fail = 1;
   16e46:	f04f 0a01 	mov.w	sl, #1
   16e4a:	e7fa      	b.n	16e42 <print_object.isra.3+0x296>
   16e4c:	20020080 	.word	0x20020080
   16e50:	2002007c 	.word	0x2002007c
			out = (char *)cJSON_malloc(len);
   16e54:	4b4a      	ldr	r3, [pc, #296]	; (16f80 <print_object.isra.3+0x3d4>)
   16e56:	4620      	mov	r0, r4
   16e58:	681b      	ldr	r3, [r3, #0]
   16e5a:	4798      	blx	r3
		if (!out)
   16e5c:	4604      	mov	r4, r0
   16e5e:	2800      	cmp	r0, #0
   16e60:	d0c0      	beq.n	16de4 <print_object.isra.3+0x238>
		*out = '{';
   16e62:	237b      	movs	r3, #123	; 0x7b
   16e64:	7003      	strb	r3, [r0, #0]
		if (fmt)
   16e66:	bb75      	cbnz	r5, 16ec6 <print_object.isra.3+0x31a>
		ptr = out + 1;
   16e68:	1c47      	adds	r7, r0, #1
		*ptr = 0;
   16e6a:	f04f 0900 	mov.w	r9, #0
   16e6e:	9b04      	ldr	r3, [sp, #16]
   16e70:	f887 9000 	strb.w	r9, [r7]
		for (i = 0; i < numentries; i++) {
   16e74:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
   16e78:	9305      	str	r3, [sp, #20]
   16e7a:	9b00      	ldr	r3, [sp, #0]
   16e7c:	454b      	cmp	r3, r9
   16e7e:	dc26      	bgt.n	16ece <print_object.isra.3+0x322>
		cJSON_free(names);
   16e80:	f8df 8100 	ldr.w	r8, [pc, #256]	; 16f84 <print_object.isra.3+0x3d8>
   16e84:	9801      	ldr	r0, [sp, #4]
   16e86:	f8d8 3000 	ldr.w	r3, [r8]
   16e8a:	4798      	blx	r3
		cJSON_free(entries);
   16e8c:	f8d8 3000 	ldr.w	r3, [r8]
   16e90:	4630      	mov	r0, r6
   16e92:	4798      	blx	r3
		if (fmt)
   16e94:	b135      	cbz	r5, 16ea4 <print_object.isra.3+0x2f8>
				*ptr++ = '\t';
   16e96:	2309      	movs	r3, #9
			for (i = 0; i < depth - 1; i++)
   16e98:	45d3      	cmp	fp, sl
   16e9a:	dc6b      	bgt.n	16f74 <print_object.isra.3+0x3c8>
   16e9c:	f1bb 0f00 	cmp.w	fp, #0
   16ea0:	bfa8      	it	ge
   16ea2:	445f      	addge	r7, fp
		*ptr++ = '}';
   16ea4:	237d      	movs	r3, #125	; 0x7d
   16ea6:	703b      	strb	r3, [r7, #0]
		*ptr++ = 0;
   16ea8:	2300      	movs	r3, #0
   16eaa:	707b      	strb	r3, [r7, #1]
   16eac:	e6af      	b.n	16c0e <print_object.isra.3+0x62>
				if (names[i])
   16eae:	9a01      	ldr	r2, [sp, #4]
   16eb0:	f852 0024 	ldr.w	r0, [r2, r4, lsl #2]
   16eb4:	b100      	cbz	r0, 16eb8 <print_object.isra.3+0x30c>
					cJSON_free(names[i]);
   16eb6:	4798      	blx	r3
				if (entries[i])
   16eb8:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
   16ebc:	b108      	cbz	r0, 16ec2 <print_object.isra.3+0x316>
					cJSON_free(entries[i]);
   16ebe:	683b      	ldr	r3, [r7, #0]
   16ec0:	4798      	blx	r3
			for (i = 0; i < numentries; i++) {
   16ec2:	3401      	adds	r4, #1
   16ec4:	e791      	b.n	16dea <print_object.isra.3+0x23e>
			*ptr++ = '\n';
   16ec6:	230a      	movs	r3, #10
   16ec8:	1c87      	adds	r7, r0, #2
   16eca:	7043      	strb	r3, [r0, #1]
   16ecc:	e7cd      	b.n	16e6a <print_object.isra.3+0x2be>
			if (fmt)
   16ece:	b155      	cbz	r5, 16ee6 <print_object.isra.3+0x33a>
				for (j = 0; j < depth; j++)
   16ed0:	2300      	movs	r3, #0
   16ed2:	e003      	b.n	16edc <print_object.isra.3+0x330>
					*ptr++ = '\t';
   16ed4:	f04f 0209 	mov.w	r2, #9
   16ed8:	54fa      	strb	r2, [r7, r3]
				for (j = 0; j < depth; j++)
   16eda:	3301      	adds	r3, #1
   16edc:	9a04      	ldr	r2, [sp, #16]
   16ede:	429a      	cmp	r2, r3
   16ee0:	dcf8      	bgt.n	16ed4 <print_object.isra.3+0x328>
   16ee2:	9b05      	ldr	r3, [sp, #20]
   16ee4:	441f      	add	r7, r3
			tmplen = strlens(names[i]);
   16ee6:	9b03      	ldr	r3, [sp, #12]
   16ee8:	6858      	ldr	r0, [r3, #4]
   16eea:	b108      	cbz	r0, 16ef0 <print_object.isra.3+0x344>
   16eec:	f7fb f8c8 	bl	12080 <strlen>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   16ef0:	9b03      	ldr	r3, [sp, #12]
   16ef2:	4680      	mov	r8, r0
   16ef4:	4602      	mov	r2, r0
   16ef6:	6859      	ldr	r1, [r3, #4]
   16ef8:	4638      	mov	r0, r7
   16efa:	f022 f86d 	bl	38fd8 <memcpy>
			*ptr++ = ':';
   16efe:	223a      	movs	r2, #58	; 0x3a
			ptr += tmplen;
   16f00:	eb07 0308 	add.w	r3, r7, r8
			*ptr++ = ':';
   16f04:	f807 2008 	strb.w	r2, [r7, r8]
			if (fmt)
   16f08:	bb75      	cbnz	r5, 16f68 <print_object.isra.3+0x3bc>
			*ptr++ = ':';
   16f0a:	f103 0801 	add.w	r8, r3, #1
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   16f0e:	9b02      	ldr	r3, [sp, #8]
   16f10:	4640      	mov	r0, r8
   16f12:	6859      	ldr	r1, [r3, #4]
   16f14:	f022 f9ee 	bl	392f4 <strcpy>
			ptr += strlens(entries[i]);
   16f18:	9b02      	ldr	r3, [sp, #8]
   16f1a:	6858      	ldr	r0, [r3, #4]
   16f1c:	b108      	cbz	r0, 16f22 <print_object.isra.3+0x376>
   16f1e:	f7fb f8af 	bl	12080 <strlen>
			if (i != numentries - 1)
   16f22:	9b00      	ldr	r3, [sp, #0]
			ptr += strlens(entries[i]);
   16f24:	eb08 0700 	add.w	r7, r8, r0
			if (i != numentries - 1)
   16f28:	3b01      	subs	r3, #1
   16f2a:	4599      	cmp	r9, r3
				*ptr++ = ',';
   16f2c:	bf1e      	ittt	ne
   16f2e:	232c      	movne	r3, #44	; 0x2c
   16f30:	3701      	addne	r7, #1
   16f32:	f808 3000 	strbne.w	r3, [r8, r0]
			if (fmt) {
   16f36:	b115      	cbz	r5, 16f3e <print_object.isra.3+0x392>
				*ptr++ = '\n';
   16f38:	230a      	movs	r3, #10
   16f3a:	f807 3b01 	strb.w	r3, [r7], #1
			*ptr = 0;
   16f3e:	2300      	movs	r3, #0
			cJSON_free(names[i]);
   16f40:	9a03      	ldr	r2, [sp, #12]
			*ptr = 0;
   16f42:	703b      	strb	r3, [r7, #0]
			cJSON_free(names[i]);
   16f44:	f8df 803c 	ldr.w	r8, [pc, #60]	; 16f84 <print_object.isra.3+0x3d8>
   16f48:	f852 0f04 	ldr.w	r0, [r2, #4]!
   16f4c:	f8d8 3000 	ldr.w	r3, [r8]
   16f50:	9203      	str	r2, [sp, #12]
   16f52:	4798      	blx	r3
			cJSON_free(entries[i]);
   16f54:	9a02      	ldr	r2, [sp, #8]
   16f56:	f8d8 3000 	ldr.w	r3, [r8]
   16f5a:	f852 0f04 	ldr.w	r0, [r2, #4]!
		for (i = 0; i < numentries; i++) {
   16f5e:	f109 0901 	add.w	r9, r9, #1
			cJSON_free(entries[i]);
   16f62:	9202      	str	r2, [sp, #8]
   16f64:	4798      	blx	r3
   16f66:	e788      	b.n	16e7a <print_object.isra.3+0x2ce>
				*ptr++ = '\t';
   16f68:	f04f 0209 	mov.w	r2, #9
   16f6c:	f103 0802 	add.w	r8, r3, #2
   16f70:	705a      	strb	r2, [r3, #1]
   16f72:	e7cc      	b.n	16f0e <print_object.isra.3+0x362>
				*ptr++ = '\t';
   16f74:	f807 300a 	strb.w	r3, [r7, sl]
			for (i = 0; i < depth - 1; i++)
   16f78:	f10a 0a01 	add.w	sl, sl, #1
   16f7c:	e78c      	b.n	16e98 <print_object.isra.3+0x2ec>
   16f7e:	bf00      	nop
   16f80:	20020080 	.word	0x20020080
   16f84:	2002007c 	.word	0x2002007c

00016f88 <cJSON_Delete>:
{
   16f88:	b570      	push	{r4, r5, r6, lr}
   16f8a:	4604      	mov	r4, r0
   16f8c:	4d0f      	ldr	r5, [pc, #60]	; (16fcc <cJSON_Delete+0x44>)
	while (c) {
   16f8e:	b904      	cbnz	r4, 16f92 <cJSON_Delete+0xa>
}
   16f90:	bd70      	pop	{r4, r5, r6, pc}
		if (!(c->type & cJSON_IsReference) && c->child)
   16f92:	68e3      	ldr	r3, [r4, #12]
		next = c->next;
   16f94:	6826      	ldr	r6, [r4, #0]
		if (!(c->type & cJSON_IsReference) && c->child)
   16f96:	05d9      	lsls	r1, r3, #23
   16f98:	d403      	bmi.n	16fa2 <cJSON_Delete+0x1a>
   16f9a:	68a0      	ldr	r0, [r4, #8]
   16f9c:	b968      	cbnz	r0, 16fba <cJSON_Delete+0x32>
		if (!(c->type & cJSON_IsReference) && c->valuestring)
   16f9e:	6920      	ldr	r0, [r4, #16]
   16fa0:	b988      	cbnz	r0, 16fc6 <cJSON_Delete+0x3e>
		if (!(c->type & cJSON_StringIsConst) && c->string)
   16fa2:	68e3      	ldr	r3, [r4, #12]
   16fa4:	059b      	lsls	r3, r3, #22
   16fa6:	d403      	bmi.n	16fb0 <cJSON_Delete+0x28>
   16fa8:	6a20      	ldr	r0, [r4, #32]
   16faa:	b108      	cbz	r0, 16fb0 <cJSON_Delete+0x28>
			cJSON_free(c->string);
   16fac:	682b      	ldr	r3, [r5, #0]
   16fae:	4798      	blx	r3
		cJSON_free(c);
   16fb0:	4620      	mov	r0, r4
   16fb2:	682b      	ldr	r3, [r5, #0]
   16fb4:	4798      	blx	r3
		c = next;
   16fb6:	4634      	mov	r4, r6
   16fb8:	e7e9      	b.n	16f8e <cJSON_Delete+0x6>
			cJSON_Delete(c->child);
   16fba:	f7ff ffe5 	bl	16f88 <cJSON_Delete>
		if (!(c->type & cJSON_IsReference) && c->valuestring)
   16fbe:	68e3      	ldr	r3, [r4, #12]
   16fc0:	05da      	lsls	r2, r3, #23
   16fc2:	d5ec      	bpl.n	16f9e <cJSON_Delete+0x16>
   16fc4:	e7ed      	b.n	16fa2 <cJSON_Delete+0x1a>
			cJSON_free(c->valuestring);
   16fc6:	682b      	ldr	r3, [r5, #0]
   16fc8:	4798      	blx	r3
   16fca:	e7ea      	b.n	16fa2 <cJSON_Delete+0x1a>
   16fcc:	2002007c 	.word	0x2002007c

00016fd0 <cJSON_ParseWithOpts>:
{
   16fd0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   16fd4:	4605      	mov	r5, r0
   16fd6:	460e      	mov	r6, r1
   16fd8:	4691      	mov	r9, r2
	ep = 0;
   16fda:	2700      	movs	r7, #0
	cJSON *c = cJSON_New_Item();
   16fdc:	f7ff fa72 	bl	164c4 <cJSON_New_Item>
	ep = 0;
   16fe0:	f8df 8050 	ldr.w	r8, [pc, #80]	; 17034 <cJSON_ParseWithOpts+0x64>
	if (!c)
   16fe4:	4604      	mov	r4, r0
	ep = 0;
   16fe6:	f8c8 7000 	str.w	r7, [r8]
	if (!c)
   16fea:	b160      	cbz	r0, 17006 <cJSON_ParseWithOpts+0x36>
	end = parse_value(c, skip(value));
   16fec:	4628      	mov	r0, r5
   16fee:	f01b fec2 	bl	32d76 <skip>
   16ff2:	4601      	mov	r1, r0
   16ff4:	4620      	mov	r0, r4
   16ff6:	f7ff fa75 	bl	164e4 <parse_value>
	if (!end) {
   16ffa:	4605      	mov	r5, r0
   16ffc:	b930      	cbnz	r0, 1700c <cJSON_ParseWithOpts+0x3c>
		cJSON_Delete(c);
   16ffe:	4620      	mov	r0, r4
   17000:	f7ff ffc2 	bl	16f88 <cJSON_Delete>
		return 0;
   17004:	462c      	mov	r4, r5
}
   17006:	4620      	mov	r0, r4
   17008:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (require_null_terminated) {
   1700c:	f1b9 0f00 	cmp.w	r9, #0
   17010:	d00b      	beq.n	1702a <cJSON_ParseWithOpts+0x5a>
		end = skip(end);
   17012:	f01b feb0 	bl	32d76 <skip>
		if (*end) {
   17016:	7803      	ldrb	r3, [r0, #0]
		end = skip(end);
   17018:	4605      	mov	r5, r0
		if (*end) {
   1701a:	b133      	cbz	r3, 1702a <cJSON_ParseWithOpts+0x5a>
			cJSON_Delete(c);
   1701c:	4620      	mov	r0, r4
   1701e:	f7ff ffb3 	bl	16f88 <cJSON_Delete>
			return 0;
   17022:	463c      	mov	r4, r7
			ep = end;
   17024:	f8c8 5000 	str.w	r5, [r8]
			return 0;
   17028:	e7ed      	b.n	17006 <cJSON_ParseWithOpts+0x36>
	if (return_parse_end)
   1702a:	2e00      	cmp	r6, #0
   1702c:	d0eb      	beq.n	17006 <cJSON_ParseWithOpts+0x36>
		*return_parse_end = end;
   1702e:	6035      	str	r5, [r6, #0]
   17030:	e7e9      	b.n	17006 <cJSON_ParseWithOpts+0x36>
   17032:	bf00      	nop
   17034:	20021534 	.word	0x20021534

00017038 <cJSON_AddItemToObject>:
			c = c->next;
		suffix_object(c, item);
	}
}
void cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
   17038:	b570      	push	{r4, r5, r6, lr}
   1703a:	4605      	mov	r5, r0
   1703c:	460e      	mov	r6, r1
	if (!item)
   1703e:	4614      	mov	r4, r2
   17040:	b172      	cbz	r2, 17060 <cJSON_AddItemToObject+0x28>
		return;
	if (item->string)
   17042:	6a10      	ldr	r0, [r2, #32]
   17044:	b110      	cbz	r0, 1704c <cJSON_AddItemToObject+0x14>
		cJSON_free(item->string);
   17046:	4b07      	ldr	r3, [pc, #28]	; (17064 <cJSON_AddItemToObject+0x2c>)
   17048:	681b      	ldr	r3, [r3, #0]
   1704a:	4798      	blx	r3
	item->string = cJSON_strdup(string);
   1704c:	4630      	mov	r0, r6
   1704e:	f7ff fb7b 	bl	16748 <cJSON_strdup>
	cJSON_AddItemToArray(object, item);
   17052:	4621      	mov	r1, r4
	item->string = cJSON_strdup(string);
   17054:	6220      	str	r0, [r4, #32]
	cJSON_AddItemToArray(object, item);
   17056:	4628      	mov	r0, r5
}
   17058:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	cJSON_AddItemToArray(object, item);
   1705c:	f01b beaa 	b.w	32db4 <cJSON_AddItemToArray>
}
   17060:	bd70      	pop	{r4, r5, r6, pc}
   17062:	bf00      	nop
   17064:	2002007c 	.word	0x2002007c

00017068 <timer_work_handler>:
bool timer_stopped = true;

/* work handler */
void timer_work_handler(struct k_work *work)
{
	timer_stopped = false;
   17068:	2200      	movs	r2, #0
{
   1706a:	b573      	push	{r0, r1, r4, r5, r6, lr}

	sec += 1;
	uint8_t h, m, s;
	
	h = (sec/3600); 
   1706c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
	timer_stopped = false;
   17070:	4b14      	ldr	r3, [pc, #80]	; (170c4 <timer_work_handler+0x5c>)
	
	m = (sec -(3600*h))/60;
   17072:	203c      	movs	r0, #60	; 0x3c
	timer_stopped = false;
   17074:	701a      	strb	r2, [r3, #0]
	sec += 1;
   17076:	4b14      	ldr	r3, [pc, #80]	; (170c8 <timer_work_handler+0x60>)
	
	s = (sec -(3600*h)-(m*60));

	LOG_DBG("sensor uptime: %d:%d:%d\n",h,m,s);
   17078:	2404      	movs	r4, #4
	sec += 1;
   1707a:	681a      	ldr	r2, [r3, #0]
   1707c:	4e13      	ldr	r6, [pc, #76]	; (170cc <timer_work_handler+0x64>)
   1707e:	3201      	adds	r2, #1
	h = (sec/3600); 
   17080:	fbb2 f5f1 	udiv	r5, r2, r1
	sec += 1;
   17084:	601a      	str	r2, [r3, #0]
	m = (sec -(3600*h))/60;
   17086:	b2eb      	uxtb	r3, r5
   17088:	fb01 2113 	mls	r1, r1, r3, r2
   1708c:	fbb1 f1f0 	udiv	r1, r1, r0
	LOG_DBG("sensor uptime: %d:%d:%d\n",h,m,s);
   17090:	f04f 0000 	mov.w	r0, #0
   17094:	f364 0007 	bfi	r0, r4, #0, #8
   17098:	4c0d      	ldr	r4, [pc, #52]	; (170d0 <timer_work_handler+0x68>)
	s = (sec -(3600*h)-(m*60));
   1709a:	eba2 1205 	sub.w	r2, r2, r5, lsl #4
   1709e:	1ba4      	subs	r4, r4, r6
   170a0:	08e4      	lsrs	r4, r4, #3
	LOG_DBG("sensor uptime: %d:%d:%d\n",h,m,s);
   170a2:	f364 108f 	bfi	r0, r4, #6, #10
	s = (sec -(3600*h)-(m*60));
   170a6:	ebc1 1401 	rsb	r4, r1, r1, lsl #4
   170aa:	eba2 0284 	sub.w	r2, r2, r4, lsl #2
	LOG_DBG("sensor uptime: %d:%d:%d\n",h,m,s);
   170ae:	b2d2      	uxtb	r2, r2
   170b0:	b2c9      	uxtb	r1, r1
   170b2:	9201      	str	r2, [sp, #4]
   170b4:	9100      	str	r1, [sp, #0]
   170b6:	4a07      	ldr	r2, [pc, #28]	; (170d4 <timer_work_handler+0x6c>)
   170b8:	4907      	ldr	r1, [pc, #28]	; (170d8 <timer_work_handler+0x70>)
   170ba:	f01c fd9d 	bl	33bf8 <log_string_sync>
}
   170be:	b002      	add	sp, #8
   170c0:	bd70      	pop	{r4, r5, r6, pc}
   170c2:	bf00      	nop
   170c4:	20020424 	.word	0x20020424
   170c8:	20021568 	.word	0x20021568
   170cc:	00039f60 	.word	0x00039f60
   170d0:	00039f80 	.word	0x00039f80
   170d4:	0003c527 	.word	0x0003c527
   170d8:	0003c801 	.word	0x0003c801

000170dc <timer_stop_work_handler>:

void timer_stop_work_handler(struct k_work *work)
{
	LOG_DBG("BSEC took %d seconds to stabilise", sec);
   170dc:	2304      	movs	r3, #4
   170de:	f04f 0000 	mov.w	r0, #0
   170e2:	4a0a      	ldr	r2, [pc, #40]	; (1710c <timer_stop_work_handler+0x30>)
   170e4:	f363 0007 	bfi	r0, r3, #0, #8
   170e8:	4b09      	ldr	r3, [pc, #36]	; (17110 <timer_stop_work_handler+0x34>)
{
   170ea:	b510      	push	{r4, lr}
   170ec:	1a9b      	subs	r3, r3, r2
	LOG_DBG("BSEC took %d seconds to stabilise", sec);
   170ee:	4c09      	ldr	r4, [pc, #36]	; (17114 <timer_stop_work_handler+0x38>)
   170f0:	08db      	lsrs	r3, r3, #3
   170f2:	f363 108f 	bfi	r0, r3, #6, #10
   170f6:	4a08      	ldr	r2, [pc, #32]	; (17118 <timer_stop_work_handler+0x3c>)
   170f8:	6823      	ldr	r3, [r4, #0]
   170fa:	4908      	ldr	r1, [pc, #32]	; (1711c <timer_stop_work_handler+0x40>)
   170fc:	f01c fd7c 	bl	33bf8 <log_string_sync>
	sec = 0;
   17100:	2300      	movs	r3, #0
	timer_stopped = true;
   17102:	2201      	movs	r2, #1
	sec = 0;
   17104:	6023      	str	r3, [r4, #0]
	timer_stopped = true;
   17106:	4b06      	ldr	r3, [pc, #24]	; (17120 <timer_stop_work_handler+0x44>)
   17108:	701a      	strb	r2, [r3, #0]
}
   1710a:	bd10      	pop	{r4, pc}
   1710c:	00039f60 	.word	0x00039f60
   17110:	00039f80 	.word	0x00039f80
   17114:	20021568 	.word	0x20021568
   17118:	0003c53a 	.word	0x0003c53a
   1711c:	0003c7db 	.word	0x0003c7db
   17120:	20020424 	.word	0x20020424

00017124 <submit_poll_work>:
	return 0;
}

static inline int submit_poll_work(const u32_t delay_s)
{
	return k_delayed_work_submit_to_queue(env_sensors_work_q,
   17124:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   17128:	4b02      	ldr	r3, [pc, #8]	; (17134 <submit_poll_work+0x10>)
   1712a:	4342      	muls	r2, r0
   1712c:	4902      	ldr	r1, [pc, #8]	; (17138 <submit_poll_work+0x14>)
   1712e:	6818      	ldr	r0, [r3, #0]
   17130:	f017 ba20 	b.w	2e574 <k_delayed_work_submit_to_queue>
   17134:	2002155c 	.word	0x2002155c
   17138:	2002153c 	.word	0x2002153c

0001713c <bsec_thread>:
	bsec_iot_loop((void *)k_sleep, get_timestamp_us, output_ready,
   1713c:	f44f 6396 	mov.w	r3, #1200	; 0x4b0
{
   17140:	b507      	push	{r0, r1, r2, lr}
	bsec_iot_loop((void *)k_sleep, get_timestamp_us, output_ready,
   17142:	4a05      	ldr	r2, [pc, #20]	; (17158 <bsec_thread+0x1c>)
   17144:	9300      	str	r3, [sp, #0]
   17146:	4905      	ldr	r1, [pc, #20]	; (1715c <bsec_thread+0x20>)
   17148:	4b05      	ldr	r3, [pc, #20]	; (17160 <bsec_thread+0x24>)
   1714a:	4806      	ldr	r0, [pc, #24]	; (17164 <bsec_thread+0x28>)
   1714c:	f000 fdb6 	bl	17cbc <bsec_iot_loop>
}
   17150:	b003      	add	sp, #12
   17152:	f85d fb04 	ldr.w	pc, [sp], #4
   17156:	bf00      	nop
   17158:	00017255 	.word	0x00017255
   1715c:	00032e25 	.word	0x00032e25
   17160:	00017169 	.word	0x00017169
   17164:	00032e49 	.word	0x00032e49

00017168 <state_save>:
	settings_save_one("bsec/state", state_buffer, length);
   17168:	460a      	mov	r2, r1
   1716a:	4601      	mov	r1, r0
   1716c:	4801      	ldr	r0, [pc, #4]	; (17174 <state_save+0xc>)
   1716e:	f002 bd81 	b.w	19c74 <settings_save_one>
   17172:	bf00      	nop
   17174:	0003c7d0 	.word	0x0003c7d0

00017178 <settings_set>:
{
   17178:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1717c:	460d      	mov	r5, r1
	if (!strcmp(key, "state")) {
   1717e:	490b      	ldr	r1, [pc, #44]	; (171ac <settings_set+0x34>)
{
   17180:	4617      	mov	r7, r2
   17182:	4698      	mov	r8, r3
	if (!strcmp(key, "state")) {
   17184:	f7fa ff72 	bl	1206c <strcmp>
   17188:	4e09      	ldr	r6, [pc, #36]	; (171b0 <settings_set+0x38>)
   1718a:	4604      	mov	r4, r0
   1718c:	b130      	cbz	r0, 1719c <settings_set+0x24>
	s_state_buffer_len = 0;
   1718e:	2300      	movs	r3, #0
	return -1;
   17190:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	s_state_buffer_len = 0;
   17194:	6033      	str	r3, [r6, #0]
}
   17196:	4620      	mov	r0, r4
   17198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		s_state_buffer_len = len_rd;
   1719c:	6035      	str	r5, [r6, #0]
		if (read_cb(cb_arg, s_state_buffer, len_rd) > 0) {
   1719e:	462a      	mov	r2, r5
   171a0:	4904      	ldr	r1, [pc, #16]	; (171b4 <settings_set+0x3c>)
   171a2:	4640      	mov	r0, r8
   171a4:	47b8      	blx	r7
   171a6:	2800      	cmp	r0, #0
   171a8:	dcf5      	bgt.n	17196 <settings_set+0x1e>
   171aa:	e7f0      	b.n	1718e <settings_set+0x16>
   171ac:	0003c7d5 	.word	0x0003c7d5
   171b0:	20021564 	.word	0x20021564
   171b4:	20027f28 	.word	0x20027f28

000171b8 <state_load>:
	if ((s_state_buffer_len > 0) && (s_state_buffer_len <= n_buffer)) {
   171b8:	4b07      	ldr	r3, [pc, #28]	; (171d8 <state_load+0x20>)
{
   171ba:	b510      	push	{r4, lr}
	if ((s_state_buffer_len > 0) && (s_state_buffer_len <= n_buffer)) {
   171bc:	681c      	ldr	r4, [r3, #0]
   171be:	2c00      	cmp	r4, #0
   171c0:	dd07      	ble.n	171d2 <state_load+0x1a>
   171c2:	428c      	cmp	r4, r1
   171c4:	d805      	bhi.n	171d2 <state_load+0x1a>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   171c6:	4622      	mov	r2, r4
   171c8:	4904      	ldr	r1, [pc, #16]	; (171dc <state_load+0x24>)
   171ca:	f021 ff05 	bl	38fd8 <memcpy>
}
   171ce:	4620      	mov	r0, r4
   171d0:	bd10      	pop	{r4, pc}
		return 0;
   171d2:	2400      	movs	r4, #0
   171d4:	e7fb      	b.n	171ce <state_load+0x16>
   171d6:	bf00      	nop
   171d8:	20021564 	.word	0x20021564
   171dc:	20027f28 	.word	0x20027f28

000171e0 <env_sensors_poll_fn>:
{
	return initialized ? submit_poll_work(0) : -ENXIO;
}

static void env_sensors_poll_fn(struct k_work *work)
{
   171e0:	b510      	push	{r4, lr}

	if (data_send_interval_s == 0) {
   171e2:	4c09      	ldr	r4, [pc, #36]	; (17208 <env_sensors_poll_fn+0x28>)
   171e4:	6822      	ldr	r2, [r4, #0]
   171e6:	b16a      	cbz	r2, 17204 <env_sensors_poll_fn+0x24>
		return;
	}

	if (data_ready_cb) {
   171e8:	4b08      	ldr	r3, [pc, #32]	; (1720c <env_sensors_poll_fn+0x2c>)
   171ea:	681b      	ldr	r3, [r3, #0]
   171ec:	b103      	cbz	r3, 171f0 <env_sensors_poll_fn+0x10>
		data_ready_cb();
   171ee:	4798      	blx	r3
	}

	submit_poll_work(backoff_enabled ?
   171f0:	4b07      	ldr	r3, [pc, #28]	; (17210 <env_sensors_poll_fn+0x30>)
   171f2:	781b      	ldrb	r3, [r3, #0]
   171f4:	b923      	cbnz	r3, 17200 <env_sensors_poll_fn+0x20>
   171f6:	6820      	ldr	r0, [r4, #0]
		CONFIG_ENVIRONMENT_DATA_BACKOFF_TIME : data_send_interval_s);
}
   171f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	submit_poll_work(backoff_enabled ?
   171fc:	f7ff bf92 	b.w	17124 <submit_poll_work>
   17200:	2014      	movs	r0, #20
   17202:	e7f9      	b.n	171f8 <env_sensors_poll_fn+0x18>
}
   17204:	bd10      	pop	{r4, pc}
   17206:	bf00      	nop
   17208:	20020088 	.word	0x20020088
   1720c:	20021538 	.word	0x20021538
   17210:	20027f25 	.word	0x20027f25

00017214 <bus_read>:
{
   17214:	b530      	push	{r4, r5, lr}
   17216:	b089      	sub	sp, #36	; 0x24
   17218:	f88d 1007 	strb.w	r1, [sp, #7]
	return i2c_write_read(i2c_master, dev_addr, &reg_addr,
   1721c:	490c      	ldr	r1, [pc, #48]	; (17250 <bus_read+0x3c>)
{
   1721e:	4605      	mov	r5, r0
	return i2c_write_read(i2c_master, dev_addr, &reg_addr,
   17220:	6808      	ldr	r0, [r1, #0]
				 const void *write_buf, size_t num_write,
				 void *read_buf, size_t num_read)
{
	struct i2c_msg msg[2];

	msg[0].buf = (u8_t *)write_buf;
   17222:	f10d 0107 	add.w	r1, sp, #7
   17226:	9102      	str	r1, [sp, #8]
	msg[0].len = num_write;
   17228:	2101      	movs	r1, #1
   1722a:	e9cd 2305 	strd	r2, r3, [sp, #20]
   1722e:	9103      	str	r1, [sp, #12]
	msg[0].flags = I2C_MSG_WRITE;

	msg[1].buf = (u8_t *)read_buf;
	msg[1].len = num_read;
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   17230:	2307      	movs	r3, #7
	msg[0].flags = I2C_MSG_WRITE;
   17232:	2100      	movs	r1, #0
	msg[1].flags = I2C_MSG_RESTART | I2C_MSG_READ | I2C_MSG_STOP;
   17234:	f88d 301c 	strb.w	r3, [sp, #28]
	msg[0].flags = I2C_MSG_WRITE;
   17238:	f88d 1010 	strb.w	r1, [sp, #16]
	return api->transfer(dev, msgs, num_msgs, addr);
   1723c:	6883      	ldr	r3, [r0, #8]
   1723e:	2202      	movs	r2, #2
   17240:	685c      	ldr	r4, [r3, #4]
   17242:	a902      	add	r1, sp, #8
   17244:	462b      	mov	r3, r5
   17246:	47a0      	blx	r4
}
   17248:	b240      	sxtb	r0, r0
   1724a:	b009      	add	sp, #36	; 0x24
   1724c:	bd30      	pop	{r4, r5, pc}
   1724e:	bf00      	nop
   17250:	20021560 	.word	0x20021560

00017254 <output_ready>:
{
   17254:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17258:	ed2d 8b04 	vpush	{d8-d9}
   1725c:	461f      	mov	r7, r3
	if (!iaq_reading_ok) {
   1725e:	4b44      	ldr	r3, [pc, #272]	; (17370 <output_ready+0x11c>)
{
   17260:	4615      	mov	r5, r2
	if (!iaq_reading_ok) {
   17262:	781a      	ldrb	r2, [r3, #0]
{
   17264:	b083      	sub	sp, #12
   17266:	4680      	mov	r8, r0
   17268:	4689      	mov	r9, r1
   1726a:	ee10 6a10 	vmov	r6, s0
   1726e:	eef0 8a60 	vmov.f32	s17, s1
   17272:	ee11 ba10 	vmov	fp, s2
   17276:	eeb0 8a61 	vmov.f32	s16, s3
   1727a:	eeb0 9a63 	vmov.f32	s18, s7
   1727e:	469a      	mov	sl, r3
	if (!iaq_reading_ok) {
   17280:	b92a      	cbnz	r2, 1728e <output_ready+0x3a>
	z_impl_k_timer_start(timer, duration, period);
   17282:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   17286:	483b      	ldr	r0, [pc, #236]	; (17374 <output_ready+0x120>)
   17288:	4611      	mov	r1, r2
   1728a:	f017 fda9 	bl	2ede0 <z_impl_k_timer_start>
	if (timer_stopped && iaq_reading_ok) {
   1728e:	4b3a      	ldr	r3, [pc, #232]	; (17378 <output_ready+0x124>)
   17290:	4c3a      	ldr	r4, [pc, #232]	; (1737c <output_ready+0x128>)
   17292:	1ae4      	subs	r4, r4, r3
   17294:	4b3a      	ldr	r3, [pc, #232]	; (17380 <output_ready+0x12c>)
   17296:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1729a:	781b      	ldrb	r3, [r3, #0]
   1729c:	2b00      	cmp	r3, #0
   1729e:	d04b      	beq.n	17338 <output_ready+0xe4>
   172a0:	f89a 3000 	ldrb.w	r3, [sl]
   172a4:	2b00      	cmp	r3, #0
   172a6:	d047      	beq.n	17338 <output_ready+0xe4>
		LOG_DBG("timestamp, %d", timestamp);
   172a8:	2304      	movs	r3, #4
   172aa:	f04f 0000 	mov.w	r0, #0
   172ae:	f363 0007 	bfi	r0, r3, #0, #8
   172b2:	f364 108f 	bfi	r0, r4, #6, #10
   172b6:	4a33      	ldr	r2, [pc, #204]	; (17384 <output_ready+0x130>)
   172b8:	4933      	ldr	r1, [pc, #204]	; (17388 <output_ready+0x134>)
   172ba:	e9cd 8900 	strd	r8, r9, [sp]
   172be:	f01c fc9b 	bl	33bf8 <log_string_sync>
		LOG_DBG("BSEC return code, %d", bsec_status);
   172c2:	2304      	movs	r3, #4
   172c4:	f04f 0000 	mov.w	r0, #0
   172c8:	f363 0007 	bfi	r0, r3, #0, #8
   172cc:	4a2d      	ldr	r2, [pc, #180]	; (17384 <output_ready+0x130>)
   172ce:	463b      	mov	r3, r7
   172d0:	f364 108f 	bfi	r0, r4, #6, #10
   172d4:	492d      	ldr	r1, [pc, #180]	; (1738c <output_ready+0x138>)
   172d6:	f01c fc8f 	bl	33bf8 <log_string_sync>
		LOG_DBG("IAQ reading, %d", iaq);
   172da:	f04f 0700 	mov.w	r7, #0
   172de:	2304      	movs	r3, #4
   172e0:	4630      	mov	r0, r6
   172e2:	f363 0707 	bfi	r7, r3, #0, #8
   172e6:	f7f5 fe89 	bl	cffc <__aeabi_f2d>
   172ea:	f364 178f 	bfi	r7, r4, #6, #10
   172ee:	e9cd 0100 	strd	r0, r1, [sp]
   172f2:	4a24      	ldr	r2, [pc, #144]	; (17384 <output_ready+0x130>)
   172f4:	4638      	mov	r0, r7
   172f6:	4926      	ldr	r1, [pc, #152]	; (17390 <output_ready+0x13c>)
   172f8:	f01c fc7e 	bl	33bf8 <log_string_sync>
		LOG_DBG("Static IAQ reading, %d", static_iaq);
   172fc:	f04f 0700 	mov.w	r7, #0
   17300:	2304      	movs	r3, #4
   17302:	ee19 0a10 	vmov	r0, s18
   17306:	f363 0707 	bfi	r7, r3, #0, #8
   1730a:	f7f5 fe77 	bl	cffc <__aeabi_f2d>
   1730e:	f364 178f 	bfi	r7, r4, #6, #10
   17312:	e9cd 0100 	strd	r0, r1, [sp]
   17316:	4a1b      	ldr	r2, [pc, #108]	; (17384 <output_ready+0x130>)
   17318:	491e      	ldr	r1, [pc, #120]	; (17394 <output_ready+0x140>)
   1731a:	4638      	mov	r0, r7
   1731c:	f01c fc6c 	bl	33bf8 <log_string_sync>
		LOG_DBG("IAQ accuracy, %d", iaq_accuracy);
   17320:	2304      	movs	r3, #4
   17322:	f04f 0000 	mov.w	r0, #0
   17326:	f363 0007 	bfi	r0, r3, #0, #8
   1732a:	f364 108f 	bfi	r0, r4, #6, #10
   1732e:	462b      	mov	r3, r5
   17330:	4a14      	ldr	r2, [pc, #80]	; (17384 <output_ready+0x130>)
   17332:	4919      	ldr	r1, [pc, #100]	; (17398 <output_ready+0x144>)
   17334:	f01c fc60 	bl	33bf8 <log_string_sync>
			LOG_DBG("IAQ calibration unknown [%d]\n", iaq_accuracy);
   17338:	f04f 0000 	mov.w	r0, #0
   1733c:	2304      	movs	r3, #4
   1733e:	f363 0007 	bfi	r0, r3, #0, #8
   17342:	f364 108f 	bfi	r0, r4, #6, #10
	switch (iaq_accuracy) 
   17346:	2d03      	cmp	r5, #3
   17348:	f200 8137 	bhi.w	175ba <output_ready+0x366>
   1734c:	e8df f005 	tbb	[pc, r5]
   17350:	2c0c0802 	.word	0x2c0c0802
			LOG_DBG("IAQ calibration stabilising [%d]\n", iaq_accuracy);
   17354:	2300      	movs	r3, #0
   17356:	4a0b      	ldr	r2, [pc, #44]	; (17384 <output_ready+0x130>)
   17358:	4910      	ldr	r1, [pc, #64]	; (1739c <output_ready+0x148>)
			LOG_DBG("IAQ calibration unknown [%d]\n", iaq_accuracy);
   1735a:	f01c fc4d 	bl	33bf8 <log_string_sync>
   1735e:	e030      	b.n	173c2 <output_ready+0x16e>
			LOG_DBG("IAQ calibration uncertain [%d]\n", iaq_accuracy);
   17360:	2301      	movs	r3, #1
   17362:	4a08      	ldr	r2, [pc, #32]	; (17384 <output_ready+0x130>)
   17364:	490e      	ldr	r1, [pc, #56]	; (173a0 <output_ready+0x14c>)
   17366:	e7f8      	b.n	1735a <output_ready+0x106>
			LOG_DBG("IAQ currently calibrating [%d]\n", iaq_accuracy);
   17368:	2302      	movs	r3, #2
   1736a:	4a06      	ldr	r2, [pc, #24]	; (17384 <output_ready+0x130>)
   1736c:	490d      	ldr	r1, [pc, #52]	; (173a4 <output_ready+0x150>)
   1736e:	e7f4      	b.n	1735a <output_ready+0x106>
   17370:	20027f26 	.word	0x20027f26
   17374:	2002063c 	.word	0x2002063c
   17378:	00039f60 	.word	0x00039f60
   1737c:	00039f80 	.word	0x00039f80
   17380:	20020424 	.word	0x20020424
   17384:	0003c552 	.word	0x0003c552
   17388:	0003c639 	.word	0x0003c639
   1738c:	0003c64b 	.word	0x0003c64b
   17390:	0003c664 	.word	0x0003c664
   17394:	0003c678 	.word	0x0003c678
   17398:	0003c693 	.word	0x0003c693
   1739c:	0003c6a8 	.word	0x0003c6a8
   173a0:	0003c6ce 	.word	0x0003c6ce
   173a4:	0003c6f2 	.word	0x0003c6f2
			LOG_DBG("IAQ calibrated [%d]\n");
   173a8:	4a86      	ldr	r2, [pc, #536]	; (175c4 <output_ready+0x370>)
   173aa:	4987      	ldr	r1, [pc, #540]	; (175c8 <output_ready+0x374>)
   173ac:	f01c fc24 	bl	33bf8 <log_string_sync>
			iaq_reading_ok = true;
   173b0:	2201      	movs	r2, #1
   173b2:	4b86      	ldr	r3, [pc, #536]	; (175cc <output_ready+0x378>)
   173b4:	701a      	strb	r2, [r3, #0]
			if (!timer_stopped) {
   173b6:	4b86      	ldr	r3, [pc, #536]	; (175d0 <output_ready+0x37c>)
   173b8:	781b      	ldrb	r3, [r3, #0]
   173ba:	b913      	cbnz	r3, 173c2 <output_ready+0x16e>
	z_impl_k_timer_stop(timer);
   173bc:	4885      	ldr	r0, [pc, #532]	; (175d4 <output_ready+0x380>)
   173be:	f021 fd71 	bl	38ea4 <z_impl_k_timer_stop>
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
   173c2:	f04f 0320 	mov.w	r3, #32
   173c6:	f3ef 8711 	mrs	r7, BASEPRI
   173ca:	f383 8811 	msr	BASEPRI, r3
   173ce:	f3bf 8f6f 	isb	sy
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();

#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   173d2:	4881      	ldr	r0, [pc, #516]	; (175d8 <output_ready+0x384>)
   173d4:	f017 f884 	bl	2e4e0 <z_spin_lock_valid>
   173d8:	b968      	cbnz	r0, 173f6 <output_ready+0x1a2>
   173da:	235c      	movs	r3, #92	; 0x5c
   173dc:	4a7f      	ldr	r2, [pc, #508]	; (175dc <output_ready+0x388>)
   173de:	4980      	ldr	r1, [pc, #512]	; (175e0 <output_ready+0x38c>)
   173e0:	4880      	ldr	r0, [pc, #512]	; (175e4 <output_ready+0x390>)
   173e2:	f01c f8f1 	bl	335c8 <printk>
   173e6:	497c      	ldr	r1, [pc, #496]	; (175d8 <output_ready+0x384>)
   173e8:	487f      	ldr	r0, [pc, #508]	; (175e8 <output_ready+0x394>)
   173ea:	f01c f8ed 	bl	335c8 <printk>
   173ee:	215c      	movs	r1, #92	; 0x5c
   173f0:	487a      	ldr	r0, [pc, #488]	; (175dc <output_ready+0x388>)
   173f2:	f01c fbea 	bl	33bca <assert_post_action>
	while (!atomic_cas(&l->locked, 0, 1)) {
	}
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
   173f6:	4c7d      	ldr	r4, [pc, #500]	; (175ec <output_ready+0x398>)
   173f8:	f104 0018 	add.w	r0, r4, #24
   173fc:	f017 f88e 	bl	2e51c <z_spin_lock_set_owner>
	temp_sensor.sensor.value = temperature;
   17400:	ee18 0a90 	vmov	r0, s17
   17404:	f7f5 fdfa 	bl	cffc <__aeabi_f2d>
   17408:	e9c4 0102 	strd	r0, r1, [r4, #8]
static ALWAYS_INLINE void k_spin_unlock(struct k_spinlock *l,
					k_spinlock_key_t key)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1740c:	f104 0018 	add.w	r0, r4, #24
   17410:	f017 f874 	bl	2e4fc <z_spin_unlock_valid>
   17414:	b970      	cbnz	r0, 17434 <output_ready+0x1e0>
   17416:	2384      	movs	r3, #132	; 0x84
   17418:	4a70      	ldr	r2, [pc, #448]	; (175dc <output_ready+0x388>)
   1741a:	4975      	ldr	r1, [pc, #468]	; (175f0 <output_ready+0x39c>)
   1741c:	4871      	ldr	r0, [pc, #452]	; (175e4 <output_ready+0x390>)
   1741e:	f01c f8d3 	bl	335c8 <printk>
   17422:	f104 0118 	add.w	r1, r4, #24
   17426:	4873      	ldr	r0, [pc, #460]	; (175f4 <output_ready+0x3a0>)
   17428:	f01c f8ce 	bl	335c8 <printk>
   1742c:	2184      	movs	r1, #132	; 0x84
   1742e:	486b      	ldr	r0, [pc, #428]	; (175dc <output_ready+0x388>)
   17430:	f01c fbcb 	bl	33bca <assert_post_action>
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
   17434:	f387 8811 	msr	BASEPRI, r7
   17438:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   1743c:	f04f 0320 	mov.w	r3, #32
   17440:	f3ef 8711 	mrs	r7, BASEPRI
   17444:	f383 8811 	msr	BASEPRI, r3
   17448:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1744c:	486a      	ldr	r0, [pc, #424]	; (175f8 <output_ready+0x3a4>)
   1744e:	f017 f847 	bl	2e4e0 <z_spin_lock_valid>
   17452:	b968      	cbnz	r0, 17470 <output_ready+0x21c>
   17454:	235c      	movs	r3, #92	; 0x5c
   17456:	4a61      	ldr	r2, [pc, #388]	; (175dc <output_ready+0x388>)
   17458:	4961      	ldr	r1, [pc, #388]	; (175e0 <output_ready+0x38c>)
   1745a:	4862      	ldr	r0, [pc, #392]	; (175e4 <output_ready+0x390>)
   1745c:	f01c f8b4 	bl	335c8 <printk>
   17460:	4965      	ldr	r1, [pc, #404]	; (175f8 <output_ready+0x3a4>)
   17462:	4861      	ldr	r0, [pc, #388]	; (175e8 <output_ready+0x394>)
   17464:	f01c f8b0 	bl	335c8 <printk>
   17468:	215c      	movs	r1, #92	; 0x5c
   1746a:	485c      	ldr	r0, [pc, #368]	; (175dc <output_ready+0x388>)
   1746c:	f01c fbad 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   17470:	4c62      	ldr	r4, [pc, #392]	; (175fc <output_ready+0x3a8>)
   17472:	f104 0018 	add.w	r0, r4, #24
   17476:	f017 f851 	bl	2e51c <z_spin_lock_set_owner>
	humid_sensor.sensor.value = humidity;
   1747a:	4658      	mov	r0, fp
   1747c:	f7f5 fdbe 	bl	cffc <__aeabi_f2d>
   17480:	e9c4 0102 	strd	r0, r1, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17484:	f104 0018 	add.w	r0, r4, #24
   17488:	f017 f838 	bl	2e4fc <z_spin_unlock_valid>
   1748c:	b970      	cbnz	r0, 174ac <output_ready+0x258>
   1748e:	2384      	movs	r3, #132	; 0x84
   17490:	4a52      	ldr	r2, [pc, #328]	; (175dc <output_ready+0x388>)
   17492:	4957      	ldr	r1, [pc, #348]	; (175f0 <output_ready+0x39c>)
   17494:	4853      	ldr	r0, [pc, #332]	; (175e4 <output_ready+0x390>)
   17496:	f01c f897 	bl	335c8 <printk>
   1749a:	f104 0118 	add.w	r1, r4, #24
   1749e:	4855      	ldr	r0, [pc, #340]	; (175f4 <output_ready+0x3a0>)
   174a0:	f01c f892 	bl	335c8 <printk>
   174a4:	2184      	movs	r1, #132	; 0x84
   174a6:	484d      	ldr	r0, [pc, #308]	; (175dc <output_ready+0x388>)
   174a8:	f01c fb8f 	bl	33bca <assert_post_action>
	__asm__ volatile(
   174ac:	f387 8811 	msr	BASEPRI, r7
   174b0:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   174b4:	f04f 0320 	mov.w	r3, #32
   174b8:	f3ef 8711 	mrs	r7, BASEPRI
   174bc:	f383 8811 	msr	BASEPRI, r3
   174c0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   174c4:	484e      	ldr	r0, [pc, #312]	; (17600 <output_ready+0x3ac>)
   174c6:	f017 f80b 	bl	2e4e0 <z_spin_lock_valid>
   174ca:	b968      	cbnz	r0, 174e8 <output_ready+0x294>
   174cc:	235c      	movs	r3, #92	; 0x5c
   174ce:	4a43      	ldr	r2, [pc, #268]	; (175dc <output_ready+0x388>)
   174d0:	4943      	ldr	r1, [pc, #268]	; (175e0 <output_ready+0x38c>)
   174d2:	4844      	ldr	r0, [pc, #272]	; (175e4 <output_ready+0x390>)
   174d4:	f01c f878 	bl	335c8 <printk>
   174d8:	4949      	ldr	r1, [pc, #292]	; (17600 <output_ready+0x3ac>)
   174da:	4843      	ldr	r0, [pc, #268]	; (175e8 <output_ready+0x394>)
   174dc:	f01c f874 	bl	335c8 <printk>
   174e0:	215c      	movs	r1, #92	; 0x5c
   174e2:	483e      	ldr	r0, [pc, #248]	; (175dc <output_ready+0x388>)
   174e4:	f01c fb71 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   174e8:	4c46      	ldr	r4, [pc, #280]	; (17604 <output_ready+0x3b0>)
   174ea:	f104 0018 	add.w	r0, r4, #24
   174ee:	f017 f815 	bl	2e51c <z_spin_lock_set_owner>
	pressure_sensor.sensor.value = pressure / 1000;
   174f2:	eddf 7a45 	vldr	s15, [pc, #276]	; 17608 <output_ready+0x3b4>
   174f6:	eec8 7a27 	vdiv.f32	s15, s16, s15
   174fa:	ee17 0a90 	vmov	r0, s15
   174fe:	f7f5 fd7d 	bl	cffc <__aeabi_f2d>
   17502:	e9c4 0102 	strd	r0, r1, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17506:	f104 0018 	add.w	r0, r4, #24
   1750a:	f016 fff7 	bl	2e4fc <z_spin_unlock_valid>
   1750e:	b970      	cbnz	r0, 1752e <output_ready+0x2da>
   17510:	2384      	movs	r3, #132	; 0x84
   17512:	4a32      	ldr	r2, [pc, #200]	; (175dc <output_ready+0x388>)
   17514:	4936      	ldr	r1, [pc, #216]	; (175f0 <output_ready+0x39c>)
   17516:	4833      	ldr	r0, [pc, #204]	; (175e4 <output_ready+0x390>)
   17518:	f01c f856 	bl	335c8 <printk>
   1751c:	f104 0118 	add.w	r1, r4, #24
   17520:	4834      	ldr	r0, [pc, #208]	; (175f4 <output_ready+0x3a0>)
   17522:	f01c f851 	bl	335c8 <printk>
   17526:	2184      	movs	r1, #132	; 0x84
   17528:	482c      	ldr	r0, [pc, #176]	; (175dc <output_ready+0x388>)
   1752a:	f01c fb4e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   1752e:	f387 8811 	msr	BASEPRI, r7
   17532:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   17536:	f04f 0320 	mov.w	r3, #32
   1753a:	f3ef 8711 	mrs	r7, BASEPRI
   1753e:	f383 8811 	msr	BASEPRI, r3
   17542:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17546:	4831      	ldr	r0, [pc, #196]	; (1760c <output_ready+0x3b8>)
   17548:	f016 ffca 	bl	2e4e0 <z_spin_lock_valid>
   1754c:	b968      	cbnz	r0, 1756a <output_ready+0x316>
   1754e:	235c      	movs	r3, #92	; 0x5c
   17550:	4a22      	ldr	r2, [pc, #136]	; (175dc <output_ready+0x388>)
   17552:	4923      	ldr	r1, [pc, #140]	; (175e0 <output_ready+0x38c>)
   17554:	4823      	ldr	r0, [pc, #140]	; (175e4 <output_ready+0x390>)
   17556:	f01c f837 	bl	335c8 <printk>
   1755a:	492c      	ldr	r1, [pc, #176]	; (1760c <output_ready+0x3b8>)
   1755c:	4822      	ldr	r0, [pc, #136]	; (175e8 <output_ready+0x394>)
   1755e:	f01c f833 	bl	335c8 <printk>
   17562:	215c      	movs	r1, #92	; 0x5c
   17564:	481d      	ldr	r0, [pc, #116]	; (175dc <output_ready+0x388>)
   17566:	f01c fb30 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   1756a:	4c29      	ldr	r4, [pc, #164]	; (17610 <output_ready+0x3bc>)
   1756c:	f104 0018 	add.w	r0, r4, #24
   17570:	f016 ffd4 	bl	2e51c <z_spin_lock_set_owner>
	air_quality_sensor.sensor.value = iaq;
   17574:	4630      	mov	r0, r6
   17576:	f7f5 fd41 	bl	cffc <__aeabi_f2d>
   1757a:	e9c4 0102 	strd	r0, r1, [r4, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1757e:	f104 0018 	add.w	r0, r4, #24
	air_quality_sensor.sensor.accuracy = iaq_accuracy;
   17582:	7425      	strb	r5, [r4, #16]
   17584:	f016 ffba 	bl	2e4fc <z_spin_unlock_valid>
   17588:	b970      	cbnz	r0, 175a8 <output_ready+0x354>
   1758a:	2384      	movs	r3, #132	; 0x84
   1758c:	4a13      	ldr	r2, [pc, #76]	; (175dc <output_ready+0x388>)
   1758e:	4918      	ldr	r1, [pc, #96]	; (175f0 <output_ready+0x39c>)
   17590:	4814      	ldr	r0, [pc, #80]	; (175e4 <output_ready+0x390>)
   17592:	f01c f819 	bl	335c8 <printk>
   17596:	f104 0118 	add.w	r1, r4, #24
   1759a:	4816      	ldr	r0, [pc, #88]	; (175f4 <output_ready+0x3a0>)
   1759c:	f01c f814 	bl	335c8 <printk>
   175a0:	2184      	movs	r1, #132	; 0x84
   175a2:	480e      	ldr	r0, [pc, #56]	; (175dc <output_ready+0x388>)
   175a4:	f01c fb11 	bl	33bca <assert_post_action>
	__asm__ volatile(
   175a8:	f387 8811 	msr	BASEPRI, r7
   175ac:	f3bf 8f6f 	isb	sy
}
   175b0:	b003      	add	sp, #12
   175b2:	ecbd 8b04 	vpop	{d8-d9}
   175b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			LOG_DBG("IAQ calibration unknown [%d]\n", iaq_accuracy);
   175ba:	462b      	mov	r3, r5
   175bc:	4a01      	ldr	r2, [pc, #4]	; (175c4 <output_ready+0x370>)
   175be:	4915      	ldr	r1, [pc, #84]	; (17614 <output_ready+0x3c0>)
   175c0:	e6cb      	b.n	1735a <output_ready+0x106>
   175c2:	bf00      	nop
   175c4:	0003c552 	.word	0x0003c552
   175c8:	0003c716 	.word	0x0003c716
   175cc:	20027f26 	.word	0x20027f26
   175d0:	20020424 	.word	0x20020424
   175d4:	2002063c 	.word	0x2002063c
   175d8:	20020918 	.word	0x20020918
   175dc:	0003c751 	.word	0x0003c751
   175e0:	0003c777 	.word	0x0003c777
   175e4:	0003b77f 	.word	0x0003b77f
   175e8:	0003c78c 	.word	0x0003c78c
   175ec:	20020900 	.word	0x20020900
   175f0:	0003c7a4 	.word	0x0003c7a4
   175f4:	0003c7bb 	.word	0x0003c7bb
   175f8:	20020038 	.word	0x20020038
   175fc:	20020020 	.word	0x20020020
   17600:	20020058 	.word	0x20020058
   17604:	20020040 	.word	0x20020040
   17608:	447a0000 	.word	0x447a0000
   1760c:	20020018 	.word	0x20020018
   17610:	20020000 	.word	0x20020000
   17614:	0003c72f 	.word	0x0003c72f

00017618 <k_work_submit_to_queue.constprop.7>:
 * @param work_q Address of workqueue.
 * @param work Address of work item.
 *
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
   17618:	4601      	mov	r1, r0
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1761a:	f100 0308 	add.w	r3, r0, #8
   1761e:	e8d3 2fef 	ldaex	r2, [r3]
   17622:	f042 0001 	orr.w	r0, r2, #1
   17626:	e8c3 0fec 	stlex	ip, r0, [r3]
   1762a:	f1bc 0f00 	cmp.w	ip, #0
   1762e:	d1f6      	bne.n	1761e <k_work_submit_to_queue.constprop.7+0x6>
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   17630:	07d3      	lsls	r3, r2, #31
   17632:	d402      	bmi.n	1763a <k_work_submit_to_queue.constprop.7+0x22>
		k_queue_append(&work_q->queue, work);
   17634:	4801      	ldr	r0, [pc, #4]	; (1763c <k_work_submit_to_queue.constprop.7+0x24>)
   17636:	f021 bb35 	b.w	38ca4 <k_queue_append>
	}
}
   1763a:	4770      	bx	lr
   1763c:	20027524 	.word	0x20027524

00017640 <iaq_timer_handler>:
 *
 * @return N/A
 */
static inline void k_work_submit(struct k_work *work)
{
	k_work_submit_to_queue(&k_sys_work_q, work);
   17640:	4801      	ldr	r0, [pc, #4]	; (17648 <iaq_timer_handler+0x8>)
   17642:	f7ff bfe9 	b.w	17618 <k_work_submit_to_queue.constprop.7>
   17646:	bf00      	nop
   17648:	20020098 	.word	0x20020098

0001764c <iaq_timer_stop>:
   1764c:	4801      	ldr	r0, [pc, #4]	; (17654 <iaq_timer_stop+0x8>)
   1764e:	f7ff bfe3 	b.w	17618 <k_work_submit_to_queue.constprop.7>
   17652:	bf00      	nop
   17654:	2002008c 	.word	0x2002008c

00017658 <bus_write>:
{
   17658:	b5f0      	push	{r4, r5, r6, r7, lr}
   1765a:	b085      	sub	sp, #20
   1765c:	4605      	mov	r5, r0
	u8_t buf[data_len+1];
   1765e:	4668      	mov	r0, sp
{
   17660:	4616      	mov	r6, r2
	u8_t buf[data_len+1];
   17662:	f103 0208 	add.w	r2, r3, #8
   17666:	08d2      	lsrs	r2, r2, #3
   17668:	eba0 02c2 	sub.w	r2, r0, r2, lsl #3
{
   1766c:	af00      	add	r7, sp, #0
	u8_t buf[data_len+1];
   1766e:	4695      	mov	sp, r2
	buf[0] = reg_addr;
   17670:	4668      	mov	r0, sp
   17672:	461a      	mov	r2, r3
   17674:	f800 1b01 	strb.w	r1, [r0], #1
   17678:	4631      	mov	r1, r6
	u8_t buf[data_len+1];
   1767a:	1c5c      	adds	r4, r3, #1
   1767c:	f021 fcac 	bl	38fd8 <memcpy>
	return i2c_write(i2c_master, buf, data_len+1, dev_addr);
   17680:	4b08      	ldr	r3, [pc, #32]	; (176a4 <bus_write+0x4c>)
	msg.buf = (u8_t *)buf;
   17682:	f8c7 d004 	str.w	sp, [r7, #4]
   17686:	6818      	ldr	r0, [r3, #0]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   17688:	2302      	movs	r3, #2
	msg.len = num_bytes;
   1768a:	60bc      	str	r4, [r7, #8]
	msg.flags = I2C_MSG_WRITE | I2C_MSG_STOP;
   1768c:	733b      	strb	r3, [r7, #12]
	return api->transfer(dev, msgs, num_msgs, addr);
   1768e:	6883      	ldr	r3, [r0, #8]
   17690:	1d39      	adds	r1, r7, #4
   17692:	685c      	ldr	r4, [r3, #4]
   17694:	2201      	movs	r2, #1
   17696:	462b      	mov	r3, r5
   17698:	47a0      	blx	r4
}
   1769a:	3714      	adds	r7, #20
   1769c:	b240      	sxtb	r0, r0
   1769e:	46bd      	mov	sp, r7
   176a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   176a2:	bf00      	nop
   176a4:	20021560 	.word	0x20021560

000176a8 <env_sensors_get_temperature>:
{
   176a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sensor_data == NULL) {
   176aa:	4604      	mov	r4, r0
   176ac:	2800      	cmp	r0, #0
   176ae:	d040      	beq.n	17732 <env_sensors_get_temperature+0x8a>
	__asm__ volatile(
   176b0:	f04f 0320 	mov.w	r3, #32
   176b4:	f3ef 8711 	mrs	r7, BASEPRI
   176b8:	f383 8811 	msr	BASEPRI, r3
   176bc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   176c0:	481d      	ldr	r0, [pc, #116]	; (17738 <env_sensors_get_temperature+0x90>)
   176c2:	f016 ff0d 	bl	2e4e0 <z_spin_lock_valid>
   176c6:	4e1c      	ldr	r6, [pc, #112]	; (17738 <env_sensors_get_temperature+0x90>)
   176c8:	b968      	cbnz	r0, 176e6 <env_sensors_get_temperature+0x3e>
   176ca:	235c      	movs	r3, #92	; 0x5c
   176cc:	4a1b      	ldr	r2, [pc, #108]	; (1773c <env_sensors_get_temperature+0x94>)
   176ce:	491c      	ldr	r1, [pc, #112]	; (17740 <env_sensors_get_temperature+0x98>)
   176d0:	481c      	ldr	r0, [pc, #112]	; (17744 <env_sensors_get_temperature+0x9c>)
   176d2:	f01b ff79 	bl	335c8 <printk>
   176d6:	4631      	mov	r1, r6
   176d8:	481b      	ldr	r0, [pc, #108]	; (17748 <env_sensors_get_temperature+0xa0>)
   176da:	f01b ff75 	bl	335c8 <printk>
   176de:	215c      	movs	r1, #92	; 0x5c
   176e0:	4816      	ldr	r0, [pc, #88]	; (1773c <env_sensors_get_temperature+0x94>)
   176e2:	f01c fa72 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   176e6:	4814      	ldr	r0, [pc, #80]	; (17738 <env_sensors_get_temperature+0x90>)
   176e8:	f016 ff18 	bl	2e51c <z_spin_lock_set_owner>
   176ec:	4623      	mov	r3, r4
   176ee:	4d17      	ldr	r5, [pc, #92]	; (1774c <env_sensors_get_temperature+0xa4>)
   176f0:	462a      	mov	r2, r5
   176f2:	ca03      	ldmia	r2!, {r0, r1}
   176f4:	42b2      	cmp	r2, r6
   176f6:	6018      	str	r0, [r3, #0]
   176f8:	6059      	str	r1, [r3, #4]
   176fa:	4615      	mov	r5, r2
   176fc:	f103 0308 	add.w	r3, r3, #8
   17700:	d1f6      	bne.n	176f0 <env_sensors_get_temperature+0x48>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17702:	480d      	ldr	r0, [pc, #52]	; (17738 <env_sensors_get_temperature+0x90>)
   17704:	f016 fefa 	bl	2e4fc <z_spin_unlock_valid>
   17708:	b968      	cbnz	r0, 17726 <env_sensors_get_temperature+0x7e>
   1770a:	2384      	movs	r3, #132	; 0x84
   1770c:	4a0b      	ldr	r2, [pc, #44]	; (1773c <env_sensors_get_temperature+0x94>)
   1770e:	4910      	ldr	r1, [pc, #64]	; (17750 <env_sensors_get_temperature+0xa8>)
   17710:	480c      	ldr	r0, [pc, #48]	; (17744 <env_sensors_get_temperature+0x9c>)
   17712:	f01b ff59 	bl	335c8 <printk>
   17716:	4908      	ldr	r1, [pc, #32]	; (17738 <env_sensors_get_temperature+0x90>)
   17718:	480e      	ldr	r0, [pc, #56]	; (17754 <env_sensors_get_temperature+0xac>)
   1771a:	f01b ff55 	bl	335c8 <printk>
   1771e:	2184      	movs	r1, #132	; 0x84
   17720:	4806      	ldr	r0, [pc, #24]	; (1773c <env_sensors_get_temperature+0x94>)
   17722:	f01c fa52 	bl	33bca <assert_post_action>
	__asm__ volatile(
   17726:	f387 8811 	msr	BASEPRI, r7
   1772a:	f3bf 8f6f 	isb	sy
	return 0;
   1772e:	2000      	movs	r0, #0
}
   17730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -1;
   17732:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   17736:	e7fb      	b.n	17730 <env_sensors_get_temperature+0x88>
   17738:	20020918 	.word	0x20020918
   1773c:	0003c751 	.word	0x0003c751
   17740:	0003c777 	.word	0x0003c777
   17744:	0003b77f 	.word	0x0003b77f
   17748:	0003c78c 	.word	0x0003c78c
   1774c:	20020900 	.word	0x20020900
   17750:	0003c7a4 	.word	0x0003c7a4
   17754:	0003c7bb 	.word	0x0003c7bb

00017758 <env_sensors_get_humidity>:
{
   17758:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sensor_data == NULL) {
   1775a:	4604      	mov	r4, r0
   1775c:	2800      	cmp	r0, #0
   1775e:	d040      	beq.n	177e2 <env_sensors_get_humidity+0x8a>
	__asm__ volatile(
   17760:	f04f 0320 	mov.w	r3, #32
   17764:	f3ef 8711 	mrs	r7, BASEPRI
   17768:	f383 8811 	msr	BASEPRI, r3
   1776c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17770:	481d      	ldr	r0, [pc, #116]	; (177e8 <env_sensors_get_humidity+0x90>)
   17772:	f016 feb5 	bl	2e4e0 <z_spin_lock_valid>
   17776:	4e1c      	ldr	r6, [pc, #112]	; (177e8 <env_sensors_get_humidity+0x90>)
   17778:	b968      	cbnz	r0, 17796 <env_sensors_get_humidity+0x3e>
   1777a:	235c      	movs	r3, #92	; 0x5c
   1777c:	4a1b      	ldr	r2, [pc, #108]	; (177ec <env_sensors_get_humidity+0x94>)
   1777e:	491c      	ldr	r1, [pc, #112]	; (177f0 <env_sensors_get_humidity+0x98>)
   17780:	481c      	ldr	r0, [pc, #112]	; (177f4 <env_sensors_get_humidity+0x9c>)
   17782:	f01b ff21 	bl	335c8 <printk>
   17786:	4631      	mov	r1, r6
   17788:	481b      	ldr	r0, [pc, #108]	; (177f8 <env_sensors_get_humidity+0xa0>)
   1778a:	f01b ff1d 	bl	335c8 <printk>
   1778e:	215c      	movs	r1, #92	; 0x5c
   17790:	4816      	ldr	r0, [pc, #88]	; (177ec <env_sensors_get_humidity+0x94>)
   17792:	f01c fa1a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   17796:	4814      	ldr	r0, [pc, #80]	; (177e8 <env_sensors_get_humidity+0x90>)
   17798:	f016 fec0 	bl	2e51c <z_spin_lock_set_owner>
   1779c:	4623      	mov	r3, r4
   1779e:	4d17      	ldr	r5, [pc, #92]	; (177fc <env_sensors_get_humidity+0xa4>)
   177a0:	462a      	mov	r2, r5
   177a2:	ca03      	ldmia	r2!, {r0, r1}
   177a4:	42b2      	cmp	r2, r6
   177a6:	6018      	str	r0, [r3, #0]
   177a8:	6059      	str	r1, [r3, #4]
   177aa:	4615      	mov	r5, r2
   177ac:	f103 0308 	add.w	r3, r3, #8
   177b0:	d1f6      	bne.n	177a0 <env_sensors_get_humidity+0x48>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   177b2:	480d      	ldr	r0, [pc, #52]	; (177e8 <env_sensors_get_humidity+0x90>)
   177b4:	f016 fea2 	bl	2e4fc <z_spin_unlock_valid>
   177b8:	b968      	cbnz	r0, 177d6 <env_sensors_get_humidity+0x7e>
   177ba:	2384      	movs	r3, #132	; 0x84
   177bc:	4a0b      	ldr	r2, [pc, #44]	; (177ec <env_sensors_get_humidity+0x94>)
   177be:	4910      	ldr	r1, [pc, #64]	; (17800 <env_sensors_get_humidity+0xa8>)
   177c0:	480c      	ldr	r0, [pc, #48]	; (177f4 <env_sensors_get_humidity+0x9c>)
   177c2:	f01b ff01 	bl	335c8 <printk>
   177c6:	4908      	ldr	r1, [pc, #32]	; (177e8 <env_sensors_get_humidity+0x90>)
   177c8:	480e      	ldr	r0, [pc, #56]	; (17804 <env_sensors_get_humidity+0xac>)
   177ca:	f01b fefd 	bl	335c8 <printk>
   177ce:	2184      	movs	r1, #132	; 0x84
   177d0:	4806      	ldr	r0, [pc, #24]	; (177ec <env_sensors_get_humidity+0x94>)
   177d2:	f01c f9fa 	bl	33bca <assert_post_action>
	__asm__ volatile(
   177d6:	f387 8811 	msr	BASEPRI, r7
   177da:	f3bf 8f6f 	isb	sy
	return 0;
   177de:	2000      	movs	r0, #0
}
   177e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -1;
   177e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   177e6:	e7fb      	b.n	177e0 <env_sensors_get_humidity+0x88>
   177e8:	20020038 	.word	0x20020038
   177ec:	0003c751 	.word	0x0003c751
   177f0:	0003c777 	.word	0x0003c777
   177f4:	0003b77f 	.word	0x0003b77f
   177f8:	0003c78c 	.word	0x0003c78c
   177fc:	20020020 	.word	0x20020020
   17800:	0003c7a4 	.word	0x0003c7a4
   17804:	0003c7bb 	.word	0x0003c7bb

00017808 <env_sensors_get_pressure>:
{
   17808:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sensor_data == NULL) {
   1780a:	4604      	mov	r4, r0
   1780c:	2800      	cmp	r0, #0
   1780e:	d040      	beq.n	17892 <env_sensors_get_pressure+0x8a>
	__asm__ volatile(
   17810:	f04f 0320 	mov.w	r3, #32
   17814:	f3ef 8711 	mrs	r7, BASEPRI
   17818:	f383 8811 	msr	BASEPRI, r3
   1781c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   17820:	481d      	ldr	r0, [pc, #116]	; (17898 <env_sensors_get_pressure+0x90>)
   17822:	f016 fe5d 	bl	2e4e0 <z_spin_lock_valid>
   17826:	4e1c      	ldr	r6, [pc, #112]	; (17898 <env_sensors_get_pressure+0x90>)
   17828:	b968      	cbnz	r0, 17846 <env_sensors_get_pressure+0x3e>
   1782a:	235c      	movs	r3, #92	; 0x5c
   1782c:	4a1b      	ldr	r2, [pc, #108]	; (1789c <env_sensors_get_pressure+0x94>)
   1782e:	491c      	ldr	r1, [pc, #112]	; (178a0 <env_sensors_get_pressure+0x98>)
   17830:	481c      	ldr	r0, [pc, #112]	; (178a4 <env_sensors_get_pressure+0x9c>)
   17832:	f01b fec9 	bl	335c8 <printk>
   17836:	4631      	mov	r1, r6
   17838:	481b      	ldr	r0, [pc, #108]	; (178a8 <env_sensors_get_pressure+0xa0>)
   1783a:	f01b fec5 	bl	335c8 <printk>
   1783e:	215c      	movs	r1, #92	; 0x5c
   17840:	4816      	ldr	r0, [pc, #88]	; (1789c <env_sensors_get_pressure+0x94>)
   17842:	f01c f9c2 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   17846:	4814      	ldr	r0, [pc, #80]	; (17898 <env_sensors_get_pressure+0x90>)
   17848:	f016 fe68 	bl	2e51c <z_spin_lock_set_owner>
   1784c:	4623      	mov	r3, r4
   1784e:	4d17      	ldr	r5, [pc, #92]	; (178ac <env_sensors_get_pressure+0xa4>)
   17850:	462a      	mov	r2, r5
   17852:	ca03      	ldmia	r2!, {r0, r1}
   17854:	42b2      	cmp	r2, r6
   17856:	6018      	str	r0, [r3, #0]
   17858:	6059      	str	r1, [r3, #4]
   1785a:	4615      	mov	r5, r2
   1785c:	f103 0308 	add.w	r3, r3, #8
   17860:	d1f6      	bne.n	17850 <env_sensors_get_pressure+0x48>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17862:	480d      	ldr	r0, [pc, #52]	; (17898 <env_sensors_get_pressure+0x90>)
   17864:	f016 fe4a 	bl	2e4fc <z_spin_unlock_valid>
   17868:	b968      	cbnz	r0, 17886 <env_sensors_get_pressure+0x7e>
   1786a:	2384      	movs	r3, #132	; 0x84
   1786c:	4a0b      	ldr	r2, [pc, #44]	; (1789c <env_sensors_get_pressure+0x94>)
   1786e:	4910      	ldr	r1, [pc, #64]	; (178b0 <env_sensors_get_pressure+0xa8>)
   17870:	480c      	ldr	r0, [pc, #48]	; (178a4 <env_sensors_get_pressure+0x9c>)
   17872:	f01b fea9 	bl	335c8 <printk>
   17876:	4908      	ldr	r1, [pc, #32]	; (17898 <env_sensors_get_pressure+0x90>)
   17878:	480e      	ldr	r0, [pc, #56]	; (178b4 <env_sensors_get_pressure+0xac>)
   1787a:	f01b fea5 	bl	335c8 <printk>
   1787e:	2184      	movs	r1, #132	; 0x84
   17880:	4806      	ldr	r0, [pc, #24]	; (1789c <env_sensors_get_pressure+0x94>)
   17882:	f01c f9a2 	bl	33bca <assert_post_action>
	__asm__ volatile(
   17886:	f387 8811 	msr	BASEPRI, r7
   1788a:	f3bf 8f6f 	isb	sy
	return 0;
   1788e:	2000      	movs	r0, #0
}
   17890:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -1;
   17892:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   17896:	e7fb      	b.n	17890 <env_sensors_get_pressure+0x88>
   17898:	20020058 	.word	0x20020058
   1789c:	0003c751 	.word	0x0003c751
   178a0:	0003c777 	.word	0x0003c777
   178a4:	0003b77f 	.word	0x0003b77f
   178a8:	0003c78c 	.word	0x0003c78c
   178ac:	20020040 	.word	0x20020040
   178b0:	0003c7a4 	.word	0x0003c7a4
   178b4:	0003c7bb 	.word	0x0003c7bb

000178b8 <env_sensors_get_air_quality>:
{
   178b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (sensor_data == NULL) {
   178ba:	4604      	mov	r4, r0
   178bc:	2800      	cmp	r0, #0
   178be:	d040      	beq.n	17942 <env_sensors_get_air_quality+0x8a>
	__asm__ volatile(
   178c0:	f04f 0320 	mov.w	r3, #32
   178c4:	f3ef 8711 	mrs	r7, BASEPRI
   178c8:	f383 8811 	msr	BASEPRI, r3
   178cc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   178d0:	481d      	ldr	r0, [pc, #116]	; (17948 <env_sensors_get_air_quality+0x90>)
   178d2:	f016 fe05 	bl	2e4e0 <z_spin_lock_valid>
   178d6:	4e1c      	ldr	r6, [pc, #112]	; (17948 <env_sensors_get_air_quality+0x90>)
   178d8:	b968      	cbnz	r0, 178f6 <env_sensors_get_air_quality+0x3e>
   178da:	235c      	movs	r3, #92	; 0x5c
   178dc:	4a1b      	ldr	r2, [pc, #108]	; (1794c <env_sensors_get_air_quality+0x94>)
   178de:	491c      	ldr	r1, [pc, #112]	; (17950 <env_sensors_get_air_quality+0x98>)
   178e0:	481c      	ldr	r0, [pc, #112]	; (17954 <env_sensors_get_air_quality+0x9c>)
   178e2:	f01b fe71 	bl	335c8 <printk>
   178e6:	4631      	mov	r1, r6
   178e8:	481b      	ldr	r0, [pc, #108]	; (17958 <env_sensors_get_air_quality+0xa0>)
   178ea:	f01b fe6d 	bl	335c8 <printk>
   178ee:	215c      	movs	r1, #92	; 0x5c
   178f0:	4816      	ldr	r0, [pc, #88]	; (1794c <env_sensors_get_air_quality+0x94>)
   178f2:	f01c f96a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   178f6:	4814      	ldr	r0, [pc, #80]	; (17948 <env_sensors_get_air_quality+0x90>)
   178f8:	f016 fe10 	bl	2e51c <z_spin_lock_set_owner>
   178fc:	4623      	mov	r3, r4
   178fe:	4d17      	ldr	r5, [pc, #92]	; (1795c <env_sensors_get_air_quality+0xa4>)
   17900:	462a      	mov	r2, r5
   17902:	ca03      	ldmia	r2!, {r0, r1}
   17904:	42b2      	cmp	r2, r6
   17906:	6018      	str	r0, [r3, #0]
   17908:	6059      	str	r1, [r3, #4]
   1790a:	4615      	mov	r5, r2
   1790c:	f103 0308 	add.w	r3, r3, #8
   17910:	d1f6      	bne.n	17900 <env_sensors_get_air_quality+0x48>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   17912:	480d      	ldr	r0, [pc, #52]	; (17948 <env_sensors_get_air_quality+0x90>)
   17914:	f016 fdf2 	bl	2e4fc <z_spin_unlock_valid>
   17918:	b968      	cbnz	r0, 17936 <env_sensors_get_air_quality+0x7e>
   1791a:	2384      	movs	r3, #132	; 0x84
   1791c:	4a0b      	ldr	r2, [pc, #44]	; (1794c <env_sensors_get_air_quality+0x94>)
   1791e:	4910      	ldr	r1, [pc, #64]	; (17960 <env_sensors_get_air_quality+0xa8>)
   17920:	480c      	ldr	r0, [pc, #48]	; (17954 <env_sensors_get_air_quality+0x9c>)
   17922:	f01b fe51 	bl	335c8 <printk>
   17926:	4908      	ldr	r1, [pc, #32]	; (17948 <env_sensors_get_air_quality+0x90>)
   17928:	480e      	ldr	r0, [pc, #56]	; (17964 <env_sensors_get_air_quality+0xac>)
   1792a:	f01b fe4d 	bl	335c8 <printk>
   1792e:	2184      	movs	r1, #132	; 0x84
   17930:	4806      	ldr	r0, [pc, #24]	; (1794c <env_sensors_get_air_quality+0x94>)
   17932:	f01c f94a 	bl	33bca <assert_post_action>
	__asm__ volatile(
   17936:	f387 8811 	msr	BASEPRI, r7
   1793a:	f3bf 8f6f 	isb	sy
	return 0;
   1793e:	2000      	movs	r0, #0
}
   17940:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -1;
   17942:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   17946:	e7fb      	b.n	17940 <env_sensors_get_air_quality+0x88>
   17948:	20020018 	.word	0x20020018
   1794c:	0003c751 	.word	0x0003c751
   17950:	0003c777 	.word	0x0003c777
   17954:	0003b77f 	.word	0x0003b77f
   17958:	0003c78c 	.word	0x0003c78c
   1795c:	20020000 	.word	0x20020000
   17960:	0003c7a4 	.word	0x0003c7a4
   17964:	0003c7bb 	.word	0x0003c7bb

00017968 <env_sensors_init_and_start>:

int env_sensors_init_and_start(struct k_work_q *work_q,
			       const env_sensors_data_ready_cb cb)
{
   17968:	b5f0      	push	{r4, r5, r6, r7, lr}
   1796a:	460f      	mov	r7, r1
   1796c:	b08d      	sub	sp, #52	; 0x34
	
	return_values_init bsec_ret;
	int ret;

	if ((work_q == NULL) || (cb == NULL)) {
   1796e:	4606      	mov	r6, r0
   17970:	b100      	cbz	r0, 17974 <env_sensors_init_and_start+0xc>
   17972:	b999      	cbnz	r1, 1799c <env_sensors_init_and_start+0x34>
		LOG_DBG("EINVAL");
   17974:	2304      	movs	r3, #4
   17976:	f04f 0000 	mov.w	r0, #0
   1797a:	4a5c      	ldr	r2, [pc, #368]	; (17aec <env_sensors_init_and_start+0x184>)
   1797c:	f363 0007 	bfi	r0, r3, #0, #8
   17980:	4b5b      	ldr	r3, [pc, #364]	; (17af0 <env_sensors_init_and_start+0x188>)
   17982:	495c      	ldr	r1, [pc, #368]	; (17af4 <env_sensors_init_and_start+0x18c>)
   17984:	1a9b      	subs	r3, r3, r2
   17986:	08db      	lsrs	r3, r3, #3
   17988:	f363 108f 	bfi	r0, r3, #6, #10
   1798c:	4a5a      	ldr	r2, [pc, #360]	; (17af8 <env_sensors_init_and_start+0x190>)
   1798e:	f01c f933 	bl	33bf8 <log_string_sync>
	}

	i2c_master = device_get_binding("I2C_2");
	if (!i2c_master) {
		LOG_ERR("cannot bind to BME680");
		return -EINVAL;
   17992:	f06f 0415 	mvn.w	r4, #21

	initialized = true;

	return (data_send_interval_s > 0) ?
		submit_poll_work(ENV_INIT_DELAY_S) : 0;
}
   17996:	4620      	mov	r0, r4
   17998:	b00d      	add	sp, #52	; 0x34
   1799a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
   1799c:	4857      	ldr	r0, [pc, #348]	; (17afc <env_sensors_init_and_start+0x194>)
   1799e:	f013 ff39 	bl	2b814 <z_impl_device_get_binding>
	i2c_master = device_get_binding("I2C_2");
   179a2:	4b57      	ldr	r3, [pc, #348]	; (17b00 <env_sensors_init_and_start+0x198>)
   179a4:	6018      	str	r0, [r3, #0]
	if (!i2c_master) {
   179a6:	b960      	cbnz	r0, 179c2 <env_sensors_init_and_start+0x5a>
		LOG_ERR("cannot bind to BME680");
   179a8:	2301      	movs	r3, #1
   179aa:	4a50      	ldr	r2, [pc, #320]	; (17aec <env_sensors_init_and_start+0x184>)
   179ac:	f363 0007 	bfi	r0, r3, #0, #8
   179b0:	4b4f      	ldr	r3, [pc, #316]	; (17af0 <env_sensors_init_and_start+0x188>)
   179b2:	4954      	ldr	r1, [pc, #336]	; (17b04 <env_sensors_init_and_start+0x19c>)
   179b4:	1a9b      	subs	r3, r3, r2
   179b6:	08db      	lsrs	r3, r3, #3
   179b8:	f363 108f 	bfi	r0, r3, #6, #10
   179bc:	f01c f91c 	bl	33bf8 <log_string_sync>
   179c0:	e7e7      	b.n	17992 <env_sensors_init_and_start+0x2a>
	settings_subsys_init();
   179c2:	f002 fa5b 	bl	19e7c <settings_subsys_init>
	struct settings_handler my_conf = {
   179c6:	2214      	movs	r2, #20
   179c8:	2100      	movs	r1, #0
   179ca:	a807      	add	r0, sp, #28
   179cc:	f021 fb3e 	bl	3904c <memset>
   179d0:	4b4d      	ldr	r3, [pc, #308]	; (17b08 <env_sensors_init_and_start+0x1a0>)
	err = settings_register(&my_conf);
   179d2:	a806      	add	r0, sp, #24
	struct settings_handler my_conf = {
   179d4:	9306      	str	r3, [sp, #24]
   179d6:	4b4d      	ldr	r3, [pc, #308]	; (17b0c <env_sensors_init_and_start+0x1a4>)
   179d8:	9308      	str	r3, [sp, #32]
	err = settings_register(&my_conf);
   179da:	f002 f9a1 	bl	19d20 <settings_register>
	if (err) {
   179de:	4604      	mov	r4, r0
   179e0:	b1e8      	cbz	r0, 17a1e <env_sensors_init_and_start+0xb6>
		LOG_ERR("Cannot register settings handler");
   179e2:	2301      	movs	r3, #1
   179e4:	f04f 0000 	mov.w	r0, #0
   179e8:	4a40      	ldr	r2, [pc, #256]	; (17aec <env_sensors_init_and_start+0x184>)
   179ea:	f363 0007 	bfi	r0, r3, #0, #8
   179ee:	4b40      	ldr	r3, [pc, #256]	; (17af0 <env_sensors_init_and_start+0x188>)
   179f0:	4947      	ldr	r1, [pc, #284]	; (17b10 <env_sensors_init_and_start+0x1a8>)
   179f2:	1a9b      	subs	r3, r3, r2
   179f4:	08db      	lsrs	r3, r3, #3
   179f6:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Cannot load settings");
   179fa:	f01c f8fd 	bl	33bf8 <log_string_sync>
		LOG_ERR("Cannot enable settings err: %d", ret);
   179fe:	2301      	movs	r3, #1
   17a00:	f04f 0000 	mov.w	r0, #0
   17a04:	4a39      	ldr	r2, [pc, #228]	; (17aec <env_sensors_init_and_start+0x184>)
   17a06:	f363 0007 	bfi	r0, r3, #0, #8
   17a0a:	4b39      	ldr	r3, [pc, #228]	; (17af0 <env_sensors_init_and_start+0x188>)
   17a0c:	4941      	ldr	r1, [pc, #260]	; (17b14 <env_sensors_init_and_start+0x1ac>)
   17a0e:	1a9b      	subs	r3, r3, r2
   17a10:	08db      	lsrs	r3, r3, #3
   17a12:	f363 108f 	bfi	r0, r3, #6, #10
   17a16:	4622      	mov	r2, r4
   17a18:	f01c f8ee 	bl	33bf8 <log_string_sync>
		return ret;
   17a1c:	e7bb      	b.n	17996 <env_sensors_init_and_start+0x2e>
	err = settings_load();
   17a1e:	f01c fb6d 	bl	340fc <settings_load>
	if (err) {
   17a22:	4604      	mov	r4, r0
   17a24:	2800      	cmp	r0, #0
   17a26:	d03f      	beq.n	17aa8 <env_sensors_init_and_start+0x140>
		LOG_ERR("Cannot load settings");
   17a28:	2301      	movs	r3, #1
   17a2a:	f04f 0000 	mov.w	r0, #0
   17a2e:	4a2f      	ldr	r2, [pc, #188]	; (17aec <env_sensors_init_and_start+0x184>)
   17a30:	f363 0007 	bfi	r0, r3, #0, #8
   17a34:	4b2e      	ldr	r3, [pc, #184]	; (17af0 <env_sensors_init_and_start+0x188>)
   17a36:	4938      	ldr	r1, [pc, #224]	; (17b18 <env_sensors_init_and_start+0x1b0>)
   17a38:	1a9b      	subs	r3, r3, r2
   17a3a:	08db      	lsrs	r3, r3, #3
   17a3c:	f363 108f 	bfi	r0, r3, #6, #10
   17a40:	e7db      	b.n	179fa <env_sensors_init_and_start+0x92>
	bsec_ret = bsec_iot_init(BSEC_SAMPLE_RATE, 1.2f, bus_write,
   17a42:	f99d 5019 	ldrsb.w	r5, [sp, #25]
	} else if (bsec_ret.bsec_status) {
   17a46:	b165      	cbz	r5, 17a62 <env_sensors_init_and_start+0xfa>
		LOG_ERR("Could not initialize BSEC library");
   17a48:	2301      	movs	r3, #1
   17a4a:	f04f 0000 	mov.w	r0, #0
   17a4e:	4a27      	ldr	r2, [pc, #156]	; (17aec <env_sensors_init_and_start+0x184>)
   17a50:	f363 0007 	bfi	r0, r3, #0, #8
   17a54:	4b26      	ldr	r3, [pc, #152]	; (17af0 <env_sensors_init_and_start+0x188>)
   17a56:	4931      	ldr	r1, [pc, #196]	; (17b1c <env_sensors_init_and_start+0x1b4>)
   17a58:	1a9b      	subs	r3, r3, r2
   17a5a:	08db      	lsrs	r3, r3, #3
   17a5c:	f363 108f 	bfi	r0, r3, #6, #10
   17a60:	e03f      	b.n	17ae2 <env_sensors_init_and_start+0x17a>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   17a62:	2307      	movs	r3, #7
   17a64:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   17a68:	e9cd 4302 	strd	r4, r3, [sp, #8]
   17a6c:	492c      	ldr	r1, [pc, #176]	; (17b20 <env_sensors_init_and_start+0x1b8>)
   17a6e:	4b2d      	ldr	r3, [pc, #180]	; (17b24 <env_sensors_init_and_start+0x1bc>)
   17a70:	e9cd 4404 	strd	r4, r4, [sp, #16]
   17a74:	e9cd 4400 	strd	r4, r4, [sp]
   17a78:	482b      	ldr	r0, [pc, #172]	; (17b28 <env_sensors_init_and_start+0x1c0>)
   17a7a:	f016 fc53 	bl	2e324 <z_impl_k_thread_create>
	data_ready_cb = cb;
   17a7e:	4b2b      	ldr	r3, [pc, #172]	; (17b2c <env_sensors_init_and_start+0x1c4>)
	k_delayed_work_init(&env_sensors_poller, env_sensors_poll_fn);
   17a80:	492b      	ldr	r1, [pc, #172]	; (17b30 <env_sensors_init_and_start+0x1c8>)
	data_ready_cb = cb;
   17a82:	601f      	str	r7, [r3, #0]
	env_sensors_work_q = work_q;
   17a84:	4b2b      	ldr	r3, [pc, #172]	; (17b34 <env_sensors_init_and_start+0x1cc>)
	k_delayed_work_init(&env_sensors_poller, env_sensors_poll_fn);
   17a86:	482c      	ldr	r0, [pc, #176]	; (17b38 <env_sensors_init_and_start+0x1d0>)
	env_sensors_work_q = work_q;
   17a88:	601e      	str	r6, [r3, #0]
	k_delayed_work_init(&env_sensors_poller, env_sensors_poll_fn);
   17a8a:	f021 f9cb 	bl	38e24 <k_delayed_work_init>
	initialized = true;
   17a8e:	2201      	movs	r2, #1
   17a90:	4b2a      	ldr	r3, [pc, #168]	; (17b3c <env_sensors_init_and_start+0x1d4>)
   17a92:	701a      	strb	r2, [r3, #0]
	return (data_send_interval_s > 0) ?
   17a94:	4b2a      	ldr	r3, [pc, #168]	; (17b40 <env_sensors_init_and_start+0x1d8>)
		submit_poll_work(ENV_INIT_DELAY_S) : 0;
   17a96:	681b      	ldr	r3, [r3, #0]
   17a98:	2b00      	cmp	r3, #0
   17a9a:	f43f af7c 	beq.w	17996 <env_sensors_init_and_start+0x2e>
   17a9e:	2005      	movs	r0, #5
   17aa0:	f7ff fb40 	bl	17124 <submit_poll_work>
   17aa4:	4604      	mov	r4, r0
   17aa6:	e776      	b.n	17996 <env_sensors_init_and_start+0x2e>
	bsec_ret = bsec_iot_init(BSEC_SAMPLE_RATE, 1.2f, bus_write,
   17aa8:	4b26      	ldr	r3, [pc, #152]	; (17b44 <env_sensors_init_and_start+0x1dc>)
   17aaa:	4a27      	ldr	r2, [pc, #156]	; (17b48 <env_sensors_init_and_start+0x1e0>)
   17aac:	9300      	str	r3, [sp, #0]
   17aae:	4927      	ldr	r1, [pc, #156]	; (17b4c <env_sensors_init_and_start+0x1e4>)
   17ab0:	4b27      	ldr	r3, [pc, #156]	; (17b50 <env_sensors_init_and_start+0x1e8>)
   17ab2:	4828      	ldr	r0, [pc, #160]	; (17b54 <env_sensors_init_and_start+0x1ec>)
   17ab4:	eddf 0a28 	vldr	s1, [pc, #160]	; 17b58 <env_sensors_init_and_start+0x1f0>
   17ab8:	ed9f 0a28 	vldr	s0, [pc, #160]	; 17b5c <env_sensors_init_and_start+0x1f4>
   17abc:	f000 f852 	bl	17b64 <bsec_iot_init>
   17ac0:	b245      	sxtb	r5, r0
   17ac2:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (bsec_ret.bme680_status) {
   17ac6:	2d00      	cmp	r5, #0
   17ac8:	d0bb      	beq.n	17a42 <env_sensors_init_and_start+0xda>
		LOG_ERR("Could not initialize BME680");
   17aca:	2301      	movs	r3, #1
   17acc:	f04f 0000 	mov.w	r0, #0
   17ad0:	4a06      	ldr	r2, [pc, #24]	; (17aec <env_sensors_init_and_start+0x184>)
   17ad2:	f363 0007 	bfi	r0, r3, #0, #8
   17ad6:	4b06      	ldr	r3, [pc, #24]	; (17af0 <env_sensors_init_and_start+0x188>)
   17ad8:	4921      	ldr	r1, [pc, #132]	; (17b60 <env_sensors_init_and_start+0x1f8>)
   17ada:	1a9b      	subs	r3, r3, r2
   17adc:	08db      	lsrs	r3, r3, #3
   17ade:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not initialize BSEC library");
   17ae2:	f01c f889 	bl	33bf8 <log_string_sync>
		return (int)bsec_ret.bsec_status;
   17ae6:	462c      	mov	r4, r5
   17ae8:	e755      	b.n	17996 <env_sensors_init_and_start+0x2e>
   17aea:	bf00      	nop
   17aec:	00039f60 	.word	0x00039f60
   17af0:	00039f80 	.word	0x00039f80
   17af4:	0003c57a 	.word	0x0003c57a
   17af8:	0003c55f 	.word	0x0003c55f
   17afc:	0003c585 	.word	0x0003c585
   17b00:	20021560 	.word	0x20021560
   17b04:	0003c58b 	.word	0x0003c58b
   17b08:	0003c5a1 	.word	0x0003c5a1
   17b0c:	00017179 	.word	0x00017179
   17b10:	0003c5a6 	.word	0x0003c5a6
   17b14:	0003c61a 	.word	0x0003c61a
   17b18:	0003c5c7 	.word	0x0003c5c7
   17b1c:	0003c5f8 	.word	0x0003c5f8
   17b20:	20030608 	.word	0x20030608
   17b24:	0001713d 	.word	0x0001713d
   17b28:	2002156c 	.word	0x2002156c
   17b2c:	20021538 	.word	0x20021538
   17b30:	000171e1 	.word	0x000171e1
   17b34:	2002155c 	.word	0x2002155c
   17b38:	2002153c 	.word	0x2002153c
   17b3c:	20027f27 	.word	0x20027f27
   17b40:	20020088 	.word	0x20020088
   17b44:	00032e21 	.word	0x00032e21
   17b48:	00032e4d 	.word	0x00032e4d
   17b4c:	00017215 	.word	0x00017215
   17b50:	000171b9 	.word	0x000171b9
   17b54:	00017659 	.word	0x00017659
   17b58:	3f99999a 	.word	0x3f99999a
   17b5c:	3eaaaa3b 	.word	0x3eaaaa3b
   17b60:	0003c5dc 	.word	0x0003c5dc

00017b64 <bsec_iot_init>:
 *
 * @return      zero if successful, negative otherwise
 */
return_values_init bsec_iot_init(float sample_rate, float temperature_offset, bme680_com_fptr_t bus_write, 
                    bme680_com_fptr_t bus_read, sleep_fct sleep, state_load_fct state_load, config_load_fct config_load)
{
   17b64:	b5f0      	push	{r4, r5, r6, r7, lr}
   17b66:	ed2d 8b02 	vpush	{d8}
   17b6a:	f2ad 5de4 	subw	sp, sp, #1508	; 0x5e4
   17b6e:	460d      	mov	r5, r1
   17b70:	4607      	mov	r7, r0
   17b72:	4614      	mov	r4, r2
    return_values_init ret = {BME680_OK, BSEC_OK};
    bsec_library_return_t bsec_status = BSEC_OK;
    
    uint8_t bsec_state[BSEC_MAX_PROPERTY_BLOB_SIZE] = {0};
   17b74:	2100      	movs	r1, #0
   17b76:	f44f 72e3 	mov.w	r2, #454	; 0x1c6
   17b7a:	a822      	add	r0, sp, #136	; 0x88
{
   17b7c:	eeb0 8a40 	vmov.f32	s16, s0
   17b80:	eef0 8a60 	vmov.f32	s17, s1
   17b84:	461e      	mov	r6, r3
    uint8_t bsec_state[BSEC_MAX_PROPERTY_BLOB_SIZE] = {0};
   17b86:	f021 fa61 	bl	3904c <memset>
    uint8_t bsec_config[BSEC_MAX_PROPERTY_BLOB_SIZE] = {0};
   17b8a:	f44f 72e3 	mov.w	r2, #454	; 0x1c6
   17b8e:	2100      	movs	r1, #0
   17b90:	a894      	add	r0, sp, #592	; 0x250
   17b92:	f021 fa5b 	bl	3904c <memset>
    uint8_t work_buffer[BSEC_MAX_PROPERTY_BLOB_SIZE] = {0};
   17b96:	f44f 72e3 	mov.w	r2, #454	; 0x1c6
   17b9a:	2100      	movs	r1, #0
   17b9c:	f50d 6083 	add.w	r0, sp, #1048	; 0x418
   17ba0:	f021 fa54 	bl	3904c <memset>
    int bsec_state_len, bsec_config_len;
    
    /* Fixed I2C configuration */
    bme680_g.dev_id = BME680_I2C_ADDR_PRIMARY;
   17ba4:	2376      	movs	r3, #118	; 0x76
   17ba6:	4843      	ldr	r0, [pc, #268]	; (17cb4 <bsec_iot_init+0x150>)
   17ba8:	7043      	strb	r3, [r0, #1]
    bme680_g.intf = BME680_I2C_INTF;
   17baa:	2301      	movs	r3, #1
    /* User configurable I2C configuration */
    bme680_g.write = bus_write;
    bme680_g.read = bus_read;
   17bac:	e9c0 5712 	strd	r5, r7, [r0, #72]	; 0x48
    bme680_g.intf = BME680_I2C_INTF;
   17bb0:	7083      	strb	r3, [r0, #2]
    bme680_g.delay_ms = sleep;
   17bb2:	6504      	str	r4, [r0, #80]	; 0x50
    
    /* Initialize BME680 API */
    ret.bme680_status = bme680_init(&bme680_g);
   17bb4:	f01b fa4b 	bl	3304e <bme680_init>
    if (ret.bme680_status != BME680_OK)
   17bb8:	4605      	mov	r5, r0
   17bba:	b190      	cbz	r0, 17be2 <bsec_iot_init+0x7e>
    {
        return ret;
   17bbc:	2300      	movs	r3, #0
   17bbe:	f88d 0048 	strb.w	r0, [sp, #72]	; 0x48
   17bc2:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
   17bc6:	2000      	movs	r0, #0
   17bc8:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
   17bcc:	f363 0007 	bfi	r0, r3, #0, #8
   17bd0:	f89d 3049 	ldrb.w	r3, [sp, #73]	; 0x49
   17bd4:	f363 200f 	bfi	r0, r3, #8, #8
    {
        return ret;
    }
    
    return ret;
}
   17bd8:	f20d 5de4 	addw	sp, sp, #1508	; 0x5e4
   17bdc:	ecbd 8b02 	vpop	{d8}
   17be0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret.bsec_status = bsec_init();
   17be2:	f7f5 ff4d 	bl	da80 <bsec_init>
    if (ret.bsec_status != BSEC_OK)
   17be6:	4604      	mov	r4, r0
   17be8:	b120      	cbz	r0, 17bf4 <bsec_iot_init+0x90>
        return ret;
   17bea:	f88d 5048 	strb.w	r5, [sp, #72]	; 0x48
   17bee:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
   17bf2:	e7e8      	b.n	17bc6 <bsec_iot_init+0x62>
    bsec_config_len = config_load(bsec_config, sizeof(bsec_config));
   17bf4:	f44f 71e3 	mov.w	r1, #454	; 0x1c6
   17bf8:	a894      	add	r0, sp, #592	; 0x250
   17bfa:	f8dd 3600 	ldr.w	r3, [sp, #1536]	; 0x600
   17bfe:	4798      	blx	r3
    if (bsec_config_len != 0)
   17c00:	4601      	mov	r1, r0
   17c02:	b160      	cbz	r0, 17c1e <bsec_iot_init+0xba>
        ret.bsec_status = bsec_set_configuration(bsec_config, bsec_config_len, work_buffer, sizeof(work_buffer));     
   17c04:	f44f 73e3 	mov.w	r3, #454	; 0x1c6
   17c08:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
   17c0c:	a894      	add	r0, sp, #592	; 0x250
   17c0e:	f7f5 ff69 	bl	dae4 <bsec_set_configuration>
        if (ret.bsec_status != BSEC_OK)
   17c12:	b120      	cbz	r0, 17c1e <bsec_iot_init+0xba>
            return ret;
   17c14:	f88d 4048 	strb.w	r4, [sp, #72]	; 0x48
            return ret;
   17c18:	f88d 0049 	strb.w	r0, [sp, #73]	; 0x49
   17c1c:	e7d3      	b.n	17bc6 <bsec_iot_init+0x62>
    bsec_state_len = state_load(bsec_state, sizeof(bsec_state));
   17c1e:	f44f 71e3 	mov.w	r1, #454	; 0x1c6
   17c22:	a822      	add	r0, sp, #136	; 0x88
   17c24:	47b0      	blx	r6
    if (bsec_state_len != 0)
   17c26:	4601      	mov	r1, r0
   17c28:	b158      	cbz	r0, 17c42 <bsec_iot_init+0xde>
        ret.bsec_status = bsec_set_state(bsec_state, bsec_state_len, work_buffer, sizeof(work_buffer));     
   17c2a:	f44f 73e3 	mov.w	r3, #454	; 0x1c6
   17c2e:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
   17c32:	a822      	add	r0, sp, #136	; 0x88
   17c34:	f7f5 ff64 	bl	db00 <bsec_set_state>
        if (ret.bsec_status != BSEC_OK)
   17c38:	b118      	cbz	r0, 17c42 <bsec_iot_init+0xde>
            return ret;
   17c3a:	2300      	movs	r3, #0
   17c3c:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
   17c40:	e7ea      	b.n	17c18 <bsec_iot_init+0xb4>
    bme680_temperature_offset_g = temperature_offset;
   17c42:	4b1d      	ldr	r3, [pc, #116]	; (17cb8 <bsec_iot_init+0x154>)
    uint8_t n_required_sensor_settings = BSEC_MAX_PHYSICAL_SENSOR;
   17c44:	2108      	movs	r1, #8
    bme680_temperature_offset_g = temperature_offset;
   17c46:	edc3 8a00 	vstr	s17, [r3]
    requested_virtual_sensors[0].sensor_id = BSEC_OUTPUT_IAQ;
   17c4a:	2301      	movs	r3, #1
   17c4c:	f88d 300c 	strb.w	r3, [sp, #12]
    requested_virtual_sensors[1].sensor_id = BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_TEMPERATURE;
   17c50:	230e      	movs	r3, #14
   17c52:	f88d 3014 	strb.w	r3, [sp, #20]
    requested_virtual_sensors[2].sensor_id = BSEC_OUTPUT_RAW_PRESSURE;
   17c56:	2307      	movs	r3, #7
   17c58:	f88d 301c 	strb.w	r3, [sp, #28]
    requested_virtual_sensors[3].sensor_id = BSEC_OUTPUT_SENSOR_HEAT_COMPENSATED_HUMIDITY;
   17c5c:	230f      	movs	r3, #15
   17c5e:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    requested_virtual_sensors[4].sensor_id = BSEC_OUTPUT_RAW_GAS;
   17c62:	2309      	movs	r3, #9
   17c64:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    requested_virtual_sensors[5].sensor_id = BSEC_OUTPUT_RAW_TEMPERATURE;
   17c68:	2306      	movs	r3, #6
   17c6a:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    requested_virtual_sensors[7].sensor_id = BSEC_OUTPUT_STATIC_IAQ;
   17c6e:	2302      	movs	r3, #2
    status = bsec_update_subscription(requested_virtual_sensors, n_requested_virtual_sensors, required_sensor_settings,
   17c70:	aa12      	add	r2, sp, #72	; 0x48
    requested_virtual_sensors[7].sensor_id = BSEC_OUTPUT_STATIC_IAQ;
   17c72:	f88d 3044 	strb.w	r3, [sp, #68]	; 0x44
    status = bsec_update_subscription(requested_virtual_sensors, n_requested_virtual_sensors, required_sensor_settings,
   17c76:	eb0d 0001 	add.w	r0, sp, r1
   17c7a:	f10d 0307 	add.w	r3, sp, #7
    uint8_t n_required_sensor_settings = BSEC_MAX_PHYSICAL_SENSOR;
   17c7e:	f88d 1007 	strb.w	r1, [sp, #7]
    requested_virtual_sensors[0].sample_rate = sample_rate;
   17c82:	ed8d 8a02 	vstr	s16, [sp, #8]
    requested_virtual_sensors[1].sample_rate = sample_rate;
   17c86:	ed8d 8a04 	vstr	s16, [sp, #16]
    requested_virtual_sensors[2].sample_rate = sample_rate;
   17c8a:	ed8d 8a06 	vstr	s16, [sp, #24]
    requested_virtual_sensors[3].sample_rate = sample_rate;
   17c8e:	ed8d 8a08 	vstr	s16, [sp, #32]
    requested_virtual_sensors[4].sample_rate = sample_rate;
   17c92:	ed8d 8a0a 	vstr	s16, [sp, #40]	; 0x28
    requested_virtual_sensors[5].sample_rate = sample_rate;
   17c96:	ed8d 8a0c 	vstr	s16, [sp, #48]	; 0x30
    requested_virtual_sensors[6].sensor_id = BSEC_OUTPUT_RAW_HUMIDITY;
   17c9a:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
    requested_virtual_sensors[6].sample_rate = sample_rate;
   17c9e:	ed8d 8a0e 	vstr	s16, [sp, #56]	; 0x38
    requested_virtual_sensors[7].sample_rate = sample_rate;
   17ca2:	ed8d 8a10 	vstr	s16, [sp, #64]	; 0x40
    status = bsec_update_subscription(requested_virtual_sensors, n_requested_virtual_sensors, required_sensor_settings,
   17ca6:	f7f5 fef9 	bl	da9c <bsec_update_subscription>
    if (ret.bsec_status != BSEC_OK)
   17caa:	2800      	cmp	r0, #0
   17cac:	d1c5      	bne.n	17c3a <bsec_iot_init+0xd6>
    return ret;
   17cae:	f8ad 0048 	strh.w	r0, [sp, #72]	; 0x48
   17cb2:	e788      	b.n	17bc6 <bsec_iot_init+0x62>
   17cb4:	20021624 	.word	0x20021624
   17cb8:	2002167c 	.word	0x2002167c

00017cbc <bsec_iot_loop>:
 *
 * @return      none
 */
void bsec_iot_loop(sleep_fct sleep, get_timestamp_us_fct get_timestamp_us, output_ready_fct output_ready,
                    state_save_fct state_save, uint32_t save_intvl)
{
   17cbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17cc0:	ed2d 8b02 	vpush	{d8}
    bsec_bme_settings_t sensor_settings;
    
    /* Save state variables */
    uint8_t bsec_state[BSEC_MAX_STATE_BLOB_SIZE];
    uint8_t work_buffer[BSEC_MAX_STATE_BLOB_SIZE];
    uint32_t bsec_state_len = 0;
   17cc4:	2500      	movs	r5, #0
{
   17cc6:	4680      	mov	r8, r0
   17cc8:	4689      	mov	r9, r1
   17cca:	4692      	mov	sl, r2
   17ccc:	469b      	mov	fp, r3
    float breath_voc_equivalent = 0.0f;
   17cce:	ed9f 8aa6 	vldr	s16, [pc, #664]	; 17f68 <bsec_iot_loop+0x2ac>
{
   17cd2:	f5ad 7d2d 	sub.w	sp, sp, #692	; 0x2b4
   17cd6:	4ca5      	ldr	r4, [pc, #660]	; (17f6c <bsec_iot_loop+0x2b0>)
    uint32_t bsec_state_len = 0;
   17cd8:	9507      	str	r5, [sp, #28]
    bsec_library_return_t bsec_status = BSEC_OK;

    while (1)
    {
        /* get the timestamp in nanoseconds before calling bsec_sensor_control() */
        time_stamp = get_timestamp_us() * 1000;
   17cda:	47c8      	blx	r9
   17cdc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   17ce0:	fba0 6703 	umull	r6, r7, r0, r3
   17ce4:	fb03 7701 	mla	r7, r3, r1, r7
        
        /* Retrieve sensor settings to be used in this time instant by calling bsec_sensor_control */
        bsec_sensor_control(time_stamp, &sensor_settings);
   17ce8:	aa08      	add	r2, sp, #32
   17cea:	4630      	mov	r0, r6
   17cec:	4639      	mov	r1, r7
   17cee:	f7f5 ff49 	bl	db84 <bsec_sensor_control>
    if (sensor_settings->trigger_measurement)
   17cf2:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
   17cf6:	b1f3      	cbz	r3, 17d36 <bsec_iot_loop+0x7a>
        bme680_g.tph_sett.os_pres = sensor_settings->pressure_oversampling;
   17cf8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
        bme680_status = bme680_set_sensor_settings(set_required_settings, &bme680_g);
   17cfc:	4621      	mov	r1, r4
        bme680_g.tph_sett.os_pres = sensor_settings->pressure_oversampling;
   17cfe:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
        bme680_g.tph_sett.os_hum  = sensor_settings->humidity_oversampling;
   17d02:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
        bme680_status = bme680_set_sensor_settings(set_required_settings, &bme680_g);
   17d06:	20cf      	movs	r0, #207	; 0xcf
        bme680_g.tph_sett.os_hum  = sensor_settings->humidity_oversampling;
   17d08:	ba5b      	rev16	r3, r3
   17d0a:	8723      	strh	r3, [r4, #56]	; 0x38
        bme680_g.gas_sett.run_gas = sensor_settings->run_gas;
   17d0c:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   17d10:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
        bme680_g.gas_sett.heatr_temp = sensor_settings->heater_temperature; /* degree Celsius */
   17d14:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   17d16:	6423      	str	r3, [r4, #64]	; 0x40
        bme680_g.power_mode = BME680_FORCED_MODE;
   17d18:	2301      	movs	r3, #1
   17d1a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
        bme680_status = bme680_set_sensor_settings(set_required_settings, &bme680_g);
   17d1e:	f000 f935 	bl	17f8c <bme680_set_sensor_settings>
        bme680_status = bme680_set_sensor_mode(&bme680_g);
   17d22:	4620      	mov	r0, r4
   17d24:	f01b fa6a 	bl	331fc <bme680_set_sensor_mode>
        bme680_get_profile_dur(&meas_period, &bme680_g);
   17d28:	a874      	add	r0, sp, #464	; 0x1d0
   17d2a:	4621      	mov	r1, r4
   17d2c:	f000 faac 	bl	18288 <bme680_get_profile_dur>
        sleep((uint32_t)meas_period);
   17d30:	f8bd 01d0 	ldrh.w	r0, [sp, #464]	; 0x1d0
        sleep(5);
   17d34:	47c0      	blx	r8
        bme680_status = bme680_get_sensor_mode(&bme680_g);
   17d36:	4620      	mov	r0, r4
   17d38:	f01b fa9f 	bl	3327a <bme680_get_sensor_mode>
    while (bme680_g.power_mode == BME680_FORCED_MODE)
   17d3c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   17d40:	2b01      	cmp	r3, #1
   17d42:	f000 80a4 	beq.w	17e8e <bsec_iot_loop+0x1d2>
        /* Trigger a measurement if necessary */
        bme680_bsec_trigger_measurement(&sensor_settings, sleep);
        
        /* Read data from last measurement */
        num_bsec_inputs = 0;
        bme680_bsec_read_data(time_stamp, bsec_inputs, &num_bsec_inputs, sensor_settings.process_data);
   17d46:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    if (bsec_process_data)
   17d48:	2b00      	cmp	r3, #0
   17d4a:	f000 80a4 	beq.w	17e96 <bsec_iot_loop+0x1da>
        bme680_status = bme680_get_sensor_data(&data, &bme680_g);
   17d4e:	4a88      	ldr	r2, [pc, #544]	; (17f70 <bsec_iot_loop+0x2b4>)
   17d50:	4621      	mov	r1, r4
   17d52:	4610      	mov	r0, r2
   17d54:	9305      	str	r3, [sp, #20]
   17d56:	f000 facb 	bl	182f0 <bme680_get_sensor_data>
        if (data.status & BME680_NEW_DATA_MSK)
   17d5a:	4a85      	ldr	r2, [pc, #532]	; (17f70 <bsec_iot_loop+0x2b4>)
   17d5c:	7810      	ldrb	r0, [r2, #0]
   17d5e:	0603      	lsls	r3, r0, #24
   17d60:	f140 8099 	bpl.w	17e96 <bsec_iot_loop+0x1da>
            if (bsec_process_data & BSEC_PROCESS_PRESSURE)
   17d64:	9b05      	ldr	r3, [sp, #20]
   17d66:	f013 0101 	ands.w	r1, r3, #1
   17d6a:	d00a      	beq.n	17d82 <bsec_iot_loop+0xc6>
                inputs[*num_bsec_inputs].signal = data.pressure;
   17d6c:	edd2 7a02 	vldr	s15, [r2, #8]
   17d70:	eef8 7a67 	vcvt.f32.u32	s15, s15
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_PRESSURE;
   17d74:	2101      	movs	r1, #1
                inputs[*num_bsec_inputs].signal = data.pressure;
   17d76:	edcd 7a10 	vstr	s15, [sp, #64]	; 0x40
                inputs[*num_bsec_inputs].time_stamp = time_stamp_trigger;
   17d7a:	e9cd 670e 	strd	r6, r7, [sp, #56]	; 0x38
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_PRESSURE;
   17d7e:	f88d 1045 	strb.w	r1, [sp, #69]	; 0x45
            if (bsec_process_data & BSEC_PROCESS_TEMPERATURE)
   17d82:	f013 0f04 	tst.w	r3, #4
   17d86:	d029      	beq.n	17ddc <bsec_iot_loop+0x120>
                    inputs[*num_bsec_inputs].signal = data.temperature / 100.0f;
   17d88:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
   17d8c:	eddf 6a79 	vldr	s13, [pc, #484]	; 17f74 <bsec_iot_loop+0x2b8>
   17d90:	ee07 2a90 	vmov	s15, r2
   17d94:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_TEMPERATURE;
   17d98:	f04f 0e03 	mov.w	lr, #3
                    inputs[*num_bsec_inputs].signal = data.temperature / 100.0f;
   17d9c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_TEMPERATURE;
   17da0:	f10d 0c38 	add.w	ip, sp, #56	; 0x38
   17da4:	eb0c 1c01 	add.w	ip, ip, r1, lsl #4
                (*num_bsec_inputs)++;
   17da8:	1c4a      	adds	r2, r1, #1
                inputs[*num_bsec_inputs].time_stamp = time_stamp_trigger;
   17daa:	e9cc 6700 	strd	r6, r7, [ip]
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_TEMPERATURE;
   17dae:	f88c e00d 	strb.w	lr, [ip, #13]
                    inputs[*num_bsec_inputs].signal = data.temperature / 100.0f;
   17db2:	ed8c 7a02 	vstr	s14, [ip, #8]
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_HEATSOURCE;
   17db6:	b2d2      	uxtb	r2, r2
   17db8:	f10d 0c38 	add.w	ip, sp, #56	; 0x38
   17dbc:	eb0c 1202 	add.w	r2, ip, r2, lsl #4
   17dc0:	f04f 0c0e 	mov.w	ip, #14
   17dc4:	f882 c00d 	strb.w	ip, [r2, #13]
                inputs[*num_bsec_inputs].signal = bme680_temperature_offset_g;
   17dc8:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 17f88 <bsec_iot_loop+0x2cc>
                inputs[*num_bsec_inputs].time_stamp = time_stamp_trigger;
   17dcc:	e9c2 6700 	strd	r6, r7, [r2]
                inputs[*num_bsec_inputs].signal = bme680_temperature_offset_g;
   17dd0:	f8dc c000 	ldr.w	ip, [ip]
                (*num_bsec_inputs)++;
   17dd4:	3102      	adds	r1, #2
                inputs[*num_bsec_inputs].signal = bme680_temperature_offset_g;
   17dd6:	f8c2 c008 	str.w	ip, [r2, #8]
                (*num_bsec_inputs)++;
   17dda:	b2c9      	uxtb	r1, r1
            if (bsec_process_data & BSEC_PROCESS_HUMIDITY)
   17ddc:	079a      	lsls	r2, r3, #30
   17dde:	d516      	bpl.n	17e0e <bsec_iot_loop+0x152>
                inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_HUMIDITY;
   17de0:	f04f 0c02 	mov.w	ip, #2
   17de4:	aa0e      	add	r2, sp, #56	; 0x38
   17de6:	eb02 1201 	add.w	r2, r2, r1, lsl #4
   17dea:	f882 c00d 	strb.w	ip, [r2, #13]
                    inputs[*num_bsec_inputs].signal = data.humidity / 1000.0f;
   17dee:	f8df c180 	ldr.w	ip, [pc, #384]	; 17f70 <bsec_iot_loop+0x2b4>
   17df2:	eddf 6a61 	vldr	s13, [pc, #388]	; 17f78 <bsec_iot_loop+0x2bc>
   17df6:	eddc 7a03 	vldr	s15, [ip, #12]
   17dfa:	eef8 7a67 	vcvt.f32.u32	s15, s15
   17dfe:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   17e02:	ed82 7a02 	vstr	s14, [r2, #8]
                inputs[*num_bsec_inputs].time_stamp = time_stamp_trigger;
   17e06:	e9c2 6700 	strd	r6, r7, [r2]
                (*num_bsec_inputs)++;
   17e0a:	3101      	adds	r1, #1
   17e0c:	b2c9      	uxtb	r1, r1
            if (bsec_process_data & BSEC_PROCESS_GAS)
   17e0e:	071a      	lsls	r2, r3, #28
   17e10:	d53f      	bpl.n	17e92 <bsec_iot_loop+0x1d6>
                if(data.status & BME680_GASM_VALID_MSK)
   17e12:	0683      	lsls	r3, r0, #26
   17e14:	d53d      	bpl.n	17e92 <bsec_iot_loop+0x1d6>
                    inputs[*num_bsec_inputs].sensor_id = BSEC_INPUT_GASRESISTOR;
   17e16:	2204      	movs	r2, #4
   17e18:	ab0e      	add	r3, sp, #56	; 0x38
   17e1a:	eb03 1301 	add.w	r3, r3, r1, lsl #4
   17e1e:	735a      	strb	r2, [r3, #13]
                    inputs[*num_bsec_inputs].signal = data.gas_resistance;
   17e20:	4a53      	ldr	r2, [pc, #332]	; (17f70 <bsec_iot_loop+0x2b4>)
                    inputs[*num_bsec_inputs].time_stamp = time_stamp_trigger;
   17e22:	e9c3 6700 	strd	r6, r7, [r3]
                    inputs[*num_bsec_inputs].signal = data.gas_resistance;
   17e26:	edd2 7a04 	vldr	s15, [r2, #16]
   17e2a:	eef8 7a67 	vcvt.f32.u32	s15, s15
   17e2e:	edc3 7a02 	vstr	s15, [r3, #8]
                    (*num_bsec_inputs)++;
   17e32:	3101      	adds	r1, #1
   17e34:	b2c9      	uxtb	r1, r1
        num_bsec_outputs = BSEC_NUMBER_OUTPUTS;
   17e36:	230e      	movs	r3, #14
        bsec_status = bsec_do_steps(bsec_inputs, num_bsec_inputs, bsec_outputs, &num_bsec_outputs);
   17e38:	aa74      	add	r2, sp, #464	; 0x1d0
        num_bsec_outputs = BSEC_NUMBER_OUTPUTS;
   17e3a:	f88d 301b 	strb.w	r3, [sp, #27]
        bsec_status = bsec_do_steps(bsec_inputs, num_bsec_inputs, bsec_outputs, &num_bsec_outputs);
   17e3e:	a80e      	add	r0, sp, #56	; 0x38
   17e40:	f10d 031b 	add.w	r3, sp, #27
   17e44:	f7f5 fe3c 	bl	dac0 <bsec_do_steps>
        for (index = 0; index < num_bsec_outputs; index++)
   17e48:	2700      	movs	r7, #0
        bsec_status = bsec_do_steps(bsec_inputs, num_bsec_inputs, bsec_outputs, &num_bsec_outputs);
   17e4a:	9005      	str	r0, [sp, #20]
    float breath_voc_equivalent = 0.0f;
   17e4c:	eef0 4a48 	vmov.f32	s9, s16
    float co2_equivalent = 0.0f;
   17e50:	eeb0 4a48 	vmov.f32	s8, s16
    float static_iaq = 0.0f;
   17e54:	eef0 3a48 	vmov.f32	s7, s16
    float raw_gas = 0.0f;
   17e58:	eeb0 3a48 	vmov.f32	s6, s16
    float raw_humidity = 0.0f;
   17e5c:	eef0 2a48 	vmov.f32	s5, s16
    float humidity = 0.0f;
   17e60:	eeb0 1a48 	vmov.f32	s2, s16
    float raw_pressure = 0.0f;
   17e64:	eef0 1a48 	vmov.f32	s3, s16
    float raw_temp = 0.0f;
   17e68:	eeb0 2a48 	vmov.f32	s4, s16
    float temp = 0.0f;
   17e6c:	eef0 0a48 	vmov.f32	s1, s16
    uint8_t iaq_accuracy = 0;
   17e70:	463a      	mov	r2, r7
    float iaq = 0.0f;
   17e72:	eeb0 0a48 	vmov.f32	s0, s16
    int64_t timestamp = 0;
   17e76:	2000      	movs	r0, #0
   17e78:	2100      	movs	r1, #0
        for (index = 0; index < num_bsec_outputs; index++)
   17e7a:	f89d e01b 	ldrb.w	lr, [sp, #27]
   17e7e:	ae74      	add	r6, sp, #464	; 0x1d0
   17e80:	fa5f fc87 	uxtb.w	ip, r7
   17e84:	45e6      	cmp	lr, ip
   17e86:	d836      	bhi.n	17ef6 <bsec_iot_loop+0x23a>
        output_ready(timestamp, iaq, iaq_accuracy, temp, humidity, raw_pressure, raw_temp, 
   17e88:	9b05      	ldr	r3, [sp, #20]
   17e8a:	47d0      	blx	sl
   17e8c:	e003      	b.n	17e96 <bsec_iot_loop+0x1da>
        sleep(5);
   17e8e:	2005      	movs	r0, #5
   17e90:	e750      	b.n	17d34 <bsec_iot_loop+0x78>
    if (num_bsec_inputs > 0)
   17e92:	2900      	cmp	r1, #0
   17e94:	d1cf      	bne.n	17e36 <bsec_iot_loop+0x17a>
        
        /* Increment sample counter */
        n_samples++;
        
        /* Retrieve and store state if the passed save_intvl */
        if (n_samples >= save_intvl)
   17e96:	9bb8      	ldr	r3, [sp, #736]	; 0x2e0
        n_samples++;
   17e98:	3501      	adds	r5, #1
        if (n_samples >= save_intvl)
   17e9a:	429d      	cmp	r5, r3
   17e9c:	d30e      	bcc.n	17ebc <bsec_iot_loop+0x200>
        {
            bsec_status = bsec_get_state(0, bsec_state, sizeof(bsec_state), work_buffer, sizeof(work_buffer), &bsec_state_len);
   17e9e:	228b      	movs	r2, #139	; 0x8b
   17ea0:	ae07      	add	r6, sp, #28
   17ea2:	9601      	str	r6, [sp, #4]
   17ea4:	9200      	str	r2, [sp, #0]
   17ea6:	ab51      	add	r3, sp, #324	; 0x144
   17ea8:	a92e      	add	r1, sp, #184	; 0xb8
   17eaa:	2000      	movs	r0, #0
   17eac:	f7f5 fe50 	bl	db50 <bsec_get_state>
            if (bsec_status == BSEC_OK)
   17eb0:	4605      	mov	r5, r0
   17eb2:	2800      	cmp	r0, #0
   17eb4:	d156      	bne.n	17f64 <bsec_iot_loop+0x2a8>
            {
                state_save(bsec_state, bsec_state_len);
   17eb6:	6831      	ldr	r1, [r6, #0]
   17eb8:	a82e      	add	r0, sp, #184	; 0xb8
   17eba:	47d8      	blx	fp
        }
        
        
        /* Compute how long we can sleep until we need to call bsec_sensor_control() next */
        /* Time_stamp is converted from microseconds to nanoseconds first and then the difference to milliseconds */
        time_stamp_interval_ms = (sensor_settings.next_call - get_timestamp_us() * 1000) / 1000000;
   17ebc:	e9dd 6708 	ldrd	r6, r7, [sp, #32]
   17ec0:	47c8      	blx	r9
   17ec2:	4a2e      	ldr	r2, [pc, #184]	; (17f7c <bsec_iot_loop+0x2c0>)
   17ec4:	4243      	negs	r3, r0
   17ec6:	fb02 3301 	mla	r3, r2, r1, r3
   17eca:	fba0 0102 	umull	r0, r1, r0, r2
   17ece:	4419      	add	r1, r3
   17ed0:	1983      	adds	r3, r0, r6
   17ed2:	9302      	str	r3, [sp, #8]
   17ed4:	eb41 0307 	adc.w	r3, r1, r7
   17ed8:	9303      	str	r3, [sp, #12]
        if (time_stamp_interval_ms > 0)
   17eda:	2300      	movs	r3, #0
   17edc:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   17ee0:	4a27      	ldr	r2, [pc, #156]	; (17f80 <bsec_iot_loop+0x2c4>)
   17ee2:	4282      	cmp	r2, r0
   17ee4:	418b      	sbcs	r3, r1
   17ee6:	f6bf aef8 	bge.w	17cda <bsec_iot_loop+0x1e>
        time_stamp_interval_ms = (sensor_settings.next_call - get_timestamp_us() * 1000) / 1000000;
   17eea:	4a26      	ldr	r2, [pc, #152]	; (17f84 <bsec_iot_loop+0x2c8>)
   17eec:	2300      	movs	r3, #0
   17eee:	f7f5 fbef 	bl	d6d0 <__aeabi_ldivmod>
        {
            sleep((uint32_t)time_stamp_interval_ms);
   17ef2:	47c0      	blx	r8
   17ef4:	e6f1      	b.n	17cda <bsec_iot_loop+0x1e>
            switch (bsec_outputs[index].sensor_id)
   17ef6:	f896 c00d 	ldrb.w	ip, [r6, #13]
   17efa:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
   17efe:	f1bc 0f14 	cmp.w	ip, #20
   17f02:	d811      	bhi.n	17f28 <bsec_iot_loop+0x26c>
   17f04:	e8df f00c 	tbb	[pc, ip]
   17f08:	1916130b 	.word	0x1916130b
   17f0c:	2b1f2810 	.word	0x2b1f2810
   17f10:	10101025 	.word	0x10101025
   17f14:	10221c10 	.word	0x10221c10
   17f18:	10100e10 	.word	0x10100e10
   17f1c:	0e          	.byte	0x0e
   17f1d:	00          	.byte	0x00
                    iaq = bsec_outputs[index].signal;
   17f1e:	ed96 0a02 	vldr	s0, [r6, #8]
                    iaq_accuracy = bsec_outputs[index].accuracy;
   17f22:	7bb2      	ldrb	r2, [r6, #14]
            timestamp = bsec_outputs[index].time_stamp;
   17f24:	e9d6 0100 	ldrd	r0, r1, [r6]
   17f28:	3701      	adds	r7, #1
   17f2a:	3610      	adds	r6, #16
   17f2c:	e7a8      	b.n	17e80 <bsec_iot_loop+0x1c4>
                    static_iaq = bsec_outputs[index].signal;
   17f2e:	edd6 3a02 	vldr	s7, [r6, #8]
                    break;
   17f32:	e7f7      	b.n	17f24 <bsec_iot_loop+0x268>
                    co2_equivalent = bsec_outputs[index].signal;
   17f34:	ed96 4a02 	vldr	s8, [r6, #8]
                    break;
   17f38:	e7f4      	b.n	17f24 <bsec_iot_loop+0x268>
                    breath_voc_equivalent = bsec_outputs[index].signal;
   17f3a:	edd6 4a02 	vldr	s9, [r6, #8]
                    break;
   17f3e:	e7f1      	b.n	17f24 <bsec_iot_loop+0x268>
                    temp = bsec_outputs[index].signal;
   17f40:	edd6 0a02 	vldr	s1, [r6, #8]
                    break;
   17f44:	e7ee      	b.n	17f24 <bsec_iot_loop+0x268>
                    raw_pressure = bsec_outputs[index].signal;
   17f46:	edd6 1a02 	vldr	s3, [r6, #8]
                    break;
   17f4a:	e7eb      	b.n	17f24 <bsec_iot_loop+0x268>
                    humidity = bsec_outputs[index].signal;
   17f4c:	ed96 1a02 	vldr	s2, [r6, #8]
                    break;
   17f50:	e7e8      	b.n	17f24 <bsec_iot_loop+0x268>
                    raw_gas = bsec_outputs[index].signal;
   17f52:	ed96 3a02 	vldr	s6, [r6, #8]
                    break;
   17f56:	e7e5      	b.n	17f24 <bsec_iot_loop+0x268>
                    raw_temp = bsec_outputs[index].signal;
   17f58:	ed96 2a02 	vldr	s4, [r6, #8]
                    break;
   17f5c:	e7e2      	b.n	17f24 <bsec_iot_loop+0x268>
                    raw_humidity = bsec_outputs[index].signal;
   17f5e:	edd6 2a02 	vldr	s5, [r6, #8]
                    break;
   17f62:	e7df      	b.n	17f24 <bsec_iot_loop+0x268>
            n_samples = 0;
   17f64:	2500      	movs	r5, #0
   17f66:	e7a9      	b.n	17ebc <bsec_iot_loop+0x200>
   17f68:	00000000 	.word	0x00000000
   17f6c:	20021624 	.word	0x20021624
   17f70:	20021680 	.word	0x20021680
   17f74:	42c80000 	.word	0x42c80000
   17f78:	447a0000 	.word	0x447a0000
   17f7c:	fffffc18 	.word	0xfffffc18
   17f80:	000f423f 	.word	0x000f423f
   17f84:	000f4240 	.word	0x000f4240
   17f88:	2002167c 	.word	0x2002167c

00017f8c <bme680_set_sensor_settings>:
 */
int8_t bme680_set_sensor_settings(uint16_t desired_settings, struct bme680_dev *dev)
{
	int8_t rslt;
	uint8_t reg_addr;
	uint8_t data = 0;
   17f8c:	2300      	movs	r3, #0
{
   17f8e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   17f92:	4606      	mov	r6, r0
   17f94:	b088      	sub	sp, #32
	uint8_t reg_array[BME680_REG_BUFFER_LENGTH] = { 0 };
	uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 };
	uint8_t intended_power_mode = dev->power_mode; /* Save intended power mode */

	/* Check for null pointer in the device structure*/
	rslt = null_ptr_check(dev);
   17f96:	4608      	mov	r0, r1
{
   17f98:	460c      	mov	r4, r1
	uint8_t data = 0;
   17f9a:	f88d 3007 	strb.w	r3, [sp, #7]
	uint8_t reg_array[BME680_REG_BUFFER_LENGTH] = { 0 };
   17f9e:	9304      	str	r3, [sp, #16]
   17fa0:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint8_t data_array[BME680_REG_BUFFER_LENGTH] = { 0 };
   17fa4:	9306      	str	r3, [sp, #24]
   17fa6:	f8ad 301c 	strh.w	r3, [sp, #28]
	rslt = null_ptr_check(dev);
   17faa:	f01a ff51 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   17fae:	2800      	cmp	r0, #0
   17fb0:	f040 8101 	bne.w	181b6 <bme680_set_sensor_settings+0x22a>
		if (desired_settings & BME680_GAS_MEAS_SEL)
   17fb4:	f016 0308 	ands.w	r3, r6, #8
	uint8_t intended_power_mode = dev->power_mode; /* Save intended power mode */
   17fb8:	f891 7044 	ldrb.w	r7, [r1, #68]	; 0x44
		if (desired_settings & BME680_GAS_MEAS_SEL)
   17fbc:	d105      	bne.n	17fca <bme680_set_sensor_settings+0x3e>
			rslt = set_gas_config(dev);

		dev->power_mode = BME680_SLEEP_MODE;
   17fbe:	f881 3044 	strb.w	r3, [r1, #68]	; 0x44
		if (rslt == BME680_OK)
			rslt = bme680_set_sensor_mode(dev);
   17fc2:	4620      	mov	r0, r4
   17fc4:	f01b f91a 	bl	331fc <bme680_set_sensor_mode>
   17fc8:	e009      	b.n	17fde <bme680_set_sensor_settings+0x52>
	if (rslt == BME680_OK) {

		uint8_t reg_addr[2] = {0};
		uint8_t reg_data[2] = {0};

		if (dev->power_mode == BME680_FORCED_MODE) {
   17fca:	2f01      	cmp	r7, #1
		uint8_t reg_addr[2] = {0};
   17fcc:	f8ad 0008 	strh.w	r0, [sp, #8]
		uint8_t reg_data[2] = {0};
   17fd0:	f8ad 000c 	strh.w	r0, [sp, #12]
		if (dev->power_mode == BME680_FORCED_MODE) {
   17fd4:	f000 80f2 	beq.w	181bc <bme680_set_sensor_settings+0x230>
		dev->power_mode = BME680_SLEEP_MODE;
   17fd8:	f881 0044 	strb.w	r0, [r1, #68]	; 0x44
			reg_data[0] = calc_heater_res(dev->gas_sett.heatr_temp, dev);
			reg_addr[1] = BME680_GAS_WAIT0_ADDR;
			reg_data[1] = calc_heater_dur(dev->gas_sett.heatr_dur);
			dev->gas_sett.nb_conv = 0;
		} else {
			rslt = BME680_W_DEFINE_PWR_MODE;
   17fdc:	2001      	movs	r0, #1
		if (desired_settings & BME680_FILTER_SEL) {
   17fde:	f016 0510 	ands.w	r5, r6, #16
   17fe2:	d020      	beq.n	18026 <bme680_set_sensor_settings+0x9a>
			rslt = boundary_check(&dev->tph_sett.filter, BME680_FILTER_SIZE_0, BME680_FILTER_SIZE_127, dev);
   17fe4:	f104 0246 	add.w	r2, r4, #70	; 0x46
   17fe8:	2107      	movs	r1, #7
   17fea:	f104 003b 	add.w	r0, r4, #59	; 0x3b
   17fee:	f01a ff87 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK)
   17ff2:	b930      	cbnz	r0, 18002 <bme680_set_sensor_settings+0x76>
				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
   17ff4:	4623      	mov	r3, r4
   17ff6:	2201      	movs	r2, #1
   17ff8:	f10d 0107 	add.w	r1, sp, #7
   17ffc:	2075      	movs	r0, #117	; 0x75
   17ffe:	f01a ff8b 	bl	32f18 <bme680_get_regs>
				data = BME680_SET_BITS(data, BME680_FILTER, dev->tph_sett.filter);
   18002:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
   18006:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1800a:	009b      	lsls	r3, r3, #2
   1800c:	f022 021c 	bic.w	r2, r2, #28
   18010:	f003 031c 	and.w	r3, r3, #28
   18014:	4313      	orrs	r3, r2
			reg_array[count] = reg_addr; /* Append configuration */
   18016:	2275      	movs	r2, #117	; 0x75
			count++;
   18018:	2501      	movs	r5, #1
				data = BME680_SET_BITS(data, BME680_FILTER, dev->tph_sett.filter);
   1801a:	f88d 3007 	strb.w	r3, [sp, #7]
			reg_array[count] = reg_addr; /* Append configuration */
   1801e:	f88d 2010 	strb.w	r2, [sp, #16]
			data_array[count] = data;
   18022:	f88d 3018 	strb.w	r3, [sp, #24]
		if (desired_settings & BME680_HCNTRL_SEL) {
   18026:	06b3      	lsls	r3, r6, #26
   18028:	d522      	bpl.n	18070 <bme680_set_sensor_settings+0xe4>
			rslt = boundary_check(&dev->gas_sett.heatr_ctrl, BME680_ENABLE_HEATER,
   1802a:	f104 0246 	add.w	r2, r4, #70	; 0x46
   1802e:	2108      	movs	r1, #8
   18030:	f104 003d 	add.w	r0, r4, #61	; 0x3d
   18034:	f01a ff64 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK)
   18038:	b930      	cbnz	r0, 18048 <bme680_set_sensor_settings+0xbc>
				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
   1803a:	4623      	mov	r3, r4
   1803c:	2201      	movs	r2, #1
   1803e:	f10d 0107 	add.w	r1, sp, #7
   18042:	2070      	movs	r0, #112	; 0x70
   18044:	f01a ff68 	bl	32f18 <bme680_get_regs>
			reg_array[count] = reg_addr; /* Append configuration */
   18048:	2170      	movs	r1, #112	; 0x70
			data = BME680_SET_BITS_POS_0(data, BME680_HCTRL, dev->gas_sett.heatr_ctrl);
   1804a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1804e:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
   18052:	f023 0308 	bic.w	r3, r3, #8
   18056:	f002 0208 	and.w	r2, r2, #8
   1805a:	4313      	orrs	r3, r2
			reg_array[count] = reg_addr; /* Append configuration */
   1805c:	aa08      	add	r2, sp, #32
   1805e:	442a      	add	r2, r5
			count++;
   18060:	3501      	adds	r5, #1
			data = BME680_SET_BITS_POS_0(data, BME680_HCTRL, dev->gas_sett.heatr_ctrl);
   18062:	f88d 3007 	strb.w	r3, [sp, #7]
			reg_array[count] = reg_addr; /* Append configuration */
   18066:	f802 1c10 	strb.w	r1, [r2, #-16]
			data_array[count] = data;
   1806a:	f802 3c08 	strb.w	r3, [r2, #-8]
			count++;
   1806e:	b2ed      	uxtb	r5, r5
		if (desired_settings & (BME680_OST_SEL | BME680_OSP_SEL)) {
   18070:	07b1      	lsls	r1, r6, #30
   18072:	d033      	beq.n	180dc <bme680_set_sensor_settings+0x150>
			rslt = boundary_check(&dev->tph_sett.os_temp, BME680_OS_NONE, BME680_OS_16X, dev);
   18074:	f104 0246 	add.w	r2, r4, #70	; 0x46
   18078:	2105      	movs	r1, #5
   1807a:	f104 0039 	add.w	r0, r4, #57	; 0x39
   1807e:	f01a ff3f 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK)
   18082:	b930      	cbnz	r0, 18092 <bme680_set_sensor_settings+0x106>
				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
   18084:	4623      	mov	r3, r4
   18086:	2201      	movs	r2, #1
   18088:	f10d 0107 	add.w	r1, sp, #7
   1808c:	2074      	movs	r0, #116	; 0x74
   1808e:	f01a ff43 	bl	32f18 <bme680_get_regs>
			if (desired_settings & BME680_OST_SEL)
   18092:	07f2      	lsls	r2, r6, #31
   18094:	d509      	bpl.n	180aa <bme680_set_sensor_settings+0x11e>
				data = BME680_SET_BITS(data, BME680_OST, dev->tph_sett.os_temp);
   18096:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1809a:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
   1809e:	f003 031f 	and.w	r3, r3, #31
   180a2:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
   180a6:	f88d 3007 	strb.w	r3, [sp, #7]
			if (desired_settings & BME680_OSP_SEL)
   180aa:	07b3      	lsls	r3, r6, #30
   180ac:	d50b      	bpl.n	180c6 <bme680_set_sensor_settings+0x13a>
				data = BME680_SET_BITS(data, BME680_OSP, dev->tph_sett.os_pres);
   180ae:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
   180b2:	f89d 2007 	ldrb.w	r2, [sp, #7]
   180b6:	009b      	lsls	r3, r3, #2
   180b8:	f003 031c 	and.w	r3, r3, #28
   180bc:	f022 021c 	bic.w	r2, r2, #28
   180c0:	4313      	orrs	r3, r2
   180c2:	f88d 3007 	strb.w	r3, [sp, #7]
			reg_array[count] = reg_addr;
   180c6:	2274      	movs	r2, #116	; 0x74
   180c8:	ab08      	add	r3, sp, #32
   180ca:	442b      	add	r3, r5
   180cc:	f803 2c10 	strb.w	r2, [r3, #-16]
			data_array[count] = data;
   180d0:	f89d 2007 	ldrb.w	r2, [sp, #7]
			count++;
   180d4:	3501      	adds	r5, #1
			data_array[count] = data;
   180d6:	f803 2c08 	strb.w	r2, [r3, #-8]
			count++;
   180da:	b2ed      	uxtb	r5, r5
		if (desired_settings & BME680_OSH_SEL) {
   180dc:	0771      	lsls	r1, r6, #29
   180de:	d522      	bpl.n	18126 <bme680_set_sensor_settings+0x19a>
			rslt = boundary_check(&dev->tph_sett.os_hum, BME680_OS_NONE, BME680_OS_16X, dev);
   180e0:	f104 0246 	add.w	r2, r4, #70	; 0x46
   180e4:	2105      	movs	r1, #5
   180e6:	f104 0038 	add.w	r0, r4, #56	; 0x38
   180ea:	f01a ff09 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK)
   180ee:	b930      	cbnz	r0, 180fe <bme680_set_sensor_settings+0x172>
				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
   180f0:	4623      	mov	r3, r4
   180f2:	2201      	movs	r2, #1
   180f4:	f10d 0107 	add.w	r1, sp, #7
   180f8:	2072      	movs	r0, #114	; 0x72
   180fa:	f01a ff0d 	bl	32f18 <bme680_get_regs>
			reg_array[count] = reg_addr; /* Append configuration */
   180fe:	2172      	movs	r1, #114	; 0x72
			data = BME680_SET_BITS_POS_0(data, BME680_OSH, dev->tph_sett.os_hum);
   18100:	f89d 3007 	ldrb.w	r3, [sp, #7]
   18104:	f894 2038 	ldrb.w	r2, [r4, #56]	; 0x38
   18108:	f023 0307 	bic.w	r3, r3, #7
   1810c:	f002 0207 	and.w	r2, r2, #7
   18110:	4313      	orrs	r3, r2
			reg_array[count] = reg_addr; /* Append configuration */
   18112:	aa08      	add	r2, sp, #32
   18114:	442a      	add	r2, r5
			count++;
   18116:	3501      	adds	r5, #1
			data = BME680_SET_BITS_POS_0(data, BME680_OSH, dev->tph_sett.os_hum);
   18118:	f88d 3007 	strb.w	r3, [sp, #7]
			reg_array[count] = reg_addr; /* Append configuration */
   1811c:	f802 1c10 	strb.w	r1, [r2, #-16]
			data_array[count] = data;
   18120:	f802 3c08 	strb.w	r3, [r2, #-8]
			count++;
   18124:	b2ed      	uxtb	r5, r5
		if (desired_settings & (BME680_RUN_GAS_SEL | BME680_NBCONV_SEL)) {
   18126:	f016 0fc0 	tst.w	r6, #192	; 0xc0
   1812a:	d03b      	beq.n	181a4 <bme680_set_sensor_settings+0x218>
			rslt = boundary_check(&dev->gas_sett.run_gas, BME680_RUN_GAS_DISABLE,
   1812c:	f104 0846 	add.w	r8, r4, #70	; 0x46
   18130:	4642      	mov	r2, r8
   18132:	2101      	movs	r1, #1
   18134:	f104 003e 	add.w	r0, r4, #62	; 0x3e
   18138:	f01a fee2 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK) {
   1813c:	b960      	cbnz	r0, 18158 <bme680_set_sensor_settings+0x1cc>
				rslt = boundary_check(&dev->gas_sett.nb_conv, BME680_NBCONV_MIN,
   1813e:	210a      	movs	r1, #10
   18140:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   18144:	f01a fedc 	bl	32f00 <boundary_check.isra.1.constprop.6>
			if (rslt == BME680_OK)
   18148:	b930      	cbnz	r0, 18158 <bme680_set_sensor_settings+0x1cc>
				rslt = bme680_get_regs(reg_addr, &data, 1, dev);
   1814a:	4623      	mov	r3, r4
   1814c:	2201      	movs	r2, #1
   1814e:	f10d 0107 	add.w	r1, sp, #7
   18152:	2071      	movs	r0, #113	; 0x71
   18154:	f01a fee0 	bl	32f18 <bme680_get_regs>
			if (desired_settings & BME680_RUN_GAS_SEL)
   18158:	0672      	lsls	r2, r6, #25
   1815a:	d50b      	bpl.n	18174 <bme680_set_sensor_settings+0x1e8>
				data = BME680_SET_BITS(data, BME680_RUN_GAS, dev->gas_sett.run_gas);
   1815c:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
   18160:	f89d 2007 	ldrb.w	r2, [sp, #7]
   18164:	011b      	lsls	r3, r3, #4
   18166:	f003 0310 	and.w	r3, r3, #16
   1816a:	f022 0210 	bic.w	r2, r2, #16
   1816e:	4313      	orrs	r3, r2
   18170:	f88d 3007 	strb.w	r3, [sp, #7]
			if (desired_settings & BME680_NBCONV_SEL)
   18174:	0633      	lsls	r3, r6, #24
   18176:	d50a      	bpl.n	1818e <bme680_set_sensor_settings+0x202>
				data = BME680_SET_BITS_POS_0(data, BME680_NBCONV, dev->gas_sett.nb_conv);
   18178:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1817c:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
   18180:	f023 030f 	bic.w	r3, r3, #15
   18184:	f002 020f 	and.w	r2, r2, #15
   18188:	4313      	orrs	r3, r2
   1818a:	f88d 3007 	strb.w	r3, [sp, #7]
			reg_array[count] = reg_addr; /* Append configuration */
   1818e:	2271      	movs	r2, #113	; 0x71
   18190:	ab08      	add	r3, sp, #32
   18192:	442b      	add	r3, r5
   18194:	f803 2c10 	strb.w	r2, [r3, #-16]
			data_array[count] = data;
   18198:	f89d 2007 	ldrb.w	r2, [sp, #7]
			count++;
   1819c:	3501      	adds	r5, #1
			data_array[count] = data;
   1819e:	f803 2c08 	strb.w	r2, [r3, #-8]
			count++;
   181a2:	b2ed      	uxtb	r5, r5
		if (rslt == BME680_OK)
   181a4:	b928      	cbnz	r0, 181b2 <bme680_set_sensor_settings+0x226>
			rslt = bme680_set_regs(reg_array, data_array, count, dev);
   181a6:	4623      	mov	r3, r4
   181a8:	462a      	mov	r2, r5
   181aa:	a906      	add	r1, sp, #24
   181ac:	a804      	add	r0, sp, #16
   181ae:	f01a fed7 	bl	32f60 <bme680_set_regs>
		dev->power_mode = intended_power_mode;
   181b2:	f884 7044 	strb.w	r7, [r4, #68]	; 0x44
}
   181b6:	b008      	add	sp, #32
   181b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	if (temp > 400) /* Cap temperature */
		temp = 400;

	var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
	var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
   181bc:	8a4a      	ldrh	r2, [r1, #18]
   181be:	2105      	movs	r1, #5
   181c0:	4b30      	ldr	r3, [pc, #192]	; (18284 <bme680_set_sensor_settings+0x2f8>)
	var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
   181c2:	f994 5014 	ldrsb.w	r5, [r4, #20]
	var2 = (dev->calib.par_gh1 + 784) * (((((dev->calib.par_gh2 + 154009) * temp * 5) / 100) + 3276800) / 10);
   181c6:	fb12 3301 	smlabb	r3, r2, r1, r3
   181ca:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
   181ce:	2164      	movs	r1, #100	; 0x64
   181d0:	f5b2 7fc8 	cmp.w	r2, #400	; 0x190
   181d4:	bf28      	it	cs
   181d6:	f44f 72c8 	movcs.w	r2, #400	; 0x190
   181da:	435a      	muls	r2, r3
   181dc:	fbb2 f2f1 	udiv	r2, r2, r1
   181e0:	230a      	movs	r3, #10
   181e2:	f502 1248 	add.w	r2, r2, #3276800	; 0x320000
   181e6:	fbb2 f2f3 	udiv	r2, r2, r3
   181ea:	f994 3011 	ldrsb.w	r3, [r4, #17]
   181ee:	f503 7344 	add.w	r3, r3, #784	; 0x310
   181f2:	435a      	muls	r2, r3
	var1 = (((int32_t) dev->amb_temp * dev->calib.par_gh3) / 1000) * 256;
   181f4:	f994 3004 	ldrsb.w	r3, [r4, #4]
   181f8:	fb13 f305 	smulbb	r3, r3, r5
   181fc:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   18200:	fb93 f3f5 	sdiv	r3, r3, r5
   18204:	021b      	lsls	r3, r3, #8
	var3 = var1 + (var2 / 2);
   18206:	eb03 0362 	add.w	r3, r3, r2, asr #1
	var4 = (var3 / (dev->calib.res_heat_range + 4));
   1820a:	f894 2034 	ldrb.w	r2, [r4, #52]	; 0x34
	var5 = (131 * dev->calib.res_heat_val) + 65536;
   1820e:	f994 5035 	ldrsb.w	r5, [r4, #53]	; 0x35
	var4 = (var3 / (dev->calib.res_heat_range + 4));
   18212:	3204      	adds	r2, #4
   18214:	fbb3 f3f2 	udiv	r3, r3, r2
	var5 = (131 * dev->calib.res_heat_val) + 65536;
   18218:	2283      	movs	r2, #131	; 0x83
   1821a:	436a      	muls	r2, r5
   1821c:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
	heatr_res_x100 = (int32_t) (((var4 / var5) - 250) * 34);
   18220:	fbb3 f3f2 	udiv	r3, r3, r2
   18224:	2222      	movs	r2, #34	; 0x22
   18226:	4353      	muls	r3, r2
	heatr_res = (uint8_t) ((heatr_res_x100 + 50) / 100);
   18228:	f5a3 5304 	sub.w	r3, r3, #8448	; 0x2100
   1822c:	3b02      	subs	r3, #2
   1822e:	fb93 f3f1 	sdiv	r3, r3, r1
   18232:	f88d 300c 	strb.w	r3, [sp, #12]
			reg_addr[0] = BME680_RES_HEAT0_ADDR;
   18236:	f246 435a 	movw	r3, #25690	; 0x645a
   1823a:	f8ad 3008 	strh.w	r3, [sp, #8]
			reg_data[1] = calc_heater_dur(dev->gas_sett.heatr_dur);
   1823e:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
static uint8_t calc_heater_dur(uint16_t dur)
{
	uint8_t factor = 0;
	uint8_t durval;

	if (dur >= 0xfc0) {
   18242:	f5b3 6f7c 	cmp.w	r3, #4032	; 0xfc0
   18246:	d21a      	bcs.n	1827e <bme680_set_sensor_settings+0x2f2>
		durval = 0xff; /* Max duration*/
	} else {
		while (dur > 0x3F) {
   18248:	2b3f      	cmp	r3, #63	; 0x3f
   1824a:	b242      	sxtb	r2, r0
   1824c:	f100 0001 	add.w	r0, r0, #1
   18250:	d813      	bhi.n	1827a <bme680_set_sensor_settings+0x2ee>
			dur = dur / 4;
			factor += 1;
		}
		durval = (uint8_t) (dur + (factor * 64));
   18252:	eb03 1382 	add.w	r3, r3, r2, lsl #6
   18256:	b2db      	uxtb	r3, r3
			dev->gas_sett.nb_conv = 0;
   18258:	2500      	movs	r5, #0
			reg_data[1] = calc_heater_dur(dev->gas_sett.heatr_dur);
   1825a:	f88d 300d 	strb.w	r3, [sp, #13]
			dev->gas_sett.nb_conv = 0;
   1825e:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
			rslt = bme680_set_regs(reg_addr, reg_data, 2, dev);
   18262:	4623      	mov	r3, r4
   18264:	2202      	movs	r2, #2
   18266:	a903      	add	r1, sp, #12
   18268:	a802      	add	r0, sp, #8
   1826a:	f01a fe79 	bl	32f60 <bme680_set_regs>
		dev->power_mode = BME680_SLEEP_MODE;
   1826e:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
		if (rslt == BME680_OK)
   18272:	2800      	cmp	r0, #0
   18274:	f47f aeb3 	bne.w	17fde <bme680_set_sensor_settings+0x52>
   18278:	e6a3      	b.n	17fc2 <bme680_set_sensor_settings+0x36>
			dur = dur / 4;
   1827a:	089b      	lsrs	r3, r3, #2
			factor += 1;
   1827c:	e7e4      	b.n	18248 <bme680_set_sensor_settings+0x2bc>
		durval = 0xff; /* Max duration*/
   1827e:	23ff      	movs	r3, #255	; 0xff
   18280:	e7ea      	b.n	18258 <bme680_set_sensor_settings+0x2cc>
   18282:	bf00      	nop
   18284:	000bbffd 	.word	0x000bbffd

00018288 <bme680_get_profile_dur>:
{
   18288:	b513      	push	{r0, r1, r4, lr}
	uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16};
   1828a:	4b18      	ldr	r3, [pc, #96]	; (182ec <bme680_get_profile_dur+0x64>)
	meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp];
   1828c:	aa02      	add	r2, sp, #8
	uint8_t os_to_meas_cycles[6] = {0, 1, 2, 4, 8, 16};
   1828e:	9300      	str	r3, [sp, #0]
   18290:	f241 0308 	movw	r3, #4104	; 0x1008
   18294:	f8ad 3004 	strh.w	r3, [sp, #4]
	meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp];
   18298:	f891 3039 	ldrb.w	r3, [r1, #57]	; 0x39
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres];
   1829c:	f891 403a 	ldrb.w	r4, [r1, #58]	; 0x3a
	meas_cycles = os_to_meas_cycles[dev->tph_sett.os_temp];
   182a0:	4413      	add	r3, r2
   182a2:	f813 2c08 	ldrb.w	r2, [r3, #-8]
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres];
   182a6:	ab02      	add	r3, sp, #8
   182a8:	441c      	add	r4, r3
   182aa:	f814 3c08 	ldrb.w	r3, [r4, #-8]
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum];
   182ae:	ac02      	add	r4, sp, #8
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_pres];
   182b0:	441a      	add	r2, r3
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum];
   182b2:	f891 3038 	ldrb.w	r3, [r1, #56]	; 0x38
   182b6:	4423      	add	r3, r4
   182b8:	f813 3c08 	ldrb.w	r3, [r3, #-8]
	tph_dur += UINT32_C(500); /* Get it to the closest whole number.*/
   182bc:	f240 74ab 	movw	r4, #1963	; 0x7ab
	meas_cycles += os_to_meas_cycles[dev->tph_sett.os_hum];
   182c0:	4413      	add	r3, r2
	tph_dur += UINT32_C(500); /* Get it to the closest whole number.*/
   182c2:	f241 22b9 	movw	r2, #4793	; 0x12b9
   182c6:	fb04 2303 	mla	r3, r4, r3, r2
	tph_dur /= UINT32_C(1000); /* Convert to ms */
   182ca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   182ce:	fbb3 f3f2 	udiv	r3, r3, r2
	tph_dur += UINT32_C(1); /* Wake up duration of 1ms */
   182d2:	3301      	adds	r3, #1
	*duration = (uint16_t) tph_dur;
   182d4:	b29b      	uxth	r3, r3
   182d6:	8003      	strh	r3, [r0, #0]
	if (dev->gas_sett.run_gas) {
   182d8:	f891 203e 	ldrb.w	r2, [r1, #62]	; 0x3e
   182dc:	b11a      	cbz	r2, 182e6 <bme680_get_profile_dur+0x5e>
		*duration += dev->gas_sett.heatr_dur;
   182de:	f8b1 2042 	ldrh.w	r2, [r1, #66]	; 0x42
   182e2:	4413      	add	r3, r2
   182e4:	8003      	strh	r3, [r0, #0]
}
   182e6:	b002      	add	sp, #8
   182e8:	bd10      	pop	{r4, pc}
   182ea:	bf00      	nop
   182ec:	04020100 	.word	0x04020100

000182f0 <bme680_get_sensor_data>:
{
   182f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   182f4:	4606      	mov	r6, r0
   182f6:	b0a9      	sub	sp, #164	; 0xa4
	rslt = null_ptr_check(dev);
   182f8:	4608      	mov	r0, r1
{
   182fa:	460c      	mov	r4, r1
	rslt = null_ptr_check(dev);
   182fc:	f01a fda8 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   18300:	4605      	mov	r5, r0
   18302:	2800      	cmp	r0, #0
   18304:	f040 8199 	bne.w	1863a <bme680_get_sensor_data+0x34a>
 * @brief This internal API is used to calculate the field data of sensor.
 */
static int8_t read_field_data(struct bme680_field_data *data, struct bme680_dev *dev)
{
	int8_t rslt;
	uint8_t buff[BME680_FIELD_LENGTH] = { 0 };
   18308:	f10d 0a10 	add.w	sl, sp, #16
   1830c:	4601      	mov	r1, r0
   1830e:	220f      	movs	r2, #15
   18310:	4650      	mov	r0, sl
   18312:	f020 fe9b 	bl	3904c <memset>
	uint16_t adc_hum;
	uint16_t adc_gas_res;
	uint8_t tries = 10;

	/* Check for null pointer in the device structure*/
	rslt = null_ptr_check(dev);
   18316:	4620      	mov	r0, r4
   18318:	f01a fd9a 	bl	32e50 <null_ptr_check>
   1831c:	f04f 090a 	mov.w	r9, #10
   18320:	4605      	mov	r5, r0
	do {
		if (rslt == BME680_OK) {
   18322:	2d00      	cmp	r5, #0
   18324:	f040 8190 	bne.w	18648 <bme680_get_sensor_data+0x358>
			rslt = bme680_get_regs(((uint8_t) (BME680_FIELD0_ADDR)), buff, (uint16_t) BME680_FIELD_LENGTH,
   18328:	4623      	mov	r3, r4
   1832a:	220f      	movs	r2, #15
   1832c:	4651      	mov	r1, sl
   1832e:	201d      	movs	r0, #29
   18330:	f01a fdf2 	bl	32f18 <bme680_get_regs>
			/* read the raw data from the sensor */
			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
				| ((uint32_t) buff[4] / 16));
			adc_temp = (uint32_t) (((uint32_t) buff[5] * 4096) | ((uint32_t) buff[6] * 16)
				| ((uint32_t) buff[7] / 16));
			adc_hum = (uint16_t) (((uint32_t) buff[8] * 256) | (uint32_t) buff[9]);
   18334:	f89d 1018 	ldrb.w	r1, [sp, #24]
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   18338:	f89d 701e 	ldrb.w	r7, [sp, #30]
			adc_hum = (uint16_t) (((uint32_t) buff[8] * 256) | (uint32_t) buff[9]);
   1833c:	9101      	str	r1, [sp, #4]
   1833e:	f89d 1019 	ldrb.w	r1, [sp, #25]
			data->status = buff[0] & BME680_NEW_DATA_MSK;
   18342:	f89d b010 	ldrb.w	fp, [sp, #16]
			adc_hum = (uint16_t) (((uint32_t) buff[8] * 256) | (uint32_t) buff[9]);
   18346:	9102      	str	r1, [sp, #8]
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   18348:	f89d 101d 	ldrb.w	r1, [sp, #29]
			gas_range = buff[14] & BME680_GAS_RANGE_MSK;

			data->status |= buff[14] & BME680_GASM_VALID_MSK;
   1834c:	fa4f fe87 	sxtb.w	lr, r7
			data->gas_index = buff[0] & BME680_GAS_INDEX_MSK;
   18350:	f00b 030f 	and.w	r3, fp, #15
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   18354:	9103      	str	r1, [sp, #12]
			data->status = buff[0] & BME680_NEW_DATA_MSK;
   18356:	f02b 0b7f 	bic.w	fp, fp, #127	; 0x7f
			data->status |= buff[14] & BME680_GASM_VALID_MSK;
   1835a:	f00e 0120 	and.w	r1, lr, #32
			data->gas_index = buff[0] & BME680_GAS_INDEX_MSK;
   1835e:	7073      	strb	r3, [r6, #1]
			data->status |= buff[14] & BME680_GASM_VALID_MSK;
   18360:	ea4b 0101 	orr.w	r1, fp, r1
			data->meas_index = buff[1];
   18364:	f89d 3011 	ldrb.w	r3, [sp, #17]
			data->status |= buff[14] & BME680_HEAT_STAB_MSK;
   18368:	f00e 0e10 	and.w	lr, lr, #16
   1836c:	ea41 010e 	orr.w	r1, r1, lr
   18370:	b249      	sxtb	r1, r1
			data->meas_index = buff[1];
   18372:	70b3      	strb	r3, [r6, #2]
			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
   18374:	f89d 3012 	ldrb.w	r3, [sp, #18]

			if (data->status & BME680_NEW_DATA_MSK) {
   18378:	2900      	cmp	r1, #0
			rslt = bme680_get_regs(((uint8_t) (BME680_FIELD0_ADDR)), buff, (uint16_t) BME680_FIELD_LENGTH,
   1837a:	4605      	mov	r5, r0
			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
   1837c:	9300      	str	r3, [sp, #0]
   1837e:	f89d c013 	ldrb.w	ip, [sp, #19]
				| ((uint32_t) buff[4] / 16));
   18382:	f89d 3014 	ldrb.w	r3, [sp, #20]
			adc_temp = (uint32_t) (((uint32_t) buff[5] * 4096) | ((uint32_t) buff[6] * 16)
   18386:	f89d 2015 	ldrb.w	r2, [sp, #21]
   1838a:	f89d 8016 	ldrb.w	r8, [sp, #22]
				| ((uint32_t) buff[7] / 16));
   1838e:	f89d 0017 	ldrb.w	r0, [sp, #23]
			data->status |= buff[14] & BME680_HEAT_STAB_MSK;
   18392:	7031      	strb	r1, [r6, #0]
			if (data->status & BME680_NEW_DATA_MSK) {
   18394:	f280 8155 	bge.w	18642 <bme680_get_sensor_data+0x352>
				| ((uint32_t) buff[7] / 16));
   18398:	0900      	lsrs	r0, r0, #4
			adc_temp = (uint32_t) (((uint32_t) buff[5] * 4096) | ((uint32_t) buff[6] * 16)
   1839a:	ea40 1808 	orr.w	r8, r0, r8, lsl #4
   1839e:	ea48 3202 	orr.w	r2, r8, r2, lsl #12
	var1 = ((int32_t) temp_adc >> 3) - ((int32_t) dev->calib.par_t1 << 1);
   183a2:	f8b4 8016 	ldrh.w	r8, [r4, #22]
	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
   183a6:	f994 001a 	ldrsb.w	r0, [r4, #26]
	var1 = ((int32_t) temp_adc >> 3) - ((int32_t) dev->calib.par_t1 << 1);
   183aa:	ea4f 0848 	mov.w	r8, r8, lsl #1
   183ae:	ebc8 02d2 	rsb	r2, r8, r2, lsr #3
   183b2:	17d1      	asrs	r1, r2, #31
	var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
   183b4:	ea4f 0a52 	mov.w	sl, r2, lsr #1
   183b8:	ea4a 7ac1 	orr.w	sl, sl, r1, lsl #31
   183bc:	1049      	asrs	r1, r1, #1
   183be:	fb0a f101 	mul.w	r1, sl, r1
   183c2:	fbaa ab0a 	umull	sl, fp, sl, sl
   183c6:	eb0b 0b41 	add.w	fp, fp, r1, lsl #1
   183ca:	ea4f 3e1a 	mov.w	lr, sl, lsr #12
	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
   183ce:	0101      	lsls	r1, r0, #4
	var3 = ((var1 >> 1) * (var1 >> 1)) >> 12;
   183d0:	ea4e 5e0b 	orr.w	lr, lr, fp, lsl #20
   183d4:	ea4f 382b 	mov.w	r8, fp, asr #12
	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
   183d8:	ea4f 7be1 	mov.w	fp, r1, asr #31
   183dc:	fb0e f00b 	mul.w	r0, lr, fp
   183e0:	fbae ab01 	umull	sl, fp, lr, r1
   183e4:	fb01 0808 	mla	r8, r1, r8, r0
   183e8:	44c3      	add	fp, r8
	var2 = (var1 * (int32_t) dev->calib.par_t2) >> 11;
   183ea:	f9b4 8018 	ldrsh.w	r8, [r4, #24]
	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
   183ee:	ea4f 309a 	mov.w	r0, sl, lsr #14
	var2 = (var1 * (int32_t) dev->calib.par_t2) >> 11;
   183f2:	fb88 8902 	smull	r8, r9, r8, r2
   183f6:	ea4f 22d8 	mov.w	r2, r8, lsr #11
   183fa:	ea42 5249 	orr.w	r2, r2, r9, lsl #21
	var3 = ((var3) * ((int32_t) dev->calib.par_t3 << 4)) >> 14;
   183fe:	ea40 408b 	orr.w	r0, r0, fp, lsl #18
	dev->calib.t_fine = (int32_t) (var2 + var3);
   18402:	4410      	add	r0, r2
   18404:	6320      	str	r0, [r4, #48]	; 0x30
	calc_temp = (int16_t) (((dev->calib.t_fine * 5) + 128) >> 8);
   18406:	eb00 0280 	add.w	r2, r0, r0, lsl #2
	var1 = (((int32_t)dev->calib.t_fine) >> 1) - 64000;
   1840a:	1040      	asrs	r0, r0, #1
   1840c:	f5a0 407a 	sub.w	r0, r0, #64000	; 0xfa00
	var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) *
   18410:	1081      	asrs	r1, r0, #2
   18412:	4349      	muls	r1, r1
	calc_temp = (int16_t) (((dev->calib.t_fine * 5) + 128) >> 8);
   18414:	3280      	adds	r2, #128	; 0x80
   18416:	1212      	asrs	r2, r2, #8
   18418:	80b2      	strh	r2, [r6, #4]
		(int32_t)dev->calib.par_p6) >> 2;
   1841a:	f994 8026 	ldrsb.w	r8, [r4, #38]	; 0x26
	var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) *
   1841e:	ea4f 2ee1 	mov.w	lr, r1, asr #11
   18422:	fb08 f80e 	mul.w	r8, r8, lr
	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
   18426:	f9b4 e024 	ldrsh.w	lr, [r4, #36]	; 0x24
				| ((uint32_t) buff[4] / 16));
   1842a:	091b      	lsrs	r3, r3, #4
	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
   1842c:	fb00 fe0e 	mul.w	lr, r0, lr
			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
   18430:	ea43 1c0c 	orr.w	ip, r3, ip, lsl #4
   18434:	9b00      	ldr	r3, [sp, #0]
	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
   18436:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
			adc_pres = (uint32_t) (((uint32_t) buff[2] * 4096) | ((uint32_t) buff[3] * 16)
   1843a:	ea4c 3c03 	orr.w	ip, ip, r3, lsl #12
	var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
   1843e:	f9b4 3022 	ldrsh.w	r3, [r4, #34]	; 0x22
	var2 = var2 + ((var1 * (int32_t)dev->calib.par_p5) << 1);
   18442:	eb0e 0ea8 	add.w	lr, lr, r8, asr #2
	var2 = (var2 >> 2) + ((int32_t)dev->calib.par_p4 << 16);
   18446:	041b      	lsls	r3, r3, #16
   18448:	eb03 0eae 	add.w	lr, r3, lr, asr #2
	pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
   1844c:	f640 4335 	movw	r3, #3125	; 0xc35
		(((int32_t)dev->calib.par_p2 * var1) >> 1);
   18450:	f9b4 801e 	ldrsh.w	r8, [r4, #30]
	var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
   18454:	1349      	asrs	r1, r1, #13
		(((int32_t)dev->calib.par_p2 * var1) >> 1);
   18456:	fb00 f008 	mul.w	r0, r0, r8
		((int32_t)dev->calib.par_p3 << 5)) >> 3) +
   1845a:	f994 8020 	ldrsb.w	r8, [r4, #32]
	pressure_comp = 1048576 - pres_adc;
   1845e:	f5cc 1c80 	rsb	ip, ip, #1048576	; 0x100000
		((int32_t)dev->calib.par_p3 << 5)) >> 3) +
   18462:	ea4f 1848 	mov.w	r8, r8, lsl #5
	var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
   18466:	fb01 f108 	mul.w	r1, r1, r8
		((int32_t)dev->calib.par_p3 << 5)) >> 3) +
   1846a:	10c9      	asrs	r1, r1, #3
	var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) *
   1846c:	eb01 0060 	add.w	r0, r1, r0, asr #1
	var1 = var1 >> 18;
   18470:	1480      	asrs	r0, r0, #18
	var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
   18472:	8ba1      	ldrh	r1, [r4, #28]
   18474:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
	pressure_comp = (int32_t)((pressure_comp - (var2 >> 12)) * ((uint32_t)3125));
   18478:	ebac 3e2e 	sub.w	lr, ip, lr, asr #12
   1847c:	fb03 fe0e 	mul.w	lr, r3, lr
	var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
   18480:	4341      	muls	r1, r0
	if (pressure_comp >= BME680_MAX_OVERFLOW_VAL)
   18482:	f1be 4f80 	cmp.w	lr, #1073741824	; 0x40000000
	var1 = ((32768 + var1) * (int32_t)dev->calib.par_p1) >> 15;
   18486:	ea4f 31e1 	mov.w	r1, r1, asr #15
		pressure_comp = ((pressure_comp / var1) << 1);
   1848a:	bfad      	iteet	ge
   1848c:	fb9e f3f1 	sdivge	r3, lr, r1
		pressure_comp = ((pressure_comp << 1) / var1);
   18490:	ea4f 0e4e 	movlt.w	lr, lr, lsl #1
   18494:	fb9e f3f1 	sdivlt	r3, lr, r1
		pressure_comp = ((pressure_comp / var1) << 1);
   18498:	005b      	lslge	r3, r3, #1
		(int32_t)dev->calib.par_p8) >> 13;
   1849a:	f9b4 0028 	ldrsh.w	r0, [r4, #40]	; 0x28
	var2 = ((int32_t)(pressure_comp >> 2) *
   1849e:	ea4f 0ea3 	mov.w	lr, r3, asr #2
   184a2:	fb00 fe0e 	mul.w	lr, r0, lr
	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
   184a6:	10d9      	asrs	r1, r3, #3
		((int32_t)dev->calib.par_p7 << 7)) >> 4);
   184a8:	f994 0027 	ldrsb.w	r0, [r4, #39]	; 0x27
	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
   184ac:	4349      	muls	r1, r1
		((int32_t)dev->calib.par_p7 << 7)) >> 4);
   184ae:	01c0      	lsls	r0, r0, #7
	pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 +
   184b0:	eb00 306e 	add.w	r0, r0, lr, asr #13
	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
   184b4:	f9b4 e02a 	ldrsh.w	lr, [r4, #42]	; 0x2a
		(pressure_comp >> 3)) >> 13)) >> 12;
   184b8:	1349      	asrs	r1, r1, #13
	var1 = ((int32_t)dev->calib.par_p9 * (int32_t)(((pressure_comp >> 3) *
   184ba:	fb0e f101 	mul.w	r1, lr, r1
	var3 = ((int32_t)(pressure_comp >> 8) * (int32_t)(pressure_comp >> 8) *
   184be:	ea4f 2c23 	mov.w	ip, r3, asr #8
   184c2:	fb0c fe0c 	mul.w	lr, ip, ip
	pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 +
   184c6:	eb00 3121 	add.w	r1, r0, r1, asr #12
		(int32_t)dev->calib.par_p10) >> 17;
   184ca:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
		(int32_t)(pressure_comp >> 8) *
   184ce:	fb00 f00e 	mul.w	r0, r0, lr
   184d2:	fb0c f000 	mul.w	r0, ip, r0
	pressure_comp = (int32_t)(pressure_comp) + ((var1 + var2 + var3 +
   184d6:	eb01 4060 	add.w	r0, r1, r0, asr #17
   184da:	eb03 1320 	add.w	r3, r3, r0, asr #4
			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
   184de:	2064      	movs	r0, #100	; 0x64
				data->temperature = calc_temperature(adc_temp, dev);
				data->pressure = calc_pressure(adc_pres, dev);
   184e0:	60b3      	str	r3, [r6, #8]
			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
   184e2:	f994 100e 	ldrsb.w	r1, [r4, #14]
		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
   184e6:	f994 300d 	ldrsb.w	r3, [r4, #13]
			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
   184ea:	4351      	muls	r1, r2
   184ec:	fb91 f1f0 	sdiv	r1, r1, r0
		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
   184f0:	4353      	muls	r3, r2
			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
   184f2:	4351      	muls	r1, r2
		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
   184f4:	fb93 f3f0 	sdiv	r3, r3, r0
			+ (((temp_scaled * ((temp_scaled * (int32_t) dev->calib.par_h5) / ((int32_t) 100))) >> 6)
   184f8:	1189      	asrs	r1, r1, #6
				/ ((int32_t) 100)) + (int32_t) (1 << 14))) >> 10;
   184fa:	fb91 f1f0 	sdiv	r1, r1, r0
	var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16)))
   184fe:	f06f 0e0f 	mvn.w	lr, #15
	var2 = ((int32_t) dev->calib.par_h2
   18502:	f8b4 c00a 	ldrh.w	ip, [r4, #10]
				/ ((int32_t) 100)) + (int32_t) (1 << 14))) >> 10;
   18506:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
   1850a:	4419      	add	r1, r3
		* (((temp_scaled * (int32_t) dev->calib.par_h4) / ((int32_t) 100))
   1850c:	fb0c f101 	mul.w	r1, ip, r1
	var2 = ((int32_t) dev->calib.par_h2
   18510:	ea4f 2ca1 	mov.w	ip, r1, asr #10
	var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16)))
   18514:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
   18518:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
   1851c:	8921      	ldrh	r1, [r4, #8]
   1851e:	fb0e 3101 	mla	r1, lr, r1, r3
		- (((temp_scaled * (int32_t) dev->calib.par_h3) / ((int32_t) 100)) >> 1);
   18522:	f994 300c 	ldrsb.w	r3, [r4, #12]
	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
   18526:	f10d 0e20 	add.w	lr, sp, #32
		- (((temp_scaled * (int32_t) dev->calib.par_h3) / ((int32_t) 100)) >> 1);
   1852a:	4353      	muls	r3, r2
   1852c:	fb93 f3f0 	sdiv	r3, r3, r0
	var1 = (int32_t) (hum_adc - ((int32_t) ((int32_t) dev->calib.par_h1 * 16)))
   18530:	eba1 0163 	sub.w	r1, r1, r3, asr #1
	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
   18534:	f994 3010 	ldrsb.w	r3, [r4, #16]
	var3 = var1 * var2;
   18538:	fb01 f10c 	mul.w	r1, r1, ip
	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
   1853c:	4353      	muls	r3, r2
   1853e:	fb93 f3f0 	sdiv	r3, r3, r0
	var4 = (int32_t) dev->calib.par_h6 << 7;
   18542:	7be2      	ldrb	r2, [r4, #15]
	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
   18544:	f8df c11c 	ldr.w	ip, [pc, #284]	; 18664 <bme680_get_sensor_data+0x374>
	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
   18548:	eb03 13c2 	add.w	r3, r3, r2, lsl #7
	var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
   1854c:	138a      	asrs	r2, r1, #14
   1854e:	4352      	muls	r2, r2
	var4 = ((var4) + ((temp_scaled * (int32_t) dev->calib.par_h7) / ((int32_t) 100))) >> 4;
   18550:	111b      	asrs	r3, r3, #4
	var5 = ((var3 >> 14) * (var3 >> 14)) >> 10;
   18552:	1292      	asrs	r2, r2, #10
	var6 = (var4 * var5) >> 1;
   18554:	4353      	muls	r3, r2
	calc_hum = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12;
   18556:	eb01 0363 	add.w	r3, r1, r3, asr #1
   1855a:	1299      	asrs	r1, r3, #10
   1855c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   18560:	434b      	muls	r3, r1
				data->humidity = calc_humidity(adc_hum, dev);
   18562:	4a3f      	ldr	r2, [pc, #252]	; (18660 <bme680_get_sensor_data+0x370>)
	calc_hum = (((var3 + var6) >> 10) * ((int32_t) 1000)) >> 12;
   18564:	131b      	asrs	r3, r3, #12
   18566:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
				data->humidity = calc_humidity(adc_hum, dev);
   1856a:	4293      	cmp	r3, r2
   1856c:	bfd4      	ite	le
   1856e:	60f3      	strle	r3, [r6, #12]
   18570:	60f2      	strgt	r2, [r6, #12]
				data->gas_resistance = calc_gas_resistance(adc_gas_res, gas_range, dev);
   18572:	f994 8036 	ldrsb.w	r8, [r4, #54]	; 0x36
	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
   18576:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1857a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   1857e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   18582:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   18586:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1858a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   1858e:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
	uint32_t lookupTable2[16] = { UINT32_C(4096000000), UINT32_C(2048000000), UINT32_C(1024000000), UINT32_C(512000000),
   18592:	f10c 0c10 	add.w	ip, ip, #16
	uint32_t lookupTable1[16] = { UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
   18596:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
	uint32_t lookupTable2[16] = { UINT32_C(4096000000), UINT32_C(2048000000), UINT32_C(1024000000), UINT32_C(512000000),
   1859a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   1859e:	f10d 0e60 	add.w	lr, sp, #96	; 0x60
   185a2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   185a6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   185aa:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   185ae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
   185b2:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
   185b6:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
   185ba:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}
	var1 = (int64_t) ((1340 + (5 * (int64_t) dev->calib.range_sw_err)) *
   185be:	2305      	movs	r3, #5
   185c0:	f240 503c 	movw	r0, #1340	; 0x53c
   185c4:	2100      	movs	r1, #0
		((int64_t) lookupTable1[gas_range])) >> 16;
   185c6:	f007 0c0f 	and.w	ip, r7, #15
	var1 = (int64_t) ((1340 + (5 * (int64_t) dev->calib.range_sw_err)) *
   185ca:	fbc8 0103 	smlal	r0, r1, r8, r3
		((int64_t) lookupTable1[gas_range])) >> 16;
   185ce:	ab28      	add	r3, sp, #160	; 0xa0
   185d0:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   185d4:	f85c ec80 	ldr.w	lr, [ip, #-128]
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   185d8:	ea4f 1897 	mov.w	r8, r7, lsr #6
	var1 = (int64_t) ((1340 + (5 * (int64_t) dev->calib.range_sw_err)) *
   185dc:	fba0 230e 	umull	r2, r3, r0, lr
   185e0:	fb0e 3301 	mla	r3, lr, r1, r3
   185e4:	0c11      	lsrs	r1, r2, #16
   185e6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   185ea:	1418      	asrs	r0, r3, #16
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   185ec:	9b03      	ldr	r3, [sp, #12]
	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
   185ee:	f85c 7c40 	ldr.w	r7, [ip, #-64]
			adc_gas_res = (uint16_t) ((uint32_t) buff[13] * 4 | (((uint32_t) buff[14]) / 64));
   185f2:	ea48 0883 	orr.w	r8, r8, r3, lsl #2
	var2 = (((int64_t) ((int64_t) gas_res_adc << 15) - (int64_t) (16777216)) + var1);
   185f6:	fa1f f888 	uxth.w	r8, r8
   185fa:	ea4f 4358 	mov.w	r3, r8, lsr #17
   185fe:	ea4f 32c8 	mov.w	r2, r8, lsl #15
	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
   18602:	fba7 8901 	umull	r8, r9, r7, r1
   18606:	fb07 9900 	mla	r9, r7, r0, r9
	var2 = (((int64_t) ((int64_t) gas_res_adc << 15) - (int64_t) (16777216)) + var1);
   1860a:	f112 427f 	adds.w	r2, r2, #4278190080	; 0xff000000
   1860e:	f143 33ff 	adc.w	r3, r3, #4294967295	; 0xffffffff
   18612:	1852      	adds	r2, r2, r1
   18614:	eb40 0303 	adc.w	r3, r0, r3
	calc_gas_res = (uint32_t) ((var3 + ((int64_t) var2 >> 1)) / (int64_t) var2);
   18618:	0857      	lsrs	r7, r2, #1
	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
   1861a:	ea4f 2058 	mov.w	r0, r8, lsr #9
	calc_gas_res = (uint32_t) ((var3 + ((int64_t) var2 >> 1)) / (int64_t) var2);
   1861e:	ea47 77c3 	orr.w	r7, r7, r3, lsl #31
	var3 = (((int64_t) lookupTable2[gas_range] * (int64_t) var1) >> 9);
   18622:	ea40 50c9 	orr.w	r0, r0, r9, lsl #23
   18626:	ea4f 2c69 	mov.w	ip, r9, asr #9
	calc_gas_res = (uint32_t) ((var3 + ((int64_t) var2 >> 1)) / (int64_t) var2);
   1862a:	1059      	asrs	r1, r3, #1
   1862c:	19c0      	adds	r0, r0, r7
   1862e:	eb4c 0101 	adc.w	r1, ip, r1
   18632:	f7f5 f84d 	bl	d6d0 <__aeabi_ldivmod>
				data->gas_resistance = calc_gas_resistance(adc_gas_res, gas_range, dev);
   18636:	6130      	str	r0, [r6, #16]
		if (rslt == BME680_OK) {
   18638:	b175      	cbz	r5, 18658 <bme680_get_sensor_data+0x368>
}
   1863a:	4628      	mov	r0, r5
   1863c:	b029      	add	sp, #164	; 0xa4
   1863e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				break;
			}
			/* Delay to poll the data */
			dev->delay_ms(BME680_POLL_PERIOD_MS);
   18642:	6d23      	ldr	r3, [r4, #80]	; 0x50
   18644:	200a      	movs	r0, #10
   18646:	4798      	blx	r3
		}
		tries--;
   18648:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
	} while (tries);
   1864c:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
   18650:	f47f ae67 	bne.w	18322 <bme680_get_sensor_data+0x32>

	if (!tries)
		rslt = BME680_W_NO_NEW_DATA;
   18654:	2502      	movs	r5, #2
	return rslt;
   18656:	e7f0      	b.n	1863a <bme680_get_sensor_data+0x34a>
				dev->new_fields = 1;
   18658:	2301      	movs	r3, #1
   1865a:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   1865e:	e7ec      	b.n	1863a <bme680_get_sensor_data+0x34a>
   18660:	000186a0 	.word	0x000186a0
   18664:	0003a040 	.word	0x0003a040

00018668 <primary_feed_worker>:
static struct wdt_data_storage wdt_data;
static struct k_work_q *second_work_q;

static void primary_feed_worker(struct k_work *work_desc)
{
	k_work_submit_to_queue(second_work_q, &wdt_data.second_workqueue_work);
   18668:	4b08      	ldr	r3, [pc, #32]	; (1868c <primary_feed_worker+0x24>)
   1866a:	4909      	ldr	r1, [pc, #36]	; (18690 <primary_feed_worker+0x28>)
   1866c:	6818      	ldr	r0, [r3, #0]
   1866e:	e8d1 3fef 	ldaex	r3, [r1]
   18672:	f043 0201 	orr.w	r2, r3, #1
   18676:	e8c1 2fec 	stlex	ip, r2, [r1]
   1867a:	f1bc 0f00 	cmp.w	ip, #0
   1867e:	d1f6      	bne.n	1866e <primary_feed_worker+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   18680:	07db      	lsls	r3, r3, #31
   18682:	d402      	bmi.n	1868a <primary_feed_worker+0x22>
		k_queue_append(&work_q->queue, work);
   18684:	3908      	subs	r1, #8
   18686:	f020 bb0d 	b.w	38ca4 <k_queue_append>
}
   1868a:	4770      	bx	lr
   1868c:	20021694 	.word	0x20021694
   18690:	200216c8 	.word	0x200216c8

00018694 <secondary_feed_worker>:
static void secondary_feed_worker(struct k_work *work_desc)
{
   18694:	b570      	push	{r4, r5, r6, lr}
	int err = wdt_feed(wdt_data.wdt_drv, wdt_data.wdt_channel_id);
   18696:	4d17      	ldr	r5, [pc, #92]	; (186f4 <secondary_feed_worker+0x60>)
   18698:	e9d5 0100 	ldrd	r0, r1, [r5]
static inline int z_impl_wdt_feed(struct device *dev, int channel_id)
{
	const struct wdt_driver_api *api =
		(const struct wdt_driver_api *)dev->driver_api;

	return api->feed(dev, channel_id);
   1869c:	6883      	ldr	r3, [r0, #8]
   1869e:	4c16      	ldr	r4, [pc, #88]	; (186f8 <secondary_feed_worker+0x64>)
   186a0:	68db      	ldr	r3, [r3, #12]
   186a2:	4798      	blx	r3

	LOG_DBG("Feeding watchdog");
   186a4:	2304      	movs	r3, #4
   186a6:	4606      	mov	r6, r0
   186a8:	f04f 0000 	mov.w	r0, #0
   186ac:	f363 0007 	bfi	r0, r3, #0, #8
   186b0:	4b12      	ldr	r3, [pc, #72]	; (186fc <secondary_feed_worker+0x68>)
   186b2:	4a13      	ldr	r2, [pc, #76]	; (18700 <secondary_feed_worker+0x6c>)
   186b4:	1ae4      	subs	r4, r4, r3
   186b6:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   186ba:	f364 108f 	bfi	r0, r4, #6, #10
   186be:	4911      	ldr	r1, [pc, #68]	; (18704 <secondary_feed_worker+0x70>)
   186c0:	f01b fa9a 	bl	33bf8 <log_string_sync>

	if (err) {
   186c4:	b166      	cbz	r6, 186e0 <secondary_feed_worker+0x4c>
		LOG_ERR("Cannot feed watchdog. Error code: %d", err);
   186c6:	f04f 0000 	mov.w	r0, #0
   186ca:	2301      	movs	r3, #1
   186cc:	f363 0007 	bfi	r0, r3, #0, #8
   186d0:	f364 108f 	bfi	r0, r4, #6, #10
   186d4:	4632      	mov	r2, r6
	} else {
		k_delayed_work_submit(&wdt_data.system_workqueue_work,
				      K_MSEC(WDT_FEED_WORKER_DELAY_MS));
	}
}
   186d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LOG_ERR("Cannot feed watchdog. Error code: %d", err);
   186da:	490b      	ldr	r1, [pc, #44]	; (18708 <secondary_feed_worker+0x74>)
   186dc:	f01b ba8c 	b.w	33bf8 <log_string_sync>
 * @retval -EADDRINUSE Work item is pending on a different workqueue.
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					k_timeout_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   186e0:	f105 0108 	add.w	r1, r5, #8
   186e4:	f241 3288 	movw	r2, #5000	; 0x1388
}
   186e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   186ec:	4807      	ldr	r0, [pc, #28]	; (1870c <secondary_feed_worker+0x78>)
   186ee:	f015 bf41 	b.w	2e574 <k_delayed_work_submit_to_queue>
   186f2:	bf00      	nop
   186f4:	20021698 	.word	0x20021698
   186f8:	0003a020 	.word	0x0003a020
   186fc:	00039f60 	.word	0x00039f60
   18700:	0003c81e 	.word	0x0003c81e
   18704:	0003c834 	.word	0x0003c834
   18708:	0003c849 	.word	0x0003c849
   1870c:	20027524 	.word	0x20027524

00018710 <watchdog_init_and_start>:

	return 0;
}

int watchdog_init_and_start(struct k_work_q *work_q)
{
   18710:	b570      	push	{r4, r5, r6, lr}
	if (work_q == NULL) {
   18712:	2800      	cmp	r0, #0
   18714:	f000 808b 	beq.w	1882e <watchdog_init_and_start+0x11e>
		return -EINVAL;
	}
	second_work_q = work_q;
   18718:	4b46      	ldr	r3, [pc, #280]	; (18834 <watchdog_init_and_start+0x124>)
   1871a:	6018      	str	r0, [r3, #0]
   1871c:	4846      	ldr	r0, [pc, #280]	; (18838 <watchdog_init_and_start+0x128>)
   1871e:	f013 f879 	bl	2b814 <z_impl_device_get_binding>
   18722:	4d46      	ldr	r5, [pc, #280]	; (1883c <watchdog_init_and_start+0x12c>)
   18724:	4a46      	ldr	r2, [pc, #280]	; (18840 <watchdog_init_and_start+0x130>)
	data->wdt_drv = device_get_binding(DT_LABEL(DT_NODELABEL(wdt)));
   18726:	4e47      	ldr	r6, [pc, #284]	; (18844 <watchdog_init_and_start+0x134>)
   18728:	1aad      	subs	r5, r5, r2
   1872a:	6030      	str	r0, [r6, #0]
	if (data->wdt_drv == NULL) {
   1872c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   18730:	b968      	cbnz	r0, 1874e <watchdog_init_and_start+0x3e>
		LOG_ERR("Cannot bind watchdog driver");
   18732:	2301      	movs	r3, #1
   18734:	f04f 0000 	mov.w	r0, #0
   18738:	f363 0007 	bfi	r0, r3, #0, #8
   1873c:	f365 108f 	bfi	r0, r5, #6, #10
   18740:	4941      	ldr	r1, [pc, #260]	; (18848 <watchdog_init_and_start+0x138>)
   18742:	f01b fa59 	bl	33bf8 <log_string_sync>
		return err;
   18746:	f06f 0405 	mvn.w	r4, #5
	return watchdog_enable(&wdt_data);
}
   1874a:	4620      	mov	r0, r4
   1874c:	bd70      	pop	{r4, r5, r6, pc}
	return api->install_timeout(dev, cfg);
   1874e:	6883      	ldr	r3, [r0, #8]
   18750:	493e      	ldr	r1, [pc, #248]	; (1884c <watchdog_init_and_start+0x13c>)
   18752:	689b      	ldr	r3, [r3, #8]
   18754:	4798      	blx	r3
   18756:	4602      	mov	r2, r0
	if (data->wdt_channel_id < 0) {
   18758:	2a00      	cmp	r2, #0
	data->wdt_channel_id = wdt_install_timeout(
   1875a:	6070      	str	r0, [r6, #4]
		LOG_ERR("Cannot install watchdog timer! Error code: %d",
   1875c:	f04f 0000 	mov.w	r0, #0
	if (data->wdt_channel_id < 0) {
   18760:	da0a      	bge.n	18778 <watchdog_init_and_start+0x68>
		LOG_ERR("Cannot install watchdog timer! Error code: %d",
   18762:	2101      	movs	r1, #1
   18764:	f361 0007 	bfi	r0, r1, #0, #8
   18768:	f365 108f 	bfi	r0, r5, #6, #10
   1876c:	4938      	ldr	r1, [pc, #224]	; (18850 <watchdog_init_and_start+0x140>)
   1876e:	f01b fa43 	bl	33bf8 <log_string_sync>
		return -EFAULT;
   18772:	f06f 040d 	mvn.w	r4, #13
   18776:	e7e8      	b.n	1874a <watchdog_init_and_start+0x3a>
	LOG_INF("Watchdog timeout installed. Timeout: %d",
   18778:	2303      	movs	r3, #3
   1877a:	f363 0007 	bfi	r0, r3, #0, #8
   1877e:	f365 108f 	bfi	r0, r5, #6, #10
   18782:	f242 7210 	movw	r2, #10000	; 0x2710
   18786:	4933      	ldr	r1, [pc, #204]	; (18854 <watchdog_init_and_start+0x144>)
   18788:	f01b fa36 	bl	33bf8 <log_string_sync>
	int err = wdt_setup(data->wdt_drv, WDT_OPT_PAUSE_HALTED_BY_DBG);
   1878c:	6830      	ldr	r0, [r6, #0]
	return api->setup(dev, options);
   1878e:	6883      	ldr	r3, [r0, #8]
   18790:	2102      	movs	r1, #2
   18792:	681b      	ldr	r3, [r3, #0]
   18794:	4798      	blx	r3
	if (err) {
   18796:	4604      	mov	r4, r0
		LOG_ERR("Cannot start watchdog! Error code: %d", err);
   18798:	f04f 0000 	mov.w	r0, #0
	if (err) {
   1879c:	b14c      	cbz	r4, 187b2 <watchdog_init_and_start+0xa2>
		LOG_ERR("Cannot start watchdog! Error code: %d", err);
   1879e:	2301      	movs	r3, #1
   187a0:	4622      	mov	r2, r4
   187a2:	f363 0007 	bfi	r0, r3, #0, #8
   187a6:	492c      	ldr	r1, [pc, #176]	; (18858 <watchdog_init_and_start+0x148>)
   187a8:	f365 108f 	bfi	r0, r5, #6, #10
		LOG_INF("Watchdog feed enabled. Timeout: %d",
   187ac:	f01b fa24 	bl	33bf8 <log_string_sync>
	if (err) {
   187b0:	e7cb      	b.n	1874a <watchdog_init_and_start+0x3a>
		LOG_INF("Watchdog started");
   187b2:	2303      	movs	r3, #3
   187b4:	f363 0007 	bfi	r0, r3, #0, #8
   187b8:	f365 108f 	bfi	r0, r5, #6, #10
   187bc:	4927      	ldr	r1, [pc, #156]	; (1885c <watchdog_init_and_start+0x14c>)
   187be:	f01b fa1b 	bl	33bf8 <log_string_sync>
	k_delayed_work_init(&data->system_workqueue_work, primary_feed_worker);
   187c2:	f106 0008 	add.w	r0, r6, #8
   187c6:	4926      	ldr	r1, [pc, #152]	; (18860 <watchdog_init_and_start+0x150>)
   187c8:	f020 fb2c 	bl	38e24 <k_delayed_work_init>
	int err = wdt_feed(data->wdt_drv, data->wdt_channel_id);
   187cc:	e9d6 0100 	ldrd	r0, r1, [r6]
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   187d0:	4b24      	ldr	r3, [pc, #144]	; (18864 <watchdog_init_and_start+0x154>)
   187d2:	62b4      	str	r4, [r6, #40]	; 0x28
   187d4:	e9c6 340b 	strd	r3, r4, [r6, #44]	; 0x2c
	return api->feed(dev, channel_id);
   187d8:	6883      	ldr	r3, [r0, #8]
   187da:	68db      	ldr	r3, [r3, #12]
   187dc:	4798      	blx	r3
	if (err) {
   187de:	4604      	mov	r4, r0
   187e0:	b148      	cbz	r0, 187f6 <watchdog_init_and_start+0xe6>
		LOG_ERR("Cannot feed watchdog. Error code: %d", err);
   187e2:	f04f 0000 	mov.w	r0, #0
   187e6:	2301      	movs	r3, #1
   187e8:	f363 0007 	bfi	r0, r3, #0, #8
   187ec:	f365 108f 	bfi	r0, r5, #6, #10
   187f0:	4622      	mov	r2, r4
   187f2:	491d      	ldr	r1, [pc, #116]	; (18868 <watchdog_init_and_start+0x158>)
   187f4:	e7da      	b.n	187ac <watchdog_init_and_start+0x9c>
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   187f6:	f241 3288 	movw	r2, #5000	; 0x1388
   187fa:	f106 0108 	add.w	r1, r6, #8
   187fe:	481b      	ldr	r0, [pc, #108]	; (1886c <watchdog_init_and_start+0x15c>)
   18800:	f015 feb8 	bl	2e574 <k_delayed_work_submit_to_queue>
	if (err) {
   18804:	4604      	mov	r4, r0
		LOG_ERR("Cannot start watchdog feed worker!"
   18806:	f04f 0000 	mov.w	r0, #0
	if (err) {
   1880a:	b13c      	cbz	r4, 1881c <watchdog_init_and_start+0x10c>
		LOG_ERR("Cannot start watchdog feed worker!"
   1880c:	2301      	movs	r3, #1
   1880e:	f363 0007 	bfi	r0, r3, #0, #8
   18812:	f365 108f 	bfi	r0, r5, #6, #10
   18816:	4622      	mov	r2, r4
   18818:	4915      	ldr	r1, [pc, #84]	; (18870 <watchdog_init_and_start+0x160>)
   1881a:	e7c7      	b.n	187ac <watchdog_init_and_start+0x9c>
		LOG_INF("Watchdog feed enabled. Timeout: %d",
   1881c:	2303      	movs	r3, #3
   1881e:	f363 0007 	bfi	r0, r3, #0, #8
   18822:	f365 108f 	bfi	r0, r5, #6, #10
   18826:	f241 3288 	movw	r2, #5000	; 0x1388
   1882a:	4912      	ldr	r1, [pc, #72]	; (18874 <watchdog_init_and_start+0x164>)
   1882c:	e7be      	b.n	187ac <watchdog_init_and_start+0x9c>
		return -EINVAL;
   1882e:	f06f 0415 	mvn.w	r4, #21
   18832:	e78a      	b.n	1874a <watchdog_init_and_start+0x3a>
   18834:	20021694 	.word	0x20021694
   18838:	0003c86e 	.word	0x0003c86e
   1883c:	0003a020 	.word	0x0003a020
   18840:	00039f60 	.word	0x00039f60
   18844:	20021698 	.word	0x20021698
   18848:	0003c872 	.word	0x0003c872
   1884c:	0003a238 	.word	0x0003a238
   18850:	0003c88e 	.word	0x0003c88e
   18854:	0003c8bc 	.word	0x0003c8bc
   18858:	0003c8e4 	.word	0x0003c8e4
   1885c:	0003c90a 	.word	0x0003c90a
   18860:	00018669 	.word	0x00018669
   18864:	00018695 	.word	0x00018695
   18868:	0003c849 	.word	0x0003c849
   1886c:	20027524 	.word	0x20027524
   18870:	0003c91b 	.word	0x0003c91b
   18874:	0003c94d 	.word	0x0003c94d

00018878 <_check_fd>:
	return -1;
}

static int _check_fd(int fd)
{
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
   18878:	2803      	cmp	r0, #3
{
   1887a:	b508      	push	{r3, lr}
	if (fd < 0 || fd >= ARRAY_SIZE(fdtable)) {
   1887c:	d906      	bls.n	1888c <_check_fd+0x14>
	}

	fd = k_array_index_sanitize(fd, ARRAY_SIZE(fdtable));

	if (fdtable[fd].obj == NULL) {
		errno = EBADF;
   1887e:	f01c fe33 	bl	354e8 <__errno>
   18882:	2309      	movs	r3, #9
   18884:	6003      	str	r3, [r0, #0]
   18886:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return -1;
	}

	return 0;
}
   1888a:	bd08      	pop	{r3, pc}
	if (fdtable[fd].obj == NULL) {
   1888c:	4b03      	ldr	r3, [pc, #12]	; (1889c <_check_fd+0x24>)
   1888e:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
   18892:	2b00      	cmp	r3, #0
   18894:	d0f3      	beq.n	1887e <_check_fd+0x6>
	return 0;
   18896:	2000      	movs	r0, #0
   18898:	e7f7      	b.n	1888a <_check_fd+0x12>
   1889a:	bf00      	nop
   1889c:	200216cc 	.word	0x200216cc

000188a0 <z_get_fd_obj>:

void *z_get_fd_obj(int fd, const struct fd_op_vtable *vtable, int err)
{
   188a0:	b570      	push	{r4, r5, r6, lr}
   188a2:	4604      	mov	r4, r0
   188a4:	460d      	mov	r5, r1
   188a6:	4616      	mov	r6, r2
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
   188a8:	f7ff ffe6 	bl	18878 <_check_fd>
   188ac:	2800      	cmp	r0, #0
   188ae:	db09      	blt.n	188c4 <z_get_fd_obj+0x24>
		return NULL;
	}

	fd_entry = &fdtable[fd];

	if (vtable != NULL && fd_entry->vtable != vtable) {
   188b0:	4b07      	ldr	r3, [pc, #28]	; (188d0 <z_get_fd_obj+0x30>)
   188b2:	b14d      	cbz	r5, 188c8 <z_get_fd_obj+0x28>
   188b4:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
   188b8:	6852      	ldr	r2, [r2, #4]
   188ba:	42aa      	cmp	r2, r5
   188bc:	d004      	beq.n	188c8 <z_get_fd_obj+0x28>
		errno = err;
   188be:	f01c fe13 	bl	354e8 <__errno>
   188c2:	6006      	str	r6, [r0, #0]
		return NULL;
   188c4:	2000      	movs	r0, #0
   188c6:	e001      	b.n	188cc <z_get_fd_obj+0x2c>
		return NULL;
	}

	return fd_entry->obj;
   188c8:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
}
   188cc:	bd70      	pop	{r4, r5, r6, pc}
   188ce:	bf00      	nop
   188d0:	200216cc 	.word	0x200216cc

000188d4 <z_get_fd_obj_and_vtable>:

void *z_get_fd_obj_and_vtable(int fd, const struct fd_op_vtable **vtable)
{
   188d4:	b538      	push	{r3, r4, r5, lr}
   188d6:	4604      	mov	r4, r0
   188d8:	460d      	mov	r5, r1
	struct fd_entry *fd_entry;

	if (_check_fd(fd) < 0) {
   188da:	f7ff ffcd 	bl	18878 <_check_fd>
   188de:	2800      	cmp	r0, #0
		return NULL;
	}

	fd_entry = &fdtable[fd];
	*vtable = fd_entry->vtable;
   188e0:	bfa9      	itett	ge
   188e2:	4b05      	ldrge	r3, [pc, #20]	; (188f8 <z_get_fd_obj_and_vtable+0x24>)
		return NULL;
   188e4:	2000      	movlt	r0, #0
	*vtable = fd_entry->vtable;
   188e6:	eb03 02c4 	addge.w	r2, r3, r4, lsl #3
   188ea:	6852      	ldrge	r2, [r2, #4]

	return fd_entry->obj;
   188ec:	bfa4      	itt	ge
   188ee:	f853 0034 	ldrge.w	r0, [r3, r4, lsl #3]
	*vtable = fd_entry->vtable;
   188f2:	602a      	strge	r2, [r5, #0]
}
   188f4:	bd38      	pop	{r3, r4, r5, pc}
   188f6:	bf00      	nop
   188f8:	200216cc 	.word	0x200216cc

000188fc <z_reserve_fd>:

int z_reserve_fd(void)
{
   188fc:	b510      	push	{r4, lr}
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
   188fe:	2400      	movs	r4, #0
	return z_impl_k_mutex_lock(mutex, timeout);
   18900:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   18904:	480c      	ldr	r0, [pc, #48]	; (18938 <z_reserve_fd+0x3c>)
   18906:	f013 fe81 	bl	2c60c <z_impl_k_mutex_lock>
		if (fdtable[fd].obj == NULL) {
   1890a:	4b0c      	ldr	r3, [pc, #48]	; (1893c <z_reserve_fd+0x40>)
   1890c:	f853 2034 	ldr.w	r2, [r3, r4, lsl #3]
   18910:	b16a      	cbz	r2, 1892e <z_reserve_fd+0x32>
	for (fd = 0; fd < ARRAY_SIZE(fdtable); fd++) {
   18912:	3401      	adds	r4, #1
   18914:	2c04      	cmp	r4, #4
   18916:	d1f9      	bne.n	1890c <z_reserve_fd+0x10>
	errno = ENFILE;
   18918:	f01c fde6 	bl	354e8 <__errno>
   1891c:	2317      	movs	r3, #23
	return -1;
   1891e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	errno = ENFILE;
   18922:	6003      	str	r3, [r0, #0]
	return z_impl_k_mutex_unlock(mutex);
   18924:	4804      	ldr	r0, [pc, #16]	; (18938 <z_reserve_fd+0x3c>)
   18926:	f013 ff4f 	bl	2c7c8 <z_impl_k_mutex_unlock>
	}

	k_mutex_unlock(&fdtable_lock);

	return fd;
}
   1892a:	4620      	mov	r0, r4
   1892c:	bd10      	pop	{r4, pc}
		fdtable[fd].obj = FD_OBJ_RESERVED;
   1892e:	2201      	movs	r2, #1
   18930:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
   18934:	e7f6      	b.n	18924 <z_reserve_fd+0x28>
   18936:	bf00      	nop
   18938:	20020734 	.word	0x20020734
   1893c:	200216cc 	.word	0x200216cc

00018940 <z_finalize_fd>:

void z_finalize_fd(int fd, void *obj, const struct fd_op_vtable *vtable)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = obj;
   18940:	4b03      	ldr	r3, [pc, #12]	; (18950 <z_finalize_fd+0x10>)
   18942:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
	fdtable[fd].vtable = vtable;
   18946:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
   1894a:	605a      	str	r2, [r3, #4]
}
   1894c:	4770      	bx	lr
   1894e:	bf00      	nop
   18950:	200216cc 	.word	0x200216cc

00018954 <z_free_fd>:

void z_free_fd(int fd)
{
	/* Assumes fd was already bounds-checked. */
	fdtable[fd].obj = NULL;
   18954:	2200      	movs	r2, #0
   18956:	4b02      	ldr	r3, [pc, #8]	; (18960 <z_free_fd+0xc>)
   18958:	f843 2030 	str.w	r2, [r3, r0, lsl #3]
}
   1895c:	4770      	bx	lr
   1895e:	bf00      	nop
   18960:	200216cc 	.word	0x200216cc

00018964 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
   18964:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18968:	b085      	sub	sp, #20
   1896a:	9c0e      	ldr	r4, [sp, #56]	; 0x38
   1896c:	469b      	mov	fp, r3
   1896e:	2c01      	cmp	r4, #1
   18970:	bfb8      	it	lt
   18972:	2401      	movlt	r4, #1
   18974:	2b01      	cmp	r3, #1
   18976:	bf0c      	ite	eq
   18978:	2330      	moveq	r3, #48	; 0x30
   1897a:	2320      	movne	r3, #32
   1897c:	4616      	mov	r6, r2
   1897e:	4682      	mov	sl, r0
   18980:	4688      	mov	r8, r1
   18982:	2501      	movs	r5, #1
   18984:	270a      	movs	r7, #10
   18986:	2200      	movs	r2, #0
   18988:	f8df 906c 	ldr.w	r9, [pc, #108]	; 189f8 <_printk_dec_ulong+0x94>
   1898c:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
   1898e:	fbb6 f3f9 	udiv	r3, r6, r9
   18992:	9301      	str	r3, [sp, #4]
   18994:	b90a      	cbnz	r2, 1899a <_printk_dec_ulong+0x36>
   18996:	45b1      	cmp	r9, r6
   18998:	d81c      	bhi.n	189d4 <_printk_dec_ulong+0x70>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
   1899a:	9b01      	ldr	r3, [sp, #4]
   1899c:	4641      	mov	r1, r8
   1899e:	f103 0030 	add.w	r0, r3, #48	; 0x30
   189a2:	47d0      	blx	sl
			found_largest_digit = 1;
   189a4:	2201      	movs	r2, #1
			digits++;
   189a6:	3501      	adds	r5, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
   189a8:	9b01      	ldr	r3, [sp, #4]
		remaining--;
   189aa:	3f01      	subs	r7, #1
		remainder %= pos;
   189ac:	fb09 6613 	mls	r6, r9, r3, r6
		pos /= 10;
   189b0:	230a      	movs	r3, #10
	while (pos >= 10) {
   189b2:	2f01      	cmp	r7, #1
		pos /= 10;
   189b4:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
   189b8:	d1e9      	bne.n	1898e <_printk_dec_ulong+0x2a>
	}
	out((int)(remainder + 48), ctx);
   189ba:	4641      	mov	r1, r8
   189bc:	f106 0030 	add.w	r0, r6, #48	; 0x30
   189c0:	47d0      	blx	sl

	if (padding == PAD_SPACE_AFTER) {
   189c2:	f1bb 0f03 	cmp.w	fp, #3
   189c6:	d102      	bne.n	189ce <_printk_dec_ulong+0x6a>
		remaining = min_width - digits;
   189c8:	1b64      	subs	r4, r4, r5
		while (remaining-- > 0) {
   189ca:	2c00      	cmp	r4, #0
   189cc:	dc0e      	bgt.n	189ec <_printk_dec_ulong+0x88>
			out(' ', ctx);
		}
	}
}
   189ce:	b005      	add	sp, #20
   189d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
   189d4:	42bc      	cmp	r4, r7
   189d6:	dbe7      	blt.n	189a8 <_printk_dec_ulong+0x44>
				&& padding < PAD_SPACE_AFTER) {
   189d8:	f1bb 0f02 	cmp.w	fp, #2
   189dc:	d8e4      	bhi.n	189a8 <_printk_dec_ulong+0x44>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   189de:	4641      	mov	r1, r8
   189e0:	9802      	ldr	r0, [sp, #8]
   189e2:	9203      	str	r2, [sp, #12]
			digits++;
   189e4:	3501      	adds	r5, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
   189e6:	47d0      	blx	sl
			digits++;
   189e8:	9a03      	ldr	r2, [sp, #12]
   189ea:	e7dd      	b.n	189a8 <_printk_dec_ulong+0x44>
			out(' ', ctx);
   189ec:	4641      	mov	r1, r8
   189ee:	2020      	movs	r0, #32
   189f0:	47d0      	blx	sl
   189f2:	3c01      	subs	r4, #1
   189f4:	e7e9      	b.n	189ca <_printk_dec_ulong+0x66>
   189f6:	bf00      	nop
   189f8:	3b9aca00 	.word	0x3b9aca00

000189fc <__printk_hook_install>:
	_char_out = fn;
   189fc:	4b01      	ldr	r3, [pc, #4]	; (18a04 <__printk_hook_install+0x8>)
   189fe:	6018      	str	r0, [r3, #0]
}
   18a00:	4770      	bx	lr
   18a02:	bf00      	nop
   18a04:	200200a4 	.word	0x200200a4

00018a08 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
   18a08:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
   18a0a:	2500      	movs	r5, #0
{
   18a0c:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
   18a0e:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
   18a12:	4604      	mov	r4, r0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
   18a14:	a901      	add	r1, sp, #4
   18a16:	4805      	ldr	r0, [pc, #20]	; (18a2c <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
   18a18:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
   18a1a:	f01a fc65 	bl	332e8 <z_vprintk>

	if (ctx.count < ctx.max) {
   18a1e:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
   18a22:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
   18a24:	bfb8      	it	lt
   18a26:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
   18a28:	b005      	add	sp, #20
   18a2a:	bd30      	pop	{r4, r5, pc}
   18a2c:	000332c3 	.word	0x000332c3

00018a30 <timeutil_timegm64>:

	return era * 146097 + (time_t)doe - 719468;
}

s64_t timeutil_timegm64(const struct tm *tm)
{
   18a30:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s64_t y = 1900 + (s64_t)tm->tm_year;
	unsigned int m = tm->tm_mon + 1;
   18a34:	6903      	ldr	r3, [r0, #16]
	unsigned int d = tm->tm_mday - 1;
   18a36:	68c4      	ldr	r4, [r0, #12]
	unsigned int m = tm->tm_mon + 1;
   18a38:	f103 0801 	add.w	r8, r3, #1
	unsigned int d = tm->tm_mday - 1;
   18a3c:	1e63      	subs	r3, r4, #1
	s64_t y = 1900 + (s64_t)tm->tm_year;
   18a3e:	f240 746c 	movw	r4, #1900	; 0x76c
   18a42:	2500      	movs	r5, #0
	unsigned int d = tm->tm_mday - 1;
   18a44:	461e      	mov	r6, r3
	s64_t y = 1900 + (s64_t)tm->tm_year;
   18a46:	6943      	ldr	r3, [r0, #20]
{
   18a48:	4681      	mov	r9, r0
	s64_t y = 1900 + (s64_t)tm->tm_year;
   18a4a:	18e1      	adds	r1, r4, r3
   18a4c:	eb45 72e3 	adc.w	r2, r5, r3, asr #31
	y -= m <= 2;
   18a50:	f1b8 0f02 	cmp.w	r8, #2
   18a54:	bf8c      	ite	hi
   18a56:	2300      	movhi	r3, #0
   18a58:	2301      	movls	r3, #1
   18a5a:	1acc      	subs	r4, r1, r3
   18a5c:	f162 0500 	sbc.w	r5, r2, #0
	s64_t era = (y >= 0 ? y : y - 399) / 400;
   18a60:	2c00      	cmp	r4, #0
   18a62:	f175 0300 	sbcs.w	r3, r5, #0
   18a66:	da5c      	bge.n	18b22 <timeutil_timegm64+0xf2>
   18a68:	f46f 70c7 	mvn.w	r0, #398	; 0x18e
   18a6c:	f44f 72c8 	mov.w	r2, #400	; 0x190
   18a70:	2300      	movs	r3, #0
   18a72:	1820      	adds	r0, r4, r0
   18a74:	f145 31ff 	adc.w	r1, r5, #4294967295	; 0xffffffff
   18a78:	f7f4 fe2a 	bl	d6d0 <__aeabi_ldivmod>
	unsigned int yoe = y - era * 400;
   18a7c:	4b2c      	ldr	r3, [pc, #176]	; (18b30 <timeutil_timegm64+0x100>)
	s64_t ndays = time_days_from_civil(y, m, d);
	s64_t time = tm->tm_sec;

	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
   18a7e:	f04f 0c3c 	mov.w	ip, #60	; 0x3c
	unsigned int yoe = y - era * 400;
   18a82:	fb03 4400 	mla	r4, r3, r0, r4
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
   18a86:	e9d9 5300 	ldrd	r5, r3, [r9]
   18a8a:	469a      	mov	sl, r3
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
   18a8c:	f1b8 0f02 	cmp.w	r8, #2
   18a90:	bf8c      	ite	hi
   18a92:	f06f 0e02 	mvnhi.w	lr, #2
   18a96:	f04f 0e09 	movls.w	lr, #9
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
   18a9a:	ea4f 7be3 	mov.w	fp, r3, asr #31
   18a9e:	f8d9 3008 	ldr.w	r3, [r9, #8]
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
   18aa2:	44f0      	add	r8, lr
	time += 60LL * (tm->tm_min + 60LL * tm->tm_hour);
   18aa4:	fbcc ab03 	smlal	sl, fp, ip, r3
   18aa8:	fbaa 230c 	umull	r2, r3, sl, ip
   18aac:	fb0c 330b 	mla	r3, ip, fp, r3
   18ab0:	eb12 0905 	adds.w	r9, r2, r5
   18ab4:	eb43 7ae5 	adc.w	sl, r3, r5, asr #31
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
   18ab8:	f240 156d 	movw	r5, #365	; 0x16d
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
   18abc:	f04f 0e99 	mov.w	lr, #153	; 0x99
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
   18ac0:	ea4f 0c94 	mov.w	ip, r4, lsr #2
   18ac4:	fb05 c504 	mla	r5, r5, r4, ip
   18ac8:	f04f 0c64 	mov.w	ip, #100	; 0x64
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
   18acc:	fb0e fe08 	mul.w	lr, lr, r8
   18ad0:	f04f 0805 	mov.w	r8, #5
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
   18ad4:	fbb4 f4fc 	udiv	r4, r4, ip
	unsigned int doy = (153U * (m + (m > 2 ? -3 : 9)) + 2U) / 5U + d;
   18ad8:	f10e 0e02 	add.w	lr, lr, #2
   18adc:	fbbe fef8 	udiv	lr, lr, r8
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
   18ae0:	4435      	add	r5, r6
	return era * 146097 + (time_t)doe - 719468;
   18ae2:	f8df c058 	ldr.w	ip, [pc, #88]	; 18b3c <timeutil_timegm64+0x10c>
	unsigned int doe = yoe * 365U + yoe / 4U - yoe / 100U + doy;
   18ae6:	1b2c      	subs	r4, r5, r4
   18ae8:	44a6      	add	lr, r4
	return era * 146097 + (time_t)doe - 719468;
   18aea:	fba0 450c 	umull	r4, r5, r0, ip
   18aee:	fb0c 5501 	mla	r5, ip, r1, r5
   18af2:	4910      	ldr	r1, [pc, #64]	; (18b34 <timeutil_timegm64+0x104>)
   18af4:	1863      	adds	r3, r4, r1
   18af6:	9300      	str	r3, [sp, #0]
   18af8:	f145 33ff 	adc.w	r3, r5, #4294967295	; 0xffffffff
	time += 86400LL * ndays;
   18afc:	490e      	ldr	r1, [pc, #56]	; (18b38 <timeutil_timegm64+0x108>)
	return era * 146097 + (time_t)doe - 719468;
   18afe:	9301      	str	r3, [sp, #4]
   18b00:	e9dd 6700 	ldrd	r6, r7, [sp]
   18b04:	eb16 060e 	adds.w	r6, r6, lr
	time += 86400LL * ndays;
   18b08:	fba6 4501 	umull	r4, r5, r6, r1
	return era * 146097 + (time_t)doe - 719468;
   18b0c:	f147 0700 	adc.w	r7, r7, #0
	time += 86400LL * ndays;
   18b10:	fb01 5507 	mla	r5, r1, r7, r5

	return time;
}
   18b14:	eb14 0009 	adds.w	r0, r4, r9
   18b18:	eb45 010a 	adc.w	r1, r5, sl
   18b1c:	b003      	add	sp, #12
   18b1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	s64_t era = (y >= 0 ? y : y - 399) / 400;
   18b22:	f44f 72c8 	mov.w	r2, #400	; 0x190
   18b26:	2300      	movs	r3, #0
   18b28:	4620      	mov	r0, r4
   18b2a:	4629      	mov	r1, r5
   18b2c:	e7a4      	b.n	18a78 <timeutil_timegm64+0x48>
   18b2e:	bf00      	nop
   18b30:	fffffe70 	.word	0xfffffe70
   18b34:	fff50594 	.word	0xfff50594
   18b38:	00015180 	.word	0x00015180
   18b3c:	00023ab1 	.word	0x00023ab1

00018b40 <str_encode>:
	return append_bytes("]", 1, data);
}

static int str_encode(const char **str, json_append_bytes_t append_bytes,
		      void *data)
{
   18b40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   18b42:	460c      	mov	r4, r1
   18b44:	4606      	mov	r6, r0
	int ret;

	ret = append_bytes("\"", 1, data);
   18b46:	2101      	movs	r1, #1
   18b48:	4811      	ldr	r0, [pc, #68]	; (18b90 <str_encode+0x50>)
{
   18b4a:	4615      	mov	r5, r2
	ret = append_bytes("\"", 1, data);
   18b4c:	47a0      	blx	r4
	if (ret < 0) {
   18b4e:	2800      	cmp	r0, #0
   18b50:	db17      	blt.n	18b82 <str_encode+0x42>
			char bytes[2] = { '\\', escaped };
   18b52:	275c      	movs	r7, #92	; 0x5c
   18b54:	6836      	ldr	r6, [r6, #0]
   18b56:	4633      	mov	r3, r6
	for (cur = str; ret == 0 && *cur; cur++) {
   18b58:	f816 0b01 	ldrb.w	r0, [r6], #1
   18b5c:	b920      	cbnz	r0, 18b68 <str_encode+0x28>
		return ret;
	}

	ret = json_escape_internal(*str, append_bytes, data);
	if (!ret) {
		return append_bytes("\"", 1, data);
   18b5e:	462a      	mov	r2, r5
   18b60:	2101      	movs	r1, #1
   18b62:	480b      	ldr	r0, [pc, #44]	; (18b90 <str_encode+0x50>)
   18b64:	47a0      	blx	r4
   18b66:	e00c      	b.n	18b82 <str_encode+0x42>
		char escaped = escape_as(*cur);
   18b68:	f01b f814 	bl	33b94 <escape_as>
		if (escaped) {
   18b6c:	b158      	cbz	r0, 18b86 <str_encode+0x46>
			ret = append_bytes(bytes, 2, data);
   18b6e:	462a      	mov	r2, r5
   18b70:	2102      	movs	r1, #2
			char bytes[2] = { '\\', escaped };
   18b72:	f88d 0005 	strb.w	r0, [sp, #5]
   18b76:	f88d 7004 	strb.w	r7, [sp, #4]
			ret = append_bytes(bytes, 2, data);
   18b7a:	a801      	add	r0, sp, #4
			ret = append_bytes(cur, 1, data);
   18b7c:	47a0      	blx	r4
	for (cur = str; ret == 0 && *cur; cur++) {
   18b7e:	2800      	cmp	r0, #0
   18b80:	d0e9      	beq.n	18b56 <str_encode+0x16>
	}

	return ret;
}
   18b82:	b003      	add	sp, #12
   18b84:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ret = append_bytes(cur, 1, data);
   18b86:	462a      	mov	r2, r5
   18b88:	2101      	movs	r1, #1
   18b8a:	4618      	mov	r0, r3
   18b8c:	e7f6      	b.n	18b7c <str_encode+0x3c>
   18b8e:	bf00      	nop
   18b90:	0003c517 	.word	0x0003c517

00018b94 <json_obj_encode>:
}

int json_obj_encode(const struct json_obj_descr *descr, size_t descr_len,
		    const void *val, json_append_bytes_t append_bytes,
		    void *data)
{
   18b94:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18b98:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   18b9a:	4606      	mov	r6, r0
   18b9c:	4688      	mov	r8, r1
   18b9e:	4691      	mov	r9, r2
	size_t i;
	int ret;

	ret = append_bytes("{", 1, data);
   18ba0:	2101      	movs	r1, #1
   18ba2:	462a      	mov	r2, r5
   18ba4:	481b      	ldr	r0, [pc, #108]	; (18c14 <json_obj_encode+0x80>)
{
   18ba6:	461c      	mov	r4, r3
	ret = append_bytes("{", 1, data);
   18ba8:	4798      	blx	r3
	if (ret < 0) {
   18baa:	2800      	cmp	r0, #0
   18bac:	db2f      	blt.n	18c0e <json_obj_encode+0x7a>
		return ret;
	}

	for (i = 0; i < descr_len; i++) {
   18bae:	2700      	movs	r7, #0
				 append_bytes, data);
		if (ret < 0) {
			return ret;
		}

		ret = append_bytes(":", 1, data);
   18bb0:	f8df a068 	ldr.w	sl, [pc, #104]	; 18c1c <json_obj_encode+0x88>
		if (ret < 0) {
			return ret;
		}

		if (i < descr_len - 1) {
			ret = append_bytes(",", 1, data);
   18bb4:	f8df b068 	ldr.w	fp, [pc, #104]	; 18c20 <json_obj_encode+0x8c>
	for (i = 0; i < descr_len; i++) {
   18bb8:	45b8      	cmp	r8, r7
		ret = str_encode((const char **)&descr[i].field_name,
   18bba:	462a      	mov	r2, r5
	for (i = 0; i < descr_len; i++) {
   18bbc:	d106      	bne.n	18bcc <json_obj_encode+0x38>
				return ret;
			}
		}
	}

	return append_bytes("}", 1, data);
   18bbe:	2101      	movs	r1, #1
   18bc0:	4623      	mov	r3, r4
   18bc2:	4815      	ldr	r0, [pc, #84]	; (18c18 <json_obj_encode+0x84>)
}
   18bc4:	b001      	add	sp, #4
   18bc6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return append_bytes("}", 1, data);
   18bca:	4718      	bx	r3
		ret = str_encode((const char **)&descr[i].field_name,
   18bcc:	4621      	mov	r1, r4
   18bce:	4630      	mov	r0, r6
   18bd0:	f7ff ffb6 	bl	18b40 <str_encode>
		if (ret < 0) {
   18bd4:	2800      	cmp	r0, #0
   18bd6:	db1a      	blt.n	18c0e <json_obj_encode+0x7a>
		ret = append_bytes(":", 1, data);
   18bd8:	462a      	mov	r2, r5
   18bda:	2101      	movs	r1, #1
   18bdc:	4650      	mov	r0, sl
   18bde:	47a0      	blx	r4
		if (ret < 0) {
   18be0:	2800      	cmp	r0, #0
   18be2:	db14      	blt.n	18c0e <json_obj_encode+0x7a>
		ret = encode(&descr[i], val, append_bytes, data);
   18be4:	462b      	mov	r3, r5
   18be6:	4622      	mov	r2, r4
   18be8:	4649      	mov	r1, r9
   18bea:	4630      	mov	r0, r6
   18bec:	f000 f81a 	bl	18c24 <encode>
		if (ret < 0) {
   18bf0:	2800      	cmp	r0, #0
   18bf2:	db0c      	blt.n	18c0e <json_obj_encode+0x7a>
		if (i < descr_len - 1) {
   18bf4:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   18bf8:	429f      	cmp	r7, r3
   18bfa:	d302      	bcc.n	18c02 <json_obj_encode+0x6e>
	for (i = 0; i < descr_len; i++) {
   18bfc:	3701      	adds	r7, #1
   18bfe:	3610      	adds	r6, #16
   18c00:	e7da      	b.n	18bb8 <json_obj_encode+0x24>
			ret = append_bytes(",", 1, data);
   18c02:	462a      	mov	r2, r5
   18c04:	2101      	movs	r1, #1
   18c06:	4658      	mov	r0, fp
   18c08:	47a0      	blx	r4
			if (ret < 0) {
   18c0a:	2800      	cmp	r0, #0
   18c0c:	daf6      	bge.n	18bfc <json_obj_encode+0x68>
}
   18c0e:	b001      	add	sp, #4
   18c10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   18c14:	0003c972 	.word	0x0003c972
   18c18:	0003c976 	.word	0x0003c976
   18c1c:	0003e3ea 	.word	0x0003e3ea
   18c20:	0003c974 	.word	0x0003c974

00018c24 <encode>:
{
   18c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18c28:	461d      	mov	r5, r3
	switch (descr->type) {
   18c2a:	7943      	ldrb	r3, [r0, #5]
{
   18c2c:	4614      	mov	r4, r2
	switch (descr->type) {
   18c2e:	085b      	lsrs	r3, r3, #1
	void *ptr = (char *)val + descr->offset;
   18c30:	88c2      	ldrh	r2, [r0, #6]
	switch (descr->type) {
   18c32:	2b5b      	cmp	r3, #91	; 0x5b
{
   18c34:	b087      	sub	sp, #28
	void *ptr = (char *)val + descr->offset;
   18c36:	eb01 0602 	add.w	r6, r1, r2
	switch (descr->type) {
   18c3a:	d01f      	beq.n	18c7c <encode+0x58>
   18c3c:	d806      	bhi.n	18c4c <encode+0x28>
   18c3e:	2b22      	cmp	r3, #34	; 0x22
   18c40:	d014      	beq.n	18c6c <encode+0x48>
   18c42:	2b30      	cmp	r3, #48	; 0x30
   18c44:	d051      	beq.n	18cea <encode+0xc6>
		return -EINVAL;
   18c46:	f06f 0015 	mvn.w	r0, #21
   18c4a:	e014      	b.n	18c76 <encode+0x52>
	switch (descr->type) {
   18c4c:	2b74      	cmp	r3, #116	; 0x74
   18c4e:	d003      	beq.n	18c58 <encode+0x34>
   18c50:	2b7b      	cmp	r3, #123	; 0x7b
   18c52:	d042      	beq.n	18cda <encode+0xb6>
   18c54:	2b66      	cmp	r3, #102	; 0x66
   18c56:	d1f6      	bne.n	18c46 <encode+0x22>
	if (*value) {
   18c58:	5c8b      	ldrb	r3, [r1, r2]
		return append_bytes("true", 4, data);
   18c5a:	462a      	mov	r2, r5
	if (*value) {
   18c5c:	b11b      	cbz	r3, 18c66 <encode+0x42>
		return append_bytes("true", 4, data);
   18c5e:	2104      	movs	r1, #4
   18c60:	482b      	ldr	r0, [pc, #172]	; (18d10 <encode+0xec>)
	return append_bytes(buf, (size_t)ret, data);
   18c62:	47a0      	blx	r4
   18c64:	e007      	b.n	18c76 <encode+0x52>
	return append_bytes("false", 5, data);
   18c66:	2105      	movs	r1, #5
   18c68:	482a      	ldr	r0, [pc, #168]	; (18d14 <encode+0xf0>)
   18c6a:	e7fa      	b.n	18c62 <encode+0x3e>
		return str_encode(ptr, append_bytes, data);
   18c6c:	462a      	mov	r2, r5
   18c6e:	4621      	mov	r1, r4
   18c70:	4630      	mov	r0, r6
   18c72:	f7ff ff65 	bl	18b40 <str_encode>
}
   18c76:	b007      	add	sp, #28
   18c78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return arr_encode(descr->array.element_descr, ptr,
   18c7c:	f8d0 8008 	ldr.w	r8, [r0, #8]
	ptrdiff_t elem_size = get_elem_size(elem_descr);
   18c80:	4640      	mov	r0, r8
   18c82:	f01a ff49 	bl	33b18 <get_elem_size>
	size_t n_elem = *(size_t *)((char *)val + elem_descr->offset);
   18c86:	f8b8 3006 	ldrh.w	r3, [r8, #6]
	ptrdiff_t elem_size = get_elem_size(elem_descr);
   18c8a:	4682      	mov	sl, r0
	size_t n_elem = *(size_t *)((char *)val + elem_descr->offset);
   18c8c:	f851 9003 	ldr.w	r9, [r1, r3]
	ret = append_bytes("[", 1, data);
   18c90:	462a      	mov	r2, r5
   18c92:	2101      	movs	r1, #1
   18c94:	4820      	ldr	r0, [pc, #128]	; (18d18 <encode+0xf4>)
   18c96:	47a0      	blx	r4
	if (ret < 0) {
   18c98:	2800      	cmp	r0, #0
   18c9a:	dbec      	blt.n	18c76 <encode+0x52>
	for (i = 0; i < n_elem; i++) {
   18c9c:	2700      	movs	r7, #0
		if (i < n_elem - 1) {
   18c9e:	f109 3bff 	add.w	fp, r9, #4294967295	; 0xffffffff
	for (i = 0; i < n_elem; i++) {
   18ca2:	45b9      	cmp	r9, r7
   18ca4:	d103      	bne.n	18cae <encode+0x8a>
	return append_bytes("]", 1, data);
   18ca6:	462a      	mov	r2, r5
   18ca8:	2101      	movs	r1, #1
   18caa:	481c      	ldr	r0, [pc, #112]	; (18d1c <encode+0xf8>)
   18cac:	e7d9      	b.n	18c62 <encode+0x3e>
		ret = encode(elem_descr, (char *)field - elem_descr->offset,
   18cae:	f8b8 1006 	ldrh.w	r1, [r8, #6]
   18cb2:	462b      	mov	r3, r5
   18cb4:	4622      	mov	r2, r4
   18cb6:	1a71      	subs	r1, r6, r1
   18cb8:	4640      	mov	r0, r8
   18cba:	f7ff ffb3 	bl	18c24 <encode>
		if (ret < 0) {
   18cbe:	2800      	cmp	r0, #0
   18cc0:	dbd9      	blt.n	18c76 <encode+0x52>
		if (i < n_elem - 1) {
   18cc2:	45bb      	cmp	fp, r7
   18cc4:	d802      	bhi.n	18ccc <encode+0xa8>
		field = (char *)field + elem_size;
   18cc6:	4456      	add	r6, sl
	for (i = 0; i < n_elem; i++) {
   18cc8:	3701      	adds	r7, #1
   18cca:	e7ea      	b.n	18ca2 <encode+0x7e>
			ret = append_bytes(",", 1, data);
   18ccc:	462a      	mov	r2, r5
   18cce:	2101      	movs	r1, #1
   18cd0:	4813      	ldr	r0, [pc, #76]	; (18d20 <encode+0xfc>)
   18cd2:	47a0      	blx	r4
			if (ret < 0) {
   18cd4:	2800      	cmp	r0, #0
   18cd6:	daf6      	bge.n	18cc6 <encode+0xa2>
   18cd8:	e7cd      	b.n	18c76 <encode+0x52>
		return json_obj_encode(descr->object.sub_descr,
   18cda:	9500      	str	r5, [sp, #0]
   18cdc:	4623      	mov	r3, r4
   18cde:	e9d0 0102 	ldrd	r0, r1, [r0, #8]
   18ce2:	4632      	mov	r2, r6
   18ce4:	f7ff ff56 	bl	18b94 <json_obj_encode>
   18ce8:	e7c5      	b.n	18c76 <encode+0x52>
	ret = snprintk(buf, sizeof(buf), "%d", *num);
   18cea:	588b      	ldr	r3, [r1, r2]
   18cec:	210c      	movs	r1, #12
   18cee:	4a0d      	ldr	r2, [pc, #52]	; (18d24 <encode+0x100>)
   18cf0:	eb0d 0001 	add.w	r0, sp, r1
   18cf4:	f01a fc75 	bl	335e2 <snprintk>
	if (ret < 0) {
   18cf8:	2800      	cmp	r0, #0
   18cfa:	dbbc      	blt.n	18c76 <encode+0x52>
	if (ret >= (int)sizeof(buf)) {
   18cfc:	280b      	cmp	r0, #11
   18cfe:	dc03      	bgt.n	18d08 <encode+0xe4>
	return append_bytes(buf, (size_t)ret, data);
   18d00:	4601      	mov	r1, r0
   18d02:	462a      	mov	r2, r5
   18d04:	a803      	add	r0, sp, #12
   18d06:	e7ac      	b.n	18c62 <encode+0x3e>
		return -ENOMEM;
   18d08:	f06f 000b 	mvn.w	r0, #11
		return num_encode(ptr, append_bytes, data);
   18d0c:	e7b3      	b.n	18c76 <encode+0x52>
   18d0e:	bf00      	nop
   18d10:	0003c503 	.word	0x0003c503
   18d14:	0003c4fd 	.word	0x0003c4fd
   18d18:	0003c970 	.word	0x0003c970
   18d1c:	0003c509 	.word	0x0003c509
   18d20:	0003c974 	.word	0x0003c974
   18d24:	0003c661 	.word	0x0003c661

00018d28 <nordicsemi_nrf91_init>:
	__asm__ volatile(
   18d28:	f04f 0220 	mov.w	r2, #32
   18d2c:	f3ef 8311 	mrs	r3, BASEPRI
   18d30:	f382 8811 	msr	BASEPRI, r2
   18d34:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
   18d38:	2101      	movs	r1, #1
   18d3a:	4a04      	ldr	r2, [pc, #16]	; (18d4c <nordicsemi_nrf91_init+0x24>)
   18d3c:	f8c2 1540 	str.w	r1, [r2, #1344]	; 0x540
	__asm__ volatile(
   18d40:	f383 8811 	msr	BASEPRI, r3
   18d44:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
   18d48:	2000      	movs	r0, #0
   18d4a:	4770      	bx	lr
   18d4c:	40039000 	.word	0x40039000

00018d50 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
   18d50:	b120      	cbz	r0, 18d5c <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
   18d52:	4b03      	ldr	r3, [pc, #12]	; (18d60 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
   18d54:	0180      	lsls	r0, r0, #6
   18d56:	f043 0301 	orr.w	r3, r3, #1
   18d5a:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
   18d5c:	4770      	bx	lr
   18d5e:	bf00      	nop
   18d60:	0003a130 	.word	0x0003a130

00018d64 <log_generic>:
	if (_is_user_context()) {
		log_generic_from_user(src_level, fmt, ap);
	} else  if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) &&
	    (!IS_ENABLED(CONFIG_LOG_FRONTEND))) {
		struct log_backend const *backend;
		u32_t timestamp = timestamp_func();
   18d64:	4b13      	ldr	r3, [pc, #76]	; (18db4 <log_generic+0x50>)
{
   18d66:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		u32_t timestamp = timestamp_func();
   18d6a:	681b      	ldr	r3, [r3, #0]
{
   18d6c:	4680      	mov	r8, r0
   18d6e:	4689      	mov	r9, r1
   18d70:	4692      	mov	sl, r2
		u32_t timestamp = timestamp_func();
   18d72:	4798      	blx	r3

		for (int i = 0; i < log_backend_count_get(); i++) {
   18d74:	2600      	movs	r6, #0
		u32_t timestamp = timestamp_func();
   18d76:	4607      	mov	r7, r0
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
   18d78:	4c0f      	ldr	r4, [pc, #60]	; (18db8 <log_generic+0x54>)
   18d7a:	4d10      	ldr	r5, [pc, #64]	; (18dbc <log_generic+0x58>)
   18d7c:	1b2d      	subs	r5, r5, r4
   18d7e:	112d      	asrs	r5, r5, #4
		for (int i = 0; i < log_backend_count_get(); i++) {
   18d80:	42ae      	cmp	r6, r5
   18d82:	db02      	blt.n	18d8a <log_generic+0x26>
			args[i] = va_arg(ap, log_arg_t);
		}

		log_n(fmt, args, nargs, src_level);
	}
}
   18d84:	b003      	add	sp, #12
   18d86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (log_backend_is_active(backend)) {
   18d8a:	4620      	mov	r0, r4
   18d8c:	f01a ff27 	bl	33bde <log_backend_is_active>
   18d90:	b160      	cbz	r0, 18dac <log_generic+0x48>
	if (backend->api->put_sync_string) {
   18d92:	6823      	ldr	r3, [r4, #0]
   18d94:	f8d3 b004 	ldr.w	fp, [r3, #4]
   18d98:	f1bb 0f00 	cmp.w	fp, #0
   18d9c:	d006      	beq.n	18dac <log_generic+0x48>
		backend->api->put_sync_string(backend, src_level,
   18d9e:	f8cd a000 	str.w	sl, [sp]
   18da2:	464b      	mov	r3, r9
   18da4:	463a      	mov	r2, r7
   18da6:	4641      	mov	r1, r8
   18da8:	4620      	mov	r0, r4
   18daa:	47d8      	blx	fp
		for (int i = 0; i < log_backend_count_get(); i++) {
   18dac:	3601      	adds	r6, #1
   18dae:	3410      	adds	r4, #16
   18db0:	e7e6      	b.n	18d80 <log_generic+0x1c>
   18db2:	bf00      	nop
   18db4:	200200a8 	.word	0x200200a8
   18db8:	0003a030 	.word	0x0003a030
   18dbc:	0003a040 	.word	0x0003a040

00018dc0 <log_core_init>:
	/* Set default timestamp. */
	if (sys_clock_hw_cycles_per_sec() > 1000000) {
		timestamp_func = k_uptime_get_32;
		freq = 1000;
	} else {
		timestamp_func = k_cycle_get_32_wrapper;
   18dc0:	4b03      	ldr	r3, [pc, #12]	; (18dd0 <log_core_init+0x10>)
   18dc2:	4a04      	ldr	r2, [pc, #16]	; (18dd4 <log_core_init+0x14>)
		freq = sys_clock_hw_cycles_per_sec();
	}

	log_output_timestamp_freq_set(freq);
   18dc4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
   18dc8:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
   18dca:	f000 ba35 	b.w	19238 <log_output_timestamp_freq_set>
   18dce:	bf00      	nop
   18dd0:	200200a8 	.word	0x200200a8
   18dd4:	00033be5 	.word	0x00033be5

00018dd8 <log_source_name_get>:
   18dd8:	4a04      	ldr	r2, [pc, #16]	; (18dec <log_source_name_get+0x14>)
   18dda:	4b05      	ldr	r3, [pc, #20]	; (18df0 <log_source_name_get+0x18>)
   18ddc:	1a9b      	subs	r3, r3, r2
	return log_sources_count();
}

const char *log_source_name_get(u32_t domain_id, u32_t src_id)
{
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
   18dde:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
   18de2:	bf34      	ite	cc
   18de4:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
   18de8:	2000      	movcs	r0, #0
}
   18dea:	4770      	bx	lr
   18dec:	00039f60 	.word	0x00039f60
   18df0:	0003a030 	.word	0x0003a030

00018df4 <log_backend_enable>:
}

void log_backend_enable(struct log_backend const *const backend,
			void *ctx,
			u32_t level)
{
   18df4:	b570      	push	{r4, r5, r6, lr}
	/* As first slot in filtering mask is reserved, backend ID has offset.*/
	u32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;

	id += backend - log_backend_get(0);
   18df6:	4c10      	ldr	r4, [pc, #64]	; (18e38 <log_backend_enable+0x44>)
{
   18df8:	4605      	mov	r5, r0
	id += backend - log_backend_get(0);
   18dfa:	1b04      	subs	r4, r0, r4
   18dfc:	1124      	asrs	r4, r4, #4
   18dfe:	3401      	adds	r4, #1
{
   18e00:	460e      	mov	r6, r1

	log_backend_id_set(backend, id);
   18e02:	b2e4      	uxtb	r4, r4
	__ASSERT_NO_MSG(backend != NULL);
   18e04:	b948      	cbnz	r0, 18e1a <log_backend_enable+0x26>
   18e06:	490d      	ldr	r1, [pc, #52]	; (18e3c <log_backend_enable+0x48>)
   18e08:	480d      	ldr	r0, [pc, #52]	; (18e40 <log_backend_enable+0x4c>)
   18e0a:	23c0      	movs	r3, #192	; 0xc0
   18e0c:	4a0d      	ldr	r2, [pc, #52]	; (18e44 <log_backend_enable+0x50>)
   18e0e:	f01a fbdb 	bl	335c8 <printk>
   18e12:	21c0      	movs	r1, #192	; 0xc0
   18e14:	480b      	ldr	r0, [pc, #44]	; (18e44 <log_backend_enable+0x50>)
   18e16:	f01a fed8 	bl	33bca <assert_post_action>
static inline void log_backend_activate(const struct log_backend *const backend,
					void *ctx)
{
	__ASSERT_NO_MSG(backend != NULL);
	backend->cb->ctx = ctx;
	backend->cb->active = true;
   18e1a:	2201      	movs	r2, #1
	backend->cb->id = id;
   18e1c:	686b      	ldr	r3, [r5, #4]
   18e1e:	711c      	strb	r4, [r3, #4]
	log_backend_activate(backend, ctx);

	/* Wakeup logger thread after attaching first backend. It might be
	 * blocked with log messages pending.
	 */
	if (!backend_attached) {
   18e20:	4c09      	ldr	r4, [pc, #36]	; (18e48 <log_backend_enable+0x54>)
	backend->cb->active = true;
   18e22:	715a      	strb	r2, [r3, #5]
   18e24:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
   18e26:	601e      	str	r6, [r3, #0]
   18e28:	b912      	cbnz	r2, 18e30 <log_backend_enable+0x3c>
	z_impl_k_sem_give(sem);
   18e2a:	4808      	ldr	r0, [pc, #32]	; (18e4c <log_backend_enable+0x58>)
   18e2c:	f015 f8de 	bl	2dfec <z_impl_k_sem_give>
		k_sem_give(&log_process_thread_sem);
	}

	backend_attached = true;
   18e30:	2301      	movs	r3, #1
   18e32:	7023      	strb	r3, [r4, #0]
}
   18e34:	bd70      	pop	{r4, r5, r6, pc}
   18e36:	bf00      	nop
   18e38:	0003a030 	.word	0x0003a030
   18e3c:	0003c9b6 	.word	0x0003c9b6
   18e40:	0003b77f 	.word	0x0003b77f
   18e44:	0003c985 	.word	0x0003c985
   18e48:	20027fb3 	.word	0x20027fb3
   18e4c:	200206d4 	.word	0x200206d4

00018e50 <log_init>:
{
   18e50:	b570      	push	{r4, r5, r6, lr}
	return __log_backends_end - __log_backends_start;
   18e52:	4c13      	ldr	r4, [pc, #76]	; (18ea0 <log_init+0x50>)
   18e54:	4d13      	ldr	r5, [pc, #76]	; (18ea4 <log_init+0x54>)
   18e56:	1b2d      	subs	r5, r5, r4
   18e58:	112d      	asrs	r5, r5, #4
	assert(log_backend_count_get() < LOG_FILTERS_NUM_OF_SLOTS);
   18e5a:	2d09      	cmp	r5, #9
   18e5c:	d906      	bls.n	18e6c <log_init+0x1c>
   18e5e:	4b12      	ldr	r3, [pc, #72]	; (18ea8 <log_init+0x58>)
   18e60:	4a12      	ldr	r2, [pc, #72]	; (18eac <log_init+0x5c>)
   18e62:	f44f 71f9 	mov.w	r1, #498	; 0x1f2
   18e66:	4812      	ldr	r0, [pc, #72]	; (18eb0 <log_init+0x60>)
   18e68:	f018 f9a4 	bl	311b4 <__assert_func>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   18e6c:	4b11      	ldr	r3, [pc, #68]	; (18eb4 <log_init+0x64>)
   18e6e:	e8d3 6fef 	ldaex	r6, [r3]
   18e72:	1c72      	adds	r2, r6, #1
   18e74:	e8c3 2fe1 	stlex	r1, r2, [r3]
   18e78:	2900      	cmp	r1, #0
   18e7a:	d1f8      	bne.n	18e6e <log_init+0x1e>
	if (atomic_inc(&initialized) != 0) {
   18e7c:	b90e      	cbnz	r6, 18e82 <log_init+0x32>
	for (i = 0; i < log_backend_count_get(); i++) {
   18e7e:	42ae      	cmp	r6, r5
   18e80:	d100      	bne.n	18e84 <log_init+0x34>
}
   18e82:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
   18e84:	7b23      	ldrb	r3, [r4, #12]
   18e86:	b143      	cbz	r3, 18e9a <log_init+0x4a>
			if (backend->api->init != NULL) {
   18e88:	6823      	ldr	r3, [r4, #0]
   18e8a:	695b      	ldr	r3, [r3, #20]
   18e8c:	b103      	cbz	r3, 18e90 <log_init+0x40>
				backend->api->init();
   18e8e:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
   18e90:	2204      	movs	r2, #4
   18e92:	2100      	movs	r1, #0
   18e94:	4620      	mov	r0, r4
   18e96:	f7ff ffad 	bl	18df4 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
   18e9a:	3601      	adds	r6, #1
   18e9c:	3410      	adds	r4, #16
   18e9e:	e7ee      	b.n	18e7e <log_init+0x2e>
   18ea0:	0003a030 	.word	0x0003a030
   18ea4:	0003a040 	.word	0x0003a040
   18ea8:	0003c9cd 	.word	0x0003c9cd
   18eac:	0003c97c 	.word	0x0003c97c
   18eb0:	0003ca04 	.word	0x0003ca04
   18eb4:	200216ec 	.word	0x200216ec

00018eb8 <z_impl_log_panic>:
{
   18eb8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
   18eba:	4f0c      	ldr	r7, [pc, #48]	; (18eec <z_impl_log_panic+0x34>)
   18ebc:	783d      	ldrb	r5, [r7, #0]
   18ebe:	b94d      	cbnz	r5, 18ed4 <z_impl_log_panic+0x1c>
	log_init();
   18ec0:	f7ff ffc6 	bl	18e50 <log_init>
   18ec4:	4c0a      	ldr	r4, [pc, #40]	; (18ef0 <z_impl_log_panic+0x38>)
   18ec6:	4e0b      	ldr	r6, [pc, #44]	; (18ef4 <z_impl_log_panic+0x3c>)
   18ec8:	1b36      	subs	r6, r6, r4
   18eca:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
   18ecc:	42b5      	cmp	r5, r6
   18ece:	db02      	blt.n	18ed6 <z_impl_log_panic+0x1e>
	panic_mode = true;
   18ed0:	2301      	movs	r3, #1
   18ed2:	703b      	strb	r3, [r7, #0]
}
   18ed4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (log_backend_is_active(backend)) {
   18ed6:	4620      	mov	r0, r4
   18ed8:	f01a fe81 	bl	33bde <log_backend_is_active>
   18edc:	b118      	cbz	r0, 18ee6 <z_impl_log_panic+0x2e>
	backend->api->panic(backend);
   18ede:	6823      	ldr	r3, [r4, #0]
   18ee0:	4620      	mov	r0, r4
   18ee2:	691b      	ldr	r3, [r3, #16]
   18ee4:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
   18ee6:	3501      	adds	r5, #1
   18ee8:	3410      	adds	r4, #16
   18eea:	e7ef      	b.n	18ecc <z_impl_log_panic+0x14>
   18eec:	20027fb4 	.word	0x20027fb4
   18ef0:	0003a030 	.word	0x0003a030
   18ef4:	0003a040 	.word	0x0003a040

00018ef8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
   18ef8:	b40e      	push	{r1, r2, r3}
   18efa:	b503      	push	{r0, r1, lr}
   18efc:	ab03      	add	r3, sp, #12
   18efe:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
   18f02:	4601      	mov	r1, r0
   18f04:	4804      	ldr	r0, [pc, #16]	; (18f18 <print_formatted+0x20>)
	va_start(args, fmt);
   18f06:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
   18f08:	f01a f9ee 	bl	332e8 <z_vprintk>
#endif
	va_end(args);

	return length;
}
   18f0c:	2000      	movs	r0, #0
   18f0e:	b002      	add	sp, #8
   18f10:	f85d eb04 	ldr.w	lr, [sp], #4
   18f14:	b003      	add	sp, #12
   18f16:	4770      	bx	lr
   18f18:	00033c1f 	.word	0x00033c1f

00018f1c <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
   18f1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
   18f20:	f011 0402 	ands.w	r4, r1, #2
{
   18f24:	b085      	sub	sp, #20
   18f26:	4606      	mov	r6, r0
   18f28:	4690      	mov	r8, r2
   18f2a:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
   18f2e:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
   18f32:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
   18f36:	d007      	beq.n	18f48 <prefix_print+0x2c>
	if (!format) {
   18f38:	f011 0f44 	tst.w	r1, #68	; 0x44
   18f3c:	d137      	bne.n	18fae <prefix_print+0x92>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
   18f3e:	461a      	mov	r2, r3
   18f40:	4932      	ldr	r1, [pc, #200]	; (1900c <prefix_print+0xf0>)
   18f42:	f7ff ffd9 	bl	18ef8 <print_formatted>
		length += timestamp_print(log_output, flags, timestamp);
   18f46:	4604      	mov	r4, r0
	if (color) {
   18f48:	f1b9 0f00 	cmp.w	r9, #0
   18f4c:	d00a      	beq.n	18f64 <prefix_print+0x48>
		const char *color = start && (colors[level] != NULL) ?
   18f4e:	4b30      	ldr	r3, [pc, #192]	; (19010 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
   18f50:	4930      	ldr	r1, [pc, #192]	; (19014 <prefix_print+0xf8>)
		const char *color = start && (colors[level] != NULL) ?
   18f52:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
   18f56:	4b30      	ldr	r3, [pc, #192]	; (19018 <prefix_print+0xfc>)
   18f58:	4630      	mov	r0, r6
   18f5a:	2a00      	cmp	r2, #0
   18f5c:	bf08      	it	eq
   18f5e:	461a      	moveq	r2, r3
   18f60:	f7ff ffca 	bl	18ef8 <print_formatted>
	if (level_on) {
   18f64:	b13d      	cbz	r5, 18f76 <prefix_print+0x5a>
		total += print_formatted(log_output, "<%s> ", severity[level]);
   18f66:	4b2d      	ldr	r3, [pc, #180]	; (1901c <prefix_print+0x100>)
   18f68:	492d      	ldr	r1, [pc, #180]	; (19020 <prefix_print+0x104>)
   18f6a:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
   18f6e:	4630      	mov	r0, r6
   18f70:	f7ff ffc2 	bl	18ef8 <print_formatted>
   18f74:	4605      	mov	r5, r0
	total += print_formatted(log_output,
   18f76:	f1b8 0f00 	cmp.w	r8, #0
   18f7a:	d044      	beq.n	19006 <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
   18f7c:	2301      	movs	r3, #1
   18f7e:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
   18f82:	4b28      	ldr	r3, [pc, #160]	; (19024 <prefix_print+0x108>)
   18f84:	f017 0f10 	tst.w	r7, #16
   18f88:	4f27      	ldr	r7, [pc, #156]	; (19028 <prefix_print+0x10c>)
   18f8a:	bf18      	it	ne
   18f8c:	461f      	movne	r7, r3
   18f8e:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
   18f92:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
   18f96:	f7ff ff1f 	bl	18dd8 <log_source_name_get>
   18f9a:	4639      	mov	r1, r7
   18f9c:	4602      	mov	r2, r0
   18f9e:	4630      	mov	r0, r6
   18fa0:	f7ff ffaa 	bl	18ef8 <print_formatted>
   18fa4:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
   18fa6:	4420      	add	r0, r4
   18fa8:	b005      	add	sp, #20
   18faa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
   18fae:	4a1f      	ldr	r2, [pc, #124]	; (1902c <prefix_print+0x110>)
   18fb0:	6811      	ldr	r1, [r2, #0]
   18fb2:	b331      	cbz	r1, 19002 <prefix_print+0xe6>
		timestamp /= timestamp_div;
   18fb4:	4a1e      	ldr	r2, [pc, #120]	; (19030 <prefix_print+0x114>)
   18fb6:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
   18fba:	6814      	ldr	r4, [r2, #0]
		ms = (remainder * 1000U) / freq;
   18fbc:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
   18fc0:	fbb3 f3f4 	udiv	r3, r3, r4
		seconds = timestamp / freq;
   18fc4:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
   18fc8:	fbb4 f2fe 	udiv	r2, r4, lr
   18fcc:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
   18fd0:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
   18fd4:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   18fd8:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
   18fdc:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   18fe0:	fb01 441b 	mls	r4, r1, fp, r4
   18fe4:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
   18fe8:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
   18fec:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
   18ff0:	e9cd b101 	strd	fp, r1, [sp, #4]
   18ff4:	fb0a e113 	mls	r1, sl, r3, lr
   18ff8:	9100      	str	r1, [sp, #0]
   18ffa:	490e      	ldr	r1, [pc, #56]	; (19034 <prefix_print+0x118>)
   18ffc:	f7ff ff7c 	bl	18ef8 <print_formatted>
   19000:	e7a1      	b.n	18f46 <prefix_print+0x2a>
		length = 0;
   19002:	4608      	mov	r0, r1
   19004:	e79f      	b.n	18f46 <prefix_print+0x2a>
	total += print_formatted(log_output,
   19006:	4f08      	ldr	r7, [pc, #32]	; (19028 <prefix_print+0x10c>)
   19008:	e7c1      	b.n	18f8e <prefix_print+0x72>
   1900a:	bf00      	nop
   1900c:	0003caa8 	.word	0x0003caa8
   19010:	0003a248 	.word	0x0003a248
   19014:	0003e625 	.word	0x0003e625
   19018:	0003ca9a 	.word	0x0003ca9a
   1901c:	0003a25c 	.word	0x0003a25c
   19020:	0003cacd 	.word	0x0003cacd
   19024:	0003caa4 	.word	0x0003caa4
   19028:	0003ca9f 	.word	0x0003ca9f
   1902c:	200216f0 	.word	0x200216f0
   19030:	200216f4 	.word	0x200216f4
   19034:	0003cab1 	.word	0x0003cab1

00019038 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
   19038:	b538      	push	{r3, r4, r5, lr}
   1903a:	460c      	mov	r4, r1
	if (color) {
   1903c:	07e1      	lsls	r1, r4, #31
{
   1903e:	4605      	mov	r5, r0
	if (color) {
   19040:	d503      	bpl.n	1904a <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
   19042:	4a08      	ldr	r2, [pc, #32]	; (19064 <postfix_print+0x2c>)
   19044:	4908      	ldr	r1, [pc, #32]	; (19068 <postfix_print+0x30>)
   19046:	f7ff ff57 	bl	18ef8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   1904a:	06e2      	lsls	r2, r4, #27
   1904c:	d408      	bmi.n	19060 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   1904e:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
   19050:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
   19052:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
   19056:	bf4c      	ite	mi
   19058:	4904      	ldrmi	r1, [pc, #16]	; (1906c <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
   1905a:	4905      	ldrpl	r1, [pc, #20]	; (19070 <postfix_print+0x38>)
   1905c:	f7ff bf4c 	b.w	18ef8 <print_formatted>
}
   19060:	bd38      	pop	{r3, r4, r5, pc}
   19062:	bf00      	nop
   19064:	0003ca9a 	.word	0x0003ca9a
   19068:	0003e625 	.word	0x0003e625
   1906c:	0003cb8c 	.word	0x0003cb8c
   19070:	0003f572 	.word	0x0003f572

00019074 <hexdump_line_print>:
{
   19074:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   19078:	4698      	mov	r8, r3
   1907a:	9b08      	ldr	r3, [sp, #32]
   1907c:	4604      	mov	r4, r0
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   1907e:	06dd      	lsls	r5, r3, #27
{
   19080:	460e      	mov	r6, r1
   19082:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
   19084:	d405      	bmi.n	19092 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
   19086:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
   19088:	bf4c      	ite	mi
   1908a:	492a      	ldrmi	r1, [pc, #168]	; (19134 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
   1908c:	492a      	ldrpl	r1, [pc, #168]	; (19138 <hexdump_line_print+0xc4>)
   1908e:	f7ff ff33 	bl	18ef8 <print_formatted>
{
   19092:	2500      	movs	r5, #0
		print_formatted(log_output, " ");
   19094:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 19140 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
   19098:	4545      	cmp	r5, r8
   1909a:	db2d      	blt.n	190f8 <hexdump_line_print+0x84>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   1909c:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
   1909e:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 19144 <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
   190a2:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 19148 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
   190a6:	f8df a098 	ldr.w	sl, [pc, #152]	; 19140 <hexdump_line_print+0xcc>
		if (i < length) {
   190aa:	42bd      	cmp	r5, r7
   190ac:	d231      	bcs.n	19112 <hexdump_line_print+0x9e>
			print_formatted(log_output, "%02x ", data[i]);
   190ae:	5d72      	ldrb	r2, [r6, r5]
   190b0:	4649      	mov	r1, r9
   190b2:	4620      	mov	r0, r4
   190b4:	f7ff ff20 	bl	18ef8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   190b8:	3501      	adds	r5, #1
   190ba:	2d10      	cmp	r5, #16
   190bc:	d122      	bne.n	19104 <hexdump_line_print+0x90>
	print_formatted(log_output, "|");
   190be:	491f      	ldr	r1, [pc, #124]	; (1913c <hexdump_line_print+0xc8>)
   190c0:	4620      	mov	r0, r4
   190c2:	f7ff ff19 	bl	18ef8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   190c6:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
   190c8:	f8df 8074 	ldr.w	r8, [pc, #116]	; 19140 <hexdump_line_print+0xcc>
			      isprint((int)c) ? c : '.');
   190cc:	f8df 907c 	ldr.w	r9, [pc, #124]	; 1914c <hexdump_line_print+0xd8>
			print_formatted(log_output, "%c",
   190d0:	f8df a07c 	ldr.w	sl, [pc, #124]	; 19150 <hexdump_line_print+0xdc>
		if (i < length) {
   190d4:	42af      	cmp	r7, r5
   190d6:	d928      	bls.n	1912a <hexdump_line_print+0xb6>
			char c = (char)data[i];
   190d8:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
   190da:	4651      	mov	r1, sl
   190dc:	f812 3009 	ldrb.w	r3, [r2, r9]
   190e0:	4620      	mov	r0, r4
   190e2:	f013 0f97 	tst.w	r3, #151	; 0x97
   190e6:	bf08      	it	eq
   190e8:	222e      	moveq	r2, #46	; 0x2e
   190ea:	f7ff ff05 	bl	18ef8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
   190ee:	3501      	adds	r5, #1
   190f0:	2d10      	cmp	r5, #16
   190f2:	d113      	bne.n	1911c <hexdump_line_print+0xa8>
}
   190f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
   190f8:	4649      	mov	r1, r9
   190fa:	4620      	mov	r0, r4
   190fc:	f7ff fefc 	bl	18ef8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
   19100:	3501      	adds	r5, #1
   19102:	e7c9      	b.n	19098 <hexdump_line_print+0x24>
		if (i > 0 && !(i % 8)) {
   19104:	076a      	lsls	r2, r5, #29
   19106:	d1d0      	bne.n	190aa <hexdump_line_print+0x36>
			print_formatted(log_output, " ");
   19108:	4651      	mov	r1, sl
   1910a:	4620      	mov	r0, r4
   1910c:	f7ff fef4 	bl	18ef8 <print_formatted>
   19110:	e7cb      	b.n	190aa <hexdump_line_print+0x36>
			print_formatted(log_output, "   ");
   19112:	4641      	mov	r1, r8
   19114:	4620      	mov	r0, r4
   19116:	f7ff feef 	bl	18ef8 <print_formatted>
   1911a:	e7cd      	b.n	190b8 <hexdump_line_print+0x44>
		if (i > 0 && !(i % 8)) {
   1911c:	076b      	lsls	r3, r5, #29
   1911e:	d1d9      	bne.n	190d4 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   19120:	4641      	mov	r1, r8
   19122:	4620      	mov	r0, r4
   19124:	f7ff fee8 	bl	18ef8 <print_formatted>
   19128:	e7d4      	b.n	190d4 <hexdump_line_print+0x60>
			print_formatted(log_output, " ");
   1912a:	4641      	mov	r1, r8
   1912c:	4620      	mov	r0, r4
   1912e:	f7ff fee3 	bl	18ef8 <print_formatted>
   19132:	e7dc      	b.n	190ee <hexdump_line_print+0x7a>
   19134:	0003cb8c 	.word	0x0003cb8c
   19138:	0003f572 	.word	0x0003f572
   1913c:	0003ca53 	.word	0x0003ca53
   19140:	0003ca51 	.word	0x0003ca51
   19144:	0003ca4f 	.word	0x0003ca4f
   19148:	0003ca49 	.word	0x0003ca49
   1914c:	00040188 	.word	0x00040188
   19150:	0003ca55 	.word	0x0003ca55

00019154 <log_output_string>:
}

void log_output_string(const struct log_output *log_output,
		       struct log_msg_ids src_level, u32_t timestamp,
		       const char *fmt, va_list ap, u32_t flags)
{
   19154:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
		log_output_string_syst_process(log_output,
				src_level, fmt, ap, flags);
		return;
	}

	if (!raw_string) {
   19158:	f011 0407 	ands.w	r4, r1, #7
{
   1915c:	4606      	mov	r6, r0
   1915e:	e9dd 870a 	ldrd	r8, r7, [sp, #40]	; 0x28
   19162:	461d      	mov	r5, r3
	if (!raw_string) {
   19164:	d00b      	beq.n	1917e <log_output_string+0x2a>
		prefix_print(log_output, flags, true, timestamp,
   19166:	f3c1 1389 	ubfx	r3, r1, #6, #10
   1916a:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   1916e:	9302      	str	r3, [sp, #8]
   19170:	e9cd 4100 	strd	r4, r1, [sp]
   19174:	4613      	mov	r3, r2
   19176:	4639      	mov	r1, r7
   19178:	2201      	movs	r2, #1
   1917a:	f7ff fecf 	bl	18f1c <prefix_print>

#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, ap);
#else
	z_vprintk(out_func, (void *)log_output, fmt, ap);
   1917e:	4643      	mov	r3, r8
   19180:	462a      	mov	r2, r5
   19182:	4631      	mov	r1, r6
   19184:	480d      	ldr	r0, [pc, #52]	; (191bc <log_output_string+0x68>)
   19186:	f01a f8af 	bl	332e8 <z_vprintk>
#endif

	(void)length;

	if (raw_string) {
   1918a:	b98c      	cbnz	r4, 191b0 <log_output_string+0x5c>
   1918c:	3d01      	subs	r5, #1
	while (*fmt != '\0') {
   1918e:	f815 3f01 	ldrb.w	r3, [r5, #1]!
   19192:	b95b      	cbnz	r3, 191ac <log_output_string+0x58>
		/* add \r if string ends with newline. */
		if (ends_with_newline(fmt)) {
   19194:	2c0a      	cmp	r4, #10
   19196:	d103      	bne.n	191a0 <log_output_string+0x4c>
			print_formatted(log_output, "\r");
   19198:	4909      	ldr	r1, [pc, #36]	; (191c0 <log_output_string+0x6c>)
   1919a:	4630      	mov	r0, r6
   1919c:	f7ff feac 	bl	18ef8 <print_formatted>
		}
	} else {
		postfix_print(log_output, flags, level);
	}

	log_output_flush(log_output);
   191a0:	4630      	mov	r0, r6
}
   191a2:	b004      	add	sp, #16
   191a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	log_output_flush(log_output);
   191a8:	f01a bd52 	b.w	33c50 <log_output_flush>
	while (*fmt != '\0') {
   191ac:	461c      	mov	r4, r3
   191ae:	e7ee      	b.n	1918e <log_output_string+0x3a>
		postfix_print(log_output, flags, level);
   191b0:	4622      	mov	r2, r4
   191b2:	4639      	mov	r1, r7
   191b4:	4630      	mov	r0, r6
   191b6:	f7ff ff3f 	bl	19038 <postfix_print>
   191ba:	e7f1      	b.n	191a0 <log_output_string+0x4c>
   191bc:	00033c1f 	.word	0x00033c1f
   191c0:	0003ca98 	.word	0x0003ca98

000191c4 <log_output_hexdump>:

void log_output_hexdump(const struct log_output *log_output,
			     struct log_msg_ids src_level, u32_t timestamp,
			     const char *metadata, const u8_t *data,
			     u32_t length, u32_t flags)
{
   191c4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   191c8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   191ca:	4698      	mov	r8, r3
   191cc:	e9dd 750c 	ldrd	r7, r5, [sp, #48]	; 0x30
		log_output_hexdump_syst_process(log_output,
				src_level, data, length, flags);
		return;
	}

	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   191d0:	f3c1 1389 	ubfx	r3, r1, #6, #10
	u8_t level = (u8_t)src_level.level;
   191d4:	f001 0907 	and.w	r9, r1, #7
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   191d8:	f3c1 01c2 	ubfx	r1, r1, #3, #3
   191dc:	9302      	str	r3, [sp, #8]
   191de:	e9cd 9100 	strd	r9, r1, [sp]
   191e2:	4613      	mov	r3, r2
   191e4:	4631      	mov	r1, r6
   191e6:	2201      	movs	r2, #1
{
   191e8:	4604      	mov	r4, r0
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   191ea:	f7ff fe97 	bl	18f1c <prefix_print>
				     level, domain_id, source_id);

	/* Print metadata */
	print_formatted(log_output, "%s", metadata);
   191ee:	4642      	mov	r2, r8
	prefix_offset = prefix_print(log_output, flags, true, timestamp,
   191f0:	4682      	mov	sl, r0
	print_formatted(log_output, "%s", metadata);
   191f2:	4910      	ldr	r1, [pc, #64]	; (19234 <log_output_hexdump+0x70>)
   191f4:	4620      	mov	r0, r4
   191f6:	f7ff fe7f 	bl	18ef8 <print_formatted>

	while (length) {
   191fa:	b955      	cbnz	r5, 19212 <log_output_hexdump+0x4e>

		data += part_len;
		length -= part_len;
	};

	postfix_print(log_output, flags, level);
   191fc:	4620      	mov	r0, r4
   191fe:	464a      	mov	r2, r9
   19200:	4631      	mov	r1, r6
   19202:	f7ff ff19 	bl	19038 <postfix_print>
	log_output_flush(log_output);
   19206:	4620      	mov	r0, r4
}
   19208:	b004      	add	sp, #16
   1920a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	log_output_flush(log_output);
   1920e:	f01a bd1f 	b.w	33c50 <log_output_flush>
		u32_t part_len = length > HEXDUMP_BYTES_IN_LINE ?
   19212:	2d10      	cmp	r5, #16
   19214:	46a8      	mov	r8, r5
   19216:	bf28      	it	cs
   19218:	f04f 0810 	movcs.w	r8, #16
		hexdump_line_print(log_output, data, part_len,
   1921c:	4639      	mov	r1, r7
   1921e:	9600      	str	r6, [sp, #0]
   19220:	4653      	mov	r3, sl
   19222:	4642      	mov	r2, r8
   19224:	4620      	mov	r0, r4
   19226:	f7ff ff25 	bl	19074 <hexdump_line_print>
		data += part_len;
   1922a:	4447      	add	r7, r8
		length -= part_len;
   1922c:	eba5 0508 	sub.w	r5, r5, r8
   19230:	e7e3      	b.n	191fa <log_output_hexdump+0x36>
   19232:	bf00      	nop
   19234:	0003e625 	.word	0x0003e625

00019238 <log_output_timestamp_freq_set>:
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
}

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
   19238:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
   1923a:	2100      	movs	r1, #0
	timestamp_div = 1U;
   1923c:	4a07      	ldr	r2, [pc, #28]	; (1925c <log_output_timestamp_freq_set+0x24>)
{
   1923e:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
   19240:	4c07      	ldr	r4, [pc, #28]	; (19260 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
   19242:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
   19244:	42a0      	cmp	r0, r4
   19246:	d804      	bhi.n	19252 <log_output_timestamp_freq_set+0x1a>
   19248:	b101      	cbz	r1, 1924c <log_output_timestamp_freq_set+0x14>
   1924a:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
   1924c:	4b05      	ldr	r3, [pc, #20]	; (19264 <log_output_timestamp_freq_set+0x2c>)
   1924e:	6018      	str	r0, [r3, #0]
}
   19250:	bd10      	pop	{r4, pc}
		frequency /= 2U;
   19252:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
   19254:	005b      	lsls	r3, r3, #1
   19256:	2101      	movs	r1, #1
   19258:	e7f4      	b.n	19244 <log_output_timestamp_freq_set+0xc>
   1925a:	bf00      	nop
   1925c:	200216f4 	.word	0x200216f4
   19260:	000f4240 	.word	0x000f4240
   19264:	200216f0 	.word	0x200216f0

00019268 <panic>:
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
   19268:	4801      	ldr	r0, [pc, #4]	; (19270 <panic+0x8>)
   1926a:	f01a bcf1 	b.w	33c50 <log_output_flush>
   1926e:	bf00      	nop
   19270:	0003a288 	.word	0x0003a288

00019274 <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
   19274:	b508      	push	{r3, lr}
   19276:	4806      	ldr	r0, [pc, #24]	; (19290 <log_backend_uart_init+0x1c>)
   19278:	f012 facc 	bl	2b814 <z_impl_device_get_binding>
	struct device *dev;

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);
   1927c:	b928      	cbnz	r0, 1928a <log_backend_uart_init+0x16>
   1927e:	4b05      	ldr	r3, [pc, #20]	; (19294 <log_backend_uart_init+0x20>)
   19280:	4a05      	ldr	r2, [pc, #20]	; (19298 <log_backend_uart_init+0x24>)
   19282:	212d      	movs	r1, #45	; 0x2d
   19284:	4805      	ldr	r0, [pc, #20]	; (1929c <log_backend_uart_init+0x28>)
   19286:	f017 ff95 	bl	311b4 <__assert_func>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
   1928a:	4b05      	ldr	r3, [pc, #20]	; (192a0 <log_backend_uart_init+0x2c>)
   1928c:	6058      	str	r0, [r3, #4]

	log_output_ctx_set(&log_output, dev);
}
   1928e:	bd08      	pop	{r3, pc}
   19290:	0003cb09 	.word	0x0003cb09
   19294:	0003c1be 	.word	0x0003c1be
   19298:	0003caf3 	.word	0x0003caf3
   1929c:	0003cb10 	.word	0x0003cb10
   192a0:	20021700 	.word	0x20021700

000192a4 <sync_hexdump>:
}

static void sync_hexdump(const struct log_backend *const backend,
			 struct log_msg_ids src_level, u32_t timestamp,
			 const char *metadata, const u8_t *data, u32_t length)
{
   192a4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
		 * by another one, lock context for whole log processing.
		 */
		key = irq_lock();
	}

	log_output_hexdump(log_output, src_level, timestamp,
   192a6:	200f      	movs	r0, #15
   192a8:	9002      	str	r0, [sp, #8]
   192aa:	9807      	ldr	r0, [sp, #28]
   192ac:	9001      	str	r0, [sp, #4]
   192ae:	9806      	ldr	r0, [sp, #24]
   192b0:	9000      	str	r0, [sp, #0]
   192b2:	4803      	ldr	r0, [pc, #12]	; (192c0 <sync_hexdump+0x1c>)
   192b4:	f7ff ff86 	bl	191c4 <log_output_hexdump>
	u32_t flag = IS_ENABLED(CONFIG_LOG_BACKEND_UART_SYST_ENABLE) ?
		LOG_OUTPUT_FLAG_FORMAT_SYST : 0;

	log_backend_std_sync_hexdump(&log_output, flag, src_level,
				     timestamp, metadata, data, length);
}
   192b8:	b005      	add	sp, #20
   192ba:	f85d fb04 	ldr.w	pc, [sp], #4
   192be:	bf00      	nop
   192c0:	0003a288 	.word	0x0003a288

000192c4 <sync_string>:
{
   192c4:	b507      	push	{r0, r1, r2, lr}
	log_output_string(log_output, src_level, timestamp, fmt, ap, flags);
   192c6:	200f      	movs	r0, #15
   192c8:	9001      	str	r0, [sp, #4]
   192ca:	9804      	ldr	r0, [sp, #16]
   192cc:	9000      	str	r0, [sp, #0]
   192ce:	4803      	ldr	r0, [pc, #12]	; (192dc <sync_string+0x18>)
   192d0:	f7ff ff40 	bl	19154 <log_output_string>
}
   192d4:	b003      	add	sp, #12
   192d6:	f85d fb04 	ldr.w	pc, [sp], #4
   192da:	bf00      	nop
   192dc:	0003a288 	.word	0x0003a288

000192e0 <net_context_get_state>:
 *
 * @return Network state.
 */
static inline
enum net_context_state net_context_get_state(struct net_context *context)
{
   192e0:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   192e2:	4604      	mov	r4, r0
   192e4:	b970      	cbnz	r0, 19304 <net_context_get_state+0x24>
   192e6:	490a      	ldr	r1, [pc, #40]	; (19310 <net_context_get_state+0x30>)
   192e8:	f44f 73d3 	mov.w	r3, #422	; 0x1a6
   192ec:	4a09      	ldr	r2, [pc, #36]	; (19314 <net_context_get_state+0x34>)
   192ee:	480a      	ldr	r0, [pc, #40]	; (19318 <net_context_get_state+0x38>)
   192f0:	f01a f96a 	bl	335c8 <printk>
   192f4:	4809      	ldr	r0, [pc, #36]	; (1931c <net_context_get_state+0x3c>)
   192f6:	f01a f967 	bl	335c8 <printk>
   192fa:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   192fe:	4805      	ldr	r0, [pc, #20]	; (19314 <net_context_get_state+0x34>)
   19300:	f01a fc63 	bl	33bca <assert_post_action>

	return (enum net_context_state)
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
   19304:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
		NET_CONTEXT_STATE_MASK);
}
   19308:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1930c:	bd10      	pop	{r4, pc}
   1930e:	bf00      	nop
   19310:	0003cb83 	.word	0x0003cb83
   19314:	0003cb56 	.word	0x0003cb56
   19318:	0003b77f 	.word	0x0003b77f
   1931c:	0003cb8b 	.word	0x0003cb8b

00019320 <net_context_get_type>:
 *
 * @return Network context type.
 */
static inline
enum net_sock_type net_context_get_type(struct net_context *context)
{
   19320:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   19322:	4604      	mov	r4, r0
   19324:	b970      	cbnz	r0, 19344 <net_context_get_type+0x24>
   19326:	490a      	ldr	r1, [pc, #40]	; (19350 <net_context_get_type+0x30>)
   19328:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   1932c:	4a09      	ldr	r2, [pc, #36]	; (19354 <net_context_get_type+0x34>)
   1932e:	480a      	ldr	r0, [pc, #40]	; (19358 <net_context_get_type+0x38>)
   19330:	f01a f94a 	bl	335c8 <printk>
   19334:	4809      	ldr	r0, [pc, #36]	; (1935c <net_context_get_type+0x3c>)
   19336:	f01a f947 	bl	335c8 <printk>
   1933a:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   1933e:	4805      	ldr	r0, [pc, #20]	; (19354 <net_context_get_type+0x34>)
   19340:	f01a fc43 	bl	33bca <assert_post_action>

	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   19344:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   19348:	f3c0 1081 	ubfx	r0, r0, #6, #2
   1934c:	bd10      	pop	{r4, pc}
   1934e:	bf00      	nop
   19350:	0003cb83 	.word	0x0003cb83
   19354:	0003cb56 	.word	0x0003cb56
   19358:	0003b77f 	.word	0x0003b77f
   1935c:	0003cb8b 	.word	0x0003cb8b

00019360 <zsock_accepted_cb>:
#include <syscalls/zsock_shutdown_mrsh.c>
#endif /* CONFIG_USERSPACE */

static void zsock_accepted_cb(struct net_context *new_ctx,
			      struct sockaddr *addr, socklen_t addrlen,
			      int status, void *user_data) {
   19360:	b538      	push	{r3, r4, r5, lr}
   19362:	9d04      	ldr	r5, [sp, #16]
   19364:	4604      	mov	r4, r0
	struct net_context *parent = user_data;

	NET_DBG("parent=%p, ctx=%p, st=%d", parent, new_ctx, status);

	if (status == 0) {
   19366:	461a      	mov	r2, r3
   19368:	b96b      	cbnz	r3, 19386 <zsock_accepted_cb+0x26>
		/* This just installs a callback, so cannot fail. */
		(void)net_context_recv(new_ctx, zsock_received_cb, K_NO_WAIT,
   1936a:	4907      	ldr	r1, [pc, #28]	; (19388 <zsock_accepted_cb+0x28>)
   1936c:	f003 feb0 	bl	1d0d0 <net_context_recv>
	z_impl_k_queue_init(queue);
   19370:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   19374:	f01f fc89 	bl	38c8a <z_impl_k_queue_init>
				       NULL);
		k_fifo_init(&new_ctx->recv_q);

		k_fifo_put(&parent->accept_q, new_ctx);
   19378:	4621      	mov	r1, r4
   1937a:	f105 005c 	add.w	r0, r5, #92	; 0x5c
	}
}
   1937e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		k_fifo_put(&parent->accept_q, new_ctx);
   19382:	f01f bc8f 	b.w	38ca4 <k_queue_append>
}
   19386:	bd38      	pop	{r3, r4, r5, pc}
   19388:	00033d53 	.word	0x00033d53

0001938c <zsock_socket_internal>:
{
   1938c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1938e:	4607      	mov	r7, r0
   19390:	460e      	mov	r6, r1
   19392:	4614      	mov	r4, r2
	int fd = z_reserve_fd();
   19394:	f7ff fab2 	bl	188fc <z_reserve_fd>
	if (fd < 0) {
   19398:	1e05      	subs	r5, r0, #0
   1939a:	db17      	blt.n	193cc <zsock_socket_internal+0x40>
	if (proto == 0) {
   1939c:	b93c      	cbnz	r4, 193ae <zsock_socket_internal+0x22>
		if (family == AF_INET || family == AF_INET6) {
   1939e:	1e7b      	subs	r3, r7, #1
   193a0:	2b01      	cmp	r3, #1
   193a2:	d804      	bhi.n	193ae <zsock_socket_internal+0x22>
			if (type == SOCK_DGRAM) {
   193a4:	2e02      	cmp	r6, #2
   193a6:	d014      	beq.n	193d2 <zsock_socket_internal+0x46>
			} else if (type == SOCK_STREAM) {
   193a8:	2e01      	cmp	r6, #1
				proto = IPPROTO_TCP;
   193aa:	bf08      	it	eq
   193ac:	2406      	moveq	r4, #6
	res = net_context_get(family, type, proto, &ctx);
   193ae:	b2f1      	uxtb	r1, r6
   193b0:	ab01      	add	r3, sp, #4
   193b2:	b2a2      	uxth	r2, r4
   193b4:	b2b8      	uxth	r0, r7
   193b6:	f003 fa5d 	bl	1c874 <net_context_get>
	if (res < 0) {
   193ba:	1e06      	subs	r6, r0, #0
   193bc:	da0b      	bge.n	193d6 <zsock_socket_internal+0x4a>
		z_free_fd(fd);
   193be:	4628      	mov	r0, r5
   193c0:	f7ff fac8 	bl	18954 <z_free_fd>
		errno = -res;
   193c4:	f01c f890 	bl	354e8 <__errno>
   193c8:	4276      	negs	r6, r6
   193ca:	6006      	str	r6, [r0, #0]
		return -1;
   193cc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   193d0:	e012      	b.n	193f8 <zsock_socket_internal+0x6c>
				proto = IPPROTO_UDP;
   193d2:	2411      	movs	r4, #17
   193d4:	e7eb      	b.n	193ae <zsock_socket_internal+0x22>
	ctx->user_data = NULL;
   193d6:	2300      	movs	r3, #0
   193d8:	9801      	ldr	r0, [sp, #4]
   193da:	6003      	str	r3, [r0, #0]
	ctx->socket_data = NULL;
   193dc:	6583      	str	r3, [r0, #88]	; 0x58
   193de:	305c      	adds	r0, #92	; 0x5c
   193e0:	f01f fc53 	bl	38c8a <z_impl_k_queue_init>
	if (proto == IPPROTO_TCP) {
   193e4:	2c06      	cmp	r4, #6
   193e6:	d102      	bne.n	193ee <zsock_socket_internal+0x62>
		net_context_ref(ctx);
   193e8:	9801      	ldr	r0, [sp, #4]
   193ea:	f01c fad4 	bl	35996 <net_context_ref>
	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
   193ee:	4a04      	ldr	r2, [pc, #16]	; (19400 <zsock_socket_internal+0x74>)
   193f0:	9901      	ldr	r1, [sp, #4]
   193f2:	4628      	mov	r0, r5
   193f4:	f7ff faa4 	bl	18940 <z_finalize_fd>
}
   193f8:	4628      	mov	r0, r5
   193fa:	b003      	add	sp, #12
   193fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   193fe:	bf00      	nop
   19400:	0003a298 	.word	0x0003a298

00019404 <z_impl_zsock_socket>:
{
   19404:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
   19408:	f8df 909c 	ldr.w	r9, [pc, #156]	; 194a8 <z_impl_zsock_socket+0xa4>
{
   1940c:	4605      	mov	r5, r0
   1940e:	460f      	mov	r7, r1
   19410:	4690      	mov	r8, r2
   19412:	46ca      	mov	sl, r9
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
   19414:	4c1d      	ldr	r4, [pc, #116]	; (1948c <z_impl_zsock_socket+0x88>)
   19416:	4e1e      	ldr	r6, [pc, #120]	; (19490 <z_impl_zsock_socket+0x8c>)
   19418:	454c      	cmp	r4, r9
   1941a:	d90c      	bls.n	19436 <z_impl_zsock_socket+0x32>
   1941c:	491d      	ldr	r1, [pc, #116]	; (19494 <z_impl_zsock_socket+0x90>)
   1941e:	2399      	movs	r3, #153	; 0x99
   19420:	4632      	mov	r2, r6
   19422:	481d      	ldr	r0, [pc, #116]	; (19498 <z_impl_zsock_socket+0x94>)
   19424:	f01a f8d0 	bl	335c8 <printk>
   19428:	481c      	ldr	r0, [pc, #112]	; (1949c <z_impl_zsock_socket+0x98>)
   1942a:	f01a f8cd 	bl	335c8 <printk>
   1942e:	2199      	movs	r1, #153	; 0x99
   19430:	4630      	mov	r0, r6
   19432:	f01a fbca 	bl	33bca <assert_post_action>
   19436:	4554      	cmp	r4, sl
   19438:	d306      	bcc.n	19448 <z_impl_zsock_socket+0x44>
		return zsock_socket_internal(family, type, proto);
   1943a:	4642      	mov	r2, r8
   1943c:	4639      	mov	r1, r7
   1943e:	4628      	mov	r0, r5
}
   19440:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return zsock_socket_internal(family, type, proto);
   19444:	f7ff bfa2 	b.w	1938c <zsock_socket_internal>
		if (sock_family->family != family &&
   19448:	6823      	ldr	r3, [r4, #0]
   1944a:	42ab      	cmp	r3, r5
   1944c:	d000      	beq.n	19450 <z_impl_zsock_socket+0x4c>
   1944e:	b9db      	cbnz	r3, 19488 <z_impl_zsock_socket+0x84>
		NET_ASSERT(sock_family->is_supported);
   19450:	6863      	ldr	r3, [r4, #4]
   19452:	b963      	cbnz	r3, 1946e <z_impl_zsock_socket+0x6a>
   19454:	4912      	ldr	r1, [pc, #72]	; (194a0 <z_impl_zsock_socket+0x9c>)
   19456:	239f      	movs	r3, #159	; 0x9f
   19458:	4632      	mov	r2, r6
   1945a:	480f      	ldr	r0, [pc, #60]	; (19498 <z_impl_zsock_socket+0x94>)
   1945c:	f01a f8b4 	bl	335c8 <printk>
   19460:	4810      	ldr	r0, [pc, #64]	; (194a4 <z_impl_zsock_socket+0xa0>)
   19462:	f01a f8b1 	bl	335c8 <printk>
   19466:	219f      	movs	r1, #159	; 0x9f
   19468:	4630      	mov	r0, r6
   1946a:	f01a fbae 	bl	33bca <assert_post_action>
		if (!sock_family->is_supported(family, type, proto)) {
   1946e:	6863      	ldr	r3, [r4, #4]
   19470:	4642      	mov	r2, r8
   19472:	4639      	mov	r1, r7
   19474:	4628      	mov	r0, r5
   19476:	4798      	blx	r3
   19478:	b130      	cbz	r0, 19488 <z_impl_zsock_socket+0x84>
		return sock_family->handler(family, type, proto);
   1947a:	68a3      	ldr	r3, [r4, #8]
   1947c:	4642      	mov	r2, r8
   1947e:	4639      	mov	r1, r7
   19480:	4628      	mov	r0, r5
}
   19482:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return sock_family->handler(family, type, proto);
   19486:	4718      	bx	r3
	Z_STRUCT_SECTION_FOREACH(net_socket_register, sock_family) {
   19488:	340c      	adds	r4, #12
   1948a:	e7c5      	b.n	19418 <z_impl_zsock_socket+0x14>
   1948c:	00039f54 	.word	0x00039f54
   19490:	0003cb8e 	.word	0x0003cb8e
   19494:	0003cbdc 	.word	0x0003cbdc
   19498:	0003b77f 	.word	0x0003b77f
   1949c:	0003cc09 	.word	0x0003cc09
   194a0:	0003cbc2 	.word	0x0003cbc2
   194a4:	0003cb8b 	.word	0x0003cb8b
   194a8:	00039f60 	.word	0x00039f60

000194ac <zsock_bind_ctx>:
	k_fifo_put(&ctx->recv_q, pkt);
}

int zsock_bind_ctx(struct net_context *ctx, const struct sockaddr *addr,
		   socklen_t addrlen)
{
   194ac:	b538      	push	{r3, r4, r5, lr}
   194ae:	4604      	mov	r4, r0
	SET_ERRNO(net_context_bind(ctx, addr, addrlen));
   194b0:	f003 fada 	bl	1ca68 <net_context_bind>
   194b4:	1e05      	subs	r5, r0, #0
   194b6:	da06      	bge.n	194c6 <zsock_bind_ctx+0x1a>
   194b8:	f01c f816 	bl	354e8 <__errno>
   194bc:	426d      	negs	r5, r5
   194be:	6005      	str	r5, [r0, #0]
	/* For DGRAM socket, we expect to receive packets after call to
	 * bind(), but for STREAM socket, next expected operation is
	 * listen(), which doesn't work if recv callback is set.
	 */
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
   194c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   194c4:	e005      	b.n	194d2 <zsock_bind_ctx+0x26>
	if (net_context_get_type(ctx) == SOCK_DGRAM) {
   194c6:	4620      	mov	r0, r4
   194c8:	f7ff ff2a 	bl	19320 <net_context_get_type>
   194cc:	2802      	cmp	r0, #2
   194ce:	d001      	beq.n	194d4 <zsock_bind_ctx+0x28>
					   ctx->user_data));
	}

	return 0;
   194d0:	2000      	movs	r0, #0
}
   194d2:	bd38      	pop	{r3, r4, r5, pc}
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
   194d4:	6823      	ldr	r3, [r4, #0]
   194d6:	4620      	mov	r0, r4
   194d8:	2200      	movs	r2, #0
   194da:	4905      	ldr	r1, [pc, #20]	; (194f0 <zsock_bind_ctx+0x44>)
   194dc:	f003 fdf8 	bl	1d0d0 <net_context_recv>
   194e0:	1e04      	subs	r4, r0, #0
   194e2:	daf5      	bge.n	194d0 <zsock_bind_ctx+0x24>
   194e4:	f01c f800 	bl	354e8 <__errno>
   194e8:	4264      	negs	r4, r4
   194ea:	6004      	str	r4, [r0, #0]
   194ec:	e7e8      	b.n	194c0 <zsock_bind_ctx+0x14>
   194ee:	bf00      	nop
   194f0:	00033d53 	.word	0x00033d53

000194f4 <zsock_connect_ctx>:
#include <syscalls/zsock_bind_mrsh.c>
#endif /* CONFIG_USERSPACE */

int zsock_connect_ctx(struct net_context *ctx, const struct sockaddr *addr,
		      socklen_t addrlen)
{
   194f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
		SET_ERRNO(net_context_recv(ctx, zsock_received_cb,
					   K_NO_WAIT, ctx->user_data));
		return 0;
	}
#endif
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
   194f6:	f640 33b8 	movw	r3, #3000	; 0xbb8
   194fa:	2400      	movs	r4, #0
   194fc:	e9cd 3400 	strd	r3, r4, [sp]
   19500:	4623      	mov	r3, r4
{
   19502:	4606      	mov	r6, r0
	SET_ERRNO(net_context_connect(ctx, addr, addrlen, NULL,
   19504:	f003 fcc0 	bl	1ce88 <net_context_connect>
   19508:	1e05      	subs	r5, r0, #0
   1950a:	da07      	bge.n	1951c <zsock_connect_ctx+0x28>
			      K_MSEC(CONFIG_NET_SOCKETS_CONNECT_TIMEOUT),
			      NULL));
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
   1950c:	f01b ffec 	bl	354e8 <__errno>
   19510:	426d      	negs	r5, r5
   19512:	6005      	str	r5, [r0, #0]
   19514:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
				   ctx->user_data));

	return 0;
}
   19518:	b002      	add	sp, #8
   1951a:	bd70      	pop	{r4, r5, r6, pc}
	SET_ERRNO(net_context_recv(ctx, zsock_received_cb, K_NO_WAIT,
   1951c:	6833      	ldr	r3, [r6, #0]
   1951e:	4622      	mov	r2, r4
   19520:	4903      	ldr	r1, [pc, #12]	; (19530 <zsock_connect_ctx+0x3c>)
   19522:	4630      	mov	r0, r6
   19524:	f003 fdd4 	bl	1d0d0 <net_context_recv>
   19528:	1e05      	subs	r5, r0, #0
   1952a:	dbef      	blt.n	1950c <zsock_connect_ctx+0x18>
	return 0;
   1952c:	4620      	mov	r0, r4
   1952e:	e7f3      	b.n	19518 <zsock_connect_ctx+0x24>
   19530:	00033d53 	.word	0x00033d53

00019534 <zsock_listen_ctx>:
}
#include <syscalls/zsock_connect_mrsh.c>
#endif /* CONFIG_USERSPACE */

int zsock_listen_ctx(struct net_context *ctx, int backlog)
{
   19534:	b538      	push	{r3, r4, r5, lr}
   19536:	4605      	mov	r5, r0
	SET_ERRNO(net_context_listen(ctx, backlog));
   19538:	f003 fb20 	bl	1cb7c <net_context_listen>
   1953c:	1e04      	subs	r4, r0, #0
   1953e:	da06      	bge.n	1954e <zsock_listen_ctx+0x1a>
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
   19540:	f01b ffd2 	bl	354e8 <__errno>
   19544:	4264      	negs	r4, r4
   19546:	6004      	str	r4, [r0, #0]
   19548:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

	return 0;
}
   1954c:	bd38      	pop	{r3, r4, r5, pc}
	SET_ERRNO(net_context_accept(ctx, zsock_accepted_cb, K_NO_WAIT, ctx));
   1954e:	462b      	mov	r3, r5
   19550:	2200      	movs	r2, #0
   19552:	4904      	ldr	r1, [pc, #16]	; (19564 <zsock_listen_ctx+0x30>)
   19554:	4628      	mov	r0, r5
   19556:	f003 fd6b 	bl	1d030 <net_context_accept>
   1955a:	1e04      	subs	r4, r0, #0
   1955c:	dbf0      	blt.n	19540 <zsock_listen_ctx+0xc>
	return 0;
   1955e:	2000      	movs	r0, #0
   19560:	e7f4      	b.n	1954c <zsock_listen_ctx+0x18>
   19562:	bf00      	nop
   19564:	00019361 	.word	0x00019361

00019568 <zsock_accept_ctx>:
#include <syscalls/zsock_listen_mrsh.c>
#endif /* CONFIG_USERSPACE */

int zsock_accept_ctx(struct net_context *parent, struct sockaddr *addr,
		     socklen_t *addrlen)
{
   19568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1956a:	4605      	mov	r5, r0
   1956c:	460f      	mov	r7, r1
   1956e:	4616      	mov	r6, r2
	k_timeout_t timeout = K_FOREVER;
	struct net_context *ctx;
	struct net_pkt *last_pkt;
	int fd;

	fd = z_reserve_fd();
   19570:	f7ff f9c4 	bl	188fc <z_reserve_fd>
	if (fd < 0) {
   19574:	1e04      	subs	r4, r0, #0
   19576:	db31      	blt.n	195dc <zsock_accept_ctx+0x74>
		return -1;
	}

	if (sock_is_nonblock(parent)) {
   19578:	6da9      	ldr	r1, [r5, #88]	; 0x58
   1957a:	f081 0102 	eor.w	r1, r1, #2
   1957e:	f341 0140 	sbfx	r1, r1, #1, #1
	return z_impl_k_queue_get(queue, timeout);
   19582:	f105 005c 	add.w	r0, r5, #92	; 0x5c
   19586:	f013 faab 	bl	2cae0 <z_impl_k_queue_get>
		timeout = K_NO_WAIT;
	}

	ctx = k_fifo_get(&parent->accept_q, timeout);
	if (ctx == NULL) {
   1958a:	4605      	mov	r5, r0
   1958c:	b938      	cbnz	r0, 1959e <zsock_accept_ctx+0x36>
		z_free_fd(fd);
   1958e:	4620      	mov	r0, r4
   19590:	f7ff f9e0 	bl	18954 <z_free_fd>
		errno = EAGAIN;
   19594:	f01b ffa8 	bl	354e8 <__errno>
   19598:	230b      	movs	r3, #11
			*addrlen = sizeof(struct sockaddr_in);
		} else if (ctx->remote.sa_family == AF_INET6) {
			*addrlen = sizeof(struct sockaddr_in6);
		} else {
			z_free_fd(fd);
			errno = ENOTSUP;
   1959a:	6003      	str	r3, [r0, #0]
			return -1;
   1959c:	e01e      	b.n	195dc <zsock_accept_ctx+0x74>
	return z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
   1959e:	2100      	movs	r1, #0
   195a0:	6e00      	ldr	r0, [r0, #96]	; 0x60
   195a2:	f01f fb66 	bl	38c72 <z_queue_node_peek>
	if (last_pkt) {
   195a6:	b170      	cbz	r0, 195c6 <zsock_accept_ctx+0x5e>
}

#if defined(CONFIG_NET_SOCKETS)
static inline u8_t net_pkt_eof(struct net_pkt *pkt)
{
	return pkt->sent_or_eof;
   195a8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
		if (net_pkt_eof(last_pkt)) {
   195ac:	0799      	lsls	r1, r3, #30
   195ae:	d50a      	bpl.n	195c6 <zsock_accept_ctx+0x5e>
static inline void sock_set_flag(struct net_context *ctx, uintptr_t mask,
				 uintptr_t flag)
{
	uintptr_t val = POINTER_TO_UINT(ctx->socket_data);

	val = (val & ~mask) | flag;
   195b0:	6dab      	ldr	r3, [r5, #88]	; 0x58
			z_free_fd(fd);
   195b2:	4620      	mov	r0, r4
   195b4:	f043 0301 	orr.w	r3, r3, #1
	(ctx)->socket_data = UINT_TO_POINTER(val);
   195b8:	65ab      	str	r3, [r5, #88]	; 0x58
   195ba:	f7ff f9cb 	bl	18954 <z_free_fd>
			errno = ECONNABORTED;
   195be:	f01b ff93 	bl	354e8 <__errno>
   195c2:	2371      	movs	r3, #113	; 0x71
   195c4:	e7e9      	b.n	1959a <zsock_accept_ctx+0x32>
	return context->flags & NET_CONTEXT_CLOSING_SOCK;
   195c6:	f8b5 307a 	ldrh.w	r3, [r5, #122]	; 0x7a
	if (net_context_is_closing(ctx)) {
   195ca:	055a      	lsls	r2, r3, #21
   195cc:	d509      	bpl.n	195e2 <zsock_accept_ctx+0x7a>
		errno = ECONNABORTED;
   195ce:	f01b ff8b 	bl	354e8 <__errno>
   195d2:	2371      	movs	r3, #113	; 0x71
   195d4:	6003      	str	r3, [r0, #0]
		z_free_fd(fd);
   195d6:	4620      	mov	r0, r4
   195d8:	f7ff f9bc 	bl	18954 <z_free_fd>
		return -1;
   195dc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   195e0:	e01b      	b.n	1961a <zsock_accept_ctx+0xb2>
		context->flags &= ~NET_CONTEXT_ACCEPTING_SOCK;
   195e2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
   195e6:	f8a5 307a 	strh.w	r3, [r5, #122]	; 0x7a
	if (addr != NULL && addrlen != NULL) {
   195ea:	b177      	cbz	r7, 1960a <zsock_accept_ctx+0xa2>
   195ec:	b16e      	cbz	r6, 1960a <zsock_accept_ctx+0xa2>
		int len = MIN(*addrlen, sizeof(ctx->remote));
   195ee:	6832      	ldr	r2, [r6, #0]
   195f0:	f105 0124 	add.w	r1, r5, #36	; 0x24
   195f4:	2a08      	cmp	r2, #8
   195f6:	bf28      	it	cs
   195f8:	2208      	movcs	r2, #8
   195fa:	4638      	mov	r0, r7
   195fc:	f01f fcec 	bl	38fd8 <memcpy>
		if (ctx->remote.sa_family == AF_INET) {
   19600:	8cab      	ldrh	r3, [r5, #36]	; 0x24
   19602:	2b01      	cmp	r3, #1
   19604:	d10b      	bne.n	1961e <zsock_accept_ctx+0xb6>
			*addrlen = sizeof(struct sockaddr_in);
   19606:	2308      	movs	r3, #8
			*addrlen = sizeof(struct sockaddr_in6);
   19608:	6033      	str	r3, [r6, #0]
	 * connection, but it must not dispose of the context behind
	 * the application back. Likewise, when application "closes"
	 * context, it's not disposed of immediately - there's yet
	 * closing handshake for stack to perform.
	 */
	net_context_ref(ctx);
   1960a:	4628      	mov	r0, r5
   1960c:	f01c f9c3 	bl	35996 <net_context_ref>

	NET_DBG("accept: ctx=%p, fd=%d", ctx, fd);

	z_finalize_fd(fd, ctx, (const struct fd_op_vtable *)&sock_fd_op_vtable);
   19610:	4a08      	ldr	r2, [pc, #32]	; (19634 <zsock_accept_ctx+0xcc>)
   19612:	4629      	mov	r1, r5
   19614:	4620      	mov	r0, r4
   19616:	f7ff f993 	bl	18940 <z_finalize_fd>

	return fd;
}
   1961a:	4620      	mov	r0, r4
   1961c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		} else if (ctx->remote.sa_family == AF_INET6) {
   1961e:	2b02      	cmp	r3, #2
   19620:	d101      	bne.n	19626 <zsock_accept_ctx+0xbe>
			*addrlen = sizeof(struct sockaddr_in6);
   19622:	2318      	movs	r3, #24
   19624:	e7f0      	b.n	19608 <zsock_accept_ctx+0xa0>
			z_free_fd(fd);
   19626:	4620      	mov	r0, r4
   19628:	f7ff f994 	bl	18954 <z_free_fd>
			errno = ENOTSUP;
   1962c:	f01b ff5c 	bl	354e8 <__errno>
   19630:	2386      	movs	r3, #134	; 0x86
   19632:	e7b2      	b.n	1959a <zsock_accept_ctx+0x32>
   19634:	0003a298 	.word	0x0003a298

00019638 <zsock_sendto_ctx>:
#endif /* CONFIG_USERSPACE */

ssize_t zsock_sendto_ctx(struct net_context *ctx, const void *buf, size_t len,
			 int flags,
			 const struct sockaddr *dest_addr, socklen_t addrlen)
{
   19638:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_timeout_t timeout = K_FOREVER;
	int status;

	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   1963c:	065b      	lsls	r3, r3, #25
   1963e:	bf58      	it	pl
   19640:	6d84      	ldrpl	r4, [r0, #88]	; 0x58
{
   19642:	b085      	sub	sp, #20
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   19644:	bf58      	it	pl
   19646:	f084 0402 	eorpl.w	r4, r4, #2
{
   1964a:	4688      	mov	r8, r1
   1964c:	4691      	mov	r9, r2
	}

	/* Register the callback before sending in order to receive the response
	 * from the peer.
	 */
	status = net_context_recv(ctx, zsock_received_cb,
   1964e:	6803      	ldr	r3, [r0, #0]
   19650:	f04f 0200 	mov.w	r2, #0
   19654:	4919      	ldr	r1, [pc, #100]	; (196bc <zsock_sendto_ctx+0x84>)
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   19656:	bf54      	ite	pl
   19658:	f344 0440 	sbfxpl	r4, r4, #1, #1
		timeout = K_NO_WAIT;
   1965c:	2400      	movmi	r4, #0
{
   1965e:	4605      	mov	r5, r0
   19660:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	status = net_context_recv(ctx, zsock_received_cb,
   19662:	f003 fd35 	bl	1d0d0 <net_context_recv>
				  K_NO_WAIT, ctx->user_data);
	if (status < 0) {
   19666:	1e07      	subs	r7, r0, #0
   19668:	da09      	bge.n	1967e <zsock_sendto_ctx+0x46>
		errno = -status;
   1966a:	f01b ff3d 	bl	354e8 <__errno>
   1966e:	427f      	negs	r7, r7
   19670:	6007      	str	r7, [r0, #0]
					  ctx->user_data);
	}

	if (status < 0) {
		errno = -status;
		return -1;
   19672:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	}

	return status;
}
   19676:	4620      	mov	r0, r4
   19678:	b005      	add	sp, #20
   1967a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (dest_addr) {
   1967e:	682b      	ldr	r3, [r5, #0]
   19680:	b19e      	cbz	r6, 196aa <zsock_sendto_ctx+0x72>
		status = net_context_sendto(ctx, buf, len, dest_addr,
   19682:	e9cd 4302 	strd	r4, r3, [sp, #8]
   19686:	2300      	movs	r3, #0
   19688:	9301      	str	r3, [sp, #4]
   1968a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   1968c:	464a      	mov	r2, r9
   1968e:	9300      	str	r3, [sp, #0]
   19690:	4641      	mov	r1, r8
   19692:	4633      	mov	r3, r6
   19694:	4628      	mov	r0, r5
   19696:	f01c fa19 	bl	35acc <net_context_sendto>
	if (status < 0) {
   1969a:	2800      	cmp	r0, #0
		status = net_context_send(ctx, buf, len, NULL, timeout,
   1969c:	4604      	mov	r4, r0
	if (status < 0) {
   1969e:	daea      	bge.n	19676 <zsock_sendto_ctx+0x3e>
		errno = -status;
   196a0:	f01b ff22 	bl	354e8 <__errno>
   196a4:	4264      	negs	r4, r4
   196a6:	6004      	str	r4, [r0, #0]
   196a8:	e7e3      	b.n	19672 <zsock_sendto_ctx+0x3a>
		status = net_context_send(ctx, buf, len, NULL, timeout,
   196aa:	e9cd 4300 	strd	r4, r3, [sp]
   196ae:	464a      	mov	r2, r9
   196b0:	4633      	mov	r3, r6
   196b2:	4641      	mov	r1, r8
   196b4:	4628      	mov	r0, r5
   196b6:	f01c f9bc 	bl	35a32 <net_context_send>
   196ba:	e7ee      	b.n	1969a <zsock_sendto_ctx+0x62>
   196bc:	00033d53 	.word	0x00033d53

000196c0 <zsock_recvfrom_ctx>:
}

ssize_t zsock_recvfrom_ctx(struct net_context *ctx, void *buf, size_t max_len,
			   int flags,
			   struct sockaddr *src_addr, socklen_t *addrlen)
{
   196c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   196c4:	b08d      	sub	sp, #52	; 0x34
   196c6:	461d      	mov	r5, r3
   196c8:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58
   196cc:	4680      	mov	r8, r0
   196ce:	9102      	str	r1, [sp, #8]
   196d0:	9200      	str	r2, [sp, #0]
	enum net_sock_type sock_type = net_context_get_type(ctx);
   196d2:	f7ff fe25 	bl	19320 <net_context_get_type>

	if (max_len == 0) {
   196d6:	9b00      	ldr	r3, [sp, #0]
   196d8:	b90b      	cbnz	r3, 196de <zsock_recvfrom_ctx+0x1e>
	if (sock_type == SOCK_DGRAM) {
		return zsock_recv_dgram(ctx, buf, max_len, flags, src_addr, addrlen);
	} else if (sock_type == SOCK_STREAM) {
		return zsock_recv_stream(ctx, buf, max_len, flags);
	} else {
		__ASSERT(0, "Unknown socket type");
   196da:	2400      	movs	r4, #0
   196dc:	e0bf      	b.n	1985e <zsock_recvfrom_ctx+0x19e>
	if (sock_type == SOCK_DGRAM) {
   196de:	2802      	cmp	r0, #2
   196e0:	f040 80c6 	bne.w	19870 <zsock_recvfrom_ctx+0x1b0>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   196e4:	066b      	lsls	r3, r5, #25
   196e6:	bf57      	itett	pl
   196e8:	f8d8 1058 	ldrpl.w	r1, [r8, #88]	; 0x58
		timeout = K_NO_WAIT;
   196ec:	2100      	movmi	r1, #0
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   196ee:	f081 0102 	eorpl.w	r1, r1, #2
   196f2:	f341 0140 	sbfxpl	r1, r1, #1, #1
	if (flags & ZSOCK_MSG_PEEK) {
   196f6:	f015 0502 	ands.w	r5, r5, #2
   196fa:	f108 005c 	add.w	r0, r8, #92	; 0x5c
   196fe:	d01c      	beq.n	1973a <zsock_recvfrom_ctx+0x7a>
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   19700:	f01a fb12 	bl	33d28 <k_fifo_wait_non_empty>
		if (res && res != -EAGAIN && res != -EINTR) {
   19704:	f100 030b 	add.w	r3, r0, #11
   19708:	2b0b      	cmp	r3, #11
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   1970a:	4604      	mov	r4, r0
		if (res && res != -EAGAIN && res != -EINTR) {
   1970c:	d806      	bhi.n	1971c <zsock_recvfrom_ctx+0x5c>
   1970e:	f640 0181 	movw	r1, #2177	; 0x881
   19712:	40d9      	lsrs	r1, r3
   19714:	43c9      	mvns	r1, r1
   19716:	f011 0101 	ands.w	r1, r1, #1
   1971a:	d004      	beq.n	19726 <zsock_recvfrom_ctx+0x66>
			errno = -res;
   1971c:	f01b fee4 	bl	354e8 <__errno>
   19720:	4264      	negs	r4, r4
   19722:	6004      	str	r4, [r0, #0]
			return -1;
   19724:	e033      	b.n	1978e <zsock_recvfrom_ctx+0xce>
	return z_queue_node_peek(sys_sflist_peek_head(&queue->data_q), false);
   19726:	f8d8 005c 	ldr.w	r0, [r8, #92]	; 0x5c
   1972a:	f01f faa2 	bl	38c72 <z_queue_node_peek>
   1972e:	4604      	mov	r4, r0
	if (!pkt) {
   19730:	b930      	cbnz	r0, 19740 <zsock_recvfrom_ctx+0x80>
				errno = EAGAIN;
   19732:	f01b fed9 	bl	354e8 <__errno>
   19736:	230b      	movs	r3, #11
   19738:	e0b6      	b.n	198a8 <zsock_recvfrom_ctx+0x1e8>
   1973a:	f013 f9d1 	bl	2cae0 <z_impl_k_queue_get>
   1973e:	e7f6      	b.n	1972e <zsock_recvfrom_ctx+0x6e>
 */
static inline void net_pkt_cursor_backup(struct net_pkt *pkt,
					 struct net_pkt_cursor *backup)
{
	backup->buf = pkt->cursor.buf;
	backup->pos = pkt->cursor.pos;
   19740:	e9d0 a305 	ldrd	sl, r3, [r0, #20]
   19744:	9301      	str	r3, [sp, #4]
	if (src_addr && addrlen) {
   19746:	2e00      	cmp	r6, #0
   19748:	d06a      	beq.n	19820 <zsock_recvfrom_ctx+0x160>
   1974a:	2f00      	cmp	r7, #0
   1974c:	d068      	beq.n	19820 <zsock_recvfrom_ctx+0x160>
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
   1974e:	f8b8 3078 	ldrh.w	r3, [r8, #120]	; 0x78
   19752:	f8d7 8000 	ldr.w	r8, [r7]
   19756:	9303      	str	r3, [sp, #12]
	net_pkt_cursor_init(pkt);
   19758:	f01c fb22 	bl	35da0 <net_pkt_cursor_init>
	return pkt->family;
   1975c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   19760:	f3c3 0342 	ubfx	r3, r3, #1, #3
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   19764:	2b01      	cmp	r3, #1
	addr->sa_family = net_pkt_family(pkt);
   19766:	8033      	strh	r3, [r6, #0]
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   19768:	d014      	beq.n	19794 <zsock_recvfrom_ctx+0xd4>
		ret = -ENOTSUP;
   1976a:	f06f 0985 	mvn.w	r9, #133	; 0x85
 */
static inline void net_pkt_cursor_restore(struct net_pkt *pkt,
					  struct net_pkt_cursor *backup)
{
	pkt->cursor.buf = backup->buf;
	pkt->cursor.pos = backup->pos;
   1976e:	9b01      	ldr	r3, [sp, #4]
	pkt->cursor.buf = backup->buf;
   19770:	f8c4 a014 	str.w	sl, [r4, #20]
	pkt->cursor.pos = backup->pos;
   19774:	61a3      	str	r3, [r4, #24]
		if (rv < 0) {
   19776:	f1b9 0f00 	cmp.w	r9, #0
   1977a:	d04c      	beq.n	19816 <zsock_recvfrom_ctx+0x156>
			errno = -rv;
   1977c:	f01b feb4 	bl	354e8 <__errno>
   19780:	f1c9 0300 	rsb	r3, r9, #0
		errno = ENOBUFS;
   19784:	6003      	str	r3, [r0, #0]
	if (!(flags & ZSOCK_MSG_PEEK)) {
   19786:	b915      	cbnz	r5, 1978e <zsock_recvfrom_ctx+0xce>
		net_pkt_unref(pkt);
   19788:	4620      	mov	r0, r4
   1978a:	f01c faa5 	bl	35cd8 <net_pkt_unref>
	return -1;
   1978e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   19792:	e064      	b.n	1985e <zsock_recvfrom_ctx+0x19e>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
   19794:	f04f 0c00 	mov.w	ip, #0
   19798:	2314      	movs	r3, #20
		if (addrlen < sizeof(struct sockaddr_in)) {
   1979a:	f1b8 0f07 	cmp.w	r8, #7
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access,
   1979e:	e9cd c307 	strd	ip, r3, [sp, #28]
		if (addrlen < sizeof(struct sockaddr_in)) {
   197a2:	d92c      	bls.n	197fe <zsock_recvfrom_ctx+0x13e>
		ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(
   197a4:	f10d 081c 	add.w	r8, sp, #28
   197a8:	4641      	mov	r1, r8
   197aa:	4620      	mov	r0, r4
   197ac:	f01c fcd6 	bl	3615c <net_pkt_get_data>
		if (!ipv4_hdr ||
   197b0:	4683      	mov	fp, r0
   197b2:	b910      	cbnz	r0, 197ba <zsock_recvfrom_ctx+0xfa>
			ret = -ENOBUFS;
   197b4:	f06f 0968 	mvn.w	r9, #104	; 0x68
   197b8:	e7d9      	b.n	1976e <zsock_recvfrom_ctx+0xae>
 * Packet needs to be set to overwrite mode.
 */
static inline int net_pkt_acknowledge_data(struct net_pkt *pkt,
					   struct net_pkt_data_access *access)
{
	return net_pkt_skip(pkt, access->size);
   197ba:	9908      	ldr	r1, [sp, #32]
   197bc:	4620      	mov	r0, r4
   197be:	f01c fb79 	bl	35eb4 <net_pkt_skip>
		if (!ipv4_hdr ||
   197c2:	2800      	cmp	r0, #0
   197c4:	d1f6      	bne.n	197b4 <zsock_recvfrom_ctx+0xf4>
		    net_pkt_skip(pkt, net_pkt_ipv4_opts_len(pkt))) {
   197c6:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
   197ca:	4620      	mov	r0, r4
   197cc:	f01c fb72 	bl	35eb4 <net_pkt_skip>
		    net_pkt_acknowledge_data(pkt, &ipv4_access) ||
   197d0:	4681      	mov	r9, r0
   197d2:	2800      	cmp	r0, #0
   197d4:	d1ee      	bne.n	197b4 <zsock_recvfrom_ctx+0xf4>
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
   197d6:	f8db 100c 	ldr.w	r1, [fp, #12]
		rv = sock_get_pkt_src_addr(pkt, net_context_get_ip_proto(ctx),
   197da:	f89d 200c 	ldrb.w	r2, [sp, #12]
		net_ipaddr_copy(&addr4->sin_addr, &ipv4_hdr->src);
   197de:	6071      	str	r1, [r6, #4]
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   197e0:	2a11      	cmp	r2, #17
   197e2:	d10f      	bne.n	19804 <zsock_recvfrom_ctx+0x144>
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   197e4:	aa05      	add	r2, sp, #20
   197e6:	9207      	str	r2, [sp, #28]
   197e8:	2208      	movs	r2, #8
		udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt,
   197ea:	4641      	mov	r1, r8
		NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   197ec:	9208      	str	r2, [sp, #32]
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
   197ee:	4620      	mov	r0, r4
   197f0:	f01c fcb4 	bl	3615c <net_pkt_get_data>
		if (!tcp_hdr) {
   197f4:	2800      	cmp	r0, #0
   197f6:	d0dd      	beq.n	197b4 <zsock_recvfrom_ctx+0xf4>
		*port = tcp_hdr->src_port;
   197f8:	8802      	ldrh	r2, [r0, #0]
   197fa:	8072      	strh	r2, [r6, #2]
   197fc:	e7b7      	b.n	1976e <zsock_recvfrom_ctx+0xae>
			ret = -EINVAL;
   197fe:	f06f 0915 	mvn.w	r9, #21
   19802:	e7b4      	b.n	1976e <zsock_recvfrom_ctx+0xae>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
   19804:	2a06      	cmp	r2, #6
   19806:	d1b0      	bne.n	1976a <zsock_recvfrom_ctx+0xaa>
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   19808:	2214      	movs	r2, #20
   1980a:	f8cd 8014 	str.w	r8, [sp, #20]
   1980e:	9206      	str	r2, [sp, #24]
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
   19810:	eb0d 0102 	add.w	r1, sp, r2
   19814:	e7eb      	b.n	197ee <zsock_recvfrom_ctx+0x12e>
		if (src_addr->sa_family == AF_INET) {
   19816:	8833      	ldrh	r3, [r6, #0]
   19818:	2b01      	cmp	r3, #1
   1981a:	d113      	bne.n	19844 <zsock_recvfrom_ctx+0x184>
			*addrlen = sizeof(struct sockaddr_in);
   1981c:	2308      	movs	r3, #8
			*addrlen = sizeof(struct sockaddr_in6);
   1981e:	603b      	str	r3, [r7, #0]
	recv_len = net_pkt_remaining_data(pkt);
   19820:	4620      	mov	r0, r4
   19822:	f01c fbc1 	bl	35fa8 <net_pkt_remaining_data>
	if (recv_len > max_len) {
   19826:	9b00      	ldr	r3, [sp, #0]
	if (net_pkt_read(pkt, buf, recv_len)) {
   19828:	9902      	ldr	r1, [sp, #8]
   1982a:	4283      	cmp	r3, r0
   1982c:	bf28      	it	cs
   1982e:	4603      	movcs	r3, r0
   19830:	4620      	mov	r0, r4
   19832:	461a      	mov	r2, r3
   19834:	461e      	mov	r6, r3
   19836:	f01c fb53 	bl	35ee0 <net_pkt_read>
   1983a:	b158      	cbz	r0, 19854 <zsock_recvfrom_ctx+0x194>
		errno = ENOBUFS;
   1983c:	f01b fe54 	bl	354e8 <__errno>
   19840:	2369      	movs	r3, #105	; 0x69
   19842:	e79f      	b.n	19784 <zsock_recvfrom_ctx+0xc4>
		} else if (src_addr->sa_family == AF_INET6) {
   19844:	2b02      	cmp	r3, #2
   19846:	d101      	bne.n	1984c <zsock_recvfrom_ctx+0x18c>
			*addrlen = sizeof(struct sockaddr_in6);
   19848:	2318      	movs	r3, #24
   1984a:	e7e8      	b.n	1981e <zsock_recvfrom_ctx+0x15e>
			errno = ENOTSUP;
   1984c:	f01b fe4c 	bl	354e8 <__errno>
   19850:	2386      	movs	r3, #134	; 0x86
   19852:	e797      	b.n	19784 <zsock_recvfrom_ctx+0xc4>
	if (!(flags & ZSOCK_MSG_PEEK)) {
   19854:	b93d      	cbnz	r5, 19866 <zsock_recvfrom_ctx+0x1a6>
		net_pkt_unref(pkt);
   19856:	4620      	mov	r0, r4
   19858:	f01c fa3e 	bl	35cd8 <net_pkt_unref>
	return recv_len;
   1985c:	4634      	mov	r4, r6
	}

	return 0;
}
   1985e:	4620      	mov	r0, r4
   19860:	b00d      	add	sp, #52	; 0x34
   19862:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	pkt->cursor.pos = backup->pos;
   19866:	9b01      	ldr	r3, [sp, #4]
	pkt->cursor.buf = backup->buf;
   19868:	f8c4 a014 	str.w	sl, [r4, #20]
	pkt->cursor.pos = backup->pos;
   1986c:	61a3      	str	r3, [r4, #24]
   1986e:	e7f5      	b.n	1985c <zsock_recvfrom_ctx+0x19c>
	} else if (sock_type == SOCK_STREAM) {
   19870:	2801      	cmp	r0, #1
   19872:	f040 8087 	bne.w	19984 <zsock_recvfrom_ctx+0x2c4>
	NET_ASSERT(context);
   19876:	f1b8 0f00 	cmp.w	r8, #0
   1987a:	d10e      	bne.n	1989a <zsock_recvfrom_ctx+0x1da>
   1987c:	4949      	ldr	r1, [pc, #292]	; (199a4 <zsock_recvfrom_ctx+0x2e4>)
   1987e:	f44f 73a9 	mov.w	r3, #338	; 0x152
   19882:	4a49      	ldr	r2, [pc, #292]	; (199a8 <zsock_recvfrom_ctx+0x2e8>)
   19884:	4849      	ldr	r0, [pc, #292]	; (199ac <zsock_recvfrom_ctx+0x2ec>)
   19886:	f019 fe9f 	bl	335c8 <printk>
   1988a:	4849      	ldr	r0, [pc, #292]	; (199b0 <zsock_recvfrom_ctx+0x2f0>)
   1988c:	f019 fe9c 	bl	335c8 <printk>
   19890:	f44f 71a9 	mov.w	r1, #338	; 0x152
   19894:	4844      	ldr	r0, [pc, #272]	; (199a8 <zsock_recvfrom_ctx+0x2e8>)
   19896:	f01a f998 	bl	33bca <assert_post_action>
	if (!net_context_is_used(ctx)) {
   1989a:	f8b8 307a 	ldrh.w	r3, [r8, #122]	; 0x7a
   1989e:	07dc      	lsls	r4, r3, #31
   198a0:	d404      	bmi.n	198ac <zsock_recvfrom_ctx+0x1ec>
		errno = EBADF;
   198a2:	f01b fe21 	bl	354e8 <__errno>
   198a6:	2309      	movs	r3, #9
			errno = ENOBUFS;
   198a8:	6003      	str	r3, [r0, #0]
			return -1;
   198aa:	e770      	b.n	1978e <zsock_recvfrom_ctx+0xce>
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   198ac:	0668      	lsls	r0, r5, #25
}

static inline uintptr_t sock_get_flag(struct net_context *ctx, uintptr_t mask)
{
	return POINTER_TO_UINT(ctx->socket_data) & mask;
   198ae:	f8d8 7058 	ldr.w	r7, [r8, #88]	; 0x58
		timeout = K_NO_WAIT;
   198b2:	bf4e      	itee	mi
   198b4:	2700      	movmi	r7, #0
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   198b6:	f087 0702 	eorpl.w	r7, r7, #2
   198ba:	f347 0740 	sbfxpl	r7, r7, #1, #1
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   198be:	f108 0a5c 	add.w	sl, r8, #92	; 0x5c
   198c2:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
		if (sock_is_eof(ctx)) {
   198c6:	07d9      	lsls	r1, r3, #31
   198c8:	f53f af07 	bmi.w	196da <zsock_recvfrom_ctx+0x1a>
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   198cc:	4639      	mov	r1, r7
   198ce:	4650      	mov	r0, sl
   198d0:	f01a fa2a 	bl	33d28 <k_fifo_wait_non_empty>
		if (res && res != -EAGAIN && res != -EINTR) {
   198d4:	f100 010b 	add.w	r1, r0, #11
   198d8:	290b      	cmp	r1, #11
		res = k_fifo_wait_non_empty(&ctx->recv_q, timeout);
   198da:	4604      	mov	r4, r0
		if (res && res != -EAGAIN && res != -EINTR) {
   198dc:	f63f af1e 	bhi.w	1971c <zsock_recvfrom_ctx+0x5c>
   198e0:	f640 0381 	movw	r3, #2177	; 0x881
   198e4:	fa23 f101 	lsr.w	r1, r3, r1
   198e8:	43c9      	mvns	r1, r1
   198ea:	f011 0101 	ands.w	r1, r1, #1
   198ee:	f47f af15 	bne.w	1971c <zsock_recvfrom_ctx+0x5c>
   198f2:	f8d8 005c 	ldr.w	r0, [r8, #92]	; 0x5c
   198f6:	f01f f9bc 	bl	38c72 <z_queue_node_peek>
		if (!pkt) {
   198fa:	4606      	mov	r6, r0
   198fc:	b928      	cbnz	r0, 1990a <zsock_recvfrom_ctx+0x24a>
   198fe:	f8d8 3058 	ldr.w	r3, [r8, #88]	; 0x58
			if (sock_is_eof(ctx)) {
   19902:	07da      	lsls	r2, r3, #31
   19904:	f53f aee9 	bmi.w	196da <zsock_recvfrom_ctx+0x1a>
   19908:	e713      	b.n	19732 <zsock_recvfrom_ctx+0x72>
	backup->buf = pkt->cursor.buf;
   1990a:	6943      	ldr	r3, [r0, #20]
   1990c:	9303      	str	r3, [sp, #12]
	backup->pos = pkt->cursor.pos;
   1990e:	6983      	ldr	r3, [r0, #24]
   19910:	9301      	str	r3, [sp, #4]
		data_len = net_pkt_remaining_data(pkt);
   19912:	f01c fb49 	bl	35fa8 <net_pkt_remaining_data>
   19916:	9b00      	ldr	r3, [sp, #0]
   19918:	4683      	mov	fp, r0
		if (recv_len > max_len) {
   1991a:	4283      	cmp	r3, r0
   1991c:	bf28      	it	cs
   1991e:	4603      	movcs	r3, r0
		if (net_pkt_read(pkt, buf, recv_len)) {
   19920:	9902      	ldr	r1, [sp, #8]
   19922:	461a      	mov	r2, r3
   19924:	4630      	mov	r0, r6
   19926:	461c      	mov	r4, r3
   19928:	f01c fada 	bl	35ee0 <net_pkt_read>
   1992c:	9b03      	ldr	r3, [sp, #12]
   1992e:	b118      	cbz	r0, 19938 <zsock_recvfrom_ctx+0x278>
			errno = ENOBUFS;
   19930:	f01b fdda 	bl	354e8 <__errno>
   19934:	2369      	movs	r3, #105	; 0x69
   19936:	e7b7      	b.n	198a8 <zsock_recvfrom_ctx+0x1e8>
		if (!(flags & ZSOCK_MSG_PEEK)) {
   19938:	f015 0902 	ands.w	r9, r5, #2
   1993c:	d11e      	bne.n	1997c <zsock_recvfrom_ctx+0x2bc>
			if (recv_len == data_len) {
   1993e:	9b00      	ldr	r3, [sp, #0]
   19940:	455b      	cmp	r3, fp
   19942:	d310      	bcc.n	19966 <zsock_recvfrom_ctx+0x2a6>
   19944:	4649      	mov	r1, r9
   19946:	4650      	mov	r0, sl
   19948:	f013 f8ca 	bl	2cae0 <z_impl_k_queue_get>
	return pkt->sent_or_eof;
   1994c:	f896 303d 	ldrb.w	r3, [r6, #61]	; 0x3d
				net_pkt_unref(pkt);
   19950:	4630      	mov	r0, r6
				if (net_pkt_eof(pkt)) {
   19952:	079b      	lsls	r3, r3, #30
	val = (val & ~mask) | flag;
   19954:	bf42      	ittt	mi
   19956:	f8d8 3058 	ldrmi.w	r3, [r8, #88]	; 0x58
   1995a:	f043 0301 	orrmi.w	r3, r3, #1
	(ctx)->socket_data = UINT_TO_POINTER(val);
   1995e:	f8c8 3058 	strmi.w	r3, [r8, #88]	; 0x58
				net_pkt_unref(pkt);
   19962:	f01c f9b9 	bl	35cd8 <net_pkt_unref>
	} while (recv_len == 0);
   19966:	2c00      	cmp	r4, #0
   19968:	d0ab      	beq.n	198c2 <zsock_recvfrom_ctx+0x202>
	if (!(flags & ZSOCK_MSG_PEEK)) {
   1996a:	f1b9 0f00 	cmp.w	r9, #0
   1996e:	f47f af76 	bne.w	1985e <zsock_recvfrom_ctx+0x19e>
		net_context_update_recv_wnd(ctx, recv_len);
   19972:	4621      	mov	r1, r4
   19974:	4640      	mov	r0, r8
   19976:	f01c f8ca 	bl	35b0e <net_context_update_recv_wnd>
	return recv_len;
   1997a:	e770      	b.n	1985e <zsock_recvfrom_ctx+0x19e>
	pkt->cursor.buf = backup->buf;
   1997c:	6173      	str	r3, [r6, #20]
	pkt->cursor.pos = backup->pos;
   1997e:	9b01      	ldr	r3, [sp, #4]
   19980:	61b3      	str	r3, [r6, #24]
   19982:	e7f0      	b.n	19966 <zsock_recvfrom_ctx+0x2a6>
		__ASSERT(0, "Unknown socket type");
   19984:	f240 339f 	movw	r3, #927	; 0x39f
   19988:	4a0a      	ldr	r2, [pc, #40]	; (199b4 <zsock_recvfrom_ctx+0x2f4>)
   1998a:	490b      	ldr	r1, [pc, #44]	; (199b8 <zsock_recvfrom_ctx+0x2f8>)
   1998c:	4807      	ldr	r0, [pc, #28]	; (199ac <zsock_recvfrom_ctx+0x2ec>)
   1998e:	f019 fe1b 	bl	335c8 <printk>
   19992:	480a      	ldr	r0, [pc, #40]	; (199bc <zsock_recvfrom_ctx+0x2fc>)
   19994:	f019 fe18 	bl	335c8 <printk>
   19998:	f240 319f 	movw	r1, #927	; 0x39f
   1999c:	4805      	ldr	r0, [pc, #20]	; (199b4 <zsock_recvfrom_ctx+0x2f4>)
   1999e:	f01a f914 	bl	33bca <assert_post_action>
   199a2:	e69a      	b.n	196da <zsock_recvfrom_ctx+0x1a>
   199a4:	0003cb83 	.word	0x0003cb83
   199a8:	0003cb56 	.word	0x0003cb56
   199ac:	0003b77f 	.word	0x0003b77f
   199b0:	0003cb8b 	.word	0x0003cb8b
   199b4:	0003cb8e 	.word	0x0003cb8e
   199b8:	0003fd3b 	.word	0x0003fd3b
   199bc:	0003cc28 	.word	0x0003cc28

000199c0 <z_impl_zsock_poll>:

	return timeout - elapsed;
}

int z_impl_zsock_poll(struct zsock_pollfd *fds, int nfds, int poll_timeout)
{
   199c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   199c4:	4683      	mov	fp, r0
   199c6:	4688      	mov	r8, r1
   199c8:	ea42 79e2 	orr.w	r9, r2, r2, asr #31
   199cc:	b09b      	sub	sp, #108	; 0x6c
		poll_timeout = SYS_FOREVER_MS;
	} else {
		timeout = K_MSEC(poll_timeout);
	}

	end = z_timeout_end_calc(timeout);
   199ce:	4648      	mov	r0, r9
   199d0:	f01f fa36 	bl	38e40 <z_timeout_end_calc>

	pev = poll_events;
	for (pfd = fds, i = nfds; i--; pfd++) {
   199d4:	4646      	mov	r6, r8
   199d6:	464c      	mov	r4, r9
   199d8:	465f      	mov	r7, fp
	end = z_timeout_end_calc(timeout);
   199da:	e9cd 0106 	strd	r0, r1, [sp, #24]
	pev = poll_events;
   199de:	ad0b      	add	r5, sp, #44	; 0x2c
   199e0:	9509      	str	r5, [sp, #36]	; 0x24
	for (pfd = fds, i = nfds; i--; pfd++) {
   199e2:	b9ee      	cbnz	r6, 19a20 <z_impl_zsock_poll+0x60>
			errno = -result;
			return -1;
		}
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   199e4:	1c63      	adds	r3, r4, #1
   199e6:	2b01      	cmp	r3, #1
   199e8:	d94f      	bls.n	19a8a <z_impl_zsock_poll+0xca>
	    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
		s64_t remaining = end - z_tick_get();
   199ea:	f015 f987 	bl	2ecfc <z_tick_get>
   199ee:	9b06      	ldr	r3, [sp, #24]
   199f0:	1a1b      	subs	r3, r3, r0
   199f2:	9302      	str	r3, [sp, #8]
   199f4:	9b07      	ldr	r3, [sp, #28]
   199f6:	eb63 0301 	sbc.w	r3, r3, r1
   199fa:	9303      	str	r3, [sp, #12]

		if (remaining <= 0) {
   199fc:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   19a00:	2b01      	cmp	r3, #1
   19a02:	f174 0300 	sbcs.w	r3, r4, #0
   19a06:	db3f      	blt.n	19a88 <z_impl_zsock_poll+0xc8>
			return (u32_t)((t * to_hz + off) / from_hz);
   19a08:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   19a0c:	f647 72ff 	movw	r2, #32767	; 0x7fff
   19a10:	2300      	movs	r3, #0
   19a12:	9802      	ldr	r0, [sp, #8]
   19a14:	fbe1 2300 	umlal	r2, r3, r1, r0
   19a18:	0bd4      	lsrs	r4, r2, #15
   19a1a:	ea44 4443 	orr.w	r4, r4, r3, lsl #17
   19a1e:	e034      	b.n	19a8a <z_impl_zsock_poll+0xca>
		if (pfd->fd < 0) {
   19a20:	6838      	ldr	r0, [r7, #0]
   19a22:	2800      	cmp	r0, #0
   19a24:	db2d      	blt.n	19a82 <z_impl_zsock_poll+0xc2>
		ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
   19a26:	a90a      	add	r1, sp, #40	; 0x28
   19a28:	f7fe ff54 	bl	188d4 <z_get_fd_obj_and_vtable>
		if (ctx == NULL) {
   19a2c:	4682      	mov	sl, r0
   19a2e:	b340      	cbz	r0, 19a82 <z_impl_zsock_poll+0xc2>
		result = z_fdtable_call_ioctl(vtable, ctx,
   19a30:	ab1a      	add	r3, sp, #104	; 0x68
   19a32:	9301      	str	r3, [sp, #4]
   19a34:	ab09      	add	r3, sp, #36	; 0x24
   19a36:	9300      	str	r3, [sp, #0]
   19a38:	4601      	mov	r1, r0
   19a3a:	463b      	mov	r3, r7
   19a3c:	f240 1203 	movw	r2, #259	; 0x103
   19a40:	980a      	ldr	r0, [sp, #40]	; 0x28
   19a42:	f01a f95a 	bl	33cfa <z_fdtable_call_ioctl>
		if (result == -EALREADY) {
   19a46:	f110 0f78 	cmn.w	r0, #120	; 0x78
		result = z_fdtable_call_ioctl(vtable, ctx,
   19a4a:	4603      	mov	r3, r0
		if (result == -EALREADY) {
   19a4c:	d018      	beq.n	19a80 <z_impl_zsock_poll+0xc0>
		} else if (result == -EXDEV) {
   19a4e:	f110 0f12 	cmn.w	r0, #18
   19a52:	d10d      	bne.n	19a70 <z_impl_zsock_poll+0xb0>
			return z_fdtable_call_ioctl(vtable, ctx,
   19a54:	e9cd 8900 	strd	r8, r9, [sp]
   19a58:	465b      	mov	r3, fp
   19a5a:	f240 1205 	movw	r2, #261	; 0x105
   19a5e:	4651      	mov	r1, sl
   19a60:	980a      	ldr	r0, [sp, #40]	; 0x28
   19a62:	f01a f94a 	bl	33cfa <z_fdtable_call_ioctl>
   19a66:	4606      	mov	r6, r0
			}
		}
	} while (retry);

	return ret;
}
   19a68:	4630      	mov	r0, r6
   19a6a:	b01b      	add	sp, #108	; 0x6c
   19a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (result != 0) {
   19a70:	b138      	cbz	r0, 19a82 <z_impl_zsock_poll+0xc2>
   19a72:	9302      	str	r3, [sp, #8]
				errno = -result;
   19a74:	f01b fd38 	bl	354e8 <__errno>
   19a78:	9b02      	ldr	r3, [sp, #8]
   19a7a:	425b      	negs	r3, r3
   19a7c:	6003      	str	r3, [r0, #0]
				return -1;
   19a7e:	e01d      	b.n	19abc <z_impl_zsock_poll+0xfc>
			timeout = K_NO_WAIT;
   19a80:	2400      	movs	r4, #0
	for (pfd = fds, i = nfds; i--; pfd++) {
   19a82:	3708      	adds	r7, #8
   19a84:	3e01      	subs	r6, #1
   19a86:	e7ac      	b.n	199e2 <z_impl_zsock_poll+0x22>
			timeout = K_NO_WAIT;
   19a88:	4634      	mov	r4, r6
		ret = k_poll(poll_events, pev - poll_events, timeout);
   19a8a:	9909      	ldr	r1, [sp, #36]	; 0x24
   19a8c:	4b35      	ldr	r3, [pc, #212]	; (19b64 <z_impl_zsock_poll+0x1a4>)
   19a8e:	1b49      	subs	r1, r1, r5
   19a90:	1089      	asrs	r1, r1, #2
   19a92:	4359      	muls	r1, r3
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&events, *(uintptr_t *)&num_events, *(uintptr_t *)&timeout, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
   19a94:	4622      	mov	r2, r4
   19a96:	4628      	mov	r0, r5
   19a98:	f015 fbbc 	bl	2f214 <z_impl_k_poll>
		if (ret != 0 && ret != -EAGAIN && ret != -EINTR) {
   19a9c:	f100 030b 	add.w	r3, r0, #11
   19aa0:	2b0b      	cmp	r3, #11
   19aa2:	4606      	mov	r6, r0
   19aa4:	d806      	bhi.n	19ab4 <z_impl_zsock_poll+0xf4>
   19aa6:	f640 0781 	movw	r7, #2177	; 0x881
   19aaa:	40df      	lsrs	r7, r3
   19aac:	43ff      	mvns	r7, r7
   19aae:	f017 0701 	ands.w	r7, r7, #1
   19ab2:	d006      	beq.n	19ac2 <z_impl_zsock_poll+0x102>
			errno = -ret;
   19ab4:	f01b fd18 	bl	354e8 <__errno>
   19ab8:	4276      	negs	r6, r6
   19aba:	6006      	str	r6, [r0, #0]
			return -1;
   19abc:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   19ac0:	e7d2      	b.n	19a68 <z_impl_zsock_poll+0xa8>
		for (pfd = fds, i = nfds; i--; pfd++) {
   19ac2:	46c2      	mov	sl, r8
   19ac4:	46d9      	mov	r9, fp
		ret = 0;
   19ac6:	463e      	mov	r6, r7
		pev = poll_events;
   19ac8:	9509      	str	r5, [sp, #36]	; 0x24
		for (pfd = fds, i = nfds; i--; pfd++) {
   19aca:	f1ba 0f00 	cmp.w	sl, #0
   19ace:	d11d      	bne.n	19b0c <z_impl_zsock_poll+0x14c>
		if (retry) {
   19ad0:	2f00      	cmp	r7, #0
   19ad2:	d0c9      	beq.n	19a68 <z_impl_zsock_poll+0xa8>
			if (ret > 0) {
   19ad4:	2e00      	cmp	r6, #0
   19ad6:	dcc7      	bgt.n	19a68 <z_impl_zsock_poll+0xa8>
			if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   19ad8:	2c00      	cmp	r4, #0
   19ada:	d0c5      	beq.n	19a68 <z_impl_zsock_poll+0xa8>
			if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   19adc:	1c63      	adds	r3, r4, #1
   19ade:	d0d4      	beq.n	19a8a <z_impl_zsock_poll+0xca>
				s64_t remaining = end - z_tick_get();
   19ae0:	f015 f90c 	bl	2ecfc <z_tick_get>
   19ae4:	9b06      	ldr	r3, [sp, #24]
   19ae6:	1a1b      	subs	r3, r3, r0
   19ae8:	9304      	str	r3, [sp, #16]
   19aea:	9b07      	ldr	r3, [sp, #28]
   19aec:	eb63 0301 	sbc.w	r3, r3, r1
   19af0:	9305      	str	r3, [sp, #20]
				if (remaining <= 0) {
   19af2:	e9dd 3404 	ldrd	r3, r4, [sp, #16]
   19af6:	2b01      	cmp	r3, #1
   19af8:	f174 0300 	sbcs.w	r3, r4, #0
   19afc:	dbb4      	blt.n	19a68 <z_impl_zsock_poll+0xa8>
   19afe:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   19b02:	f647 72ff 	movw	r2, #32767	; 0x7fff
   19b06:	2300      	movs	r3, #0
   19b08:	9804      	ldr	r0, [sp, #16]
   19b0a:	e783      	b.n	19a14 <z_impl_zsock_poll+0x54>
			pfd->revents = 0;
   19b0c:	f04f 0300 	mov.w	r3, #0
			if (pfd->fd < 0) {
   19b10:	f8d9 0000 	ldr.w	r0, [r9]
			pfd->revents = 0;
   19b14:	f8a9 3006 	strh.w	r3, [r9, #6]
			if (pfd->fd < 0) {
   19b18:	2800      	cmp	r0, #0
   19b1a:	db1b      	blt.n	19b54 <z_impl_zsock_poll+0x194>
			ctx = z_get_fd_obj_and_vtable(pfd->fd, &vtable);
   19b1c:	a90a      	add	r1, sp, #40	; 0x28
   19b1e:	f7fe fed9 	bl	188d4 <z_get_fd_obj_and_vtable>
			if (ctx == NULL) {
   19b22:	4601      	mov	r1, r0
   19b24:	b920      	cbnz	r0, 19b30 <z_impl_zsock_poll+0x170>
				pfd->revents = ZSOCK_POLLNVAL;
   19b26:	2320      	movs	r3, #32
   19b28:	f8a9 3006 	strh.w	r3, [r9, #6]
				ret++;
   19b2c:	3601      	adds	r6, #1
   19b2e:	e011      	b.n	19b54 <z_impl_zsock_poll+0x194>
			result = z_fdtable_call_ioctl(vtable, ctx,
   19b30:	ab09      	add	r3, sp, #36	; 0x24
   19b32:	9300      	str	r3, [sp, #0]
   19b34:	f44f 7282 	mov.w	r2, #260	; 0x104
   19b38:	464b      	mov	r3, r9
   19b3a:	980a      	ldr	r0, [sp, #40]	; 0x28
   19b3c:	f01a f8dd 	bl	33cfa <z_fdtable_call_ioctl>
			if (result == -EAGAIN) {
   19b40:	f110 0f0b 	cmn.w	r0, #11
			result = z_fdtable_call_ioctl(vtable, ctx,
   19b44:	4603      	mov	r3, r0
			if (result == -EAGAIN) {
   19b46:	d00a      	beq.n	19b5e <z_impl_zsock_poll+0x19e>
			} else if (result != 0) {
   19b48:	2800      	cmp	r0, #0
   19b4a:	d192      	bne.n	19a72 <z_impl_zsock_poll+0xb2>
			if (pfd->revents != 0) {
   19b4c:	f9b9 3006 	ldrsh.w	r3, [r9, #6]
   19b50:	2b00      	cmp	r3, #0
   19b52:	d1eb      	bne.n	19b2c <z_impl_zsock_poll+0x16c>
		for (pfd = fds, i = nfds; i--; pfd++) {
   19b54:	f109 0908 	add.w	r9, r9, #8
   19b58:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
   19b5c:	e7b5      	b.n	19aca <z_impl_zsock_poll+0x10a>
				retry = true;
   19b5e:	2701      	movs	r7, #1
   19b60:	e7f8      	b.n	19b54 <z_impl_zsock_poll+0x194>
   19b62:	bf00      	nop
   19b64:	cccccccd 	.word	0xcccccccd

00019b68 <socket_offload_dns_register>:
#include "sockets_internal.h"

const struct socket_dns_offload *dns_offload;

void socket_offload_dns_register(const struct socket_dns_offload *ops)
{
   19b68:	b538      	push	{r3, r4, r5, lr}
	__ASSERT_NO_MSG(ops);
   19b6a:	4605      	mov	r5, r0
   19b6c:	b948      	cbnz	r0, 19b82 <socket_offload_dns_register+0x1a>
   19b6e:	490c      	ldr	r1, [pc, #48]	; (19ba0 <socket_offload_dns_register+0x38>)
   19b70:	480c      	ldr	r0, [pc, #48]	; (19ba4 <socket_offload_dns_register+0x3c>)
   19b72:	2313      	movs	r3, #19
   19b74:	4a0c      	ldr	r2, [pc, #48]	; (19ba8 <socket_offload_dns_register+0x40>)
   19b76:	f019 fd27 	bl	335c8 <printk>
   19b7a:	2113      	movs	r1, #19
   19b7c:	480a      	ldr	r0, [pc, #40]	; (19ba8 <socket_offload_dns_register+0x40>)
   19b7e:	f01a f824 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(dns_offload == NULL);
   19b82:	4c0a      	ldr	r4, [pc, #40]	; (19bac <socket_offload_dns_register+0x44>)
   19b84:	6822      	ldr	r2, [r4, #0]
   19b86:	b14a      	cbz	r2, 19b9c <socket_offload_dns_register+0x34>
   19b88:	4909      	ldr	r1, [pc, #36]	; (19bb0 <socket_offload_dns_register+0x48>)
   19b8a:	4806      	ldr	r0, [pc, #24]	; (19ba4 <socket_offload_dns_register+0x3c>)
   19b8c:	2314      	movs	r3, #20
   19b8e:	4a06      	ldr	r2, [pc, #24]	; (19ba8 <socket_offload_dns_register+0x40>)
   19b90:	f019 fd1a 	bl	335c8 <printk>
   19b94:	2114      	movs	r1, #20
   19b96:	4804      	ldr	r0, [pc, #16]	; (19ba8 <socket_offload_dns_register+0x40>)
   19b98:	f01a f817 	bl	33bca <assert_post_action>

	dns_offload = ops;
   19b9c:	6025      	str	r5, [r4, #0]
}
   19b9e:	bd38      	pop	{r3, r4, r5, pc}
   19ba0:	0003fa58 	.word	0x0003fa58
   19ba4:	0003b77f 	.word	0x0003b77f
   19ba8:	0003cc3e 	.word	0x0003cc3e
   19bac:	2002170c 	.word	0x2002170c
   19bb0:	0003cc79 	.word	0x0003cc79

00019bb4 <socket_offload_getaddrinfo>:

int socket_offload_getaddrinfo(const char *node, const char *service,
			       const struct zsock_addrinfo *hints,
			       struct zsock_addrinfo **res)
{
   19bb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(dns_offload);
   19bb8:	4c13      	ldr	r4, [pc, #76]	; (19c08 <socket_offload_getaddrinfo+0x54>)
{
   19bba:	4698      	mov	r8, r3
	__ASSERT_NO_MSG(dns_offload);
   19bbc:	6823      	ldr	r3, [r4, #0]
{
   19bbe:	4605      	mov	r5, r0
   19bc0:	460e      	mov	r6, r1
   19bc2:	4617      	mov	r7, r2
	__ASSERT_NO_MSG(dns_offload);
   19bc4:	b94b      	cbnz	r3, 19bda <socket_offload_getaddrinfo+0x26>
   19bc6:	4911      	ldr	r1, [pc, #68]	; (19c0c <socket_offload_getaddrinfo+0x58>)
   19bc8:	4811      	ldr	r0, [pc, #68]	; (19c10 <socket_offload_getaddrinfo+0x5c>)
   19bca:	231d      	movs	r3, #29
   19bcc:	4a11      	ldr	r2, [pc, #68]	; (19c14 <socket_offload_getaddrinfo+0x60>)
   19bce:	f019 fcfb 	bl	335c8 <printk>
   19bd2:	211d      	movs	r1, #29
   19bd4:	480f      	ldr	r0, [pc, #60]	; (19c14 <socket_offload_getaddrinfo+0x60>)
   19bd6:	f019 fff8 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(dns_offload->getaddrinfo);
   19bda:	6823      	ldr	r3, [r4, #0]
   19bdc:	681b      	ldr	r3, [r3, #0]
   19bde:	b94b      	cbnz	r3, 19bf4 <socket_offload_getaddrinfo+0x40>
   19be0:	490d      	ldr	r1, [pc, #52]	; (19c18 <socket_offload_getaddrinfo+0x64>)
   19be2:	480b      	ldr	r0, [pc, #44]	; (19c10 <socket_offload_getaddrinfo+0x5c>)
   19be4:	231e      	movs	r3, #30
   19be6:	4a0b      	ldr	r2, [pc, #44]	; (19c14 <socket_offload_getaddrinfo+0x60>)
   19be8:	f019 fcee 	bl	335c8 <printk>
   19bec:	211e      	movs	r1, #30
   19bee:	4809      	ldr	r0, [pc, #36]	; (19c14 <socket_offload_getaddrinfo+0x60>)
   19bf0:	f019 ffeb 	bl	33bca <assert_post_action>

	return dns_offload->getaddrinfo(node, service, hints, res);
   19bf4:	6823      	ldr	r3, [r4, #0]
   19bf6:	463a      	mov	r2, r7
   19bf8:	681c      	ldr	r4, [r3, #0]
   19bfa:	4631      	mov	r1, r6
   19bfc:	4643      	mov	r3, r8
   19bfe:	4628      	mov	r0, r5
   19c00:	46a4      	mov	ip, r4
}
   19c02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return dns_offload->getaddrinfo(node, service, hints, res);
   19c06:	4760      	bx	ip
   19c08:	2002170c 	.word	0x2002170c
   19c0c:	0003ccae 	.word	0x0003ccae
   19c10:	0003b77f 	.word	0x0003b77f
   19c14:	0003cc3e 	.word	0x0003cc3e
   19c18:	0003ccba 	.word	0x0003ccba

00019c1c <socket_offload_freeaddrinfo>:

void socket_offload_freeaddrinfo(struct zsock_addrinfo *res)
{
   19c1c:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(dns_offload);
   19c1e:	4c10      	ldr	r4, [pc, #64]	; (19c60 <socket_offload_freeaddrinfo+0x44>)
{
   19c20:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(dns_offload);
   19c22:	6823      	ldr	r3, [r4, #0]
   19c24:	b94b      	cbnz	r3, 19c3a <socket_offload_freeaddrinfo+0x1e>
   19c26:	490f      	ldr	r1, [pc, #60]	; (19c64 <socket_offload_freeaddrinfo+0x48>)
   19c28:	480f      	ldr	r0, [pc, #60]	; (19c68 <socket_offload_freeaddrinfo+0x4c>)
   19c2a:	2325      	movs	r3, #37	; 0x25
   19c2c:	4a0f      	ldr	r2, [pc, #60]	; (19c6c <socket_offload_freeaddrinfo+0x50>)
   19c2e:	f019 fccb 	bl	335c8 <printk>
   19c32:	2125      	movs	r1, #37	; 0x25
   19c34:	480d      	ldr	r0, [pc, #52]	; (19c6c <socket_offload_freeaddrinfo+0x50>)
   19c36:	f019 ffc8 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(dns_offload->freeaddrinfo);
   19c3a:	6823      	ldr	r3, [r4, #0]
   19c3c:	685b      	ldr	r3, [r3, #4]
   19c3e:	b94b      	cbnz	r3, 19c54 <socket_offload_freeaddrinfo+0x38>
   19c40:	490b      	ldr	r1, [pc, #44]	; (19c70 <socket_offload_freeaddrinfo+0x54>)
   19c42:	4809      	ldr	r0, [pc, #36]	; (19c68 <socket_offload_freeaddrinfo+0x4c>)
   19c44:	2326      	movs	r3, #38	; 0x26
   19c46:	4a09      	ldr	r2, [pc, #36]	; (19c6c <socket_offload_freeaddrinfo+0x50>)
   19c48:	f019 fcbe 	bl	335c8 <printk>
   19c4c:	2126      	movs	r1, #38	; 0x26
   19c4e:	4807      	ldr	r0, [pc, #28]	; (19c6c <socket_offload_freeaddrinfo+0x50>)
   19c50:	f019 ffbb 	bl	33bca <assert_post_action>

	return dns_offload->freeaddrinfo(res);
   19c54:	6823      	ldr	r3, [r4, #0]
   19c56:	4628      	mov	r0, r5
}
   19c58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return dns_offload->freeaddrinfo(res);
   19c5c:	685b      	ldr	r3, [r3, #4]
   19c5e:	4718      	bx	r3
   19c60:	2002170c 	.word	0x2002170c
   19c64:	0003ccae 	.word	0x0003ccae
   19c68:	0003b77f 	.word	0x0003b77f
   19c6c:	0003cc3e 	.word	0x0003cc3e
   19c70:	0003cc94 	.word	0x0003cc94

00019c74 <settings_save_one>:
int settings_save_one(const char *name, const void *value, size_t val_len)
{
	int rc;
	struct settings_store *cs;

	cs = settings_save_dst;
   19c74:	4b0e      	ldr	r3, [pc, #56]	; (19cb0 <settings_save_one+0x3c>)
{
   19c76:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	cs = settings_save_dst;
   19c7a:	681c      	ldr	r4, [r3, #0]
{
   19c7c:	4606      	mov	r6, r0
   19c7e:	460f      	mov	r7, r1
   19c80:	4690      	mov	r8, r2
	if (!cs) {
   19c82:	b194      	cbz	r4, 19caa <settings_save_one+0x36>
	return z_impl_k_mutex_lock(mutex, timeout);
   19c84:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19c88:	480a      	ldr	r0, [pc, #40]	; (19cb4 <settings_save_one+0x40>)
   19c8a:	f012 fcbf 	bl	2c60c <z_impl_k_mutex_lock>
		return -ENOENT;
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	rc = cs->cs_itf->csi_save(cs, name, (char *)value, val_len);
   19c8e:	6863      	ldr	r3, [r4, #4]
   19c90:	463a      	mov	r2, r7
   19c92:	689d      	ldr	r5, [r3, #8]
   19c94:	4631      	mov	r1, r6
   19c96:	4643      	mov	r3, r8
   19c98:	4620      	mov	r0, r4
   19c9a:	47a8      	blx	r5
   19c9c:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
   19c9e:	4805      	ldr	r0, [pc, #20]	; (19cb4 <settings_save_one+0x40>)
   19ca0:	f012 fd92 	bl	2c7c8 <z_impl_k_mutex_unlock>

	k_mutex_unlock(&settings_lock);

	return rc;
}
   19ca4:	4620      	mov	r0, r4
   19ca6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return -ENOENT;
   19caa:	f06f 0401 	mvn.w	r4, #1
   19cae:	e7f9      	b.n	19ca4 <settings_save_one+0x30>
   19cb0:	20021718 	.word	0x20021718
   19cb4:	20020748 	.word	0x20020748

00019cb8 <settings_load_subtree>:
	const struct settings_load_arg arg = {
   19cb8:	2300      	movs	r3, #0
{
   19cba:	b530      	push	{r4, r5, lr}
   19cbc:	b085      	sub	sp, #20
   19cbe:	4605      	mov	r5, r0
	const struct settings_load_arg arg = {
   19cc0:	e9cd 3302 	strd	r3, r3, [sp, #8]
   19cc4:	9001      	str	r0, [sp, #4]
	return z_impl_k_mutex_lock(mutex, timeout);
   19cc6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19cca:	480b      	ldr	r0, [pc, #44]	; (19cf8 <settings_load_subtree+0x40>)
   19ccc:	f012 fc9e 	bl	2c60c <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_load_srcs, cs, cs_next) {
   19cd0:	4b0a      	ldr	r3, [pc, #40]	; (19cfc <settings_load_subtree+0x44>)
   19cd2:	681c      	ldr	r4, [r3, #0]
   19cd4:	b134      	cbz	r4, 19ce4 <settings_load_subtree+0x2c>
		cs->cs_itf->csi_load(cs, &arg);
   19cd6:	6863      	ldr	r3, [r4, #4]
   19cd8:	4620      	mov	r0, r4
   19cda:	681b      	ldr	r3, [r3, #0]
   19cdc:	a901      	add	r1, sp, #4
   19cde:	4798      	blx	r3
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   19ce0:	6824      	ldr	r4, [r4, #0]
	return node->next;
   19ce2:	e7f7      	b.n	19cd4 <settings_load_subtree+0x1c>
	rc = settings_commit_subtree(subtree);
   19ce4:	4628      	mov	r0, r5
   19ce6:	f000 f875 	bl	19dd4 <settings_commit_subtree>
   19cea:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
   19cec:	4802      	ldr	r0, [pc, #8]	; (19cf8 <settings_load_subtree+0x40>)
   19cee:	f012 fd6b 	bl	2c7c8 <z_impl_k_mutex_unlock>
}
   19cf2:	4620      	mov	r0, r4
   19cf4:	b005      	add	sp, #20
   19cf6:	bd30      	pop	{r4, r5, pc}
   19cf8:	20020748 	.word	0x20020748
   19cfc:	20021710 	.word	0x20021710

00019d00 <settings_store_init>:
	list->head = NULL;
   19d00:	2200      	movs	r2, #0
   19d02:	4b02      	ldr	r3, [pc, #8]	; (19d0c <settings_store_init+0xc>)
	list->tail = NULL;
   19d04:	e9c3 2200 	strd	r2, r2, [r3]
}

void settings_store_init(void)
{
	sys_slist_init(&settings_load_srcs);
}
   19d08:	4770      	bx	lr
   19d0a:	bf00      	nop
   19d0c:	20021710 	.word	0x20021710

00019d10 <settings_init>:
	list->head = NULL;
   19d10:	2200      	movs	r2, #0
   19d12:	4b02      	ldr	r3, [pc, #8]	; (19d1c <settings_init+0xc>)
	list->tail = NULL;
   19d14:	e9c3 2200 	strd	r2, r2, [r3]
void settings_init(void)
{
#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	sys_slist_init(&settings_handlers);
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */
	settings_store_init();
   19d18:	f7ff bff2 	b.w	19d00 <settings_store_init>
   19d1c:	2002171c 	.word	0x2002171c

00019d20 <settings_register>:
}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
int settings_register(struct settings_handler *handler)
{
   19d20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19d24:	4d23      	ldr	r5, [pc, #140]	; (19db4 <settings_register+0x94>)
{
   19d26:	4606      	mov	r6, r0
   19d28:	46a8      	mov	r8, r5
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19d2a:	4c23      	ldr	r4, [pc, #140]	; (19db8 <settings_register+0x98>)
   19d2c:	4f23      	ldr	r7, [pc, #140]	; (19dbc <settings_register+0x9c>)
   19d2e:	42ac      	cmp	r4, r5
   19d30:	d90c      	bls.n	19d4c <settings_register+0x2c>
   19d32:	4923      	ldr	r1, [pc, #140]	; (19dc0 <settings_register+0xa0>)
   19d34:	232b      	movs	r3, #43	; 0x2b
   19d36:	463a      	mov	r2, r7
   19d38:	4822      	ldr	r0, [pc, #136]	; (19dc4 <settings_register+0xa4>)
   19d3a:	f019 fc45 	bl	335c8 <printk>
   19d3e:	4822      	ldr	r0, [pc, #136]	; (19dc8 <settings_register+0xa8>)
   19d40:	f019 fc42 	bl	335c8 <printk>
   19d44:	212b      	movs	r1, #43	; 0x2b
   19d46:	4638      	mov	r0, r7
   19d48:	f019 ff3f 	bl	33bca <assert_post_action>
   19d4c:	4544      	cmp	r4, r8
   19d4e:	d316      	bcc.n	19d7e <settings_register+0x5e>
	}

	k_mutex_lock(&settings_lock, K_FOREVER);

	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   19d50:	4d1e      	ldr	r5, [pc, #120]	; (19dcc <settings_register+0xac>)
	return z_impl_k_mutex_lock(mutex, timeout);
   19d52:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   19d56:	481e      	ldr	r0, [pc, #120]	; (19dd0 <settings_register+0xb0>)
   19d58:	f012 fc58 	bl	2c60c <z_impl_k_mutex_lock>
   19d5c:	682c      	ldr	r4, [r5, #0]
   19d5e:	b9ac      	cbnz	r4, 19d8c <settings_register+0x6c>
	parent->next = child;
   19d60:	2400      	movs	r4, #0
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
   19d62:	686a      	ldr	r2, [r5, #4]
		if (strcmp(handler->name, ch->name) == 0) {
			rc = -EEXIST;
			goto end;
		}
	}
	sys_slist_append(&settings_handlers, &handler->node);
   19d64:	f106 0314 	add.w	r3, r6, #20
	parent->next = child;
   19d68:	6174      	str	r4, [r6, #20]
Z_GENLIST_APPEND(slist, snode)
   19d6a:	b9ca      	cbnz	r2, 19da0 <settings_register+0x80>
	int rc = 0;
   19d6c:	4614      	mov	r4, r2
	list->head = node;
   19d6e:	e9c5 3300 	strd	r3, r3, [r5]
	return z_impl_k_mutex_unlock(mutex);
   19d72:	4817      	ldr	r0, [pc, #92]	; (19dd0 <settings_register+0xb0>)
   19d74:	f012 fd28 	bl	2c7c8 <z_impl_k_mutex_unlock>

end:
	k_mutex_unlock(&settings_lock);
	return rc;
}
   19d78:	4620      	mov	r0, r4
   19d7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (strcmp(handler->name, ch->name) == 0) {
   19d7e:	6821      	ldr	r1, [r4, #0]
   19d80:	6830      	ldr	r0, [r6, #0]
   19d82:	f7f8 f973 	bl	1206c <strcmp>
   19d86:	b188      	cbz	r0, 19dac <settings_register+0x8c>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19d88:	3414      	adds	r4, #20
   19d8a:	e7d0      	b.n	19d2e <settings_register+0xe>
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   19d8c:	3c14      	subs	r4, #20
   19d8e:	2c00      	cmp	r4, #0
   19d90:	d0e6      	beq.n	19d60 <settings_register+0x40>
		if (strcmp(handler->name, ch->name) == 0) {
   19d92:	6821      	ldr	r1, [r4, #0]
   19d94:	6830      	ldr	r0, [r6, #0]
   19d96:	f7f8 f969 	bl	1206c <strcmp>
   19d9a:	b120      	cbz	r0, 19da6 <settings_register+0x86>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   19d9c:	6964      	ldr	r4, [r4, #20]
	return node->next;
   19d9e:	e7de      	b.n	19d5e <settings_register+0x3e>
	parent->next = child;
   19da0:	6013      	str	r3, [r2, #0]
	list->tail = node;
   19da2:	606b      	str	r3, [r5, #4]
   19da4:	e7e5      	b.n	19d72 <settings_register+0x52>
			rc = -EEXIST;
   19da6:	f06f 0410 	mvn.w	r4, #16
   19daa:	e7e2      	b.n	19d72 <settings_register+0x52>
			return -EEXIST;
   19dac:	f06f 0410 	mvn.w	r4, #16
   19db0:	e7e2      	b.n	19d78 <settings_register+0x58>
   19db2:	bf00      	nop
   19db4:	00039f60 	.word	0x00039f60
   19db8:	00039f60 	.word	0x00039f60
   19dbc:	0003ccd3 	.word	0x0003ccd3
   19dc0:	0003cd05 	.word	0x0003cd05
   19dc4:	0003b77f 	.word	0x0003b77f
   19dc8:	0003cc09 	.word	0x0003cc09
   19dcc:	2002171c 	.word	0x2002171c
   19dd0:	20020748 	.word	0x20020748

00019dd4 <settings_commit_subtree>:
{
	return settings_commit_subtree(NULL);
}

int settings_commit_subtree(const char *subtree)
{
   19dd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int rc;
	int rc2;

	rc = 0;

	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19dd8:	4f21      	ldr	r7, [pc, #132]	; (19e60 <settings_commit_subtree+0x8c>)
{
   19dda:	4606      	mov	r6, r0
	rc = 0;
   19ddc:	2500      	movs	r5, #0
   19dde:	46b9      	mov	r9, r7
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19de0:	4c20      	ldr	r4, [pc, #128]	; (19e64 <settings_commit_subtree+0x90>)
   19de2:	f8df 8094 	ldr.w	r8, [pc, #148]	; 19e78 <settings_commit_subtree+0xa4>
   19de6:	42bc      	cmp	r4, r7
   19de8:	d90c      	bls.n	19e04 <settings_commit_subtree+0x30>
   19dea:	491f      	ldr	r1, [pc, #124]	; (19e68 <settings_commit_subtree+0x94>)
   19dec:	23f4      	movs	r3, #244	; 0xf4
   19dee:	4642      	mov	r2, r8
   19df0:	481e      	ldr	r0, [pc, #120]	; (19e6c <settings_commit_subtree+0x98>)
   19df2:	f019 fbe9 	bl	335c8 <printk>
   19df6:	481e      	ldr	r0, [pc, #120]	; (19e70 <settings_commit_subtree+0x9c>)
   19df8:	f019 fbe6 	bl	335c8 <printk>
   19dfc:	21f4      	movs	r1, #244	; 0xf4
   19dfe:	4640      	mov	r0, r8
   19e00:	f019 fee3 	bl	33bca <assert_post_action>
   19e04:	454c      	cmp	r4, r9
   19e06:	d307      	bcc.n	19e18 <settings_commit_subtree+0x44>
		}
	}

#if defined(CONFIG_SETTINGS_DYNAMIC_HANDLERS)
	struct settings_handler *ch;
	SYS_SLIST_FOR_EACH_CONTAINER(&settings_handlers, ch, node) {
   19e08:	4b1a      	ldr	r3, [pc, #104]	; (19e74 <settings_commit_subtree+0xa0>)
   19e0a:	681c      	ldr	r4, [r3, #0]
   19e0c:	b10c      	cbz	r4, 19e12 <settings_commit_subtree+0x3e>
   19e0e:	3c14      	subs	r4, #20
   19e10:	b9a4      	cbnz	r4, 19e3c <settings_commit_subtree+0x68>
		}
	}
#endif /* CONFIG_SETTINGS_DYNAMIC_HANDLERS */

	return rc;
}
   19e12:	4628      	mov	r0, r5
   19e14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   19e18:	b91e      	cbnz	r6, 19e22 <settings_commit_subtree+0x4e>
		if (ch->h_commit) {
   19e1a:	68e3      	ldr	r3, [r4, #12]
   19e1c:	b94b      	cbnz	r3, 19e32 <settings_commit_subtree+0x5e>
	Z_STRUCT_SECTION_FOREACH(settings_handler_static, ch) {
   19e1e:	3414      	adds	r4, #20
   19e20:	e7e1      	b.n	19de6 <settings_commit_subtree+0x12>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   19e22:	2200      	movs	r2, #0
   19e24:	4631      	mov	r1, r6
   19e26:	6820      	ldr	r0, [r4, #0]
   19e28:	f01a f96b 	bl	34102 <settings_name_steq>
   19e2c:	2800      	cmp	r0, #0
   19e2e:	d1f4      	bne.n	19e1a <settings_commit_subtree+0x46>
   19e30:	e7f5      	b.n	19e1e <settings_commit_subtree+0x4a>
			rc2 = ch->h_commit();
   19e32:	4798      	blx	r3
				rc = rc2;
   19e34:	2d00      	cmp	r5, #0
   19e36:	bf08      	it	eq
   19e38:	4605      	moveq	r5, r0
   19e3a:	e7f0      	b.n	19e1e <settings_commit_subtree+0x4a>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   19e3c:	b91e      	cbnz	r6, 19e46 <settings_commit_subtree+0x72>
		if (ch->h_commit) {
   19e3e:	68e3      	ldr	r3, [r4, #12]
   19e40:	b94b      	cbnz	r3, 19e56 <settings_commit_subtree+0x82>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   19e42:	6964      	ldr	r4, [r4, #20]
   19e44:	e7e2      	b.n	19e0c <settings_commit_subtree+0x38>
		if (subtree && !settings_name_steq(ch->name, subtree, NULL)) {
   19e46:	2200      	movs	r2, #0
   19e48:	4631      	mov	r1, r6
   19e4a:	6820      	ldr	r0, [r4, #0]
   19e4c:	f01a f959 	bl	34102 <settings_name_steq>
   19e50:	2800      	cmp	r0, #0
   19e52:	d1f4      	bne.n	19e3e <settings_commit_subtree+0x6a>
   19e54:	e7f5      	b.n	19e42 <settings_commit_subtree+0x6e>
			rc2 = ch->h_commit();
   19e56:	4798      	blx	r3
				rc = rc2;
   19e58:	2d00      	cmp	r5, #0
   19e5a:	bf08      	it	eq
   19e5c:	4605      	moveq	r5, r0
   19e5e:	e7f0      	b.n	19e42 <settings_commit_subtree+0x6e>
   19e60:	00039f60 	.word	0x00039f60
   19e64:	00039f60 	.word	0x00039f60
   19e68:	0003cd05 	.word	0x0003cd05
   19e6c:	0003b77f 	.word	0x0003b77f
   19e70:	0003cc09 	.word	0x0003cc09
   19e74:	2002171c 	.word	0x2002171c
   19e78:	0003ccd3 	.word	0x0003ccd3

00019e7c <settings_subsys_init>:
void settings_init(void);

int settings_backend_init(void);

int settings_subsys_init(void)
{
   19e7c:	b510      	push	{r4, lr}

	int err = 0;

	if (settings_subsys_initialized) {
   19e7e:	4c06      	ldr	r4, [pc, #24]	; (19e98 <settings_subsys_init+0x1c>)
   19e80:	7823      	ldrb	r3, [r4, #0]
   19e82:	b93b      	cbnz	r3, 19e94 <settings_subsys_init+0x18>
		return 0;
	}

	settings_init();
   19e84:	f7ff ff44 	bl	19d10 <settings_init>

	err = settings_backend_init(); /* func rises kernel panic once error */
   19e88:	f01a f95b 	bl	34142 <settings_backend_init>

	if (!err) {
   19e8c:	b908      	cbnz	r0, 19e92 <settings_subsys_init+0x16>
		settings_subsys_initialized = true;
   19e8e:	2301      	movs	r3, #1
   19e90:	7023      	strb	r3, [r4, #0]
	}

	return err;
}
   19e92:	bd10      	pop	{r4, pc}
		return 0;
   19e94:	2000      	movs	r0, #0
   19e96:	e7fc      	b.n	19e92 <settings_subsys_init+0x16>
   19e98:	20027fb6 	.word	0x20027fb6

00019e9c <sys_reboot>:

extern void sys_arch_reboot(int type);
extern void sys_clock_disable(void);

void sys_reboot(int type)
{
   19e9c:	b508      	push	{r3, lr}
   19e9e:	4604      	mov	r4, r0
	__asm__ volatile(
   19ea0:	f04f 0220 	mov.w	r2, #32
   19ea4:	f3ef 8311 	mrs	r3, BASEPRI
   19ea8:	f382 8811 	msr	BASEPRI, r2
   19eac:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
#ifdef CONFIG_SYS_CLOCK_EXISTS
	sys_clock_disable();
   19eb0:	f01a f97d 	bl	341ae <sys_clock_disable>
#endif

	sys_arch_reboot(type);
   19eb4:	4620      	mov	r0, r4
   19eb6:	f001 fb39 	bl	1b52c <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
   19eba:	4803      	ldr	r0, [pc, #12]	; (19ec8 <sys_reboot+0x2c>)
   19ebc:	f019 fb84 	bl	335c8 <printk>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
   19ec0:	f000 ff30 	bl	1ad24 <arch_cpu_idle>
   19ec4:	e7fc      	b.n	19ec0 <sys_reboot+0x24>
   19ec6:	bf00      	nop
   19ec8:	0003cd33 	.word	0x0003cd33

00019ecc <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
   19ecc:	b510      	push	{r4, lr}
   19ece:	4807      	ldr	r0, [pc, #28]	; (19eec <uart_console_init+0x20>)
   19ed0:	f011 fca0 	bl	2b814 <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
   19ed4:	4c06      	ldr	r4, [pc, #24]	; (19ef0 <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
   19ed6:	4b07      	ldr	r3, [pc, #28]	; (19ef4 <uart_console_init+0x28>)
   19ed8:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
   19eda:	4620      	mov	r0, r4
   19edc:	f001 fda4 	bl	1ba28 <__stdout_hook_install>
	__printk_hook_install(console_out);
   19ee0:	4620      	mov	r0, r4
   19ee2:	f7fe fd8b 	bl	189fc <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
   19ee6:	2000      	movs	r0, #0
   19ee8:	bd10      	pop	{r4, pc}
   19eea:	bf00      	nop
   19eec:	0003cb09 	.word	0x0003cb09
   19ef0:	00019ef9 	.word	0x00019ef9
   19ef4:	20021724 	.word	0x20021724

00019ef8 <console_out>:
	if ('\n' == c) {
   19ef8:	280a      	cmp	r0, #10
{
   19efa:	b538      	push	{r3, r4, r5, lr}
   19efc:	4604      	mov	r4, r0
   19efe:	4d07      	ldr	r5, [pc, #28]	; (19f1c <console_out+0x24>)
	if ('\n' == c) {
   19f00:	d104      	bne.n	19f0c <console_out+0x14>
   19f02:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
   19f04:	6883      	ldr	r3, [r0, #8]
   19f06:	210d      	movs	r1, #13
   19f08:	685b      	ldr	r3, [r3, #4]
   19f0a:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
   19f0c:	6828      	ldr	r0, [r5, #0]
   19f0e:	6883      	ldr	r3, [r0, #8]
   19f10:	b2e1      	uxtb	r1, r4
   19f12:	685b      	ldr	r3, [r3, #4]
   19f14:	4798      	blx	r3
}
   19f16:	4620      	mov	r0, r4
   19f18:	bd38      	pop	{r3, r4, r5, pc}
   19f1a:	bf00      	nop
   19f1c:	20021724 	.word	0x20021724

00019f20 <get_status>:
	return &config->subsys[type];
}

static enum clock_control_status get_status(struct device *dev,
					    clock_control_subsys_t subsys)
{
   19f20:	b538      	push	{r3, r4, r5, lr}
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
	struct nrf_clock_control_sub_data *data;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   19f22:	b2cc      	uxtb	r4, r1
   19f24:	2c01      	cmp	r4, #1
{
   19f26:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   19f28:	d909      	bls.n	19f3e <get_status+0x1e>
   19f2a:	490b      	ldr	r1, [pc, #44]	; (19f58 <get_status+0x38>)
   19f2c:	480b      	ldr	r0, [pc, #44]	; (19f5c <get_status+0x3c>)
   19f2e:	237f      	movs	r3, #127	; 0x7f
   19f30:	4a0b      	ldr	r2, [pc, #44]	; (19f60 <get_status+0x40>)
   19f32:	f019 fb49 	bl	335c8 <printk>
   19f36:	217f      	movs	r1, #127	; 0x7f
   19f38:	4809      	ldr	r0, [pc, #36]	; (19f60 <get_status+0x40>)
   19f3a:	f019 fe46 	bl	33bca <assert_post_action>
	data = get_sub_data(dev, type);
	if (data->started) {
   19f3e:	210c      	movs	r1, #12
	data = get_sub_data(dev, type);
   19f40:	68eb      	ldr	r3, [r5, #12]
	if (data->started) {
   19f42:	fb04 3101 	mla	r1, r4, r1, r3
   19f46:	7a4b      	ldrb	r3, [r1, #9]
   19f48:	b923      	cbnz	r3, 19f54 <get_status+0x34>
		return CLOCK_CONTROL_STATUS_ON;
	}

	if (data->ref > 0) {
   19f4a:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
   19f4c:	fab0 f080 	clz	r0, r0
   19f50:	0940      	lsrs	r0, r0, #5
		return CLOCK_CONTROL_STATUS_STARTING;
	}

	return CLOCK_CONTROL_STATUS_OFF;
}
   19f52:	bd38      	pop	{r3, r4, r5, pc}
		return CLOCK_CONTROL_STATUS_ON;
   19f54:	2002      	movs	r0, #2
   19f56:	e7fc      	b.n	19f52 <get_status+0x32>
   19f58:	0003cdf7 	.word	0x0003cdf7
   19f5c:	0003b77f 	.word	0x0003b77f
   19f60:	0003cdbc 	.word	0x0003cdbc

00019f64 <clock_async_start>:
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
   19f64:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct nrf_clock_control_sub_config *config;
	struct nrf_clock_control_sub_data *clk_data;
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   19f68:	b2ce      	uxtb	r6, r1
   19f6a:	2e01      	cmp	r6, #1
{
   19f6c:	4680      	mov	r8, r0
   19f6e:	4689      	mov	r9, r1
   19f70:	4614      	mov	r4, r2
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   19f72:	d909      	bls.n	19f88 <clock_async_start+0x24>
   19f74:	493f      	ldr	r1, [pc, #252]	; (1a074 <clock_async_start+0x110>)
   19f76:	4840      	ldr	r0, [pc, #256]	; (1a078 <clock_async_start+0x114>)
   19f78:	23ef      	movs	r3, #239	; 0xef
   19f7a:	4a40      	ldr	r2, [pc, #256]	; (1a07c <clock_async_start+0x118>)
   19f7c:	f019 fb24 	bl	335c8 <printk>
   19f80:	21ef      	movs	r1, #239	; 0xef
   19f82:	483e      	ldr	r0, [pc, #248]	; (1a07c <clock_async_start+0x118>)
   19f84:	f019 fe21 	bl	33bca <assert_post_action>
	config = get_sub_config(dev, type);
   19f88:	f8d8 a004 	ldr.w	sl, [r8, #4]
	clk_data = get_sub_data(dev, type);
   19f8c:	f8d8 700c 	ldr.w	r7, [r8, #12]

	__ASSERT_NO_MSG((data == NULL) ||
   19f90:	2c00      	cmp	r4, #0
   19f92:	d151      	bne.n	1a038 <clock_async_start+0xd4>
   19f94:	f04f 0320 	mov.w	r3, #32
   19f98:	f3ef 8b11 	mrs	fp, BASEPRI
   19f9c:	f383 8811 	msr	BASEPRI, r3
   19fa0:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
   19fa4:	230c      	movs	r3, #12
   19fa6:	fb06 7303 	mla	r3, r6, r3, r7
   19faa:	7a1d      	ldrb	r5, [r3, #8]
   19fac:	3501      	adds	r5, #1
   19fae:	b2ed      	uxtb	r5, r5
   19fb0:	721d      	strb	r5, [r3, #8]
	__ASSERT_NO_MSG(clk_data->ref > 0);
   19fb2:	b95d      	cbnz	r5, 19fcc <clock_async_start+0x68>
   19fb4:	4932      	ldr	r1, [pc, #200]	; (1a080 <clock_async_start+0x11c>)
   19fb6:	4830      	ldr	r0, [pc, #192]	; (1a078 <clock_async_start+0x114>)
   19fb8:	f44f 7380 	mov.w	r3, #256	; 0x100
   19fbc:	4a2f      	ldr	r2, [pc, #188]	; (1a07c <clock_async_start+0x118>)
   19fbe:	f019 fb03 	bl	335c8 <printk>
   19fc2:	f44f 7180 	mov.w	r1, #256	; 0x100
   19fc6:	482d      	ldr	r0, [pc, #180]	; (1a07c <clock_async_start+0x118>)
   19fc8:	f019 fdff 	bl	33bca <assert_post_action>
	__asm__ volatile(
   19fcc:	f38b 8811 	msr	BASEPRI, fp
   19fd0:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	if (data) {
   19fd4:	b324      	cbz	r4, 1a020 <clock_async_start+0xbc>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
   19fd6:	2203      	movs	r2, #3
   19fd8:	4b2a      	ldr	r3, [pc, #168]	; (1a084 <clock_async_start+0x120>)
   19fda:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
   19fde:	220c      	movs	r2, #12
   19fe0:	4372      	muls	r2, r6
   19fe2:	18bb      	adds	r3, r7, r2
   19fe4:	7a59      	ldrb	r1, [r3, #9]
		if (!already_started) {
   19fe6:	b989      	cbnz	r1, 1a00c <clock_async_start+0xa8>
	__asm__ volatile(
   19fe8:	f04f 0020 	mov.w	r0, #32
   19fec:	f3ef 8c11 	mrs	ip, BASEPRI
   19ff0:	f380 8811 	msr	BASEPRI, r0
   19ff4:	f3bf 8f6f 	isb	sy
	parent->next = child;
   19ff8:	6021      	str	r1, [r4, #0]
Z_GENLIST_APPEND(slist, snode)
   19ffa:	6858      	ldr	r0, [r3, #4]
   19ffc:	2800      	cmp	r0, #0
   19ffe:	d132      	bne.n	1a066 <clock_async_start+0x102>
	list->tail = node;
   1a000:	605c      	str	r4, [r3, #4]
	list->head = node;
   1a002:	50bc      	str	r4, [r7, r2]
	__asm__ volatile(
   1a004:	f38c 8811 	msr	BASEPRI, ip
   1a008:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
   1a00c:	2203      	movs	r2, #3
   1a00e:	4b1d      	ldr	r3, [pc, #116]	; (1a084 <clock_async_start+0x120>)
   1a010:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
   1a014:	b121      	cbz	r1, 1a020 <clock_async_start+0xbc>
			data->cb(dev, subsys, data->user_data);
   1a016:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
   1a01a:	4649      	mov	r1, r9
   1a01c:	4640      	mov	r0, r8
   1a01e:	4798      	blx	r3
		}
	}

	if (ref == 1) {
   1a020:	2d01      	cmp	r5, #1
   1a022:	d107      	bne.n	1a034 <clock_async_start+0xd0>
		if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			(subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
			anomaly_132_workaround();
		}

		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
   1a024:	eb0a 06c6 	add.w	r6, sl, r6, lsl #3
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1a028:	78b3      	ldrb	r3, [r6, #2]
   1a02a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1a02e:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
   1a032:	601d      	str	r5, [r3, #0]
	}

	return 0;
   1a034:	2000      	movs	r0, #0
   1a036:	e01b      	b.n	1a070 <clock_async_start+0x10c>
	__ASSERT_NO_MSG((data == NULL) ||
   1a038:	6863      	ldr	r3, [r4, #4]
   1a03a:	b94b      	cbnz	r3, 1a050 <clock_async_start+0xec>
   1a03c:	4912      	ldr	r1, [pc, #72]	; (1a088 <clock_async_start+0x124>)
   1a03e:	480e      	ldr	r0, [pc, #56]	; (1a078 <clock_async_start+0x114>)
   1a040:	23f4      	movs	r3, #244	; 0xf4
   1a042:	4a0e      	ldr	r2, [pc, #56]	; (1a07c <clock_async_start+0x118>)
   1a044:	f019 fac0 	bl	335c8 <printk>
   1a048:	21f4      	movs	r1, #244	; 0xf4
   1a04a:	480c      	ldr	r0, [pc, #48]	; (1a07c <clock_async_start+0x118>)
   1a04c:	f019 fdbd 	bl	33bca <assert_post_action>
	sys_snode_t *item = sys_slist_peek_head(list);
   1a050:	230c      	movs	r3, #12
   1a052:	4373      	muls	r3, r6
   1a054:	58fb      	ldr	r3, [r7, r3]
		if (item == node) {
   1a056:	429c      	cmp	r4, r3
   1a058:	d008      	beq.n	1a06c <clock_async_start+0x108>
Z_GENLIST_PEEK_NEXT(slist, snode)
   1a05a:	2b00      	cmp	r3, #0
   1a05c:	d09a      	beq.n	19f94 <clock_async_start+0x30>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1a05e:	681b      	ldr	r3, [r3, #0]
	} while (item);
   1a060:	2b00      	cmp	r3, #0
   1a062:	d1f8      	bne.n	1a056 <clock_async_start+0xf2>
   1a064:	e796      	b.n	19f94 <clock_async_start+0x30>
	parent->next = child;
   1a066:	6004      	str	r4, [r0, #0]
	list->tail = node;
   1a068:	605c      	str	r4, [r3, #4]
   1a06a:	e7cb      	b.n	1a004 <clock_async_start+0xa0>
		return -EBUSY;
   1a06c:	f06f 000f 	mvn.w	r0, #15
}
   1a070:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a074:	0003cdf7 	.word	0x0003cdf7
   1a078:	0003b77f 	.word	0x0003b77f
   1a07c:	0003cdbc 	.word	0x0003cdbc
   1a080:	0003cdaa 	.word	0x0003cdaa
   1a084:	40005000 	.word	0x40005000
   1a088:	0003cd5c 	.word	0x0003cd5c

0001a08c <clock_stop>:
{
   1a08c:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1a08e:	b2cc      	uxtb	r4, r1
   1a090:	2c01      	cmp	r4, #1
{
   1a092:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
   1a094:	d909      	bls.n	1a0aa <clock_stop+0x1e>
   1a096:	4919      	ldr	r1, [pc, #100]	; (1a0fc <clock_stop+0x70>)
   1a098:	4819      	ldr	r0, [pc, #100]	; (1a100 <clock_stop+0x74>)
   1a09a:	2394      	movs	r3, #148	; 0x94
   1a09c:	4a19      	ldr	r2, [pc, #100]	; (1a104 <clock_stop+0x78>)
   1a09e:	f019 fa93 	bl	335c8 <printk>
   1a0a2:	2194      	movs	r1, #148	; 0x94
   1a0a4:	4817      	ldr	r0, [pc, #92]	; (1a104 <clock_stop+0x78>)
   1a0a6:	f019 fd90 	bl	33bca <assert_post_action>
	config = get_sub_config(dev, type);
   1a0aa:	6869      	ldr	r1, [r5, #4]
	data = get_sub_data(dev, type);
   1a0ac:	68ed      	ldr	r5, [r5, #12]
	__asm__ volatile(
   1a0ae:	f04f 0320 	mov.w	r3, #32
   1a0b2:	f3ef 8611 	mrs	r6, BASEPRI
   1a0b6:	f383 8811 	msr	BASEPRI, r3
   1a0ba:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
   1a0be:	230c      	movs	r3, #12
   1a0c0:	4363      	muls	r3, r4
   1a0c2:	18ea      	adds	r2, r5, r3
   1a0c4:	7a10      	ldrb	r0, [r2, #8]
   1a0c6:	b1a0      	cbz	r0, 1a0f2 <clock_stop+0x66>
	data->ref--;
   1a0c8:	3801      	subs	r0, #1
   1a0ca:	b2c0      	uxtb	r0, r0
   1a0cc:	7210      	strb	r0, [r2, #8]
	if (data->ref == 0) {
   1a0ce:	b998      	cbnz	r0, 1a0f8 <clock_stop+0x6c>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
   1a0d0:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
	list->head = NULL;
   1a0d4:	50e8      	str	r0, [r5, r3]
   1a0d6:	78cb      	ldrb	r3, [r1, #3]
   1a0d8:	2101      	movs	r1, #1
   1a0da:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1a0de:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
	list->tail = NULL;
   1a0e2:	6050      	str	r0, [r2, #4]
   1a0e4:	6019      	str	r1, [r3, #0]
		data->started = false;
   1a0e6:	7250      	strb	r0, [r2, #9]
	__asm__ volatile(
   1a0e8:	f386 8811 	msr	BASEPRI, r6
   1a0ec:	f3bf 8f6f 	isb	sy
}
   1a0f0:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
   1a0f2:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1a0f6:	e7f7      	b.n	1a0e8 <clock_stop+0x5c>
	int err = 0;
   1a0f8:	2000      	movs	r0, #0
   1a0fa:	e7f5      	b.n	1a0e8 <clock_stop+0x5c>
   1a0fc:	0003cdf7 	.word	0x0003cdf7
   1a100:	0003b77f 	.word	0x0003b77f
   1a104:	0003cdbc 	.word	0x0003cdbc

0001a108 <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
   1a108:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1a10a:	2200      	movs	r2, #0
{
   1a10c:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
   1a10e:	2101      	movs	r1, #1
   1a110:	2005      	movs	r0, #5
   1a112:	f000 fd7d 	bl	1ac10 <z_arm_irq_priority_set>
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_IRQN(0));
   1a116:	2005      	movs	r0, #5
   1a118:	f000 fd6a 	bl	1abf0 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
   1a11c:	2202      	movs	r2, #2
   1a11e:	4b07      	ldr	r3, [pc, #28]	; (1a13c <clk_init+0x34>)
	list->head = NULL;
   1a120:	2000      	movs	r0, #0
   1a122:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
   1a126:	2203      	movs	r2, #3
   1a128:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
   1a12c:	68e3      	ldr	r3, [r4, #12]
	list->tail = NULL;
   1a12e:	e9c3 0000 	strd	r0, r0, [r3]
   1a132:	68e3      	ldr	r3, [r4, #12]
   1a134:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
   1a138:	bd10      	pop	{r4, pc}
   1a13a:	bf00      	nop
   1a13c:	40005000 	.word	0x40005000

0001a140 <clkstarted_handle.constprop.9>:
DEVICE_AND_API_INIT(clock_nrf, DT_INST_LABEL(0),
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
   1a140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
   1a142:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   1a144:	4d11      	ldr	r5, [pc, #68]	; (1a18c <clkstarted_handle.constprop.9+0x4c>)
static void clkstarted_handle(struct device *dev,
   1a146:	4606      	mov	r6, r0
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
   1a148:	68eb      	ldr	r3, [r5, #12]
	sub_data->started = true;
   1a14a:	fb04 3400 	mla	r4, r4, r0, r3
   1a14e:	2301      	movs	r3, #1
   1a150:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
   1a152:	f04f 0320 	mov.w	r3, #32
   1a156:	f3ef 8111 	mrs	r1, BASEPRI
   1a15a:	f383 8811 	msr	BASEPRI, r3
   1a15e:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
   1a162:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
   1a164:	b12b      	cbz	r3, 1a172 <clkstarted_handle.constprop.9+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
   1a166:	6860      	ldr	r0, [r4, #4]
   1a168:	681a      	ldr	r2, [r3, #0]
   1a16a:	4283      	cmp	r3, r0
	list->head = node;
   1a16c:	6022      	str	r2, [r4, #0]
	list->tail = node;
   1a16e:	bf08      	it	eq
   1a170:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
   1a172:	f381 8811 	msr	BASEPRI, r1
   1a176:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
   1a17a:	b903      	cbnz	r3, 1a17e <clkstarted_handle.constprop.9+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
   1a17c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
   1a17e:	e9d3 7201 	ldrd	r7, r2, [r3, #4]
   1a182:	4631      	mov	r1, r6
   1a184:	4628      	mov	r0, r5
   1a186:	47b8      	blx	r7
   1a188:	e7e3      	b.n	1a152 <clkstarted_handle.constprop.9+0x12>
   1a18a:	bf00      	nop
   1a18c:	20020504 	.word	0x20020504

0001a190 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
   1a190:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1a192:	4b10      	ldr	r3, [pc, #64]	; (1a1d4 <nrf_power_clock_isr+0x44>)
   1a194:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   1a196:	b162      	cbz	r2, 1a1b2 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
   1a198:	4a0f      	ldr	r2, [pc, #60]	; (1a1d8 <nrf_power_clock_isr+0x48>)
   1a19a:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   1a19e:	07d1      	lsls	r1, r2, #31
   1a1a0:	d507      	bpl.n	1a1b2 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a1a2:	2200      	movs	r2, #0
   1a1a4:	601a      	str	r2, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   1a1a6:	4b0d      	ldr	r3, [pc, #52]	; (1a1dc <nrf_power_clock_isr+0x4c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
   1a1a8:	68db      	ldr	r3, [r3, #12]
   1a1aa:	7a58      	ldrb	r0, [r3, #9]
   1a1ac:	b908      	cbnz	r0, 1a1b2 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
   1a1ae:	f7ff ffc7 	bl	1a140 <clkstarted_handle.constprop.9>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
   1a1b2:	4b0b      	ldr	r3, [pc, #44]	; (1a1e0 <nrf_power_clock_isr+0x50>)
   1a1b4:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
   1a1b6:	b15a      	cbz	r2, 1a1d0 <nrf_power_clock_isr+0x40>
    return p_reg->INTENSET & mask;
   1a1b8:	4a07      	ldr	r2, [pc, #28]	; (1a1d8 <nrf_power_clock_isr+0x48>)
   1a1ba:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
   1a1be:	0792      	lsls	r2, r2, #30
   1a1c0:	d506      	bpl.n	1a1d0 <nrf_power_clock_isr+0x40>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1a1c2:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1a1c4:	2001      	movs	r0, #1
   1a1c6:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
   1a1c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
   1a1cc:	f7ff bfb8 	b.w	1a140 <clkstarted_handle.constprop.9>
}
   1a1d0:	bd08      	pop	{r3, pc}
   1a1d2:	bf00      	nop
   1a1d4:	40005100 	.word	0x40005100
   1a1d8:	40005000 	.word	0x40005000
   1a1dc:	20020504 	.word	0x20020504
   1a1e0:	40005104 	.word	0x40005104

0001a1e4 <wdt_nrf_install_timeout>:
	return -EPERM;
}

static int wdt_nrf_install_timeout(struct device *dev,
				   const struct wdt_timeout_cfg *cfg)
{
   1a1e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	nrfx_err_t err_code;
	nrfx_wdt_channel_id channel_id;

	if (cfg->flags != WDT_FLAG_RESET_SOC) {
   1a1e6:	7b0b      	ldrb	r3, [r1, #12]
{
   1a1e8:	4604      	mov	r4, r0
	if (cfg->flags != WDT_FLAG_RESET_SOC) {
   1a1ea:	2b02      	cmp	r3, #2
{
   1a1ec:	460d      	mov	r5, r1
	if (cfg->flags != WDT_FLAG_RESET_SOC) {
   1a1ee:	d128      	bne.n	1a242 <wdt_nrf_install_timeout+0x5e>
		return -ENOTSUP;
	}

	if (cfg->window.min != 0U) {
   1a1f0:	680b      	ldr	r3, [r1, #0]
   1a1f2:	bb1b      	cbnz	r3, 1a23c <wdt_nrf_install_timeout+0x58>
		return -EINVAL;
	}

	if (get_dev_data(dev)->m_allocated_channels == 0U) {
   1a1f4:	68c2      	ldr	r2, [r0, #12]
	return dev->driver_data;
   1a1f6:	684b      	ldr	r3, [r1, #4]
	if (get_dev_data(dev)->m_allocated_channels == 0U) {
   1a1f8:	f892 1024 	ldrb.w	r1, [r2, #36]	; 0x24
   1a1fc:	b9d9      	cbnz	r1, 1a236 <wdt_nrf_install_timeout+0x52>
		 * in all nRF chips can use reload values (determining
		 * the timeout) from range 0xF-0xFFFFFFFF given in 32768 Hz
		 * clock ticks. This makes the allowed range of 0x1-0x07CFFFFF
		 * in milliseconds. Check if the provided value is within
		 * this range. */
		if ((cfg->window.max == 0U) || (cfg->window.max > 0x07CFFFFF)) {
   1a1fe:	4914      	ldr	r1, [pc, #80]	; (1a250 <wdt_nrf_install_timeout+0x6c>)
   1a200:	1e58      	subs	r0, r3, #1
   1a202:	4288      	cmp	r0, r1
   1a204:	d81a      	bhi.n	1a23c <wdt_nrf_install_timeout+0x58>
			return -EINVAL;
		}

		/* Save timeout value from first registered watchdog channel. */
		get_dev_data(dev)->m_timeout = cfg->window.max;
   1a206:	6213      	str	r3, [r2, #32]
	} else if (cfg->window.max != get_dev_data(dev)->m_timeout) {
		return -EINVAL;
	}

	err_code = nrfx_wdt_channel_alloc(&get_dev_config(dev)->wdt,
   1a208:	f10d 0107 	add.w	r1, sp, #7
   1a20c:	6860      	ldr	r0, [r4, #4]
   1a20e:	f011 fa6d 	bl	2b6ec <nrfx_wdt_channel_alloc>
					  &channel_id);

	if (err_code == NRFX_ERROR_NO_MEM) {
   1a212:	4b10      	ldr	r3, [pc, #64]	; (1a254 <wdt_nrf_install_timeout+0x70>)
   1a214:	4298      	cmp	r0, r3
   1a216:	d017      	beq.n	1a248 <wdt_nrf_install_timeout+0x64>
		return -ENOMEM;
	}

	if (cfg->callback != NULL) {
   1a218:	68ab      	ldr	r3, [r5, #8]
   1a21a:	f89d 0007 	ldrb.w	r0, [sp, #7]
   1a21e:	b113      	cbz	r3, 1a226 <wdt_nrf_install_timeout+0x42>
   1a220:	68e2      	ldr	r2, [r4, #12]
		get_dev_data(dev)->m_callbacks[channel_id] = cfg->callback;
   1a222:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
	}

	get_dev_data(dev)->m_allocated_channels++;
   1a226:	68e2      	ldr	r2, [r4, #12]
   1a228:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   1a22c:	3301      	adds	r3, #1
   1a22e:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
	return channel_id;
}
   1a232:	b003      	add	sp, #12
   1a234:	bd30      	pop	{r4, r5, pc}
	} else if (cfg->window.max != get_dev_data(dev)->m_timeout) {
   1a236:	6a12      	ldr	r2, [r2, #32]
   1a238:	429a      	cmp	r2, r3
   1a23a:	d0e5      	beq.n	1a208 <wdt_nrf_install_timeout+0x24>
		return -EINVAL;
   1a23c:	f06f 0015 	mvn.w	r0, #21
   1a240:	e7f7      	b.n	1a232 <wdt_nrf_install_timeout+0x4e>
		return -ENOTSUP;
   1a242:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1a246:	e7f4      	b.n	1a232 <wdt_nrf_install_timeout+0x4e>
		return -ENOMEM;
   1a248:	f06f 000b 	mvn.w	r0, #11
   1a24c:	e7f1      	b.n	1a232 <wdt_nrf_install_timeout+0x4e>
   1a24e:	bf00      	nop
   1a250:	07cffffe 	.word	0x07cffffe
   1a254:	0bad0002 	.word	0x0bad0002

0001a258 <wdt_0_init>:
			    &wdt_##idx##z_config,			       \
			    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \
			    &wdt_nrfx_driver_api)

#ifdef CONFIG_NRFX_WDT0
WDT_NRFX_WDT_DEVICE(0);
   1a258:	b510      	push	{r4, lr}
   1a25a:	4604      	mov	r4, r0
   1a25c:	2200      	movs	r2, #0
   1a25e:	2101      	movs	r1, #1
   1a260:	2018      	movs	r0, #24
   1a262:	f000 fcd5 	bl	1ac10 <z_arm_irq_priority_set>
   1a266:	6860      	ldr	r0, [r4, #4]
   1a268:	4a05      	ldr	r2, [pc, #20]	; (1a280 <wdt_0_init+0x28>)
   1a26a:	f100 0108 	add.w	r1, r0, #8
   1a26e:	f011 f9b3 	bl	2b5d8 <nrfx_wdt_init>
   1a272:	4b04      	ldr	r3, [pc, #16]	; (1a284 <wdt_0_init+0x2c>)
   1a274:	4298      	cmp	r0, r3
   1a276:	bf14      	ite	ne
   1a278:	f06f 000f 	mvnne.w	r0, #15
   1a27c:	2000      	moveq	r0, #0
   1a27e:	bd10      	pop	{r4, pc}
   1a280:	0001a289 	.word	0x0001a289
   1a284:	0bad0000 	.word	0x0bad0000

0001a288 <wdt_0_event_handler>:
   1a288:	b538      	push	{r3, r4, r5, lr}
	for (i = 0; i < get_dev_data(dev)->m_allocated_channels; ++i) {
   1a28a:	2400      	movs	r4, #0
   1a28c:	4d0a      	ldr	r5, [pc, #40]	; (1a2b8 <wdt_0_event_handler+0x30>)
   1a28e:	68ea      	ldr	r2, [r5, #12]
   1a290:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   1a294:	429c      	cmp	r4, r3
   1a296:	db00      	blt.n	1a29a <wdt_0_event_handler+0x12>
WDT_NRFX_WDT_DEVICE(0);
   1a298:	bd38      	pop	{r3, r4, r5, pc}
		if (nrf_wdt_request_status(get_dev_config(dev)->wdt.p_reg,
   1a29a:	686b      	ldr	r3, [r5, #4]
   1a29c:	681b      	ldr	r3, [r3, #0]
}

NRF_STATIC_INLINE bool nrf_wdt_request_status(NRF_WDT_Type const *  p_reg,
                                              nrf_wdt_rr_register_t rr_register)
{
    return (bool)(((p_reg->REQSTATUS) >> rr_register) & 0x1UL);
   1a29e:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
   1a2a2:	40e3      	lsrs	r3, r4
   1a2a4:	07db      	lsls	r3, r3, #31
   1a2a6:	d505      	bpl.n	1a2b4 <wdt_0_event_handler+0x2c>
			if (get_dev_data(dev)->m_callbacks[i]) {
   1a2a8:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   1a2ac:	b113      	cbz	r3, 1a2b4 <wdt_0_event_handler+0x2c>
				get_dev_data(dev)->m_callbacks[i](dev, i);
   1a2ae:	4621      	mov	r1, r4
   1a2b0:	4628      	mov	r0, r5
   1a2b2:	4798      	blx	r3
	for (i = 0; i < get_dev_data(dev)->m_allocated_channels; ++i) {
   1a2b4:	3401      	adds	r4, #1
   1a2b6:	e7ea      	b.n	1a28e <wdt_0_event_handler+0x6>
   1a2b8:	20020514 	.word	0x20020514

0001a2bc <z_clock_isr>:
#include <drivers/timer/system_timer.h>

/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
   1a2bc:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(false);
   1a2be:	4c06      	ldr	r4, [pc, #24]	; (1a2d8 <z_clock_isr+0x1c>)
   1a2c0:	4906      	ldr	r1, [pc, #24]	; (1a2dc <z_clock_isr+0x20>)
   1a2c2:	4622      	mov	r2, r4
   1a2c4:	4806      	ldr	r0, [pc, #24]	; (1a2e0 <z_clock_isr+0x24>)
   1a2c6:	2317      	movs	r3, #23
   1a2c8:	f019 f97e 	bl	335c8 <printk>
   1a2cc:	4620      	mov	r0, r4
}
   1a2ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT_NO_MSG(false);
   1a2d2:	2117      	movs	r1, #23
   1a2d4:	f019 bc79 	b.w	33bca <assert_post_action>
   1a2d8:	0003ce4e 	.word	0x0003ce4e
   1a2dc:	0003fd3b 	.word	0x0003fd3b
   1a2e0:	0003b77f 	.word	0x0003b77f

0001a2e4 <handle_next_tick_case>:
 * counter progresses during that time it means that 1 tick elapsed and
 * interrupt is set pending.
 */
static void handle_next_tick_case(u32_t t)
{
	set_comparator(t + 2);
   1a2e4:	1c82      	adds	r2, r0, #2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
   1a2e6:	4b08      	ldr	r3, [pc, #32]	; (1a308 <handle_next_tick_case+0x24>)
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   1a2e8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   1a2ec:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
   1a2f0:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	while (t != counter()) {
   1a2f4:	4290      	cmp	r0, r2
   1a2f6:	d100      	bne.n	1a2fa <handle_next_tick_case+0x16>
		 * generated. Trigger interrupt.
		 */
		t = counter();
		set_comparator(t + 2);
	}
}
   1a2f8:	4770      	bx	lr
   1a2fa:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		set_comparator(t + 2);
   1a2fe:	1c82      	adds	r2, r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   1a300:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
   1a304:	e7f2      	b.n	1a2ec <handle_next_tick_case+0x8>
   1a306:	bf00      	nop
   1a308:	40015000 	.word	0x40015000

0001a30c <rtc1_nrf_isr>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a30c:	2200      	movs	r2, #0
   1a30e:	4b06      	ldr	r3, [pc, #24]	; (1a328 <rtc1_nrf_isr+0x1c>)
   1a310:	601a      	str	r2, [r3, #0]
{
	ARG_UNUSED(arg);
	event_clear();

	u32_t t = get_comparator();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
   1a312:	4a06      	ldr	r2, [pc, #24]	; (1a32c <rtc1_nrf_isr+0x20>)
    return p_reg->CC[ch];
   1a314:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
   1a318:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
   1a31a:	1ac0      	subs	r0, r0, r3
   1a31c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
   1a320:	4403      	add	r3, r0
   1a322:	6013      	str	r3, [r2, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
   1a324:	f014 bc38 	b.w	2eb98 <z_clock_announce>
   1a328:	40015140 	.word	0x40015140
   1a32c:	20021768 	.word	0x20021768

0001a330 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
   1a330:	b538      	push	{r3, r4, r5, lr}
   1a332:	4814      	ldr	r0, [pc, #80]	; (1a384 <z_clock_driver_init+0x54>)
   1a334:	f011 fa6e 	bl	2b814 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
   1a338:	b300      	cbz	r0, 1a37c <z_clock_driver_init+0x4c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
   1a33a:	6883      	ldr	r3, [r0, #8]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
   1a33c:	2400      	movs	r4, #0
   1a33e:	681b      	ldr	r3, [r3, #0]
   1a340:	2101      	movs	r1, #1
   1a342:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1a344:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   1a348:	4d0f      	ldr	r5, [pc, #60]	; (1a388 <z_clock_driver_init+0x58>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a34a:	4b10      	ldr	r3, [pc, #64]	; (1a38c <z_clock_driver_init+0x5c>)
    p_reg->PRESCALER = val;
   1a34c:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a350:	601c      	str	r4, [r3, #0]
   1a352:	4b0f      	ldr	r3, [pc, #60]	; (1a390 <z_clock_driver_init+0x60>)
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
   1a354:	2101      	movs	r1, #1
   1a356:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    p_reg->INTENSET = mask;
   1a35a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   1a35e:	4622      	mov	r2, r4
   1a360:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
   1a364:	2015      	movs	r0, #21
   1a366:	f000 fc53 	bl	1ac10 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
   1a36a:	2015      	movs	r0, #21
   1a36c:	f000 fc40 	bl	1abf0 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
   1a370:	2301      	movs	r3, #1

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
   1a372:	4620      	mov	r0, r4
   1a374:	4a07      	ldr	r2, [pc, #28]	; (1a394 <z_clock_driver_init+0x64>)
   1a376:	6013      	str	r3, [r2, #0]
   1a378:	602b      	str	r3, [r5, #0]
}
   1a37a:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
   1a37c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1a380:	e7fb      	b.n	1a37a <z_clock_driver_init+0x4a>
   1a382:	bf00      	nop
   1a384:	0003ce1b 	.word	0x0003ce1b
   1a388:	40015000 	.word	0x40015000
   1a38c:	40015140 	.word	0x40015140
   1a390:	e000e100 	.word	0xe000e100
   1a394:	40015008 	.word	0x40015008

0001a398 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
   1a398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     return p_reg->COUNTER;
   1a39a:	4b2c      	ldr	r3, [pc, #176]	; (1a44c <z_clock_set_timeout+0xb4>)

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   1a39c:	4c2c      	ldr	r4, [pc, #176]	; (1a450 <z_clock_set_timeout+0xb8>)
   1a39e:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	u32_t unannounced = counter_sub(counter(), last_count);
   1a3a2:	4b2c      	ldr	r3, [pc, #176]	; (1a454 <z_clock_set_timeout+0xbc>)
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
   1a3a4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   1a3a8:	bf08      	it	eq
   1a3aa:	4620      	moveq	r0, r4
	u32_t unannounced = counter_sub(counter(), last_count);
   1a3ac:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
   1a3ae:	1a52      	subs	r2, r2, r1
   1a3b0:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
   1a3b4:	0212      	lsls	r2, r2, #8
   1a3b6:	d436      	bmi.n	1a426 <z_clock_set_timeout+0x8e>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
   1a3b8:	3801      	subs	r0, #1
   1a3ba:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   1a3be:	42a0      	cmp	r0, r4
   1a3c0:	bfa8      	it	ge
   1a3c2:	4620      	movge	r0, r4
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
   1a3c4:	3301      	adds	r3, #1
   1a3c6:	4418      	add	r0, r3
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
   1a3c8:	42a0      	cmp	r0, r4
   1a3ca:	bf94      	ite	ls
   1a3cc:	180c      	addls	r4, r1, r0
   1a3ce:	190c      	addhi	r4, r1, r4
    p_reg->INTENCLR = mask;
   1a3d0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a3d4:	2700      	movs	r7, #0
    p_reg->INTENCLR = mask;
   1a3d6:	4b1d      	ldr	r3, [pc, #116]	; (1a44c <z_clock_set_timeout+0xb4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a3d8:	4e1f      	ldr	r6, [pc, #124]	; (1a458 <z_clock_set_timeout+0xc0>)
    p_reg->INTENCLR = mask;
   1a3da:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
     return p_reg->COUNTER;
   1a3de:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
    return p_reg->CC[ch];
   1a3e2:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   1a3e6:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	return (a - b) & COUNTER_MAX;
   1a3ea:	1a52      	subs	r2, r2, r1
   1a3ec:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
	if (counter_sub(prev_val, now) == 1) {
   1a3f0:	2a01      	cmp	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a3f2:	6037      	str	r7, [r6, #0]
    p_reg->CC[ch] = cc_val;
   1a3f4:	f8c3 5540 	str.w	r5, [r3, #1344]	; 0x540
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
   1a3f8:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
	return (a - b) & COUNTER_MAX;
   1a3fc:	461d      	mov	r5, r3
	if (counter_sub(prev_val, now) == 1) {
   1a3fe:	d103      	bne.n	1a408 <z_clock_set_timeout+0x70>
	z_impl_k_busy_wait(usec_to_wait);
   1a400:	200f      	movs	r0, #15
   1a402:	f01e fca4 	bl	38d4e <z_impl_k_busy_wait>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
   1a406:	6037      	str	r7, [r6, #0]
   1a408:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   1a40c:	4b13      	ldr	r3, [pc, #76]	; (1a45c <z_clock_set_timeout+0xc4>)
   1a40e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     return p_reg->COUNTER;
   1a412:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   1a416:	1a23      	subs	r3, r4, r0
   1a418:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (diff == 1) {
   1a41c:	2b01      	cmp	r3, #1
   1a41e:	d104      	bne.n	1a42a <z_clock_set_timeout+0x92>
		handle_next_tick_case(t);
   1a420:	f7ff ff60 	bl	1a2e4 <handle_next_tick_case>
   1a424:	e00b      	b.n	1a43e <z_clock_set_timeout+0xa6>
		ticks = 0;
   1a426:	2000      	movs	r0, #0
   1a428:	e7cc      	b.n	1a3c4 <z_clock_set_timeout+0x2c>
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
   1a42a:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
   1a42e:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
     return p_reg->COUNTER;
   1a432:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
   1a436:	1a24      	subs	r4, r4, r0
   1a438:	3c02      	subs	r4, #2
	if (diff > MAX_TICKS) {
   1a43a:	0223      	lsls	r3, r4, #8
   1a43c:	d4f0      	bmi.n	1a420 <z_clock_set_timeout+0x88>
    p_reg->INTENSET = mask;
   1a43e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   1a442:	4b02      	ldr	r3, [pc, #8]	; (1a44c <z_clock_set_timeout+0xb4>)
   1a444:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	set_protected_absolute_ticks(cyc);
}
   1a448:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1a44a:	bf00      	nop
   1a44c:	40015000 	.word	0x40015000
   1a450:	007fffff 	.word	0x007fffff
   1a454:	20021768 	.word	0x20021768
   1a458:	40015140 	.word	0x40015140
   1a45c:	e000e100 	.word	0xe000e100

0001a460 <z_clock_elapsed>:

u32_t z_clock_elapsed(void)
{
   1a460:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1a462:	f04f 0320 	mov.w	r3, #32
   1a466:	f3ef 8511 	mrs	r5, BASEPRI
   1a46a:	f383 8811 	msr	BASEPRI, r3
   1a46e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1a472:	481a      	ldr	r0, [pc, #104]	; (1a4dc <z_clock_elapsed+0x7c>)
   1a474:	f014 f834 	bl	2e4e0 <z_spin_lock_valid>
   1a478:	b968      	cbnz	r0, 1a496 <z_clock_elapsed+0x36>
   1a47a:	235c      	movs	r3, #92	; 0x5c
   1a47c:	4a18      	ldr	r2, [pc, #96]	; (1a4e0 <z_clock_elapsed+0x80>)
   1a47e:	4919      	ldr	r1, [pc, #100]	; (1a4e4 <z_clock_elapsed+0x84>)
   1a480:	4819      	ldr	r0, [pc, #100]	; (1a4e8 <z_clock_elapsed+0x88>)
   1a482:	f019 f8a1 	bl	335c8 <printk>
   1a486:	4915      	ldr	r1, [pc, #84]	; (1a4dc <z_clock_elapsed+0x7c>)
   1a488:	4818      	ldr	r0, [pc, #96]	; (1a4ec <z_clock_elapsed+0x8c>)
   1a48a:	f019 f89d 	bl	335c8 <printk>
   1a48e:	215c      	movs	r1, #92	; 0x5c
   1a490:	4813      	ldr	r0, [pc, #76]	; (1a4e0 <z_clock_elapsed+0x80>)
   1a492:	f019 fb9a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   1a496:	4811      	ldr	r0, [pc, #68]	; (1a4dc <z_clock_elapsed+0x7c>)
   1a498:	f014 f840 	bl	2e51c <z_spin_lock_set_owner>
     return p_reg->COUNTER;
   1a49c:	4b14      	ldr	r3, [pc, #80]	; (1a4f0 <z_clock_elapsed+0x90>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1a49e:	480f      	ldr	r0, [pc, #60]	; (1a4dc <z_clock_elapsed+0x7c>)
   1a4a0:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
   1a4a4:	4b13      	ldr	r3, [pc, #76]	; (1a4f4 <z_clock_elapsed+0x94>)
	return (a - b) & COUNTER_MAX;
   1a4a6:	681b      	ldr	r3, [r3, #0]
   1a4a8:	1ae4      	subs	r4, r4, r3
   1a4aa:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
   1a4ae:	f014 f825 	bl	2e4fc <z_spin_unlock_valid>
   1a4b2:	b968      	cbnz	r0, 1a4d0 <z_clock_elapsed+0x70>
   1a4b4:	2384      	movs	r3, #132	; 0x84
   1a4b6:	4a0a      	ldr	r2, [pc, #40]	; (1a4e0 <z_clock_elapsed+0x80>)
   1a4b8:	490f      	ldr	r1, [pc, #60]	; (1a4f8 <z_clock_elapsed+0x98>)
   1a4ba:	480b      	ldr	r0, [pc, #44]	; (1a4e8 <z_clock_elapsed+0x88>)
   1a4bc:	f019 f884 	bl	335c8 <printk>
   1a4c0:	4906      	ldr	r1, [pc, #24]	; (1a4dc <z_clock_elapsed+0x7c>)
   1a4c2:	480e      	ldr	r0, [pc, #56]	; (1a4fc <z_clock_elapsed+0x9c>)
   1a4c4:	f019 f880 	bl	335c8 <printk>
   1a4c8:	2184      	movs	r1, #132	; 0x84
   1a4ca:	4805      	ldr	r0, [pc, #20]	; (1a4e0 <z_clock_elapsed+0x80>)
   1a4cc:	f019 fb7d 	bl	33bca <assert_post_action>
	__asm__ volatile(
   1a4d0:	f385 8811 	msr	BASEPRI, r5
   1a4d4:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   1a4d8:	4620      	mov	r0, r4
   1a4da:	bd38      	pop	{r3, r4, r5, pc}
   1a4dc:	2002176c 	.word	0x2002176c
   1a4e0:	0003c751 	.word	0x0003c751
   1a4e4:	0003c777 	.word	0x0003c777
   1a4e8:	0003b77f 	.word	0x0003b77f
   1a4ec:	0003c78c 	.word	0x0003c78c
   1a4f0:	40015000 	.word	0x40015000
   1a4f4:	20021768 	.word	0x20021768
   1a4f8:	0003c7a4 	.word	0x0003c7a4
   1a4fc:	0003c7bb 	.word	0x0003c7bb

0001a500 <z_timer_cycle_get_32>:

u32_t z_timer_cycle_get_32(void)
{
   1a500:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   1a502:	f04f 0320 	mov.w	r3, #32
   1a506:	f3ef 8511 	mrs	r5, BASEPRI
   1a50a:	f383 8811 	msr	BASEPRI, r3
   1a50e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   1a512:	481b      	ldr	r0, [pc, #108]	; (1a580 <z_timer_cycle_get_32+0x80>)
   1a514:	f013 ffe4 	bl	2e4e0 <z_spin_lock_valid>
   1a518:	b968      	cbnz	r0, 1a536 <z_timer_cycle_get_32+0x36>
   1a51a:	235c      	movs	r3, #92	; 0x5c
   1a51c:	4a19      	ldr	r2, [pc, #100]	; (1a584 <z_timer_cycle_get_32+0x84>)
   1a51e:	491a      	ldr	r1, [pc, #104]	; (1a588 <z_timer_cycle_get_32+0x88>)
   1a520:	481a      	ldr	r0, [pc, #104]	; (1a58c <z_timer_cycle_get_32+0x8c>)
   1a522:	f019 f851 	bl	335c8 <printk>
   1a526:	4916      	ldr	r1, [pc, #88]	; (1a580 <z_timer_cycle_get_32+0x80>)
   1a528:	4819      	ldr	r0, [pc, #100]	; (1a590 <z_timer_cycle_get_32+0x90>)
   1a52a:	f019 f84d 	bl	335c8 <printk>
   1a52e:	215c      	movs	r1, #92	; 0x5c
   1a530:	4814      	ldr	r0, [pc, #80]	; (1a584 <z_timer_cycle_get_32+0x84>)
   1a532:	f019 fb4a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   1a536:	4812      	ldr	r0, [pc, #72]	; (1a580 <z_timer_cycle_get_32+0x80>)
   1a538:	f013 fff0 	bl	2e51c <z_spin_lock_set_owner>
   1a53c:	4b15      	ldr	r3, [pc, #84]	; (1a594 <z_timer_cycle_get_32+0x94>)
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   1a53e:	4810      	ldr	r0, [pc, #64]	; (1a580 <z_timer_cycle_get_32+0x80>)
   1a540:	f8d3 4504 	ldr.w	r4, [r3, #1284]	; 0x504
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   1a544:	4b14      	ldr	r3, [pc, #80]	; (1a598 <z_timer_cycle_get_32+0x98>)
   1a546:	681b      	ldr	r3, [r3, #0]
	return (a - b) & COUNTER_MAX;
   1a548:	1ae4      	subs	r4, r4, r3
   1a54a:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	u32_t ret = counter_sub(counter(), last_count) + last_count;
   1a54e:	441c      	add	r4, r3
   1a550:	f013 ffd4 	bl	2e4fc <z_spin_unlock_valid>
   1a554:	b968      	cbnz	r0, 1a572 <z_timer_cycle_get_32+0x72>
   1a556:	2384      	movs	r3, #132	; 0x84
   1a558:	4a0a      	ldr	r2, [pc, #40]	; (1a584 <z_timer_cycle_get_32+0x84>)
   1a55a:	4910      	ldr	r1, [pc, #64]	; (1a59c <z_timer_cycle_get_32+0x9c>)
   1a55c:	480b      	ldr	r0, [pc, #44]	; (1a58c <z_timer_cycle_get_32+0x8c>)
   1a55e:	f019 f833 	bl	335c8 <printk>
   1a562:	4907      	ldr	r1, [pc, #28]	; (1a580 <z_timer_cycle_get_32+0x80>)
   1a564:	480e      	ldr	r0, [pc, #56]	; (1a5a0 <z_timer_cycle_get_32+0xa0>)
   1a566:	f019 f82f 	bl	335c8 <printk>
   1a56a:	2184      	movs	r1, #132	; 0x84
   1a56c:	4805      	ldr	r0, [pc, #20]	; (1a584 <z_timer_cycle_get_32+0x84>)
   1a56e:	f019 fb2c 	bl	33bca <assert_post_action>
	__asm__ volatile(
   1a572:	f385 8811 	msr	BASEPRI, r5
   1a576:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   1a57a:	4620      	mov	r0, r4
   1a57c:	bd38      	pop	{r3, r4, r5, pc}
   1a57e:	bf00      	nop
   1a580:	2002176c 	.word	0x2002176c
   1a584:	0003c751 	.word	0x0003c751
   1a588:	0003c777 	.word	0x0003c777
   1a58c:	0003b77f 	.word	0x0003b77f
   1a590:	0003c78c 	.word	0x0003c78c
   1a594:	40015000 	.word	0x40015000
   1a598:	20021768 	.word	0x20021768
   1a59c:	0003c7a4 	.word	0x0003c7a4
   1a5a0:	0003c7bb 	.word	0x0003c7bb

0001a5a4 <uECC_set_rng>:
static uECC_RNG_Function g_rng_function = 0;
#endif

void uECC_set_rng(uECC_RNG_Function rng_function)
{
	g_rng_function = rng_function;
   1a5a4:	4b01      	ldr	r3, [pc, #4]	; (1a5ac <uECC_set_rng+0x8>)
   1a5a6:	6018      	str	r0, [r3, #0]
}
   1a5a8:	4770      	bx	lr
   1a5aa:	bf00      	nop
   1a5ac:	200200ac 	.word	0x200200ac

0001a5b0 <uECC_get_rng>:

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
   1a5b0:	4b01      	ldr	r3, [pc, #4]	; (1a5b8 <uECC_get_rng+0x8>)
   1a5b2:	6818      	ldr	r0, [r3, #0]
   1a5b4:	4770      	bx	lr
   1a5b6:	bf00      	nop
   1a5b8:	200200ac 	.word	0x200200ac

0001a5bc <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
   1a5bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
   1a5be:	2208      	movs	r2, #8
{
   1a5c0:	b089      	sub	sp, #36	; 0x24
   1a5c2:	460c      	mov	r4, r1
   1a5c4:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
   1a5c6:	f01a f82c 	bl	34622 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
   1a5ca:	2700      	movs	r7, #0
	tmp[3] = product[11];
   1a5cc:	6acb      	ldr	r3, [r1, #44]	; 0x2c
	tmp[4] = product[12];
	tmp[5] = product[13];
	tmp[6] = product[14];
	tmp[7] = product[15];
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a5ce:	466a      	mov	r2, sp
	tmp[3] = product[11];
   1a5d0:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
   1a5d2:	6b0b      	ldr	r3, [r1, #48]	; 0x30
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a5d4:	4668      	mov	r0, sp
	tmp[4] = product[12];
   1a5d6:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
   1a5d8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	tmp[0] = tmp[1] = tmp[2] = 0;
   1a5da:	e9cd 7701 	strd	r7, r7, [sp, #4]
	tmp[5] = product[13];
   1a5de:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
   1a5e0:	6b8b      	ldr	r3, [r1, #56]	; 0x38
	tmp[0] = tmp[1] = tmp[2] = 0;
   1a5e2:	9700      	str	r7, [sp, #0]
	tmp[6] = product[14];
   1a5e4:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
   1a5e6:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a5e8:	4669      	mov	r1, sp
	tmp[7] = product[15];
   1a5ea:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a5ec:	2308      	movs	r3, #8
   1a5ee:	f019 ff1d 	bl	3442c <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a5f2:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a5f4:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a5f6:	466a      	mov	r2, sp
   1a5f8:	4631      	mov	r1, r6
   1a5fa:	4630      	mov	r0, r6
   1a5fc:	f019 ff16 	bl	3442c <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
   1a600:	6b23      	ldr	r3, [r4, #48]	; 0x30
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a602:	4405      	add	r5, r0
	tmp[3] = product[12];
   1a604:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
   1a606:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[5] = product[14];
	tmp[6] = product[15];
	tmp[7] = 0;
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a608:	466a      	mov	r2, sp
	tmp[4] = product[13];
   1a60a:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
   1a60c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a60e:	4669      	mov	r1, sp
	tmp[5] = product[14];
   1a610:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
   1a612:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a614:	4668      	mov	r0, sp
	tmp[7] = 0;
   1a616:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a61a:	2308      	movs	r3, #8
   1a61c:	f019 ff06 	bl	3442c <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a620:	4631      	mov	r1, r6
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
   1a622:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a624:	2308      	movs	r3, #8
   1a626:	466a      	mov	r2, sp
   1a628:	4630      	mov	r0, r6
   1a62a:	f019 feff 	bl	3442c <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
   1a62e:	6a23      	ldr	r3, [r4, #32]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a630:	4405      	add	r5, r0
	tmp[0] = product[8];
   1a632:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
   1a634:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[2] = product[10];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
	tmp[7] = product[15];
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a636:	466a      	mov	r2, sp
	tmp[1] = product[9];
   1a638:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
   1a63a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a63c:	4630      	mov	r0, r6
	tmp[2] = product[10];
   1a63e:	9302      	str	r3, [sp, #8]
	tmp[6] = product[14];
   1a640:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[3] = tmp[4] = tmp[5] = 0;
   1a642:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[14];
   1a646:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
   1a648:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = tmp[4] = tmp[5] = 0;
   1a64a:	9703      	str	r7, [sp, #12]
	tmp[7] = product[15];
   1a64c:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a64e:	2308      	movs	r3, #8
   1a650:	f019 feec 	bl	3442c <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
   1a654:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[1] = product[10];
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
   1a656:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[0] = product[9];
   1a658:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
   1a65a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[4] = product[14];
   1a65c:	9204      	str	r2, [sp, #16]
	tmp[1] = product[10];
   1a65e:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
   1a660:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[5] = product[15];
   1a662:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[2] = product[11];
   1a664:	9302      	str	r3, [sp, #8]
	tmp[3] = product[13];
   1a666:	6b63      	ldr	r3, [r4, #52]	; 0x34
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a668:	4405      	add	r5, r0
	tmp[6] = product[13];
   1a66a:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[3] = product[13];
   1a66e:	9303      	str	r3, [sp, #12]
	tmp[7] = product[8];
   1a670:	6a23      	ldr	r3, [r4, #32]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a672:	466a      	mov	r2, sp
	tmp[7] = product[8];
   1a674:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a676:	4630      	mov	r0, r6
   1a678:	2308      	movs	r3, #8
   1a67a:	f019 fed7 	bl	3442c <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
   1a67e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
   1a680:	4405      	add	r5, r0
	tmp[0] = product[11];
   1a682:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
   1a684:	6b23      	ldr	r3, [r4, #48]	; 0x30
	tmp[2] = product[13];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
	tmp[7] = product[10];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a686:	466a      	mov	r2, sp
	tmp[1] = product[12];
   1a688:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
   1a68a:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a68c:	4630      	mov	r0, r6
	tmp[2] = product[13];
   1a68e:	9302      	str	r3, [sp, #8]
	tmp[6] = product[8];
   1a690:	6a23      	ldr	r3, [r4, #32]
	tmp[3] = tmp[4] = tmp[5] = 0;
   1a692:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[8];
   1a696:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
   1a698:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[3] = tmp[4] = tmp[5] = 0;
   1a69a:	9703      	str	r7, [sp, #12]
	tmp[7] = product[10];
   1a69c:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a69e:	2308      	movs	r3, #8
   1a6a0:	f019 ffe2 	bl	34668 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
   1a6a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6a6:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[12];
   1a6a8:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
   1a6aa:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[2] = product[14];
	tmp[3] = product[15];
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
	tmp[7] = product[11];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6ac:	466a      	mov	r2, sp
	tmp[1] = product[13];
   1a6ae:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
   1a6b0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6b2:	4630      	mov	r0, r6
	tmp[2] = product[14];
   1a6b4:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
   1a6b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[4] = tmp[5] = 0;
   1a6b8:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[3] = product[15];
   1a6bc:	9303      	str	r3, [sp, #12]
	tmp[6] = product[9];
   1a6be:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1a6c0:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
   1a6c2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   1a6c4:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6c6:	2308      	movs	r3, #8
   1a6c8:	f019 ffce 	bl	34668 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
   1a6cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6ce:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[13];
   1a6d0:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
   1a6d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[3] = product[8];
	tmp[4] = product[9];
	tmp[5] = product[10];
	tmp[6] = 0;
	tmp[7] = product[12];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6d4:	466a      	mov	r2, sp
	tmp[1] = product[14];
   1a6d6:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
   1a6d8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6da:	4630      	mov	r0, r6
	tmp[2] = product[15];
   1a6dc:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
   1a6de:	6a23      	ldr	r3, [r4, #32]
   1a6e0:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
   1a6e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   1a6e4:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
   1a6e6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
   1a6e8:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
   1a6ec:	6b23      	ldr	r3, [r4, #48]	; 0x30
   1a6ee:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6f0:	2308      	movs	r3, #8
   1a6f2:	f019 ffb9 	bl	34668 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
   1a6f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6f8:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[14];
   1a6fa:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
   1a6fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = product[9];
	tmp[4] = product[10];
	tmp[5] = product[11];
	tmp[6] = 0;
	tmp[7] = product[13];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a6fe:	466a      	mov	r2, sp
	tmp[2] = 0;
   1a700:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
   1a704:	6a63      	ldr	r3, [r4, #36]	; 0x24
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a706:	4630      	mov	r0, r6
	tmp[3] = product[9];
   1a708:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
   1a70a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   1a70c:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
   1a70e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
   1a710:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
   1a714:	6b63      	ldr	r3, [r4, #52]	; 0x34

	if (carry < 0) {
		do {
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
   1a716:	4c10      	ldr	r4, [pc, #64]	; (1a758 <vli_mmod_fast_secp256r1+0x19c>)
	tmp[7] = product[13];
   1a718:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
   1a71a:	2308      	movs	r3, #8
   1a71c:	f019 ffa4 	bl	34668 <uECC_vli_sub>
	if (carry < 0) {
   1a720:	1a2d      	subs	r5, r5, r0
   1a722:	d40f      	bmi.n	1a744 <vli_mmod_fast_secp256r1+0x188>
		}
		while (carry < 0);
	} else  {
		while (carry || 
   1a724:	b935      	cbnz	r5, 1a734 <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
   1a726:	2208      	movs	r2, #8
   1a728:	4631      	mov	r1, r6
   1a72a:	4620      	mov	r0, r4
   1a72c:	f019 ff85 	bl	3463a <uECC_vli_cmp_unsafe>
		while (carry || 
   1a730:	2801      	cmp	r0, #1
   1a732:	d00f      	beq.n	1a754 <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
   1a734:	2308      	movs	r3, #8
   1a736:	4622      	mov	r2, r4
   1a738:	4631      	mov	r1, r6
   1a73a:	4630      	mov	r0, r6
   1a73c:	f019 ff94 	bl	34668 <uECC_vli_sub>
   1a740:	1a2d      	subs	r5, r5, r0
   1a742:	e7ef      	b.n	1a724 <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
   1a744:	2308      	movs	r3, #8
   1a746:	4622      	mov	r2, r4
   1a748:	4631      	mov	r1, r6
   1a74a:	4630      	mov	r0, r6
   1a74c:	f019 fe6e 	bl	3442c <uECC_vli_add>
		while (carry < 0);
   1a750:	182d      	adds	r5, r5, r0
   1a752:	d4f7      	bmi.n	1a744 <vli_mmod_fast_secp256r1+0x188>
		}
	}
}
   1a754:	b009      	add	sp, #36	; 0x24
   1a756:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1a758:	0003a314 	.word	0x0003a314

0001a75c <tc_aes128_set_encrypt_key>:

#define subbyte(a, o)(sbox[((a) >> (o))&0xff] << (o))
#define subword(a)(subbyte(a, 24)|subbyte(a, 16)|subbyte(a, 8)|subbyte(a, 0))

int tc_aes128_set_encrypt_key(TCAesKeySched_t s, const uint8_t *k)
{
   1a75c:	b5f0      	push	{r4, r5, r6, r7, lr}
   1a75e:	4607      	mov	r7, r0
   1a760:	b08d      	sub	sp, #52	; 0x34
	const unsigned int rconst[11] = {
   1a762:	4e27      	ldr	r6, [pc, #156]	; (1a800 <tc_aes128_set_encrypt_key+0xa4>)
   1a764:	ad01      	add	r5, sp, #4
{
   1a766:	460c      	mov	r4, r1
	const unsigned int rconst[11] = {
   1a768:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   1a76a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1a76c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   1a76e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   1a770:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   1a774:	e885 0007 	stmia.w	r5, {r0, r1, r2}
		0x20000000, 0x40000000, 0x80000000, 0x1b000000, 0x36000000
	};
	unsigned int i;
	unsigned int t;

	if (s == (TCAesKeySched_t) 0) {
   1a778:	2f00      	cmp	r7, #0
   1a77a:	d03d      	beq.n	1a7f8 <tc_aes128_set_encrypt_key+0x9c>
		return TC_CRYPTO_FAIL;
	} else if (k == (const uint8_t *) 0) {
   1a77c:	2c00      	cmp	r4, #0
   1a77e:	d03d      	beq.n	1a7fc <tc_aes128_set_encrypt_key+0xa0>
   1a780:	1f38      	subs	r0, r7, #4
   1a782:	4602      	mov	r2, r0
   1a784:	4621      	mov	r1, r4
   1a786:	3410      	adds	r4, #16
		return TC_CRYPTO_FAIL;
	}

	for (i = 0; i < Nk; ++i) {
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   1a788:	784b      	ldrb	r3, [r1, #1]
   1a78a:	780d      	ldrb	r5, [r1, #0]
   1a78c:	041b      	lsls	r3, r3, #16
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   1a78e:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
   1a792:	78cd      	ldrb	r5, [r1, #3]
   1a794:	3104      	adds	r1, #4
   1a796:	432b      	orrs	r3, r5
   1a798:	f811 5c02 	ldrb.w	r5, [r1, #-2]
	for (i = 0; i < Nk; ++i) {
   1a79c:	428c      	cmp	r4, r1
			      (k[Nb*i+2]<<8) | (k[Nb*i+3]);
   1a79e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
		s->words[i] = (k[Nb*i]<<24) | (k[Nb*i+1]<<16) |
   1a7a2:	f842 3f04 	str.w	r3, [r2, #4]!
	for (i = 0; i < Nk; ++i) {
   1a7a6:	d1ef      	bne.n	1a788 <tc_aes128_set_encrypt_key+0x2c>
   1a7a8:	2104      	movs	r1, #4
	}

	for (; i < (Nb * (Nr + 1)); ++i) {
		t = s->words[i-1];
		if ((i % Nk) == 0) {
			t = subword(rotword(t)) ^ rconst[i/Nk];
   1a7aa:	4c16      	ldr	r4, [pc, #88]	; (1a804 <tc_aes128_set_encrypt_key+0xa8>)
		if ((i % Nk) == 0) {
   1a7ac:	078a      	lsls	r2, r1, #30
		t = s->words[i-1];
   1a7ae:	6903      	ldr	r3, [r0, #16]
		if ((i % Nk) == 0) {
   1a7b0:	d118      	bne.n	1a7e4 <tc_aes128_set_encrypt_key+0x88>
	return (((a) >> 24)|((a) << 8));
   1a7b2:	ea4f 6333 	mov.w	r3, r3, ror #24
			t = subword(rotword(t)) ^ rconst[i/Nk];
   1a7b6:	0e1a      	lsrs	r2, r3, #24
   1a7b8:	5ca5      	ldrb	r5, [r4, r2]
   1a7ba:	b2da      	uxtb	r2, r3
   1a7bc:	5ca2      	ldrb	r2, [r4, r2]
   1a7be:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
   1a7c2:	f3c3 4507 	ubfx	r5, r3, #16, #8
   1a7c6:	5d65      	ldrb	r5, [r4, r5]
   1a7c8:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1a7cc:	5ce3      	ldrb	r3, [r4, r3]
   1a7ce:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
   1a7d2:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   1a7d6:	ad0c      	add	r5, sp, #48	; 0x30
   1a7d8:	f021 0303 	bic.w	r3, r1, #3
   1a7dc:	442b      	add	r3, r5
   1a7de:	f853 3c2c 	ldr.w	r3, [r3, #-44]
   1a7e2:	4053      	eors	r3, r2
		}
		s->words[i] = s->words[i-Nk] ^ t;
   1a7e4:	f850 2f04 	ldr.w	r2, [r0, #4]!
	for (; i < (Nb * (Nr + 1)); ++i) {
   1a7e8:	3101      	adds	r1, #1
		s->words[i] = s->words[i-Nk] ^ t;
   1a7ea:	4053      	eors	r3, r2
	for (; i < (Nb * (Nr + 1)); ++i) {
   1a7ec:	292c      	cmp	r1, #44	; 0x2c
		s->words[i] = s->words[i-Nk] ^ t;
   1a7ee:	6103      	str	r3, [r0, #16]
	for (; i < (Nb * (Nr + 1)); ++i) {
   1a7f0:	d1dc      	bne.n	1a7ac <tc_aes128_set_encrypt_key+0x50>
	}

	return TC_CRYPTO_SUCCESS;
   1a7f2:	2001      	movs	r0, #1
}
   1a7f4:	b00d      	add	sp, #52	; 0x34
   1a7f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   1a7f8:	4638      	mov	r0, r7
   1a7fa:	e7fb      	b.n	1a7f4 <tc_aes128_set_encrypt_key+0x98>
   1a7fc:	4620      	mov	r0, r4
   1a7fe:	e7f9      	b.n	1a7f4 <tc_aes128_set_encrypt_key+0x98>
   1a800:	0003a0c0 	.word	0x0003a0c0
   1a804:	0003ce80 	.word	0x0003ce80

0001a808 <tc_aes_encrypt>:
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
	(void) _copy(s, sizeof(t), t, sizeof(t));
}

int tc_aes_encrypt(uint8_t *out, const uint8_t *in, const TCAesKeySched_t s)
{
   1a808:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1a80c:	4615      	mov	r5, r2
   1a80e:	b089      	sub	sp, #36	; 0x24
	uint8_t state[Nk*Nb];
	unsigned int i;

	if (out == (uint8_t *) 0) {
   1a810:	4607      	mov	r7, r0
   1a812:	2800      	cmp	r0, #0
   1a814:	d059      	beq.n	1a8ca <tc_aes_encrypt+0xc2>
		return TC_CRYPTO_FAIL;
	} else if (in == (const uint8_t *) 0) {
   1a816:	2900      	cmp	r1, #0
   1a818:	d05a      	beq.n	1a8d0 <tc_aes_encrypt+0xc8>
		return TC_CRYPTO_FAIL;
	} else if (s == (TCAesKeySched_t) 0) {
   1a81a:	2a00      	cmp	r2, #0
   1a81c:	d05a      	beq.n	1a8d4 <tc_aes_encrypt+0xcc>
		return TC_CRYPTO_FAIL;
	}

	(void)_copy(state, sizeof(state), in, sizeof(state));
   1a81e:	2310      	movs	r3, #16
   1a820:	460a      	mov	r2, r1
   1a822:	4668      	mov	r0, sp
   1a824:	4619      	mov	r1, r3
		s[i] = sbox[s[i]];
   1a826:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 1a8d8 <tc_aes_encrypt+0xd0>
	(void)_copy(state, sizeof(state), in, sizeof(state));
   1a82a:	f019 fcc1 	bl	341b0 <_copy>
	add_round_key(state, s->words);
   1a82e:	4629      	mov	r1, r5
   1a830:	4668      	mov	r0, sp
   1a832:	f01a fbd1 	bl	34fd8 <add_round_key>

	for (i = 0; i < (Nr - 1); ++i) {
   1a836:	46c8      	mov	r8, r9
   1a838:	f105 0610 	add.w	r6, r5, #16
   1a83c:	35a0      	adds	r5, #160	; 0xa0
   1a83e:	466c      	mov	r4, sp
{
   1a840:	466a      	mov	r2, sp
   1a842:	2310      	movs	r3, #16
		s[i] = sbox[s[i]];
   1a844:	7811      	ldrb	r1, [r2, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
   1a846:	3b01      	subs	r3, #1
		s[i] = sbox[s[i]];
   1a848:	f819 1001 	ldrb.w	r1, [r9, r1]
   1a84c:	f802 1b01 	strb.w	r1, [r2], #1
	for (i = 0; i < (Nb * Nk); ++i) {
   1a850:	d1f8      	bne.n	1a844 <tc_aes_encrypt+0x3c>
		sub_bytes(state);
		shift_rows(state);
   1a852:	4668      	mov	r0, sp
   1a854:	f01a fc05 	bl	35062 <shift_rows>
	mult_row_column(t, s);
   1a858:	4669      	mov	r1, sp
   1a85a:	a804      	add	r0, sp, #16
   1a85c:	f01a fc3a 	bl	350d4 <mult_row_column>
	mult_row_column(&t[Nb], s+Nb);
   1a860:	a901      	add	r1, sp, #4
   1a862:	a805      	add	r0, sp, #20
   1a864:	f01a fc36 	bl	350d4 <mult_row_column>
	mult_row_column(&t[2 * Nb], s + (2 * Nb));
   1a868:	a902      	add	r1, sp, #8
   1a86a:	a806      	add	r0, sp, #24
   1a86c:	f01a fc32 	bl	350d4 <mult_row_column>
	mult_row_column(&t[3 * Nb], s + (3 * Nb));
   1a870:	a903      	add	r1, sp, #12
   1a872:	a807      	add	r0, sp, #28
   1a874:	f01a fc2e 	bl	350d4 <mult_row_column>
	(void) _copy(s, sizeof(t), t, sizeof(t));
   1a878:	2310      	movs	r3, #16
   1a87a:	4668      	mov	r0, sp
   1a87c:	4619      	mov	r1, r3
   1a87e:	eb0d 0203 	add.w	r2, sp, r3
   1a882:	f019 fc95 	bl	341b0 <_copy>
		mix_columns(state);
		add_round_key(state, s->words + Nb*(i+1));
   1a886:	4631      	mov	r1, r6
   1a888:	4668      	mov	r0, sp
   1a88a:	3610      	adds	r6, #16
   1a88c:	f01a fba4 	bl	34fd8 <add_round_key>
	for (i = 0; i < (Nr - 1); ++i) {
   1a890:	42ae      	cmp	r6, r5
   1a892:	d1d4      	bne.n	1a83e <tc_aes_encrypt+0x36>
   1a894:	2610      	movs	r6, #16
		s[i] = sbox[s[i]];
   1a896:	7823      	ldrb	r3, [r4, #0]
	for (i = 0; i < (Nb * Nk); ++i) {
   1a898:	3e01      	subs	r6, #1
		s[i] = sbox[s[i]];
   1a89a:	f818 3003 	ldrb.w	r3, [r8, r3]
   1a89e:	f804 3b01 	strb.w	r3, [r4], #1
	for (i = 0; i < (Nb * Nk); ++i) {
   1a8a2:	d1f8      	bne.n	1a896 <tc_aes_encrypt+0x8e>
	}

	sub_bytes(state);
	shift_rows(state);
   1a8a4:	4668      	mov	r0, sp
   1a8a6:	f01a fbdc 	bl	35062 <shift_rows>
	add_round_key(state, s->words + Nb*(i+1));
   1a8aa:	4629      	mov	r1, r5
   1a8ac:	4668      	mov	r0, sp
   1a8ae:	f01a fb93 	bl	34fd8 <add_round_key>

	(void)_copy(out, sizeof(state), state, sizeof(state));
   1a8b2:	2310      	movs	r3, #16
   1a8b4:	466a      	mov	r2, sp
   1a8b6:	4619      	mov	r1, r3
   1a8b8:	4638      	mov	r0, r7
   1a8ba:	f019 fc79 	bl	341b0 <_copy>

	/* zeroing out the state buffer */
	_set(state, TC_ZERO_BYTE, sizeof(state));
   1a8be:	4668      	mov	r0, sp
   1a8c0:	2210      	movs	r2, #16
   1a8c2:	4631      	mov	r1, r6
   1a8c4:	f019 fc81 	bl	341ca <_set>

	return TC_CRYPTO_SUCCESS;
   1a8c8:	2001      	movs	r0, #1
}
   1a8ca:	b009      	add	sp, #36	; 0x24
   1a8cc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return TC_CRYPTO_FAIL;
   1a8d0:	4608      	mov	r0, r1
   1a8d2:	e7fa      	b.n	1a8ca <tc_aes_encrypt+0xc2>
   1a8d4:	4610      	mov	r0, r2
   1a8d6:	e7f8      	b.n	1a8ca <tc_aes_encrypt+0xc2>
   1a8d8:	0003ce80 	.word	0x0003ce80

0001a8dc <compress>:
	n |= ((unsigned int)(*((*c)++)));
	return n;
}

static void compress(unsigned int *iv, const uint8_t *data)
{
   1a8dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int t1, t2;
	unsigned int work_space[16];
	unsigned int n;
	unsigned int i;

	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a8e0:	6803      	ldr	r3, [r0, #0]
{
   1a8e2:	b09d      	sub	sp, #116	; 0x74
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a8e4:	9302      	str	r3, [sp, #8]
   1a8e6:	6843      	ldr	r3, [r0, #4]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
   1a8e8:	2700      	movs	r7, #0
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a8ea:	9303      	str	r3, [sp, #12]
   1a8ec:	6883      	ldr	r3, [r0, #8]
{
   1a8ee:	9100      	str	r1, [sp, #0]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a8f0:	9304      	str	r3, [sp, #16]
   1a8f2:	68c3      	ldr	r3, [r0, #12]
   1a8f4:	4965      	ldr	r1, [pc, #404]	; (1aa8c <compress+0x1b0>)
   1a8f6:	9305      	str	r3, [sp, #20]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
   1a8f8:	6903      	ldr	r3, [r0, #16]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a8fa:	9c02      	ldr	r4, [sp, #8]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
   1a8fc:	9306      	str	r3, [sp, #24]
   1a8fe:	6943      	ldr	r3, [r0, #20]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a900:	e9dd e205 	ldrd	lr, r2, [sp, #20]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
   1a904:	9307      	str	r3, [sp, #28]
   1a906:	6983      	ldr	r3, [r0, #24]
	a = iv[0]; b = iv[1]; c = iv[2]; d = iv[3];
   1a908:	e9dd 6a03 	ldrd	r6, sl, [sp, #12]
	e = iv[4]; f = iv[5]; g = iv[6]; h = iv[7];
   1a90c:	9308      	str	r3, [sp, #32]
   1a90e:	69c3      	ldr	r3, [r0, #28]
   1a910:	e9dd cb07 	ldrd	ip, fp, [sp, #28]
   1a914:	4698      	mov	r8, r3
   1a916:	9309      	str	r3, [sp, #36]	; 0x24
	n = (((unsigned int)(*((*c)++))) << 24);
   1a918:	9b00      	ldr	r3, [sp, #0]
   1a91a:	59dd      	ldr	r5, [r3, r7]

	for (i = 0; i < 16; ++i) {
		n = BigEndian(&data);
		t1 = work_space[i] = n;
   1a91c:	ab0c      	add	r3, sp, #48	; 0x30
   1a91e:	ba2d      	rev	r5, r5
   1a920:	51dd      	str	r5, [r3, r7]
	return (((a) >> n) | ((a) << (32 - n)));
   1a922:	f851 3b04 	ldr.w	r3, [r1], #4
   1a926:	3704      	adds	r7, #4
   1a928:	eb05 0903 	add.w	r9, r5, r3
   1a92c:	ea4f 25f2 	mov.w	r5, r2, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
   1a930:	ea85 15b2 	eor.w	r5, r5, r2, ror #6
   1a934:	ea85 6572 	eor.w	r5, r5, r2, ror #25
   1a938:	444d      	add	r5, r9
   1a93a:	ea2b 0302 	bic.w	r3, fp, r2
   1a93e:	ea02 090c 	and.w	r9, r2, ip
   1a942:	ea83 0309 	eor.w	r3, r3, r9
   1a946:	442b      	add	r3, r5
   1a948:	4443      	add	r3, r8
		t2 = Sigma0(a) + Maj(a, b, c);
   1a94a:	ea86 050a 	eor.w	r5, r6, sl
	return (((a) >> n) | ((a) << (32 - n)));
   1a94e:	ea4f 3874 	mov.w	r8, r4, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
   1a952:	ea88 08b4 	eor.w	r8, r8, r4, ror #2
   1a956:	4025      	ands	r5, r4
   1a958:	ea06 090a 	and.w	r9, r6, sl
   1a95c:	ea85 0509 	eor.w	r5, r5, r9
   1a960:	ea88 58b4 	eor.w	r8, r8, r4, ror #22
   1a964:	44a8      	add	r8, r5
	for (i = 0; i < 16; ++i) {
   1a966:	2f40      	cmp	r7, #64	; 0x40
		h = g; g = f; f = e; e = d + t1;
   1a968:	eb03 050e 	add.w	r5, r3, lr
		d = c; c = b; b = a; a = t1 + t2;
   1a96c:	4443      	add	r3, r8
   1a96e:	46d6      	mov	lr, sl
   1a970:	46d8      	mov	r8, fp
	for (i = 0; i < 16; ++i) {
   1a972:	d17d      	bne.n	1aa70 <compress+0x194>
   1a974:	4946      	ldr	r1, [pc, #280]	; (1aa90 <compress+0x1b4>)
   1a976:	910a      	str	r1, [sp, #40]	; 0x28
   1a978:	2110      	movs	r1, #16
	}

	for ( ; i < 64; ++i) {
		s0 = work_space[(i+1)&0x0f];
   1a97a:	1c4f      	adds	r7, r1, #1
   1a97c:	f10d 0e70 	add.w	lr, sp, #112	; 0x70
   1a980:	970b      	str	r7, [sp, #44]	; 0x2c
   1a982:	f007 070f 	and.w	r7, r7, #15
   1a986:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
   1a98a:	f857 7c40 	ldr.w	r7, [r7, #-64]
		s0 = sigma0(s0);
		s1 = work_space[(i+14)&0x0f];
		s1 = sigma1(s1);

		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a98e:	f001 090f 	and.w	r9, r1, #15
	return (((a) >> n) | ((a) << (32 - n)));
   1a992:	ea4f 48b7 	mov.w	r8, r7, ror #18
		s0 = work_space[(i+1)&0x0f];
   1a996:	9700      	str	r7, [sp, #0]
		s0 = sigma0(s0);
   1a998:	ea88 18f7 	eor.w	r8, r8, r7, ror #7
		s1 = work_space[(i+14)&0x0f];
   1a99c:	f101 070e 	add.w	r7, r1, #14
   1a9a0:	f007 070f 	and.w	r7, r7, #15
   1a9a4:	eb0e 0787 	add.w	r7, lr, r7, lsl #2
   1a9a8:	f857 7c40 	ldr.w	r7, [r7, #-64]
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a9ac:	3109      	adds	r1, #9
	return (((a) >> n) | ((a) << (32 - n)));
   1a9ae:	ea4f 4ef7 	mov.w	lr, r7, ror #19
		s1 = work_space[(i+14)&0x0f];
   1a9b2:	9701      	str	r7, [sp, #4]
		s1 = sigma1(s1);
   1a9b4:	ea8e 4e77 	eor.w	lr, lr, r7, ror #17
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a9b8:	f001 010f 	and.w	r1, r1, #15
   1a9bc:	af1c      	add	r7, sp, #112	; 0x70
   1a9be:	eb07 0989 	add.w	r9, r7, r9, lsl #2
   1a9c2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   1a9c6:	f851 1c40 	ldr.w	r1, [r1, #-64]
   1a9ca:	f859 7c40 	ldr.w	r7, [r9, #-64]
   1a9ce:	4439      	add	r1, r7
		s0 = sigma0(s0);
   1a9d0:	9f00      	ldr	r7, [sp, #0]
   1a9d2:	ea88 08d7 	eor.w	r8, r8, r7, lsr #3
		s1 = sigma1(s1);
   1a9d6:	9f01      	ldr	r7, [sp, #4]
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a9d8:	4441      	add	r1, r8
		s1 = sigma1(s1);
   1a9da:	ea8e 2e97 	eor.w	lr, lr, r7, lsr #10
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
   1a9de:	9f0a      	ldr	r7, [sp, #40]	; 0x28
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a9e0:	4471      	add	r1, lr
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
   1a9e2:	f857 eb04 	ldr.w	lr, [r7], #4
		t1 = work_space[i&0xf] += s0 + s1 + work_space[(i+9)&0xf];
   1a9e6:	f849 1c40 	str.w	r1, [r9, #-64]
	return (((a) >> n) | ((a) << (32 - n)));
   1a9ea:	ea4f 29f5 	mov.w	r9, r5, ror #11
		t1 += h + Sigma1(e) + Ch(e, f, g) + k256[i];
   1a9ee:	970a      	str	r7, [sp, #40]	; 0x28
   1a9f0:	ea89 19b5 	eor.w	r9, r9, r5, ror #6
   1a9f4:	ea2c 0705 	bic.w	r7, ip, r5
   1a9f8:	ea05 0802 	and.w	r8, r5, r2
   1a9fc:	ea89 6975 	eor.w	r9, r9, r5, ror #25
   1aa00:	ea87 0708 	eor.w	r7, r7, r8
   1aa04:	444f      	add	r7, r9
   1aa06:	4477      	add	r7, lr
   1aa08:	4439      	add	r1, r7
   1aa0a:	4459      	add	r1, fp
	return (((a) >> n) | ((a) << (32 - n)));
   1aa0c:	ea4f 3773 	mov.w	r7, r3, ror #13
		t2 = Sigma0(a) + Maj(a, b, c);
   1aa10:	ea84 0b06 	eor.w	fp, r4, r6
   1aa14:	ea0b 0b03 	and.w	fp, fp, r3
   1aa18:	ea87 07b3 	eor.w	r7, r7, r3, ror #2
   1aa1c:	ea04 0e06 	and.w	lr, r4, r6
   1aa20:	ea87 57b3 	eor.w	r7, r7, r3, ror #22
   1aa24:	ea8b 0e0e 	eor.w	lr, fp, lr
   1aa28:	44be      	add	lr, r7
		h = g; g = f; f = e; e = d + t1;
		d = c; c = b; b = a; a = t1 + t2;
   1aa2a:	448e      	add	lr, r1
		h = g; g = f; f = e; e = d + t1;
   1aa2c:	eb01 070a 	add.w	r7, r1, sl
		d = c; c = b; b = a; a = t1 + t2;
   1aa30:	990b      	ldr	r1, [sp, #44]	; 0x2c
   1aa32:	46b2      	mov	sl, r6
	for ( ; i < 64; ++i) {
   1aa34:	2940      	cmp	r1, #64	; 0x40
   1aa36:	46e3      	mov	fp, ip
   1aa38:	d121      	bne.n	1aa7e <compress+0x1a2>
	}

	iv[0] += a; iv[1] += b; iv[2] += c; iv[3] += d;
   1aa3a:	9902      	ldr	r1, [sp, #8]
   1aa3c:	4471      	add	r1, lr
   1aa3e:	6001      	str	r1, [r0, #0]
   1aa40:	9903      	ldr	r1, [sp, #12]
   1aa42:	4419      	add	r1, r3
   1aa44:	9b04      	ldr	r3, [sp, #16]
   1aa46:	6041      	str	r1, [r0, #4]
   1aa48:	4423      	add	r3, r4
   1aa4a:	6083      	str	r3, [r0, #8]
   1aa4c:	9b05      	ldr	r3, [sp, #20]
   1aa4e:	4433      	add	r3, r6
   1aa50:	60c3      	str	r3, [r0, #12]
	iv[4] += e; iv[5] += f; iv[6] += g; iv[7] += h;
   1aa52:	9b06      	ldr	r3, [sp, #24]
   1aa54:	443b      	add	r3, r7
   1aa56:	6103      	str	r3, [r0, #16]
   1aa58:	9b07      	ldr	r3, [sp, #28]
   1aa5a:	442b      	add	r3, r5
   1aa5c:	6143      	str	r3, [r0, #20]
   1aa5e:	9b08      	ldr	r3, [sp, #32]
   1aa60:	4413      	add	r3, r2
   1aa62:	6183      	str	r3, [r0, #24]
   1aa64:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1aa66:	4463      	add	r3, ip
   1aa68:	61c3      	str	r3, [r0, #28]
}
   1aa6a:	b01d      	add	sp, #116	; 0x74
   1aa6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1aa70:	46e3      	mov	fp, ip
   1aa72:	46b2      	mov	sl, r6
   1aa74:	4694      	mov	ip, r2
   1aa76:	4626      	mov	r6, r4
		h = g; g = f; f = e; e = d + t1;
   1aa78:	462a      	mov	r2, r5
		d = c; c = b; b = a; a = t1 + t2;
   1aa7a:	461c      	mov	r4, r3
   1aa7c:	e74c      	b.n	1a918 <compress+0x3c>
   1aa7e:	4694      	mov	ip, r2
   1aa80:	4626      	mov	r6, r4
   1aa82:	462a      	mov	r2, r5
   1aa84:	461c      	mov	r4, r3
		h = g; g = f; f = e; e = d + t1;
   1aa86:	463d      	mov	r5, r7
		d = c; c = b; b = a; a = t1 + t2;
   1aa88:	4673      	mov	r3, lr
   1aa8a:	e776      	b.n	1a97a <compress+0x9e>
   1aa8c:	0003a3c0 	.word	0x0003a3c0
   1aa90:	0003a400 	.word	0x0003a400

0001aa94 <tc_sha256_init>:
{
   1aa94:	b510      	push	{r4, lr}
	if (s == (TCSha256State_t) 0) {
   1aa96:	4604      	mov	r4, r0
   1aa98:	b1c8      	cbz	r0, 1aace <tc_sha256_init+0x3a>
	_set((uint8_t *) s, 0x00, sizeof(*s));
   1aa9a:	2270      	movs	r2, #112	; 0x70
   1aa9c:	2100      	movs	r1, #0
   1aa9e:	f019 fb94 	bl	341ca <_set>
	s->iv[1] = 0xbb67ae85;
   1aaa2:	4b0b      	ldr	r3, [pc, #44]	; (1aad0 <tc_sha256_init+0x3c>)
   1aaa4:	4a0b      	ldr	r2, [pc, #44]	; (1aad4 <tc_sha256_init+0x40>)
	s->iv[3] = 0xa54ff53a;
   1aaa6:	490c      	ldr	r1, [pc, #48]	; (1aad8 <tc_sha256_init+0x44>)
	s->iv[1] = 0xbb67ae85;
   1aaa8:	e9c4 2300 	strd	r2, r3, [r4]
	s->iv[3] = 0xa54ff53a;
   1aaac:	4b0b      	ldr	r3, [pc, #44]	; (1aadc <tc_sha256_init+0x48>)
	s->iv[5] = 0x9b05688c;
   1aaae:	480c      	ldr	r0, [pc, #48]	; (1aae0 <tc_sha256_init+0x4c>)
	s->iv[3] = 0xa54ff53a;
   1aab0:	e9c4 1302 	strd	r1, r3, [r4, #8]
	s->iv[5] = 0x9b05688c;
   1aab4:	4b0b      	ldr	r3, [pc, #44]	; (1aae4 <tc_sha256_init+0x50>)
   1aab6:	e9c4 0304 	strd	r0, r3, [r4, #16]
	return TC_CRYPTO_SUCCESS;
   1aaba:	2001      	movs	r0, #1
	s->iv[6] = 0x1f83d9ab;
   1aabc:	4b0a      	ldr	r3, [pc, #40]	; (1aae8 <tc_sha256_init+0x54>)
   1aabe:	61a3      	str	r3, [r4, #24]
	s->iv[7] = 0x5be0cd19;
   1aac0:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
   1aac4:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
   1aac8:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
   1aacc:	61e3      	str	r3, [r4, #28]
}
   1aace:	bd10      	pop	{r4, pc}
   1aad0:	bb67ae85 	.word	0xbb67ae85
   1aad4:	6a09e667 	.word	0x6a09e667
   1aad8:	3c6ef372 	.word	0x3c6ef372
   1aadc:	a54ff53a 	.word	0xa54ff53a
   1aae0:	510e527f 	.word	0x510e527f
   1aae4:	9b05688c 	.word	0x9b05688c
   1aae8:	1f83d9ab 	.word	0x1f83d9ab

0001aaec <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
   1aaec:	4a09      	ldr	r2, [pc, #36]	; (1ab14 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
   1aaee:	490a      	ldr	r1, [pc, #40]	; (1ab18 <arch_swap+0x2c>)
	_current->arch.basepri = key;
   1aaf0:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
   1aaf2:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
   1aaf4:	66d8      	str	r0, [r3, #108]	; 0x6c
	_current->arch.swap_return_value = _k_neg_eagain;
   1aaf6:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1aaf8:	4908      	ldr	r1, [pc, #32]	; (1ab1c <arch_swap+0x30>)
   1aafa:	684b      	ldr	r3, [r1, #4]
   1aafc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
   1ab00:	604b      	str	r3, [r1, #4]
   1ab02:	2300      	movs	r3, #0
   1ab04:	f383 8811 	msr	BASEPRI, r3
   1ab08:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
   1ab0c:	6893      	ldr	r3, [r2, #8]
}
   1ab0e:	6f18      	ldr	r0, [r3, #112]	; 0x70
   1ab10:	4770      	bx	lr
   1ab12:	bf00      	nop
   1ab14:	200274dc 	.word	0x200274dc
   1ab18:	0003ac34 	.word	0x0003ac34
   1ab1c:	e000ed00 	.word	0xe000ed00

0001ab20 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
   1ab20:	4929      	ldr	r1, [pc, #164]	; (1abc8 <in_fp_endif+0x2c>)
    ldr r2, [r1, #_kernel_offset_to_current]
   1ab22:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
   1ab24:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
   1ab28:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
   1ab2a:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
   1ab2e:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-out thread had been using the FP registers. */
    ldr r0, =0x10 /* EXC_RETURN.F_Type Mask */
   1ab32:	f04f 0010 	mov.w	r0, #16
    tst lr, r0    /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   1ab36:	ea1e 0f00 	tst.w	lr, r0
    beq out_fp_active
   1ab3a:	d004      	beq.n	1ab46 <out_fp_active>
    /* FP context inactive: clear FP state */
    ldr r0, [r2, #_thread_offset_to_mode]
   1ab3c:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    bic r0, #0x4 /* _current->arch.mode &= ~(CONTROL_FPCA_Msk) */
   1ab40:	f020 0004 	bic.w	r0, r0, #4
    b out_fp_endif
   1ab44:	e007      	b.n	1ab56 <out_fp_endif>

0001ab46 <out_fp_active>:

out_fp_active:
    /* FP context active: set FP state and store callee-saved registers */
    add r0, r2, #_thread_offset_to_preempt_float
   1ab46:	f102 0074 	add.w	r0, r2, #116	; 0x74
    vstmia r0, {s16-s31}
   1ab4a:	ec80 8a10 	vstmia	r0, {s16-s31}
    ldr r0, [r2, #_thread_offset_to_mode]
   1ab4e:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    orrs r0, r0, #0x4 /* _current->arch.mode |= CONTROL_FPCA_Msk */
   1ab52:	f050 0004 	orrs.w	r0, r0, #4

0001ab56 <out_fp_endif>:

out_fp_endif:
    str r0, [r2, #_thread_offset_to_mode]
   1ab56:	f8c2 00b4 	str.w	r0, [r2, #180]	; 0xb4

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1ab5a:	2020      	movs	r0, #32
    msr BASEPRI, r0
   1ab5c:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
   1ab60:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
   1ab64:	4f19      	ldr	r7, [pc, #100]	; (1abcc <in_fp_endif+0x30>)
    ldr v3, =_SCS_ICSR_UNPENDSV
   1ab66:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
   1ab6a:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
   1ab6c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
   1ab6e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
   1ab70:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
   1ab72:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
   1ab74:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
   1ab76:	f380 8811 	msr	BASEPRI, r0

#ifdef CONFIG_FPU_SHARING
    /* Assess whether switched-in thread had been using the FP registers. */
    ldr r0, [r2, #_thread_offset_to_mode]
   1ab7a:	f8d2 00b4 	ldr.w	r0, [r2, #180]	; 0xb4
    tst r0, #0x04 /* thread.arch.mode & CONTROL.FPCA Msk */
   1ab7e:	f010 0f04 	tst.w	r0, #4
    bne in_fp_active
   1ab82:	d105      	bne.n	1ab90 <in_fp_active>
    /* FP context inactive for swapped-in thread:
     * - reset FPSCR to 0
     * - set EXC_RETURN.F_Type (prevents FP frame un-stacking when returning
     *   from pendSV)
     */
    movs.n r3, #0
   1ab84:	2300      	movs	r3, #0
    vmsr fpscr, r3
   1ab86:	eee1 3a10 	vmsr	fpscr, r3
    orrs lr, lr, #0x10 /* EXC_RETURN & EXC_RETURN.F_Type_Msk */
   1ab8a:	f05e 0e10 	orrs.w	lr, lr, #16
    b in_fp_endif
   1ab8e:	e005      	b.n	1ab9c <in_fp_endif>

0001ab90 <in_fp_active>:
    /* FP context active:
     * - clear EXC_RETURN.F_Type
     * - FPSCR and caller-saved registers will be restored automatically
     * - restore callee-saved FP registers
     */
    bic lr, #0x10 /* EXC_RETURN | (~EXC_RETURN.F_Type_Msk) */
   1ab90:	f02e 0e10 	bic.w	lr, lr, #16
    add r0, r2, #_thread_offset_to_preempt_float
   1ab94:	f102 0074 	add.w	r0, r2, #116	; 0x74
    vldmia r0, {s16-s31}
   1ab98:	ec90 8a10 	vldmia	r0, {s16-s31}

0001ab9c <in_fp_endif>:
in_fp_endif:
    /* Clear CONTROL.FPCA that may have been set by FP instructions */
    mrs r3, CONTROL
   1ab9c:	f3ef 8314 	mrs	r3, CONTROL
    bic r3, #0x4 /* CONTROL.FPCA Msk */
   1aba0:	f023 0304 	bic.w	r3, r3, #4
    msr CONTROL, r3
   1aba4:	f383 8814 	msr	CONTROL, r3
    isb
   1aba8:	f3bf 8f6f 	isb	sy
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
   1abac:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
   1abb0:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
   1abb4:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
   1abb8:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
   1abbc:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
   1abbe:	f01a fc43 	bl	35448 <configure_builtin_stack_guard>
    pop {r2, lr}
   1abc2:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
   1abc6:	4770      	bx	lr
    ldr r1, =_kernel
   1abc8:	200274dc 	.word	0x200274dc
    ldr v4, =_SCS_ICSR
   1abcc:	e000ed04 	.word	0xe000ed04

0001abd0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
   1abd0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
   1abd4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
   1abd6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
   1abda:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
   1abde:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
   1abe0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
   1abe4:	2902      	cmp	r1, #2
    beq _oops
   1abe6:	d0ff      	beq.n	1abe8 <_oops>

0001abe8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
   1abe8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
   1abea:	f01a fc31 	bl	35450 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
   1abee:	bd01      	pop	{r0, pc}

0001abf0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
   1abf0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
   1abf2:	2b00      	cmp	r3, #0
   1abf4:	db08      	blt.n	1ac08 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1abf6:	2201      	movs	r2, #1
   1abf8:	f000 001f 	and.w	r0, r0, #31
   1abfc:	fa02 f000 	lsl.w	r0, r2, r0
   1ac00:	4a02      	ldr	r2, [pc, #8]	; (1ac0c <arch_irq_enable+0x1c>)
   1ac02:	095b      	lsrs	r3, r3, #5
   1ac04:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   1ac08:	4770      	bx	lr
   1ac0a:	bf00      	nop
   1ac0c:	e000e100 	.word	0xe000e100

0001ac10 <z_arm_irq_priority_set>:
 * priority levels which are reserved.
 *
 * @return N/A
 */
void z_arm_irq_priority_set(unsigned int irq, unsigned int prio, u32_t flags)
{
   1ac10:	b570      	push	{r4, r5, r6, lr}
	} else {
		prio += _IRQ_PRIO_OFFSET;
	}
#else
	ARG_UNUSED(flags);
	prio += _IRQ_PRIO_OFFSET;
   1ac12:	1c4c      	adds	r4, r1, #1
	/* The last priority level is also used by PendSV exception, but
	 * allow other interrupts to use the same level, even if it ends up
	 * affecting performance (can still be useful on systems with a
	 * reduced set of priorities, like Cortex-M0/M0+).
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
   1ac14:	2c07      	cmp	r4, #7
{
   1ac16:	4605      	mov	r5, r0
   1ac18:	460e      	mov	r6, r1
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
   1ac1a:	d90e      	bls.n	1ac3a <z_arm_irq_priority_set+0x2a>
   1ac1c:	235e      	movs	r3, #94	; 0x5e
   1ac1e:	4a10      	ldr	r2, [pc, #64]	; (1ac60 <z_arm_irq_priority_set+0x50>)
   1ac20:	4910      	ldr	r1, [pc, #64]	; (1ac64 <z_arm_irq_priority_set+0x54>)
   1ac22:	4811      	ldr	r0, [pc, #68]	; (1ac68 <z_arm_irq_priority_set+0x58>)
   1ac24:	f018 fcd0 	bl	335c8 <printk>
   1ac28:	4631      	mov	r1, r6
   1ac2a:	4810      	ldr	r0, [pc, #64]	; (1ac6c <z_arm_irq_priority_set+0x5c>)
   1ac2c:	2207      	movs	r2, #7
   1ac2e:	f018 fccb 	bl	335c8 <printk>
   1ac32:	215e      	movs	r1, #94	; 0x5e
   1ac34:	480a      	ldr	r0, [pc, #40]	; (1ac60 <z_arm_irq_priority_set+0x50>)
   1ac36:	f018 ffc8 	bl	33bca <assert_post_action>
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
   1ac3a:	b26b      	sxtb	r3, r5
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
   1ac3c:	2b00      	cmp	r3, #0
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac3e:	bfa8      	it	ge
   1ac40:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
   1ac44:	ea4f 1444 	mov.w	r4, r4, lsl #5
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac48:	bfb8      	it	lt
   1ac4a:	4b09      	ldrlt	r3, [pc, #36]	; (1ac70 <z_arm_irq_priority_set+0x60>)
   1ac4c:	b2e4      	uxtb	r4, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac4e:	bfab      	itete	ge
   1ac50:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac54:	f005 050f 	andlt.w	r5, r5, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac58:	f883 4300 	strbge.w	r4, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1ac5c:	555c      	strblt	r4, [r3, r5]
}
   1ac5e:	bd70      	pop	{r4, r5, r6, pc}
   1ac60:	0003cf80 	.word	0x0003cf80
   1ac64:	0003cfb6 	.word	0x0003cfb6
   1ac68:	0003b77f 	.word	0x0003b77f
   1ac6c:	0003cfd1 	.word	0x0003cfd1
   1ac70:	e000ed14 	.word	0xe000ed14

0001ac74 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
   1ac74:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
   1ac76:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
   1ac78:	4b04      	ldr	r3, [pc, #16]	; (1ac8c <_arch_isr_direct_pm+0x18>)
   1ac7a:	6a18      	ldr	r0, [r3, #32]
   1ac7c:	b118      	cbz	r0, 1ac86 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
   1ac7e:	2200      	movs	r2, #0
   1ac80:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
   1ac82:	f01d ff3d 	bl	38b00 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
   1ac86:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
   1ac88:	bd08      	pop	{r3, pc}
   1ac8a:	bf00      	nop
   1ac8c:	200274dc 	.word	0x200274dc

0001ac90 <arch_new_thread>:
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
	thread->stack_info.size = stack_size;
   1ac90:	e9c0 1218 	strd	r1, r2, [r0, #96]	; 0x60
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
   1ac94:	440a      	add	r2, r1
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
   1ac96:	3a20      	subs	r2, #32
   1ac98:	f022 0207 	bic.w	r2, r2, #7
#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
   1ac9c:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
   1ac9e:	9b00      	ldr	r3, [sp, #0]
	pInitCtx->basic.pc &= 0xfffffffe;
   1aca0:	4908      	ldr	r1, [pc, #32]	; (1acc4 <arch_new_thread+0x34>)
	pInitCtx->basic.a2 = (u32_t)parameter1;
   1aca2:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
   1aca4:	9b01      	ldr	r3, [sp, #4]
	pInitCtx->basic.pc &= 0xfffffffe;
   1aca6:	f021 0101 	bic.w	r1, r1, #1
	pInitCtx->basic.a3 = (u32_t)parameter2;
   1acaa:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   1acac:	9b02      	ldr	r3, [sp, #8]
	pInitCtx->basic.pc &= 0xfffffffe;
   1acae:	6191      	str	r1, [r2, #24]
	pInitCtx->basic.a4 = (u32_t)parameter3;
   1acb0:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
   1acb2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1acb6:	61d3      	str	r3, [r2, #28]
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;

	thread->arch.basepri = 0;
   1acb8:	2300      	movs	r3, #0
	thread->callee_saved.psp = (u32_t)pInitCtx;
   1acba:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
   1acbc:	66c3      	str	r3, [r0, #108]	; 0x6c

#if defined(CONFIG_USERSPACE) || defined(CONFIG_FPU_SHARING)
	thread->arch.mode = 0;
   1acbe:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
   1acc2:	4770      	bx	lr
   1acc4:	00033625 	.word	0x00033625

0001acc8 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
   1acc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1acca:	461e      	mov	r6, r3
   1accc:	4607      	mov	r7, r0
   1acce:	460d      	mov	r5, r1
   1acd0:	4614      	mov	r4, r2
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
#else
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   1acd2:	2300      	movs	r3, #0
   1acd4:	eee1 3a10 	vmsr	fpscr, r3
  __ASM volatile ("MRS %0, control" : "=r" (result) );
   1acd8:	f3ef 8214 	mrs	r2, CONTROL
	 * initialized at thread creation for threads that make use of the FP).
	 */
	__set_FPSCR(0);
#if defined(CONFIG_FPU_SHARING)
	/* In Sharing mode clearing FPSCR may set the CONTROL.FPCA flag. */
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
   1acdc:	f022 0204 	bic.w	r2, r2, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
   1ace0:	f382 8814 	msr	CONTROL, r2
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
   1ace4:	f3bf 8f6f 	isb	sy
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
   1ace8:	f000 fc7c 	bl	1b5e4 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);

	_current = main_thread;
   1acec:	4b09      	ldr	r3, [pc, #36]	; (1ad14 <arch_switch_to_main_thread+0x4c>)
	start_of_main_stack =
   1acee:	442c      	add	r4, r5
	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
   1acf0:	f024 0407 	bic.w	r4, r4, #7
	_current = main_thread;
   1acf4:	609f      	str	r7, [r3, #8]
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   1acf6:	f385 880b 	msr	PSPLIM, r5

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
   1acfa:	4630      	mov	r0, r6
   1acfc:	f384 8809 	msr	PSP, r4
   1ad00:	2100      	movs	r1, #0
   1ad02:	b663      	cpsie	if
   1ad04:	f381 8811 	msr	BASEPRI, r1
   1ad08:	f3bf 8f6f 	isb	sy
   1ad0c:	2200      	movs	r2, #0
   1ad0e:	2300      	movs	r3, #0
   1ad10:	f018 fc88 	bl	33624 <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
   1ad14:	200274dc 	.word	0x200274dc

0001ad18 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
   1ad18:	4901      	ldr	r1, [pc, #4]	; (1ad20 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
   1ad1a:	2210      	movs	r2, #16
	str	r2, [r1]
   1ad1c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
   1ad1e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
   1ad20:	e000ed10 	.word	0xe000ed10

0001ad24 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
   1ad24:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
   1ad26:	4040      	eors	r0, r0
	msr	BASEPRI, r0
   1ad28:	f380 8811 	msr	BASEPRI, r0
	isb
   1ad2c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
   1ad30:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
   1ad34:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
   1ad36:	b662      	cpsie	i
	isb
   1ad38:	f3bf 8f6f 	isb	sy

	bx	lr
   1ad3c:	4770      	bx	lr
   1ad3e:	bf00      	nop

0001ad40 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   1ad40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1ad44:	4681      	mov	r9, r0
   1ad46:	b086      	sub	sp, #24

	if (esf != NULL) {
   1ad48:	460c      	mov	r4, r1
   1ad4a:	2900      	cmp	r1, #0
   1ad4c:	d075      	beq.n	1ae3a <z_arm_fatal_error+0xfa>
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
   1ad4e:	2301      	movs	r3, #1
   1ad50:	f04f 0000 	mov.w	r0, #0
   1ad54:	4d3c      	ldr	r5, [pc, #240]	; (1ae48 <z_arm_fatal_error+0x108>)
   1ad56:	f363 0007 	bfi	r0, r3, #0, #8
   1ad5a:	4b3c      	ldr	r3, [pc, #240]	; (1ae4c <z_arm_fatal_error+0x10c>)
   1ad5c:	4627      	mov	r7, r4
   1ad5e:	1aed      	subs	r5, r5, r3
   1ad60:	688b      	ldr	r3, [r1, #8]
   1ad62:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   1ad66:	9300      	str	r3, [sp, #0]
   1ad68:	e9d1 2300 	ldrd	r2, r3, [r1]
   1ad6c:	f365 108f 	bfi	r0, r5, #6, #10
   1ad70:	4937      	ldr	r1, [pc, #220]	; (1ae50 <z_arm_fatal_error+0x110>)
   1ad72:	f018 ff41 	bl	33bf8 <log_string_sync>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
   1ad76:	2301      	movs	r3, #1
   1ad78:	f04f 0000 	mov.w	r0, #0
   1ad7c:	f363 0007 	bfi	r0, r3, #0, #8
   1ad80:	6963      	ldr	r3, [r4, #20]
   1ad82:	f365 108f 	bfi	r0, r5, #6, #10
   1ad86:	9300      	str	r3, [sp, #0]
   1ad88:	e9d4 2303 	ldrd	r2, r3, [r4, #12]
   1ad8c:	4931      	ldr	r1, [pc, #196]	; (1ae54 <z_arm_fatal_error+0x114>)
   1ad8e:	f018 ff33 	bl	33bf8 <log_string_sync>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
   1ad92:	2301      	movs	r3, #1
   1ad94:	f04f 0000 	mov.w	r0, #0
   1ad98:	f363 0007 	bfi	r0, r3, #0, #8
   1ad9c:	f365 108f 	bfi	r0, r5, #6, #10
   1ada0:	69e2      	ldr	r2, [r4, #28]
   1ada2:	492d      	ldr	r1, [pc, #180]	; (1ae58 <z_arm_fatal_error+0x118>)
   1ada4:	f018 ff28 	bl	33bf8 <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   1ada8:	2600      	movs	r6, #0
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   1adaa:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 1ae64 <z_arm_fatal_error+0x124>
   1adae:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
   1adb2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1adb6:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   1adba:	f043 0301 	orr.w	r3, r3, #1
   1adbe:	f363 0807 	bfi	r8, r3, #0, #8
   1adc2:	1cf3      	adds	r3, r6, #3
   1adc4:	ed97 7a08 	vldr	s14, [r7, #32]
   1adc8:	9304      	str	r3, [sp, #16]
   1adca:	edcd 7a05 	vstr	s15, [sp, #20]
   1adce:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
   1add2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1add6:	1cb3      	adds	r3, r6, #2
   1add8:	9302      	str	r3, [sp, #8]
   1adda:	edcd 7a03 	vstr	s15, [sp, #12]
   1adde:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
   1ade2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   1ade6:	edcd 7a01 	vstr	s15, [sp, #4]
   1adea:	eefc 7ac7 	vcvt.u32.f32	s15, s14
   1adee:	1c73      	adds	r3, r6, #1
   1adf0:	f365 188f 	bfi	r8, r5, #6, #10
   1adf4:	9300      	str	r3, [sp, #0]
   1adf6:	4632      	mov	r2, r6
   1adf8:	ee17 3a90 	vmov	r3, s15
   1adfc:	4651      	mov	r1, sl
   1adfe:	4640      	mov	r0, r8
	for (int i = 0; i < 16; i += 4) {
   1ae00:	3604      	adds	r6, #4
		LOG_ERR("s[%2d]:  0x%08x  s[%2d]:  0x%08x"
   1ae02:	f018 fef9 	bl	33bf8 <log_string_sync>
	for (int i = 0; i < 16; i += 4) {
   1ae06:	2e10      	cmp	r6, #16
   1ae08:	f107 0710 	add.w	r7, r7, #16
   1ae0c:	d1cf      	bne.n	1adae <z_arm_fatal_error+0x6e>
	LOG_ERR("fpscr:  0x%08x", esf->fpscr);
   1ae0e:	2301      	movs	r3, #1
   1ae10:	f04f 0000 	mov.w	r0, #0
   1ae14:	f363 0007 	bfi	r0, r3, #0, #8
   1ae18:	f365 108f 	bfi	r0, r5, #6, #10
   1ae1c:	6e22      	ldr	r2, [r4, #96]	; 0x60
   1ae1e:	490f      	ldr	r1, [pc, #60]	; (1ae5c <z_arm_fatal_error+0x11c>)
   1ae20:	f018 feea 	bl	33bf8 <log_string_sync>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
   1ae24:	f04f 0000 	mov.w	r0, #0
   1ae28:	2301      	movs	r3, #1
   1ae2a:	f363 0007 	bfi	r0, r3, #0, #8
   1ae2e:	f365 108f 	bfi	r0, r5, #6, #10
   1ae32:	69a2      	ldr	r2, [r4, #24]
   1ae34:	490a      	ldr	r1, [pc, #40]	; (1ae60 <z_arm_fatal_error+0x120>)
   1ae36:	f018 fedf 	bl	33bf8 <log_string_sync>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   1ae3a:	4621      	mov	r1, r4
   1ae3c:	4648      	mov	r0, r9
}
   1ae3e:	b006      	add	sp, #24
   1ae40:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	z_fatal_error(reason, esf);
   1ae44:	f010 bd10 	b.w	2b868 <z_fatal_error>
   1ae48:	00039ff0 	.word	0x00039ff0
   1ae4c:	00039f60 	.word	0x00039f60
   1ae50:	0003d006 	.word	0x0003d006
   1ae54:	0003d035 	.word	0x0003d035
   1ae58:	0003d064 	.word	0x0003d064
   1ae5c:	0003d0b6 	.word	0x0003d0b6
   1ae60:	0003d0c5 	.word	0x0003d0c5
   1ae64:	0003d073 	.word	0x0003d073

0001ae68 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
   1ae68:	bf30      	wfi
    b z_SysNmiOnReset
   1ae6a:	f7ff bffd 	b.w	1ae68 <z_SysNmiOnReset>
   1ae6e:	bf00      	nop

0001ae70 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1ae70:	4a14      	ldr	r2, [pc, #80]	; (1aec4 <z_arm_prep_c+0x54>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
   1ae72:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
   1ae74:	4b14      	ldr	r3, [pc, #80]	; (1aec8 <z_arm_prep_c+0x58>)
   1ae76:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   1ae7a:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   1ae7c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1ae80:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
   1ae84:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1ae88:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
   1ae8c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
   1ae90:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   1ae94:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
   1ae98:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
   1ae9c:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
   1aea0:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
   1aea4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1aea8:	f3bf 8f6f 	isb	sy
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
   1aeac:	2300      	movs	r3, #0
   1aeae:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
   1aeb2:	f010 fd7b 	bl	2b9ac <z_bss_zero>
	z_data_copy();
   1aeb6:	f010 fd83 	bl	2b9c0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
   1aeba:	f000 fb49 	bl	1b550 <z_arm_interrupt_init>
	z_cstart();
   1aebe:	f010 fdbd 	bl	2ba3c <z_cstart>
   1aec2:	bf00      	nop
   1aec4:	0000c000 	.word	0x0000c000
   1aec8:	e000ed00 	.word	0xe000ed00

0001aecc <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
   1aecc:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
   1aece:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
   1aed0:	4a0b      	ldr	r2, [pc, #44]	; (1af00 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
   1aed2:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
   1aed4:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
   1aed6:	bf1e      	ittt	ne
	movne	r1, #0
   1aed8:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
   1aeda:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
   1aedc:	f01d fe10 	blne	38b00 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
   1aee0:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
   1aee2:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
   1aee6:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
   1aeea:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
   1aeee:	4905      	ldr	r1, [pc, #20]	; (1af04 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
   1aef0:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
   1aef2:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
   1aef4:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
   1aef6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
   1aefa:	4903      	ldr	r1, [pc, #12]	; (1af08 <_isr_wrapper+0x3c>)
	bx r1
   1aefc:	4708      	bx	r1
   1aefe:	0000      	.short	0x0000
	ldr r2, =_kernel
   1af00:	200274dc 	.word	0x200274dc
	ldr r1, =_sw_isr_table
   1af04:	00039d4c 	.word	0x00039d4c
	ldr r1, =z_arm_int_exit
   1af08:	0001b511 	.word	0x0001b511

0001af0c <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
   1af0c:	f018 fe65 	bl	33bda <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
   1af10:	2020      	movs	r0, #32
    msr BASEPRI, r0
   1af12:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
   1af16:	4808      	ldr	r0, [pc, #32]	; (1af38 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
   1af18:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
   1af1c:	1840      	adds	r0, r0, r1
    msr PSP, r0
   1af1e:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
   1af22:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
   1af26:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
   1af28:	4308      	orrs	r0, r1
    msr CONTROL, r0
   1af2a:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
   1af2e:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
   1af32:	f7ff ff9d 	bl	1ae70 <z_arm_prep_c>
   1af36:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
   1af38:	200349d8 	.word	0x200349d8

0001af3c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
   1af3c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
   1af40:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
   1af44:	4672      	mov	r2, lr

	push {r0, lr}
   1af46:	b501      	push	{r0, lr}

	bl z_arm_fault
   1af48:	f000 f9ce 	bl	1b2e8 <z_arm_fault>

	pop {r0, pc}
   1af4c:	bd01      	pop	{r0, pc}
   1af4e:	bf00      	nop

0001af50 <mem_manage_fault.isra.2>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1af50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			      bool *recoverable)
{
	u32_t reason = K_ERR_CPU_EXCEPTION;
	u32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");
   1af52:	2301      	movs	r3, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1af54:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** MPU FAULT *****");
   1af56:	f04f 0000 	mov.w	r0, #0
   1af5a:	4c40      	ldr	r4, [pc, #256]	; (1b05c <mem_manage_fault.isra.2+0x10c>)
   1af5c:	f363 0007 	bfi	r0, r3, #0, #8
   1af60:	4b3f      	ldr	r3, [pc, #252]	; (1b060 <mem_manage_fault.isra.2+0x110>)
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
   1af62:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
   1af64:	1ae4      	subs	r4, r4, r3
   1af66:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1af6a:	493e      	ldr	r1, [pc, #248]	; (1b064 <mem_manage_fault.isra.2+0x114>)
   1af6c:	f364 108f 	bfi	r0, r4, #6, #10
   1af70:	f018 fe42 	bl	33bf8 <log_string_sync>

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
   1af74:	4b3c      	ldr	r3, [pc, #240]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1af76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1af78:	06d9      	lsls	r1, r3, #27
   1af7a:	d509      	bpl.n	1af90 <mem_manage_fault.isra.2+0x40>
		PR_FAULT_INFO("  Stacking error (context area might be"
   1af7c:	f04f 0000 	mov.w	r0, #0
   1af80:	2301      	movs	r3, #1
   1af82:	f363 0007 	bfi	r0, r3, #0, #8
   1af86:	f364 108f 	bfi	r0, r4, #6, #10
   1af8a:	4938      	ldr	r1, [pc, #224]	; (1b06c <mem_manage_fault.isra.2+0x11c>)
   1af8c:	f018 fe34 	bl	33bf8 <log_string_sync>
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
   1af90:	4b35      	ldr	r3, [pc, #212]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1af92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1af94:	071a      	lsls	r2, r3, #28
   1af96:	d509      	bpl.n	1afac <mem_manage_fault.isra.2+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   1af98:	f04f 0000 	mov.w	r0, #0
   1af9c:	2301      	movs	r3, #1
   1af9e:	f363 0007 	bfi	r0, r3, #0, #8
   1afa2:	f364 108f 	bfi	r0, r4, #6, #10
   1afa6:	4932      	ldr	r1, [pc, #200]	; (1b070 <mem_manage_fault.isra.2+0x120>)
   1afa8:	f018 fe26 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
   1afac:	4d2e      	ldr	r5, [pc, #184]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1afae:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1afb0:	079b      	lsls	r3, r3, #30
   1afb2:	d51c      	bpl.n	1afee <mem_manage_fault.isra.2+0x9e>
		PR_FAULT_INFO("  Data Access Violation");
   1afb4:	2301      	movs	r3, #1
   1afb6:	f04f 0000 	mov.w	r0, #0
   1afba:	f363 0007 	bfi	r0, r3, #0, #8
   1afbe:	f364 108f 	bfi	r0, r4, #6, #10
   1afc2:	492c      	ldr	r1, [pc, #176]	; (1b074 <mem_manage_fault.isra.2+0x124>)
   1afc4:	f018 fe18 	bl	33bf8 <log_string_sync>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		mmfar = SCB->MMFAR;
   1afc8:	6b6a      	ldr	r2, [r5, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
   1afca:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1afcc:	0618      	lsls	r0, r3, #24
   1afce:	d50e      	bpl.n	1afee <mem_manage_fault.isra.2+0x9e>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
   1afd0:	f04f 0000 	mov.w	r0, #0
   1afd4:	2301      	movs	r3, #1
   1afd6:	f363 0007 	bfi	r0, r3, #0, #8
   1afda:	f364 108f 	bfi	r0, r4, #6, #10
   1afde:	4926      	ldr	r1, [pc, #152]	; (1b078 <mem_manage_fault.isra.2+0x128>)
   1afe0:	f018 fe0a 	bl	33bf8 <log_string_sync>
			if (from_hard_fault) {
   1afe4:	b11f      	cbz	r7, 1afee <mem_manage_fault.isra.2+0x9e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
   1afe6:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1afe8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   1afec:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
   1afee:	4b1e      	ldr	r3, [pc, #120]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1aff0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1aff2:	07d9      	lsls	r1, r3, #31
   1aff4:	d509      	bpl.n	1b00a <mem_manage_fault.isra.2+0xba>
		PR_FAULT_INFO("  Instruction Access Violation");
   1aff6:	f04f 0000 	mov.w	r0, #0
   1affa:	2301      	movs	r3, #1
   1affc:	f363 0007 	bfi	r0, r3, #0, #8
   1b000:	f364 108f 	bfi	r0, r4, #6, #10
   1b004:	491d      	ldr	r1, [pc, #116]	; (1b07c <mem_manage_fault.isra.2+0x12c>)
   1b006:	f018 fdf7 	bl	33bf8 <log_string_sync>
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
   1b00a:	4b17      	ldr	r3, [pc, #92]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1b00c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b00e:	069a      	lsls	r2, r3, #26
   1b010:	d509      	bpl.n	1b026 <mem_manage_fault.isra.2+0xd6>
		PR_FAULT_INFO(
   1b012:	f04f 0000 	mov.w	r0, #0
   1b016:	2301      	movs	r3, #1
   1b018:	f363 0007 	bfi	r0, r3, #0, #8
   1b01c:	f364 108f 	bfi	r0, r4, #6, #10
   1b020:	4917      	ldr	r1, [pc, #92]	; (1b080 <mem_manage_fault.isra.2+0x130>)
   1b022:	f018 fde9 	bl	33bf8 <log_string_sync>
	 * if the memory violation error is a stack corruption.
	 *
	 * By design, being a Stacking MemManage fault is a necessary
	 * and sufficient condition for a thread stack corruption.
	 */
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
   1b026:	4b10      	ldr	r3, [pc, #64]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1b028:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b02a:	06db      	lsls	r3, r3, #27
   1b02c:	d50e      	bpl.n	1b04c <mem_manage_fault.isra.2+0xfc>
					"Stacking error not a stack fail\n");
			}
		}
#else
	(void)mmfar;
	__ASSERT(0,
   1b02e:	4915      	ldr	r1, [pc, #84]	; (1b084 <mem_manage_fault.isra.2+0x134>)
   1b030:	f240 1337 	movw	r3, #311	; 0x137
   1b034:	4a14      	ldr	r2, [pc, #80]	; (1b088 <mem_manage_fault.isra.2+0x138>)
   1b036:	4815      	ldr	r0, [pc, #84]	; (1b08c <mem_manage_fault.isra.2+0x13c>)
   1b038:	f018 fac6 	bl	335c8 <printk>
   1b03c:	4814      	ldr	r0, [pc, #80]	; (1b090 <mem_manage_fault.isra.2+0x140>)
   1b03e:	f018 fac3 	bl	335c8 <printk>
   1b042:	f240 1137 	movw	r1, #311	; 0x137
   1b046:	4810      	ldr	r0, [pc, #64]	; (1b088 <mem_manage_fault.isra.2+0x138>)
   1b048:	f018 fdbf 	bl	33bca <assert_post_action>

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
   1b04c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
   1b04e:	4a06      	ldr	r2, [pc, #24]	; (1b068 <mem_manage_fault.isra.2+0x118>)
   1b050:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1b052:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
   1b056:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   1b058:	7030      	strb	r0, [r6, #0]

	return reason;
}
   1b05a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1b05c:	00039ff0 	.word	0x00039ff0
   1b060:	00039f60 	.word	0x00039f60
   1b064:	0003d17b 	.word	0x0003d17b
   1b068:	e000ed00 	.word	0xe000ed00
   1b06c:	0003d191 	.word	0x0003d191
   1b070:	0003d1c4 	.word	0x0003d1c4
   1b074:	0003d1d7 	.word	0x0003d1d7
   1b078:	0003d1ef 	.word	0x0003d1ef
   1b07c:	0003d205 	.word	0x0003d205
   1b080:	0003d224 	.word	0x0003d224
   1b084:	0003fd3b 	.word	0x0003fd3b
   1b088:	0003d253 	.word	0x0003d253
   1b08c:	0003b77f 	.word	0x0003b77f
   1b090:	0003d28d 	.word	0x0003d28d

0001b094 <bus_fault.isra.3>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1b094:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");
   1b096:	2301      	movs	r3, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1b098:	4607      	mov	r7, r0
	PR_FAULT_INFO("***** BUS FAULT *****");
   1b09a:	f04f 0000 	mov.w	r0, #0
   1b09e:	4c3d      	ldr	r4, [pc, #244]	; (1b194 <bus_fault.isra.3+0x100>)
   1b0a0:	f363 0007 	bfi	r0, r3, #0, #8
   1b0a4:	4b3c      	ldr	r3, [pc, #240]	; (1b198 <bus_fault.isra.3+0x104>)
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
   1b0a6:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
   1b0a8:	1ae4      	subs	r4, r4, r3
   1b0aa:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1b0ae:	493b      	ldr	r1, [pc, #236]	; (1b19c <bus_fault.isra.3+0x108>)
   1b0b0:	f364 108f 	bfi	r0, r4, #6, #10
   1b0b4:	f018 fda0 	bl	33bf8 <log_string_sync>

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
   1b0b8:	4b39      	ldr	r3, [pc, #228]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b0ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b0bc:	04d9      	lsls	r1, r3, #19
   1b0be:	d509      	bpl.n	1b0d4 <bus_fault.isra.3+0x40>
		PR_FAULT_INFO("  Stacking error");
   1b0c0:	f04f 0000 	mov.w	r0, #0
   1b0c4:	2301      	movs	r3, #1
   1b0c6:	f363 0007 	bfi	r0, r3, #0, #8
   1b0ca:	f364 108f 	bfi	r0, r4, #6, #10
   1b0ce:	4935      	ldr	r1, [pc, #212]	; (1b1a4 <bus_fault.isra.3+0x110>)
   1b0d0:	f018 fd92 	bl	33bf8 <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
   1b0d4:	4b32      	ldr	r3, [pc, #200]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b0d6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b0d8:	051a      	lsls	r2, r3, #20
   1b0da:	d509      	bpl.n	1b0f0 <bus_fault.isra.3+0x5c>
		PR_FAULT_INFO("  Unstacking error");
   1b0dc:	f04f 0000 	mov.w	r0, #0
   1b0e0:	2301      	movs	r3, #1
   1b0e2:	f363 0007 	bfi	r0, r3, #0, #8
   1b0e6:	f364 108f 	bfi	r0, r4, #6, #10
   1b0ea:	492f      	ldr	r1, [pc, #188]	; (1b1a8 <bus_fault.isra.3+0x114>)
   1b0ec:	f018 fd84 	bl	33bf8 <log_string_sync>
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
   1b0f0:	4d2b      	ldr	r5, [pc, #172]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b0f2:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1b0f4:	059b      	lsls	r3, r3, #22
   1b0f6:	d51c      	bpl.n	1b132 <bus_fault.isra.3+0x9e>
		PR_FAULT_INFO("  Precise data bus error");
   1b0f8:	2301      	movs	r3, #1
   1b0fa:	f04f 0000 	mov.w	r0, #0
   1b0fe:	f363 0007 	bfi	r0, r3, #0, #8
   1b102:	f364 108f 	bfi	r0, r4, #6, #10
   1b106:	4929      	ldr	r1, [pc, #164]	; (1b1ac <bus_fault.isra.3+0x118>)
   1b108:	f018 fd76 	bl	33bf8 <log_string_sync>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
   1b10c:	6baa      	ldr	r2, [r5, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
   1b10e:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1b110:	0418      	lsls	r0, r3, #16
   1b112:	d50e      	bpl.n	1b132 <bus_fault.isra.3+0x9e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
   1b114:	f04f 0000 	mov.w	r0, #0
   1b118:	2301      	movs	r3, #1
   1b11a:	f363 0007 	bfi	r0, r3, #0, #8
   1b11e:	f364 108f 	bfi	r0, r4, #6, #10
   1b122:	4923      	ldr	r1, [pc, #140]	; (1b1b0 <bus_fault.isra.3+0x11c>)
   1b124:	f018 fd68 	bl	33bf8 <log_string_sync>
			if (from_hard_fault) {
   1b128:	b11f      	cbz	r7, 1b132 <bus_fault.isra.3+0x9e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
   1b12a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1b12c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
   1b130:	62ab      	str	r3, [r5, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
   1b132:	4b1b      	ldr	r3, [pc, #108]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b134:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b136:	0559      	lsls	r1, r3, #21
   1b138:	d509      	bpl.n	1b14e <bus_fault.isra.3+0xba>
		PR_FAULT_INFO("  Imprecise data bus error");
   1b13a:	f04f 0000 	mov.w	r0, #0
   1b13e:	2301      	movs	r3, #1
   1b140:	f363 0007 	bfi	r0, r3, #0, #8
   1b144:	f364 108f 	bfi	r0, r4, #6, #10
   1b148:	491a      	ldr	r1, [pc, #104]	; (1b1b4 <bus_fault.isra.3+0x120>)
   1b14a:	f018 fd55 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
   1b14e:	4b14      	ldr	r3, [pc, #80]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b150:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   1b152:	05d2      	lsls	r2, r2, #23
   1b154:	d511      	bpl.n	1b17a <bus_fault.isra.3+0xe6>
		PR_FAULT_INFO("  Instruction bus error");
   1b156:	f04f 0000 	mov.w	r0, #0
   1b15a:	2301      	movs	r3, #1
   1b15c:	4916      	ldr	r1, [pc, #88]	; (1b1b8 <bus_fault.isra.3+0x124>)
   1b15e:	f363 0007 	bfi	r0, r3, #0, #8
   1b162:	f364 108f 	bfi	r0, r4, #6, #10
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   1b166:	f018 fd47 	bl	33bf8 <log_string_sync>
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
   1b16a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
   1b16c:	4a0c      	ldr	r2, [pc, #48]	; (1b1a0 <bus_fault.isra.3+0x10c>)
   1b16e:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1b170:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
   1b174:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
   1b176:	7030      	strb	r0, [r6, #0]

	return reason;
}
   1b178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
   1b17a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b17c:	049b      	lsls	r3, r3, #18
   1b17e:	d5f4      	bpl.n	1b16a <bus_fault.isra.3+0xd6>
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
   1b180:	f04f 0000 	mov.w	r0, #0
   1b184:	2301      	movs	r3, #1
   1b186:	f363 0007 	bfi	r0, r3, #0, #8
   1b18a:	f364 108f 	bfi	r0, r4, #6, #10
   1b18e:	490b      	ldr	r1, [pc, #44]	; (1b1bc <bus_fault.isra.3+0x128>)
   1b190:	e7e9      	b.n	1b166 <bus_fault.isra.3+0xd2>
   1b192:	bf00      	nop
   1b194:	00039ff0 	.word	0x00039ff0
   1b198:	00039f60 	.word	0x00039f60
   1b19c:	0003d0f3 	.word	0x0003d0f3
   1b1a0:	e000ed00 	.word	0xe000ed00
   1b1a4:	0003d109 	.word	0x0003d109
   1b1a8:	0003d1c4 	.word	0x0003d1c4
   1b1ac:	0003d11a 	.word	0x0003d11a
   1b1b0:	0003d133 	.word	0x0003d133
   1b1b4:	0003d148 	.word	0x0003d148
   1b1b8:	0003d163 	.word	0x0003d163
   1b1bc:	0003d224 	.word	0x0003d224

0001b1c0 <usage_fault.isra.4>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
   1b1c0:	b538      	push	{r3, r4, r5, lr}
{
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
   1b1c2:	f04f 0000 	mov.w	r0, #0
   1b1c6:	2301      	movs	r3, #1
   1b1c8:	4c3c      	ldr	r4, [pc, #240]	; (1b2bc <usage_fault.isra.4+0xfc>)
   1b1ca:	f363 0007 	bfi	r0, r3, #0, #8
   1b1ce:	4b3c      	ldr	r3, [pc, #240]	; (1b2c0 <usage_fault.isra.4+0x100>)
   1b1d0:	493c      	ldr	r1, [pc, #240]	; (1b2c4 <usage_fault.isra.4+0x104>)
   1b1d2:	1ae4      	subs	r4, r4, r3
   1b1d4:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   1b1d8:	f364 108f 	bfi	r0, r4, #6, #10
   1b1dc:	f018 fd0c 	bl	33bf8 <log_string_sync>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
   1b1e0:	4b39      	ldr	r3, [pc, #228]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b1e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b1e4:	019b      	lsls	r3, r3, #6
   1b1e6:	d509      	bpl.n	1b1fc <usage_fault.isra.4+0x3c>
		PR_FAULT_INFO("  Division by zero");
   1b1e8:	f04f 0000 	mov.w	r0, #0
   1b1ec:	2301      	movs	r3, #1
   1b1ee:	f363 0007 	bfi	r0, r3, #0, #8
   1b1f2:	f364 108f 	bfi	r0, r4, #6, #10
   1b1f6:	4935      	ldr	r1, [pc, #212]	; (1b2cc <usage_fault.isra.4+0x10c>)
   1b1f8:	f018 fcfe 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
   1b1fc:	4b32      	ldr	r3, [pc, #200]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b1fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b200:	01dd      	lsls	r5, r3, #7
   1b202:	d509      	bpl.n	1b218 <usage_fault.isra.4+0x58>
		PR_FAULT_INFO("  Unaligned memory access");
   1b204:	f04f 0000 	mov.w	r0, #0
   1b208:	2301      	movs	r3, #1
   1b20a:	f363 0007 	bfi	r0, r3, #0, #8
   1b20e:	f364 108f 	bfi	r0, r4, #6, #10
   1b212:	492f      	ldr	r1, [pc, #188]	; (1b2d0 <usage_fault.isra.4+0x110>)
   1b214:	f018 fcf0 	bl	33bf8 <log_string_sync>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
   1b218:	4b2b      	ldr	r3, [pc, #172]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b21a:	6a9d      	ldr	r5, [r3, #40]	; 0x28
   1b21c:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   1b220:	d00a      	beq.n	1b238 <usage_fault.isra.4+0x78>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
   1b222:	2301      	movs	r3, #1
   1b224:	f04f 0000 	mov.w	r0, #0
   1b228:	f363 0007 	bfi	r0, r3, #0, #8
   1b22c:	f364 108f 	bfi	r0, r4, #6, #10
   1b230:	4928      	ldr	r1, [pc, #160]	; (1b2d4 <usage_fault.isra.4+0x114>)
   1b232:	f018 fce1 	bl	33bf8 <log_string_sync>
		 * prevents the context area to be loaded on the stack upon
		 * UsageFault exception entry. As a result, we cannot rely
		 * on the reported faulty instruction address, to determine
		 * the instruction that triggered the stack overflow.
		 */
		reason = K_ERR_STACK_CHK_FAIL;
   1b236:	2502      	movs	r5, #2
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
   1b238:	4b23      	ldr	r3, [pc, #140]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b23a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b23c:	0318      	lsls	r0, r3, #12
   1b23e:	d509      	bpl.n	1b254 <usage_fault.isra.4+0x94>
		PR_FAULT_INFO("  No coprocessor instructions");
   1b240:	f04f 0000 	mov.w	r0, #0
   1b244:	2301      	movs	r3, #1
   1b246:	f363 0007 	bfi	r0, r3, #0, #8
   1b24a:	f364 108f 	bfi	r0, r4, #6, #10
   1b24e:	4922      	ldr	r1, [pc, #136]	; (1b2d8 <usage_fault.isra.4+0x118>)
   1b250:	f018 fcd2 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
   1b254:	4b1c      	ldr	r3, [pc, #112]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b256:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b258:	0359      	lsls	r1, r3, #13
   1b25a:	d509      	bpl.n	1b270 <usage_fault.isra.4+0xb0>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
   1b25c:	f04f 0000 	mov.w	r0, #0
   1b260:	2301      	movs	r3, #1
   1b262:	f363 0007 	bfi	r0, r3, #0, #8
   1b266:	f364 108f 	bfi	r0, r4, #6, #10
   1b26a:	491c      	ldr	r1, [pc, #112]	; (1b2dc <usage_fault.isra.4+0x11c>)
   1b26c:	f018 fcc4 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
   1b270:	4b15      	ldr	r3, [pc, #84]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b272:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b274:	039a      	lsls	r2, r3, #14
   1b276:	d509      	bpl.n	1b28c <usage_fault.isra.4+0xcc>
		PR_FAULT_INFO("  Illegal use of the EPSR");
   1b278:	f04f 0000 	mov.w	r0, #0
   1b27c:	2301      	movs	r3, #1
   1b27e:	f363 0007 	bfi	r0, r3, #0, #8
   1b282:	f364 108f 	bfi	r0, r4, #6, #10
   1b286:	4916      	ldr	r1, [pc, #88]	; (1b2e0 <usage_fault.isra.4+0x120>)
   1b288:	f018 fcb6 	bl	33bf8 <log_string_sync>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
   1b28c:	4b0e      	ldr	r3, [pc, #56]	; (1b2c8 <usage_fault.isra.4+0x108>)
   1b28e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1b290:	03db      	lsls	r3, r3, #15
   1b292:	d509      	bpl.n	1b2a8 <usage_fault.isra.4+0xe8>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
   1b294:	f04f 0000 	mov.w	r0, #0
   1b298:	2301      	movs	r3, #1
   1b29a:	f363 0007 	bfi	r0, r3, #0, #8
   1b29e:	f364 108f 	bfi	r0, r4, #6, #10
   1b2a2:	4910      	ldr	r1, [pc, #64]	; (1b2e4 <usage_fault.isra.4+0x124>)
   1b2a4:	f018 fca8 	bl	33bf8 <log_string_sync>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1b2a8:	4a07      	ldr	r2, [pc, #28]	; (1b2c8 <usage_fault.isra.4+0x108>)

	return reason;
}
   1b2aa:	4628      	mov	r0, r5
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
   1b2ac:	6a93      	ldr	r3, [r2, #40]	; 0x28
   1b2ae:	ea6f 4303 	mvn.w	r3, r3, lsl #16
   1b2b2:	ea6f 4313 	mvn.w	r3, r3, lsr #16
   1b2b6:	6293      	str	r3, [r2, #40]	; 0x28
}
   1b2b8:	bd38      	pop	{r3, r4, r5, pc}
   1b2ba:	bf00      	nop
   1b2bc:	00039ff0 	.word	0x00039ff0
   1b2c0:	00039f60 	.word	0x00039f60
   1b2c4:	0003d2c7 	.word	0x0003d2c7
   1b2c8:	e000ed00 	.word	0xe000ed00
   1b2cc:	0003d2df 	.word	0x0003d2df
   1b2d0:	0003d2f2 	.word	0x0003d2f2
   1b2d4:	0003d30c 	.word	0x0003d30c
   1b2d8:	0003d336 	.word	0x0003d336
   1b2dc:	0003d354 	.word	0x0003d354
   1b2e0:	0003d379 	.word	0x0003d379
   1b2e4:	0003d393 	.word	0x0003d393

0001b2e8 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
   1b2e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1b2ec:	4b70      	ldr	r3, [pc, #448]	; (1b4b0 <z_arm_fault+0x1c8>)
{
   1b2ee:	b09d      	sub	sp, #116	; 0x74
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1b2f0:	f8d3 8004 	ldr.w	r8, [r3, #4]
{
   1b2f4:	4606      	mov	r6, r0
   1b2f6:	4689      	mov	r9, r1
   1b2f8:	4614      	mov	r4, r2
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
   1b2fa:	f3c8 0708 	ubfx	r7, r8, #0, #9
   1b2fe:	2500      	movs	r5, #0
   1b300:	f385 8811 	msr	BASEPRI, r5
   1b304:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
   1b308:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
   1b30c:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
   1b310:	d11b      	bne.n	1b34a <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_EXCEPTION_SECURE_Secure) {
   1b312:	07d0      	lsls	r0, r2, #31
   1b314:	d419      	bmi.n	1b34a <z_arm_fault+0x62>
	if (exc_return & EXC_RETURN_RETURN_STACK_Secure) {
   1b316:	0651      	lsls	r1, r2, #25
   1b318:	d403      	bmi.n	1b322 <z_arm_fault+0x3a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
   1b31a:	0722      	lsls	r2, r4, #28
   1b31c:	d412      	bmi.n	1b344 <z_arm_fault+0x5c>
			*nested_exc = true;
   1b31e:	2501      	movs	r5, #1
   1b320:	e012      	b.n	1b348 <z_arm_fault+0x60>
		PR_FAULT_INFO("Exception occurred in Secure State");
   1b322:	2301      	movs	r3, #1
   1b324:	f04f 0000 	mov.w	r0, #0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
   1b328:	4a62      	ldr	r2, [pc, #392]	; (1b4b4 <z_arm_fault+0x1cc>)
   1b32a:	f363 0007 	bfi	r0, r3, #0, #8
   1b32e:	4b62      	ldr	r3, [pc, #392]	; (1b4b8 <z_arm_fault+0x1d0>)
   1b330:	4962      	ldr	r1, [pc, #392]	; (1b4bc <z_arm_fault+0x1d4>)
   1b332:	1a9b      	subs	r3, r3, r2
   1b334:	08db      	lsrs	r3, r3, #3
   1b336:	f363 108f 	bfi	r0, r3, #6, #10
   1b33a:	f018 fc5d 	bl	33bf8 <log_string_sync>
		if (exc_return & EXC_RETURN_SPSEL_PROCESS) {
   1b33e:	f014 0504 	ands.w	r5, r4, #4
   1b342:	d001      	beq.n	1b348 <z_arm_fault+0x60>
			ptr_esf = (z_arch_esf_t *)psp;
   1b344:	464e      	mov	r6, r9
	*nested_exc = false;
   1b346:	2500      	movs	r5, #0

	/* Retrieve the Exception Stack Frame (ESF) to be supplied
	 * as argument to the remainder of the fault handling process.
	 */
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
   1b348:	b97e      	cbnz	r6, 1b36a <z_arm_fault+0x82>
   1b34a:	f240 33b2 	movw	r3, #946	; 0x3b2
   1b34e:	4a5c      	ldr	r2, [pc, #368]	; (1b4c0 <z_arm_fault+0x1d8>)
   1b350:	495c      	ldr	r1, [pc, #368]	; (1b4c4 <z_arm_fault+0x1dc>)
   1b352:	485d      	ldr	r0, [pc, #372]	; (1b4c8 <z_arm_fault+0x1e0>)
   1b354:	f018 f938 	bl	335c8 <printk>
   1b358:	485c      	ldr	r0, [pc, #368]	; (1b4cc <z_arm_fault+0x1e4>)
   1b35a:	f018 f935 	bl	335c8 <printk>
   1b35e:	f240 31b2 	movw	r1, #946	; 0x3b2
   1b362:	4857      	ldr	r0, [pc, #348]	; (1b4c0 <z_arm_fault+0x1d8>)
   1b364:	f018 fc31 	bl	33bca <assert_post_action>
   1b368:	2600      	movs	r6, #0
	*recoverable = false;
   1b36a:	2300      	movs	r3, #0
   1b36c:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
   1b370:	1efb      	subs	r3, r7, #3
   1b372:	2b09      	cmp	r3, #9
   1b374:	d87f      	bhi.n	1b476 <z_arm_fault+0x18e>
   1b376:	e8df f003 	tbb	[pc, r3]
   1b37a:	6905      	.short	0x6905
   1b37c:	7e7e4c6d 	.word	0x7e7e4c6d
   1b380:	717e7e7e 	.word	0x717e7e7e
	PR_FAULT_INFO("***** HARD FAULT *****");
   1b384:	2301      	movs	r3, #1
   1b386:	f04f 0000 	mov.w	r0, #0
	*recoverable = false;
   1b38a:	f04f 0800 	mov.w	r8, #0
	PR_FAULT_INFO("***** HARD FAULT *****");
   1b38e:	f363 0007 	bfi	r0, r3, #0, #8
   1b392:	4f49      	ldr	r7, [pc, #292]	; (1b4b8 <z_arm_fault+0x1d0>)
   1b394:	4b47      	ldr	r3, [pc, #284]	; (1b4b4 <z_arm_fault+0x1cc>)
   1b396:	494e      	ldr	r1, [pc, #312]	; (1b4d0 <z_arm_fault+0x1e8>)
   1b398:	1aff      	subs	r7, r7, r3
   1b39a:	f3c7 07c9 	ubfx	r7, r7, #3, #10
   1b39e:	f367 108f 	bfi	r0, r7, #6, #10
   1b3a2:	f018 fc29 	bl	33bf8 <log_string_sync>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1b3a6:	4b42      	ldr	r3, [pc, #264]	; (1b4b0 <z_arm_fault+0x1c8>)
	*recoverable = false;
   1b3a8:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
   1b3ac:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   1b3ae:	f014 0402 	ands.w	r4, r4, #2
   1b3b2:	d00b      	beq.n	1b3cc <z_arm_fault+0xe4>
		PR_EXC("  Bus fault on vector table read");
   1b3b4:	f04f 0000 	mov.w	r0, #0
   1b3b8:	2301      	movs	r3, #1
   1b3ba:	4946      	ldr	r1, [pc, #280]	; (1b4d4 <z_arm_fault+0x1ec>)
   1b3bc:	f363 0007 	bfi	r0, r3, #0, #8
   1b3c0:	f367 108f 	bfi	r0, r7, #6, #10
	PR_FAULT_INFO(
   1b3c4:	f018 fc18 	bl	33bf8 <log_string_sync>
	u32_t reason = K_ERR_CPU_EXCEPTION;
   1b3c8:	2400      	movs	r4, #0
   1b3ca:	e025      	b.n	1b418 <z_arm_fault+0x130>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
   1b3cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1b3ce:	005b      	lsls	r3, r3, #1
   1b3d0:	d522      	bpl.n	1b418 <z_arm_fault+0x130>
		PR_EXC("  Fault escalation (see below)");
   1b3d2:	2301      	movs	r3, #1
   1b3d4:	f04f 0000 	mov.w	r0, #0
   1b3d8:	f363 0007 	bfi	r0, r3, #0, #8
   1b3dc:	f367 108f 	bfi	r0, r7, #6, #10
   1b3e0:	493d      	ldr	r1, [pc, #244]	; (1b4d8 <z_arm_fault+0x1f0>)
   1b3e2:	f018 fc09 	bl	33bf8 <log_string_sync>
		if (SCB_MMFSR != 0) {
   1b3e6:	4b3d      	ldr	r3, [pc, #244]	; (1b4dc <z_arm_fault+0x1f4>)
   1b3e8:	781b      	ldrb	r3, [r3, #0]
   1b3ea:	b12b      	cbz	r3, 1b3f8 <z_arm_fault+0x110>
			reason = mem_manage_fault(esf, 1, recoverable);
   1b3ec:	2001      	movs	r0, #1
   1b3ee:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
   1b3f2:	f7ff fdad 	bl	1af50 <mem_manage_fault.isra.2>
   1b3f6:	e00e      	b.n	1b416 <z_arm_fault+0x12e>
		} else if (SCB_BFSR != 0) {
   1b3f8:	4b39      	ldr	r3, [pc, #228]	; (1b4e0 <z_arm_fault+0x1f8>)
   1b3fa:	781b      	ldrb	r3, [r3, #0]
   1b3fc:	b12b      	cbz	r3, 1b40a <z_arm_fault+0x122>
			reason = bus_fault(esf, 1, recoverable);
   1b3fe:	2001      	movs	r0, #1
   1b400:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
   1b404:	f7ff fe46 	bl	1b094 <bus_fault.isra.3>
   1b408:	e005      	b.n	1b416 <z_arm_fault+0x12e>
		} else if (SCB_UFSR != 0) {
   1b40a:	4b36      	ldr	r3, [pc, #216]	; (1b4e4 <z_arm_fault+0x1fc>)
   1b40c:	881b      	ldrh	r3, [r3, #0]
   1b40e:	b29b      	uxth	r3, r3
   1b410:	b113      	cbz	r3, 1b418 <z_arm_fault+0x130>
			reason = usage_fault(esf);
   1b412:	f7ff fed5 	bl	1b1c0 <usage_fault.isra.4>
   1b416:	4604      	mov	r4, r0
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
   1b418:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1b41c:	b99b      	cbnz	r3, 1b446 <z_arm_fault+0x15e>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
   1b41e:	2268      	movs	r2, #104	; 0x68
   1b420:	4631      	mov	r1, r6
   1b422:	a802      	add	r0, sp, #8
   1b424:	f01d fdd8 	bl	38fd8 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
   1b428:	9b09      	ldr	r3, [sp, #36]	; 0x24
   1b42a:	2d00      	cmp	r5, #0
   1b42c:	d03a      	beq.n	1b4a4 <z_arm_fault+0x1bc>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
   1b42e:	f3c3 0208 	ubfx	r2, r3, #0, #9
   1b432:	b922      	cbnz	r2, 1b43e <z_arm_fault+0x156>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
   1b434:	ea6f 2353 	mvn.w	r3, r3, lsr #9
   1b438:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1b43c:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
   1b43e:	a902      	add	r1, sp, #8
   1b440:	4620      	mov	r0, r4
   1b442:	f7ff fc7d 	bl	1ad40 <z_arm_fatal_error>
}
   1b446:	b01d      	add	sp, #116	; 0x74
   1b448:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
   1b44c:	f10d 0107 	add.w	r1, sp, #7
   1b450:	2000      	movs	r0, #0
   1b452:	e7ce      	b.n	1b3f2 <z_arm_fault+0x10a>
		reason = bus_fault(esf, 0, recoverable);
   1b454:	f10d 0107 	add.w	r1, sp, #7
   1b458:	2000      	movs	r0, #0
   1b45a:	e7d3      	b.n	1b404 <z_arm_fault+0x11c>
	PR_FAULT_INFO(
   1b45c:	2301      	movs	r3, #1
   1b45e:	f04f 0000 	mov.w	r0, #0
   1b462:	4a14      	ldr	r2, [pc, #80]	; (1b4b4 <z_arm_fault+0x1cc>)
   1b464:	f363 0007 	bfi	r0, r3, #0, #8
   1b468:	4b13      	ldr	r3, [pc, #76]	; (1b4b8 <z_arm_fault+0x1d0>)
   1b46a:	491f      	ldr	r1, [pc, #124]	; (1b4e8 <z_arm_fault+0x200>)
   1b46c:	1a9b      	subs	r3, r3, r2
   1b46e:	08db      	lsrs	r3, r3, #3
   1b470:	f363 108f 	bfi	r0, r3, #6, #10
   1b474:	e7a6      	b.n	1b3c4 <z_arm_fault+0xdc>
	PR_FAULT_INFO("***** %s %d) *****",
   1b476:	2301      	movs	r3, #1
   1b478:	f04f 0000 	mov.w	r0, #0
   1b47c:	4a0d      	ldr	r2, [pc, #52]	; (1b4b4 <z_arm_fault+0x1cc>)
   1b47e:	f363 0007 	bfi	r0, r3, #0, #8
   1b482:	4b0d      	ldr	r3, [pc, #52]	; (1b4b8 <z_arm_fault+0x1d0>)
   1b484:	4919      	ldr	r1, [pc, #100]	; (1b4ec <z_arm_fault+0x204>)
   1b486:	1a9b      	subs	r3, r3, r2
   1b488:	08db      	lsrs	r3, r3, #3
   1b48a:	f418 7ff8 	tst.w	r8, #496	; 0x1f0
   1b48e:	f363 108f 	bfi	r0, r3, #6, #10
   1b492:	4a17      	ldr	r2, [pc, #92]	; (1b4f0 <z_arm_fault+0x208>)
   1b494:	f1a7 0310 	sub.w	r3, r7, #16
   1b498:	bf08      	it	eq
   1b49a:	460a      	moveq	r2, r1
   1b49c:	4915      	ldr	r1, [pc, #84]	; (1b4f4 <z_arm_fault+0x20c>)
   1b49e:	f018 fbab 	bl	33bf8 <log_string_sync>
   1b4a2:	e791      	b.n	1b3c8 <z_arm_fault+0xe0>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
   1b4a4:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
   1b4a8:	f023 0301 	bic.w	r3, r3, #1
   1b4ac:	e7c6      	b.n	1b43c <z_arm_fault+0x154>
   1b4ae:	bf00      	nop
   1b4b0:	e000ed00 	.word	0xe000ed00
   1b4b4:	00039f60 	.word	0x00039f60
   1b4b8:	00039ff0 	.word	0x00039ff0
   1b4bc:	0003d3ec 	.word	0x0003d3ec
   1b4c0:	0003d253 	.word	0x0003d253
   1b4c4:	0003d40f 	.word	0x0003d40f
   1b4c8:	0003b77f 	.word	0x0003b77f
   1b4cc:	0003d422 	.word	0x0003d422
   1b4d0:	0003d460 	.word	0x0003d460
   1b4d4:	0003d477 	.word	0x0003d477
   1b4d8:	0003d498 	.word	0x0003d498
   1b4dc:	e000ed28 	.word	0xe000ed28
   1b4e0:	e000ed29 	.word	0xe000ed29
   1b4e4:	e000ed2a 	.word	0xe000ed2a
   1b4e8:	0003d4b7 	.word	0x0003d4b7
   1b4ec:	0003d3be 	.word	0x0003d3be
   1b4f0:	0003d3d3 	.word	0x0003d3d3
   1b4f4:	0003d4ed 	.word	0x0003d4ed

0001b4f8 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
   1b4f8:	4b04      	ldr	r3, [pc, #16]	; (1b50c <z_arm_fault_init+0x14>)
   1b4fa:	695a      	ldr	r2, [r3, #20]
   1b4fc:	f042 0210 	orr.w	r2, r2, #16
   1b500:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
   1b502:	695a      	ldr	r2, [r3, #20]
   1b504:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   1b508:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
   1b50a:	4770      	bx	lr
   1b50c:	e000ed00 	.word	0xe000ed00

0001b510 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
   1b510:	4b04      	ldr	r3, [pc, #16]	; (1b524 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
   1b512:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
   1b514:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
   1b516:	4288      	cmp	r0, r1
	beq _EXIT_EXC
   1b518:	d003      	beq.n	1b522 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
   1b51a:	4903      	ldr	r1, [pc, #12]	; (1b528 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
   1b51c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
   1b520:	600a      	str	r2, [r1, #0]

0001b522 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
   1b522:	4770      	bx	lr
	ldr r3, =_kernel
   1b524:	200274dc 	.word	0x200274dc
	ldr r1, =_SCS_ICSR
   1b528:	e000ed04 	.word	0xe000ed04

0001b52c <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
   1b52c:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
   1b530:	4905      	ldr	r1, [pc, #20]	; (1b548 <sys_arch_reboot+0x1c>)
   1b532:	4b06      	ldr	r3, [pc, #24]	; (1b54c <sys_arch_reboot+0x20>)
   1b534:	68ca      	ldr	r2, [r1, #12]
   1b536:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
   1b53a:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
   1b53c:	60cb      	str	r3, [r1, #12]
   1b53e:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
   1b542:	bf00      	nop
   1b544:	e7fd      	b.n	1b542 <sys_arch_reboot+0x16>
   1b546:	bf00      	nop
   1b548:	e000ed00 	.word	0xe000ed00
   1b54c:	05fa0004 	.word	0x05fa0004

0001b550 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
   1b550:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   1b552:	2120      	movs	r1, #32
   1b554:	4803      	ldr	r0, [pc, #12]	; (1b564 <z_arm_interrupt_init+0x14>)
   1b556:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
   1b558:	3301      	adds	r3, #1
   1b55a:	2b41      	cmp	r3, #65	; 0x41
   1b55c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
   1b560:	d1f9      	bne.n	1b556 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
   1b562:	4770      	bx	lr
   1b564:	e000e100 	.word	0xe000e100

0001b568 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
   1b568:	b538      	push	{r3, r4, r5, lr}
   1b56a:	4604      	mov	r4, r0
	__asm__ volatile(
   1b56c:	f04f 0320 	mov.w	r3, #32
   1b570:	f3ef 8511 	mrs	r5, BASEPRI
   1b574:	f383 8811 	msr	BASEPRI, r3
   1b578:	f3bf 8f6f 	isb	sy
	unsigned int key;

	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
   1b57c:	7b03      	ldrb	r3, [r0, #12]
   1b57e:	07db      	lsls	r3, r3, #31
   1b580:	d50c      	bpl.n	1b59c <z_impl_k_thread_abort+0x34>
   1b582:	4912      	ldr	r1, [pc, #72]	; (1b5cc <z_impl_k_thread_abort+0x64>)
   1b584:	2324      	movs	r3, #36	; 0x24
   1b586:	4a12      	ldr	r2, [pc, #72]	; (1b5d0 <z_impl_k_thread_abort+0x68>)
   1b588:	4812      	ldr	r0, [pc, #72]	; (1b5d4 <z_impl_k_thread_abort+0x6c>)
   1b58a:	f018 f81d 	bl	335c8 <printk>
   1b58e:	4812      	ldr	r0, [pc, #72]	; (1b5d8 <z_impl_k_thread_abort+0x70>)
   1b590:	f018 f81a 	bl	335c8 <printk>
   1b594:	2124      	movs	r1, #36	; 0x24
   1b596:	480e      	ldr	r0, [pc, #56]	; (1b5d0 <z_impl_k_thread_abort+0x68>)
   1b598:	f018 fb17 	bl	33bca <assert_post_action>
		 "essential thread aborted");

	z_thread_single_abort(thread);
   1b59c:	4620      	mov	r0, r4
   1b59e:	f012 f883 	bl	2d6a8 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
   1b5a2:	4b0e      	ldr	r3, [pc, #56]	; (1b5dc <z_impl_k_thread_abort+0x74>)
   1b5a4:	689b      	ldr	r3, [r3, #8]
   1b5a6:	42a3      	cmp	r3, r4
   1b5a8:	d10b      	bne.n	1b5c2 <z_impl_k_thread_abort+0x5a>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
   1b5aa:	4b0d      	ldr	r3, [pc, #52]	; (1b5e0 <z_impl_k_thread_abort+0x78>)
   1b5ac:	685a      	ldr	r2, [r3, #4]
   1b5ae:	f3c2 0208 	ubfx	r2, r2, #0, #9
   1b5b2:	b912      	cbnz	r2, 1b5ba <z_impl_k_thread_abort+0x52>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
   1b5b4:	4628      	mov	r0, r5
   1b5b6:	f7ff fa99 	bl	1aaec <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
   1b5ba:	685a      	ldr	r2, [r3, #4]
   1b5bc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   1b5c0:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
   1b5c2:	4628      	mov	r0, r5
}
   1b5c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
   1b5c8:	f01d bb7f 	b.w	38cca <z_reschedule_irqlock>
   1b5cc:	0003d541 	.word	0x0003d541
   1b5d0:	0003d500 	.word	0x0003d500
   1b5d4:	0003b77f 	.word	0x0003b77f
   1b5d8:	0003d56f 	.word	0x0003d56f
   1b5dc:	200274dc 	.word	0x200274dc
   1b5e0:	e000ed00 	.word	0xe000ed00

0001b5e4 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
   1b5e4:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
   1b5e6:	4b0e      	ldr	r3, [pc, #56]	; (1b620 <z_arm_configure_static_mpu_regions+0x3c>)
{
   1b5e8:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
   1b5ea:	9302      	str	r3, [sp, #8]
   1b5ec:	4b0d      	ldr	r3, [pc, #52]	; (1b624 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1b5ee:	4c0e      	ldr	r4, [pc, #56]	; (1b628 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
   1b5f0:	9303      	str	r3, [sp, #12]
   1b5f2:	4b0e      	ldr	r3, [pc, #56]	; (1b62c <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1b5f4:	4a0e      	ldr	r2, [pc, #56]	; (1b630 <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
   1b5f6:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
   1b5f8:	ab02      	add	r3, sp, #8
   1b5fa:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
   1b5fc:	a801      	add	r0, sp, #4
   1b5fe:	4623      	mov	r3, r4
   1b600:	2101      	movs	r1, #1
   1b602:	f000 f97d 	bl	1b900 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
   1b606:	2300      	movs	r3, #0
   1b608:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
   1b60a:	4b0a      	ldr	r3, [pc, #40]	; (1b634 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1b60c:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
   1b60e:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1b610:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
   1b612:	9305      	str	r3, [sp, #20]
   1b614:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
   1b616:	f000 f999 	bl	1b94c <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
   1b61a:	b008      	add	sp, #32
   1b61c:	bd10      	pop	{r4, pc}
   1b61e:	bf00      	nop
   1b620:	20020000 	.word	0x20020000
   1b624:	00000000 	.word	0x00000000
   1b628:	20040000 	.word	0x20040000
   1b62c:	00010006 	.word	0x00010006
   1b630:	20020000 	.word	0x20020000
   1b634:	20020900 	.word	0x20020900

0001b638 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
   1b638:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1b63a:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
   1b63c:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
   1b63e:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
   1b642:	f004 031f 	and.w	r3, r4, #31
   1b646:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1b648:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1b64a:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
   1b64c:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
   1b650:	4904      	ldr	r1, [pc, #16]	; (1b664 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
   1b652:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
   1b656:	f043 0301 	orr.w	r3, r3, #1
   1b65a:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
   1b65c:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
   1b65e:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
   1b660:	bd10      	pop	{r4, pc}
   1b662:	bf00      	nop
   1b664:	e000ed90 	.word	0xe000ed90

0001b668 <region_allocate_and_init>:

static int region_allocate_and_init(const u8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {
   1b668:	280f      	cmp	r0, #15
{
   1b66a:	b510      	push	{r4, lr}
   1b66c:	4604      	mov	r4, r0
	if (index > (get_num_regions() - 1)) {
   1b66e:	d912      	bls.n	1b696 <region_allocate_and_init+0x2e>

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
   1b670:	2301      	movs	r3, #1
   1b672:	f04f 0000 	mov.w	r0, #0
   1b676:	4a09      	ldr	r2, [pc, #36]	; (1b69c <region_allocate_and_init+0x34>)
   1b678:	f363 0007 	bfi	r0, r3, #0, #8
   1b67c:	4b08      	ldr	r3, [pc, #32]	; (1b6a0 <region_allocate_and_init+0x38>)
   1b67e:	4909      	ldr	r1, [pc, #36]	; (1b6a4 <region_allocate_and_init+0x3c>)
   1b680:	1a9b      	subs	r3, r3, r2
   1b682:	08db      	lsrs	r3, r3, #3
   1b684:	4622      	mov	r2, r4
   1b686:	f363 108f 	bfi	r0, r3, #6, #10
   1b68a:	f018 fab5 	bl	33bf8 <log_string_sync>
		return -EINVAL;
   1b68e:	f06f 0415 	mvn.w	r4, #21

	/* Program region */
	region_init(index, region_conf);

	return index;
}
   1b692:	4620      	mov	r0, r4
   1b694:	bd10      	pop	{r4, pc}
	region_init(index, region_conf);
   1b696:	f7ff ffcf 	bl	1b638 <region_init>
	return index;
   1b69a:	e7fa      	b.n	1b692 <region_allocate_and_init+0x2a>
   1b69c:	00039f60 	.word	0x00039f60
   1b6a0:	00039fe0 	.word	0x00039fe0
   1b6a4:	0003d715 	.word	0x0003d715

0001b6a8 <mpu_configure_regions_and_partition.constprop.2>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   1b6a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b6ac:	4607      	mov	r7, r0
   1b6ae:	4688      	mov	r8, r1
   1b6b0:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
   1b6b2:	2600      	movs	r6, #0
	MPU->RNR = index;
   1b6b4:	4d58      	ldr	r5, [pc, #352]	; (1b818 <mpu_configure_regions_and_partition.constprop.2+0x170>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
   1b6b6:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
   1b6b8:	4546      	cmp	r6, r8
   1b6ba:	da3d      	bge.n	1b738 <mpu_configure_regions_and_partition.constprop.2+0x90>
		if (regions[i]->size == 0U) {
   1b6bc:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
   1b6c0:	f8d3 9004 	ldr.w	r9, [r3, #4]
   1b6c4:	f1b9 0f00 	cmp.w	r9, #0
   1b6c8:	d059      	beq.n	1b77e <mpu_configure_regions_and_partition.constprop.2+0xd6>
		&&
   1b6ca:	f1b9 0f1f 	cmp.w	r9, #31
   1b6ce:	d922      	bls.n	1b716 <mpu_configure_regions_and_partition.constprop.2+0x6e>
		&&
   1b6d0:	f019 0f1f 	tst.w	r9, #31
   1b6d4:	d11f      	bne.n	1b716 <mpu_configure_regions_and_partition.constprop.2+0x6e>
		((part->start &
   1b6d6:	f8d3 a000 	ldr.w	sl, [r3]
		&&
   1b6da:	f01a 0f1f 	tst.w	sl, #31
   1b6de:	d11a      	bne.n	1b716 <mpu_configure_regions_and_partition.constprop.2+0x6e>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1b6e0:	4650      	mov	r0, sl
   1b6e2:	f019 fedb 	bl	3549c <arm_cmse_mpu_region_get>
   1b6e6:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1b6e8:	eb09 000a 	add.w	r0, r9, sl
   1b6ec:	3801      	subs	r0, #1
   1b6ee:	f019 fed5 	bl	3549c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1b6f2:	4583      	cmp	fp, r0
   1b6f4:	d024      	beq.n	1b740 <mpu_configure_regions_and_partition.constprop.2+0x98>
	return -EINVAL;
   1b6f6:	f06f 0b15 	mvn.w	fp, #21
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
   1b6fa:	2301      	movs	r3, #1
   1b6fc:	f04f 0000 	mov.w	r0, #0
   1b700:	4a46      	ldr	r2, [pc, #280]	; (1b81c <mpu_configure_regions_and_partition.constprop.2+0x174>)
   1b702:	f363 0007 	bfi	r0, r3, #0, #8
   1b706:	4b46      	ldr	r3, [pc, #280]	; (1b820 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   1b708:	4946      	ldr	r1, [pc, #280]	; (1b824 <mpu_configure_regions_and_partition.constprop.2+0x17c>)
   1b70a:	1a9b      	subs	r3, r3, r2
   1b70c:	08db      	lsrs	r3, r3, #3
   1b70e:	f363 108f 	bfi	r0, r3, #6, #10
   1b712:	465a      	mov	r2, fp
   1b714:	e00c      	b.n	1b730 <mpu_configure_regions_and_partition.constprop.2+0x88>
			LOG_ERR("Partition %u: sanity check failed.", i);
   1b716:	2301      	movs	r3, #1
   1b718:	f04f 0000 	mov.w	r0, #0
   1b71c:	4a3f      	ldr	r2, [pc, #252]	; (1b81c <mpu_configure_regions_and_partition.constprop.2+0x174>)
   1b71e:	f363 0007 	bfi	r0, r3, #0, #8
   1b722:	4b3f      	ldr	r3, [pc, #252]	; (1b820 <mpu_configure_regions_and_partition.constprop.2+0x178>)
   1b724:	4940      	ldr	r1, [pc, #256]	; (1b828 <mpu_configure_regions_and_partition.constprop.2+0x180>)
   1b726:	1a9b      	subs	r3, r3, r2
   1b728:	4632      	mov	r2, r6
   1b72a:	08db      	lsrs	r3, r3, #3
   1b72c:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_ERR("Invalid underlying region index %u",
   1b730:	f018 fa62 	bl	33bf8 <log_string_sync>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
   1b734:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
   1b738:	4620      	mov	r0, r4
   1b73a:	b005      	add	sp, #20
   1b73c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
   1b740:	f11b 0f16 	cmn.w	fp, #22
   1b744:	d0d9      	beq.n	1b6fa <mpu_configure_regions_and_partition.constprop.2+0x52>
			(u_reg_index > (reg_index - 1))) {
   1b746:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
   1b748:	455b      	cmp	r3, fp
   1b74a:	dbd6      	blt.n	1b6fa <mpu_configure_regions_and_partition.constprop.2+0x52>
	MPU->RNR = index;
   1b74c:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   1b750:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
   1b752:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   1b756:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   1b758:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
   1b75c:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
   1b760:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   1b764:	e9d1 3200 	ldrd	r3, r2, [r1]
   1b768:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
   1b76a:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
   1b76c:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
		if ((regions[i]->start == u_reg_base) &&
   1b770:	d118      	bne.n	1b7a4 <mpu_configure_regions_and_partition.constprop.2+0xfc>
   1b772:	45ca      	cmp	sl, r9
   1b774:	d105      	bne.n	1b782 <mpu_configure_regions_and_partition.constprop.2+0xda>
			mpu_configure_region(u_reg_index, regions[i]);
   1b776:	fa5f f08b 	uxtb.w	r0, fp
   1b77a:	f019 fe74 	bl	35466 <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
   1b77e:	3601      	adds	r6, #1
   1b780:	e79a      	b.n	1b6b8 <mpu_configure_regions_and_partition.constprop.2+0x10>
	MPU->RNR = index;
   1b782:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   1b786:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
   1b788:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   1b78c:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
   1b790:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
   1b792:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
   1b794:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
   1b796:	f019 fe66 	bl	35466 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   1b79a:	f110 0f16 	cmn.w	r0, #22
   1b79e:	d0c9      	beq.n	1b734 <mpu_configure_regions_and_partition.constprop.2+0x8c>
			reg_index++;
   1b7a0:	1c44      	adds	r4, r0, #1
   1b7a2:	e7ec      	b.n	1b77e <mpu_configure_regions_and_partition.constprop.2+0xd6>
	MPU->RNR = index;
   1b7a4:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   1b7a8:	692a      	ldr	r2, [r5, #16]
   1b7aa:	3b01      	subs	r3, #1
   1b7ac:	f023 031f 	bic.w	r3, r3, #31
   1b7b0:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
   1b7b4:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
   1b7b6:	45ca      	cmp	sl, r9
   1b7b8:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
   1b7ba:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
   1b7bc:	d0eb      	beq.n	1b796 <mpu_configure_regions_and_partition.constprop.2+0xee>
				mpu_configure_region(reg_index, regions[i]);
   1b7be:	f019 fe52 	bl	35466 <mpu_configure_region>
			if (reg_index == -EINVAL) {
   1b7c2:	f110 0f16 	cmn.w	r0, #22
   1b7c6:	d0b5      	beq.n	1b734 <mpu_configure_regions_and_partition.constprop.2+0x8c>
	MPU->RNR = index;
   1b7c8:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
   1b7cc:	68ea      	ldr	r2, [r5, #12]
   1b7ce:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
   1b7d2:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
	attr->rbar = MPU->RBAR &
   1b7d6:	f362 0304 	bfi	r3, r2, #0, #5
   1b7da:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   1b7de:	692b      	ldr	r3, [r5, #16]
   1b7e0:	f89d 2008 	ldrb.w	r2, [sp, #8]
   1b7e4:	085b      	lsrs	r3, r3, #1
   1b7e6:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
   1b7ea:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   1b7ee:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
   1b7f2:	e9d3 2300 	ldrd	r2, r3, [r3]
   1b7f6:	4413      	add	r3, r2
   1b7f8:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
   1b7fa:	f023 031f 	bic.w	r3, r3, #31
   1b7fe:	4453      	add	r3, sl
   1b800:	eba3 0309 	sub.w	r3, r3, r9
			reg_index++;
   1b804:	3001      	adds	r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
   1b806:	f023 031f 	bic.w	r3, r3, #31
				region_allocate_and_init(reg_index,
   1b80a:	4669      	mov	r1, sp
   1b80c:	b2c0      	uxtb	r0, r0
			fill_region.attr.r_limit =
   1b80e:	9303      	str	r3, [sp, #12]
				region_allocate_and_init(reg_index,
   1b810:	f7ff ff2a 	bl	1b668 <region_allocate_and_init>
   1b814:	e7c1      	b.n	1b79a <mpu_configure_regions_and_partition.constprop.2+0xf2>
   1b816:	bf00      	nop
   1b818:	e000ed90 	.word	0xe000ed90
   1b81c:	00039f60 	.word	0x00039f60
   1b820:	00039fe0 	.word	0x00039fe0
   1b824:	0003d6f2 	.word	0x0003d6f2
   1b828:	0003d6cf 	.word	0x0003d6cf

0001b82c <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
   1b82c:	2205      	movs	r2, #5
   1b82e:	4b03      	ldr	r3, [pc, #12]	; (1b83c <arm_core_mpu_enable+0x10>)
   1b830:	605a      	str	r2, [r3, #4]
   1b832:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1b836:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
   1b83a:	4770      	bx	lr
   1b83c:	e000ed90 	.word	0xe000ed90

0001b840 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   1b840:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
   1b844:	2200      	movs	r2, #0
   1b846:	4b01      	ldr	r3, [pc, #4]	; (1b84c <arm_core_mpu_disable+0xc>)
   1b848:	605a      	str	r2, [r3, #4]
}
   1b84a:	4770      	bx	lr
   1b84c:	e000ed90 	.word	0xe000ed90

0001b850 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
   1b850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
   1b852:	4f21      	ldr	r7, [pc, #132]	; (1b8d8 <arm_mpu_init+0x88>)
   1b854:	683e      	ldr	r6, [r7, #0]
   1b856:	2e10      	cmp	r6, #16
   1b858:	d913      	bls.n	1b882 <arm_mpu_init+0x32>
		 * what is supported by hardware. As this operation
		 * is executed during system (pre-kernel) initialization,
		 * we want to ensure we can detect an attempt to
		 * perform invalid configuration.
		 */
		__ASSERT(0,
   1b85a:	f240 133d 	movw	r3, #317	; 0x13d
   1b85e:	4a1f      	ldr	r2, [pc, #124]	; (1b8dc <arm_mpu_init+0x8c>)
   1b860:	491f      	ldr	r1, [pc, #124]	; (1b8e0 <arm_mpu_init+0x90>)
   1b862:	4820      	ldr	r0, [pc, #128]	; (1b8e4 <arm_mpu_init+0x94>)
   1b864:	f017 feb0 	bl	335c8 <printk>
   1b868:	2210      	movs	r2, #16
   1b86a:	4631      	mov	r1, r6
   1b86c:	481e      	ldr	r0, [pc, #120]	; (1b8e8 <arm_mpu_init+0x98>)
   1b86e:	f017 feab 	bl	335c8 <printk>
   1b872:	481a      	ldr	r0, [pc, #104]	; (1b8dc <arm_mpu_init+0x8c>)
   1b874:	f240 113d 	movw	r1, #317	; 0x13d
   1b878:	f018 f9a7 	bl	33bca <assert_post_action>
			"Request to configure: %u regions (supported: %u)\n",
			mpu_config.num_regions,
			get_num_regions()
		);
		return -1;
   1b87c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
}
   1b880:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1b882:	2400      	movs	r4, #0
	arm_core_mpu_disable();
   1b884:	f7ff ffdc 	bl	1b840 <arm_core_mpu_disable>
	MPU->MAIR0 =
   1b888:	4d18      	ldr	r5, [pc, #96]	; (1b8ec <arm_mpu_init+0x9c>)
   1b88a:	4a19      	ldr	r2, [pc, #100]	; (1b8f0 <arm_mpu_init+0xa0>)
   1b88c:	632a      	str	r2, [r5, #48]	; 0x30
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1b88e:	42a6      	cmp	r6, r4
   1b890:	d119      	bne.n	1b8c6 <arm_mpu_init+0x76>
	static_regions_num = mpu_config.num_regions;
   1b892:	4b18      	ldr	r3, [pc, #96]	; (1b8f4 <arm_mpu_init+0xa4>)
   1b894:	701e      	strb	r6, [r3, #0]
	arm_core_mpu_enable();
   1b896:	f7ff ffc9 	bl	1b82c <arm_core_mpu_enable>
	__ASSERT(
   1b89a:	682b      	ldr	r3, [r5, #0]
   1b89c:	f3c3 2307 	ubfx	r3, r3, #8, #8
   1b8a0:	2b10      	cmp	r3, #16
   1b8a2:	d00e      	beq.n	1b8c2 <arm_mpu_init+0x72>
   1b8a4:	4914      	ldr	r1, [pc, #80]	; (1b8f8 <arm_mpu_init+0xa8>)
   1b8a6:	f44f 73af 	mov.w	r3, #350	; 0x15e
   1b8aa:	4a0c      	ldr	r2, [pc, #48]	; (1b8dc <arm_mpu_init+0x8c>)
   1b8ac:	480d      	ldr	r0, [pc, #52]	; (1b8e4 <arm_mpu_init+0x94>)
   1b8ae:	f017 fe8b 	bl	335c8 <printk>
   1b8b2:	4812      	ldr	r0, [pc, #72]	; (1b8fc <arm_mpu_init+0xac>)
   1b8b4:	f017 fe88 	bl	335c8 <printk>
   1b8b8:	f44f 71af 	mov.w	r1, #350	; 0x15e
   1b8bc:	4807      	ldr	r0, [pc, #28]	; (1b8dc <arm_mpu_init+0x8c>)
   1b8be:	f018 f984 	bl	33bca <assert_post_action>
	return 0;
   1b8c2:	2000      	movs	r0, #0
   1b8c4:	e7dc      	b.n	1b880 <arm_mpu_init+0x30>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
   1b8c6:	6879      	ldr	r1, [r7, #4]
   1b8c8:	4620      	mov	r0, r4
   1b8ca:	eb01 1104 	add.w	r1, r1, r4, lsl #4
   1b8ce:	f7ff feb3 	bl	1b638 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
   1b8d2:	3401      	adds	r4, #1
   1b8d4:	e7db      	b.n	1b88e <arm_mpu_init+0x3e>
   1b8d6:	bf00      	nop
   1b8d8:	0003a4c0 	.word	0x0003a4c0
   1b8dc:	0003d5e9 	.word	0x0003d5e9
   1b8e0:	0003fd3b 	.word	0x0003fd3b
   1b8e4:	0003b77f 	.word	0x0003b77f
   1b8e8:	0003d629 	.word	0x0003d629
   1b8ec:	e000ed90 	.word	0xe000ed90
   1b8f0:	0044ffaa 	.word	0x0044ffaa
   1b8f4:	20027fb7 	.word	0x20027fb7
   1b8f8:	0003d65d 	.word	0x0003d65d
   1b8fc:	0003d6ae 	.word	0x0003d6ae

0001b900 <arm_core_mpu_configure_static_mpu_regions>:
{
   1b900:	b538      	push	{r3, r4, r5, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
   1b902:	4c0d      	ldr	r4, [pc, #52]	; (1b938 <arm_core_mpu_configure_static_mpu_regions+0x38>)
   1b904:	460d      	mov	r5, r1
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
   1b906:	7822      	ldrb	r2, [r4, #0]
   1b908:	f7ff fece 	bl	1b6a8 <mpu_configure_regions_and_partition.constprop.2>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
   1b90c:	7020      	strb	r0, [r4, #0]
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
   1b90e:	3016      	adds	r0, #22
   1b910:	d111      	bne.n	1b936 <arm_core_mpu_configure_static_mpu_regions+0x36>
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   1b912:	f240 1303 	movw	r3, #259	; 0x103
   1b916:	4a09      	ldr	r2, [pc, #36]	; (1b93c <arm_core_mpu_configure_static_mpu_regions+0x3c>)
   1b918:	4909      	ldr	r1, [pc, #36]	; (1b940 <arm_core_mpu_configure_static_mpu_regions+0x40>)
   1b91a:	480a      	ldr	r0, [pc, #40]	; (1b944 <arm_core_mpu_configure_static_mpu_regions+0x44>)
   1b91c:	f017 fe54 	bl	335c8 <printk>
   1b920:	4629      	mov	r1, r5
   1b922:	4809      	ldr	r0, [pc, #36]	; (1b948 <arm_core_mpu_configure_static_mpu_regions+0x48>)
   1b924:	f017 fe50 	bl	335c8 <printk>
}
   1b928:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		__ASSERT(0, "Configuring %u static MPU regions failed\n",
   1b92c:	f240 1103 	movw	r1, #259	; 0x103
   1b930:	4802      	ldr	r0, [pc, #8]	; (1b93c <arm_core_mpu_configure_static_mpu_regions+0x3c>)
   1b932:	f018 b94a 	b.w	33bca <assert_post_action>
}
   1b936:	bd38      	pop	{r3, r4, r5, pc}
   1b938:	20027fb7 	.word	0x20027fb7
   1b93c:	0003d5e9 	.word	0x0003d5e9
   1b940:	0003fd3b 	.word	0x0003fd3b
   1b944:	0003b77f 	.word	0x0003b77f
   1b948:	0003d58e 	.word	0x0003d58e

0001b94c <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
   1b94c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1b950:	4c2e      	ldr	r4, [pc, #184]	; (1ba0c <arm_core_mpu_mark_areas_for_dynamic_regions+0xc0>)
   1b952:	4689      	mov	r9, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1b954:	4680      	mov	r8, r0
   1b956:	2700      	movs	r7, #0
   1b958:	46a2      	mov	sl, r4
	attr->rbar = MPU->RBAR &
   1b95a:	f04f 0b14 	mov.w	fp, #20
	MPU->RNR = index;
   1b95e:	4d2c      	ldr	r5, [pc, #176]	; (1ba10 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1b960:	454f      	cmp	r7, r9
   1b962:	db02      	blt.n	1b96a <arm_core_mpu_mark_areas_for_dynamic_regions+0x1e>
}
   1b964:	b003      	add	sp, #12
   1b966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (dyn_region_areas[i].size == 0U) {
   1b96a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   1b96e:	9301      	str	r3, [sp, #4]
   1b970:	2b00      	cmp	r3, #0
   1b972:	d046      	beq.n	1ba02 <arm_core_mpu_mark_areas_for_dynamic_regions+0xb6>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
   1b974:	f8d8 1000 	ldr.w	r1, [r8]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1b978:	4608      	mov	r0, r1
   1b97a:	9100      	str	r1, [sp, #0]
   1b97c:	f019 fd8e 	bl	3549c <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1b980:	e9dd 1300 	ldrd	r1, r3, [sp]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
   1b984:	4606      	mov	r6, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
   1b986:	1858      	adds	r0, r3, r1
   1b988:	3801      	subs	r0, #1
   1b98a:	f019 fd87 	bl	3549c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
   1b98e:	4286      	cmp	r6, r0
   1b990:	4a20      	ldr	r2, [pc, #128]	; (1ba14 <arm_core_mpu_mark_areas_for_dynamic_regions+0xc8>)
   1b992:	d018      	beq.n	1b9c6 <arm_core_mpu_mark_areas_for_dynamic_regions+0x7a>
		dyn_reg_info[i].index =
   1b994:	2314      	movs	r3, #20
   1b996:	435f      	muls	r7, r3
   1b998:	f06f 0315 	mvn.w	r3, #21
   1b99c:	f84a 3007 	str.w	r3, [sl, r7]
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   1b9a0:	f240 1313 	movw	r3, #275	; 0x113
   1b9a4:	4a1c      	ldr	r2, [pc, #112]	; (1ba18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
   1b9a6:	491d      	ldr	r1, [pc, #116]	; (1ba1c <arm_core_mpu_mark_areas_for_dynamic_regions+0xd0>)
   1b9a8:	481d      	ldr	r0, [pc, #116]	; (1ba20 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd4>)
   1b9aa:	f017 fe0d 	bl	335c8 <printk>
   1b9ae:	4649      	mov	r1, r9
   1b9b0:	481c      	ldr	r0, [pc, #112]	; (1ba24 <arm_core_mpu_mark_areas_for_dynamic_regions+0xd8>)
   1b9b2:	f017 fe09 	bl	335c8 <printk>
   1b9b6:	f240 1113 	movw	r1, #275	; 0x113
   1b9ba:	4817      	ldr	r0, [pc, #92]	; (1ba18 <arm_core_mpu_mark_areas_for_dynamic_regions+0xcc>)
}
   1b9bc:	b003      	add	sp, #12
   1b9be:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		__ASSERT(0, "Marking %u areas for dynamic regions failed\n",
   1b9c2:	f018 b902 	b.w	33bca <assert_post_action>
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
   1b9c6:	f116 0f16 	cmn.w	r6, #22
		dyn_reg_info[i].index =
   1b9ca:	6026      	str	r6, [r4, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
   1b9cc:	d0e8      	beq.n	1b9a0 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
   1b9ce:	7813      	ldrb	r3, [r2, #0]
   1b9d0:	42b3      	cmp	r3, r6
   1b9d2:	dde5      	ble.n	1b9a0 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
	attr->rbar = MPU->RBAR &
   1b9d4:	fb0b a307 	mla	r3, fp, r7, sl
	MPU->RNR = index;
   1b9d8:	60ae      	str	r6, [r5, #8]
	MPU->RNR = index;
   1b9da:	60ae      	str	r6, [r5, #8]
	attr->rbar = MPU->RBAR &
   1b9dc:	68e8      	ldr	r0, [r5, #12]
   1b9de:	7b19      	ldrb	r1, [r3, #12]
   1b9e0:	f360 0104 	bfi	r1, r0, #0, #5
   1b9e4:	7319      	strb	r1, [r3, #12]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
   1b9e6:	6929      	ldr	r1, [r5, #16]
   1b9e8:	7b18      	ldrb	r0, [r3, #12]
   1b9ea:	0849      	lsrs	r1, r1, #1
   1b9ec:	f361 1047 	bfi	r0, r1, #5, #3
   1b9f0:	7318      	strb	r0, [r3, #12]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
   1b9f2:	68eb      	ldr	r3, [r5, #12]
   1b9f4:	f023 031f 	bic.w	r3, r3, #31
   1b9f8:	6063      	str	r3, [r4, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
   1b9fa:	692b      	ldr	r3, [r5, #16]
   1b9fc:	f023 031f 	bic.w	r3, r3, #31
   1ba00:	6123      	str	r3, [r4, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
   1ba02:	3701      	adds	r7, #1
   1ba04:	3414      	adds	r4, #20
   1ba06:	f108 080c 	add.w	r8, r8, #12
   1ba0a:	e7a9      	b.n	1b960 <arm_core_mpu_mark_areas_for_dynamic_regions+0x14>
   1ba0c:	20021770 	.word	0x20021770
   1ba10:	e000ed90 	.word	0xe000ed90
   1ba14:	20027fb7 	.word	0x20027fb7
   1ba18:	0003d5e9 	.word	0x0003d5e9
   1ba1c:	0003fd3b 	.word	0x0003fd3b
   1ba20:	0003b77f 	.word	0x0003b77f
   1ba24:	0003d5ba 	.word	0x0003d5ba

0001ba28 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
   1ba28:	4b01      	ldr	r3, [pc, #4]	; (1ba30 <__stdout_hook_install+0x8>)
   1ba2a:	6018      	str	r0, [r3, #0]
}
   1ba2c:	4770      	bx	lr
   1ba2e:	bf00      	nop
   1ba30:	200200b4 	.word	0x200200b4

0001ba34 <z_impl_zephyr_read_stdin>:
{
	_stdin_hook = hook;
}

int z_impl_zephyr_read_stdin(char *buf, int nbytes)
{
   1ba34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ba36:	4606      	mov	r6, r0
   1ba38:	460d      	mov	r5, r1
	int i = 0;

	for (i = 0; i < nbytes; i++) {
   1ba3a:	2400      	movs	r4, #0
		*(buf + i) = _stdin_hook();
   1ba3c:	4f06      	ldr	r7, [pc, #24]	; (1ba58 <z_impl_zephyr_read_stdin+0x24>)
	for (i = 0; i < nbytes; i++) {
   1ba3e:	42ac      	cmp	r4, r5
   1ba40:	da08      	bge.n	1ba54 <z_impl_zephyr_read_stdin+0x20>
		*(buf + i) = _stdin_hook();
   1ba42:	683b      	ldr	r3, [r7, #0]
   1ba44:	4798      	blx	r3
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   1ba46:	280a      	cmp	r0, #10
		*(buf + i) = _stdin_hook();
   1ba48:	5530      	strb	r0, [r6, r4]
		if ((*(buf + i) == '\n') || (*(buf + i) == '\r')) {
   1ba4a:	f104 0401 	add.w	r4, r4, #1
   1ba4e:	d001      	beq.n	1ba54 <z_impl_zephyr_read_stdin+0x20>
   1ba50:	280d      	cmp	r0, #13
   1ba52:	d1f4      	bne.n	1ba3e <z_impl_zephyr_read_stdin+0xa>
			i++;
			break;
		}
	}
	return i;
}
   1ba54:	4620      	mov	r0, r4
   1ba56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1ba58:	200200b0 	.word	0x200200b0

0001ba5c <z_impl_zephyr_write_stdout>:
}
#include <syscalls/z_zephyr_read_stdin_mrsh.c>
#endif

int z_impl_zephyr_write_stdout(const void *buffer, int nbytes)
{
   1ba5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1ba5e:	460e      	mov	r6, r1
   1ba60:	4f09      	ldr	r7, [pc, #36]	; (1ba88 <z_impl_zephyr_write_stdout+0x2c>)
   1ba62:	1e44      	subs	r4, r0, #1
	const char *buf = buffer;
	int i;

	for (i = 0; i < nbytes; i++) {
   1ba64:	f1c0 0501 	rsb	r5, r0, #1
   1ba68:	192b      	adds	r3, r5, r4
   1ba6a:	429e      	cmp	r6, r3
   1ba6c:	dc01      	bgt.n	1ba72 <z_impl_zephyr_write_stdout+0x16>
			_stdout_hook('\r');
		}
		_stdout_hook(*(buf + i));
	}
	return nbytes;
}
   1ba6e:	4630      	mov	r0, r6
   1ba70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (*(buf + i) == '\n') {
   1ba72:	7863      	ldrb	r3, [r4, #1]
   1ba74:	2b0a      	cmp	r3, #10
   1ba76:	d102      	bne.n	1ba7e <z_impl_zephyr_write_stdout+0x22>
			_stdout_hook('\r');
   1ba78:	683b      	ldr	r3, [r7, #0]
   1ba7a:	200d      	movs	r0, #13
   1ba7c:	4798      	blx	r3
		_stdout_hook(*(buf + i));
   1ba7e:	683b      	ldr	r3, [r7, #0]
   1ba80:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   1ba84:	4798      	blx	r3
   1ba86:	e7ef      	b.n	1ba68 <z_impl_zephyr_write_stdout+0xc>
   1ba88:	200200b4 	.word	0x200200b4

0001ba8c <_exit>:
	return 0;
}
__weak FUNC_ALIAS(_fstat, fstat, int);

__weak void _exit(int status)
{
   1ba8c:	b508      	push	{r3, lr}
	return z_impl_zephyr_write_stdout(buf, nbytes);
   1ba8e:	2105      	movs	r1, #5
   1ba90:	4801      	ldr	r0, [pc, #4]	; (1ba98 <_exit+0xc>)
   1ba92:	f7ff ffe3 	bl	1ba5c <z_impl_zephyr_write_stdout>
	_write(1, "exit\n", 5);
	while (1) {
		;
   1ba96:	e7fe      	b.n	1ba96 <_exit+0xa>
   1ba98:	0003d73b 	.word	0x0003d73b

0001ba9c <_sbrk>:
}

static LIBC_DATA SYS_SEM_DEFINE(heap_sem, 1, 1);

void *_sbrk(int count)
{
   1ba9c:	b538      	push	{r3, r4, r5, lr}
   1ba9e:	4605      	mov	r5, r0
	void *ret, *ptr;

	sys_sem_take(&heap_sem, K_FOREVER);
   1baa0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1baa4:	480b      	ldr	r0, [pc, #44]	; (1bad4 <_sbrk+0x38>)
   1baa6:	f017 fdae 	bl	33606 <sys_sem_take>

#if CONFIG_NEWLIB_LIBC_ALIGNED_HEAP_SIZE
	ptr = heap_base + heap_sz;
#else
	ptr = ((char *)HEAP_BASE) + heap_sz;
   1baaa:	4a0b      	ldr	r2, [pc, #44]	; (1bad8 <_sbrk+0x3c>)
#endif

	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   1baac:	490b      	ldr	r1, [pc, #44]	; (1badc <_sbrk+0x40>)
	ptr = ((char *)HEAP_BASE) + heap_sz;
   1baae:	6814      	ldr	r4, [r2, #0]
	if ((heap_sz + count) < MAX_HEAP_SIZE) {
   1bab0:	f1c1 5300 	rsb	r3, r1, #536870912	; 0x20000000
   1bab4:	4425      	add	r5, r4
   1bab6:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   1baba:	429d      	cmp	r5, r3
		heap_sz += count;
		ret = ptr;
	} else {
		ret = (void *)-1;
   1babc:	bf2c      	ite	cs
   1babe:	f04f 34ff 	movcs.w	r4, #4294967295	; 0xffffffff
	ptr = ((char *)HEAP_BASE) + heap_sz;
   1bac2:	1864      	addcc	r4, r4, r1
	}

	sys_sem_give(&heap_sem);
   1bac4:	4803      	ldr	r0, [pc, #12]	; (1bad4 <_sbrk+0x38>)
		heap_sz += count;
   1bac6:	bf38      	it	cc
   1bac8:	6015      	strcc	r5, [r2, #0]
	sys_sem_give(&heap_sem);
   1baca:	f017 fd97 	bl	335fc <sys_sem_give>

	return ret;
}
   1bace:	4620      	mov	r0, r4
   1bad0:	bd38      	pop	{r3, r4, r5, pc}
   1bad2:	bf00      	nop
   1bad4:	2002071c 	.word	0x2002071c
   1bad8:	20021784 	.word	0x20021784
   1badc:	20038b6f 	.word	0x20038b6f

0001bae0 <thingy91_board_init>:
#endif
	return 0;
}

static int thingy91_board_init(struct device *dev)
{
   1bae0:	b530      	push	{r4, r5, lr}
   1bae2:	b0a3      	sub	sp, #140	; 0x8c
	return z_impl_zsock_socket(family, type, proto);
   1bae4:	f240 2201 	movw	r2, #513	; 0x201
   1bae8:	2102      	movs	r1, #2
   1baea:	2066      	movs	r0, #102	; 0x66
   1baec:	f7fd fc8a 	bl	19404 <z_impl_zsock_socket>
	if (at_socket_fd == -1) {
   1baf0:	1c43      	adds	r3, r0, #1
   1baf2:	4604      	mov	r4, r0
   1baf4:	d11f      	bne.n	1bb36 <thingy91_board_init+0x56>
		LOG_ERR("AT socket could not be opened");
   1baf6:	2301      	movs	r3, #1
   1baf8:	f04f 0000 	mov.w	r0, #0
   1bafc:	4a5d      	ldr	r2, [pc, #372]	; (1bc74 <thingy91_board_init+0x194>)
   1bafe:	f363 0007 	bfi	r0, r3, #0, #8
   1bb02:	4b5d      	ldr	r3, [pc, #372]	; (1bc78 <thingy91_board_init+0x198>)
   1bb04:	495d      	ldr	r1, [pc, #372]	; (1bc7c <thingy91_board_init+0x19c>)
   1bb06:	1a9b      	subs	r3, r3, r2
   1bb08:	08db      	lsrs	r3, r3, #3
   1bb0a:	f363 108f 	bfi	r0, r3, #6, #10
   1bb0e:	f018 f873 	bl	33bf8 <log_string_sync>
		return -EFAULT;
   1bb12:	f06f 050d 	mvn.w	r5, #13
	int err;

	err = thingy91_magpio_configure();
	if (err) {
		LOG_ERR("thingy91_magpio_configure failed with error: %d", err);
   1bb16:	2301      	movs	r3, #1
   1bb18:	f04f 0000 	mov.w	r0, #0
   1bb1c:	4a55      	ldr	r2, [pc, #340]	; (1bc74 <thingy91_board_init+0x194>)
   1bb1e:	f363 0007 	bfi	r0, r3, #0, #8
   1bb22:	4b55      	ldr	r3, [pc, #340]	; (1bc78 <thingy91_board_init+0x198>)
   1bb24:	4956      	ldr	r1, [pc, #344]	; (1bc80 <thingy91_board_init+0x1a0>)
   1bb26:	1a9b      	subs	r3, r3, r2
   1bb28:	08db      	lsrs	r3, r3, #3
   1bb2a:	f363 108f 	bfi	r0, r3, #6, #10
   1bb2e:	462a      	mov	r2, r5
   1bb30:	f018 f862 	bl	33bf8 <log_string_sync>
		return err;
   1bb34:	e09a      	b.n	1bc6c <thingy91_board_init+0x18c>
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   1bb36:	2500      	movs	r5, #0
   1bb38:	2210      	movs	r2, #16
   1bb3a:	e9cd 5500 	strd	r5, r5, [sp]
   1bb3e:	462b      	mov	r3, r5
   1bb40:	4950      	ldr	r1, [pc, #320]	; (1bc84 <thingy91_board_init+0x1a4>)
   1bb42:	f018 f9a5 	bl	33e90 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_TRACE)) {
   1bb46:	2810      	cmp	r0, #16
   1bb48:	d01d      	beq.n	1bb86 <thingy91_board_init+0xa6>
		LOG_ERR("XMODEMTRACE command failed");
   1bb4a:	2301      	movs	r3, #1
   1bb4c:	f04f 0000 	mov.w	r0, #0
   1bb50:	4a48      	ldr	r2, [pc, #288]	; (1bc74 <thingy91_board_init+0x194>)
   1bb52:	f363 0007 	bfi	r0, r3, #0, #8
   1bb56:	4b48      	ldr	r3, [pc, #288]	; (1bc78 <thingy91_board_init+0x198>)
   1bb58:	494b      	ldr	r1, [pc, #300]	; (1bc88 <thingy91_board_init+0x1a8>)
   1bb5a:	1a9b      	subs	r3, r3, r2
   1bb5c:	08db      	lsrs	r3, r3, #3
   1bb5e:	f363 108f 	bfi	r0, r3, #6, #10
   1bb62:	f018 f849 	bl	33bf8 <log_string_sync>
		close(at_socket_fd);
   1bb66:	4620      	mov	r0, r4
   1bb68:	f019 fcc0 	bl	354ec <close>
		__ASSERT_NO_MSG(false);
   1bb6c:	4947      	ldr	r1, [pc, #284]	; (1bc8c <thingy91_board_init+0x1ac>)
   1bb6e:	232a      	movs	r3, #42	; 0x2a
   1bb70:	4a47      	ldr	r2, [pc, #284]	; (1bc90 <thingy91_board_init+0x1b0>)
   1bb72:	4848      	ldr	r0, [pc, #288]	; (1bc94 <thingy91_board_init+0x1b4>)
   1bb74:	f017 fd28 	bl	335c8 <printk>
   1bb78:	212a      	movs	r1, #42	; 0x2a
		__ASSERT_NO_MSG(false);
   1bb7a:	4845      	ldr	r0, [pc, #276]	; (1bc90 <thingy91_board_init+0x1b0>)
   1bb7c:	f018 f825 	bl	33bca <assert_post_action>
		return -EIO;
   1bb80:	f06f 0504 	mvn.w	r5, #4
   1bb84:	e7c7      	b.n	1bb16 <thingy91_board_init+0x36>
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   1bb86:	2280      	movs	r2, #128	; 0x80
   1bb88:	e9cd 5500 	strd	r5, r5, [sp]
   1bb8c:	462b      	mov	r3, r5
   1bb8e:	a902      	add	r1, sp, #8
   1bb90:	4620      	mov	r0, r4
   1bb92:	f018 f9cf 	bl	33f34 <z_impl_zsock_recvfrom>
	if ((buffer < 2) ||
   1bb96:	2801      	cmp	r0, #1
   1bb98:	dc18      	bgt.n	1bbcc <thingy91_board_init+0xec>
		LOG_ERR("XMODEMTRACE received unexpected response");
   1bb9a:	2301      	movs	r3, #1
   1bb9c:	f04f 0000 	mov.w	r0, #0
   1bba0:	4a34      	ldr	r2, [pc, #208]	; (1bc74 <thingy91_board_init+0x194>)
   1bba2:	f363 0007 	bfi	r0, r3, #0, #8
   1bba6:	4b34      	ldr	r3, [pc, #208]	; (1bc78 <thingy91_board_init+0x198>)
   1bba8:	493b      	ldr	r1, [pc, #236]	; (1bc98 <thingy91_board_init+0x1b8>)
   1bbaa:	1a9b      	subs	r3, r3, r2
   1bbac:	08db      	lsrs	r3, r3, #3
   1bbae:	f363 108f 	bfi	r0, r3, #6, #10
   1bbb2:	f018 f821 	bl	33bf8 <log_string_sync>
		close(at_socket_fd);
   1bbb6:	4620      	mov	r0, r4
   1bbb8:	f019 fc98 	bl	354ec <close>
		__ASSERT_NO_MSG(false);
   1bbbc:	4933      	ldr	r1, [pc, #204]	; (1bc8c <thingy91_board_init+0x1ac>)
   1bbbe:	2334      	movs	r3, #52	; 0x34
   1bbc0:	4a33      	ldr	r2, [pc, #204]	; (1bc90 <thingy91_board_init+0x1b0>)
   1bbc2:	4834      	ldr	r0, [pc, #208]	; (1bc94 <thingy91_board_init+0x1b4>)
   1bbc4:	f017 fd00 	bl	335c8 <printk>
   1bbc8:	2134      	movs	r1, #52	; 0x34
   1bbca:	e7d6      	b.n	1bb7a <thingy91_board_init+0x9a>
	    (memcmp("OK", read_buffer, 2 != 0))) {
   1bbcc:	2201      	movs	r2, #1
   1bbce:	a902      	add	r1, sp, #8
   1bbd0:	4832      	ldr	r0, [pc, #200]	; (1bc9c <thingy91_board_init+0x1bc>)
   1bbd2:	f01d f9f3 	bl	38fbc <memcmp>
	if ((buffer < 2) ||
   1bbd6:	4605      	mov	r5, r0
   1bbd8:	2800      	cmp	r0, #0
   1bbda:	d1de      	bne.n	1bb9a <thingy91_board_init+0xba>
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   1bbdc:	225c      	movs	r2, #92	; 0x5c
   1bbde:	e9cd 0000 	strd	r0, r0, [sp]
   1bbe2:	4603      	mov	r3, r0
   1bbe4:	492e      	ldr	r1, [pc, #184]	; (1bca0 <thingy91_board_init+0x1c0>)
   1bbe6:	4620      	mov	r0, r4
   1bbe8:	f018 f952 	bl	33e90 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_MAGPIO)) {
   1bbec:	285c      	cmp	r0, #92	; 0x5c
   1bbee:	d00c      	beq.n	1bc0a <thingy91_board_init+0x12a>
		LOG_ERR("MAGPIO command failed");
   1bbf0:	2301      	movs	r3, #1
   1bbf2:	f04f 0000 	mov.w	r0, #0
   1bbf6:	4a1f      	ldr	r2, [pc, #124]	; (1bc74 <thingy91_board_init+0x194>)
   1bbf8:	f363 0007 	bfi	r0, r3, #0, #8
   1bbfc:	4b1e      	ldr	r3, [pc, #120]	; (1bc78 <thingy91_board_init+0x198>)
   1bbfe:	4929      	ldr	r1, [pc, #164]	; (1bca4 <thingy91_board_init+0x1c4>)
   1bc00:	1a9b      	subs	r3, r3, r2
   1bc02:	08db      	lsrs	r3, r3, #3
   1bc04:	f363 108f 	bfi	r0, r3, #6, #10
   1bc08:	e015      	b.n	1bc36 <thingy91_board_init+0x156>
   1bc0a:	2217      	movs	r2, #23
   1bc0c:	e9cd 5500 	strd	r5, r5, [sp]
   1bc10:	462b      	mov	r3, r5
   1bc12:	4925      	ldr	r1, [pc, #148]	; (1bca8 <thingy91_board_init+0x1c8>)
   1bc14:	4620      	mov	r0, r4
   1bc16:	f018 f93b 	bl	33e90 <z_impl_zsock_sendto>
	if (buffer != AT_CMD_LEN(AT_CMD_COEX0)) {
   1bc1a:	2817      	cmp	r0, #23
   1bc1c:	d011      	beq.n	1bc42 <thingy91_board_init+0x162>
		LOG_ERR("COEX0 command failed");
   1bc1e:	2301      	movs	r3, #1
   1bc20:	f04f 0000 	mov.w	r0, #0
   1bc24:	4a13      	ldr	r2, [pc, #76]	; (1bc74 <thingy91_board_init+0x194>)
   1bc26:	f363 0007 	bfi	r0, r3, #0, #8
   1bc2a:	4b13      	ldr	r3, [pc, #76]	; (1bc78 <thingy91_board_init+0x198>)
   1bc2c:	491f      	ldr	r1, [pc, #124]	; (1bcac <thingy91_board_init+0x1cc>)
   1bc2e:	1a9b      	subs	r3, r3, r2
   1bc30:	08db      	lsrs	r3, r3, #3
   1bc32:	f363 108f 	bfi	r0, r3, #6, #10
   1bc36:	f017 ffdf 	bl	33bf8 <log_string_sync>
		close(at_socket_fd);
   1bc3a:	4620      	mov	r0, r4
   1bc3c:	f019 fc56 	bl	354ec <close>
   1bc40:	e79e      	b.n	1bb80 <thingy91_board_init+0xa0>
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   1bc42:	2280      	movs	r2, #128	; 0x80
   1bc44:	e9cd 5500 	strd	r5, r5, [sp]
   1bc48:	462b      	mov	r3, r5
   1bc4a:	a902      	add	r1, sp, #8
   1bc4c:	4620      	mov	r0, r4
   1bc4e:	f018 f971 	bl	33f34 <z_impl_zsock_recvfrom>
	if ((buffer < 2) ||
   1bc52:	2801      	cmp	r0, #1
   1bc54:	ddcc      	ble.n	1bbf0 <thingy91_board_init+0x110>
	    (memcmp("OK", read_buffer, 2 != 0))) {
   1bc56:	2201      	movs	r2, #1
   1bc58:	a902      	add	r1, sp, #8
   1bc5a:	4810      	ldr	r0, [pc, #64]	; (1bc9c <thingy91_board_init+0x1bc>)
   1bc5c:	f01d f9ae 	bl	38fbc <memcmp>
	if ((buffer < 2) ||
   1bc60:	4605      	mov	r5, r0
   1bc62:	2800      	cmp	r0, #0
   1bc64:	d1c4      	bne.n	1bbf0 <thingy91_board_init+0x110>
	close(at_socket_fd);
   1bc66:	4620      	mov	r0, r4
   1bc68:	f019 fc40 	bl	354ec <close>
	}

	return 0;
}
   1bc6c:	4628      	mov	r0, r5
   1bc6e:	b023      	add	sp, #140	; 0x8c
   1bc70:	bd30      	pop	{r4, r5, pc}
   1bc72:	bf00      	nop
   1bc74:	00039f60 	.word	0x00039f60
   1bc78:	00039f70 	.word	0x00039f70
   1bc7c:	0003d760 	.word	0x0003d760
   1bc80:	0003d8b4 	.word	0x0003d8b4
   1bc84:	0003d77e 	.word	0x0003d77e
   1bc88:	0003d78f 	.word	0x0003d78f
   1bc8c:	0003fd3b 	.word	0x0003fd3b
   1bc90:	0003d7aa 	.word	0x0003d7aa
   1bc94:	0003b77f 	.word	0x0003b77f
   1bc98:	0003d7e8 	.word	0x0003d7e8
   1bc9c:	0003d811 	.word	0x0003d811
   1bca0:	0003d814 	.word	0x0003d814
   1bca4:	0003d871 	.word	0x0003d871
   1bca8:	0003d887 	.word	0x0003d887
   1bcac:	0003d89f 	.word	0x0003d89f

0001bcb0 <net_buf_id>:

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	return buf - pool->__bufs;
   1bcb0:	212c      	movs	r1, #44	; 0x2c
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1bcb2:	7983      	ldrb	r3, [r0, #6]
	return buf - pool->__bufs;
   1bcb4:	4a04      	ldr	r2, [pc, #16]	; (1bcc8 <net_buf_id+0x18>)
   1bcb6:	fb01 2303 	mla	r3, r1, r3, r2
   1bcba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1bcbc:	1ac0      	subs	r0, r0, r3
}
   1bcbe:	4b03      	ldr	r3, [pc, #12]	; (1bccc <net_buf_id+0x1c>)
	return buf - pool->__bufs;
   1bcc0:	10c0      	asrs	r0, r0, #3
}
   1bcc2:	4358      	muls	r0, r3
   1bcc4:	4770      	bx	lr
   1bcc6:	bf00      	nop
   1bcc8:	200207f8 	.word	0x200207f8
   1bccc:	aaaaaaab 	.word	0xaaaaaaab

0001bcd0 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
   1bcd0:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1bcd2:	242c      	movs	r4, #44	; 0x2c
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1bcd4:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1bcd6:	4a09      	ldr	r2, [pc, #36]	; (1bcfc <fixed_data_alloc+0x2c>)
   1bcd8:	fb04 2303 	mla	r3, r4, r3, r2
   1bcdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24

	*size = MIN(fixed->data_size, *size);
   1bcde:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   1bce0:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
   1bce2:	6823      	ldr	r3, [r4, #0]
   1bce4:	429a      	cmp	r2, r3
   1bce6:	bf94      	ite	ls
   1bce8:	600a      	strls	r2, [r1, #0]
   1bcea:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
   1bcec:	f7ff ffe0 	bl	1bcb0 <net_buf_id>
   1bcf0:	e9d4 2300 	ldrd	r2, r3, [r4]
}
   1bcf4:	fb02 3000 	mla	r0, r2, r0, r3
   1bcf8:	bd10      	pop	{r4, pc}
   1bcfa:	bf00      	nop
   1bcfc:	200207f8 	.word	0x200207f8

0001bd00 <net_buf_reset>:
{
   1bd00:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(buf->flags == 0U);
   1bd02:	7943      	ldrb	r3, [r0, #5]
{
   1bd04:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(buf->flags == 0U);
   1bd06:	b14b      	cbz	r3, 1bd1c <net_buf_reset+0x1c>
   1bd08:	490d      	ldr	r1, [pc, #52]	; (1bd40 <net_buf_reset+0x40>)
   1bd0a:	480e      	ldr	r0, [pc, #56]	; (1bd44 <net_buf_reset+0x44>)
   1bd0c:	234f      	movs	r3, #79	; 0x4f
   1bd0e:	4a0e      	ldr	r2, [pc, #56]	; (1bd48 <net_buf_reset+0x48>)
   1bd10:	f017 fc5a 	bl	335c8 <printk>
   1bd14:	214f      	movs	r1, #79	; 0x4f
   1bd16:	480c      	ldr	r0, [pc, #48]	; (1bd48 <net_buf_reset+0x48>)
   1bd18:	f017 ff57 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(buf->frags == NULL);
   1bd1c:	6823      	ldr	r3, [r4, #0]
   1bd1e:	b14b      	cbz	r3, 1bd34 <net_buf_reset+0x34>
   1bd20:	490a      	ldr	r1, [pc, #40]	; (1bd4c <net_buf_reset+0x4c>)
   1bd22:	4808      	ldr	r0, [pc, #32]	; (1bd44 <net_buf_reset+0x44>)
   1bd24:	2350      	movs	r3, #80	; 0x50
   1bd26:	4a08      	ldr	r2, [pc, #32]	; (1bd48 <net_buf_reset+0x48>)
   1bd28:	f017 fc4e 	bl	335c8 <printk>
   1bd2c:	2150      	movs	r1, #80	; 0x50
   1bd2e:	4806      	ldr	r0, [pc, #24]	; (1bd48 <net_buf_reset+0x48>)
   1bd30:	f017 ff4b 	bl	33bca <assert_post_action>
 *
 * @param buf Buffer to reset.
 */
static inline void net_buf_simple_reset(struct net_buf_simple *buf)
{
	buf->len  = 0U;
   1bd34:	2300      	movs	r3, #0
   1bd36:	81a3      	strh	r3, [r4, #12]
	buf->data = buf->__buf;
   1bd38:	6923      	ldr	r3, [r4, #16]
   1bd3a:	60a3      	str	r3, [r4, #8]
}
   1bd3c:	bd10      	pop	{r4, pc}
   1bd3e:	bf00      	nop
   1bd40:	0003d92a 	.word	0x0003d92a
   1bd44:	0003b77f 	.word	0x0003b77f
   1bd48:	0003d906 	.word	0x0003d906
   1bd4c:	0003d93b 	.word	0x0003d93b

0001bd50 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
   1bd50:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1bd54:	4605      	mov	r5, r0
	u64_t end = z_timeout_end_calc(timeout);
   1bd56:	4610      	mov	r0, r2
{
   1bd58:	9101      	str	r1, [sp, #4]
   1bd5a:	4616      	mov	r6, r2
	u64_t end = z_timeout_end_calc(timeout);
   1bd5c:	f01d f870 	bl	38e40 <z_timeout_end_calc>
   1bd60:	4607      	mov	r7, r0
   1bd62:	468a      	mov	sl, r1
	struct net_buf *buf;
	unsigned int key;

	__ASSERT_NO_MSG(pool);
   1bd64:	b94d      	cbnz	r5, 1bd7a <net_buf_alloc_len+0x2a>
   1bd66:	494c      	ldr	r1, [pc, #304]	; (1be98 <net_buf_alloc_len+0x148>)
   1bd68:	484c      	ldr	r0, [pc, #304]	; (1be9c <net_buf_alloc_len+0x14c>)
   1bd6a:	23f1      	movs	r3, #241	; 0xf1
   1bd6c:	4a4c      	ldr	r2, [pc, #304]	; (1bea0 <net_buf_alloc_len+0x150>)
   1bd6e:	f017 fc2b 	bl	335c8 <printk>
   1bd72:	21f1      	movs	r1, #241	; 0xf1
   1bd74:	484a      	ldr	r0, [pc, #296]	; (1bea0 <net_buf_alloc_len+0x150>)
   1bd76:	f017 ff28 	bl	33bca <assert_post_action>
   1bd7a:	f04f 0320 	mov.w	r3, #32
   1bd7e:	f3ef 8b11 	mrs	fp, BASEPRI
   1bd82:	f383 8811 	msr	BASEPRI, r3
   1bd86:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
   1bd8a:	8beb      	ldrh	r3, [r5, #30]
   1bd8c:	2b00      	cmp	r3, #0
   1bd8e:	d056      	beq.n	1be3e <net_buf_alloc_len+0xee>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
   1bd90:	8baa      	ldrh	r2, [r5, #28]
   1bd92:	429a      	cmp	r2, r3
   1bd94:	d93f      	bls.n	1be16 <net_buf_alloc_len+0xc6>
	return z_impl_k_queue_get(queue, timeout);
   1bd96:	2100      	movs	r1, #0
   1bd98:	4628      	mov	r0, r5
   1bd9a:	f010 fea1 	bl	2cae0 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
   1bd9e:	4604      	mov	r4, r0
   1bda0:	2800      	cmp	r0, #0
   1bda2:	d038      	beq.n	1be16 <net_buf_alloc_len+0xc6>
	__asm__ volatile(
   1bda4:	f38b 8811 	msr	BASEPRI, fp
   1bda8:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
   1bdac:	9d01      	ldr	r5, [sp, #4]
   1bdae:	2d00      	cmp	r5, #0
   1bdb0:	d070      	beq.n	1be94 <net_buf_alloc_len+0x144>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1bdb2:	1c73      	adds	r3, r6, #1
   1bdb4:	2b01      	cmp	r3, #1
   1bdb6:	d916      	bls.n	1bde6 <net_buf_alloc_len+0x96>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			s64_t remaining = end - z_tick_get();
   1bdb8:	f012 ffa0 	bl	2ecfc <z_tick_get>
   1bdbc:	ebb7 0800 	subs.w	r8, r7, r0
   1bdc0:	eb6a 0901 	sbc.w	r9, sl, r1

			if (remaining <= 0) {
   1bdc4:	f1b8 0f01 	cmp.w	r8, #1
   1bdc8:	f179 0300 	sbcs.w	r3, r9, #0
   1bdcc:	bfa3      	ittte	ge
   1bdce:	f647 72ff 	movwge	r2, #32767	; 0x7fff
   1bdd2:	2300      	movge	r3, #0
   1bdd4:	f44f 717a 	movge.w	r1, #1000	; 0x3e8
				timeout = K_NO_WAIT;
   1bdd8:	2600      	movlt	r6, #0
   1bdda:	bfa2      	ittt	ge
   1bddc:	fbe1 2308 	umlalge	r2, r3, r1, r8
   1bde0:	0bd6      	lsrge	r6, r2, #15
   1bde2:	ea46 4643 	orrge.w	r6, r6, r3, lsl #17
	return pool->alloc->cb->alloc(buf, size, timeout);
   1bde6:	f04f 082c 	mov.w	r8, #44	; 0x2c
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
   1bdea:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
   1bdec:	4f2d      	ldr	r7, [pc, #180]	; (1bea4 <net_buf_alloc_len+0x154>)
   1bdee:	4632      	mov	r2, r6
   1bdf0:	fb08 7303 	mla	r3, r8, r3, r7
   1bdf4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1bdf6:	a901      	add	r1, sp, #4
   1bdf8:	681b      	ldr	r3, [r3, #0]
   1bdfa:	4620      	mov	r0, r4
   1bdfc:	681b      	ldr	r3, [r3, #0]
   1bdfe:	4798      	blx	r3
   1be00:	4606      	mov	r6, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
   1be02:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
   1be04:	bb50      	cbnz	r0, 1be5c <net_buf_alloc_len+0x10c>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
   1be06:	79a0      	ldrb	r0, [r4, #6]
   1be08:	4621      	mov	r1, r4
   1be0a:	fb00 7008 	mla	r0, r0, r8, r7
   1be0e:	f01c ff4e 	bl	38cae <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
   1be12:	4634      	mov	r4, r6
   1be14:	e01e      	b.n	1be54 <net_buf_alloc_len+0x104>
		uninit_count = pool->uninit_count--;
   1be16:	8beb      	ldrh	r3, [r5, #30]
   1be18:	1e5a      	subs	r2, r3, #1
   1be1a:	83ea      	strh	r2, [r5, #30]
   1be1c:	f38b 8811 	msr	BASEPRI, fp
   1be20:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
   1be24:	2218      	movs	r2, #24
   1be26:	8bac      	ldrh	r4, [r5, #28]
   1be28:	1ae4      	subs	r4, r4, r3
   1be2a:	6aab      	ldr	r3, [r5, #40]	; 0x28
   1be2c:	fb02 3404 	mla	r4, r2, r4, r3
	return pool - _net_buf_pool_list;
   1be30:	4b1c      	ldr	r3, [pc, #112]	; (1bea4 <net_buf_alloc_len+0x154>)
   1be32:	1aed      	subs	r5, r5, r3
   1be34:	4b1c      	ldr	r3, [pc, #112]	; (1bea8 <net_buf_alloc_len+0x158>)
   1be36:	10ad      	asrs	r5, r5, #2
   1be38:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
   1be3a:	71a5      	strb	r5, [r4, #6]
		goto success;
   1be3c:	e7b6      	b.n	1bdac <net_buf_alloc_len+0x5c>
   1be3e:	f38b 8811 	msr	BASEPRI, fp
   1be42:	f3bf 8f6f 	isb	sy
   1be46:	4631      	mov	r1, r6
   1be48:	4628      	mov	r0, r5
   1be4a:	f010 fe49 	bl	2cae0 <z_impl_k_queue_get>
	if (!buf) {
   1be4e:	4604      	mov	r4, r0
   1be50:	2800      	cmp	r0, #0
   1be52:	d1ab      	bne.n	1bdac <net_buf_alloc_len+0x5c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
   1be54:	4620      	mov	r0, r4
   1be56:	b003      	add	sp, #12
   1be58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		NET_BUF_ASSERT(req_size <= size);
   1be5c:	9b01      	ldr	r3, [sp, #4]
   1be5e:	429d      	cmp	r5, r3
   1be60:	d90e      	bls.n	1be80 <net_buf_alloc_len+0x130>
   1be62:	4912      	ldr	r1, [pc, #72]	; (1beac <net_buf_alloc_len+0x15c>)
   1be64:	f240 1351 	movw	r3, #337	; 0x151
   1be68:	4a0d      	ldr	r2, [pc, #52]	; (1bea0 <net_buf_alloc_len+0x150>)
   1be6a:	480c      	ldr	r0, [pc, #48]	; (1be9c <net_buf_alloc_len+0x14c>)
   1be6c:	f017 fbac 	bl	335c8 <printk>
   1be70:	480f      	ldr	r0, [pc, #60]	; (1beb0 <net_buf_alloc_len+0x160>)
   1be72:	f017 fba9 	bl	335c8 <printk>
   1be76:	f240 1151 	movw	r1, #337	; 0x151
   1be7a:	4809      	ldr	r0, [pc, #36]	; (1bea0 <net_buf_alloc_len+0x150>)
   1be7c:	f017 fea5 	bl	33bca <assert_post_action>
	buf->frags = NULL;
   1be80:	2300      	movs	r3, #0
   1be82:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
   1be84:	2301      	movs	r3, #1
   1be86:	80a3      	strh	r3, [r4, #4]
	buf->size  = size;
   1be88:	9b01      	ldr	r3, [sp, #4]
	net_buf_reset(buf);
   1be8a:	4620      	mov	r0, r4
	buf->size  = size;
   1be8c:	81e3      	strh	r3, [r4, #14]
	net_buf_reset(buf);
   1be8e:	f7ff ff37 	bl	1bd00 <net_buf_reset>
	return buf;
   1be92:	e7df      	b.n	1be54 <net_buf_alloc_len+0x104>
		buf->__buf = NULL;
   1be94:	6125      	str	r5, [r4, #16]
   1be96:	e7f3      	b.n	1be80 <net_buf_alloc_len+0x130>
   1be98:	0003d8e4 	.word	0x0003d8e4
   1be9c:	0003b77f 	.word	0x0003b77f
   1bea0:	0003d906 	.word	0x0003d906
   1bea4:	200207f8 	.word	0x200207f8
   1bea8:	ba2e8ba3 	.word	0xba2e8ba3
   1beac:	0003d8e9 	.word	0x0003d8e9
   1beb0:	0003cb8b 	.word	0x0003cb8b

0001beb4 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
   1beb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(buf);
   1beb8:	4604      	mov	r4, r0
   1beba:	b328      	cbz	r0, 1bf08 <net_buf_unref+0x54>
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
   1bebc:	2600      	movs	r6, #0
	pool->alloc->cb->unref(buf, data);
   1bebe:	272c      	movs	r7, #44	; 0x2c
   1bec0:	4d1b      	ldr	r5, [pc, #108]	; (1bf30 <net_buf_unref+0x7c>)
		if (--buf->ref > 0) {
   1bec2:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
   1bec4:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
   1bec8:	3b01      	subs	r3, #1
   1beca:	b2db      	uxtb	r3, r3
   1becc:	7123      	strb	r3, [r4, #4]
   1bece:	b9cb      	cbnz	r3, 1bf04 <net_buf_unref+0x50>
		if (buf->__buf) {
   1bed0:	6921      	ldr	r1, [r4, #16]
   1bed2:	b159      	cbz	r1, 1beec <net_buf_unref+0x38>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
   1bed4:	7963      	ldrb	r3, [r4, #5]
   1bed6:	079b      	lsls	r3, r3, #30
   1bed8:	d407      	bmi.n	1beea <net_buf_unref+0x36>
	pool->alloc->cb->unref(buf, data);
   1beda:	79a3      	ldrb	r3, [r4, #6]
   1bedc:	4620      	mov	r0, r4
   1bede:	fb07 5303 	mla	r3, r7, r3, r5
   1bee2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1bee4:	681b      	ldr	r3, [r3, #0]
   1bee6:	689b      	ldr	r3, [r3, #8]
   1bee8:	4798      	blx	r3
			buf->__buf = NULL;
   1beea:	6126      	str	r6, [r4, #16]
		}

		buf->data = NULL;
		buf->frags = NULL;

		pool = net_buf_pool_get(buf->pool_id);
   1beec:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
   1beee:	60a6      	str	r6, [r4, #8]
#if defined(CONFIG_NET_BUF_POOL_USAGE)
		pool->avail_count++;
		__ASSERT_NO_MSG(pool->avail_count <= pool->buf_count);
#endif

		if (pool->destroy) {
   1bef0:	fb07 5300 	mla	r3, r7, r0, r5
   1bef4:	6a1b      	ldr	r3, [r3, #32]
		buf->frags = NULL;
   1bef6:	6026      	str	r6, [r4, #0]
		if (pool->destroy) {
   1bef8:	b1a3      	cbz	r3, 1bf24 <net_buf_unref+0x70>
			pool->destroy(buf);
   1befa:	4620      	mov	r0, r4
   1befc:	4798      	blx	r3
	while (buf) {
   1befe:	4644      	mov	r4, r8
   1bf00:	2c00      	cmp	r4, #0
   1bf02:	d1de      	bne.n	1bec2 <net_buf_unref+0xe>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
   1bf04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	__ASSERT_NO_MSG(buf);
   1bf08:	490a      	ldr	r1, [pc, #40]	; (1bf34 <net_buf_unref+0x80>)
   1bf0a:	480b      	ldr	r0, [pc, #44]	; (1bf38 <net_buf_unref+0x84>)
   1bf0c:	f44f 7303 	mov.w	r3, #524	; 0x20c
   1bf10:	4a0a      	ldr	r2, [pc, #40]	; (1bf3c <net_buf_unref+0x88>)
   1bf12:	f017 fb59 	bl	335c8 <printk>
}
   1bf16:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	__ASSERT_NO_MSG(buf);
   1bf1a:	f44f 7103 	mov.w	r1, #524	; 0x20c
   1bf1e:	4807      	ldr	r0, [pc, #28]	; (1bf3c <net_buf_unref+0x88>)
   1bf20:	f017 be53 	b.w	33bca <assert_post_action>
   1bf24:	4621      	mov	r1, r4
   1bf26:	fb00 5007 	mla	r0, r0, r7, r5
   1bf2a:	f01c fec0 	bl	38cae <k_queue_prepend>
   1bf2e:	e7e6      	b.n	1befe <net_buf_unref+0x4a>
   1bf30:	200207f8 	.word	0x200207f8
   1bf34:	0003d98c 	.word	0x0003d98c
   1bf38:	0003b77f 	.word	0x0003b77f
   1bf3c:	0003d906 	.word	0x0003d906

0001bf40 <net_buf_frag_last>:

	return clone;
}

struct net_buf *net_buf_frag_last(struct net_buf *buf)
{
   1bf40:	b510      	push	{r4, lr}
	__ASSERT_NO_MSG(buf);
   1bf42:	4604      	mov	r4, r0
   1bf44:	b958      	cbnz	r0, 1bf5e <net_buf_frag_last+0x1e>
   1bf46:	4909      	ldr	r1, [pc, #36]	; (1bf6c <net_buf_frag_last+0x2c>)
   1bf48:	4809      	ldr	r0, [pc, #36]	; (1bf70 <net_buf_frag_last+0x30>)
   1bf4a:	f44f 731e 	mov.w	r3, #632	; 0x278
   1bf4e:	4a09      	ldr	r2, [pc, #36]	; (1bf74 <net_buf_frag_last+0x34>)
   1bf50:	f017 fb3a 	bl	335c8 <printk>
   1bf54:	f44f 711e 	mov.w	r1, #632	; 0x278
   1bf58:	4806      	ldr	r0, [pc, #24]	; (1bf74 <net_buf_frag_last+0x34>)
   1bf5a:	f017 fe36 	bl	33bca <assert_post_action>

	while (buf->frags) {
   1bf5e:	6823      	ldr	r3, [r4, #0]
   1bf60:	b90b      	cbnz	r3, 1bf66 <net_buf_frag_last+0x26>
		buf = buf->frags;
	}

	return buf;
}
   1bf62:	4620      	mov	r0, r4
   1bf64:	bd10      	pop	{r4, pc}
   1bf66:	461c      	mov	r4, r3
   1bf68:	e7f9      	b.n	1bf5e <net_buf_frag_last+0x1e>
   1bf6a:	bf00      	nop
   1bf6c:	0003d98c 	.word	0x0003d98c
   1bf70:	0003b77f 	.word	0x0003b77f
   1bf74:	0003d906 	.word	0x0003d906

0001bf78 <net_buf_frag_insert>:

void net_buf_frag_insert(struct net_buf *parent, struct net_buf *frag)
{
   1bf78:	b538      	push	{r3, r4, r5, lr}
   1bf7a:	460d      	mov	r5, r1
	__ASSERT_NO_MSG(parent);
   1bf7c:	4604      	mov	r4, r0
   1bf7e:	b958      	cbnz	r0, 1bf98 <net_buf_frag_insert+0x20>
   1bf80:	4910      	ldr	r1, [pc, #64]	; (1bfc4 <net_buf_frag_insert+0x4c>)
   1bf82:	4811      	ldr	r0, [pc, #68]	; (1bfc8 <net_buf_frag_insert+0x50>)
   1bf84:	f240 2383 	movw	r3, #643	; 0x283
   1bf88:	4a10      	ldr	r2, [pc, #64]	; (1bfcc <net_buf_frag_insert+0x54>)
   1bf8a:	f017 fb1d 	bl	335c8 <printk>
   1bf8e:	f240 2183 	movw	r1, #643	; 0x283
   1bf92:	480e      	ldr	r0, [pc, #56]	; (1bfcc <net_buf_frag_insert+0x54>)
   1bf94:	f017 fe19 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(frag);
   1bf98:	b95d      	cbnz	r5, 1bfb2 <net_buf_frag_insert+0x3a>
   1bf9a:	490d      	ldr	r1, [pc, #52]	; (1bfd0 <net_buf_frag_insert+0x58>)
   1bf9c:	480a      	ldr	r0, [pc, #40]	; (1bfc8 <net_buf_frag_insert+0x50>)
   1bf9e:	f44f 7321 	mov.w	r3, #644	; 0x284
   1bfa2:	4a0a      	ldr	r2, [pc, #40]	; (1bfcc <net_buf_frag_insert+0x54>)
   1bfa4:	f017 fb10 	bl	335c8 <printk>
   1bfa8:	f44f 7121 	mov.w	r1, #644	; 0x284
   1bfac:	4807      	ldr	r0, [pc, #28]	; (1bfcc <net_buf_frag_insert+0x54>)
   1bfae:	f017 fe0c 	bl	33bca <assert_post_action>

	if (parent->frags) {
   1bfb2:	6823      	ldr	r3, [r4, #0]
   1bfb4:	b123      	cbz	r3, 1bfc0 <net_buf_frag_insert+0x48>
		net_buf_frag_last(frag)->frags = parent->frags;
   1bfb6:	4628      	mov	r0, r5
   1bfb8:	f7ff ffc2 	bl	1bf40 <net_buf_frag_last>
   1bfbc:	6823      	ldr	r3, [r4, #0]
   1bfbe:	6003      	str	r3, [r0, #0]
	}
	/* Take ownership of the fragment reference */
	parent->frags = frag;
   1bfc0:	6025      	str	r5, [r4, #0]
}
   1bfc2:	bd38      	pop	{r3, r4, r5, pc}
   1bfc4:	0003d8fa 	.word	0x0003d8fa
   1bfc8:	0003b77f 	.word	0x0003b77f
   1bfcc:	0003d906 	.word	0x0003d906
   1bfd0:	0003d901 	.word	0x0003d901

0001bfd4 <net_buf_simple_add>:
{
	memcpy(clone, original, sizeof(struct net_buf_simple));
}

void *net_buf_simple_add(struct net_buf_simple *buf, size_t len)
{
   1bfd4:	b570      	push	{r4, r5, r6, lr}
	return buf->data + buf->len;
   1bfd6:	6803      	ldr	r3, [r0, #0]
   1bfd8:	8886      	ldrh	r6, [r0, #4]
   1bfda:	4604      	mov	r4, r0
   1bfdc:	460d      	mov	r5, r1
   1bfde:	441e      	add	r6, r3
	u8_t *tail = net_buf_simple_tail(buf);

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);
   1bfe0:	f019 fa8d 	bl	354fe <net_buf_simple_tailroom>
   1bfe4:	4288      	cmp	r0, r1
   1bfe6:	d20b      	bcs.n	1c000 <net_buf_simple_add+0x2c>
   1bfe8:	4908      	ldr	r1, [pc, #32]	; (1c00c <net_buf_simple_add+0x38>)
   1bfea:	4809      	ldr	r0, [pc, #36]	; (1c010 <net_buf_simple_add+0x3c>)
   1bfec:	f240 3319 	movw	r3, #793	; 0x319
   1bff0:	4a08      	ldr	r2, [pc, #32]	; (1c014 <net_buf_simple_add+0x40>)
   1bff2:	f017 fae9 	bl	335c8 <printk>
   1bff6:	f240 3119 	movw	r1, #793	; 0x319
   1bffa:	4806      	ldr	r0, [pc, #24]	; (1c014 <net_buf_simple_add+0x40>)
   1bffc:	f017 fde5 	bl	33bca <assert_post_action>

	buf->len += len;
   1c000:	88a3      	ldrh	r3, [r4, #4]
	return tail;
}
   1c002:	4630      	mov	r0, r6
	buf->len += len;
   1c004:	441d      	add	r5, r3
   1c006:	80a5      	strh	r5, [r4, #4]
}
   1c008:	bd70      	pop	{r4, r5, r6, pc}
   1c00a:	bf00      	nop
   1c00c:	0003d955 	.word	0x0003d955
   1c010:	0003b77f 	.word	0x0003b77f
   1c014:	0003d906 	.word	0x0003d906

0001c018 <net_ipv4_is_ll_addr>:
 *
 * @return True if it is, false otherwise.
 */
static inline bool net_ipv4_is_ll_addr(const struct in_addr *addr)
{
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xA9FE0000) == 0xA9FE0000;
   1c018:	6803      	ldr	r3, [r0, #0]
   1c01a:	4a04      	ldr	r2, [pc, #16]	; (1c02c <net_ipv4_is_ll_addr+0x14>)
   1c01c:	ba1b      	rev	r3, r3
   1c01e:	ea32 0303 	bics.w	r3, r2, r3
}
   1c022:	bf0c      	ite	eq
   1c024:	2001      	moveq	r0, #1
   1c026:	2000      	movne	r0, #0
   1c028:	4770      	bx	lr
   1c02a:	bf00      	nop
   1c02c:	a9fe0000 	.word	0xa9fe0000

0001c030 <net_if_flag_is_set>:
 *
 * @return True if the value is set, false otherwise
 */
static inline bool net_if_flag_is_set(struct net_if *iface,
				      enum net_if_flag value)
{
   1c030:	b538      	push	{r3, r4, r5, lr}
   1c032:	460d      	mov	r5, r1
	NET_ASSERT(iface);
   1c034:	4604      	mov	r4, r0
   1c036:	b970      	cbnz	r0, 1c056 <net_if_flag_is_set+0x26>
   1c038:	490b      	ldr	r1, [pc, #44]	; (1c068 <net_if_flag_is_set+0x38>)
   1c03a:	f44f 7307 	mov.w	r3, #540	; 0x21c
   1c03e:	4a0b      	ldr	r2, [pc, #44]	; (1c06c <net_if_flag_is_set+0x3c>)
   1c040:	480b      	ldr	r0, [pc, #44]	; (1c070 <net_if_flag_is_set+0x40>)
   1c042:	f017 fac1 	bl	335c8 <printk>
   1c046:	480b      	ldr	r0, [pc, #44]	; (1c074 <net_if_flag_is_set+0x44>)
   1c048:	f017 fabe 	bl	335c8 <printk>
   1c04c:	f44f 7107 	mov.w	r1, #540	; 0x21c
   1c050:	4806      	ldr	r0, [pc, #24]	; (1c06c <net_if_flag_is_set+0x3c>)
   1c052:	f017 fdba 	bl	33bca <assert_post_action>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1c056:	6823      	ldr	r3, [r4, #0]
   1c058:	330c      	adds	r3, #12
   1c05a:	e8d3 0faf 	lda	r0, [r3]
 */
static inline bool atomic_test_bit(const atomic_t *target, int bit)
{
	atomic_val_t val = atomic_get(ATOMIC_ELEM(target, bit));

	return (1 & (val >> (bit & (ATOMIC_BITS - 1)))) != 0;
   1c05e:	4128      	asrs	r0, r5

	return atomic_test_bit(iface->if_dev->flags, value);
}
   1c060:	f000 0001 	and.w	r0, r0, #1
   1c064:	bd38      	pop	{r3, r4, r5, pc}
   1c066:	bf00      	nop
   1c068:	0003d9b8 	.word	0x0003d9b8
   1c06c:	0003d990 	.word	0x0003d990
   1c070:	0003b77f 	.word	0x0003b77f
   1c074:	0003cb8b 	.word	0x0003cb8b

0001c078 <iface_router_run_timer>:
	}
}


static void iface_router_run_timer(u32_t current_time)
{
   1c078:	b538      	push	{r3, r4, r5, lr}
   1c07a:	4604      	mov	r4, r0
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
   1c07c:	4817      	ldr	r0, [pc, #92]	; (1c0dc <iface_router_run_timer+0x64>)
   1c07e:	f012 fca9 	bl	2e9d4 <z_timeout_remaining>
   1c082:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1c086:	fba0 0103 	umull	r0, r1, r0, r3
   1c08a:	0bc3      	lsrs	r3, r0, #15
	struct net_if_router *router, *next;
	u32_t new_timer = UINT_MAX;

	if (k_delayed_work_remaining_get(&router_timer)) {
   1c08c:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   1c090:	d002      	beq.n	1c098 <iface_router_run_timer+0x20>
		k_delayed_work_cancel(&router_timer);
   1c092:	4813      	ldr	r0, [pc, #76]	; (1c0e0 <iface_router_run_timer+0x68>)
   1c094:	f012 fb00 	bl	2e698 <k_delayed_work_cancel>
	}

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
   1c098:	4b12      	ldr	r3, [pc, #72]	; (1c0e4 <iface_router_run_timer+0x6c>)
   1c09a:	681b      	ldr	r3, [r3, #0]
   1c09c:	b1e3      	cbz	r3, 1c0d8 <iface_router_run_timer+0x60>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c09e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
					 router, next, node) {
		u32_t current_timer = router->life_start +
			(MSEC_PER_SEC * router->lifetime) - current_time;
   1c0a2:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   1c0a6:	6819      	ldr	r1, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
   1c0a8:	b93b      	cbnz	r3, 1c0ba <iface_router_run_timer+0x42>

		new_timer = MIN(current_timer, new_timer);
	}

	if (new_timer != UINT_MAX) {
   1c0aa:	1c53      	adds	r3, r2, #1
   1c0ac:	d014      	beq.n	1c0d8 <iface_router_run_timer+0x60>
		k_delayed_work_submit(&router_timer, K_MSEC(new_timer));
	}
}
   1c0ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1c0b2:	490b      	ldr	r1, [pc, #44]	; (1c0e0 <iface_router_run_timer+0x68>)
   1c0b4:	480c      	ldr	r0, [pc, #48]	; (1c0e8 <iface_router_run_timer+0x70>)
   1c0b6:	f012 ba5d 	b.w	2e574 <k_delayed_work_submit_to_queue>
			(MSEC_PER_SEC * router->lifetime) - current_time;
   1c0ba:	8c18      	ldrh	r0, [r3, #32]
		u32_t current_timer = router->life_start +
   1c0bc:	69db      	ldr	r3, [r3, #28]
   1c0be:	1b1b      	subs	r3, r3, r4
   1c0c0:	fb05 3300 	mla	r3, r5, r0, r3
		new_timer = MIN(current_timer, new_timer);
   1c0c4:	429a      	cmp	r2, r3
   1c0c6:	bf28      	it	cs
   1c0c8:	461a      	movcs	r2, r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
   1c0ca:	b119      	cbz	r1, 1c0d4 <iface_router_run_timer+0x5c>
   1c0cc:	6808      	ldr	r0, [r1, #0]
   1c0ce:	460b      	mov	r3, r1
   1c0d0:	4601      	mov	r1, r0
   1c0d2:	e7e9      	b.n	1c0a8 <iface_router_run_timer+0x30>
   1c0d4:	4608      	mov	r0, r1
   1c0d6:	e7fa      	b.n	1c0ce <iface_router_run_timer+0x56>
}
   1c0d8:	bd38      	pop	{r3, r4, r5, pc}
   1c0da:	bf00      	nop
   1c0dc:	200217e4 	.word	0x200217e4
   1c0e0:	200217d8 	.word	0x200217d8
   1c0e4:	20021788 	.word	0x20021788
   1c0e8:	20027524 	.word	0x20027524

0001c0ec <net_if_flag_set.constprop.32>:
static inline void net_if_flag_set(struct net_if *iface,
   1c0ec:	b510      	push	{r4, lr}
	NET_ASSERT(iface);
   1c0ee:	4604      	mov	r4, r0
   1c0f0:	b970      	cbnz	r0, 1c110 <net_if_flag_set.constprop.32+0x24>
   1c0f2:	490d      	ldr	r1, [pc, #52]	; (1c128 <net_if_flag_set.constprop.32+0x3c>)
   1c0f4:	f44f 73f7 	mov.w	r3, #494	; 0x1ee
   1c0f8:	4a0c      	ldr	r2, [pc, #48]	; (1c12c <net_if_flag_set.constprop.32+0x40>)
   1c0fa:	480d      	ldr	r0, [pc, #52]	; (1c130 <net_if_flag_set.constprop.32+0x44>)
   1c0fc:	f017 fa64 	bl	335c8 <printk>
   1c100:	480c      	ldr	r0, [pc, #48]	; (1c134 <net_if_flag_set.constprop.32+0x48>)
   1c102:	f017 fa61 	bl	335c8 <printk>
   1c106:	f44f 71f7 	mov.w	r1, #494	; 0x1ee
   1c10a:	4808      	ldr	r0, [pc, #32]	; (1c12c <net_if_flag_set.constprop.32+0x40>)
   1c10c:	f017 fd5d 	bl	33bca <assert_post_action>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   1c110:	6823      	ldr	r3, [r4, #0]
   1c112:	330c      	adds	r3, #12
   1c114:	e8d3 2fef 	ldaex	r2, [r3]
   1c118:	f042 0201 	orr.w	r2, r2, #1
   1c11c:	e8c3 2fe1 	stlex	r1, r2, [r3]
   1c120:	2900      	cmp	r1, #0
   1c122:	d1f7      	bne.n	1c114 <net_if_flag_set.constprop.32+0x28>
}
   1c124:	bd10      	pop	{r4, pc}
   1c126:	bf00      	nop
   1c128:	0003d9b8 	.word	0x0003d9b8
   1c12c:	0003d990 	.word	0x0003d990
   1c130:	0003b77f 	.word	0x0003b77f
   1c134:	0003cb8b 	.word	0x0003cb8b

0001c138 <net_if_ipv4_get_best_match.isra.17>:
	}

	return false;
}

static struct in_addr *net_if_ipv4_get_best_match(struct net_if *iface,
   1c138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c13a:	4615      	mov	r5, r2
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
	struct in_addr *src = NULL;
	u8_t len;
	int i;

	if (!ipv4) {
   1c13c:	4604      	mov	r4, r0
   1c13e:	b310      	cbz	r0, 1c186 <net_if_ipv4_get_best_match.isra.17+0x4e>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
   1c140:	6942      	ldr	r2, [r0, #20]
   1c142:	4b17      	ldr	r3, [pc, #92]	; (1c1a0 <net_if_ipv4_get_best_match.isra.17+0x68>)
   1c144:	4013      	ands	r3, r2
   1c146:	4a17      	ldr	r2, [pc, #92]	; (1c1a4 <net_if_ipv4_get_best_match.isra.17+0x6c>)
   1c148:	4293      	cmp	r3, r2
   1c14a:	d001      	beq.n	1c150 <net_if_ipv4_get_best_match.isra.17+0x18>
		return NULL;
   1c14c:	2400      	movs	r4, #0
   1c14e:	e01a      	b.n	1c186 <net_if_ipv4_get_best_match.isra.17+0x4e>
	if (addr->is_used && addr->addr_state == NET_ADDR_PREFERRED &&
   1c150:	8823      	ldrh	r3, [r4, #0]
   1c152:	2b01      	cmp	r3, #1
   1c154:	d1fa      	bne.n	1c14c <net_if_ipv4_get_best_match.isra.17+0x14>
	    !net_ipv4_is_ll_addr(&addr->address.in_addr)) {
   1c156:	1d26      	adds	r6, r4, #4
   1c158:	4630      	mov	r0, r6
   1c15a:	f7ff ff5d 	bl	1c018 <net_ipv4_is_ll_addr>
	    addr->address.family == AF_INET &&
   1c15e:	2800      	cmp	r0, #0
   1c160:	d1f4      	bne.n	1c14c <net_if_ipv4_get_best_match.isra.17+0x14>
   1c162:	3901      	subs	r1, #1
   1c164:	3403      	adds	r4, #3
		if (src[j] == dst[j]) {
   1c166:	f811 3f01 	ldrb.w	r3, [r1, #1]!
   1c16a:	f814 7f01 	ldrb.w	r7, [r4, #1]!
   1c16e:	f100 0208 	add.w	r2, r0, #8
   1c172:	42bb      	cmp	r3, r7
   1c174:	d109      	bne.n	1c18a <net_if_ipv4_get_best_match.isra.17+0x52>
			len += 8U;
   1c176:	b2d0      	uxtb	r0, r2
	for (j = 0U; j < addr_len; j++) {
   1c178:	2820      	cmp	r0, #32
   1c17a:	d1f4      	bne.n	1c166 <net_if_ipv4_get_best_match.isra.17+0x2e>
		if (!is_proper_ipv4_address(&ipv4->unicast[i])) {
			continue;
		}

		len = get_diff_ipv4(dst, &ipv4->unicast[i].address.in_addr);
		if (len >= *best_so_far) {
   1c17c:	782b      	ldrb	r3, [r5, #0]
   1c17e:	4283      	cmp	r3, r0
   1c180:	d8e4      	bhi.n	1c14c <net_if_ipv4_get_best_match.isra.17+0x14>
		len = get_diff_ipv4(dst, &ipv4->unicast[i].address.in_addr);
   1c182:	4634      	mov	r4, r6
			*best_so_far = len;
   1c184:	7028      	strb	r0, [r5, #0]
			src = &ipv4->unicast[i].address.in_addr;
		}
	}

	return src;
}
   1c186:	4620      	mov	r0, r4
   1c188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xor = src[j] ^ dst[j];
   1c18a:	407b      	eors	r3, r7
			for (k = 0U; k < 8; k++) {
   1c18c:	b2d2      	uxtb	r2, r2
				if (!(xor & 0x80)) {
   1c18e:	0619      	lsls	r1, r3, #24
   1c190:	d4f4      	bmi.n	1c17c <net_if_ipv4_get_best_match.isra.17+0x44>
					len++;
   1c192:	3001      	adds	r0, #1
   1c194:	b2c0      	uxtb	r0, r0
					xor <<= 1;
   1c196:	005b      	lsls	r3, r3, #1
			for (k = 0U; k < 8; k++) {
   1c198:	4282      	cmp	r2, r0
					xor <<= 1;
   1c19a:	b2db      	uxtb	r3, r3
			for (k = 0U; k < 8; k++) {
   1c19c:	d1f7      	bne.n	1c18e <net_if_ipv4_get_best_match.isra.17+0x56>
   1c19e:	e7ed      	b.n	1c17c <net_if_ipv4_get_best_match.isra.17+0x44>
   1c1a0:	0002ff00 	.word	0x0002ff00
   1c1a4:	00020100 	.word	0x00020100

0001c1a8 <iface_router_expired>:
{
   1c1a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t current_time = k_uptime_get_32();
   1c1aa:	f019 fa9c 	bl	356e6 <k_uptime_get_32>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
   1c1ae:	4a18      	ldr	r2, [pc, #96]	; (1c210 <iface_router_expired+0x68>)
   1c1b0:	6813      	ldr	r3, [r2, #0]
   1c1b2:	b91b      	cbnz	r3, 1c1bc <iface_router_expired+0x14>
}
   1c1b4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	iface_router_run_timer(current_time);
   1c1b8:	f7ff bf5e 	b.w	1c078 <iface_router_run_timer>
   1c1bc:	2100      	movs	r1, #0
			    (MSEC_PER_SEC * router->lifetime) -
   1c1be:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
	parent->next = child;
   1c1c2:	468c      	mov	ip, r1
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c1c4:	681c      	ldr	r4, [r3, #0]
   1c1c6:	69de      	ldr	r6, [r3, #28]
   1c1c8:	8c1d      	ldrh	r5, [r3, #32]
   1c1ca:	1a36      	subs	r6, r6, r0
   1c1cc:	fb0e 6505 	mla	r5, lr, r5, r6
		if ((s32_t)(router->life_start +
   1c1d0:	2d00      	cmp	r5, #0
   1c1d2:	461f      	mov	r7, r3
   1c1d4:	dc0f      	bgt.n	1c1f6 <iface_router_expired+0x4e>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
   1c1d6:	681d      	ldr	r5, [r3, #0]
   1c1d8:	b999      	cbnz	r1, 1c202 <iface_router_expired+0x5a>
   1c1da:	6856      	ldr	r6, [r2, #4]
	list->head = node;
   1c1dc:	6015      	str	r5, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c1de:	429e      	cmp	r6, r3
   1c1e0:	d100      	bne.n	1c1e4 <iface_router_expired+0x3c>
	list->tail = node;
   1c1e2:	6055      	str	r5, [r2, #4]
		router->is_used = false;
   1c1e4:	460f      	mov	r7, r1
   1c1e6:	f893 5022 	ldrb.w	r5, [r3, #34]	; 0x22
	parent->next = child;
   1c1ea:	f8c3 c000 	str.w	ip, [r3]
   1c1ee:	f36c 0500 	bfi	r5, ip, #0, #1
   1c1f2:	f883 5022 	strb.w	r5, [r3, #34]	; 0x22
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&active_router_timers,
   1c1f6:	2c00      	cmp	r4, #0
   1c1f8:	d0dc      	beq.n	1c1b4 <iface_router_expired+0xc>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c1fa:	4623      	mov	r3, r4
   1c1fc:	4639      	mov	r1, r7
   1c1fe:	6824      	ldr	r4, [r4, #0]
   1c200:	e7e1      	b.n	1c1c6 <iface_router_expired+0x1e>
	parent->next = child;
   1c202:	600d      	str	r5, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   1c204:	6855      	ldr	r5, [r2, #4]
   1c206:	429d      	cmp	r5, r3
	list->tail = node;
   1c208:	bf08      	it	eq
   1c20a:	6051      	streq	r1, [r2, #4]
   1c20c:	e7ea      	b.n	1c1e4 <iface_router_expired+0x3c>
   1c20e:	bf00      	nop
   1c210:	20021788 	.word	0x20021788

0001c214 <net_if_queue_tx>:
{
   1c214:	b510      	push	{r4, lr}
	u8_t tc = net_tx_priority2tc(prio);
   1c216:	2000      	movs	r0, #0
{
   1c218:	460c      	mov	r4, r1
	u8_t tc = net_tx_priority2tc(prio);
   1c21a:	f001 f8e1 	bl	1d3e0 <net_tx_priority2tc>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   1c21e:	2300      	movs	r3, #0
   1c220:	4a04      	ldr	r2, [pc, #16]	; (1c234 <net_if_queue_tx+0x20>)
   1c222:	6023      	str	r3, [r4, #0]
   1c224:	e9c4 2301 	strd	r2, r3, [r4, #4]
	if (!net_tc_submit_to_tx_queue(tc, pkt)) {
   1c228:	4621      	mov	r1, r4
}
   1c22a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (!net_tc_submit_to_tx_queue(tc, pkt)) {
   1c22e:	b2c0      	uxtb	r0, r0
   1c230:	f001 b8c2 	b.w	1d3b8 <net_tc_submit_to_tx_queue>
   1c234:	0001c3f9 	.word	0x0001c3f9

0001c238 <net_if_get_default>:
}
   1c238:	4b02      	ldr	r3, [pc, #8]	; (1c244 <net_if_get_default+0xc>)
	if (__net_if_start == __net_if_end) {
   1c23a:	4803      	ldr	r0, [pc, #12]	; (1c248 <net_if_get_default+0x10>)
}
   1c23c:	4298      	cmp	r0, r3
   1c23e:	bf08      	it	eq
   1c240:	2000      	moveq	r0, #0
   1c242:	4770      	bx	lr
   1c244:	200208e0 	.word	0x200208e0
   1c248:	200208c0 	.word	0x200208c0

0001c24c <net_if_ipv4_is_addr_bcast>:
{
   1c24c:	b570      	push	{r4, r5, r6, lr}
   1c24e:	460e      	mov	r6, r1
	if (iface) {
   1c250:	b168      	cbz	r0, 1c26e <net_if_ipv4_is_addr_bcast+0x22>
}
   1c252:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return ipv4_is_broadcast_address(iface, addr);
   1c256:	f019 ba67 	b.w	35728 <ipv4_is_broadcast_address>
		ret = ipv4_is_broadcast_address(iface, addr);
   1c25a:	4631      	mov	r1, r6
   1c25c:	4620      	mov	r0, r4
   1c25e:	f019 fa63 	bl	35728 <ipv4_is_broadcast_address>
		if (ret) {
   1c262:	b918      	cbnz	r0, 1c26c <net_if_ipv4_is_addr_bcast+0x20>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c264:	3420      	adds	r4, #32
   1c266:	42ac      	cmp	r4, r5
   1c268:	d1f7      	bne.n	1c25a <net_if_ipv4_is_addr_bcast+0xe>
	return false;
   1c26a:	2000      	movs	r0, #0
}
   1c26c:	bd70      	pop	{r4, r5, r6, pc}
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c26e:	4c01      	ldr	r4, [pc, #4]	; (1c274 <net_if_ipv4_is_addr_bcast+0x28>)
   1c270:	4d01      	ldr	r5, [pc, #4]	; (1c278 <net_if_ipv4_is_addr_bcast+0x2c>)
   1c272:	e7f8      	b.n	1c266 <net_if_ipv4_is_addr_bcast+0x1a>
   1c274:	200208c0 	.word	0x200208c0
   1c278:	200208e0 	.word	0x200208e0

0001c27c <net_if_ipv4_select_src_iface>:
{
   1c27c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c27e:	4c0a      	ldr	r4, [pc, #40]	; (1c2a8 <net_if_ipv4_select_src_iface+0x2c>)
{
   1c280:	4607      	mov	r7, r0
   1c282:	4625      	mov	r5, r4
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c284:	4e09      	ldr	r6, [pc, #36]	; (1c2ac <net_if_ipv4_select_src_iface+0x30>)
   1c286:	42b4      	cmp	r4, r6
   1c288:	d106      	bne.n	1c298 <net_if_ipv4_select_src_iface+0x1c>
		return NULL;
   1c28a:	4b07      	ldr	r3, [pc, #28]	; (1c2a8 <net_if_ipv4_select_src_iface+0x2c>)
   1c28c:	42a5      	cmp	r5, r4
   1c28e:	bf14      	ite	ne
   1c290:	461c      	movne	r4, r3
   1c292:	2400      	moveq	r4, #0
}
   1c294:	4620      	mov	r0, r4
   1c296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		ret = net_if_ipv4_addr_mask_cmp(iface, dst);
   1c298:	4639      	mov	r1, r7
   1c29a:	4620      	mov	r0, r4
   1c29c:	f019 fa30 	bl	35700 <net_if_ipv4_addr_mask_cmp>
		if (ret) {
   1c2a0:	2800      	cmp	r0, #0
   1c2a2:	d1f7      	bne.n	1c294 <net_if_ipv4_select_src_iface+0x18>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c2a4:	3420      	adds	r4, #32
   1c2a6:	e7ee      	b.n	1c286 <net_if_ipv4_select_src_iface+0xa>
   1c2a8:	200208c0 	.word	0x200208c0
   1c2ac:	200208e0 	.word	0x200208e0

0001c2b0 <net_if_ipv4_select_src_addr>:

const struct in_addr *net_if_ipv4_select_src_addr(struct net_if *dst_iface,
						  const struct in_addr *dst)
{
	struct in_addr *src = NULL;
	u8_t best_match = 0U;
   1c2b0:	2300      	movs	r3, #0
{
   1c2b2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   1c2b6:	4605      	mov	r5, r0
	struct net_if *iface;

	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
   1c2b8:	4608      	mov	r0, r1
{
   1c2ba:	460e      	mov	r6, r1
	u8_t best_match = 0U;
   1c2bc:	f88d 3007 	strb.w	r3, [sp, #7]
	if (!net_ipv4_is_ll_addr(dst) && !net_ipv4_is_addr_mcast(dst)) {
   1c2c0:	f7ff feaa 	bl	1c018 <net_ipv4_is_ll_addr>
   1c2c4:	bba8      	cbnz	r0, 1c332 <net_if_ipv4_select_src_addr+0x82>
   1c2c6:	4608      	mov	r0, r1
   1c2c8:	f019 f9c7 	bl	3565a <net_ipv4_is_addr_mcast>
   1c2cc:	bb88      	cbnz	r0, 1c332 <net_if_ipv4_select_src_addr+0x82>

		for (iface = __net_if_start;
   1c2ce:	4f1d      	ldr	r7, [pc, #116]	; (1c344 <net_if_ipv4_select_src_addr+0x94>)
	struct in_addr *src = NULL;
   1c2d0:	4604      	mov	r4, r0
		     !dst_iface && iface != __net_if_end;
   1c2d2:	f8df 8074 	ldr.w	r8, [pc, #116]	; 1c348 <net_if_ipv4_select_src_addr+0x98>
		for (iface = __net_if_start;
   1c2d6:	b185      	cbz	r5, 1c2fa <net_if_ipv4_select_src_addr+0x4a>
			}
		}

		/* If caller has supplied interface, then use that */
		if (dst_iface) {
			src = net_if_ipv4_get_best_match(dst_iface, dst,
   1c2d8:	f10d 0207 	add.w	r2, sp, #7
   1c2dc:	6868      	ldr	r0, [r5, #4]
   1c2de:	f7ff ff2b 	bl	1c138 <net_if_ipv4_get_best_match.isra.17>
				break;
			}
		}

		if (dst_iface) {
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
   1c2e2:	4604      	mov	r4, r0
   1c2e4:	e00b      	b.n	1c2fe <net_if_ipv4_select_src_addr+0x4e>
			addr = net_if_ipv4_get_best_match(iface, dst,
   1c2e6:	6878      	ldr	r0, [r7, #4]
   1c2e8:	f10d 0207 	add.w	r2, sp, #7
   1c2ec:	4631      	mov	r1, r6
   1c2ee:	f7ff ff23 	bl	1c138 <net_if_ipv4_get_best_match.isra.17>
			if (addr) {
   1c2f2:	2800      	cmp	r0, #0
   1c2f4:	bf18      	it	ne
   1c2f6:	4604      	movne	r4, r0
		     iface++) {
   1c2f8:	3720      	adds	r7, #32
		     !dst_iface && iface != __net_if_end;
   1c2fa:	4547      	cmp	r7, r8
   1c2fc:	d1f3      	bne.n	1c2e6 <net_if_ipv4_select_src_addr+0x36>
		}
	}

	if (!src) {
   1c2fe:	b16c      	cbz	r4, 1c31c <net_if_ipv4_select_src_addr+0x6c>

		return net_ipv4_unspecified_address();
	}

	return src;
}
   1c300:	4620      	mov	r0, r4
   1c302:	b002      	add	sp, #8
   1c304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			addr = net_if_ipv4_get_ll(iface, NET_ADDR_PREFERRED);
   1c308:	2101      	movs	r1, #1
   1c30a:	4630      	mov	r0, r6
   1c30c:	f019 fa1d 	bl	3574a <net_if_ipv4_get_ll>
			if (addr) {
   1c310:	4604      	mov	r4, r0
   1c312:	2800      	cmp	r0, #0
   1c314:	d1f4      	bne.n	1c300 <net_if_ipv4_select_src_addr+0x50>
		     iface++) {
   1c316:	3620      	adds	r6, #32
		     !dst_iface && iface != __net_if_end;
   1c318:	42be      	cmp	r6, r7
   1c31a:	d1f5      	bne.n	1c308 <net_if_ipv4_select_src_addr+0x58>
		src = net_if_ipv4_get_global_addr(dst_iface,
   1c31c:	2101      	movs	r1, #1
   1c31e:	4628      	mov	r0, r5
   1c320:	f019 fa16 	bl	35750 <net_if_ipv4_get_global_addr>
		if (src) {
   1c324:	4604      	mov	r4, r0
   1c326:	2800      	cmp	r0, #0
   1c328:	d1ea      	bne.n	1c300 <net_if_ipv4_select_src_addr+0x50>
		return net_ipv4_unspecified_address();
   1c32a:	f000 f957 	bl	1c5dc <net_ipv4_unspecified_address>
   1c32e:	4604      	mov	r4, r0
   1c330:	e7e6      	b.n	1c300 <net_if_ipv4_select_src_addr+0x50>
   1c332:	4e04      	ldr	r6, [pc, #16]	; (1c344 <net_if_ipv4_select_src_addr+0x94>)
		     !dst_iface && iface != __net_if_end;
   1c334:	4f04      	ldr	r7, [pc, #16]	; (1c348 <net_if_ipv4_select_src_addr+0x98>)
		for (iface = __net_if_start;
   1c336:	2d00      	cmp	r5, #0
   1c338:	d0ee      	beq.n	1c318 <net_if_ipv4_select_src_addr+0x68>
			src = net_if_ipv4_get_ll(dst_iface, NET_ADDR_PREFERRED);
   1c33a:	2101      	movs	r1, #1
   1c33c:	4628      	mov	r0, r5
   1c33e:	f019 fa04 	bl	3574a <net_if_ipv4_get_ll>
   1c342:	e7ce      	b.n	1c2e2 <net_if_ipv4_select_src_addr+0x32>
   1c344:	200208c0 	.word	0x200208c0
   1c348:	200208e0 	.word	0x200208e0

0001c34c <net_if_ipv4_addr_lookup>:

struct net_if_addr *net_if_ipv4_addr_lookup(const struct in_addr *addr,
					    struct net_if **ret)
{
   1c34c:	b570      	push	{r4, r5, r6, lr}
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c34e:	4a0c      	ldr	r2, [pc, #48]	; (1c380 <net_if_ipv4_addr_lookup+0x34>)
   1c350:	4c0c      	ldr	r4, [pc, #48]	; (1c384 <net_if_ipv4_addr_lookup+0x38>)
   1c352:	42a2      	cmp	r2, r4
   1c354:	d101      	bne.n	1c35a <net_if_ipv4_addr_lookup+0xe>
				return &ipv4->unicast[i];
			}
		}
	}

	return NULL;
   1c356:	2000      	movs	r0, #0
   1c358:	e00e      	b.n	1c378 <net_if_ipv4_addr_lookup+0x2c>
		struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
   1c35a:	6853      	ldr	r3, [r2, #4]
		if (!ipv4) {
   1c35c:	b16b      	cbz	r3, 1c37a <net_if_ipv4_addr_lookup+0x2e>
			if (!ipv4->unicast[i].is_used ||
   1c35e:	7d9d      	ldrb	r5, [r3, #22]
   1c360:	07ad      	lsls	r5, r5, #30
   1c362:	d50a      	bpl.n	1c37a <net_if_ipv4_addr_lookup+0x2e>
   1c364:	881d      	ldrh	r5, [r3, #0]
   1c366:	2d01      	cmp	r5, #1
   1c368:	d107      	bne.n	1c37a <net_if_ipv4_addr_lookup+0x2e>
			if (UNALIGNED_GET(&addr->s4_addr32[0]) ==
   1c36a:	6805      	ldr	r5, [r0, #0]
   1c36c:	685e      	ldr	r6, [r3, #4]
   1c36e:	42ae      	cmp	r6, r5
   1c370:	d103      	bne.n	1c37a <net_if_ipv4_addr_lookup+0x2e>
				if (ret) {
   1c372:	b101      	cbz	r1, 1c376 <net_if_ipv4_addr_lookup+0x2a>
					*ret = iface;
   1c374:	600a      	str	r2, [r1, #0]
				return &ipv4->unicast[i];
   1c376:	4618      	mov	r0, r3
}
   1c378:	bd70      	pop	{r4, r5, r6, pc}
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c37a:	3220      	adds	r2, #32
   1c37c:	e7e9      	b.n	1c352 <net_if_ipv4_addr_lookup+0x6>
   1c37e:	bf00      	nop
   1c380:	200208c0 	.word	0x200208c0
   1c384:	200208e0 	.word	0x200208e0

0001c388 <net_if_ipv4_maddr_lookup>:
	return false;
}

struct net_if_mcast_addr *net_if_ipv4_maddr_lookup(const struct in_addr *maddr,
						   struct net_if **ret)
{
   1c388:	b570      	push	{r4, r5, r6, lr}
	struct net_if_mcast_addr *addr;
	struct net_if *iface;

	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c38a:	4a0f      	ldr	r2, [pc, #60]	; (1c3c8 <net_if_ipv4_maddr_lookup+0x40>)
   1c38c:	4c0f      	ldr	r4, [pc, #60]	; (1c3cc <net_if_ipv4_maddr_lookup+0x44>)
   1c38e:	42a2      	cmp	r2, r4
   1c390:	d101      	bne.n	1c396 <net_if_ipv4_maddr_lookup+0xe>

			return addr;
		}
	}

	return NULL;
   1c392:	2000      	movs	r0, #0
   1c394:	e00e      	b.n	1c3b4 <net_if_ipv4_maddr_lookup+0x2c>
		if (ret && *ret && iface != *ret) {
   1c396:	b119      	cbz	r1, 1c3a0 <net_if_ipv4_maddr_lookup+0x18>
   1c398:	680b      	ldr	r3, [r1, #0]
   1c39a:	b10b      	cbz	r3, 1c3a0 <net_if_ipv4_maddr_lookup+0x18>
   1c39c:	4293      	cmp	r3, r2
   1c39e:	d10e      	bne.n	1c3be <net_if_ipv4_maddr_lookup+0x36>
		addr = ipv4_maddr_find(iface, true, maddr);
   1c3a0:	6853      	ldr	r3, [r2, #4]
	if (!ipv4) {
   1c3a2:	b163      	cbz	r3, 1c3be <net_if_ipv4_maddr_lookup+0x36>
		if ((is_used && !ipv4->mcast[i].is_used) ||
   1c3a4:	f893 502c 	ldrb.w	r5, [r3, #44]	; 0x2c
   1c3a8:	07ed      	lsls	r5, r5, #31
   1c3aa:	d508      	bpl.n	1c3be <net_if_ipv4_maddr_lookup+0x36>
		if (addr) {
   1c3ac:	b918      	cbnz	r0, 1c3b6 <net_if_ipv4_maddr_lookup+0x2e>
		return &ipv4->mcast[i];
   1c3ae:	f103 0018 	add.w	r0, r3, #24
			if (ret) {
   1c3b2:	b931      	cbnz	r1, 1c3c2 <net_if_ipv4_maddr_lookup+0x3a>
}
   1c3b4:	bd70      	pop	{r4, r5, r6, pc}
 *  @return True if the addresses are the same, false otherwise.
 */
static inline bool net_ipv4_addr_cmp(const struct in_addr *addr1,
				     const struct in_addr *addr2)
{
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   1c3b6:	69de      	ldr	r6, [r3, #28]
   1c3b8:	6805      	ldr	r5, [r0, #0]
			if (!net_ipv4_addr_cmp(&ipv4->mcast[i].address.in_addr,
   1c3ba:	42ae      	cmp	r6, r5
   1c3bc:	d0f7      	beq.n	1c3ae <net_if_ipv4_maddr_lookup+0x26>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c3be:	3220      	adds	r2, #32
   1c3c0:	e7e5      	b.n	1c38e <net_if_ipv4_maddr_lookup+0x6>
				*ret = iface;
   1c3c2:	600a      	str	r2, [r1, #0]
   1c3c4:	e7f6      	b.n	1c3b4 <net_if_ipv4_maddr_lookup+0x2c>
   1c3c6:	bf00      	nop
   1c3c8:	200208c0 	.word	0x200208c0
   1c3cc:	200208e0 	.word	0x200208e0

0001c3d0 <net_if_call_link_cb>:
	sys_slist_find_and_remove(&link_callbacks, &link->node);
}

void net_if_call_link_cb(struct net_if *iface, struct net_linkaddr *lladdr,
			 int status)
{
   1c3d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct net_if_link_cb *link, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
   1c3d2:	4b08      	ldr	r3, [pc, #32]	; (1c3f4 <net_if_call_link_cb+0x24>)
{
   1c3d4:	4605      	mov	r5, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
   1c3d6:	681b      	ldr	r3, [r3, #0]
{
   1c3d8:	460e      	mov	r6, r1
   1c3da:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
   1c3dc:	b14b      	cbz	r3, 1c3f2 <net_if_call_link_cb+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1c3de:	681c      	ldr	r4, [r3, #0]
		link->cb(iface, lladdr, status);
   1c3e0:	685b      	ldr	r3, [r3, #4]
   1c3e2:	463a      	mov	r2, r7
   1c3e4:	4631      	mov	r1, r6
   1c3e6:	4628      	mov	r0, r5
   1c3e8:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&link_callbacks, link, tmp, node) {
   1c3ea:	b114      	cbz	r4, 1c3f2 <net_if_call_link_cb+0x22>
   1c3ec:	4623      	mov	r3, r4
   1c3ee:	6824      	ldr	r4, [r4, #0]
   1c3f0:	e7f6      	b.n	1c3e0 <net_if_call_link_cb+0x10>
	}
}
   1c3f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c3f4:	200217d0 	.word	0x200217d0

0001c3f8 <process_tx_packet>:
	struct net_linkaddr ll_dst = {
   1c3f8:	2300      	movs	r3, #0
{
   1c3fa:	b5f0      	push	{r4, r5, r6, r7, lr}
   1c3fc:	b085      	sub	sp, #20
	struct net_linkaddr ll_dst = {
   1c3fe:	e9cd 3300 	strd	r3, r3, [sp]
Z_GENLIST_IS_EMPTY(slist)
   1c402:	4b24      	ldr	r3, [pc, #144]	; (1c494 <process_tx_packet+0x9c>)
{
   1c404:	4604      	mov	r4, r0
	if (!sys_slist_is_empty(&link_callbacks)) {
   1c406:	681b      	ldr	r3, [r3, #0]
	iface = net_pkt_iface(pkt);
   1c408:	6a05      	ldr	r5, [r0, #32]
	if (!sys_slist_is_empty(&link_callbacks)) {
   1c40a:	b1ab      	cbz	r3, 1c438 <process_tx_packet+0x40>
		if (net_linkaddr_set(&ll_dst_storage,
   1c40c:	6b01      	ldr	r1, [r0, #48]	; 0x30
   1c40e:	f890 6034 	ldrb.w	r6, [r0, #52]	; 0x34
 * This value should always be <= NET_LINK_ADDR_MAX_LENGTH.
 */
static inline int net_linkaddr_set(struct net_linkaddr_storage *lladdr_store,
				   u8_t *new_addr, u8_t new_len)
{
	if (!lladdr_store || !new_addr) {
   1c412:	b189      	cbz	r1, 1c438 <process_tx_packet+0x40>
		return -EINVAL;
	}

	if (new_len > NET_LINK_ADDR_MAX_LENGTH) {
   1c414:	2e06      	cmp	r6, #6
   1c416:	d80f      	bhi.n	1c438 <process_tx_packet+0x40>
		return -EMSGSIZE;
	}

	lladdr_store->len = new_len;
	memcpy(lladdr_store->addr, new_addr, new_len);
   1c418:	f10d 070a 	add.w	r7, sp, #10
   1c41c:	2306      	movs	r3, #6
   1c41e:	4632      	mov	r2, r6
   1c420:	4638      	mov	r0, r7
	lladdr_store->len = new_len;
   1c422:	f88d 6009 	strb.w	r6, [sp, #9]
	memcpy(lladdr_store->addr, new_addr, new_len);
   1c426:	f01c fde4 	bl	38ff2 <__memcpy_chk>
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
   1c42a:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
			ll_dst.addr = ll_dst_storage.addr;
   1c42e:	9700      	str	r7, [sp, #0]
			ll_dst.len = ll_dst_storage.len;
   1c430:	f88d 6004 	strb.w	r6, [sp, #4]
			ll_dst.type = net_pkt_lladdr_dst(pkt)->type;
   1c434:	f88d 3005 	strb.w	r3, [sp, #5]
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   1c438:	2100      	movs	r1, #0
   1c43a:	4628      	mov	r0, r5
	context = net_pkt_context(pkt);
   1c43c:	69e7      	ldr	r7, [r4, #28]
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   1c43e:	f7ff fdf7 	bl	1c030 <net_if_flag_is_set>
   1c442:	b320      	cbz	r0, 1c48e <process_tx_packet+0x96>
	return pkt->family;
   1c444:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
		status = net_if_l2(iface)->send(iface, pkt);
   1c448:	4628      	mov	r0, r5
		if (IS_ENABLED(CONFIG_NET_TCP) &&
   1c44a:	f013 0f0e 	tst.w	r3, #14
	pkt->pkt_queued = send;
   1c44e:	bf1e      	ittt	ne
   1c450:	f894 303e 	ldrbne.w	r3, [r4, #62]	; 0x3e
   1c454:	f36f 0300 	bfcne	r3, #0, #1
   1c458:	f884 303e 	strbne.w	r3, [r4, #62]	; 0x3e
		status = net_if_l2(iface)->send(iface, pkt);
   1c45c:	f019 f906 	bl	3566c <net_if_l2>
   1c460:	4621      	mov	r1, r4
   1c462:	6843      	ldr	r3, [r0, #4]
   1c464:	4628      	mov	r0, r5
   1c466:	4798      	blx	r3
	if (status < 0) {
   1c468:	1e06      	subs	r6, r0, #0
   1c46a:	da02      	bge.n	1c472 <process_tx_packet+0x7a>
		net_pkt_unref(pkt);
   1c46c:	4620      	mov	r0, r4
   1c46e:	f019 fc33 	bl	35cd8 <net_pkt_unref>
	if (context) {
   1c472:	b11f      	cbz	r7, 1c47c <process_tx_packet+0x84>
		net_context_send_cb(context, status);
   1c474:	4631      	mov	r1, r6
   1c476:	4638      	mov	r0, r7
   1c478:	f019 f8fd 	bl	35676 <net_context_send_cb>
	if (ll_dst.addr) {
   1c47c:	9b00      	ldr	r3, [sp, #0]
   1c47e:	b123      	cbz	r3, 1c48a <process_tx_packet+0x92>
		net_if_call_link_cb(iface, &ll_dst, status);
   1c480:	4632      	mov	r2, r6
   1c482:	4669      	mov	r1, sp
   1c484:	4628      	mov	r0, r5
   1c486:	f7ff ffa3 	bl	1c3d0 <net_if_call_link_cb>
}
   1c48a:	b005      	add	sp, #20
   1c48c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		status = -ENETDOWN;
   1c48e:	f06f 0672 	mvn.w	r6, #114	; 0x72
   1c492:	e7eb      	b.n	1c46c <process_tx_packet+0x74>
   1c494:	200217d0 	.word	0x200217d0

0001c498 <net_if_get_by_index>:
	return need_calc_checksum(iface, ETHERNET_HW_RX_CHKSUM_OFFLOAD);
}

struct net_if *net_if_get_by_index(int index)
{
	if (index <= 0) {
   1c498:	2800      	cmp	r0, #0
   1c49a:	dd08      	ble.n	1c4ae <net_if_get_by_index+0x16>
		return NULL;
	}

	if (&__net_if_start[index - 1] >= __net_if_end) {
   1c49c:	1e43      	subs	r3, r0, #1
   1c49e:	4805      	ldr	r0, [pc, #20]	; (1c4b4 <net_if_get_by_index+0x1c>)
   1c4a0:	eb00 1043 	add.w	r0, r0, r3, lsl #5
		return NULL;
   1c4a4:	4b04      	ldr	r3, [pc, #16]	; (1c4b8 <net_if_get_by_index+0x20>)
   1c4a6:	4298      	cmp	r0, r3
   1c4a8:	bf28      	it	cs
   1c4aa:	2000      	movcs	r0, #0
   1c4ac:	4770      	bx	lr
   1c4ae:	2000      	movs	r0, #0
		NET_DBG("Index %d is too large", index);
		return NULL;
	}

	return &__net_if_start[index - 1];
}
   1c4b0:	4770      	bx	lr
   1c4b2:	bf00      	nop
   1c4b4:	200208c0 	.word	0x200208c0
   1c4b8:	200208e0 	.word	0x200208e0

0001c4bc <net_if_get_by_iface>:

int net_if_get_by_iface(struct net_if *iface)
{
	if (!(iface >= __net_if_start && iface < __net_if_end)) {
   1c4bc:	4b06      	ldr	r3, [pc, #24]	; (1c4d8 <net_if_get_by_iface+0x1c>)
   1c4be:	4298      	cmp	r0, r3
   1c4c0:	d306      	bcc.n	1c4d0 <net_if_get_by_iface+0x14>
   1c4c2:	4a06      	ldr	r2, [pc, #24]	; (1c4dc <net_if_get_by_iface+0x20>)
   1c4c4:	4290      	cmp	r0, r2
   1c4c6:	d203      	bcs.n	1c4d0 <net_if_get_by_iface+0x14>
		return -1;
	}

	return (iface - __net_if_start) + 1;
   1c4c8:	1ac0      	subs	r0, r0, r3
   1c4ca:	1140      	asrs	r0, r0, #5
   1c4cc:	3001      	adds	r0, #1
   1c4ce:	4770      	bx	lr
		return -1;
   1c4d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   1c4d4:	4770      	bx	lr
   1c4d6:	bf00      	nop
   1c4d8:	200208c0 	.word	0x200208c0
   1c4dc:	200208e0 	.word	0x200208e0

0001c4e0 <net_if_up>:
		cb(iface, user_data);
	}
}

int net_if_up(struct net_if *iface)
{
   1c4e0:	b538      	push	{r3, r4, r5, lr}
	int status;

	NET_DBG("iface %p", iface);

	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   1c4e2:	2100      	movs	r1, #0
{
   1c4e4:	4605      	mov	r5, r0
	if (net_if_flag_is_set(iface, NET_IF_UP)) {
   1c4e6:	f7ff fda3 	bl	1c030 <net_if_flag_is_set>
   1c4ea:	b928      	cbnz	r0, 1c4f8 <net_if_up+0x18>
 * @return True if socket offloading is active, false otherwise.
 */
static inline bool net_if_is_socket_offloaded(struct net_if *iface)
{
#if defined(CONFIG_NET_SOCKETS_OFFLOAD)
	return iface->if_dev->offloaded;
   1c4ec:	682b      	ldr	r3, [r5, #0]

	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
	     net_if_is_ip_offloaded(iface)) ||
	    (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD) &&
	     net_if_is_socket_offloaded(iface))) {
		net_if_flag_set(iface, NET_IF_UP);
   1c4ee:	4628      	mov	r0, r5
	if ((IS_ENABLED(CONFIG_NET_OFFLOAD) &&
   1c4f0:	7e9b      	ldrb	r3, [r3, #26]
   1c4f2:	b11b      	cbz	r3, 1c4fc <net_if_up+0x1c>
		net_if_flag_set(iface, NET_IF_UP);
   1c4f4:	f7ff fdfa 	bl	1c0ec <net_if_flag_set.constprop.32>
		return 0;
   1c4f8:	2000      	movs	r0, #0
   1c4fa:	e023      	b.n	1c544 <net_if_up+0x64>
		goto exit;
	}

	/* If the L2 does not support enable just set the flag */
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   1c4fc:	f019 f8b6 	bl	3566c <net_if_l2>
   1c500:	b9c0      	cbnz	r0, 1c534 <net_if_up+0x54>

done:
	/* In many places it's assumed that link address was set with
	 * net_if_set_link_addr(). Better check that now.
	 */
	NET_ASSERT(net_if_get_link_addr(iface)->addr != NULL);
   1c502:	682b      	ldr	r3, [r5, #0]
   1c504:	691b      	ldr	r3, [r3, #16]
   1c506:	b973      	cbnz	r3, 1c526 <net_if_up+0x46>
   1c508:	490f      	ldr	r1, [pc, #60]	; (1c548 <net_if_up+0x68>)
   1c50a:	f640 53ba 	movw	r3, #3514	; 0xdba
   1c50e:	4a0f      	ldr	r2, [pc, #60]	; (1c54c <net_if_up+0x6c>)
   1c510:	480f      	ldr	r0, [pc, #60]	; (1c550 <net_if_up+0x70>)
   1c512:	f017 f859 	bl	335c8 <printk>
   1c516:	480f      	ldr	r0, [pc, #60]	; (1c554 <net_if_up+0x74>)
   1c518:	f017 f856 	bl	335c8 <printk>
   1c51c:	f640 51ba 	movw	r1, #3514	; 0xdba
   1c520:	480a      	ldr	r0, [pc, #40]	; (1c54c <net_if_up+0x6c>)
   1c522:	f017 fb52 	bl	33bca <assert_post_action>

	net_if_flag_set(iface, NET_IF_UP);
   1c526:	4628      	mov	r0, r5
   1c528:	f7ff fde0 	bl	1c0ec <net_if_flag_set.constprop.32>

	/* If the interface is only having point-to-point traffic then we do
	 * not need to run DAD etc for it.
	 */
	if (!(l2_flags_get(iface) & NET_L2_POINT_TO_POINT)) {
   1c52c:	4628      	mov	r0, r5
   1c52e:	f019 f8a8 	bl	35682 <l2_flags_get>
   1c532:	e7e1      	b.n	1c4f8 <net_if_up+0x18>
	if (!net_if_l2(iface) || !net_if_l2(iface)->enable) {
   1c534:	6883      	ldr	r3, [r0, #8]
   1c536:	2b00      	cmp	r3, #0
   1c538:	d0e3      	beq.n	1c502 <net_if_up+0x22>
	status = net_if_l2(iface)->enable(iface, true);
   1c53a:	2101      	movs	r1, #1
   1c53c:	4628      	mov	r0, r5
   1c53e:	4798      	blx	r3
	if (status < 0) {
   1c540:	2800      	cmp	r0, #0
   1c542:	dade      	bge.n	1c502 <net_if_up+0x22>

exit:
	net_mgmt_event_notify(NET_EVENT_IF_UP, iface);

	return 0;
}
   1c544:	bd38      	pop	{r3, r4, r5, pc}
   1c546:	bf00      	nop
   1c548:	0003d9be 	.word	0x0003d9be
   1c54c:	0003d9ef 	.word	0x0003d9ef
   1c550:	0003b77f 	.word	0x0003b77f
   1c554:	0003cb8b 	.word	0x0003cb8b

0001c558 <net_if_init>:
	k_fifo_put(&tx_ts_queue, pkt);
}
#endif /* CONFIG_NET_PKT_TIMESTAMP_THREAD */

void net_if_init(void)
{
   1c558:	b570      	push	{r4, r5, r6, lr}

	NET_DBG("");

	net_tc_tx_init();

	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
   1c55a:	4c10      	ldr	r4, [pc, #64]	; (1c59c <net_if_init+0x44>)
	net_tc_tx_init();
   1c55c:	f000 ff48 	bl	1d3f0 <net_tc_tx_init>
	for (iface = __net_if_start, if_count = 0; iface != __net_if_end;
   1c560:	4625      	mov	r5, r4
   1c562:	4e0f      	ldr	r6, [pc, #60]	; (1c5a0 <net_if_init+0x48>)
   1c564:	42b4      	cmp	r4, r6
   1c566:	d10e      	bne.n	1c586 <net_if_init+0x2e>
	     iface++, if_count++) {
		init_iface(iface);
	}

	if (iface == __net_if_start) {
   1c568:	42ac      	cmp	r4, r5
   1c56a:	d00b      	beq.n	1c584 <net_if_init+0x2c>
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
   1c56c:	2240      	movs	r2, #64	; 0x40
   1c56e:	4b0d      	ldr	r3, [pc, #52]	; (1c5a4 <net_if_init+0x4c>)
	k_delayed_work_init(&router_timer, iface_router_expired);
   1c570:	490d      	ldr	r1, [pc, #52]	; (1c5a8 <net_if_init+0x50>)
		ipv4_addresses[i].ipv4.ttl = CONFIG_NET_INITIAL_TTL;
   1c572:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	k_delayed_work_init(&router_timer, iface_router_expired);
   1c576:	480d      	ldr	r0, [pc, #52]	; (1c5ac <net_if_init+0x54>)
   1c578:	f01c fc54 	bl	38e24 <k_delayed_work_init>
	list->head = NULL;
   1c57c:	2200      	movs	r2, #0
   1c57e:	4b0c      	ldr	r3, [pc, #48]	; (1c5b0 <net_if_init+0x58>)
	list->tail = NULL;
   1c580:	e9c3 2200 	strd	r2, r2, [r3]
		NET_WARN("You have configured only %d VLAN interfaces"
			 " but you have %d network interfaces.",
			 CONFIG_NET_VLAN_COUNT, if_count);
	}
#endif
}
   1c584:	bd70      	pop	{r4, r5, r6, pc}
	return iface->if_dev->dev;
   1c586:	6823      	ldr	r3, [r4, #0]
	const struct net_if_api *api = net_if_get_device(iface)->driver_api;
   1c588:	681b      	ldr	r3, [r3, #0]
   1c58a:	689b      	ldr	r3, [r3, #8]
	if (!api || !api->init) {
   1c58c:	b11b      	cbz	r3, 1c596 <net_if_init+0x3e>
   1c58e:	681b      	ldr	r3, [r3, #0]
   1c590:	b10b      	cbz	r3, 1c596 <net_if_init+0x3e>
	api->init(iface);
   1c592:	4620      	mov	r0, r4
   1c594:	4798      	blx	r3
	     iface++, if_count++) {
   1c596:	3420      	adds	r4, #32
   1c598:	e7e4      	b.n	1c564 <net_if_init+0xc>
   1c59a:	bf00      	nop
   1c59c:	200208c0 	.word	0x200208c0
   1c5a0:	200208e0 	.word	0x200208e0
   1c5a4:	20021790 	.word	0x20021790
   1c5a8:	0001c1a9 	.word	0x0001c1a9
   1c5ac:	200217d8 	.word	0x200217d8
   1c5b0:	20021788 	.word	0x20021788

0001c5b4 <net_if_post_init>:

void net_if_post_init(void)
{
   1c5b4:	b538      	push	{r3, r4, r5, lr}
	struct net_if *iface;

	NET_DBG("");

	/* After TX is running, attempt to bring the interface up */
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c5b6:	4c07      	ldr	r4, [pc, #28]	; (1c5d4 <net_if_post_init+0x20>)
   1c5b8:	4d07      	ldr	r5, [pc, #28]	; (1c5d8 <net_if_post_init+0x24>)
   1c5ba:	42ac      	cmp	r4, r5
   1c5bc:	d100      	bne.n	1c5c0 <net_if_post_init+0xc>
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
			net_if_up(iface);
		}
	}
}
   1c5be:	bd38      	pop	{r3, r4, r5, pc}
		if (!net_if_flag_is_set(iface, NET_IF_NO_AUTO_START)) {
   1c5c0:	2103      	movs	r1, #3
   1c5c2:	4620      	mov	r0, r4
   1c5c4:	f7ff fd34 	bl	1c030 <net_if_flag_is_set>
   1c5c8:	b910      	cbnz	r0, 1c5d0 <net_if_post_init+0x1c>
			net_if_up(iface);
   1c5ca:	4620      	mov	r0, r4
   1c5cc:	f7ff ff88 	bl	1c4e0 <net_if_up>
	for (iface = __net_if_start; iface != __net_if_end; iface++) {
   1c5d0:	3420      	adds	r4, #32
   1c5d2:	e7f2      	b.n	1c5ba <net_if_post_init+0x6>
   1c5d4:	200208c0 	.word	0x200208c0
   1c5d8:	200208e0 	.word	0x200208e0

0001c5dc <net_ipv4_unspecified_address>:
const struct in_addr *net_ipv4_unspecified_address(void)
{
	static const struct in_addr addr;

	return &addr;
}
   1c5dc:	4800      	ldr	r0, [pc, #0]	; (1c5e0 <net_ipv4_unspecified_address+0x4>)
   1c5de:	4770      	bx	lr
   1c5e0:	0003a4f4 	.word	0x0003a4f4

0001c5e4 <net_ipv4_broadcast_address>:
const struct in_addr *net_ipv4_broadcast_address(void)
{
	static const struct in_addr addr = { { { 255, 255, 255, 255 } } };

	return &addr;
}
   1c5e4:	4800      	ldr	r0, [pc, #0]	; (1c5e8 <net_ipv4_broadcast_address+0x4>)
   1c5e6:	4770      	bx	lr
   1c5e8:	0003a4f8 	.word	0x0003a4f8

0001c5ec <net_context_is_used>:
{
   1c5ec:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1c5ee:	4604      	mov	r4, r0
   1c5f0:	b970      	cbnz	r0, 1c610 <net_context_is_used+0x24>
   1c5f2:	490a      	ldr	r1, [pc, #40]	; (1c61c <net_context_is_used+0x30>)
   1c5f4:	f44f 73a9 	mov.w	r3, #338	; 0x152
   1c5f8:	4a09      	ldr	r2, [pc, #36]	; (1c620 <net_context_is_used+0x34>)
   1c5fa:	480a      	ldr	r0, [pc, #40]	; (1c624 <net_context_is_used+0x38>)
   1c5fc:	f016 ffe4 	bl	335c8 <printk>
   1c600:	4809      	ldr	r0, [pc, #36]	; (1c628 <net_context_is_used+0x3c>)
   1c602:	f016 ffe1 	bl	335c8 <printk>
   1c606:	f44f 71a9 	mov.w	r1, #338	; 0x152
   1c60a:	4805      	ldr	r0, [pc, #20]	; (1c620 <net_context_is_used+0x34>)
   1c60c:	f017 fadd 	bl	33bca <assert_post_action>
	return context->flags & NET_CONTEXT_IN_USE;
   1c610:	f894 007a 	ldrb.w	r0, [r4, #122]	; 0x7a
}
   1c614:	f000 0001 	and.w	r0, r0, #1
   1c618:	bd10      	pop	{r4, pc}
   1c61a:	bf00      	nop
   1c61c:	0003cb83 	.word	0x0003cb83
   1c620:	0003cb56 	.word	0x0003cb56
   1c624:	0003b77f 	.word	0x0003b77f
   1c628:	0003cb8b 	.word	0x0003cb8b

0001c62c <check_used_port>:
#if defined(CONFIG_NET_UDP) || defined(CONFIG_NET_TCP)
static int check_used_port(enum net_ip_protocol ip_proto,
			   u16_t local_port,
			   const struct sockaddr *local_addr)

{
   1c62c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1c630:	460f      	mov	r7, r1
   1c632:	4615      	mov	r5, r2
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
		if (!net_context_is_used(&contexts[i])) {
			continue;
		}

		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
   1c634:	4680      	mov	r8, r0
   1c636:	4c0f      	ldr	r4, [pc, #60]	; (1c674 <check_used_port+0x48>)
   1c638:	f504 7640 	add.w	r6, r4, #768	; 0x300
		if (!net_context_is_used(&contexts[i])) {
   1c63c:	4620      	mov	r0, r4
   1c63e:	f7ff ffd5 	bl	1c5ec <net_context_is_used>
   1c642:	b170      	cbz	r0, 1c662 <check_used_port+0x36>
		if (!(net_context_get_ip_proto(&contexts[i]) == ip_proto &&
   1c644:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1c648:	4543      	cmp	r3, r8
   1c64a:	d10a      	bne.n	1c662 <check_used_port+0x36>
   1c64c:	8be3      	ldrh	r3, [r4, #30]
   1c64e:	42bb      	cmp	r3, r7
   1c650:	d107      	bne.n	1c662 <check_used_port+0x36>
							     sin6_addr,
				    &((struct sockaddr_in6 *)
				      local_addr)->sin6_addr)) {
				return -EEXIST;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1c652:	882b      	ldrh	r3, [r5, #0]
   1c654:	2b01      	cmp	r3, #1
   1c656:	d104      	bne.n	1c662 <check_used_port+0x36>
   1c658:	6a23      	ldr	r3, [r4, #32]
   1c65a:	686a      	ldr	r2, [r5, #4]
   1c65c:	681b      	ldr	r3, [r3, #0]
			   local_addr->sa_family == AF_INET) {
			if (net_ipv4_addr_cmp(
   1c65e:	429a      	cmp	r2, r3
   1c660:	d005      	beq.n	1c66e <check_used_port+0x42>
   1c662:	3480      	adds	r4, #128	; 0x80
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
   1c664:	42b4      	cmp	r4, r6
   1c666:	d1e9      	bne.n	1c63c <check_used_port+0x10>
				return -EEXIST;
			}
		}
	}

	return 0;
   1c668:	2000      	movs	r0, #0
}
   1c66a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				return -EEXIST;
   1c66e:	f06f 0010 	mvn.w	r0, #16
   1c672:	e7fa      	b.n	1c66a <check_used_port+0x3e>
   1c674:	200217f8 	.word	0x200217f8

0001c678 <net_context_get_state>:
{
   1c678:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1c67a:	4604      	mov	r4, r0
   1c67c:	b970      	cbnz	r0, 1c69c <net_context_get_state+0x24>
   1c67e:	490a      	ldr	r1, [pc, #40]	; (1c6a8 <net_context_get_state+0x30>)
   1c680:	f44f 73d3 	mov.w	r3, #422	; 0x1a6
   1c684:	4a09      	ldr	r2, [pc, #36]	; (1c6ac <net_context_get_state+0x34>)
   1c686:	480a      	ldr	r0, [pc, #40]	; (1c6b0 <net_context_get_state+0x38>)
   1c688:	f016 ff9e 	bl	335c8 <printk>
   1c68c:	4809      	ldr	r0, [pc, #36]	; (1c6b4 <net_context_get_state+0x3c>)
   1c68e:	f016 ff9b 	bl	335c8 <printk>
   1c692:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   1c696:	4805      	ldr	r0, [pc, #20]	; (1c6ac <net_context_get_state+0x34>)
   1c698:	f017 fa97 	bl	33bca <assert_post_action>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
   1c69c:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   1c6a0:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1c6a4:	bd10      	pop	{r4, pc}
   1c6a6:	bf00      	nop
   1c6a8:	0003cb83 	.word	0x0003cb83
   1c6ac:	0003cb56 	.word	0x0003cb56
   1c6b0:	0003b77f 	.word	0x0003b77f
   1c6b4:	0003cb8b 	.word	0x0003cb8b

0001c6b8 <net_context_get_family>:
{
   1c6b8:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1c6ba:	4604      	mov	r4, r0
   1c6bc:	b970      	cbnz	r0, 1c6dc <net_context_get_family+0x24>
   1c6be:	490a      	ldr	r1, [pc, #40]	; (1c6e8 <net_context_get_family+0x30>)
   1c6c0:	f240 13cb 	movw	r3, #459	; 0x1cb
   1c6c4:	4a09      	ldr	r2, [pc, #36]	; (1c6ec <net_context_get_family+0x34>)
   1c6c6:	480a      	ldr	r0, [pc, #40]	; (1c6f0 <net_context_get_family+0x38>)
   1c6c8:	f016 ff7e 	bl	335c8 <printk>
   1c6cc:	4809      	ldr	r0, [pc, #36]	; (1c6f4 <net_context_get_family+0x3c>)
   1c6ce:	f016 ff7b 	bl	335c8 <printk>
   1c6d2:	f240 11cb 	movw	r1, #459	; 0x1cb
   1c6d6:	4805      	ldr	r0, [pc, #20]	; (1c6ec <net_context_get_family+0x34>)
   1c6d8:	f017 fa77 	bl	33bca <assert_post_action>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   1c6dc:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   1c6e0:	f3c0 00c2 	ubfx	r0, r0, #3, #3
   1c6e4:	bd10      	pop	{r4, pc}
   1c6e6:	bf00      	nop
   1c6e8:	0003cb83 	.word	0x0003cb83
   1c6ec:	0003cb56 	.word	0x0003cb56
   1c6f0:	0003b77f 	.word	0x0003b77f
   1c6f4:	0003cb8b 	.word	0x0003cb8b

0001c6f8 <net_context_get_type>:
{
   1c6f8:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1c6fa:	4604      	mov	r4, r0
   1c6fc:	b970      	cbnz	r0, 1c71c <net_context_get_type+0x24>
   1c6fe:	490a      	ldr	r1, [pc, #40]	; (1c728 <net_context_get_type+0x30>)
   1c700:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
   1c704:	4a09      	ldr	r2, [pc, #36]	; (1c72c <net_context_get_type+0x34>)
   1c706:	480a      	ldr	r0, [pc, #40]	; (1c730 <net_context_get_type+0x38>)
   1c708:	f016 ff5e 	bl	335c8 <printk>
   1c70c:	4809      	ldr	r0, [pc, #36]	; (1c734 <net_context_get_type+0x3c>)
   1c70e:	f016 ff5b 	bl	335c8 <printk>
   1c712:	f44f 71fb 	mov.w	r1, #502	; 0x1f6
   1c716:	4805      	ldr	r0, [pc, #20]	; (1c72c <net_context_get_type+0x34>)
   1c718:	f017 fa57 	bl	33bca <assert_post_action>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   1c71c:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   1c720:	f3c0 1081 	ubfx	r0, r0, #6, #2
   1c724:	bd10      	pop	{r4, pc}
   1c726:	bf00      	nop
   1c728:	0003cb83 	.word	0x0003cb83
   1c72c:	0003cb56 	.word	0x0003cb56
   1c730:	0003b77f 	.word	0x0003b77f
   1c734:	0003cb8b 	.word	0x0003cb8b

0001c738 <find_available_port>:

static u16_t find_available_port(struct net_context *context,
				    const struct sockaddr *addr)
{
   1c738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1c73a:	4605      	mov	r5, r0
   1c73c:	460e      	mov	r6, r1
	u16_t local_port;

	do {
		local_port = sys_rand32_get() | 0x8000;
   1c73e:	4f08      	ldr	r7, [pc, #32]	; (1c760 <find_available_port+0x28>)
   1c740:	f002 faea 	bl	1ed18 <sys_rand32_get>
   1c744:	ea40 0407 	orr.w	r4, r0, r7
   1c748:	ba64      	rev16	r4, r4
   1c74a:	b2a4      	uxth	r4, r4
		if (local_port <= 1023U) {
			/* 0 - 1023 ports are reserved */
			continue;
		}
	} while (check_used_port(net_context_get_ip_proto(context),
   1c74c:	4632      	mov	r2, r6
   1c74e:	4621      	mov	r1, r4
   1c750:	f895 0078 	ldrb.w	r0, [r5, #120]	; 0x78
   1c754:	f7ff ff6a 	bl	1c62c <check_used_port>
				 htons(local_port), addr) == -EEXIST);
   1c758:	3011      	adds	r0, #17
   1c75a:	d0f1      	beq.n	1c740 <find_available_port+0x8>

	return htons(local_port);
}
   1c75c:	4620      	mov	r0, r4
   1c75e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1c760:	ffff8000 	.word	0xffff8000

0001c764 <net_context_set_iface.isra.16>:
 * @details This function binds network interface to this context.
 *
 * @param context Network context.
 * @param iface Network interface.
 */
static inline void net_context_set_iface(struct net_context *context,
   1c764:	b538      	push	{r3, r4, r5, lr}
   1c766:	4605      	mov	r5, r0
					 struct net_if *iface)
{
	NET_ASSERT(iface);
   1c768:	460c      	mov	r4, r1
   1c76a:	b971      	cbnz	r1, 1c78a <net_context_set_iface.isra.16+0x26>
   1c76c:	4909      	ldr	r1, [pc, #36]	; (1c794 <net_context_set_iface.isra.16+0x30>)
   1c76e:	f240 2381 	movw	r3, #641	; 0x281
   1c772:	4a09      	ldr	r2, [pc, #36]	; (1c798 <net_context_set_iface.isra.16+0x34>)
   1c774:	4809      	ldr	r0, [pc, #36]	; (1c79c <net_context_set_iface.isra.16+0x38>)
   1c776:	f016 ff27 	bl	335c8 <printk>
   1c77a:	4809      	ldr	r0, [pc, #36]	; (1c7a0 <net_context_set_iface.isra.16+0x3c>)
   1c77c:	f016 ff24 	bl	335c8 <printk>
   1c780:	f240 2181 	movw	r1, #641	; 0x281
   1c784:	4804      	ldr	r0, [pc, #16]	; (1c798 <net_context_set_iface.isra.16+0x34>)
   1c786:	f017 fa20 	bl	33bca <assert_post_action>

	context->iface = net_if_get_by_iface(iface);
   1c78a:	4620      	mov	r0, r4
   1c78c:	f7ff fe96 	bl	1c4bc <net_if_get_by_iface>
   1c790:	7028      	strb	r0, [r5, #0]
}
   1c792:	bd38      	pop	{r3, r4, r5, pc}
   1c794:	0003d9b8 	.word	0x0003d9b8
   1c798:	0003cb56 	.word	0x0003cb56
   1c79c:	0003b77f 	.word	0x0003b77f
   1c7a0:	0003cb8b 	.word	0x0003cb8b

0001c7a4 <net_context_packet_received>:
enum net_verdict net_context_packet_received(struct net_conn *conn,
					     struct net_pkt *pkt,
					     union net_ip_header *ip_hdr,
					     union net_proto_header *proto_hdr,
					     void *user_data)
{
   1c7a4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   1c7a8:	4682      	mov	sl, r0
   1c7aa:	460e      	mov	r6, r1
   1c7ac:	4690      	mov	r8, r2
   1c7ae:	4699      	mov	r9, r3
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
   1c7b0:	2700      	movs	r7, #0
   1c7b2:	4d2a      	ldr	r5, [pc, #168]	; (1c85c <net_context_packet_received+0xb8>)
		if (!net_context_is_used(&contexts[i])) {
   1c7b4:	4628      	mov	r0, r5
   1c7b6:	462c      	mov	r4, r5
   1c7b8:	f7ff ff18 	bl	1c5ec <net_context_is_used>
   1c7bc:	b110      	cbz	r0, 1c7c4 <net_context_packet_received+0x20>
		if (contexts[i].conn_handler == conn_handler) {
   1c7be:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1c7c0:	459a      	cmp	sl, r3
   1c7c2:	d014      	beq.n	1c7ee <net_context_packet_received+0x4a>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
   1c7c4:	3701      	adds	r7, #1
   1c7c6:	2f06      	cmp	r7, #6
   1c7c8:	f105 0580 	add.w	r5, r5, #128	; 0x80
   1c7cc:	d1f2      	bne.n	1c7b4 <net_context_packet_received+0x10>
	struct net_context *context = find_context(conn);
	enum net_verdict verdict = NET_DROP;

	NET_ASSERT(context);
   1c7ce:	f240 63b9 	movw	r3, #1721	; 0x6b9
   1c7d2:	4a23      	ldr	r2, [pc, #140]	; (1c860 <net_context_packet_received+0xbc>)
   1c7d4:	4923      	ldr	r1, [pc, #140]	; (1c864 <net_context_packet_received+0xc0>)
   1c7d6:	4824      	ldr	r0, [pc, #144]	; (1c868 <net_context_packet_received+0xc4>)
   1c7d8:	f016 fef6 	bl	335c8 <printk>
   1c7dc:	4823      	ldr	r0, [pc, #140]	; (1c86c <net_context_packet_received+0xc8>)
   1c7de:	f016 fef3 	bl	335c8 <printk>
   1c7e2:	f240 61b9 	movw	r1, #1721	; 0x6b9
   1c7e6:	481e      	ldr	r0, [pc, #120]	; (1c860 <net_context_packet_received+0xbc>)
   1c7e8:	f017 f9ef 	bl	33bca <assert_post_action>
	return NULL;
   1c7ec:	2400      	movs	r4, #0
	NET_ASSERT(net_pkt_iface(pkt));
   1c7ee:	6a33      	ldr	r3, [r6, #32]
   1c7f0:	b973      	cbnz	r3, 1c810 <net_context_packet_received+0x6c>
   1c7f2:	491f      	ldr	r1, [pc, #124]	; (1c870 <net_context_packet_received+0xcc>)
   1c7f4:	f240 63ba 	movw	r3, #1722	; 0x6ba
   1c7f8:	4a19      	ldr	r2, [pc, #100]	; (1c860 <net_context_packet_received+0xbc>)
   1c7fa:	481b      	ldr	r0, [pc, #108]	; (1c868 <net_context_packet_received+0xc4>)
   1c7fc:	f016 fee4 	bl	335c8 <printk>
   1c800:	481a      	ldr	r0, [pc, #104]	; (1c86c <net_context_packet_received+0xc8>)
   1c802:	f016 fee1 	bl	335c8 <printk>
   1c806:	f240 61ba 	movw	r1, #1722	; 0x6ba
   1c80a:	4815      	ldr	r0, [pc, #84]	; (1c860 <net_context_packet_received+0xbc>)
   1c80c:	f017 f9dd 	bl	33bca <assert_post_action>

	k_mutex_lock(&context->lock, K_FOREVER);
   1c810:	f104 0708 	add.w	r7, r4, #8
   1c814:	4638      	mov	r0, r7
   1c816:	f019 f8ba 	bl	3598e <k_mutex_lock.constprop.28>

	net_context_set_iface(context, net_pkt_iface(pkt));
   1c81a:	6a31      	ldr	r1, [r6, #32]
   1c81c:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   1c820:	f7ff ffa0 	bl	1c764 <net_context_set_iface.isra.16>
	net_pkt_set_context(pkt, context);

	/* If there is no callback registered, then we can only drop
	 * the packet.
	 */
	if (!context->recv_cb) {
   1c824:	f8d4 a030 	ldr.w	sl, [r4, #48]	; 0x30
	pkt->context = ctx;
   1c828:	61f4      	str	r4, [r6, #28]
   1c82a:	f1ba 0f00 	cmp.w	sl, #0
   1c82e:	d013      	beq.n	1c858 <net_context_packet_received+0xb4>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		net_stats_update_tcp_recv(net_pkt_iface(pkt),
					  net_pkt_remaining_data(pkt));
	}

	context->recv_cb(context, pkt, ip_hdr, proto_hdr, 0, user_data);
   1c830:	2500      	movs	r5, #0
   1c832:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   1c834:	9500      	str	r5, [sp, #0]
   1c836:	9301      	str	r3, [sp, #4]
   1c838:	4642      	mov	r2, r8
   1c83a:	464b      	mov	r3, r9
   1c83c:	4631      	mov	r1, r6
   1c83e:	4620      	mov	r0, r4
   1c840:	47d0      	blx	sl
	z_impl_k_sem_give(sem);
   1c842:	f104 0040 	add.w	r0, r4, #64	; 0x40
   1c846:	f011 fbd1 	bl	2dfec <z_impl_k_sem_give>
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

	verdict = NET_OK;

unlock:
	k_mutex_unlock(&context->lock);
   1c84a:	4638      	mov	r0, r7
   1c84c:	f019 f882 	bl	35954 <k_mutex_unlock>

	return verdict;
}
   1c850:	4628      	mov	r0, r5
   1c852:	b002      	add	sp, #8
   1c854:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	enum net_verdict verdict = NET_DROP;
   1c858:	2502      	movs	r5, #2
   1c85a:	e7f6      	b.n	1c84a <net_context_packet_received+0xa6>
   1c85c:	200217f8 	.word	0x200217f8
   1c860:	0003db97 	.word	0x0003db97
   1c864:	0003cb83 	.word	0x0003cb83
   1c868:	0003b77f 	.word	0x0003b77f
   1c86c:	0003cb8b 	.word	0x0003cb8b
   1c870:	0003dbc6 	.word	0x0003dbc6

0001c874 <net_context_get>:
		if (!IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
   1c874:	2802      	cmp	r0, #2
{
   1c876:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1c87a:	4607      	mov	r7, r0
   1c87c:	468a      	mov	sl, r1
   1c87e:	4690      	mov	r8, r2
   1c880:	4699      	mov	r9, r3
		if (!IS_ENABLED(CONFIG_NET_IPV6) && family == AF_INET6) {
   1c882:	f000 809d 	beq.w	1c9c0 <net_context_get+0x14c>
		if (!IS_ENABLED(CONFIG_NET_SOCKETS_CAN) && family == AF_CAN) {
   1c886:	2804      	cmp	r0, #4
   1c888:	f000 809a 	beq.w	1c9c0 <net_context_get+0x14c>
		if (type == SOCK_RAW) {
   1c88c:	2903      	cmp	r1, #3
   1c88e:	d003      	beq.n	1c898 <net_context_get+0x24>
			if (family == AF_PACKET || family == AF_CAN) {
   1c890:	1ec3      	subs	r3, r0, #3
   1c892:	2b01      	cmp	r3, #1
   1c894:	f240 809a 	bls.w	1c9cc <net_context_get+0x158>
		if (family != AF_INET && family != AF_INET6 &&
   1c898:	1e7b      	subs	r3, r7, #1
   1c89a:	2b03      	cmp	r3, #3
   1c89c:	f200 8093 	bhi.w	1c9c6 <net_context_get+0x152>
		if (type != SOCK_DGRAM && type != SOCK_STREAM &&
   1c8a0:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
   1c8a4:	2b02      	cmp	r3, #2
   1c8a6:	f200 8091 	bhi.w	1c9cc <net_context_get+0x158>
		if (type != SOCK_RAW && ip_proto != IPPROTO_UDP &&
   1c8aa:	f1ba 0f03 	cmp.w	sl, #3
   1c8ae:	d00a      	beq.n	1c8c6 <net_context_get+0x52>
   1c8b0:	f1b8 0f11 	cmp.w	r8, #17
   1c8b4:	f000 8090 	beq.w	1c9d8 <net_context_get+0x164>
   1c8b8:	f1b8 0f06 	cmp.w	r8, #6
   1c8bc:	f000 8093 	beq.w	1c9e6 <net_context_get+0x172>
			return -EPROTONOSUPPORT;
   1c8c0:	f06f 047a 	mvn.w	r4, #122	; 0x7a
   1c8c4:	e01f      	b.n	1c906 <net_context_get+0x92>
		if (!context) {
   1c8c6:	f1b9 0f00 	cmp.w	r9, #0
   1c8ca:	f000 8082 	beq.w	1c9d2 <net_context_get+0x15e>
	return z_impl_k_sem_take(sem, timeout);
   1c8ce:	4c47      	ldr	r4, [pc, #284]	; (1c9ec <net_context_get+0x178>)
   1c8d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1c8d4:	4846      	ldr	r0, [pc, #280]	; (1c9f0 <net_context_get+0x17c>)
   1c8d6:	f011 fbcd 	bl	2e074 <z_impl_k_sem_take>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
   1c8da:	f04f 0b00 	mov.w	fp, #0
   1c8de:	4626      	mov	r6, r4
		if (net_context_is_used(&contexts[i])) {
   1c8e0:	4620      	mov	r0, r4
   1c8e2:	f7ff fe83 	bl	1c5ec <net_context_is_used>
   1c8e6:	ea4f 15cb 	mov.w	r5, fp, lsl #7
   1c8ea:	4601      	mov	r1, r0
   1c8ec:	b170      	cbz	r0, 1c90c <net_context_get+0x98>
	for (i = 0; i < NET_MAX_CONTEXT; i++) {
   1c8ee:	f10b 0b01 	add.w	fp, fp, #1
   1c8f2:	f1bb 0f06 	cmp.w	fp, #6
   1c8f6:	f104 0480 	add.w	r4, r4, #128	; 0x80
   1c8fa:	d1f1      	bne.n	1c8e0 <net_context_get+0x6c>
	int i, ret = -ENOENT;
   1c8fc:	f06f 0401 	mvn.w	r4, #1
	z_impl_k_sem_give(sem);
   1c900:	483b      	ldr	r0, [pc, #236]	; (1c9f0 <net_context_get+0x17c>)
   1c902:	f011 fb73 	bl	2dfec <z_impl_k_sem_give>
}
   1c906:	4620      	mov	r0, r4
   1c908:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
__ssp_bos_icheck3(memset, void *, int)
   1c90c:	2280      	movs	r2, #128	; 0x80
   1c90e:	4620      	mov	r0, r4
   1c910:	f01c fb9c 	bl	3904c <memset>
		if (!net_if_is_ip_offloaded(net_if_get_default())
   1c914:	f7ff fc90 	bl	1c238 <net_if_get_default>
			&& ip_proto == IPPROTO_TCP) {
   1c918:	f1b8 0f06 	cmp.w	r8, #6
   1c91c:	d032      	beq.n	1c984 <net_context_get+0x110>
		contexts[i].iface = -1;
   1c91e:	22ff      	movs	r2, #255	; 0xff
   1c920:	1973      	adds	r3, r6, r5
   1c922:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
		contexts[i].flags = 0U;
   1c926:	2200      	movs	r2, #0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   1c928:	2001      	movs	r0, #1
   1c92a:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a
   1c92e:	1d19      	adds	r1, r3, #4
   1c930:	e8d1 cfef 	ldaex	ip, [r1]
   1c934:	e8c1 0fee 	stlex	lr, r0, [r1]
   1c938:	f1be 0f00 	cmp.w	lr, #0
   1c93c:	d1f8      	bne.n	1c930 <net_context_get+0xbc>
		flag = family << 3;
   1c93e:	00f9      	lsls	r1, r7, #3
	context->flags |= flag;
   1c940:	f8b3 007a 	ldrh.w	r0, [r3, #122]	; 0x7a
	context->flags |= flag;
   1c944:	b2c9      	uxtb	r1, r1
	context->flags |= flag;
   1c946:	ea41 118a 	orr.w	r1, r1, sl, lsl #6
   1c94a:	4301      	orrs	r1, r0
   1c94c:	f8a3 107a 	strh.w	r1, [r3, #122]	; 0x7a
			(void)memset(&contexts[i].remote, 0,
   1c950:	f105 0324 	add.w	r3, r5, #36	; 0x24
	context->proto = proto;
   1c954:	f8a4 8078 	strh.w	r8, [r4, #120]	; 0x78
   1c958:	18f1      	adds	r1, r6, r3
   1c95a:	50f2      	str	r2, [r6, r3]
			(void)memset(&contexts[i].local, 0,
   1c95c:	f105 031c 	add.w	r3, r5, #28
   1c960:	eb06 0803 	add.w	r8, r6, r3
		if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1c964:	2f01      	cmp	r7, #1
   1c966:	604a      	str	r2, [r1, #4]
   1c968:	50f2      	str	r2, [r6, r3]
   1c96a:	f8c8 2004 	str.w	r2, [r8, #4]
   1c96e:	d10f      	bne.n	1c990 <net_context_get+0x11c>
			addr->sin_port = find_available_port(&contexts[i],
   1c970:	4641      	mov	r1, r8
   1c972:	4620      	mov	r0, r4
   1c974:	f7ff fee0 	bl	1c738 <find_available_port>
   1c978:	f8a8 0002 	strh.w	r0, [r8, #2]
			if (!addr->sin_port) {
   1c97c:	b940      	cbnz	r0, 1c990 <net_context_get+0x11c>
				ret = -EADDRINUSE;
   1c97e:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   1c982:	e7bd      	b.n	1c900 <net_context_get+0x8c>
			if (net_tcp_get(&contexts[i]) < 0) {
   1c984:	4620      	mov	r0, r4
   1c986:	f001 ff43 	bl	1e810 <net_tcp_get>
   1c98a:	2800      	cmp	r0, #0
   1c98c:	dac7      	bge.n	1c91e <net_context_get+0xaa>
   1c98e:	e7b5      	b.n	1c8fc <net_context_get+0x88>
		k_sem_init(&contexts[i].recv_data_wait, 1, UINT_MAX);
   1c990:	f105 0040 	add.w	r0, r5, #64	; 0x40
	return z_impl_k_sem_init(sem, initial_count, limit);
   1c994:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1c998:	2101      	movs	r1, #1
   1c99a:	4430      	add	r0, r6
   1c99c:	f01c f9c1 	bl	38d22 <z_impl_k_sem_init>
		k_mutex_init(&contexts[i].lock);
   1c9a0:	f105 0008 	add.w	r0, r5, #8
	return z_impl_k_mutex_init(mutex);
   1c9a4:	4430      	add	r0, r6
		contexts[i].flags |= NET_CONTEXT_IN_USE;
   1c9a6:	4435      	add	r5, r6
   1c9a8:	f01c f95c 	bl	38c64 <z_impl_k_mutex_init>
   1c9ac:	f8b5 307a 	ldrh.w	r3, [r5, #122]	; 0x7a
   1c9b0:	f043 0301 	orr.w	r3, r3, #1
   1c9b4:	f8a5 307a 	strh.w	r3, [r5, #122]	; 0x7a
		*context = &contexts[i];
   1c9b8:	f8c9 4000 	str.w	r4, [r9]
		ret = 0;
   1c9bc:	2400      	movs	r4, #0
		break;
   1c9be:	e79f      	b.n	1c900 <net_context_get+0x8c>
			return -EPFNOSUPPORT;
   1c9c0:	f06f 045f 	mvn.w	r4, #95	; 0x5f
   1c9c4:	e79f      	b.n	1c906 <net_context_get+0x92>
			return -EAFNOSUPPORT;
   1c9c6:	f06f 0469 	mvn.w	r4, #105	; 0x69
   1c9ca:	e79c      	b.n	1c906 <net_context_get+0x92>
				return -EPROTOTYPE;
   1c9cc:	f06f 046a 	mvn.w	r4, #106	; 0x6a
   1c9d0:	e799      	b.n	1c906 <net_context_get+0x92>
			return -EINVAL;
   1c9d2:	f06f 0415 	mvn.w	r4, #21
   1c9d6:	e796      	b.n	1c906 <net_context_get+0x92>
		if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
   1c9d8:	f1ba 0f01 	cmp.w	sl, #1
   1c9dc:	f47f af73 	bne.w	1c8c6 <net_context_get+0x52>
			return -EOPNOTSUPP;
   1c9e0:	f06f 045e 	mvn.w	r4, #94	; 0x5e
   1c9e4:	e78f      	b.n	1c906 <net_context_get+0x92>
		if ((type == SOCK_STREAM && ip_proto == IPPROTO_UDP) ||
   1c9e6:	f1ba 0f02 	cmp.w	sl, #2
   1c9ea:	e7f7      	b.n	1c9dc <net_context_get+0x168>
   1c9ec:	200217f8 	.word	0x200217f8
   1c9f0:	20021af8 	.word	0x20021af8

0001c9f4 <net_context_put>:
{
   1c9f4:	b570      	push	{r4, r5, r6, lr}
	NET_ASSERT(context);
   1c9f6:	4605      	mov	r5, r0
   1c9f8:	b988      	cbnz	r0, 1ca1e <net_context_put+0x2a>
   1c9fa:	4916      	ldr	r1, [pc, #88]	; (1ca54 <net_context_put+0x60>)
   1c9fc:	f44f 73b7 	mov.w	r3, #366	; 0x16e
   1ca00:	4a15      	ldr	r2, [pc, #84]	; (1ca58 <net_context_put+0x64>)
   1ca02:	4816      	ldr	r0, [pc, #88]	; (1ca5c <net_context_put+0x68>)
   1ca04:	f016 fde0 	bl	335c8 <printk>
   1ca08:	4815      	ldr	r0, [pc, #84]	; (1ca60 <net_context_put+0x6c>)
   1ca0a:	f016 fddd 	bl	335c8 <printk>
   1ca0e:	f44f 71b7 	mov.w	r1, #366	; 0x16e
   1ca12:	4811      	ldr	r0, [pc, #68]	; (1ca58 <net_context_put+0x64>)
   1ca14:	f017 f8d9 	bl	33bca <assert_post_action>
		return -EINVAL;
   1ca18:	f06f 0015 	mvn.w	r0, #21
   1ca1c:	e019      	b.n	1ca52 <net_context_put+0x5e>
	if (!PART_OF_ARRAY(contexts, context)) {
   1ca1e:	4b11      	ldr	r3, [pc, #68]	; (1ca64 <net_context_put+0x70>)
   1ca20:	4298      	cmp	r0, r3
   1ca22:	d3f9      	bcc.n	1ca18 <net_context_put+0x24>
   1ca24:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1ca28:	429d      	cmp	r5, r3
   1ca2a:	d2f5      	bcs.n	1ca18 <net_context_put+0x24>
	context->connect_cb = NULL;
   1ca2c:	2400      	movs	r4, #0
	k_mutex_lock(&context->lock, K_FOREVER);
   1ca2e:	f105 0608 	add.w	r6, r5, #8
   1ca32:	4630      	mov	r0, r6
   1ca34:	f018 ffab 	bl	3598e <k_mutex_lock.constprop.28>
	context->connect_cb = NULL;
   1ca38:	63ac      	str	r4, [r5, #56]	; 0x38
	context->send_cb = NULL;
   1ca3a:	e9c5 440c 	strd	r4, r4, [r5, #48]	; 0x30
	net_context_unref(context);
   1ca3e:	4628      	mov	r0, r5
   1ca40:	f018 ffb3 	bl	359aa <net_context_unref>
	net_tcp_put(context);
   1ca44:	4628      	mov	r0, r5
   1ca46:	f01a fa5f 	bl	36f08 <net_tcp_put>
	k_mutex_unlock(&context->lock);
   1ca4a:	4630      	mov	r0, r6
   1ca4c:	f018 ff82 	bl	35954 <k_mutex_unlock>
	return ret;
   1ca50:	4620      	mov	r0, r4
}
   1ca52:	bd70      	pop	{r4, r5, r6, pc}
   1ca54:	0003cb83 	.word	0x0003cb83
   1ca58:	0003db97 	.word	0x0003db97
   1ca5c:	0003b77f 	.word	0x0003b77f
   1ca60:	0003cb8b 	.word	0x0003cb8b
   1ca64:	200217f8 	.word	0x200217f8

0001ca68 <net_context_bind>:
{
   1ca68:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   1ca6a:	4605      	mov	r5, r0
   1ca6c:	4614      	mov	r4, r2
	NET_ASSERT(addr);
   1ca6e:	460e      	mov	r6, r1
   1ca70:	b971      	cbnz	r1, 1ca90 <net_context_bind+0x28>
   1ca72:	493c      	ldr	r1, [pc, #240]	; (1cb64 <net_context_bind+0xfc>)
   1ca74:	f44f 73f5 	mov.w	r3, #490	; 0x1ea
   1ca78:	4a3b      	ldr	r2, [pc, #236]	; (1cb68 <net_context_bind+0x100>)
   1ca7a:	483c      	ldr	r0, [pc, #240]	; (1cb6c <net_context_bind+0x104>)
   1ca7c:	f016 fda4 	bl	335c8 <printk>
   1ca80:	483b      	ldr	r0, [pc, #236]	; (1cb70 <net_context_bind+0x108>)
   1ca82:	f016 fda1 	bl	335c8 <printk>
   1ca86:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
   1ca8a:	4837      	ldr	r0, [pc, #220]	; (1cb68 <net_context_bind+0x100>)
   1ca8c:	f017 f89d 	bl	33bca <assert_post_action>
	NET_ASSERT(PART_OF_ARRAY(contexts, context));
   1ca90:	b135      	cbz	r5, 1caa0 <net_context_bind+0x38>
   1ca92:	4b38      	ldr	r3, [pc, #224]	; (1cb74 <net_context_bind+0x10c>)
   1ca94:	429d      	cmp	r5, r3
   1ca96:	d303      	bcc.n	1caa0 <net_context_bind+0x38>
   1ca98:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1ca9c:	429d      	cmp	r5, r3
   1ca9e:	d30e      	bcc.n	1cabe <net_context_bind+0x56>
   1caa0:	4935      	ldr	r1, [pc, #212]	; (1cb78 <net_context_bind+0x110>)
   1caa2:	f240 13eb 	movw	r3, #491	; 0x1eb
   1caa6:	4a30      	ldr	r2, [pc, #192]	; (1cb68 <net_context_bind+0x100>)
   1caa8:	4830      	ldr	r0, [pc, #192]	; (1cb6c <net_context_bind+0x104>)
   1caaa:	f016 fd8d 	bl	335c8 <printk>
   1caae:	4830      	ldr	r0, [pc, #192]	; (1cb70 <net_context_bind+0x108>)
   1cab0:	f016 fd8a 	bl	335c8 <printk>
   1cab4:	f240 11eb 	movw	r1, #491	; 0x1eb
   1cab8:	482b      	ldr	r0, [pc, #172]	; (1cb68 <net_context_bind+0x100>)
   1caba:	f017 f886 	bl	33bca <assert_post_action>
	if (context->conn_handler) {
   1cabe:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1cac0:	2b00      	cmp	r3, #0
   1cac2:	d148      	bne.n	1cb56 <net_context_bind+0xee>
	if (IS_ENABLED(CONFIG_NET_IPV4) && addr->sa_family == AF_INET) {
   1cac4:	8832      	ldrh	r2, [r6, #0]
   1cac6:	2a01      	cmp	r2, #1
   1cac8:	d148      	bne.n	1cb5c <net_context_bind+0xf4>
		if (addrlen < sizeof(struct sockaddr_in)) {
   1caca:	2c07      	cmp	r4, #7
		struct net_if *iface = NULL;
   1cacc:	9301      	str	r3, [sp, #4]
		if (addrlen < sizeof(struct sockaddr_in)) {
   1cace:	d945      	bls.n	1cb5c <net_context_bind+0xf4>
		if (net_ipv4_is_addr_mcast(&addr4->sin_addr)) {
   1cad0:	1d32      	adds	r2, r6, #4
   1cad2:	4610      	mov	r0, r2
   1cad4:	f018 ff35 	bl	35942 <net_ipv4_is_addr_mcast>
   1cad8:	b148      	cbz	r0, 1caee <net_context_bind+0x86>
			maddr = net_if_ipv4_maddr_lookup(&addr4->sin_addr,
   1cada:	a901      	add	r1, sp, #4
   1cadc:	4610      	mov	r0, r2
   1cade:	f7ff fc53 	bl	1c388 <net_if_ipv4_maddr_lookup>
			if (!maddr) {
   1cae2:	bb78      	cbnz	r0, 1cb44 <net_context_bind+0xdc>
				return -ENOENT;
   1cae4:	f06f 0401 	mvn.w	r4, #1
}
   1cae8:	4620      	mov	r0, r4
   1caea:	b003      	add	sp, #12
   1caec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		} else if (addr4->sin_addr.s_addr == INADDR_ANY) {
   1caee:	6873      	ldr	r3, [r6, #4]
   1caf0:	bb1b      	cbnz	r3, 1cb3a <net_context_bind+0xd2>
			iface = net_if_ipv4_select_src_iface(
   1caf2:	f105 0028 	add.w	r0, r5, #40	; 0x28
   1caf6:	f7ff fbc1 	bl	1c27c <net_if_ipv4_select_src_iface>
   1cafa:	9001      	str	r0, [sp, #4]
			ptr = (struct in_addr *)net_ipv4_unspecified_address();
   1cafc:	f7ff fd6e 	bl	1c5dc <net_ipv4_unspecified_address>
   1cb00:	4604      	mov	r4, r0
		if (!iface) {
   1cb02:	9b01      	ldr	r3, [sp, #4]
   1cb04:	b323      	cbz	r3, 1cb50 <net_context_bind+0xe8>
		k_mutex_lock(&context->lock, K_FOREVER);
   1cb06:	f105 0708 	add.w	r7, r5, #8
   1cb0a:	4638      	mov	r0, r7
   1cb0c:	f018 ff3f 	bl	3598e <k_mutex_lock.constprop.28>
		net_context_set_iface(context, iface);
   1cb10:	9901      	ldr	r1, [sp, #4]
   1cb12:	f105 007c 	add.w	r0, r5, #124	; 0x7c
   1cb16:	f7ff fe25 	bl	1c764 <net_context_set_iface.isra.16>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
   1cb1a:	2001      	movs	r0, #1
		if (addr4->sin_port) {
   1cb1c:	8871      	ldrh	r1, [r6, #2]
		net_sin_ptr(&context->local)->sin_family = AF_INET;
   1cb1e:	83a8      	strh	r0, [r5, #28]
		net_sin_ptr(&context->local)->sin_addr = ptr;
   1cb20:	622c      	str	r4, [r5, #32]
		if (addr4->sin_port) {
   1cb22:	b189      	cbz	r1, 1cb48 <net_context_bind+0xe0>
			ret = check_used_port(AF_INET, addr4->sin_port,
   1cb24:	4632      	mov	r2, r6
   1cb26:	f7ff fd81 	bl	1c62c <check_used_port>
			if (!ret) {
   1cb2a:	4604      	mov	r4, r0
   1cb2c:	b908      	cbnz	r0, 1cb32 <net_context_bind+0xca>
				net_sin_ptr(&context->local)->sin_port =
   1cb2e:	8873      	ldrh	r3, [r6, #2]
   1cb30:	83eb      	strh	r3, [r5, #30]
		k_mutex_unlock(&context->lock);
   1cb32:	4638      	mov	r0, r7
   1cb34:	f018 ff0e 	bl	35954 <k_mutex_unlock>
		return ret;
   1cb38:	e7d6      	b.n	1cae8 <net_context_bind+0x80>
			ifaddr = net_if_ipv4_addr_lookup(&addr4->sin_addr,
   1cb3a:	a901      	add	r1, sp, #4
   1cb3c:	4610      	mov	r0, r2
   1cb3e:	f7ff fc05 	bl	1c34c <net_if_ipv4_addr_lookup>
   1cb42:	e7ce      	b.n	1cae2 <net_context_bind+0x7a>
			ptr = &ifaddr->address.in_addr;
   1cb44:	1d04      	adds	r4, r0, #4
   1cb46:	e7dc      	b.n	1cb02 <net_context_bind+0x9a>
			addr4->sin_port =
   1cb48:	8beb      	ldrh	r3, [r5, #30]
   1cb4a:	460c      	mov	r4, r1
   1cb4c:	8073      	strh	r3, [r6, #2]
   1cb4e:	e7f0      	b.n	1cb32 <net_context_bind+0xca>
			return -EADDRNOTAVAIL;
   1cb50:	f06f 047c 	mvn.w	r4, #124	; 0x7c
   1cb54:	e7c8      	b.n	1cae8 <net_context_bind+0x80>
		return -EISCONN;
   1cb56:	f06f 047e 	mvn.w	r4, #126	; 0x7e
   1cb5a:	e7c5      	b.n	1cae8 <net_context_bind+0x80>
	return -EINVAL;
   1cb5c:	f06f 0415 	mvn.w	r4, #21
   1cb60:	e7c2      	b.n	1cae8 <net_context_bind+0x80>
   1cb62:	bf00      	nop
   1cb64:	0003db92 	.word	0x0003db92
   1cb68:	0003db97 	.word	0x0003db97
   1cb6c:	0003b77f 	.word	0x0003b77f
   1cb70:	0003cb8b 	.word	0x0003cb8b
   1cb74:	200217f8 	.word	0x200217f8
   1cb78:	0003da19 	.word	0x0003da19

0001cb7c <net_context_listen>:
{
   1cb7c:	b538      	push	{r3, r4, r5, lr}
	NET_ASSERT(PART_OF_ARRAY(contexts, context));
   1cb7e:	4604      	mov	r4, r0
   1cb80:	b130      	cbz	r0, 1cb90 <net_context_listen+0x14>
   1cb82:	4b18      	ldr	r3, [pc, #96]	; (1cbe4 <net_context_listen+0x68>)
   1cb84:	4298      	cmp	r0, r3
   1cb86:	d303      	bcc.n	1cb90 <net_context_listen+0x14>
   1cb88:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1cb8c:	4298      	cmp	r0, r3
   1cb8e:	d30e      	bcc.n	1cbae <net_context_listen+0x32>
   1cb90:	4915      	ldr	r1, [pc, #84]	; (1cbe8 <net_context_listen+0x6c>)
   1cb92:	f240 331d 	movw	r3, #797	; 0x31d
   1cb96:	4a15      	ldr	r2, [pc, #84]	; (1cbec <net_context_listen+0x70>)
   1cb98:	4815      	ldr	r0, [pc, #84]	; (1cbf0 <net_context_listen+0x74>)
   1cb9a:	f016 fd15 	bl	335c8 <printk>
   1cb9e:	4815      	ldr	r0, [pc, #84]	; (1cbf4 <net_context_listen+0x78>)
   1cba0:	f016 fd12 	bl	335c8 <printk>
   1cba4:	f240 311d 	movw	r1, #797	; 0x31d
   1cba8:	4810      	ldr	r0, [pc, #64]	; (1cbec <net_context_listen+0x70>)
   1cbaa:	f017 f80e 	bl	33bca <assert_post_action>
	if (!net_context_is_used(context)) {
   1cbae:	4620      	mov	r0, r4
   1cbb0:	f7ff fd1c 	bl	1c5ec <net_context_is_used>
   1cbb4:	b198      	cbz	r0, 1cbde <net_context_listen+0x62>
	k_mutex_lock(&context->lock, K_FOREVER);
   1cbb6:	f104 0508 	add.w	r5, r4, #8
   1cbba:	4628      	mov	r0, r5
   1cbbc:	f018 fee7 	bl	3598e <k_mutex_lock.constprop.28>
	if (net_tcp_listen(context) >= 0) {
   1cbc0:	4620      	mov	r0, r4
   1cbc2:	f01a f9f1 	bl	36fa8 <net_tcp_listen>
   1cbc6:	2800      	cmp	r0, #0
		k_mutex_unlock(&context->lock);
   1cbc8:	4628      	mov	r0, r5
	if (net_tcp_listen(context) >= 0) {
   1cbca:	db03      	blt.n	1cbd4 <net_context_listen+0x58>
		k_mutex_unlock(&context->lock);
   1cbcc:	f018 fec2 	bl	35954 <k_mutex_unlock>
		return 0;
   1cbd0:	2000      	movs	r0, #0
}
   1cbd2:	bd38      	pop	{r3, r4, r5, pc}
	k_mutex_unlock(&context->lock);
   1cbd4:	f018 febe 	bl	35954 <k_mutex_unlock>
	return -EOPNOTSUPP;
   1cbd8:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   1cbdc:	e7f9      	b.n	1cbd2 <net_context_listen+0x56>
		return -EBADF;
   1cbde:	f06f 0008 	mvn.w	r0, #8
   1cbe2:	e7f6      	b.n	1cbd2 <net_context_listen+0x56>
   1cbe4:	200217f8 	.word	0x200217f8
   1cbe8:	0003da19 	.word	0x0003da19
   1cbec:	0003db97 	.word	0x0003db97
   1cbf0:	0003b77f 	.word	0x0003b77f
   1cbf4:	0003cb8b 	.word	0x0003cb8b

0001cbf8 <net_context_create_ipv4_new>:
{
   1cbf8:	b570      	push	{r4, r5, r6, lr}
   1cbfa:	460c      	mov	r4, r1
   1cbfc:	4605      	mov	r5, r0
   1cbfe:	461e      	mov	r6, r3
	if (!src) {
   1cc00:	4611      	mov	r1, r2
   1cc02:	b98a      	cbnz	r2, 1cc28 <net_context_create_ipv4_new+0x30>
		NET_ASSERT(((
   1cc04:	6a03      	ldr	r3, [r0, #32]
   1cc06:	b973      	cbnz	r3, 1cc26 <net_context_create_ipv4_new+0x2e>
   1cc08:	4914      	ldr	r1, [pc, #80]	; (1cc5c <net_context_create_ipv4_new+0x64>)
   1cc0a:	f240 333d 	movw	r3, #829	; 0x33d
   1cc0e:	4a14      	ldr	r2, [pc, #80]	; (1cc60 <net_context_create_ipv4_new+0x68>)
   1cc10:	4814      	ldr	r0, [pc, #80]	; (1cc64 <net_context_create_ipv4_new+0x6c>)
   1cc12:	f016 fcd9 	bl	335c8 <printk>
   1cc16:	4814      	ldr	r0, [pc, #80]	; (1cc68 <net_context_create_ipv4_new+0x70>)
   1cc18:	f016 fcd6 	bl	335c8 <printk>
   1cc1c:	f240 313d 	movw	r1, #829	; 0x33d
   1cc20:	480f      	ldr	r0, [pc, #60]	; (1cc60 <net_context_create_ipv4_new+0x68>)
   1cc22:	f016 ffd2 	bl	33bca <assert_post_action>
		src = ((struct sockaddr_in_ptr *)&context->local)->sin_addr;
   1cc26:	6a29      	ldr	r1, [r5, #32]
	return UNALIGNED_GET(&addr->s_addr) == 0;
   1cc28:	680b      	ldr	r3, [r1, #0]
	if (net_ipv4_is_addr_unspecified(src)
   1cc2a:	b11b      	cbz	r3, 1cc34 <net_context_create_ipv4_new+0x3c>
	    || net_ipv4_is_addr_mcast(src)) {
   1cc2c:	4608      	mov	r0, r1
   1cc2e:	f018 fe88 	bl	35942 <net_ipv4_is_addr_mcast>
   1cc32:	b130      	cbz	r0, 1cc42 <net_context_create_ipv4_new+0x4a>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
   1cc34:	4631      	mov	r1, r6
   1cc36:	6a20      	ldr	r0, [r4, #32]
   1cc38:	f7ff fb3a 	bl	1c2b0 <net_if_ipv4_select_src_addr>
   1cc3c:	6803      	ldr	r3, [r0, #0]
   1cc3e:	4601      	mov	r1, r0
		if (net_ipv4_is_addr_unspecified(src)) {
   1cc40:	b14b      	cbz	r3, 1cc56 <net_context_create_ipv4_new+0x5e>
	net_pkt_set_ipv4_ttl(pkt, net_context_get_ipv4_ttl(context));
   1cc42:	f895 307d 	ldrb.w	r3, [r5, #125]	; 0x7d
	return net_ipv4_create(pkt, src, dst);
   1cc46:	4632      	mov	r2, r6
	pkt->ipv4_ttl = ttl;
   1cc48:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   1cc4c:	4620      	mov	r0, r4
}
   1cc4e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_ipv4_create(pkt, src, dst);
   1cc52:	f019 bbd9 	b.w	36408 <net_ipv4_create>
}
   1cc56:	f06f 0015 	mvn.w	r0, #21
   1cc5a:	bd70      	pop	{r4, r5, r6, pc}
   1cc5c:	0003db60 	.word	0x0003db60
   1cc60:	0003db97 	.word	0x0003db97
   1cc64:	0003b77f 	.word	0x0003b77f
   1cc68:	0003cb8b 	.word	0x0003cb8b

0001cc6c <context_sendto.isra.21>:
static int context_sendto(struct net_context *context,
   1cc6c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1cc70:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
   1cc74:	4689      	mov	r9, r1
   1cc76:	e9dd 6a0c 	ldrd	r6, sl, [sp, #48]	; 0x30
   1cc7a:	4617      	mov	r7, r2
   1cc7c:	461d      	mov	r5, r3
   1cc7e:	f89d 803c 	ldrb.w	r8, [sp, #60]	; 0x3c
	NET_ASSERT(PART_OF_ARRAY(contexts, context));
   1cc82:	4604      	mov	r4, r0
   1cc84:	b130      	cbz	r0, 1cc94 <context_sendto.isra.21+0x28>
   1cc86:	4b79      	ldr	r3, [pc, #484]	; (1ce6c <context_sendto.isra.21+0x200>)
   1cc88:	4298      	cmp	r0, r3
   1cc8a:	d303      	bcc.n	1cc94 <context_sendto.isra.21+0x28>
   1cc8c:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1cc90:	4298      	cmp	r0, r3
   1cc92:	d30e      	bcc.n	1ccb2 <context_sendto.isra.21+0x46>
   1cc94:	4976      	ldr	r1, [pc, #472]	; (1ce70 <context_sendto.isra.21+0x204>)
   1cc96:	f240 534c 	movw	r3, #1356	; 0x54c
   1cc9a:	4a76      	ldr	r2, [pc, #472]	; (1ce74 <context_sendto.isra.21+0x208>)
   1cc9c:	4876      	ldr	r0, [pc, #472]	; (1ce78 <context_sendto.isra.21+0x20c>)
   1cc9e:	f016 fc93 	bl	335c8 <printk>
   1cca2:	4876      	ldr	r0, [pc, #472]	; (1ce7c <context_sendto.isra.21+0x210>)
   1cca4:	f016 fc90 	bl	335c8 <printk>
   1cca8:	f240 514c 	movw	r1, #1356	; 0x54c
   1ccac:	4871      	ldr	r0, [pc, #452]	; (1ce74 <context_sendto.isra.21+0x208>)
   1ccae:	f016 ff8c 	bl	33bca <assert_post_action>
	if (!net_context_is_used(context)) {
   1ccb2:	4620      	mov	r0, r4
   1ccb4:	f7ff fc9a 	bl	1c5ec <net_context_is_used>
   1ccb8:	2800      	cmp	r0, #0
   1ccba:	f000 80d0 	beq.w	1ce5e <context_sendto.isra.21+0x1f2>
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
   1ccbe:	f1b8 0f00 	cmp.w	r8, #0
   1ccc2:	d00b      	beq.n	1ccdc <context_sendto.isra.21+0x70>
   1ccc4:	b956      	cbnz	r6, 1ccdc <context_sendto.isra.21+0x70>
   1ccc6:	b95d      	cbnz	r5, 1cce0 <context_sendto.isra.21+0x74>
   1ccc8:	f1b9 0f00 	cmp.w	r9, #0
   1cccc:	f040 8093 	bne.w	1cdf6 <context_sendto.isra.21+0x18a>
		return -EDESTADDRREQ;
   1ccd0:	f06f 0578 	mvn.w	r5, #120	; 0x78
}
   1ccd4:	4628      	mov	r0, r5
   1ccd6:	b003      	add	sp, #12
   1ccd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (!msghdr && !dst_addr &&
   1ccdc:	2d00      	cmp	r5, #0
   1ccde:	d0f7      	beq.n	1ccd0 <context_sendto.isra.21+0x64>
   1cce0:	f04f 0800 	mov.w	r8, #0
		   net_context_get_family(context) == AF_INET) {
   1cce4:	4620      	mov	r0, r4
   1cce6:	f7ff fce7 	bl	1c6b8 <net_context_get_family>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1ccea:	2801      	cmp	r0, #1
   1ccec:	f040 8087 	bne.w	1cdfe <context_sendto.isra.21+0x192>
		if (msghdr) {
   1ccf0:	f1b8 0f00 	cmp.w	r8, #0
   1ccf4:	f000 8081 	beq.w	1cdfa <context_sendto.isra.21+0x18e>
			addrlen = msghdr->msg_namelen;
   1ccf8:	e9d8 5600 	ldrd	r5, r6, [r8]
			if (!addr4) {
   1ccfc:	2d00      	cmp	r5, #0
   1ccfe:	d17c      	bne.n	1cdfa <context_sendto.isra.21+0x18e>
				addr4 = net_sin(&context->remote);
   1cd00:	f104 0524 	add.w	r5, r4, #36	; 0x24
		if (!addr4->sin_addr.s_addr) {
   1cd04:	686b      	ldr	r3, [r5, #4]
   1cd06:	2b00      	cmp	r3, #0
   1cd08:	d0e2      	beq.n	1ccd0 <context_sendto.isra.21+0x64>
	if (msghdr && len == 0) {
   1cd0a:	f1b8 0f00 	cmp.w	r8, #0
   1cd0e:	d005      	beq.n	1cd1c <context_sendto.isra.21+0xb0>
   1cd10:	b927      	cbnz	r7, 1cd1c <context_sendto.isra.21+0xb0>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
   1cd12:	463b      	mov	r3, r7
   1cd14:	f8d8 100c 	ldr.w	r1, [r8, #12]
   1cd18:	428b      	cmp	r3, r1
   1cd1a:	d173      	bne.n	1ce04 <context_sendto.isra.21+0x198>
	NET_ASSERT(context);
   1cd1c:	b974      	cbnz	r4, 1cd3c <context_sendto.isra.21+0xd0>
   1cd1e:	4958      	ldr	r1, [pc, #352]	; (1ce80 <context_sendto.isra.21+0x214>)
   1cd20:	f240 2371 	movw	r3, #625	; 0x271
   1cd24:	4a57      	ldr	r2, [pc, #348]	; (1ce84 <context_sendto.isra.21+0x218>)
   1cd26:	4854      	ldr	r0, [pc, #336]	; (1ce78 <context_sendto.isra.21+0x20c>)
   1cd28:	f016 fc4e 	bl	335c8 <printk>
   1cd2c:	4853      	ldr	r0, [pc, #332]	; (1ce7c <context_sendto.isra.21+0x210>)
   1cd2e:	f016 fc4b 	bl	335c8 <printk>
   1cd32:	f240 2171 	movw	r1, #625	; 0x271
   1cd36:	4853      	ldr	r0, [pc, #332]	; (1ce84 <context_sendto.isra.21+0x218>)
   1cd38:	f016 ff47 	bl	33bca <assert_post_action>
	return net_if_get_by_index(context->iface);
   1cd3c:	f994 007c 	ldrsb.w	r0, [r4, #124]	; 0x7c
   1cd40:	f7ff fbaa 	bl	1c498 <net_if_get_by_index>
   1cd44:	4606      	mov	r6, r0
	pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context), len,
   1cd46:	4620      	mov	r0, r4
   1cd48:	f7ff fcb6 	bl	1c6b8 <net_context_get_family>
   1cd4c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   1cd50:	9300      	str	r3, [sp, #0]
   1cd52:	4602      	mov	r2, r0
   1cd54:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
   1cd58:	4630      	mov	r0, r6
   1cd5a:	4639      	mov	r1, r7
   1cd5c:	f000 fb1e 	bl	1d39c <net_pkt_alloc_with_buffer>
	if (pkt) {
   1cd60:	4606      	mov	r6, r0
   1cd62:	2800      	cmp	r0, #0
   1cd64:	d07e      	beq.n	1ce64 <context_sendto.isra.21+0x1f8>
	pkt->context = ctx;
   1cd66:	61c4      	str	r4, [r0, #28]
	tmp_len = net_pkt_available_payload_buffer(
   1cd68:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
   1cd6c:	f018 ffe6 	bl	35d3c <net_pkt_available_payload_buffer>
	    net_context_get_ip_proto(context) == IPPROTO_UDP) {
   1cd70:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1cd74:	4287      	cmp	r7, r0
   1cd76:	bf28      	it	cs
   1cd78:	4607      	movcs	r7, r0
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
   1cd7a:	2b11      	cmp	r3, #17
	context->send_cb = cb;
   1cd7c:	f8c4 a034 	str.w	sl, [r4, #52]	; 0x34
	context->user_data = user_data;
   1cd80:	f8c4 b000 	str.w	fp, [r4]
	} else if (IS_ENABLED(CONFIG_NET_UDP) &&
   1cd84:	d14c      	bne.n	1ce20 <context_sendto.isra.21+0x1b4>
		   net_context_get_family(context) == AF_INET) {
   1cd86:	4620      	mov	r0, r4
   1cd88:	f7ff fc96 	bl	1c6b8 <net_context_get_family>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1cd8c:	2801      	cmp	r0, #1
   1cd8e:	d160      	bne.n	1ce52 <context_sendto.isra.21+0x1e6>
		ret = net_context_create_ipv4_new(context, pkt,
   1cd90:	1d2b      	adds	r3, r5, #4
   1cd92:	2200      	movs	r2, #0
   1cd94:	4631      	mov	r1, r6
   1cd96:	4620      	mov	r0, r4
		dst_port = addr4->sin_port;
   1cd98:	f8b5 a002 	ldrh.w	sl, [r5, #2]
		ret = net_context_create_ipv4_new(context, pkt,
   1cd9c:	f7ff ff2c 	bl	1cbf8 <net_context_create_ipv4_new>
	if (ret < 0) {
   1cda0:	1e05      	subs	r5, r0, #0
   1cda2:	db39      	blt.n	1ce18 <context_sendto.isra.21+0x1ac>
	ret = bind_default(context);
   1cda4:	4620      	mov	r0, r4
   1cda6:	f018 fe27 	bl	359f8 <bind_default>
	if (ret) {
   1cdaa:	4605      	mov	r5, r0
   1cdac:	bb90      	cbnz	r0, 1ce14 <context_sendto.isra.21+0x1a8>
	ret = net_udp_create(pkt,
   1cdae:	4652      	mov	r2, sl
   1cdb0:	8be1      	ldrh	r1, [r4, #30]
   1cdb2:	4630      	mov	r0, r6
   1cdb4:	f01a f93b 	bl	3702e <net_udp_create>
	if (ret) {
   1cdb8:	4605      	mov	r5, r0
   1cdba:	bb58      	cbnz	r0, 1ce14 <context_sendto.isra.21+0x1a8>
	ret = context_write_data(pkt, buf, len, msg);
   1cdbc:	4643      	mov	r3, r8
   1cdbe:	463a      	mov	r2, r7
   1cdc0:	4649      	mov	r1, r9
   1cdc2:	4630      	mov	r0, r6
   1cdc4:	f018 fdc8 	bl	35958 <context_write_data>
	if (ret) {
   1cdc8:	4605      	mov	r5, r0
   1cdca:	bb18      	cbnz	r0, 1ce14 <context_sendto.isra.21+0x1a8>
	net_pkt_cursor_init(pkt);
   1cdcc:	4630      	mov	r0, r6
   1cdce:	f018 ffe7 	bl	35da0 <net_pkt_cursor_init>
		   net_context_get_family(context) == AF_INET) {
   1cdd2:	4620      	mov	r0, r4
   1cdd4:	f7ff fc70 	bl	1c6b8 <net_context_get_family>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1cdd8:	2801      	cmp	r0, #1
   1cdda:	d104      	bne.n	1cde6 <context_sendto.isra.21+0x17a>
		net_ipv4_finalize(pkt, net_context_get_ip_proto(context));
   1cddc:	f894 1078 	ldrb.w	r1, [r4, #120]	; 0x78
   1cde0:	4630      	mov	r0, r6
   1cde2:	f019 fb44 	bl	3646e <net_ipv4_finalize>
		ret = net_send_data(pkt);
   1cde6:	4630      	mov	r0, r6
   1cde8:	f018 fbc7 	bl	3557a <net_send_data>
	if (ret < 0) {
   1cdec:	2800      	cmp	r0, #0
		ret = net_tcp_send_data(context, cb, user_data);
   1cdee:	4605      	mov	r5, r0
	if (ret < 0) {
   1cdf0:	db12      	blt.n	1ce18 <context_sendto.isra.21+0x1ac>
	return len;
   1cdf2:	463d      	mov	r5, r7
   1cdf4:	e76e      	b.n	1ccd4 <context_sendto.isra.21+0x68>
	if (sendto && addrlen == 0 && dst_addr == NULL && buf != NULL) {
   1cdf6:	46c8      	mov	r8, r9
   1cdf8:	e774      	b.n	1cce4 <context_sendto.isra.21+0x78>
		if (addrlen < sizeof(struct sockaddr_in)) {
   1cdfa:	2e07      	cmp	r6, #7
   1cdfc:	d882      	bhi.n	1cd04 <context_sendto.isra.21+0x98>
		return -EINVAL;
   1cdfe:	f06f 0515 	mvn.w	r5, #21
   1ce02:	e767      	b.n	1ccd4 <context_sendto.isra.21+0x68>
			len += msghdr->msg_iov[i].iov_len;
   1ce04:	f8d8 2008 	ldr.w	r2, [r8, #8]
   1ce08:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   1ce0c:	6852      	ldr	r2, [r2, #4]
		for (i = 0; i < msghdr->msg_iovlen; i++) {
   1ce0e:	3301      	adds	r3, #1
			len += msghdr->msg_iov[i].iov_len;
   1ce10:	4417      	add	r7, r2
   1ce12:	e781      	b.n	1cd18 <context_sendto.isra.21+0xac>
		if (ret < 0) {
   1ce14:	2d00      	cmp	r5, #0
   1ce16:	dad9      	bge.n	1cdcc <context_sendto.isra.21+0x160>
	net_pkt_unref(pkt);
   1ce18:	4630      	mov	r0, r6
   1ce1a:	f018 ff5d 	bl	35cd8 <net_pkt_unref>
	return ret;
   1ce1e:	e759      	b.n	1ccd4 <context_sendto.isra.21+0x68>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   1ce20:	2b06      	cmp	r3, #6
   1ce22:	d119      	bne.n	1ce58 <context_sendto.isra.21+0x1ec>
		ret = context_write_data(pkt, buf, len, msghdr);
   1ce24:	4643      	mov	r3, r8
   1ce26:	463a      	mov	r2, r7
   1ce28:	4649      	mov	r1, r9
   1ce2a:	4630      	mov	r0, r6
   1ce2c:	f018 fd94 	bl	35958 <context_write_data>
		if (ret < 0) {
   1ce30:	1e05      	subs	r5, r0, #0
   1ce32:	dbf1      	blt.n	1ce18 <context_sendto.isra.21+0x1ac>
		net_pkt_cursor_init(pkt);
   1ce34:	4630      	mov	r0, r6
   1ce36:	f018 ffb3 	bl	35da0 <net_pkt_cursor_init>
		ret = net_tcp_queue_data(context, pkt);
   1ce3a:	4631      	mov	r1, r6
   1ce3c:	4620      	mov	r0, r4
   1ce3e:	f001 f869 	bl	1df14 <net_tcp_queue_data>
		if (ret < 0) {
   1ce42:	1e05      	subs	r5, r0, #0
   1ce44:	dbe8      	blt.n	1ce18 <context_sendto.isra.21+0x1ac>
		ret = net_tcp_send_data(context, cb, user_data);
   1ce46:	465a      	mov	r2, fp
   1ce48:	4651      	mov	r1, sl
   1ce4a:	4620      	mov	r0, r4
   1ce4c:	f019 fdc6 	bl	369dc <net_tcp_send_data>
   1ce50:	e7cc      	b.n	1cdec <context_sendto.isra.21+0x180>
	int ret = -EINVAL;
   1ce52:	f06f 0515 	mvn.w	r5, #21
   1ce56:	e7df      	b.n	1ce18 <context_sendto.isra.21+0x1ac>
		ret = -EPROTONOSUPPORT;
   1ce58:	f06f 057a 	mvn.w	r5, #122	; 0x7a
   1ce5c:	e7dc      	b.n	1ce18 <context_sendto.isra.21+0x1ac>
		return -EBADF;
   1ce5e:	f06f 0508 	mvn.w	r5, #8
   1ce62:	e737      	b.n	1ccd4 <context_sendto.isra.21+0x68>
		return -ENOMEM;
   1ce64:	f06f 050b 	mvn.w	r5, #11
   1ce68:	e734      	b.n	1ccd4 <context_sendto.isra.21+0x68>
   1ce6a:	bf00      	nop
   1ce6c:	200217f8 	.word	0x200217f8
   1ce70:	0003da19 	.word	0x0003da19
   1ce74:	0003db97 	.word	0x0003db97
   1ce78:	0003b77f 	.word	0x0003b77f
   1ce7c:	0003cb8b 	.word	0x0003cb8b
   1ce80:	0003cb83 	.word	0x0003cb83
   1ce84:	0003cb56 	.word	0x0003cb56

0001ce88 <net_context_connect>:
{
   1ce88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ce8c:	4604      	mov	r4, r0
   1ce8e:	b087      	sub	sp, #28
   1ce90:	4615      	mov	r5, r2
   1ce92:	461f      	mov	r7, r3
	NET_ASSERT(addr);
   1ce94:	460e      	mov	r6, r1
   1ce96:	b971      	cbnz	r1, 1ceb6 <net_context_connect+0x2e>
   1ce98:	495d      	ldr	r1, [pc, #372]	; (1d010 <net_context_connect+0x188>)
   1ce9a:	f240 3379 	movw	r3, #889	; 0x379
   1ce9e:	4a5d      	ldr	r2, [pc, #372]	; (1d014 <net_context_connect+0x18c>)
   1cea0:	485d      	ldr	r0, [pc, #372]	; (1d018 <net_context_connect+0x190>)
   1cea2:	f016 fb91 	bl	335c8 <printk>
   1cea6:	485d      	ldr	r0, [pc, #372]	; (1d01c <net_context_connect+0x194>)
   1cea8:	f016 fb8e 	bl	335c8 <printk>
   1ceac:	f240 3179 	movw	r1, #889	; 0x379
   1ceb0:	4858      	ldr	r0, [pc, #352]	; (1d014 <net_context_connect+0x18c>)
   1ceb2:	f016 fe8a 	bl	33bca <assert_post_action>
	NET_ASSERT(PART_OF_ARRAY(contexts, context));
   1ceb6:	b134      	cbz	r4, 1cec6 <net_context_connect+0x3e>
   1ceb8:	4b59      	ldr	r3, [pc, #356]	; (1d020 <net_context_connect+0x198>)
   1ceba:	429c      	cmp	r4, r3
   1cebc:	d303      	bcc.n	1cec6 <net_context_connect+0x3e>
   1cebe:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1cec2:	429c      	cmp	r4, r3
   1cec4:	d30e      	bcc.n	1cee4 <net_context_connect+0x5c>
   1cec6:	4957      	ldr	r1, [pc, #348]	; (1d024 <net_context_connect+0x19c>)
   1cec8:	f240 337a 	movw	r3, #890	; 0x37a
   1cecc:	4a51      	ldr	r2, [pc, #324]	; (1d014 <net_context_connect+0x18c>)
   1cece:	4852      	ldr	r0, [pc, #328]	; (1d018 <net_context_connect+0x190>)
   1ced0:	f016 fb7a 	bl	335c8 <printk>
   1ced4:	4851      	ldr	r0, [pc, #324]	; (1d01c <net_context_connect+0x194>)
   1ced6:	f016 fb77 	bl	335c8 <printk>
   1ceda:	f240 317a 	movw	r1, #890	; 0x37a
   1cede:	484d      	ldr	r0, [pc, #308]	; (1d014 <net_context_connect+0x18c>)
   1cee0:	f016 fe73 	bl	33bca <assert_post_action>
	k_mutex_lock(&context->lock, K_FOREVER);
   1cee4:	f104 0808 	add.w	r8, r4, #8
   1cee8:	4640      	mov	r0, r8
   1ceea:	f018 fd50 	bl	3598e <k_mutex_lock.constprop.28>
	if (!net_context_is_used(context)) {
   1ceee:	4620      	mov	r0, r4
   1cef0:	f7ff fb7c 	bl	1c5ec <net_context_is_used>
   1cef4:	2800      	cmp	r0, #0
   1cef6:	f000 8081 	beq.w	1cffc <net_context_connect+0x174>
	if (addr->sa_family != net_context_get_family(context)) {
   1cefa:	4620      	mov	r0, r4
   1cefc:	f8b6 9000 	ldrh.w	r9, [r6]
   1cf00:	f7ff fbda 	bl	1c6b8 <net_context_get_family>
   1cf04:	4581      	cmp	r9, r0
   1cf06:	d024      	beq.n	1cf52 <net_context_connect+0xca>
		NET_ASSERT(addr->sa_family == net_context_get_family(context),
   1cf08:	4620      	mov	r0, r4
   1cf0a:	8835      	ldrh	r5, [r6, #0]
   1cf0c:	f7ff fbd4 	bl	1c6b8 <net_context_get_family>
   1cf10:	4285      	cmp	r5, r0
   1cf12:	d108      	bne.n	1cf26 <net_context_connect+0x9e>
		ret = -EINVAL;
   1cf14:	f06f 0515 	mvn.w	r5, #21
	k_mutex_unlock(&context->lock);
   1cf18:	4640      	mov	r0, r8
   1cf1a:	f018 fd1b 	bl	35954 <k_mutex_unlock>
}
   1cf1e:	4628      	mov	r0, r5
   1cf20:	b007      	add	sp, #28
   1cf22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		NET_ASSERT(addr->sa_family == net_context_get_family(context),
   1cf26:	f240 3387 	movw	r3, #903	; 0x387
   1cf2a:	4a3a      	ldr	r2, [pc, #232]	; (1d014 <net_context_connect+0x18c>)
   1cf2c:	493e      	ldr	r1, [pc, #248]	; (1d028 <net_context_connect+0x1a0>)
   1cf2e:	483a      	ldr	r0, [pc, #232]	; (1d018 <net_context_connect+0x190>)
   1cf30:	f016 fb4a 	bl	335c8 <printk>
   1cf34:	4620      	mov	r0, r4
   1cf36:	8835      	ldrh	r5, [r6, #0]
   1cf38:	f7ff fbbe 	bl	1c6b8 <net_context_get_family>
   1cf3c:	4629      	mov	r1, r5
   1cf3e:	4602      	mov	r2, r0
   1cf40:	483a      	ldr	r0, [pc, #232]	; (1d02c <net_context_connect+0x1a4>)
   1cf42:	f016 fb41 	bl	335c8 <printk>
   1cf46:	f240 3187 	movw	r1, #903	; 0x387
   1cf4a:	4832      	ldr	r0, [pc, #200]	; (1d014 <net_context_connect+0x18c>)
   1cf4c:	f016 fe3d 	bl	33bca <assert_post_action>
   1cf50:	e7e0      	b.n	1cf14 <net_context_connect+0x8c>
	if (net_context_get_state(context) == NET_CONTEXT_LISTENING) {
   1cf52:	4620      	mov	r0, r4
   1cf54:	f7ff fb90 	bl	1c678 <net_context_get_state>
   1cf58:	2803      	cmp	r0, #3
   1cf5a:	d052      	beq.n	1d002 <net_context_connect+0x17a>
		   net_context_get_family(context) == AF_INET) {
   1cf5c:	4620      	mov	r0, r4
   1cf5e:	f7ff fbab 	bl	1c6b8 <net_context_get_family>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1cf62:	2801      	cmp	r0, #1
   1cf64:	d1d6      	bne.n	1cf14 <net_context_connect+0x8c>
		if (addrlen < sizeof(struct sockaddr_in)) {
   1cf66:	2d07      	cmp	r5, #7
   1cf68:	d9d4      	bls.n	1cf14 <net_context_connect+0x8c>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1cf6a:	6872      	ldr	r2, [r6, #4]
   1cf6c:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
   1cf70:	62a2      	str	r2, [r4, #40]	; 0x28
		addr4->sin_port = net_sin(addr)->sin_port;
   1cf72:	f8b6 9002 	ldrh.w	r9, [r6, #2]
		addr4->sin_family = AF_INET;
   1cf76:	84a0      	strh	r0, [r4, #36]	; 0x24
		addr4->sin_port = net_sin(addr)->sin_port;
   1cf78:	f8a4 9026 	strh.w	r9, [r4, #38]	; 0x26
		if (addr4->sin_addr.s_addr) {
   1cf7c:	b33a      	cbz	r2, 1cfce <net_context_connect+0x146>
			context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
   1cf7e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1cf82:	f8a4 307a 	strh.w	r3, [r4, #122]	; 0x7a
		ret = bind_default(context);
   1cf86:	4620      	mov	r0, r4
   1cf88:	f018 fd36 	bl	359f8 <bind_default>
		if (ret) {
   1cf8c:	4605      	mov	r5, r0
   1cf8e:	2800      	cmp	r0, #0
   1cf90:	d1c2      	bne.n	1cf18 <net_context_connect+0x90>
		net_sin_ptr(&context->local)->sin_family = AF_INET;
   1cf92:	2301      	movs	r3, #1
		net_sin(&local_addr)->sin_port = lport =
   1cf94:	f8b4 b01e 	ldrh.w	fp, [r4, #30]
		if (net_sin_ptr(&context->local)->sin_addr) {
   1cf98:	f8d4 a020 	ldr.w	sl, [r4, #32]
		net_sin_ptr(&context->local)->sin_family = AF_INET;
   1cf9c:	83a3      	strh	r3, [r4, #28]
		net_sin(&local_addr)->sin_family = AF_INET;
   1cf9e:	f8ad 3010 	strh.w	r3, [sp, #16]
		net_sin(&local_addr)->sin_port = lport =
   1cfa2:	f8ad b012 	strh.w	fp, [sp, #18]
		if (net_sin_ptr(&context->local)->sin_addr) {
   1cfa6:	f1ba 0f00 	cmp.w	sl, #0
   1cfaa:	d004      	beq.n	1cfb6 <net_context_connect+0x12e>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
   1cfac:	f8da 3000 	ldr.w	r3, [sl]
   1cfb0:	9305      	str	r3, [sp, #20]
			laddr = &local_addr;
   1cfb2:	f10d 0a10 	add.w	sl, sp, #16
	    net_context_get_type(context) == SOCK_DGRAM) {
   1cfb6:	4620      	mov	r0, r4
   1cfb8:	f7ff fb9e 	bl	1c6f8 <net_context_get_type>
	if (IS_ENABLED(CONFIG_NET_UDP) &&
   1cfbc:	2802      	cmp	r0, #2
   1cfbe:	d10a      	bne.n	1cfd6 <net_context_connect+0x14e>
		if (cb) {
   1cfc0:	2f00      	cmp	r7, #0
   1cfc2:	d0a9      	beq.n	1cf18 <net_context_connect+0x90>
			cb(context, 0, user_data);
   1cfc4:	9a11      	ldr	r2, [sp, #68]	; 0x44
   1cfc6:	2100      	movs	r1, #0
   1cfc8:	4620      	mov	r0, r4
   1cfca:	47b8      	blx	r7
   1cfcc:	e7a4      	b.n	1cf18 <net_context_connect+0x90>
			context->flags &= ~NET_CONTEXT_REMOTE_ADDR_SET;
   1cfce:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1cfd2:	b29b      	uxth	r3, r3
   1cfd4:	e7d5      	b.n	1cf82 <net_context_connect+0xfa>
		   net_context_get_type(context) == SOCK_STREAM) {
   1cfd6:	4620      	mov	r0, r4
   1cfd8:	f7ff fb8e 	bl	1c6f8 <net_context_get_type>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   1cfdc:	2801      	cmp	r0, #1
   1cfde:	d113      	bne.n	1d008 <net_context_connect+0x180>
		ret = net_tcp_connect(context, addr, laddr, rport, lport,
   1cfe0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   1cfe2:	4652      	mov	r2, sl
   1cfe4:	e9cd 7302 	strd	r7, r3, [sp, #8]
   1cfe8:	9b10      	ldr	r3, [sp, #64]	; 0x40
   1cfea:	4631      	mov	r1, r6
   1cfec:	e9cd b300 	strd	fp, r3, [sp]
   1cff0:	4620      	mov	r0, r4
   1cff2:	464b      	mov	r3, r9
   1cff4:	f001 fcd6 	bl	1e9a4 <net_tcp_connect>
   1cff8:	4605      	mov	r5, r0
   1cffa:	e78d      	b.n	1cf18 <net_context_connect+0x90>
		ret = -EBADF;
   1cffc:	f06f 0508 	mvn.w	r5, #8
   1d000:	e78a      	b.n	1cf18 <net_context_connect+0x90>
		ret = -EOPNOTSUPP;
   1d002:	f06f 055e 	mvn.w	r5, #94	; 0x5e
   1d006:	e787      	b.n	1cf18 <net_context_connect+0x90>
		ret = -ENOTSUP;
   1d008:	f06f 0585 	mvn.w	r5, #133	; 0x85
   1d00c:	e784      	b.n	1cf18 <net_context_connect+0x90>
   1d00e:	bf00      	nop
   1d010:	0003db92 	.word	0x0003db92
   1d014:	0003db97 	.word	0x0003db97
   1d018:	0003b77f 	.word	0x0003b77f
   1d01c:	0003cb8b 	.word	0x0003cb8b
   1d020:	200217f8 	.word	0x200217f8
   1d024:	0003da19 	.word	0x0003da19
   1d028:	0003db0b 	.word	0x0003db0b
   1d02c:	0003db3e 	.word	0x0003db3e

0001d030 <net_context_accept>:
{
   1d030:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1d032:	460e      	mov	r6, r1
   1d034:	461f      	mov	r7, r3
	NET_ASSERT(PART_OF_ARRAY(contexts, context));
   1d036:	4604      	mov	r4, r0
   1d038:	b130      	cbz	r0, 1d048 <net_context_accept+0x18>
   1d03a:	4b20      	ldr	r3, [pc, #128]	; (1d0bc <net_context_accept+0x8c>)
   1d03c:	4298      	cmp	r0, r3
   1d03e:	d303      	bcc.n	1d048 <net_context_accept+0x18>
   1d040:	f503 7340 	add.w	r3, r3, #768	; 0x300
   1d044:	4298      	cmp	r0, r3
   1d046:	d30e      	bcc.n	1d066 <net_context_accept+0x36>
   1d048:	491d      	ldr	r1, [pc, #116]	; (1d0c0 <net_context_accept+0x90>)
   1d04a:	f240 4325 	movw	r3, #1061	; 0x425
   1d04e:	4a1d      	ldr	r2, [pc, #116]	; (1d0c4 <net_context_accept+0x94>)
   1d050:	481d      	ldr	r0, [pc, #116]	; (1d0c8 <net_context_accept+0x98>)
   1d052:	f016 fab9 	bl	335c8 <printk>
   1d056:	481d      	ldr	r0, [pc, #116]	; (1d0cc <net_context_accept+0x9c>)
   1d058:	f016 fab6 	bl	335c8 <printk>
   1d05c:	f240 4125 	movw	r1, #1061	; 0x425
   1d060:	4818      	ldr	r0, [pc, #96]	; (1d0c4 <net_context_accept+0x94>)
   1d062:	f016 fdb2 	bl	33bca <assert_post_action>
	if (!net_context_is_used(context)) {
   1d066:	4620      	mov	r0, r4
   1d068:	f7ff fac0 	bl	1c5ec <net_context_is_used>
   1d06c:	b310      	cbz	r0, 1d0b4 <net_context_accept+0x84>
	k_mutex_lock(&context->lock, K_FOREVER);
   1d06e:	f104 0508 	add.w	r5, r4, #8
   1d072:	4628      	mov	r0, r5
   1d074:	f018 fc8b 	bl	3598e <k_mutex_lock.constprop.28>
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
   1d078:	4620      	mov	r0, r4
   1d07a:	f7ff fafd 	bl	1c678 <net_context_get_state>
   1d07e:	2803      	cmp	r0, #3
   1d080:	d109      	bne.n	1d096 <net_context_accept+0x66>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   1d082:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1d086:	2b06      	cmp	r3, #6
   1d088:	d00d      	beq.n	1d0a6 <net_context_accept+0x76>
	int ret = 0;
   1d08a:	2400      	movs	r4, #0
	k_mutex_unlock(&context->lock);
   1d08c:	4628      	mov	r0, r5
   1d08e:	f018 fc61 	bl	35954 <k_mutex_unlock>
}
   1d092:	4620      	mov	r0, r4
   1d094:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    (net_context_get_type(context) != SOCK_STREAM)) {
   1d096:	4620      	mov	r0, r4
   1d098:	f7ff fb2e 	bl	1c6f8 <net_context_get_type>
	if ((net_context_get_state(context) != NET_CONTEXT_LISTENING) &&
   1d09c:	2801      	cmp	r0, #1
   1d09e:	d0f0      	beq.n	1d082 <net_context_accept+0x52>
		ret = -EINVAL;
   1d0a0:	f06f 0415 	mvn.w	r4, #21
   1d0a4:	e7f2      	b.n	1d08c <net_context_accept+0x5c>
		ret = net_tcp_accept(context, cb, user_data);
   1d0a6:	4620      	mov	r0, r4
   1d0a8:	463a      	mov	r2, r7
   1d0aa:	4631      	mov	r1, r6
   1d0ac:	f001 fc00 	bl	1e8b0 <net_tcp_accept>
   1d0b0:	4604      	mov	r4, r0
		goto unlock;
   1d0b2:	e7eb      	b.n	1d08c <net_context_accept+0x5c>
		return -EBADF;
   1d0b4:	f06f 0408 	mvn.w	r4, #8
   1d0b8:	e7eb      	b.n	1d092 <net_context_accept+0x62>
   1d0ba:	bf00      	nop
   1d0bc:	200217f8 	.word	0x200217f8
   1d0c0:	0003da19 	.word	0x0003da19
   1d0c4:	0003db97 	.word	0x0003db97
   1d0c8:	0003b77f 	.word	0x0003b77f
   1d0cc:	0003cb8b 	.word	0x0003cb8b

0001d0d0 <net_context_recv>:

int net_context_recv(struct net_context *context,
		     net_context_recv_cb_t cb,
		     k_timeout_t timeout,
		     void *user_data)
{
   1d0d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1d0d4:	4688      	mov	r8, r1
   1d0d6:	b088      	sub	sp, #32
   1d0d8:	4617      	mov	r7, r2
   1d0da:	4699      	mov	r9, r3
	int ret;
	NET_ASSERT(context);
   1d0dc:	4604      	mov	r4, r0
   1d0de:	b970      	cbnz	r0, 1d0fe <net_context_recv+0x2e>
   1d0e0:	4944      	ldr	r1, [pc, #272]	; (1d1f4 <net_context_recv+0x124>)
   1d0e2:	f240 7365 	movw	r3, #1893	; 0x765
   1d0e6:	4a44      	ldr	r2, [pc, #272]	; (1d1f8 <net_context_recv+0x128>)
   1d0e8:	4844      	ldr	r0, [pc, #272]	; (1d1fc <net_context_recv+0x12c>)
   1d0ea:	f016 fa6d 	bl	335c8 <printk>
   1d0ee:	4844      	ldr	r0, [pc, #272]	; (1d200 <net_context_recv+0x130>)
   1d0f0:	f016 fa6a 	bl	335c8 <printk>
   1d0f4:	f240 7165 	movw	r1, #1893	; 0x765
   1d0f8:	483f      	ldr	r0, [pc, #252]	; (1d1f8 <net_context_recv+0x128>)
   1d0fa:	f016 fd66 	bl	33bca <assert_post_action>

	if (!net_context_is_used(context)) {
   1d0fe:	4620      	mov	r0, r4
   1d100:	f7ff fa74 	bl	1c5ec <net_context_is_used>
   1d104:	2800      	cmp	r0, #0
   1d106:	d071      	beq.n	1d1ec <net_context_recv+0x11c>
		return -EBADF;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
   1d108:	f104 0608 	add.w	r6, r4, #8
   1d10c:	4630      	mov	r0, r6
   1d10e:	f018 fc3e 	bl	3598e <k_mutex_lock.constprop.28>
			context, cb, timeout, user_data);
		goto unlock;
	}

	if (IS_ENABLED(CONFIG_NET_UDP) &&
	    net_context_get_ip_proto(context) == IPPROTO_UDP) {
   1d112:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
	if (IS_ENABLED(CONFIG_NET_UDP) &&
   1d116:	2b11      	cmp	r3, #17
   1d118:	d15d      	bne.n	1d1d6 <net_context_recv+0x106>
	struct sockaddr local_addr = {
   1d11a:	2500      	movs	r5, #0
		.sa_family = net_context_get_family(context),
   1d11c:	4620      	mov	r0, r4
	struct sockaddr local_addr = {
   1d11e:	e9cd 5506 	strd	r5, r5, [sp, #24]
		.sa_family = net_context_get_family(context),
   1d122:	f7ff fac9 	bl	1c6b8 <net_context_get_family>
	struct sockaddr local_addr = {
   1d126:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (context->conn_handler) {
   1d12a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   1d12c:	b110      	cbz	r0, 1d134 <net_context_recv+0x64>
		net_conn_unregister(context->conn_handler);
   1d12e:	f000 fab5 	bl	1d69c <net_conn_unregister>
		context->conn_handler = NULL;
   1d132:	62e5      	str	r5, [r4, #44]	; 0x2c
	ret = bind_default(context);
   1d134:	4620      	mov	r0, r4
   1d136:	f018 fc5f 	bl	359f8 <bind_default>
	if (ret) {
   1d13a:	4605      	mov	r5, r0
   1d13c:	bb90      	cbnz	r0, 1d1a4 <net_context_recv+0xd4>
		   net_context_get_family(context) == AF_INET) {
   1d13e:	4620      	mov	r0, r4
   1d140:	f7ff faba 	bl	1c6b8 <net_context_get_family>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d144:	2801      	cmp	r0, #1
   1d146:	d144      	bne.n	1d1d2 <net_context_recv+0x102>
		if (net_sin_ptr(&context->local)->sin_addr) {
   1d148:	f8d4 a020 	ldr.w	sl, [r4, #32]
   1d14c:	f1ba 0f00 	cmp.w	sl, #0
   1d150:	d004      	beq.n	1d15c <net_context_recv+0x8c>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
   1d152:	f8da 3000 	ldr.w	r3, [sl]
   1d156:	9307      	str	r3, [sp, #28]
			laddr = &local_addr;
   1d158:	f10d 0a18 	add.w	sl, sp, #24
		lport = net_sin((struct sockaddr *)&context->local)->sin_port;
   1d15c:	8be5      	ldrh	r5, [r4, #30]
	context->recv_cb = cb;
   1d15e:	f8c4 8030 	str.w	r8, [r4, #48]	; 0x30
				net_context_get_family(context),
   1d162:	4620      	mov	r0, r4
	ret = net_conn_register(net_context_get_ip_proto(context),
   1d164:	f8b4 8078 	ldrh.w	r8, [r4, #120]	; 0x78
				net_context_get_family(context),
   1d168:	f7ff faa6 	bl	1c6b8 <net_context_get_family>
	ret = net_conn_register(net_context_get_ip_proto(context),
   1d16c:	f104 032c 	add.w	r3, r4, #44	; 0x2c
   1d170:	f8b4 207a 	ldrh.w	r2, [r4, #122]	; 0x7a
   1d174:	b2c1      	uxtb	r1, r0
				ntohs(net_sin(&context->remote)->sin_port),
   1d176:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
	ret = net_conn_register(net_context_get_ip_proto(context),
   1d178:	e9cd 9303 	strd	r9, r3, [sp, #12]
   1d17c:	4b21      	ldr	r3, [pc, #132]	; (1d204 <net_context_recv+0x134>)
   1d17e:	ba6d      	rev16	r5, r5
   1d180:	9302      	str	r3, [sp, #8]
				ntohs(net_sin(&context->remote)->sin_port),
   1d182:	0203      	lsls	r3, r0, #8
   1d184:	ea43 2310 	orr.w	r3, r3, r0, lsr #8
	ret = net_conn_register(net_context_get_ip_proto(context),
   1d188:	b29b      	uxth	r3, r3
   1d18a:	f412 7280 	ands.w	r2, r2, #256	; 0x100
   1d18e:	b2ad      	uxth	r5, r5
   1d190:	9300      	str	r3, [sp, #0]
   1d192:	bf18      	it	ne
   1d194:	f104 0224 	addne.w	r2, r4, #36	; 0x24
   1d198:	9501      	str	r5, [sp, #4]
   1d19a:	4653      	mov	r3, sl
   1d19c:	4640      	mov	r0, r8
   1d19e:	f000 f9bb 	bl	1d518 <net_conn_register>
		ret = recv_udp(context, cb, timeout, user_data);
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
		   net_context_get_ip_proto(context) == IPPROTO_TCP) {
		ret = net_tcp_recv(context, cb, user_data);
   1d1a2:	4605      	mov	r5, r0
		} else {
			ret = -EPROTOTYPE;
		}
	}

	if (ret < 0) {
   1d1a4:	2d00      	cmp	r5, #0
   1d1a6:	db0d      	blt.n	1d1c4 <net_context_recv+0xf4>
		goto unlock;
	}

#if defined(CONFIG_NET_CONTEXT_SYNC_RECV)
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   1d1a8:	b167      	cbz	r7, 1d1c4 <net_context_recv+0xf4>
	sem->count = 0U;
   1d1aa:	2300      	movs	r3, #0
		 * net_context_packet_received() callback will release the
		 * semaphore when data has been received.
		 */
		k_sem_reset(&context->recv_data_wait);

		k_mutex_unlock(&context->lock);
   1d1ac:	4630      	mov	r0, r6
   1d1ae:	64a3      	str	r3, [r4, #72]	; 0x48
   1d1b0:	f018 fbd0 	bl	35954 <k_mutex_unlock>
	return z_impl_k_sem_take(sem, timeout);
   1d1b4:	4639      	mov	r1, r7
   1d1b6:	f104 0040 	add.w	r0, r4, #64	; 0x40
   1d1ba:	f010 ff5b 	bl	2e074 <z_impl_k_sem_take>

		ret = k_sem_take(&context->recv_data_wait, timeout);

		k_mutex_lock(&context->lock, K_FOREVER);
   1d1be:	4630      	mov	r0, r6
   1d1c0:	f018 fbe5 	bl	3598e <k_mutex_lock.constprop.28>
		}
	}
#endif /* CONFIG_NET_CONTEXT_SYNC_RECV */

unlock:
	k_mutex_unlock(&context->lock);
   1d1c4:	4630      	mov	r0, r6
   1d1c6:	f018 fbc5 	bl	35954 <k_mutex_unlock>

	return ret;
}
   1d1ca:	4628      	mov	r0, r5
   1d1cc:	b008      	add	sp, #32
   1d1ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	struct sockaddr *laddr = NULL;
   1d1d2:	46aa      	mov	sl, r5
   1d1d4:	e7c3      	b.n	1d15e <net_context_recv+0x8e>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   1d1d6:	2b06      	cmp	r3, #6
   1d1d8:	d105      	bne.n	1d1e6 <net_context_recv+0x116>
		ret = net_tcp_recv(context, cb, user_data);
   1d1da:	464a      	mov	r2, r9
   1d1dc:	4641      	mov	r1, r8
   1d1de:	4620      	mov	r0, r4
   1d1e0:	f001 fae0 	bl	1e7a4 <net_tcp_recv>
   1d1e4:	e7dd      	b.n	1d1a2 <net_context_recv+0xd2>
			ret = -EPROTOTYPE;
   1d1e6:	f06f 056a 	mvn.w	r5, #106	; 0x6a
   1d1ea:	e7eb      	b.n	1d1c4 <net_context_recv+0xf4>
		return -EBADF;
   1d1ec:	f06f 0508 	mvn.w	r5, #8
   1d1f0:	e7eb      	b.n	1d1ca <net_context_recv+0xfa>
   1d1f2:	bf00      	nop
   1d1f4:	0003cb83 	.word	0x0003cb83
   1d1f8:	0003db97 	.word	0x0003db97
   1d1fc:	0003b77f 	.word	0x0003b77f
   1d200:	0003cb8b 	.word	0x0003cb8b
   1d204:	0001c7a5 	.word	0x0001c7a5

0001d208 <net_context_init>:
	return z_impl_k_sem_init(sem, initial_count, limit);
   1d208:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1d20c:	2101      	movs	r1, #1
   1d20e:	4801      	ldr	r0, [pc, #4]	; (1d214 <net_context_init+0xc>)
   1d210:	f01b bd87 	b.w	38d22 <z_impl_k_sem_init>
   1d214:	20021af8 	.word	0x20021af8

0001d218 <net_pkt_alloc_buffer>:
int net_pkt_alloc_buffer(struct net_pkt *pkt,
			 size_t size,
			 enum net_ip_protocol proto,
			 k_timeout_t timeout)
#endif
{
   1d218:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1d21c:	4607      	mov	r7, r0
   1d21e:	b085      	sub	sp, #20
	u64_t end = z_timeout_end_calc(timeout);
   1d220:	4618      	mov	r0, r3
{
   1d222:	460e      	mov	r6, r1
   1d224:	4690      	mov	r8, r2
   1d226:	461c      	mov	r4, r3
	u64_t end = z_timeout_end_calc(timeout);
   1d228:	f01b fe0a 	bl	38e40 <z_timeout_end_calc>
   1d22c:	4681      	mov	r9, r0
   1d22e:	468a      	mov	sl, r1
	struct net_buf_pool *pool = NULL;
	size_t alloc_len = 0;
	size_t hdr_len = 0;
	struct net_buf *buf;

	if (!size && proto == 0 && net_pkt_family(pkt) == AF_UNSPEC) {
   1d230:	b946      	cbnz	r6, 1d244 <net_pkt_alloc_buffer+0x2c>
   1d232:	f1b8 0f00 	cmp.w	r8, #0
   1d236:	d105      	bne.n	1d244 <net_pkt_alloc_buffer+0x2c>
	return pkt->family;
   1d238:	f897 003f 	ldrb.w	r0, [r7, #63]	; 0x3f
   1d23c:	f3c0 0042 	ubfx	r0, r0, #1, #3
   1d240:	2800      	cmp	r0, #0
   1d242:	d074      	beq.n	1d32e <net_pkt_alloc_buffer+0x116>
		return 0;
	}

	if (k_is_in_isr()) {
   1d244:	f01b fd7d 	bl	38d42 <k_is_in_isr>
		timeout = K_NO_WAIT;
   1d248:	2800      	cmp	r0, #0
	}

	/* Verifying existing buffer and take into account free space there */
	alloc_len = pkt_get_size(pkt) - net_pkt_get_len(pkt);
   1d24a:	6938      	ldr	r0, [r7, #16]
		timeout = K_NO_WAIT;
   1d24c:	bf18      	it	ne
   1d24e:	2400      	movne	r4, #0
	struct net_buf *buf = pkt->buffer;
   1d250:	4605      	mov	r5, r0
	size_t size = 0;
   1d252:	f04f 0b00 	mov.w	fp, #0
	while (buf) {
   1d256:	2d00      	cmp	r5, #0
   1d258:	d156      	bne.n	1d308 <net_pkt_alloc_buffer+0xf0>
	return net_buf_frags_len(pkt->frags);
   1d25a:	f018 fc6a 	bl	35b32 <net_buf_frags_len>
   1d25e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
	if (!alloc_len) {
   1d262:	4558      	cmp	r0, fp
   1d264:	4603      	mov	r3, r0
   1d266:	f3c2 0242 	ubfx	r2, r2, #1, #3
   1d26a:	d151      	bne.n	1d310 <net_pkt_alloc_buffer+0xf8>
		/* In case of no free space, it will account for header
		 * space estimation
		 */
		hdr_len = pkt_estimate_headers_length(pkt,
   1d26c:	b290      	uxth	r0, r2
	if (family == AF_UNSPEC) {
   1d26e:	2800      	cmp	r0, #0
   1d270:	d04e      	beq.n	1d310 <net_pkt_alloc_buffer+0xf8>
   1d272:	4641      	mov	r1, r8
   1d274:	f018 fca5 	bl	35bc2 <pkt_estimate_headers_length.isra.19.part.20>
	if (net_pkt_iface(pkt)) {
   1d278:	6a39      	ldr	r1, [r7, #32]
						      net_pkt_family(pkt),
						      proto);
	}

	/* Calculate the maximum that can be allocated depending on size */
	alloc_len = pkt_buffer_length(pkt, size + hdr_len, proto, alloc_len);
   1d27a:	4406      	add	r6, r0
	if (net_pkt_iface(pkt)) {
   1d27c:	b109      	cbz	r1, 1d282 <net_pkt_alloc_buffer+0x6a>
 *
 * @return the MTU
 */
static inline u16_t net_if_get_mtu(struct net_if *iface)
{
	return iface->if_dev->mtu;
   1d27e:	6809      	ldr	r1, [r1, #0]
		max_len = net_if_get_mtu(net_pkt_iface(pkt));
   1d280:	8b09      	ldrh	r1, [r1, #24]
	} else if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1d282:	2a01      	cmp	r2, #1
   1d284:	d146      	bne.n	1d314 <net_pkt_alloc_buffer+0xfc>
		max_len = MAX(max_len, NET_IPV4_MTU);
   1d286:	f5b1 7f10 	cmp.w	r1, #576	; 0x240
   1d28a:	bf38      	it	cc
   1d28c:	f44f 7110 	movcc.w	r1, #576	; 0x240
	max_len -= existing;
   1d290:	eba3 030b 	sub.w	r3, r3, fp
   1d294:	4419      	add	r1, r3
	return MIN(size, max_len);
   1d296:	428e      	cmp	r6, r1
   1d298:	bf28      	it	cs
   1d29a:	460e      	movcs	r6, r1
	if (pkt->context) {
		pool = get_data_pool(pkt->context);
	}

	if (!pool) {
		pool = pkt->slab == &tx_pkts ? &tx_bufs : &rx_bufs;
   1d29c:	4b3c      	ldr	r3, [pc, #240]	; (1d390 <net_pkt_alloc_buffer+0x178>)
   1d29e:	68f9      	ldr	r1, [r7, #12]
   1d2a0:	483c      	ldr	r0, [pc, #240]	; (1d394 <net_pkt_alloc_buffer+0x17c>)
   1d2a2:	4a3d      	ldr	r2, [pc, #244]	; (1d398 <net_pkt_alloc_buffer+0x180>)
   1d2a4:	4281      	cmp	r1, r0
   1d2a6:	bf0c      	ite	eq
   1d2a8:	4690      	moveq	r8, r2
   1d2aa:	4698      	movne	r8, r3
	}

	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1d2ac:	1c63      	adds	r3, r4, #1
   1d2ae:	2b01      	cmp	r3, #1
   1d2b0:	d91a      	bls.n	1d2e8 <net_pkt_alloc_buffer+0xd0>
	    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
		s64_t remaining = end - z_tick_get();
   1d2b2:	f011 fd23 	bl	2ecfc <z_tick_get>
   1d2b6:	ebb9 0300 	subs.w	r3, r9, r0
   1d2ba:	9300      	str	r3, [sp, #0]
   1d2bc:	eb6a 0301 	sbc.w	r3, sl, r1
   1d2c0:	9301      	str	r3, [sp, #4]

		if (remaining <= 0) {
   1d2c2:	e9dd 3400 	ldrd	r3, r4, [sp]
   1d2c6:	2b01      	cmp	r3, #1
   1d2c8:	f174 0300 	sbcs.w	r3, r4, #0
   1d2cc:	bfa3      	ittte	ge
   1d2ce:	f647 72ff 	movwge	r2, #32767	; 0x7fff
   1d2d2:	2300      	movge	r3, #0
   1d2d4:	f44f 717a 	movge.w	r1, #1000	; 0x3e8
			timeout = K_NO_WAIT;
   1d2d8:	2400      	movlt	r4, #0
   1d2da:	bfa1      	itttt	ge
   1d2dc:	9800      	ldrge	r0, [sp, #0]
   1d2de:	fbe1 2300 	umlalge	r2, r3, r1, r0
   1d2e2:	0bd4      	lsrge	r4, r2, #15
   1d2e4:	ea44 4443 	orrge.w	r4, r4, r3, lsl #17
	u64_t end = z_timeout_end_calc(timeout);
   1d2e8:	4620      	mov	r0, r4
   1d2ea:	f01b fda9 	bl	38e40 <z_timeout_end_calc>
   1d2ee:	f44f 7a7a 	mov.w	sl, #1000	; 0x3e8
   1d2f2:	4681      	mov	r9, r0
   1d2f4:	468b      	mov	fp, r1
	struct net_buf *current = NULL;
   1d2f6:	2200      	movs	r2, #0
	while (size) {
   1d2f8:	b976      	cbnz	r6, 1d318 <net_pkt_alloc_buffer+0x100>
	buf = pkt_alloc_buffer(pool, alloc_len, timeout, caller, line);
#else
	buf = pkt_alloc_buffer(pool, alloc_len, timeout);
#endif

	if (!buf) {
   1d2fa:	b1b5      	cbz	r5, 1d32a <net_pkt_alloc_buffer+0x112>
		NET_ERR("Data buffer (%zd) allocation failed.", alloc_len);
#endif
		return -ENOMEM;
	}

	net_pkt_append_buffer(pkt, buf);
   1d2fc:	4638      	mov	r0, r7
   1d2fe:	4629      	mov	r1, r5
   1d300:	f018 fd83 	bl	35e0a <net_pkt_append_buffer>

	return 0;
   1d304:	2000      	movs	r0, #0
   1d306:	e012      	b.n	1d32e <net_pkt_alloc_buffer+0x116>
		size += buf->size;
   1d308:	89eb      	ldrh	r3, [r5, #14]
		buf = buf->frags;
   1d30a:	682d      	ldr	r5, [r5, #0]
		size += buf->size;
   1d30c:	449b      	add	fp, r3
		buf = buf->frags;
   1d30e:	e7a2      	b.n	1d256 <net_pkt_alloc_buffer+0x3e>
	size_t hdr_len = 0;
   1d310:	4628      	mov	r0, r5
   1d312:	e7b1      	b.n	1d278 <net_pkt_alloc_buffer+0x60>
			max_len = size;
   1d314:	4631      	mov	r1, r6
   1d316:	e7bb      	b.n	1d290 <net_pkt_alloc_buffer+0x78>
		new = net_buf_alloc_fixed(pool, timeout);
   1d318:	4621      	mov	r1, r4
   1d31a:	4640      	mov	r0, r8
   1d31c:	9200      	str	r2, [sp, #0]
   1d31e:	f018 f8e8 	bl	354f2 <net_buf_alloc_fixed>
		if (!new) {
   1d322:	9a00      	ldr	r2, [sp, #0]
   1d324:	4603      	mov	r3, r0
   1d326:	b928      	cbnz	r0, 1d334 <net_pkt_alloc_buffer+0x11c>
	if (first) {
   1d328:	bb6d      	cbnz	r5, 1d386 <net_pkt_alloc_buffer+0x16e>
		return -ENOMEM;
   1d32a:	f06f 000b 	mvn.w	r0, #11
}
   1d32e:	b005      	add	sp, #20
   1d330:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!first && !current) {
   1d334:	b905      	cbnz	r5, 1d338 <net_pkt_alloc_buffer+0x120>
   1d336:	b322      	cbz	r2, 1d382 <net_pkt_alloc_buffer+0x16a>
			current->frags = new;
   1d338:	6013      	str	r3, [r2, #0]
		if (current->size > size) {
   1d33a:	89da      	ldrh	r2, [r3, #14]
   1d33c:	42b2      	cmp	r2, r6
			current->size = size;
   1d33e:	bf88      	it	hi
   1d340:	81de      	strhhi	r6, [r3, #14]
		size -= current->size;
   1d342:	89da      	ldrh	r2, [r3, #14]
   1d344:	1ab6      	subs	r6, r6, r2
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1d346:	1c62      	adds	r2, r4, #1
   1d348:	2a01      	cmp	r2, #1
   1d34a:	d918      	bls.n	1d37e <net_pkt_alloc_buffer+0x166>
   1d34c:	9300      	str	r3, [sp, #0]
			s64_t remaining = end - z_tick_get();
   1d34e:	f011 fcd5 	bl	2ecfc <z_tick_get>
   1d352:	ebb9 0300 	subs.w	r3, r9, r0
   1d356:	9302      	str	r3, [sp, #8]
   1d358:	eb6b 0301 	sbc.w	r3, fp, r1
   1d35c:	9303      	str	r3, [sp, #12]
			if (remaining <= 0) {
   1d35e:	e9dd 3402 	ldrd	r3, r4, [sp, #8]
   1d362:	2b01      	cmp	r3, #1
   1d364:	f174 0300 	sbcs.w	r3, r4, #0
   1d368:	dbc7      	blt.n	1d2fa <net_pkt_alloc_buffer+0xe2>
   1d36a:	f647 70ff 	movw	r0, #32767	; 0x7fff
   1d36e:	2100      	movs	r1, #0
   1d370:	9b02      	ldr	r3, [sp, #8]
   1d372:	fbea 0103 	umlal	r0, r1, sl, r3
   1d376:	9b00      	ldr	r3, [sp, #0]
   1d378:	0bc4      	lsrs	r4, r0, #15
   1d37a:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
		if (!first && !current) {
   1d37e:	461a      	mov	r2, r3
   1d380:	e7ba      	b.n	1d2f8 <net_pkt_alloc_buffer+0xe0>
   1d382:	4605      	mov	r5, r0
   1d384:	e7d9      	b.n	1d33a <net_pkt_alloc_buffer+0x122>
		net_buf_unref(first);
   1d386:	4628      	mov	r0, r5
   1d388:	f7fe fd94 	bl	1beb4 <net_buf_unref>
   1d38c:	e7cd      	b.n	1d32a <net_pkt_alloc_buffer+0x112>
   1d38e:	bf00      	nop
   1d390:	20020850 	.word	0x20020850
   1d394:	20020684 	.word	0x20020684
   1d398:	2002087c 	.word	0x2002087c

0001d39c <net_pkt_alloc_with_buffer>:
					  size_t size,
					  sa_family_t family,
					  enum net_ip_protocol proto,
					  k_timeout_t timeout)
#endif
{
   1d39c:	b513      	push	{r0, r1, r4, lr}
#if NET_LOG_LEVEL >= LOG_LEVEL_DBG
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
				     proto, timeout, caller, line);
#else
	return pkt_alloc_with_buffer(&tx_pkts, iface, size, family,
   1d39e:	9c04      	ldr	r4, [sp, #16]
   1d3a0:	e9cd 3400 	strd	r3, r4, [sp]
   1d3a4:	4613      	mov	r3, r2
   1d3a6:	460a      	mov	r2, r1
   1d3a8:	4601      	mov	r1, r0
   1d3aa:	4802      	ldr	r0, [pc, #8]	; (1d3b4 <net_pkt_alloc_with_buffer+0x18>)
   1d3ac:	f018 fd3f 	bl	35e2e <pkt_alloc_with_buffer>
				     proto, timeout);
#endif
}
   1d3b0:	b002      	add	sp, #8
   1d3b2:	bd10      	pop	{r4, pc}
   1d3b4:	20020684 	.word	0x20020684

0001d3b8 <net_tc_submit_to_tx_queue>:

static struct net_traffic_class tx_classes[NET_TC_TX_COUNT];
static struct net_traffic_class rx_classes[NET_TC_RX_COUNT];

bool net_tc_submit_to_tx_queue(u8_t tc, struct net_pkt *pkt)
{
   1d3b8:	b508      	push	{r3, lr}
   1d3ba:	460b      	mov	r3, r1
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   1d3bc:	3308      	adds	r3, #8
   1d3be:	e8d3 3faf 	lda	r3, [r3]
	if (k_work_pending(net_pkt_work(pkt))) {
   1d3c2:	07db      	lsls	r3, r3, #31
   1d3c4:	d407      	bmi.n	1d3d6 <net_tc_submit_to_tx_queue+0x1e>
		return false;
	}

	k_work_submit_to_queue(&tx_classes[tc].work_q, net_pkt_work(pkt));
   1d3c6:	22dc      	movs	r2, #220	; 0xdc
   1d3c8:	4b04      	ldr	r3, [pc, #16]	; (1d3dc <net_tc_submit_to_tx_queue+0x24>)
   1d3ca:	fb00 3002 	mla	r0, r0, r2, r3
   1d3ce:	f018 feeb 	bl	361a8 <k_work_submit_to_queue>

	return true;
   1d3d2:	2001      	movs	r0, #1
}
   1d3d4:	bd08      	pop	{r3, pc}
		return false;
   1d3d6:	2000      	movs	r0, #0
   1d3d8:	e7fc      	b.n	1d3d4 <net_tc_submit_to_tx_queue+0x1c>
   1d3da:	bf00      	nop
   1d3dc:	20021bec 	.word	0x20021bec

0001d3e0 <net_tx_priority2tc>:

int net_tx_priority2tc(enum net_priority prio)
{
	if (prio > NET_PRIORITY_NC) {
		/* Use default value suggested in 802.1Q */
		prio = NET_PRIORITY_BE;
   1d3e0:	2807      	cmp	r0, #7
   1d3e2:	bf88      	it	hi
   1d3e4:	2000      	movhi	r0, #0
	}

	return tx_prio2tc_map[prio];
}
   1d3e6:	4b01      	ldr	r3, [pc, #4]	; (1d3ec <net_tx_priority2tc+0xc>)
   1d3e8:	5c18      	ldrb	r0, [r3, r0]
   1d3ea:	4770      	bx	lr
   1d3ec:	0003dbeb 	.word	0x0003dbeb

0001d3f0 <net_tc_tx_init>:

	for (i = 0; i < NET_TC_TX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = tx_tc2thread(i);
		tx_classes[i].tc = thread_priority;
   1d3f0:	2307      	movs	r3, #7
{
   1d3f2:	b510      	push	{r4, lr}
		tx_classes[i].tc = thread_priority;
   1d3f4:	4c08      	ldr	r4, [pc, #32]	; (1d418 <net_tc_tx_init+0x28>)
			"prio %d (%d)", i,
			&tx_classes[i].work_q.queue,
			K_THREAD_STACK_SIZEOF(tx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&tx_classes[i].work_q,
   1d3f6:	f44f 6296 	mov.w	r2, #1200	; 0x4b0
		tx_classes[i].tc = thread_priority;
   1d3fa:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
		k_work_q_start(&tx_classes[i].work_q,
   1d3fe:	4907      	ldr	r1, [pc, #28]	; (1d41c <net_tc_tx_init+0x2c>)
   1d400:	f06f 0308 	mvn.w	r3, #8
   1d404:	4620      	mov	r0, r4
   1d406:	f011 f891 	bl	2e52c <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   1d40a:	4905      	ldr	r1, [pc, #20]	; (1d420 <net_tc_tx_init+0x30>)
   1d40c:	f104 001c 	add.w	r0, r4, #28
			       tx_stack[i],
			       K_THREAD_STACK_SIZEOF(tx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&tx_classes[i].work_q.thread, "tx_workq");
	}
}
   1d410:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d414:	f01b bc9d 	b.w	38d52 <z_impl_k_thread_name_set>
   1d418:	20021bec 	.word	0x20021bec
   1d41c:	20031608 	.word	0x20031608
   1d420:	0003dbe2 	.word	0x0003dbe2

0001d424 <net_tc_rx_init>:

	for (i = 0; i < NET_TC_RX_COUNT; i++) {
		u8_t thread_priority;

		thread_priority = rx_tc2thread(i);
		rx_classes[i].tc = thread_priority;
   1d424:	2307      	movs	r3, #7
{
   1d426:	b510      	push	{r4, lr}
		rx_classes[i].tc = thread_priority;
   1d428:	4c08      	ldr	r4, [pc, #32]	; (1d44c <net_tc_rx_init+0x28>)
			"prio %d (%d)", i,
			&rx_classes[i].work_q.queue,
			K_THREAD_STACK_SIZEOF(rx_stack[i]),
			thread_priority, K_PRIO_COOP(thread_priority));

		k_work_q_start(&rx_classes[i].work_q,
   1d42a:	f240 52dc 	movw	r2, #1500	; 0x5dc
		rx_classes[i].tc = thread_priority;
   1d42e:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
		k_work_q_start(&rx_classes[i].work_q,
   1d432:	4907      	ldr	r1, [pc, #28]	; (1d450 <net_tc_rx_init+0x2c>)
   1d434:	f06f 0308 	mvn.w	r3, #8
   1d438:	4620      	mov	r0, r4
   1d43a:	f011 f877 	bl	2e52c <k_work_q_start>
   1d43e:	4905      	ldr	r1, [pc, #20]	; (1d454 <net_tc_rx_init+0x30>)
   1d440:	f104 001c 	add.w	r0, r4, #28
			       rx_stack[i],
			       K_THREAD_STACK_SIZEOF(rx_stack[i]),
			       K_PRIO_COOP(thread_priority));
		k_thread_name_set(&rx_classes[i].work_q.thread, "rx_workq");
	}
}
   1d444:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1d448:	f01b bc83 	b.w	38d52 <z_impl_k_thread_name_set>
   1d44c:	20021b10 	.word	0x20021b10
   1d450:	20031ab8 	.word	0x20031ab8
   1d454:	0003dbd9 	.word	0x0003dbd9

0001d458 <net_icmpv4_register_handler>:
Z_GENLIST_PREPEND(slist, snode)
   1d458:	4b03      	ldr	r3, [pc, #12]	; (1d468 <net_icmpv4_register_handler+0x10>)
   1d45a:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   1d45c:	6002      	str	r2, [r0, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d45e:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   1d460:	6018      	str	r0, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d462:	b902      	cbnz	r2, 1d466 <net_icmpv4_register_handler+0xe>
	list->tail = node;
   1d464:	6058      	str	r0, [r3, #4]
}

void net_icmpv4_register_handler(struct net_icmpv4_handler *handler)
{
	sys_slist_prepend(&handlers, &handler->node);
}
   1d466:	4770      	bx	lr
   1d468:	20021cc8 	.word	0x20021cc8

0001d46c <net_icmpv4_input>:
	sys_slist_find_and_remove(&handlers, &handler->node);
}

enum net_verdict net_icmpv4_input(struct net_pkt *pkt,
				  struct net_ipv4_hdr *ip_hdr)
{
   1d46c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   1d46e:	2304      	movs	r3, #4
   1d470:	2200      	movs	r2, #0
{
   1d472:	460e      	mov	r6, r1
					      struct net_icmp_hdr);
	struct net_icmp_hdr *icmp_hdr;
	struct net_icmpv4_handler *cb;

	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   1d474:	4669      	mov	r1, sp
{
   1d476:	4605      	mov	r5, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmp_access,
   1d478:	e9cd 2300 	strd	r2, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmp_access);
   1d47c:	f018 fe6e 	bl	3615c <net_pkt_get_data>
	if (!icmp_hdr) {
   1d480:	4604      	mov	r4, r0
   1d482:	b910      	cbnz	r0, 1d48a <net_icmpv4_input+0x1e>
		NET_DBG("DROP: NULL ICMPv4 header");
		return NET_DROP;
   1d484:	2002      	movs	r0, #2

drop:
	net_stats_update_icmp_drop(net_pkt_iface(pkt));

	return NET_DROP;
}
   1d486:	b003      	add	sp, #12
   1d488:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return net_calc_chksum(pkt, IPPROTO_ICMPV6);
}

static inline u16_t net_calc_chksum_icmpv4(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_ICMP);
   1d48a:	2101      	movs	r1, #1
   1d48c:	4628      	mov	r0, r5
   1d48e:	f018 f9bf 	bl	35810 <net_calc_chksum>
	if (net_calc_chksum_icmpv4(pkt) != 0U) {
   1d492:	2800      	cmp	r0, #0
   1d494:	d1f6      	bne.n	1d484 <net_icmpv4_input+0x18>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &ip_hdr->dst) &&
   1d496:	6a2f      	ldr	r7, [r5, #32]
 */
#if defined(CONFIG_NET_NATIVE_IPV4)
static inline bool net_ipv4_is_addr_bcast(struct net_if *iface,
					  const struct in_addr *addr)
{
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   1d498:	f7ff f8a4 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   1d49c:	6932      	ldr	r2, [r6, #16]
   1d49e:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   1d4a0:	429a      	cmp	r2, r3
   1d4a2:	d0ef      	beq.n	1d484 <net_icmpv4_input+0x18>
		return true;
	}

	return net_if_ipv4_is_addr_bcast(iface, addr);
   1d4a4:	f106 0110 	add.w	r1, r6, #16
   1d4a8:	4638      	mov	r0, r7
   1d4aa:	f7fe fecf 	bl	1c24c <net_if_ipv4_is_addr_bcast>
   1d4ae:	2800      	cmp	r0, #0
   1d4b0:	d1e8      	bne.n	1d484 <net_icmpv4_input+0x18>
	return net_pkt_skip(pkt, access->size);
   1d4b2:	9901      	ldr	r1, [sp, #4]
   1d4b4:	4628      	mov	r0, r5
   1d4b6:	f018 fcfd 	bl	35eb4 <net_pkt_skip>
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   1d4ba:	4b0b      	ldr	r3, [pc, #44]	; (1d4e8 <net_icmpv4_input+0x7c>)
   1d4bc:	681b      	ldr	r3, [r3, #0]
   1d4be:	2b00      	cmp	r3, #0
   1d4c0:	d0e0      	beq.n	1d484 <net_icmpv4_input+0x18>
		if (cb->type == icmp_hdr->type &&
   1d4c2:	7821      	ldrb	r1, [r4, #0]
   1d4c4:	7a1a      	ldrb	r2, [r3, #8]
   1d4c6:	428a      	cmp	r2, r1
   1d4c8:	d10a      	bne.n	1d4e0 <net_icmpv4_input+0x74>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
   1d4ca:	7a5a      	ldrb	r2, [r3, #9]
		if (cb->type == icmp_hdr->type &&
   1d4cc:	7860      	ldrb	r0, [r4, #1]
   1d4ce:	4290      	cmp	r0, r2
   1d4d0:	d000      	beq.n	1d4d4 <net_icmpv4_input+0x68>
		    (cb->code == icmp_hdr->code || cb->code == 0U)) {
   1d4d2:	b92a      	cbnz	r2, 1d4e0 <net_icmpv4_input+0x74>
			return cb->handler(pkt, ip_hdr, icmp_hdr);
   1d4d4:	685b      	ldr	r3, [r3, #4]
   1d4d6:	4622      	mov	r2, r4
   1d4d8:	4631      	mov	r1, r6
   1d4da:	4628      	mov	r0, r5
   1d4dc:	4798      	blx	r3
   1d4de:	e7d2      	b.n	1d486 <net_icmpv4_input+0x1a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1d4e0:	681b      	ldr	r3, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&handlers, cb, node) {
   1d4e2:	2b00      	cmp	r3, #0
   1d4e4:	d1ee      	bne.n	1d4c4 <net_icmpv4_input+0x58>
   1d4e6:	e7cd      	b.n	1d484 <net_icmpv4_input+0x18>
   1d4e8:	20021cc8 	.word	0x20021cc8

0001d4ec <net_icmpv4_init>:
	.handler = icmpv4_handle_echo_request,
};

void net_icmpv4_init(void)
{
	net_icmpv4_register_handler(&echo_request_handler);
   1d4ec:	4801      	ldr	r0, [pc, #4]	; (1d4f4 <net_icmpv4_init+0x8>)
   1d4ee:	f7ff bfb3 	b.w	1d458 <net_icmpv4_register_handler>
   1d4f2:	bf00      	nop
   1d4f4:	200200b8 	.word	0x200200b8

0001d4f8 <conn_set_unused>:

	sys_slist_prepend(&conn_used, &conn->node);
}

static void conn_set_unused(struct net_conn *conn)
{
   1d4f8:	b510      	push	{r4, lr}
   1d4fa:	4604      	mov	r4, r0
__ssp_bos_icheck3(memset, void *, int)
   1d4fc:	2220      	movs	r2, #32
   1d4fe:	2100      	movs	r1, #0
   1d500:	f01b fda4 	bl	3904c <memset>
Z_GENLIST_PREPEND(slist, snode)
   1d504:	4b03      	ldr	r3, [pc, #12]	; (1d514 <conn_set_unused+0x1c>)
   1d506:	681a      	ldr	r2, [r3, #0]
	parent->next = child;
   1d508:	6022      	str	r2, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d50a:	685a      	ldr	r2, [r3, #4]
	list->head = node;
   1d50c:	601c      	str	r4, [r3, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d50e:	b902      	cbnz	r2, 1d512 <conn_set_unused+0x1a>
	list->tail = node;
   1d510:	605c      	str	r4, [r3, #4]
	(void)memset(conn, 0, sizeof(*conn));

	sys_slist_prepend(&conn_unused, &conn->node);
}
   1d512:	bd10      	pop	{r4, pc}
   1d514:	20021cd0 	.word	0x20021cd0

0001d518 <net_conn_register>:
		      u16_t remote_port,
		      u16_t local_port,
		      net_conn_cb_t cb,
		      void *user_data,
		      struct net_conn_handle **handle)
{
   1d518:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d51c:	4e5d      	ldr	r6, [pc, #372]	; (1d694 <net_conn_register+0x17c>)
{
   1d51e:	9101      	str	r1, [sp, #4]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d520:	6834      	ldr	r4, [r6, #0]
{
   1d522:	f8bd 7030 	ldrh.w	r7, [sp, #48]	; 0x30
   1d526:	f8bd c034 	ldrh.w	ip, [sp, #52]	; 0x34
   1d52a:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d52e:	b344      	cbz	r4, 1d582 <net_conn_register+0x6a>
   1d530:	fa97 f897 	rev16.w	r8, r7
   1d534:	fa9c f99c 	rev16.w	r9, ip
   1d538:	fa1f f888 	uxth.w	r8, r8
   1d53c:	fa1f f989 	uxth.w	r9, r9
		if (conn->proto != proto) {
   1d540:	8ba5      	ldrh	r5, [r4, #28]
   1d542:	4285      	cmp	r5, r0
   1d544:	d11a      	bne.n	1d57c <net_conn_register+0x64>
		if (conn->family != family) {
   1d546:	7fa5      	ldrb	r5, [r4, #30]
   1d548:	9901      	ldr	r1, [sp, #4]
   1d54a:	428d      	cmp	r5, r1
   1d54c:	d116      	bne.n	1d57c <net_conn_register+0x64>
		if (remote_addr) {
   1d54e:	7fe5      	ldrb	r5, [r4, #31]
   1d550:	f005 0a02 	and.w	sl, r5, #2
   1d554:	b1da      	cbz	r2, 1d58e <net_conn_register+0x76>
			if (!(conn->flags & NET_CONN_REMOTE_ADDR_SET)) {
   1d556:	f1ba 0f00 	cmp.w	sl, #0
   1d55a:	d00f      	beq.n	1d57c <net_conn_register+0x64>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d55c:	f8b2 a000 	ldrh.w	sl, [r2]
   1d560:	f1ba 0f01 	cmp.w	sl, #1
   1d564:	d10a      	bne.n	1d57c <net_conn_register+0x64>
				   remote_addr->sa_family == AF_INET &&
   1d566:	f8b4 a004 	ldrh.w	sl, [r4, #4]
   1d56a:	f1ba 0f01 	cmp.w	sl, #1
   1d56e:	d105      	bne.n	1d57c <net_conn_register+0x64>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   1d570:	f8d2 b004 	ldr.w	fp, [r2, #4]
   1d574:	f8d4 a008 	ldr.w	sl, [r4, #8]
				if (!net_ipv4_addr_cmp(
   1d578:	45d3      	cmp	fp, sl
   1d57a:	d00b      	beq.n	1d594 <net_conn_register+0x7c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1d57c:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d57e:	2c00      	cmp	r4, #0
   1d580:	d1de      	bne.n	1d540 <net_conn_register+0x28>
	node = sys_slist_peek_head(&conn_unused);
   1d582:	4d45      	ldr	r5, [pc, #276]	; (1d698 <net_conn_register+0x180>)
   1d584:	682c      	ldr	r4, [r5, #0]
	if (!node) {
   1d586:	bb0c      	cbnz	r4, 1d5cc <net_conn_register+0xb4>
		return -EALREADY;
	}

	conn = conn_get_unused();
	if (!conn) {
		return -ENOENT;
   1d588:	f06f 0001 	mvn.w	r0, #1
   1d58c:	e075      	b.n	1d67a <net_conn_register+0x162>
		} else if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
   1d58e:	f1ba 0f00 	cmp.w	sl, #0
   1d592:	d1f3      	bne.n	1d57c <net_conn_register+0x64>
		if (local_addr) {
   1d594:	f005 0504 	and.w	r5, r5, #4
   1d598:	b1ab      	cbz	r3, 1d5c6 <net_conn_register+0xae>
			if (!(conn->flags & NET_CONN_LOCAL_ADDR_SET)) {
   1d59a:	2d00      	cmp	r5, #0
   1d59c:	d0ee      	beq.n	1d57c <net_conn_register+0x64>
			} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d59e:	881d      	ldrh	r5, [r3, #0]
   1d5a0:	2d01      	cmp	r5, #1
   1d5a2:	d1eb      	bne.n	1d57c <net_conn_register+0x64>
				   local_addr->sa_family == AF_INET &&
   1d5a4:	89a5      	ldrh	r5, [r4, #12]
   1d5a6:	2d01      	cmp	r5, #1
   1d5a8:	d1e8      	bne.n	1d57c <net_conn_register+0x64>
   1d5aa:	f8d3 a004 	ldr.w	sl, [r3, #4]
   1d5ae:	6925      	ldr	r5, [r4, #16]
				if (!net_ipv4_addr_cmp(
   1d5b0:	45aa      	cmp	sl, r5
   1d5b2:	d1e3      	bne.n	1d57c <net_conn_register+0x64>
		if (net_sin(&conn->remote_addr)->sin_port !=
   1d5b4:	88e5      	ldrh	r5, [r4, #6]
   1d5b6:	4545      	cmp	r5, r8
   1d5b8:	d1e0      	bne.n	1d57c <net_conn_register+0x64>
		if (net_sin(&conn->local_addr)->sin_port !=
   1d5ba:	89e5      	ldrh	r5, [r4, #14]
   1d5bc:	454d      	cmp	r5, r9
   1d5be:	d1dd      	bne.n	1d57c <net_conn_register+0x64>
		return -EALREADY;
   1d5c0:	f06f 0077 	mvn.w	r0, #119	; 0x77
   1d5c4:	e059      	b.n	1d67a <net_conn_register+0x162>
		} else if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
   1d5c6:	2d00      	cmp	r5, #0
   1d5c8:	d0f4      	beq.n	1d5b4 <net_conn_register+0x9c>
   1d5ca:	e7d7      	b.n	1d57c <net_conn_register+0x64>
Z_GENLIST_REMOVE(slist, snode)
   1d5cc:	6869      	ldr	r1, [r5, #4]
   1d5ce:	f8d4 9000 	ldr.w	r9, [r4]
   1d5d2:	428c      	cmp	r4, r1
	list->head = node;
   1d5d4:	f8c5 9000 	str.w	r9, [r5]
	list->tail = node;
   1d5d8:	bf08      	it	eq
   1d5da:	f8c5 9004 	streq.w	r9, [r5, #4]
	parent->next = child;
   1d5de:	2500      	movs	r5, #0
   1d5e0:	6025      	str	r5, [r4, #0]
	}

	if (remote_addr) {
   1d5e2:	2a00      	cmp	r2, #0
   1d5e4:	d04c      	beq.n	1d680 <net_conn_register+0x168>
			if (!net_ipv6_is_addr_unspecified(
				    &net_sin6(remote_addr)->
				    sin6_addr)) {
				flags |= NET_CONN_REMOTE_ADDR_SPEC;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d5e6:	8815      	ldrh	r5, [r2, #0]
   1d5e8:	2d01      	cmp	r5, #1
   1d5ea:	d14b      	bne.n	1d684 <net_conn_register+0x16c>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1d5ec:	6815      	ldr	r5, [r2, #0]
   1d5ee:	6065      	str	r5, [r4, #4]
   1d5f0:	6855      	ldr	r5, [r2, #4]
   1d5f2:	60a5      	str	r5, [r4, #8]
			   remote_addr->sa_family == AF_INET) {
			memcpy(&conn->remote_addr, remote_addr,
			       sizeof(struct sockaddr_in));

			if (net_sin(remote_addr)->sin_addr.s_addr) {
   1d5f4:	6855      	ldr	r5, [r2, #4]
				flags |= NET_CONN_REMOTE_ADDR_SPEC;
   1d5f6:	2d00      	cmp	r5, #0
		} else {
			NET_ERR("Remote address family not set");
			goto error;
		}

		flags |= NET_CONN_REMOTE_ADDR_SET;
   1d5f8:	bf14      	ite	ne
   1d5fa:	2522      	movne	r5, #34	; 0x22
   1d5fc:	2502      	moveq	r5, #2
	}

	if (local_addr) {
   1d5fe:	b1bb      	cbz	r3, 1d630 <net_conn_register+0x118>
			if (!net_ipv6_is_addr_unspecified(
				    &net_sin6(local_addr)->
				    sin6_addr)) {
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
			}
		} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d600:	f8b3 8000 	ldrh.w	r8, [r3]
   1d604:	f1b8 0f01 	cmp.w	r8, #1
   1d608:	d13c      	bne.n	1d684 <net_conn_register+0x16c>
   1d60a:	f8d3 8000 	ldr.w	r8, [r3]
   1d60e:	f8c4 800c 	str.w	r8, [r4, #12]
   1d612:	f8d3 8004 	ldr.w	r8, [r3, #4]
   1d616:	f8c4 8010 	str.w	r8, [r4, #16]
			   local_addr->sa_family == AF_INET) {
			memcpy(&conn->local_addr, local_addr,
			       sizeof(struct sockaddr_in));

			if (net_sin(local_addr)->sin_addr.s_addr) {
   1d61a:	6859      	ldr	r1, [r3, #4]
   1d61c:	b109      	cbz	r1, 1d622 <net_conn_register+0x10a>
				flags |= NET_CONN_LOCAL_ADDR_SPEC;
   1d61e:	f045 0540 	orr.w	r5, r5, #64	; 0x40
		} else {
			NET_ERR("Local address family not set");
			goto error;
		}

		flags |= NET_CONN_LOCAL_ADDR_SET;
   1d622:	f045 0504 	orr.w	r5, r5, #4
	}

	if (remote_addr && local_addr) {
   1d626:	b11a      	cbz	r2, 1d630 <net_conn_register+0x118>
		if (remote_addr->sa_family != local_addr->sa_family) {
   1d628:	8812      	ldrh	r2, [r2, #0]
   1d62a:	881b      	ldrh	r3, [r3, #0]
   1d62c:	429a      	cmp	r2, r3
   1d62e:	d129      	bne.n	1d684 <net_conn_register+0x16c>
			NET_ERR("Address families different");
			goto error;
		}
	}

	if (remote_port) {
   1d630:	b11f      	cbz	r7, 1d63a <net_conn_register+0x122>
		flags |= NET_CONN_REMOTE_PORT_SPEC;
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
   1d632:	ba7f      	rev16	r7, r7
		flags |= NET_CONN_REMOTE_PORT_SPEC;
   1d634:	f045 0508 	orr.w	r5, r5, #8
		net_sin(&conn->remote_addr)->sin_port = htons(remote_port);
   1d638:	80e7      	strh	r7, [r4, #6]
	}

	if (local_port) {
   1d63a:	f1bc 0f00 	cmp.w	ip, #0
   1d63e:	d005      	beq.n	1d64c <net_conn_register+0x134>
		flags |= NET_CONN_LOCAL_PORT_SPEC;
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
   1d640:	fa9c fc9c 	rev16.w	ip, ip
		flags |= NET_CONN_LOCAL_PORT_SPEC;
   1d644:	f045 0510 	orr.w	r5, r5, #16
		net_sin(&conn->local_addr)->sin_port = htons(local_port);
   1d648:	f8a4 c00e 	strh.w	ip, [r4, #14]
	}

	conn->cb = cb;
   1d64c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	conn->user_data = user_data;
	conn->flags = flags;
   1d64e:	77e5      	strb	r5, [r4, #31]
	conn->cb = cb;
   1d650:	6163      	str	r3, [r4, #20]
	conn->user_data = user_data;
   1d652:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	conn->proto = proto;
   1d654:	83a0      	strh	r0, [r4, #28]
	conn->user_data = user_data;
   1d656:	61a3      	str	r3, [r4, #24]
	conn->family = family;
   1d658:	9b01      	ldr	r3, [sp, #4]
   1d65a:	77a3      	strb	r3, [r4, #30]

	if (handle) {
   1d65c:	f1be 0f00 	cmp.w	lr, #0
   1d660:	d001      	beq.n	1d666 <net_conn_register+0x14e>
		*handle = (struct net_conn_handle *)conn;
   1d662:	f8ce 4000 	str.w	r4, [lr]
	conn->flags |= NET_CONN_IN_USE;
   1d666:	7fe3      	ldrb	r3, [r4, #31]
   1d668:	f043 0301 	orr.w	r3, r3, #1
   1d66c:	77e3      	strb	r3, [r4, #31]
Z_GENLIST_PREPEND(slist, snode)
   1d66e:	6833      	ldr	r3, [r6, #0]
	parent->next = child;
   1d670:	6023      	str	r3, [r4, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d672:	6870      	ldr	r0, [r6, #4]
	list->head = node;
   1d674:	6034      	str	r4, [r6, #0]
Z_GENLIST_PREPEND(slist, snode)
   1d676:	b958      	cbnz	r0, 1d690 <net_conn_register+0x178>
	list->tail = node;
   1d678:	6074      	str	r4, [r6, #4]

	return 0;
error:
	conn_set_unused(conn);
	return -EINVAL;
}
   1d67a:	b003      	add	sp, #12
   1d67c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u8_t flags = 0U;
   1d680:	4615      	mov	r5, r2
   1d682:	e7bc      	b.n	1d5fe <net_conn_register+0xe6>
	conn_set_unused(conn);
   1d684:	4620      	mov	r0, r4
   1d686:	f7ff ff37 	bl	1d4f8 <conn_set_unused>
	return -EINVAL;
   1d68a:	f06f 0015 	mvn.w	r0, #21
   1d68e:	e7f4      	b.n	1d67a <net_conn_register+0x162>
	return 0;
   1d690:	2000      	movs	r0, #0
   1d692:	e7f2      	b.n	1d67a <net_conn_register+0x162>
   1d694:	20021cd8 	.word	0x20021cd8
   1d698:	20021cd0 	.word	0x20021cd0

0001d69c <net_conn_unregister>:

int net_conn_unregister(struct net_conn_handle *handle)
{
   1d69c:	b508      	push	{r3, lr}
	struct net_conn *conn = (struct net_conn *)handle;

	if (conn < &conns[0] || conn > &conns[CONFIG_NET_MAX_CONN]) {
   1d69e:	4b15      	ldr	r3, [pc, #84]	; (1d6f4 <net_conn_unregister+0x58>)
   1d6a0:	4298      	cmp	r0, r3
   1d6a2:	d321      	bcc.n	1d6e8 <net_conn_unregister+0x4c>
   1d6a4:	3380      	adds	r3, #128	; 0x80
   1d6a6:	4298      	cmp	r0, r3
   1d6a8:	d81e      	bhi.n	1d6e8 <net_conn_unregister+0x4c>
		return -EINVAL;
	}

	if (!(conn->flags & NET_CONN_IN_USE)) {
   1d6aa:	7fc3      	ldrb	r3, [r0, #31]
   1d6ac:	07db      	lsls	r3, r3, #31
   1d6ae:	d51e      	bpl.n	1d6ee <net_conn_unregister+0x52>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1d6b0:	2100      	movs	r1, #0
   1d6b2:	4b11      	ldr	r3, [pc, #68]	; (1d6f8 <net_conn_unregister+0x5c>)
   1d6b4:	681a      	ldr	r2, [r3, #0]
   1d6b6:	b152      	cbz	r2, 1d6ce <net_conn_unregister+0x32>
   1d6b8:	4290      	cmp	r0, r2
   1d6ba:	d112      	bne.n	1d6e2 <net_conn_unregister+0x46>
Z_GENLIST_REMOVE(slist, snode)
   1d6bc:	6802      	ldr	r2, [r0, #0]
   1d6be:	b951      	cbnz	r1, 1d6d6 <net_conn_unregister+0x3a>
   1d6c0:	6859      	ldr	r1, [r3, #4]
	list->head = node;
   1d6c2:	601a      	str	r2, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1d6c4:	4288      	cmp	r0, r1
   1d6c6:	d100      	bne.n	1d6ca <net_conn_unregister+0x2e>
	list->tail = node;
   1d6c8:	605a      	str	r2, [r3, #4]
	parent->next = child;
   1d6ca:	2300      	movs	r3, #0
   1d6cc:	6003      	str	r3, [r0, #0]

	NET_DBG("Connection handler %p removed", conn);

	sys_slist_find_and_remove(&conn_used, &conn->node);

	conn_set_unused(conn);
   1d6ce:	f7ff ff13 	bl	1d4f8 <conn_set_unused>

	return 0;
   1d6d2:	2000      	movs	r0, #0
}
   1d6d4:	bd08      	pop	{r3, pc}
   1d6d6:	600a      	str	r2, [r1, #0]
Z_GENLIST_REMOVE(slist, snode)
   1d6d8:	685a      	ldr	r2, [r3, #4]
   1d6da:	4290      	cmp	r0, r2
	list->tail = node;
   1d6dc:	bf08      	it	eq
   1d6de:	6059      	streq	r1, [r3, #4]
   1d6e0:	e7f3      	b.n	1d6ca <net_conn_unregister+0x2e>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1d6e2:	4611      	mov	r1, r2
   1d6e4:	6812      	ldr	r2, [r2, #0]
   1d6e6:	e7e6      	b.n	1d6b6 <net_conn_unregister+0x1a>
		return -EINVAL;
   1d6e8:	f06f 0015 	mvn.w	r0, #21
   1d6ec:	e7f2      	b.n	1d6d4 <net_conn_unregister+0x38>
		return -ENOENT;
   1d6ee:	f06f 0001 	mvn.w	r0, #1
   1d6f2:	e7ef      	b.n	1d6d4 <net_conn_unregister+0x38>
   1d6f4:	20021ce0 	.word	0x20021ce0
   1d6f8:	20021cd8 	.word	0x20021cd8

0001d6fc <net_conn_input>:

enum net_verdict net_conn_input(struct net_pkt *pkt,
				union net_ip_header *ip_hdr,
				u8_t proto,
				union net_proto_header *proto_hdr)
{
   1d6fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	s16_t best_rank = -1;
	struct net_conn *conn;
	u16_t src_port;
	u16_t dst_port;

	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   1d700:	2a11      	cmp	r2, #17
{
   1d702:	b087      	sub	sp, #28
   1d704:	4606      	mov	r6, r0
   1d706:	4689      	mov	r9, r1
   1d708:	4617      	mov	r7, r2
   1d70a:	469a      	mov	sl, r3
	if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   1d70c:	d16f      	bne.n	1d7ee <net_conn_input+0xf2>
		src_port = proto_hdr->udp->src_port;
		dst_port = proto_hdr->udp->dst_port;
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
		src_port = proto_hdr->tcp->src_port;
   1d70e:	f8da 3000 	ldr.w	r3, [sl]
   1d712:	881a      	ldrh	r2, [r3, #0]
   1d714:	9202      	str	r2, [sp, #8]
		dst_port = proto_hdr->tcp->dst_port;
   1d716:	f8b3 b002 	ldrh.w	fp, [r3, #2]
	return pkt->family;
   1d71a:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
   1d71e:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1d722:	2b01      	cmp	r3, #1
   1d724:	d069      	beq.n	1d7fa <net_conn_input+0xfe>
	bool is_mcast_pkt = false, mcast_pkt_delivered = false;
   1d726:	2500      	movs	r5, #0
		if (net_ipv6_is_addr_mcast(&ip_hdr->ipv6->dst)) {
			is_mcast_pkt = true;
		}
	}

	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d728:	4b6a      	ldr	r3, [pc, #424]	; (1d8d4 <net_conn_input+0x1d8>)
   1d72a:	681c      	ldr	r4, [r3, #0]
   1d72c:	2c00      	cmp	r4, #0
   1d72e:	f000 80be 	beq.w	1d8ae <net_conn_input+0x1b2>
   1d732:	2200      	movs	r2, #0
   1d734:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1d738:	4690      	mov	r8, r2
   1d73a:	9304      	str	r3, [sp, #16]
		if (conn->proto != proto) {
   1d73c:	b2bb      	uxth	r3, r7
   1d73e:	9305      	str	r3, [sp, #20]
   1d740:	8ba3      	ldrh	r3, [r4, #28]
   1d742:	9905      	ldr	r1, [sp, #20]
   1d744:	428b      	cmp	r3, r1
   1d746:	d146      	bne.n	1d7d6 <net_conn_input+0xda>
			continue;
		}

		if (conn->family != AF_UNSPEC &&
   1d748:	7fa1      	ldrb	r1, [r4, #30]
   1d74a:	b129      	cbz	r1, 1d758 <net_conn_input+0x5c>
   1d74c:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
   1d750:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1d754:	428b      	cmp	r3, r1
   1d756:	d13e      	bne.n	1d7d6 <net_conn_input+0xda>
			continue;
		}

		if (IS_ENABLED(CONFIG_NET_UDP) ||
		    IS_ENABLED(CONFIG_NET_TCP)) {
			if (net_sin(&conn->remote_addr)->sin_port) {
   1d758:	88e3      	ldrh	r3, [r4, #6]
   1d75a:	b113      	cbz	r3, 1d762 <net_conn_input+0x66>
				if (net_sin(&conn->remote_addr)->sin_port !=
   1d75c:	9902      	ldr	r1, [sp, #8]
   1d75e:	4299      	cmp	r1, r3
   1d760:	d139      	bne.n	1d7d6 <net_conn_input+0xda>
				    src_port) {
					continue;
				}
			}

			if (net_sin(&conn->local_addr)->sin_port) {
   1d762:	89e3      	ldrh	r3, [r4, #14]
   1d764:	b10b      	cbz	r3, 1d76a <net_conn_input+0x6e>
				if (net_sin(&conn->local_addr)->sin_port !=
   1d766:	459b      	cmp	fp, r3
   1d768:	d135      	bne.n	1d7d6 <net_conn_input+0xda>
				    dst_port) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_REMOTE_ADDR_SET) {
   1d76a:	7fe3      	ldrb	r3, [r4, #31]
   1d76c:	079f      	lsls	r7, r3, #30
   1d76e:	d50f      	bpl.n	1d790 <net_conn_input+0x94>
   1d770:	f896 103f 	ldrb.w	r1, [r6, #63]	; 0x3f
	if (addr->sa_family != net_pkt_family(pkt)) {
   1d774:	88a0      	ldrh	r0, [r4, #4]
   1d776:	f3c1 0142 	ubfx	r1, r1, #1, #3
   1d77a:	4288      	cmp	r0, r1
   1d77c:	d12b      	bne.n	1d7d6 <net_conn_input+0xda>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d77e:	2901      	cmp	r1, #1
   1d780:	d106      	bne.n	1d790 <net_conn_input+0x94>
		if (net_sin(addr)->sin_addr.s_addr) {
   1d782:	68a1      	ldr	r1, [r4, #8]
   1d784:	b121      	cbz	r1, 1d790 <net_conn_input+0x94>
   1d786:	f8d9 0000 	ldr.w	r0, [r9]
   1d78a:	68c0      	ldr	r0, [r0, #12]
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
   1d78c:	4281      	cmp	r1, r0
   1d78e:	d122      	bne.n	1d7d6 <net_conn_input+0xda>
						   true)) {
					continue;
				}
			}

			if (conn->flags & NET_CONN_LOCAL_ADDR_SET) {
   1d790:	0758      	lsls	r0, r3, #29
   1d792:	d50f      	bpl.n	1d7b4 <net_conn_input+0xb8>
   1d794:	f896 103f 	ldrb.w	r1, [r6, #63]	; 0x3f
	if (addr->sa_family != net_pkt_family(pkt)) {
   1d798:	89a0      	ldrh	r0, [r4, #12]
   1d79a:	f3c1 0142 	ubfx	r1, r1, #1, #3
   1d79e:	4288      	cmp	r0, r1
   1d7a0:	d119      	bne.n	1d7d6 <net_conn_input+0xda>
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d7a2:	2901      	cmp	r1, #1
   1d7a4:	d106      	bne.n	1d7b4 <net_conn_input+0xb8>
		if (net_sin(addr)->sin_addr.s_addr) {
   1d7a6:	6921      	ldr	r1, [r4, #16]
   1d7a8:	b121      	cbz	r1, 1d7b4 <net_conn_input+0xb8>
   1d7aa:	f8d9 0000 	ldr.w	r0, [r9]
   1d7ae:	6900      	ldr	r0, [r0, #16]
			if (!net_ipv4_addr_cmp(&net_sin(addr)->sin_addr,
   1d7b0:	4281      	cmp	r1, r0
   1d7b2:	d110      	bne.n	1d7d6 <net_conn_input+0xda>

			/* If we have an existing best_match, and that one
			 * specifies a remote port, then we've matched to a
			 * LISTENING connection that should not override.
			 */
			if (best_match != NULL &&
   1d7b4:	f1b8 0f00 	cmp.w	r8, #0
   1d7b8:	d003      	beq.n	1d7c2 <net_conn_input+0xc6>
   1d7ba:	f898 101f 	ldrb.w	r1, [r8, #31]
   1d7be:	0709      	lsls	r1, r1, #28
   1d7c0:	d409      	bmi.n	1d7d6 <net_conn_input+0xda>
			    best_match->flags & NET_CONN_REMOTE_PORT_SPEC) {
				continue;
			}

			if (best_rank < NET_CONN_RANK(conn->flags)) {
   1d7c2:	9904      	ldr	r1, [sp, #16]
   1d7c4:	f003 0378 	and.w	r3, r3, #120	; 0x78
   1d7c8:	4299      	cmp	r1, r3
   1d7ca:	da04      	bge.n	1d7d6 <net_conn_input+0xda>
				struct net_pkt *mcast_pkt;

				if (!is_mcast_pkt) {
   1d7cc:	2d00      	cmp	r5, #0
   1d7ce:	d148      	bne.n	1d862 <net_conn_input+0x166>
					best_rank = NET_CONN_RANK(conn->flags);
					best_match = conn;

					continue;
   1d7d0:	46a0      	mov	r8, r4
					best_rank = NET_CONN_RANK(conn->flags);
   1d7d2:	b21b      	sxth	r3, r3
   1d7d4:	9304      	str	r3, [sp, #16]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1d7d6:	6824      	ldr	r4, [r4, #0]
	SYS_SLIST_FOR_EACH_CONTAINER(&conn_used, conn, node) {
   1d7d8:	2c00      	cmp	r4, #0
   1d7da:	d1b1      	bne.n	1d740 <net_conn_input+0x44>
			best_rank = 0;
			best_match = conn;
		}
	}

	if (is_mcast_pkt && mcast_pkt_delivered) {
   1d7dc:	2d00      	cmp	r5, #0
   1d7de:	d056      	beq.n	1d88e <net_conn_input+0x192>
   1d7e0:	2a00      	cmp	r2, #0
   1d7e2:	d054      	beq.n	1d88e <net_conn_input+0x192>
		/* As one or more multicast packets have already been delivered
		 * in the loop above, we shall not call the callback again here
		 */

		net_pkt_unref(pkt);
   1d7e4:	4630      	mov	r0, r6
   1d7e6:	f018 fa77 	bl	35cd8 <net_pkt_unref>
			goto drop;
		}

		net_stats_update_per_proto_recv(pkt_iface, proto);

		return NET_OK;
   1d7ea:	2000      	movs	r0, #0
   1d7ec:	e002      	b.n	1d7f4 <net_conn_input+0xf8>
	} else if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
   1d7ee:	2a06      	cmp	r2, #6
   1d7f0:	d08d      	beq.n	1d70e <net_conn_input+0x12>
	}

drop:
	net_stats_update_per_proto_drop(pkt_iface, proto);

	return NET_DROP;
   1d7f2:	2002      	movs	r0, #2
}
   1d7f4:	b007      	add	sp, #28
   1d7f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (net_ipv4_addr_cmp(&ip_hdr->ipv4->src,
   1d7fa:	f8d9 4000 	ldr.w	r4, [r9]
   1d7fe:	68e2      	ldr	r2, [r4, #12]
   1d800:	6923      	ldr	r3, [r4, #16]
   1d802:	429a      	cmp	r2, r3
   1d804:	d061      	beq.n	1d8ca <net_conn_input+0x1ce>
		    net_ipv4_is_my_addr(&ip_hdr->ipv4->src)) {
   1d806:	f104 050c 	add.w	r5, r4, #12
 */
static inline bool net_ipv4_is_my_addr(const struct in_addr *addr)
{
	bool ret;

	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   1d80a:	2100      	movs	r1, #0
   1d80c:	4628      	mov	r0, r5
   1d80e:	f7fe fd9d 	bl	1c34c <net_if_ipv4_addr_lookup>
   1d812:	f1b0 0800 	subs.w	r8, r0, #0
   1d816:	bf14      	ite	ne
   1d818:	2001      	movne	r0, #1
   1d81a:	2000      	moveq	r0, #0
	if (!ret) {
   1d81c:	d109      	bne.n	1d832 <net_conn_input+0x136>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   1d81e:	f7fe fee1 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   1d822:	68e2      	ldr	r2, [r4, #12]
   1d824:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   1d826:	429a      	cmp	r2, r3
   1d828:	d004      	beq.n	1d834 <net_conn_input+0x138>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   1d82a:	4629      	mov	r1, r5
   1d82c:	4640      	mov	r0, r8
   1d82e:	f7fe fd0d 	bl	1c24c <net_if_ipv4_is_addr_bcast>
				      &ip_hdr->ipv4->dst) ||
   1d832:	b110      	cbz	r0, 1d83a <net_conn_input+0x13e>
	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
   1d834:	9b02      	ldr	r3, [sp, #8]
   1d836:	459b      	cmp	fp, r3
   1d838:	d0db      	beq.n	1d7f2 <net_conn_input+0xf6>
   1d83a:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
   1d83e:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1d842:	2b01      	cmp	r3, #1
   1d844:	f47f af6f 	bne.w	1d726 <net_conn_input+0x2a>
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   1d848:	f8d9 3000 	ldr.w	r3, [r9]
   1d84c:	691d      	ldr	r5, [r3, #16]
   1d84e:	ba2d      	rev	r5, r5
   1d850:	f005 4560 	and.w	r5, r5, #3758096384	; 0xe0000000
		if (net_ipv4_is_addr_mcast(&ip_hdr->ipv4->dst)) {
   1d854:	f105 5c00 	add.w	ip, r5, #536870912	; 0x20000000
   1d858:	f1dc 0500 	rsbs	r5, ip, #0
   1d85c:	eb45 050c 	adc.w	r5, r5, ip
   1d860:	e762      	b.n	1d728 <net_conn_input+0x2c>
				mcast_pkt = net_pkt_clone(pkt, CLONE_TIMEOUT);
   1d862:	2164      	movs	r1, #100	; 0x64
   1d864:	4630      	mov	r0, r6
   1d866:	f018 fbd7 	bl	36018 <net_pkt_clone>
				if (!mcast_pkt) {
   1d86a:	9003      	str	r0, [sp, #12]
   1d86c:	2800      	cmp	r0, #0
   1d86e:	d0c0      	beq.n	1d7f2 <net_conn_input+0xf6>
				if (conn->cb(conn, mcast_pkt, ip_hdr,
   1d870:	69a3      	ldr	r3, [r4, #24]
   1d872:	4601      	mov	r1, r0
   1d874:	9300      	str	r3, [sp, #0]
   1d876:	464a      	mov	r2, r9
   1d878:	4653      	mov	r3, sl
   1d87a:	4620      	mov	r0, r4
   1d87c:	6967      	ldr	r7, [r4, #20]
   1d87e:	47b8      	blx	r7
   1d880:	2802      	cmp	r0, #2
   1d882:	d102      	bne.n	1d88a <net_conn_input+0x18e>
					net_pkt_unref(mcast_pkt);
   1d884:	9803      	ldr	r0, [sp, #12]
   1d886:	f018 fa27 	bl	35cd8 <net_pkt_unref>
				mcast_pkt_delivered = true;
   1d88a:	462a      	mov	r2, r5
   1d88c:	e7a3      	b.n	1d7d6 <net_conn_input+0xda>
	if (conn) {
   1d88e:	f1b8 0f00 	cmp.w	r8, #0
   1d892:	d00c      	beq.n	1d8ae <net_conn_input+0x1b2>
		if (conn->cb(conn, pkt, ip_hdr, proto_hdr,
   1d894:	f8d8 3018 	ldr.w	r3, [r8, #24]
   1d898:	464a      	mov	r2, r9
   1d89a:	9300      	str	r3, [sp, #0]
   1d89c:	f8d8 4014 	ldr.w	r4, [r8, #20]
   1d8a0:	4653      	mov	r3, sl
   1d8a2:	4631      	mov	r1, r6
   1d8a4:	4640      	mov	r0, r8
   1d8a6:	47a0      	blx	r4
   1d8a8:	2802      	cmp	r0, #2
   1d8aa:	d19e      	bne.n	1d7ea <net_conn_input+0xee>
   1d8ac:	e7a1      	b.n	1d7f2 <net_conn_input+0xf6>
   1d8ae:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1d8b2:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1d8b6:	2b01      	cmp	r3, #1
   1d8b8:	d101      	bne.n	1d8be <net_conn_input+0x1c2>
		   net_pkt_family(pkt) == AF_INET && is_mcast_pkt) {
   1d8ba:	2d00      	cmp	r5, #0
   1d8bc:	d199      	bne.n	1d7f2 <net_conn_input+0xf6>
		net_icmpv4_send_error(pkt, NET_ICMPV4_DST_UNREACH,
   1d8be:	2203      	movs	r2, #3
   1d8c0:	4630      	mov	r0, r6
   1d8c2:	4611      	mov	r1, r2
   1d8c4:	f018 fd13 	bl	362ee <net_icmpv4_send_error>
   1d8c8:	e793      	b.n	1d7f2 <net_conn_input+0xf6>
	if (!conn_are_end_points_valid(pkt, ip_hdr, src_port, dst_port)) {
   1d8ca:	9b02      	ldr	r3, [sp, #8]
   1d8cc:	459b      	cmp	fp, r3
   1d8ce:	d090      	beq.n	1d7f2 <net_conn_input+0xf6>
   1d8d0:	e7ba      	b.n	1d848 <net_conn_input+0x14c>
   1d8d2:	bf00      	nop
   1d8d4:	20021cd8 	.word	0x20021cd8

0001d8d8 <net_conn_init>:
	list->head = NULL;
   1d8d8:	2200      	movs	r2, #0
   1d8da:	4b09      	ldr	r3, [pc, #36]	; (1d900 <net_conn_init+0x28>)
	list->tail = NULL;
   1d8dc:	e9c3 2200 	strd	r2, r2, [r3]
	parent->next = child;
   1d8e0:	4b08      	ldr	r3, [pc, #32]	; (1d904 <net_conn_init+0x2c>)
   1d8e2:	4619      	mov	r1, r3
   1d8e4:	601a      	str	r2, [r3, #0]
   1d8e6:	f103 0220 	add.w	r2, r3, #32
   1d8ea:	f841 2f40 	str.w	r2, [r1, #64]!
   1d8ee:	461a      	mov	r2, r3
   1d8f0:	f842 1f60 	str.w	r1, [r2, #96]!
   1d8f4:	4904      	ldr	r1, [pc, #16]	; (1d908 <net_conn_init+0x30>)
   1d8f6:	621b      	str	r3, [r3, #32]
	return list->tail;
   1d8f8:	e9c1 2300 	strd	r2, r3, [r1]
	sys_slist_init(&conn_used);

	for (i = 0; i < CONFIG_NET_MAX_CONN; i++) {
		sys_slist_prepend(&conn_unused, &conns[i].node);
	}
}
   1d8fc:	4770      	bx	lr
   1d8fe:	bf00      	nop
   1d900:	20021cd8 	.word	0x20021cd8
   1d904:	20021ce0 	.word	0x20021ce0
   1d908:	20021cd0 	.word	0x20021cd0

0001d90c <k_delayed_work_submit>:
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   1d90c:	460a      	mov	r2, r1
   1d90e:	4601      	mov	r1, r0
   1d910:	4801      	ldr	r0, [pc, #4]	; (1d918 <k_delayed_work_submit+0xc>)
   1d912:	f010 be2f 	b.w	2e574 <k_delayed_work_submit_to_queue>
   1d916:	bf00      	nop
   1d918:	20027524 	.word	0x20027524

0001d91c <net_context_get_family>:
{
   1d91c:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1d91e:	4604      	mov	r4, r0
   1d920:	b970      	cbnz	r0, 1d940 <net_context_get_family+0x24>
   1d922:	490a      	ldr	r1, [pc, #40]	; (1d94c <net_context_get_family+0x30>)
   1d924:	f240 13cb 	movw	r3, #459	; 0x1cb
   1d928:	4a09      	ldr	r2, [pc, #36]	; (1d950 <net_context_get_family+0x34>)
   1d92a:	480a      	ldr	r0, [pc, #40]	; (1d954 <net_context_get_family+0x38>)
   1d92c:	f015 fe4c 	bl	335c8 <printk>
   1d930:	4809      	ldr	r0, [pc, #36]	; (1d958 <net_context_get_family+0x3c>)
   1d932:	f015 fe49 	bl	335c8 <printk>
   1d936:	f240 11cb 	movw	r1, #459	; 0x1cb
   1d93a:	4805      	ldr	r0, [pc, #20]	; (1d950 <net_context_get_family+0x34>)
   1d93c:	f016 f945 	bl	33bca <assert_post_action>
	return ((context->flags & NET_CONTEXT_FAMILY) >> 3);
   1d940:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   1d944:	f3c0 00c2 	ubfx	r0, r0, #3, #3
   1d948:	bd10      	pop	{r4, pc}
   1d94a:	bf00      	nop
   1d94c:	0003cb83 	.word	0x0003cb83
   1d950:	0003cb56 	.word	0x0003cb56
   1d954:	0003b77f 	.word	0x0003b77f
   1d958:	0003cb8b 	.word	0x0003cb8b

0001d95c <net_context_get_state>:
{
   1d95c:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1d95e:	4604      	mov	r4, r0
   1d960:	b970      	cbnz	r0, 1d980 <net_context_get_state+0x24>
   1d962:	490a      	ldr	r1, [pc, #40]	; (1d98c <net_context_get_state+0x30>)
   1d964:	f44f 73d3 	mov.w	r3, #422	; 0x1a6
   1d968:	4a09      	ldr	r2, [pc, #36]	; (1d990 <net_context_get_state+0x34>)
   1d96a:	480a      	ldr	r0, [pc, #40]	; (1d994 <net_context_get_state+0x38>)
   1d96c:	f015 fe2c 	bl	335c8 <printk>
   1d970:	4809      	ldr	r0, [pc, #36]	; (1d998 <net_context_get_state+0x3c>)
   1d972:	f015 fe29 	bl	335c8 <printk>
   1d976:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
   1d97a:	4805      	ldr	r0, [pc, #20]	; (1d990 <net_context_get_state+0x34>)
   1d97c:	f016 f925 	bl	33bca <assert_post_action>
		((context->flags >> NET_CONTEXT_STATE_SHIFT) &
   1d980:	f8b4 007a 	ldrh.w	r0, [r4, #122]	; 0x7a
}
   1d984:	f3c0 0041 	ubfx	r0, r0, #1, #2
   1d988:	bd10      	pop	{r4, pc}
   1d98a:	bf00      	nop
   1d98c:	0003cb83 	.word	0x0003cb83
   1d990:	0003cb56 	.word	0x0003cb56
   1d994:	0003b77f 	.word	0x0003b77f
   1d998:	0003cb8b 	.word	0x0003cb8b

0001d99c <net_context_set_state>:
{
   1d99c:	b538      	push	{r3, r4, r5, lr}
   1d99e:	460d      	mov	r5, r1
	NET_ASSERT(context);
   1d9a0:	4604      	mov	r4, r0
   1d9a2:	b970      	cbnz	r0, 1d9c2 <net_context_set_state+0x26>
   1d9a4:	490b      	ldr	r1, [pc, #44]	; (1d9d4 <net_context_set_state+0x38>)
   1d9a6:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
   1d9aa:	4a0b      	ldr	r2, [pc, #44]	; (1d9d8 <net_context_set_state+0x3c>)
   1d9ac:	480b      	ldr	r0, [pc, #44]	; (1d9dc <net_context_set_state+0x40>)
   1d9ae:	f015 fe0b 	bl	335c8 <printk>
   1d9b2:	480b      	ldr	r0, [pc, #44]	; (1d9e0 <net_context_set_state+0x44>)
   1d9b4:	f015 fe08 	bl	335c8 <printk>
   1d9b8:	f44f 71dc 	mov.w	r1, #440	; 0x1b8
   1d9bc:	4806      	ldr	r0, [pc, #24]	; (1d9d8 <net_context_set_state+0x3c>)
   1d9be:	f016 f904 	bl	33bca <assert_post_action>
	context->flags &= ~(NET_CONTEXT_STATE_MASK << NET_CONTEXT_STATE_SHIFT);
   1d9c2:	f8b4 107a 	ldrh.w	r1, [r4, #122]	; 0x7a
   1d9c6:	f021 0106 	bic.w	r1, r1, #6
	context->flags |= ((state & NET_CONTEXT_STATE_MASK) <<
   1d9ca:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
   1d9ce:	f8a4 107a 	strh.w	r1, [r4, #122]	; 0x7a
}
   1d9d2:	bd38      	pop	{r3, r4, r5, pc}
   1d9d4:	0003cb83 	.word	0x0003cb83
   1d9d8:	0003cb56 	.word	0x0003cb56
   1d9dc:	0003b77f 	.word	0x0003b77f
   1d9e0:	0003cb8b 	.word	0x0003cb8b

0001d9e4 <net_context_get_iface>:
{
   1d9e4:	b510      	push	{r4, lr}
	NET_ASSERT(context);
   1d9e6:	4604      	mov	r4, r0
   1d9e8:	b970      	cbnz	r0, 1da08 <net_context_get_iface+0x24>
   1d9ea:	490a      	ldr	r1, [pc, #40]	; (1da14 <net_context_get_iface+0x30>)
   1d9ec:	f240 2371 	movw	r3, #625	; 0x271
   1d9f0:	4a09      	ldr	r2, [pc, #36]	; (1da18 <net_context_get_iface+0x34>)
   1d9f2:	480a      	ldr	r0, [pc, #40]	; (1da1c <net_context_get_iface+0x38>)
   1d9f4:	f015 fde8 	bl	335c8 <printk>
   1d9f8:	4809      	ldr	r0, [pc, #36]	; (1da20 <net_context_get_iface+0x3c>)
   1d9fa:	f015 fde5 	bl	335c8 <printk>
   1d9fe:	f240 2171 	movw	r1, #625	; 0x271
   1da02:	4805      	ldr	r0, [pc, #20]	; (1da18 <net_context_get_iface+0x34>)
   1da04:	f016 f8e1 	bl	33bca <assert_post_action>
	return net_if_get_by_index(context->iface);
   1da08:	f994 007c 	ldrsb.w	r0, [r4, #124]	; 0x7c
}
   1da0c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return net_if_get_by_index(context->iface);
   1da10:	f7fe bd42 	b.w	1c498 <net_if_get_by_index>
   1da14:	0003cb83 	.word	0x0003cb83
   1da18:	0003cb56 	.word	0x0003cb56
   1da1c:	0003b77f 	.word	0x0003b77f
   1da20:	0003cb8b 	.word	0x0003cb8b

0001da24 <net_context_set_iface.isra.25>:
static inline void net_context_set_iface(struct net_context *context,
   1da24:	b538      	push	{r3, r4, r5, lr}
   1da26:	4605      	mov	r5, r0
	NET_ASSERT(iface);
   1da28:	460c      	mov	r4, r1
   1da2a:	b971      	cbnz	r1, 1da4a <net_context_set_iface.isra.25+0x26>
   1da2c:	4909      	ldr	r1, [pc, #36]	; (1da54 <net_context_set_iface.isra.25+0x30>)
   1da2e:	f240 2381 	movw	r3, #641	; 0x281
   1da32:	4a09      	ldr	r2, [pc, #36]	; (1da58 <net_context_set_iface.isra.25+0x34>)
   1da34:	4809      	ldr	r0, [pc, #36]	; (1da5c <net_context_set_iface.isra.25+0x38>)
   1da36:	f015 fdc7 	bl	335c8 <printk>
   1da3a:	4809      	ldr	r0, [pc, #36]	; (1da60 <net_context_set_iface.isra.25+0x3c>)
   1da3c:	f015 fdc4 	bl	335c8 <printk>
   1da40:	f240 2181 	movw	r1, #641	; 0x281
   1da44:	4804      	ldr	r0, [pc, #16]	; (1da58 <net_context_set_iface.isra.25+0x34>)
   1da46:	f016 f8c0 	bl	33bca <assert_post_action>
	context->iface = net_if_get_by_iface(iface);
   1da4a:	4620      	mov	r0, r4
   1da4c:	f7fe fd36 	bl	1c4bc <net_if_get_by_iface>
   1da50:	7028      	strb	r0, [r5, #0]
}
   1da52:	bd38      	pop	{r3, r4, r5, pc}
   1da54:	0003d9b8 	.word	0x0003d9b8
   1da58:	0003cb56 	.word	0x0003cb56
   1da5c:	0003b77f 	.word	0x0003b77f
   1da60:	0003cb8b 	.word	0x0003cb8b

0001da64 <tcp_backlog_find.isra.26>:
		addr6->sin6_port = port;
		addr->sa_family = AF_INET6;
	}
}

static int tcp_backlog_find(struct net_pkt *pkt,
   1da64:	b570      	push	{r4, r5, r6, lr}
			    int *empty_slot)
{
	int i, empty = -1;

	for (i = 0; i < CONFIG_NET_TCP_BACKLOG_SIZE; i++) {
		if (tcp_backlog[i].tcp == NULL && empty < 0) {
   1da66:	4d12      	ldr	r5, [pc, #72]	; (1dab0 <tcp_backlog_find.isra.26+0x4c>)
static int tcp_backlog_find(struct net_pkt *pkt,
   1da68:	461e      	mov	r6, r3
		if (tcp_backlog[i].tcp == NULL && empty < 0) {
   1da6a:	682c      	ldr	r4, [r5, #0]
   1da6c:	b144      	cbz	r4, 1da80 <tcp_backlog_find.isra.26+0x1c>
   1da6e:	f890 003f 	ldrb.w	r0, [r0, #63]	; 0x3f
			empty = i;
			continue;
		}

		if (net_pkt_family(pkt) != tcp_backlog[i].remote.sa_family) {
   1da72:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
   1da74:	f3c0 0042 	ubfx	r0, r0, #1, #3
   1da78:	4283      	cmp	r3, r0
   1da7a:	d006      	beq.n	1da8a <tcp_backlog_find.isra.26+0x26>
	int i, empty = -1;
   1da7c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		}

		return i;
	}

	if (empty_slot) {
   1da80:	b106      	cbz	r6, 1da84 <tcp_backlog_find.isra.26+0x20>
		*empty_slot = empty;
   1da82:	6034      	str	r4, [r6, #0]
	}

	return -EADDRNOTAVAIL;
   1da84:	f06f 007c 	mvn.w	r0, #124	; 0x7c
   1da88:	e002      	b.n	1da90 <tcp_backlog_find.isra.26+0x2c>
		if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1da8a:	2801      	cmp	r0, #1
   1da8c:	d001      	beq.n	1da92 <tcp_backlog_find.isra.26+0x2e>
	return -EADDRNOTAVAIL;
   1da8e:	2000      	movs	r0, #0
}
   1da90:	bd70      	pop	{r4, r5, r6, pc}
			if (net_sin(&tcp_backlog[i].remote)->sin_port !=
   1da92:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
   1da94:	8813      	ldrh	r3, [r2, #0]
   1da96:	4298      	cmp	r0, r3
   1da98:	d1f0      	bne.n	1da7c <tcp_backlog_find.isra.26+0x18>
				   &ip_hdr->ipv4->src,
   1da9a:	6809      	ldr	r1, [r1, #0]
			if (memcmp(&net_sin(&tcp_backlog[i].remote)->sin_addr,
   1da9c:	2204      	movs	r2, #4
   1da9e:	310c      	adds	r1, #12
   1daa0:	f105 0030 	add.w	r0, r5, #48	; 0x30
   1daa4:	f01b fa8a 	bl	38fbc <memcmp>
   1daa8:	2800      	cmp	r0, #0
   1daaa:	d0f0      	beq.n	1da8e <tcp_backlog_find.isra.26+0x2a>
   1daac:	e7e6      	b.n	1da7c <tcp_backlog_find.isra.26+0x18>
   1daae:	bf00      	nop
   1dab0:	20021d60 	.word	0x20021d60

0001dab4 <prepare_segment.isra.21>:
static int prepare_segment(struct net_tcp *tcp,
   1dab4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dab8:	b08d      	sub	sp, #52	; 0x34
   1daba:	9303      	str	r3, [sp, #12]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   1dabc:	ab07      	add	r3, sp, #28
   1dabe:	9305      	str	r3, [sp, #20]
   1dac0:	2314      	movs	r3, #20
static int prepare_segment(struct net_tcp *tcp,
   1dac2:	460e      	mov	r6, r1
   1dac4:	4614      	mov	r4, r2
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   1dac6:	9306      	str	r3, [sp, #24]
	NET_ASSERT(context);
   1dac8:	4605      	mov	r5, r0
   1daca:	b970      	cbnz	r0, 1daea <prepare_segment.isra.21+0x36>
   1dacc:	4974      	ldr	r1, [pc, #464]	; (1dca0 <prepare_segment.isra.21+0x1ec>)
   1dace:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
   1dad2:	4a74      	ldr	r2, [pc, #464]	; (1dca4 <prepare_segment.isra.21+0x1f0>)
   1dad4:	4874      	ldr	r0, [pc, #464]	; (1dca8 <prepare_segment.isra.21+0x1f4>)
   1dad6:	f015 fd77 	bl	335c8 <printk>
   1dada:	4874      	ldr	r0, [pc, #464]	; (1dcac <prepare_segment.isra.21+0x1f8>)
   1dadc:	f015 fd74 	bl	335c8 <printk>
   1dae0:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
   1dae4:	486f      	ldr	r0, [pc, #444]	; (1dca4 <prepare_segment.isra.21+0x1f0>)
   1dae6:	f016 f870 	bl	33bca <assert_post_action>
	if (pkt) {
   1daea:	2c00      	cmp	r4, #0
   1daec:	f000 8095 	beq.w	1dc1a <prepare_segment.isra.21+0x166>
		pkt->buffer = NULL;
   1daf0:	2300      	movs	r3, #0
		tail = pkt->buffer;
   1daf2:	f8d4 8010 	ldr.w	r8, [r4, #16]
		pkt->buffer = NULL;
   1daf6:	6123      	str	r3, [r4, #16]
		status = net_pkt_alloc_buffer(pkt, segment->optlen,
   1daf8:	2206      	movs	r2, #6
   1dafa:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1dafe:	7af1      	ldrb	r1, [r6, #11]
   1db00:	4620      	mov	r0, r4
   1db02:	f7ff fb89 	bl	1d218 <net_pkt_alloc_buffer>
		if (status) {
   1db06:	4607      	mov	r7, r0
   1db08:	2800      	cmp	r0, #0
   1db0a:	f040 80ab 	bne.w	1dc64 <prepare_segment.isra.21+0x1b0>
		pkt_allocated = false;
   1db0e:	4681      	mov	r9, r0
	pkt->tcp_first_msg = is_1st;
   1db10:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   1db14:	f043 0301 	orr.w	r3, r3, #1
   1db18:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
	pkt->sent_or_eof = sent;
   1db1c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   1db20:	f36f 0341 	bfc	r3, #1, #1
   1db24:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	return pkt->family;
   1db28:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1db2c:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1db30:	2b01      	cmp	r3, #1
   1db32:	f040 80ac 	bne.w	1dc8e <prepare_segment.isra.21+0x1da>
				net_sin_ptr(segment->src_addr)->sin_addr,
   1db36:	e9d6 2304 	ldrd	r2, r3, [r6, #16]
		status = net_context_create_ipv4_new(context, pkt,
   1db3a:	4621      	mov	r1, r4
   1db3c:	3304      	adds	r3, #4
   1db3e:	6852      	ldr	r2, [r2, #4]
   1db40:	4628      	mov	r0, r5
   1db42:	f7ff f859 	bl	1cbf8 <net_context_create_ipv4_new>
		if (status < 0) {
   1db46:	1e07      	subs	r7, r0, #0
   1db48:	f2c0 8089 	blt.w	1dc5e <prepare_segment.isra.21+0x1aa>
		dst_port = net_sin(segment->dst_addr)->sin_port;
   1db4c:	6973      	ldr	r3, [r6, #20]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   1db4e:	a905      	add	r1, sp, #20
		dst_port = net_sin(segment->dst_addr)->sin_port;
   1db50:	885b      	ldrh	r3, [r3, #2]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   1db52:	4620      	mov	r0, r4
		src_port = ((struct sockaddr_in_ptr *)&context->local)->
   1db54:	f8b5 b01e 	ldrh.w	fp, [r5, #30]
		dst_port = net_sin(segment->dst_addr)->sin_port;
   1db58:	9302      	str	r3, [sp, #8]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   1db5a:	f018 faff 	bl	3615c <net_pkt_get_data>
	if (!tcp_hdr) {
   1db5e:	4605      	mov	r5, r0
   1db60:	2800      	cmp	r0, #0
   1db62:	f000 8097 	beq.w	1dc94 <prepare_segment.isra.21+0x1e0>
	if (segment->options && segment->optlen) {
   1db66:	68f3      	ldr	r3, [r6, #12]
   1db68:	2b00      	cmp	r3, #0
   1db6a:	d06f      	beq.n	1dc4c <prepare_segment.isra.21+0x198>
   1db6c:	f896 a00b 	ldrb.w	sl, [r6, #11]
   1db70:	f1ba 0f00 	cmp.w	sl, #0
   1db74:	d007      	beq.n	1db86 <prepare_segment.isra.21+0xd2>
		if ((segment->optlen & 0x3u) != 0u) {
   1db76:	f01a 0f03 	tst.w	sl, #3
   1db7a:	d004      	beq.n	1db86 <prepare_segment.isra.21+0xd2>
			optlen = (segment->optlen & 0xfffCu) + 4u;
   1db7c:	f02a 0303 	bic.w	r3, sl, #3
   1db80:	3304      	adds	r3, #4
   1db82:	fa5f fa83 	uxtb.w	sl, r3
__ssp_bos_icheck3(memset, void *, int)
   1db86:	2210      	movs	r2, #16
   1db88:	2100      	movs	r1, #0
   1db8a:	1d28      	adds	r0, r5, #4
   1db8c:	f01b fa5e 	bl	3904c <memset>
	sys_put_be32(segment->seq, tcp_hdr->seq);
   1db90:	6832      	ldr	r2, [r6, #0]
	tcp_hdr->dst_port = dst_port;
   1db92:	9b02      	ldr	r3, [sp, #8]
 *  @param val 32-bit integer in host endianness.
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_be32(u32_t val, u8_t dst[4])
{
	sys_put_be16(val >> 16, dst);
   1db94:	0c11      	lsrs	r1, r2, #16
	dst[1] = val;
   1db96:	7169      	strb	r1, [r5, #5]
	dst[0] = val >> 8;
   1db98:	0a08      	lsrs	r0, r1, #8
   1db9a:	f3c2 2107 	ubfx	r1, r2, #8, #8
   1db9e:	7128      	strb	r0, [r5, #4]
   1dba0:	71a9      	strb	r1, [r5, #6]
	dst[1] = val;
   1dba2:	71ea      	strb	r2, [r5, #7]
	sys_put_be32(segment->ack, tcp_hdr->ack);
   1dba4:	6872      	ldr	r2, [r6, #4]
	tcp_hdr->src_port = src_port;
   1dba6:	f8a5 b000 	strh.w	fp, [r5]
	sys_put_be16(val >> 16, dst);
   1dbaa:	0c11      	lsrs	r1, r2, #16
	dst[0] = val >> 8;
   1dbac:	0a08      	lsrs	r0, r1, #8
	dst[1] = val;
   1dbae:	7269      	strb	r1, [r5, #9]
   1dbb0:	72ea      	strb	r2, [r5, #11]
	dst[0] = val >> 8;
   1dbb2:	f3c2 2107 	ubfx	r1, r2, #8, #8
	tcp_hdr->offset   = (NET_TCPH_LEN + optlen) << 2;
   1dbb6:	f10a 0214 	add.w	r2, sl, #20
   1dbba:	0092      	lsls	r2, r2, #2
   1dbbc:	7228      	strb	r0, [r5, #8]
   1dbbe:	72a9      	strb	r1, [r5, #10]
   1dbc0:	732a      	strb	r2, [r5, #12]
	tcp_hdr->dst_port = dst_port;
   1dbc2:	806b      	strh	r3, [r5, #2]
	tcp_hdr->flags    = segment->flags;
   1dbc4:	7ab2      	ldrb	r2, [r6, #10]
	net_pkt_set_data(pkt, &tcp_access);
   1dbc6:	4620      	mov	r0, r4
	tcp_hdr->flags    = segment->flags;
   1dbc8:	736a      	strb	r2, [r5, #13]
	sys_put_be16(segment->wnd, tcp_hdr->wnd);
   1dbca:	8932      	ldrh	r2, [r6, #8]
   1dbcc:	0a11      	lsrs	r1, r2, #8
	dst[1] = val;
   1dbce:	73ea      	strb	r2, [r5, #15]
	tcp_hdr->chksum   = 0U;
   1dbd0:	2200      	movs	r2, #0
	dst[0] = val >> 8;
   1dbd2:	73a9      	strb	r1, [r5, #14]
   1dbd4:	742a      	strb	r2, [r5, #16]
   1dbd6:	746a      	strb	r2, [r5, #17]
	tcp_hdr->urg[0]   = 0U;
   1dbd8:	74aa      	strb	r2, [r5, #18]
	tcp_hdr->urg[1]   = 0U;
   1dbda:	74ea      	strb	r2, [r5, #19]
	net_pkt_set_data(pkt, &tcp_access);
   1dbdc:	a905      	add	r1, sp, #20
   1dbde:	f018 fade 	bl	3619e <net_pkt_set_data>
	if (optlen && net_pkt_write(pkt, segment->options, segment->optlen)) {
   1dbe2:	f1ba 0f00 	cmp.w	sl, #0
   1dbe6:	d133      	bne.n	1dc50 <prepare_segment.isra.21+0x19c>
	if (tail) {
   1dbe8:	f1b8 0f00 	cmp.w	r8, #0
   1dbec:	d140      	bne.n	1dc70 <prepare_segment.isra.21+0x1bc>
	net_pkt_cursor_init(pkt);
   1dbee:	4620      	mov	r0, r4
   1dbf0:	f018 f8d6 	bl	35da0 <net_pkt_cursor_init>
   1dbf4:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   1dbf8:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1dbfc:	2b01      	cmp	r3, #1
   1dbfe:	d13c      	bne.n	1dc7a <prepare_segment.isra.21+0x1c6>
		return net_ipv4_finalize(pkt, IPPROTO_TCP);
   1dc00:	2106      	movs	r1, #6
   1dc02:	4620      	mov	r0, r4
   1dc04:	f018 fc33 	bl	3646e <net_ipv4_finalize>
	if (status < 0) {
   1dc08:	1e07      	subs	r7, r0, #0
   1dc0a:	da39      	bge.n	1dc80 <prepare_segment.isra.21+0x1cc>
		if (pkt_allocated) {
   1dc0c:	f1b9 0f00 	cmp.w	r9, #0
   1dc10:	d039      	beq.n	1dc86 <prepare_segment.isra.21+0x1d2>
		net_pkt_unref(pkt);
   1dc12:	4620      	mov	r0, r4
   1dc14:	f018 f860 	bl	35cd8 <net_pkt_unref>
   1dc18:	e035      	b.n	1dc86 <prepare_segment.isra.21+0x1d2>
		pkt = net_pkt_alloc_with_buffer(net_context_get_iface(context),
   1dc1a:	4628      	mov	r0, r5
   1dc1c:	f7ff fee2 	bl	1d9e4 <net_context_get_iface>
   1dc20:	4607      	mov	r7, r0
   1dc22:	4628      	mov	r0, r5
   1dc24:	f896 800b 	ldrb.w	r8, [r6, #11]
   1dc28:	f7ff fe78 	bl	1d91c <net_context_get_family>
   1dc2c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1dc30:	4602      	mov	r2, r0
   1dc32:	9300      	str	r3, [sp, #0]
   1dc34:	4641      	mov	r1, r8
   1dc36:	2306      	movs	r3, #6
   1dc38:	4638      	mov	r0, r7
   1dc3a:	f7ff fbaf 	bl	1d39c <net_pkt_alloc_with_buffer>
		if (!pkt) {
   1dc3e:	b360      	cbz	r0, 1dc9a <prepare_segment.isra.21+0x1e6>
	struct net_buf *tail = NULL;
   1dc40:	46a0      	mov	r8, r4
	pkt->context = ctx;
   1dc42:	61c5      	str	r5, [r0, #28]
   1dc44:	4604      	mov	r4, r0
		pkt_allocated = true;
   1dc46:	f04f 0901 	mov.w	r9, #1
   1dc4a:	e761      	b.n	1db10 <prepare_segment.isra.21+0x5c>
	u8_t optlen = 0U;
   1dc4c:	469a      	mov	sl, r3
   1dc4e:	e79a      	b.n	1db86 <prepare_segment.isra.21+0xd2>
	if (optlen && net_pkt_write(pkt, segment->options, segment->optlen)) {
   1dc50:	7af2      	ldrb	r2, [r6, #11]
   1dc52:	68f1      	ldr	r1, [r6, #12]
   1dc54:	4620      	mov	r0, r4
   1dc56:	f018 fa66 	bl	36126 <net_pkt_write>
   1dc5a:	2800      	cmp	r0, #0
   1dc5c:	d0c4      	beq.n	1dbe8 <prepare_segment.isra.21+0x134>
	if (pkt_allocated) {
   1dc5e:	f1b9 0f00 	cmp.w	r9, #0
   1dc62:	d1d6      	bne.n	1dc12 <prepare_segment.isra.21+0x15e>
		net_buf_unref(pkt->buffer);
   1dc64:	6920      	ldr	r0, [r4, #16]
   1dc66:	f7fe f925 	bl	1beb4 <net_buf_unref>
		pkt->buffer = tail;
   1dc6a:	f8c4 8010 	str.w	r8, [r4, #16]
   1dc6e:	e00a      	b.n	1dc86 <prepare_segment.isra.21+0x1d2>
		net_pkt_append_buffer(pkt, tail);
   1dc70:	4641      	mov	r1, r8
   1dc72:	4620      	mov	r0, r4
   1dc74:	f018 f8c9 	bl	35e0a <net_pkt_append_buffer>
   1dc78:	e7b9      	b.n	1dbee <prepare_segment.isra.21+0x13a>
	return -EINVAL;
   1dc7a:	f06f 0715 	mvn.w	r7, #21
   1dc7e:	e7c5      	b.n	1dc0c <prepare_segment.isra.21+0x158>
	return 0;
   1dc80:	2700      	movs	r7, #0
	*out_pkt = pkt;
   1dc82:	9b03      	ldr	r3, [sp, #12]
   1dc84:	601c      	str	r4, [r3, #0]
}
   1dc86:	4638      	mov	r0, r7
   1dc88:	b00d      	add	sp, #52	; 0x34
   1dc8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		status = -EINVAL;
   1dc8e:	f06f 0715 	mvn.w	r7, #21
   1dc92:	e7e4      	b.n	1dc5e <prepare_segment.isra.21+0x1aa>
		status = -ENOBUFS;
   1dc94:	f06f 0768 	mvn.w	r7, #104	; 0x68
   1dc98:	e7e1      	b.n	1dc5e <prepare_segment.isra.21+0x1aa>
			return -ENOMEM;
   1dc9a:	f06f 070b 	mvn.w	r7, #11
   1dc9e:	e7f2      	b.n	1dc86 <prepare_segment.isra.21+0x1d2>
   1dca0:	0003cb83 	.word	0x0003cb83
   1dca4:	0003dc4d 	.word	0x0003dc4d
   1dca8:	0003b77f 	.word	0x0003b77f
   1dcac:	0003cb8b 	.word	0x0003cb8b

0001dcb0 <net_tcp_alloc>:
{
   1dcb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1dcb2:	4607      	mov	r7, r0
	__asm__ volatile(
   1dcb4:	f04f 0320 	mov.w	r3, #32
   1dcb8:	f3ef 8411 	mrs	r4, BASEPRI
   1dcbc:	f383 8811 	msr	BASEPRI, r3
   1dcc0:	f3bf 8f6f 	isb	sy
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
   1dcc4:	4a26      	ldr	r2, [pc, #152]	; (1dd60 <net_tcp_alloc+0xb0>)
   1dcc6:	2300      	movs	r3, #0
   1dcc8:	4616      	mov	r6, r2
		if (!net_tcp_is_used(&tcp_context[i])) {
   1dcca:	4610      	mov	r0, r2
   1dccc:	f018 fcd3 	bl	36676 <net_tcp_is_used>
   1dcd0:	2800      	cmp	r0, #0
   1dcd2:	d13c      	bne.n	1dd4e <net_tcp_alloc+0x9e>
			tcp_context[i].flags |= NET_TCP_IN_USE;
   1dcd4:	22c0      	movs	r2, #192	; 0xc0
   1dcd6:	fb02 6203 	mla	r2, r2, r3, r6
   1dcda:	f8b2 10bc 	ldrh.w	r1, [r2, #188]	; 0xbc
   1dcde:	f041 0120 	orr.w	r1, r1, #32
   1dce2:	f8a2 10bc 	strh.w	r1, [r2, #188]	; 0xbc
	__asm__ volatile(
   1dce6:	f384 8811 	msr	BASEPRI, r4
   1dcea:	f3bf 8f6f 	isb	sy
	if (i >= NET_MAX_TCP_CONTEXT) {
   1dcee:	2b06      	cmp	r3, #6
   1dcf0:	d033      	beq.n	1dd5a <net_tcp_alloc+0xaa>
	(void)memset(&tcp_context[i], 0, sizeof(struct net_tcp));
   1dcf2:	22c0      	movs	r2, #192	; 0xc0
   1dcf4:	fb02 f403 	mul.w	r4, r2, r3
   1dcf8:	1935      	adds	r5, r6, r4
   1dcfa:	2100      	movs	r1, #0
   1dcfc:	4628      	mov	r0, r5
   1dcfe:	f01b f9a5 	bl	3904c <memset>
	tcp_context[i].state = NET_TCP_CLOSED;
   1dd02:	f104 02b8 	add.w	r2, r4, #184	; 0xb8
   1dd06:	4432      	add	r2, r6
	tcp_context[i].flags = NET_TCP_IN_USE;
   1dd08:	6853      	ldr	r3, [r2, #4]
   1dd0a:	f423 33ff 	bic.w	r3, r3, #130560	; 0x1fe00
   1dd0e:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
   1dd12:	f043 0320 	orr.w	r3, r3, #32
   1dd16:	6053      	str	r3, [r2, #4]
	tcp_context[i].context = context;
   1dd18:	5137      	str	r7, [r6, r4]
 * @return Return a random TCP sequence number
 */
static inline u32_t tcp_init_isn(void)
{
	/* Randomise initial seq number */
	return sys_rand32_get();
   1dd1a:	f000 fffd 	bl	1ed18 <sys_rand32_get>
	tcp_context[i].accept_cb = NULL;
   1dd1e:	2700      	movs	r7, #0
	tcp_context[i].recv_wnd = MIN(NET_TCP_MAX_WIN, NET_TCP_BUF_MAX_LEN);
   1dd20:	4b10      	ldr	r3, [pc, #64]	; (1dd64 <net_tcp_alloc+0xb4>)
	tcp_context[i].send_seq = tcp_init_isn();
   1dd22:	f8c5 0090 	str.w	r0, [r5, #144]	; 0x90
	k_delayed_work_init(&tcp_context[i].retry_timer, tcp_retry_expired);
   1dd26:	f104 0048 	add.w	r0, r4, #72	; 0x48
	tcp_context[i].recv_wnd = MIN(NET_TCP_MAX_WIN, NET_TCP_BUF_MAX_LEN);
   1dd2a:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
	tcp_context[i].accept_cb = NULL;
   1dd2e:	f8c5 709c 	str.w	r7, [r5, #156]	; 0x9c
	k_delayed_work_init(&tcp_context[i].retry_timer, tcp_retry_expired);
   1dd32:	490d      	ldr	r1, [pc, #52]	; (1dd68 <net_tcp_alloc+0xb8>)
   1dd34:	4430      	add	r0, r6
   1dd36:	f01b f875 	bl	38e24 <k_delayed_work_init>
	k_sem_init(&tcp_context[i].connect_wait, 0, UINT_MAX);
   1dd3a:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
	return z_impl_k_sem_init(sem, initial_count, limit);
   1dd3e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   1dd42:	4639      	mov	r1, r7
   1dd44:	4430      	add	r0, r6
   1dd46:	f01a ffec 	bl	38d22 <z_impl_k_sem_init>
}
   1dd4a:	4628      	mov	r0, r5
   1dd4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (i = 0; i < NET_MAX_TCP_CONTEXT; i++) {
   1dd4e:	3301      	adds	r3, #1
   1dd50:	2b06      	cmp	r3, #6
   1dd52:	f102 02c0 	add.w	r2, r2, #192	; 0xc0
   1dd56:	d1b8      	bne.n	1dcca <net_tcp_alloc+0x1a>
   1dd58:	e7c5      	b.n	1dce6 <net_tcp_alloc+0x36>
		return NULL;
   1dd5a:	2500      	movs	r5, #0
   1dd5c:	e7f5      	b.n	1dd4a <net_tcp_alloc+0x9a>
   1dd5e:	bf00      	nop
   1dd60:	20021d98 	.word	0x20021d98
   1dd64:	02180500 	.word	0x02180500
   1dd68:	00036935 	.word	0x00036935

0001dd6c <net_tcp_change_state>:
{
   1dd6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1dd6e:	460d      	mov	r5, r1
	NET_ASSERT(tcp);
   1dd70:	4604      	mov	r4, r0
   1dd72:	b970      	cbnz	r0, 1dd92 <net_tcp_change_state+0x26>
   1dd74:	4922      	ldr	r1, [pc, #136]	; (1de00 <net_tcp_change_state+0x94>)
   1dd76:	f240 5319 	movw	r3, #1305	; 0x519
   1dd7a:	4a22      	ldr	r2, [pc, #136]	; (1de04 <net_tcp_change_state+0x98>)
   1dd7c:	4822      	ldr	r0, [pc, #136]	; (1de08 <net_tcp_change_state+0x9c>)
   1dd7e:	f015 fc23 	bl	335c8 <printk>
   1dd82:	4822      	ldr	r0, [pc, #136]	; (1de0c <net_tcp_change_state+0xa0>)
   1dd84:	f015 fc20 	bl	335c8 <printk>
   1dd88:	f240 5119 	movw	r1, #1305	; 0x519
   1dd8c:	481d      	ldr	r0, [pc, #116]	; (1de04 <net_tcp_change_state+0x98>)
   1dd8e:	f015 ff1c 	bl	33bca <assert_post_action>
 * @param tcp TCP context
 */
#if defined(CONFIG_NET_NATIVE_TCP)
static inline enum net_tcp_state net_tcp_get_state(const struct net_tcp *tcp)
{
	return (enum net_tcp_state)tcp->state;
   1dd92:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
	if (net_tcp_get_state(tcp) == new_state) {
   1dd96:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1dd9a:	42ab      	cmp	r3, r5
   1dd9c:	d02d      	beq.n	1ddfa <net_tcp_change_state+0x8e>
	NET_ASSERT(new_state >= NET_TCP_CLOSED &&
   1dd9e:	2d0a      	cmp	r5, #10
   1dda0:	d90e      	bls.n	1ddc0 <net_tcp_change_state+0x54>
   1dda2:	491b      	ldr	r1, [pc, #108]	; (1de10 <net_tcp_change_state+0xa4>)
   1dda4:	f44f 63a4 	mov.w	r3, #1312	; 0x520
   1dda8:	4a16      	ldr	r2, [pc, #88]	; (1de04 <net_tcp_change_state+0x98>)
   1ddaa:	4817      	ldr	r0, [pc, #92]	; (1de08 <net_tcp_change_state+0x9c>)
   1ddac:	f015 fc0c 	bl	335c8 <printk>
   1ddb0:	4816      	ldr	r0, [pc, #88]	; (1de0c <net_tcp_change_state+0xa0>)
   1ddb2:	f015 fc09 	bl	335c8 <printk>
   1ddb6:	f44f 61a4 	mov.w	r1, #1312	; 0x520
   1ddba:	4812      	ldr	r0, [pc, #72]	; (1de04 <net_tcp_change_state+0x98>)
   1ddbc:	f015 ff05 	bl	33bca <assert_post_action>
	tcp->state = new_state;
   1ddc0:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
   1ddc4:	f005 050f 	and.w	r5, r5, #15
   1ddc8:	f365 3350 	bfi	r3, r5, #13, #4
   1ddcc:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
	if (net_tcp_get_state(tcp) != NET_TCP_CLOSED) {
   1ddd0:	b99d      	cbnz	r5, 1ddfa <net_tcp_change_state+0x8e>
	if (!tcp->context) {
   1ddd2:	6823      	ldr	r3, [r4, #0]
   1ddd4:	b18b      	cbz	r3, 1ddfa <net_tcp_change_state+0x8e>
	if (tcp->context->conn_handler) {
   1ddd6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   1ddd8:	b118      	cbz	r0, 1dde2 <net_tcp_change_state+0x76>
	return net_conn_unregister(handle);
   1ddda:	f7ff fc5f 	bl	1d69c <net_conn_unregister>
		tcp->context->conn_handler = NULL;
   1ddde:	6823      	ldr	r3, [r4, #0]
   1dde0:	62dd      	str	r5, [r3, #44]	; 0x2c
	if (tcp->accept_cb) {
   1dde2:	f8d4 509c 	ldr.w	r5, [r4, #156]	; 0x9c
   1dde6:	b145      	cbz	r5, 1ddfa <net_tcp_change_state+0x8e>
		tcp->accept_cb(tcp->context,
   1dde8:	6820      	ldr	r0, [r4, #0]
   1ddea:	2208      	movs	r2, #8
   1ddec:	4601      	mov	r1, r0
   1ddee:	f851 3b24 	ldr.w	r3, [r1], #36
   1ddf2:	9300      	str	r3, [sp, #0]
   1ddf4:	f06f 037d 	mvn.w	r3, #125	; 0x7d
   1ddf8:	47a8      	blx	r5
}
   1ddfa:	b003      	add	sp, #12
   1ddfc:	bd30      	pop	{r4, r5, pc}
   1ddfe:	bf00      	nop
   1de00:	0003dc88 	.word	0x0003dc88
   1de04:	0003dc4d 	.word	0x0003dc4d
   1de08:	0003b77f 	.word	0x0003b77f
   1de0c:	0003cb8b 	.word	0x0003cb8b
   1de10:	0003dbf3 	.word	0x0003dbf3

0001de14 <net_tcp_release>:
{
   1de14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (!PART_OF_ARRAY(tcp_context, tcp)) {
   1de18:	4604      	mov	r4, r0
   1de1a:	2800      	cmp	r0, #0
   1de1c:	d074      	beq.n	1df08 <net_tcp_release+0xf4>
   1de1e:	4b3c      	ldr	r3, [pc, #240]	; (1df10 <net_tcp_release+0xfc>)
   1de20:	4298      	cmp	r0, r3
   1de22:	d371      	bcc.n	1df08 <net_tcp_release+0xf4>
   1de24:	f503 6390 	add.w	r3, r3, #1152	; 0x480
   1de28:	4298      	cmp	r0, r3
   1de2a:	d26d      	bcs.n	1df08 <net_tcp_release+0xf4>
	k_delayed_work_cancel(&tcp->retry_timer);
   1de2c:	3048      	adds	r0, #72	; 0x48
   1de2e:	f010 fc33 	bl	2e698 <k_delayed_work_cancel>
	sem->count = 0U;
   1de32:	2500      	movs	r5, #0
	k_delayed_work_cancel(&tcp->ack_timer);
   1de34:	f104 0008 	add.w	r0, r4, #8
   1de38:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
   1de3c:	f010 fc2c 	bl	2e698 <k_delayed_work_cancel>
	k_delayed_work_cancel(&tcp->fin_timer);
   1de40:	f104 0028 	add.w	r0, r4, #40	; 0x28
   1de44:	f010 fc28 	bl	2e698 <k_delayed_work_cancel>
	k_delayed_work_cancel(&tcp->timewait_timer);
   1de48:	f104 0068 	add.w	r0, r4, #104	; 0x68
   1de4c:	f010 fc24 	bl	2e698 <k_delayed_work_cancel>
	net_tcp_change_state(tcp, NET_TCP_CLOSED);
   1de50:	4629      	mov	r1, r5
   1de52:	4620      	mov	r0, r4
   1de54:	f7ff ff8a 	bl	1dd6c <net_tcp_change_state>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, pkt, tmp,
   1de58:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   1de5c:	b1d3      	cbz	r3, 1de94 <net_tcp_release+0x80>
   1de5e:	f1b3 0538 	subs.w	r5, r3, #56	; 0x38
   1de62:	d017      	beq.n	1de94 <net_tcp_release+0x80>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1de64:	681e      	ldr	r6, [r3, #0]
   1de66:	b106      	cbz	r6, 1de6a <net_tcp_release+0x56>
   1de68:	3e38      	subs	r6, #56	; 0x38
	parent->next = child;
   1de6a:	f04f 0800 	mov.w	r8, #0
Z_GENLIST_REMOVE(slist, snode)
   1de6e:	462b      	mov	r3, r5
   1de70:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
   1de74:	f853 2f38 	ldr.w	r2, [r3, #56]!
		if (atomic_get(&pkt->atomic_ref) == 0) {
   1de78:	f105 0724 	add.w	r7, r5, #36	; 0x24
   1de7c:	4299      	cmp	r1, r3
	list->head = node;
   1de7e:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	list->tail = node;
   1de82:	bf08      	it	eq
   1de84:	f8c4 208c 	streq.w	r2, [r4, #140]	; 0x8c
	parent->next = child;
   1de88:	f8c5 8038 	str.w	r8, [r5, #56]	; 0x38
   1de8c:	e8d7 3faf 	lda	r3, [r7]
   1de90:	b9d3      	cbnz	r3, 1dec8 <net_tcp_release+0xb4>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, pkt, tmp,
   1de92:	bb9e      	cbnz	r6, 1defc <net_tcp_release+0xe8>
	tcp->context = NULL;
   1de94:	2000      	movs	r0, #0
   1de96:	6020      	str	r0, [r4, #0]
	__asm__ volatile(
   1de98:	f04f 0320 	mov.w	r3, #32
   1de9c:	f3ef 8111 	mrs	r1, BASEPRI
   1dea0:	f383 8811 	msr	BASEPRI, r3
   1dea4:	f3bf 8f6f 	isb	sy
	tcp->flags &= ~(NET_TCP_IN_USE | NET_TCP_RECV_MSS_SET);
   1dea8:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
   1deac:	f3c3 1247 	ubfx	r2, r3, #5, #8
   1deb0:	f022 0221 	bic.w	r2, r2, #33	; 0x21
   1deb4:	f362 134c 	bfi	r3, r2, #5, #8
   1deb8:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
	__asm__ volatile(
   1debc:	f381 8811 	msr	BASEPRI, r1
   1dec0:	f3bf 8f6f 	isb	sy
}
   1dec4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_pkt_unref(pkt);
   1dec8:	4628      	mov	r0, r5
   1deca:	f017 ff05 	bl	35cd8 <net_pkt_unref>
   1dece:	e8d7 3faf 	lda	r3, [r7]
		if (refcount > 0) {
   1ded2:	2b00      	cmp	r3, #0
   1ded4:	461f      	mov	r7, r3
   1ded6:	dddc      	ble.n	1de92 <net_tcp_release+0x7e>
   1ded8:	f105 0208 	add.w	r2, r5, #8
   1dedc:	e8d2 2faf 	lda	r2, [r2]
			if (k_work_pending(net_pkt_work(pkt)) ||
   1dee0:	07d1      	lsls	r1, r2, #31
   1dee2:	d403      	bmi.n	1deec <net_tcp_release+0xd8>
	return pkt->sent_or_eof;
   1dee4:	f895 203d 	ldrb.w	r2, [r5, #61]	; 0x3d
   1dee8:	0792      	lsls	r2, r2, #30
   1deea:	d500      	bpl.n	1deee <net_tcp_release+0xda>
				refcount--;
   1deec:	1e5f      	subs	r7, r3, #1
			while (refcount) {
   1deee:	2f00      	cmp	r7, #0
   1def0:	d0cf      	beq.n	1de92 <net_tcp_release+0x7e>
				net_pkt_unref(pkt);
   1def2:	4628      	mov	r0, r5
   1def4:	f017 fef0 	bl	35cd8 <net_pkt_unref>
				refcount--;
   1def8:	3f01      	subs	r7, #1
   1defa:	e7f8      	b.n	1deee <net_tcp_release+0xda>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1defc:	6bb3      	ldr	r3, [r6, #56]	; 0x38
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&tcp->sent_list, pkt, tmp,
   1defe:	b103      	cbz	r3, 1df02 <net_tcp_release+0xee>
   1df00:	3b38      	subs	r3, #56	; 0x38
{
   1df02:	4635      	mov	r5, r6
   1df04:	461e      	mov	r6, r3
   1df06:	e7b2      	b.n	1de6e <net_tcp_release+0x5a>
		return -EINVAL;
   1df08:	f06f 0015 	mvn.w	r0, #21
   1df0c:	e7da      	b.n	1dec4 <net_tcp_release+0xb0>
   1df0e:	bf00      	nop
   1df10:	20021d98 	.word	0x20021d98

0001df14 <net_tcp_queue_data>:
{
   1df14:	b570      	push	{r4, r5, r6, lr}
   1df16:	4604      	mov	r4, r0
 *
 * @return Number of bytes in the buffer and its fragments.
 */
static inline size_t net_buf_frags_len(struct net_buf *buf)
{
	size_t bytes = 0;
   1df18:	2500      	movs	r5, #0
   1df1a:	b086      	sub	sp, #24
	struct net_conn *conn = (struct net_conn *)context->conn_handler;
   1df1c:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
	size_t data_len = net_pkt_get_len(pkt);
   1df1e:	690b      	ldr	r3, [r1, #16]
{
   1df20:	9105      	str	r1, [sp, #20]

	while (buf) {
   1df22:	bba3      	cbnz	r3, 1df8e <net_tcp_queue_data+0x7a>
	if (net_context_get_state(context) != NET_CONTEXT_CONNECTED) {
   1df24:	4620      	mov	r0, r4
   1df26:	f7ff fd19 	bl	1d95c <net_context_get_state>
   1df2a:	2802      	cmp	r0, #2
   1df2c:	d133      	bne.n	1df96 <net_tcp_queue_data+0x82>
	NET_ASSERT(context->tcp);
   1df2e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1df30:	b973      	cbnz	r3, 1df50 <net_tcp_queue_data+0x3c>
   1df32:	491c      	ldr	r1, [pc, #112]	; (1dfa4 <net_tcp_queue_data+0x90>)
   1df34:	f240 3366 	movw	r3, #870	; 0x366
   1df38:	4a1b      	ldr	r2, [pc, #108]	; (1dfa8 <net_tcp_queue_data+0x94>)
   1df3a:	481c      	ldr	r0, [pc, #112]	; (1dfac <net_tcp_queue_data+0x98>)
   1df3c:	f015 fb44 	bl	335c8 <printk>
   1df40:	481b      	ldr	r0, [pc, #108]	; (1dfb0 <net_tcp_queue_data+0x9c>)
   1df42:	f015 fb41 	bl	335c8 <printk>
   1df46:	f240 3166 	movw	r1, #870	; 0x366
   1df4a:	4817      	ldr	r0, [pc, #92]	; (1dfa8 <net_tcp_queue_data+0x94>)
   1df4c:	f015 fe3d 	bl	33bca <assert_post_action>
	if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
   1df50:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1df52:	f8b0 30bc 	ldrh.w	r3, [r0, #188]	; 0xbc
   1df56:	f3c3 1347 	ubfx	r3, r3, #5, #8
   1df5a:	f013 0308 	ands.w	r3, r3, #8
   1df5e:	d11d      	bne.n	1df9c <net_tcp_queue_data+0x88>
	ret = net_tcp_prepare_segment(context->tcp, NET_TCP_PSH | NET_TCP_ACK,
   1df60:	aa05      	add	r2, sp, #20
				      NULL, 0, NULL, &conn->remote_addr, &pkt);
   1df62:	3604      	adds	r6, #4
	ret = net_tcp_prepare_segment(context->tcp, NET_TCP_PSH | NET_TCP_ACK,
   1df64:	9202      	str	r2, [sp, #8]
   1df66:	e9cd 3600 	strd	r3, r6, [sp]
   1df6a:	461a      	mov	r2, r3
   1df6c:	2118      	movs	r1, #24
   1df6e:	f018 fd6e 	bl	36a4e <net_tcp_prepare_segment>
	if (ret) {
   1df72:	b950      	cbnz	r0, 1df8a <net_tcp_queue_data+0x76>
	context->tcp->send_seq += data_len;
   1df74:	4620      	mov	r0, r4
   1df76:	f850 2f3c 	ldr.w	r2, [r0, #60]!
	return net_tcp_queue_pkt(context, pkt);
   1df7a:	9905      	ldr	r1, [sp, #20]
	context->tcp->send_seq += data_len;
   1df7c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   1df80:	441d      	add	r5, r3
   1df82:	f8c2 5090 	str.w	r5, [r2, #144]	; 0x90
	return net_tcp_queue_pkt(context, pkt);
   1df86:	f018 fb7b 	bl	36680 <net_tcp_queue_pkt.isra.22>
}
   1df8a:	b006      	add	sp, #24
   1df8c:	bd70      	pop	{r4, r5, r6, pc}
		bytes += buf->len;
   1df8e:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   1df90:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   1df92:	4415      	add	r5, r2
		buf = buf->frags;
   1df94:	e7c5      	b.n	1df22 <net_tcp_queue_data+0xe>
		return -ENOTCONN;
   1df96:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1df9a:	e7f6      	b.n	1df8a <net_tcp_queue_data+0x76>
		return -ESHUTDOWN;
   1df9c:	f06f 006d 	mvn.w	r0, #109	; 0x6d
   1dfa0:	e7f3      	b.n	1df8a <net_tcp_queue_data+0x76>
   1dfa2:	bf00      	nop
   1dfa4:	0003dc7f 	.word	0x0003dc7f
   1dfa8:	0003dc4d 	.word	0x0003dc4d
   1dfac:	0003b77f 	.word	0x0003b77f
   1dfb0:	0003cb8b 	.word	0x0003cb8b

0001dfb4 <tcp_established>:
 *				    union net_ip_header *ip_hdr,
 *				    union net_proto_header *proto_hdr,
 *				    struct net_pkt *pkt,
 *                                  void *user_data)
 */
NET_CONN_CB(tcp_established)
   1dfb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1dfb8:	469b      	mov	fp, r3
   1dfba:	b087      	sub	sp, #28
   1dfbc:	9c10      	ldr	r4, [sp, #64]	; 0x40
   1dfbe:	4681      	mov	r9, r0
   1dfc0:	4620      	mov	r0, r4
   1dfc2:	4688      	mov	r8, r1
   1dfc4:	9204      	str	r2, [sp, #16]
   1dfc6:	f017 fce6 	bl	35996 <net_context_ref>
	enum net_verdict ret = NET_OK;
	bool do_not_send_ack = false;
	u8_t tcp_flags;
	u16_t data_len;

	k_mutex_lock(&context->lock, K_FOREVER);
   1dfca:	f104 0308 	add.w	r3, r4, #8
	struct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;
   1dfce:	f8db 7000 	ldr.w	r7, [fp]
	k_mutex_lock(&context->lock, K_FOREVER);
   1dfd2:	9303      	str	r3, [sp, #12]
	return z_impl_k_mutex_lock(mutex, timeout);
   1dfd4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1dfd8:	9803      	ldr	r0, [sp, #12]
   1dfda:	f00e fb17 	bl	2c60c <z_impl_k_mutex_lock>

	NET_ASSERT(context && context->tcp);
   1dfde:	b10c      	cbz	r4, 1dfe4 <tcp_established+0x30>
   1dfe0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1dfe2:	b973      	cbnz	r3, 1e002 <tcp_established+0x4e>
   1dfe4:	497b      	ldr	r1, [pc, #492]	; (1e1d4 <tcp_established+0x220>)
   1dfe6:	f640 0304 	movw	r3, #2052	; 0x804
   1dfea:	4a7b      	ldr	r2, [pc, #492]	; (1e1d8 <tcp_established+0x224>)
   1dfec:	487b      	ldr	r0, [pc, #492]	; (1e1dc <tcp_established+0x228>)
   1dfee:	f015 faeb 	bl	335c8 <printk>
   1dff2:	487b      	ldr	r0, [pc, #492]	; (1e1e0 <tcp_established+0x22c>)
   1dff4:	f015 fae8 	bl	335c8 <printk>
   1dff8:	f640 0104 	movw	r1, #2052	; 0x804
   1dffc:	4876      	ldr	r0, [pc, #472]	; (1e1d8 <tcp_established+0x224>)
   1dffe:	f015 fde4 	bl	33bca <assert_post_action>

	if (net_tcp_get_state(context->tcp) < NET_TCP_ESTABLISHED) {
   1e002:	f8d4 a03c 	ldr.w	sl, [r4, #60]	; 0x3c
	return (enum net_tcp_state)tcp->state;
   1e006:	f8da 30bc 	ldr.w	r3, [sl, #188]	; 0xbc
   1e00a:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e00e:	2b03      	cmp	r3, #3
   1e010:	d80a      	bhi.n	1e028 <tcp_established+0x74>
					 context->tcp->recv_user_data);
		}

		net_context_unref(context);

		ret = NET_DROP;
   1e012:	2602      	movs	r6, #2
	return z_impl_k_mutex_unlock(mutex);
   1e014:	9803      	ldr	r0, [sp, #12]
   1e016:	f00e fbd7 	bl	2c7c8 <z_impl_k_mutex_unlock>
NET_CONN_CB(tcp_established)
   1e01a:	4620      	mov	r0, r4
   1e01c:	f017 fcc5 	bl	359aa <net_context_unref>
   1e020:	4630      	mov	r0, r6
   1e022:	b007      	add	sp, #28
   1e024:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
   1e028:	1d38      	adds	r0, r7, #4
   1e02a:	f018 fb15 	bl	36658 <sys_get_be32>
 *
 * @return < 0 if seq1 < seq2, 0 if seq1 == seq2, > 0 if seq > seq2
 */
static inline s32_t net_tcp_seq_cmp(u32_t seq1, u32_t seq2)
{
	return (s32_t)(seq1 - seq2);
   1e02e:	f8da 3094 	ldr.w	r3, [sl, #148]	; 0x94
   1e032:	1ac3      	subs	r3, r0, r3
   1e034:	2b00      	cmp	r3, #0
   1e036:	da06      	bge.n	1e046 <tcp_established+0x92>
		send_ack(context, &conn->remote_addr, true);
   1e038:	2201      	movs	r2, #1
   1e03a:	f109 0104 	add.w	r1, r9, #4
   1e03e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e040:	f018 fd9c 	bl	36b7c <send_ack.isra.34>
		goto unlock;
   1e044:	e7e5      	b.n	1e012 <tcp_established+0x5e>
   1e046:	9305      	str	r3, [sp, #20]
	if (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
   1e048:	d1e3      	bne.n	1e012 <tcp_established+0x5e>
	tcp_flags = NET_TCP_FLAGS(tcp_hdr);
   1e04a:	7b7d      	ldrb	r5, [r7, #13]
	if (tcp_flags & NET_TCP_RST) {
   1e04c:	f015 0604 	ands.w	r6, r5, #4
   1e050:	d016      	beq.n	1e080 <tcp_established+0xcc>
		if (!net_tcp_validate_seq(context->tcp, tcp_hdr)) {
   1e052:	4639      	mov	r1, r7
   1e054:	4650      	mov	r0, sl
   1e056:	f018 fee1 	bl	36e1c <net_tcp_validate_seq>
   1e05a:	2800      	cmp	r0, #0
   1e05c:	d0d9      	beq.n	1e012 <tcp_established+0x5e>
		if (context->recv_cb) {
   1e05e:	6b25      	ldr	r5, [r4, #48]	; 0x30
   1e060:	b155      	cbz	r5, 1e078 <tcp_established+0xc4>
			context->recv_cb(context, NULL, NULL, NULL, -ECONNRESET,
   1e062:	f8da 2004 	ldr.w	r2, [sl, #4]
   1e066:	9b05      	ldr	r3, [sp, #20]
   1e068:	9201      	str	r2, [sp, #4]
   1e06a:	f06f 0267 	mvn.w	r2, #103	; 0x67
   1e06e:	4619      	mov	r1, r3
   1e070:	9200      	str	r2, [sp, #0]
   1e072:	4620      	mov	r0, r4
   1e074:	461a      	mov	r2, r3
   1e076:	47a8      	blx	r5
		net_context_unref(context);
   1e078:	4620      	mov	r0, r4
   1e07a:	f017 fc96 	bl	359aa <net_context_unref>
   1e07e:	e7c8      	b.n	1e012 <tcp_established+0x5e>
		goto unlock;
	}

	/* Handle TCP state transition */
	if (tcp_flags & NET_TCP_ACK) {
   1e080:	06ea      	lsls	r2, r5, #27
   1e082:	d513      	bpl.n	1e0ac <tcp_established+0xf8>
		if (!net_tcp_ack_received(context,
   1e084:	f107 0008 	add.w	r0, r7, #8
   1e088:	f018 fae6 	bl	36658 <sys_get_be32>
   1e08c:	4601      	mov	r1, r0
   1e08e:	4620      	mov	r0, r4
   1e090:	f018 fdc6 	bl	36c20 <net_tcp_ack_received>
   1e094:	2800      	cmp	r0, #0
   1e096:	d0bc      	beq.n	1e012 <tcp_established+0x5e>

		/* TCP state might be changed after maintaining the sent pkt
		 * list, e.g., an ack of FIN is received.
		 */

		if (net_tcp_get_state(context->tcp)
   1e098:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e09a:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   1e09e:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e0a2:	2b07      	cmp	r3, #7
   1e0a4:	d133      	bne.n	1e10e <tcp_established+0x15a>
			   == NET_TCP_FIN_WAIT_1) {
			/* Active close: step to FIN_WAIT_2 */
			net_tcp_change_state(context->tcp, NET_TCP_FIN_WAIT_2);
   1e0a6:	2108      	movs	r1, #8
   1e0a8:	f7ff fe60 	bl	1dd6c <net_tcp_change_state>
			net_pkt_unref(pkt);
			goto clean_up;
		}
	}

	if (tcp_flags & NET_TCP_FIN) {
   1e0ac:	f015 0301 	ands.w	r3, r5, #1
   1e0b0:	469a      	mov	sl, r3
   1e0b2:	d01c      	beq.n	1e0ee <tcp_established+0x13a>
		if (net_tcp_get_state(context->tcp) == NET_TCP_ESTABLISHED) {
   1e0b4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e0b6:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   1e0ba:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e0be:	2b04      	cmp	r3, #4
   1e0c0:	d14d      	bne.n	1e15e <tcp_established+0x1aa>
			/* Passive close: step to CLOSE_WAIT */
			net_tcp_change_state(context->tcp, NET_TCP_CLOSE_WAIT);
   1e0c2:	2105      	movs	r1, #5
   1e0c4:	f7ff fe52 	bl	1dd6c <net_tcp_change_state>
			/* We should receive ACK next in order to get rid of
			 * LAST_ACK state that we are entering in a short while.
			 * But we need to be prepared to NOT to receive it as
			 * otherwise the connection would be stuck forever.
			 */
			k_delayed_work_submit(&context->tcp->ack_timer,
   1e0c8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e0ca:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e0ce:	3008      	adds	r0, #8
   1e0d0:	f7ff fc1c 	bl	1d90c <k_delayed_work_submit>
		context->flags |= NET_CONTEXT_CLOSING_SOCK;
   1e0d4:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
   1e0d8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   1e0dc:	f8a4 307a 	strh.w	r3, [r4, #122]	; 0x7a
			k_delayed_work_cancel(&context->tcp->fin_timer);
			/* Active close: step to TIME_WAIT */
			net_tcp_change_state(context->tcp, NET_TCP_TIME_WAIT);
		}

		context->tcp->fin_rcvd = 1U;
   1e0e0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   1e0e2:	f892 30be 	ldrb.w	r3, [r2, #190]	; 0xbe
   1e0e6:	f043 0304 	orr.w	r3, r3, #4
   1e0ea:	f882 30be 	strb.w	r3, [r2, #190]	; 0xbe
	}

	if (!IS_ENABLED(CONFIG_NET_TCP_AUTO_ACCEPT) &&
   1e0ee:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
   1e0f2:	059b      	lsls	r3, r3, #22
   1e0f4:	d464      	bmi.n	1e1c0 <tcp_established+0x20c>
	    net_context_is_accepting(context)) {
		data_len = 0;
		do_not_send_ack = true;
	} else {
		data_len = net_pkt_remaining_data(pkt);
   1e0f6:	4640      	mov	r0, r8
   1e0f8:	f017 ff56 	bl	35fa8 <net_pkt_remaining_data>
	return tcp->recv_wnd;
   1e0fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
		data_len = net_pkt_remaining_data(pkt);
   1e0fe:	b285      	uxth	r5, r0
	}

	if (data_len > net_tcp_get_recv_wnd(context->tcp)) {
   1e100:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
   1e104:	42ab      	cmp	r3, r5
   1e106:	d234      	bcs.n	1e172 <tcp_established+0x1be>
		 * for net_tcp_get_recv_wnd(context->tcp) == 0, but
		 * given the if above, we know that if data_len == 1,
		 * then net_tcp_get_recv_wnd(context->tcp) can be only 0
		 * here.
		 */
		if (data_len == 1U) {
   1e108:	2d01      	cmp	r5, #1
   1e10a:	d182      	bne.n	1e012 <tcp_established+0x5e>
   1e10c:	e794      	b.n	1e038 <tcp_established+0x84>
		} else if (net_tcp_get_state(context->tcp)
   1e10e:	2b06      	cmp	r3, #6
   1e110:	d1cc      	bne.n	1e0ac <tcp_established+0xf8>
			net_tcp_change_state(context->tcp, NET_TCP_CLOSED);
   1e112:	4631      	mov	r1, r6
   1e114:	f7ff fe2a 	bl	1dd6c <net_tcp_change_state>
			net_pkt_unref(pkt);
   1e118:	4640      	mov	r0, r8
   1e11a:	f017 fddd 	bl	35cd8 <net_pkt_unref>

		send_ack(context, &conn->remote_addr, false);
	}

clean_up:
	if (net_tcp_get_state(context->tcp) == NET_TCP_TIME_WAIT) {
   1e11e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e120:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   1e124:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e128:	2b09      	cmp	r3, #9
   1e12a:	d103      	bne.n	1e134 <tcp_established+0x180>
		k_delayed_work_submit(&context->tcp->timewait_timer,
   1e12c:	21fa      	movs	r1, #250	; 0xfa
   1e12e:	3068      	adds	r0, #104	; 0x68
   1e130:	f7ff fbec 	bl	1d90c <k_delayed_work_submit>
				      K_MSEC(CONFIG_NET_TCP_TIME_WAIT_DELAY));
	}

	if (net_tcp_get_state(context->tcp) == NET_TCP_CLOSED) {
   1e134:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   1e136:	f8d2 30bc 	ldr.w	r3, [r2, #188]	; 0xbc
   1e13a:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e13e:	2b00      	cmp	r3, #0
   1e140:	f47f af68 	bne.w	1e014 <tcp_established+0x60>
		if (context->recv_cb) {
   1e144:	6b25      	ldr	r5, [r4, #48]	; 0x30
   1e146:	b135      	cbz	r5, 1e156 <tcp_established+0x1a2>
			context->recv_cb(context, NULL, NULL, NULL, 0,
   1e148:	6852      	ldr	r2, [r2, #4]
   1e14a:	4619      	mov	r1, r3
   1e14c:	e9cd 3200 	strd	r3, r2, [sp]
   1e150:	4620      	mov	r0, r4
   1e152:	461a      	mov	r2, r3
   1e154:	47a8      	blx	r5
					 context->tcp->recv_user_data);
		}

		net_context_unref(context);
   1e156:	4620      	mov	r0, r4
   1e158:	f017 fc27 	bl	359aa <net_context_unref>
   1e15c:	e75a      	b.n	1e014 <tcp_established+0x60>
		} else if (net_tcp_get_state(context->tcp)
   1e15e:	2b08      	cmp	r3, #8
   1e160:	d1be      	bne.n	1e0e0 <tcp_established+0x12c>
			k_delayed_work_cancel(&context->tcp->fin_timer);
   1e162:	3028      	adds	r0, #40	; 0x28
   1e164:	f010 fa98 	bl	2e698 <k_delayed_work_cancel>
			net_tcp_change_state(context->tcp, NET_TCP_TIME_WAIT);
   1e168:	2109      	movs	r1, #9
   1e16a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e16c:	f7ff fdfe 	bl	1dd6c <net_tcp_change_state>
   1e170:	e7b6      	b.n	1e0e0 <tcp_established+0x12c>
	if (data_len > 0) {
   1e172:	b335      	cbz	r5, 1e1c2 <tcp_established+0x20e>
	u8_t offset = tcp_hdr->offset >> 4;
   1e174:	7b3e      	ldrb	r6, [r7, #12]
   1e176:	0936      	lsrs	r6, r6, #4
	if ((offset << 2) > sizeof(struct net_tcp_hdr)) {
   1e178:	00b6      	lsls	r6, r6, #2
   1e17a:	2e14      	cmp	r6, #20
   1e17c:	dd08      	ble.n	1e190 <tcp_established+0x1dc>
		net_pkt_skip(pkt, (offset << 2) -
   1e17e:	f1a6 0114 	sub.w	r1, r6, #20
   1e182:	4640      	mov	r0, r8
   1e184:	f017 fe96 	bl	35eb4 <net_pkt_skip>
		data_len -= (offset << 2) - sizeof(struct net_tcp_hdr);
   1e188:	f1c6 0614 	rsb	r6, r6, #20
   1e18c:	4435      	add	r5, r6
   1e18e:	b2ad      	uxth	r5, r5
		ret = net_context_packet_received(conn, pkt, ip_hdr, proto_hdr,
   1e190:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e192:	9a04      	ldr	r2, [sp, #16]
   1e194:	685b      	ldr	r3, [r3, #4]
   1e196:	4641      	mov	r1, r8
   1e198:	9300      	str	r3, [sp, #0]
   1e19a:	4648      	mov	r0, r9
   1e19c:	465b      	mov	r3, fp
   1e19e:	f7fe fb01 	bl	1c7a4 <net_context_packet_received>
   1e1a2:	4606      	mov	r6, r0
		context->tcp->send_ack += data_len;
   1e1a4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e1a6:	f8d0 3094 	ldr.w	r3, [r0, #148]	; 0x94
   1e1aa:	441d      	add	r5, r3
		if (tcp_flags & NET_TCP_FIN) {
   1e1ac:	4653      	mov	r3, sl
   1e1ae:	b973      	cbnz	r3, 1e1ce <tcp_established+0x21a>
			context->tcp->send_ack += 1U;
   1e1b0:	f8c0 5094 	str.w	r5, [r0, #148]	; 0x94
		send_ack(context, &conn->remote_addr, false);
   1e1b4:	2200      	movs	r2, #0
   1e1b6:	f109 0104 	add.w	r1, r9, #4
   1e1ba:	f018 fcdf 	bl	36b7c <send_ack.isra.34>
   1e1be:	e7ae      	b.n	1e11e <tcp_established+0x16a>
		do_not_send_ack = true;
   1e1c0:	2501      	movs	r5, #1
		net_pkt_unref(pkt);
   1e1c2:	4640      	mov	r0, r8
   1e1c4:	f017 fd88 	bl	35cd8 <net_pkt_unref>
	if (do_not_send_ack == false) {
   1e1c8:	2d00      	cmp	r5, #0
   1e1ca:	d1a8      	bne.n	1e11e <tcp_established+0x16a>
   1e1cc:	e7ea      	b.n	1e1a4 <tcp_established+0x1f0>
			context->tcp->send_ack += 1U;
   1e1ce:	3501      	adds	r5, #1
   1e1d0:	e7ee      	b.n	1e1b0 <tcp_established+0x1fc>
   1e1d2:	bf00      	nop
   1e1d4:	0003dc74 	.word	0x0003dc74
   1e1d8:	0003dc4d 	.word	0x0003dc4d
   1e1dc:	0003b77f 	.word	0x0003b77f
   1e1e0:	0003cb8b 	.word	0x0003cb8b

0001e1e4 <tcp_synack_received>:
 *					struct net_pkt *pkt,
 *				        union net_ip_header *ip_hdr,
 *				        union net_proto_header *proto_hdr,
 *					void *user_data)
 */
NET_CONN_CB(tcp_synack_received)
   1e1e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1e1e8:	461d      	mov	r5, r3
   1e1ea:	b08a      	sub	sp, #40	; 0x28
   1e1ec:	9c10      	ldr	r4, [sp, #64]	; 0x40
   1e1ee:	460e      	mov	r6, r1
   1e1f0:	4620      	mov	r0, r4
   1e1f2:	4690      	mov	r8, r2
   1e1f4:	f017 fbcf 	bl	35996 <net_context_ref>
   1e1f8:	682d      	ldr	r5, [r5, #0]
{
	struct net_context *context = (struct net_context *)user_data;
	struct net_tcp_hdr *tcp_hdr = proto_hdr->tcp;
	int ret;

	NET_ASSERT(context && context->tcp);
   1e1fa:	b10c      	cbz	r4, 1e200 <tcp_synack_received+0x1c>
   1e1fc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e1fe:	b973      	cbnz	r3, 1e21e <tcp_synack_received+0x3a>
   1e200:	4958      	ldr	r1, [pc, #352]	; (1e364 <tcp_synack_received+0x180>)
   1e202:	f640 03cd 	movw	r3, #2253	; 0x8cd
   1e206:	4a58      	ldr	r2, [pc, #352]	; (1e368 <tcp_synack_received+0x184>)
   1e208:	4858      	ldr	r0, [pc, #352]	; (1e36c <tcp_synack_received+0x188>)
   1e20a:	f015 f9dd 	bl	335c8 <printk>
   1e20e:	4858      	ldr	r0, [pc, #352]	; (1e370 <tcp_synack_received+0x18c>)
   1e210:	f015 f9da 	bl	335c8 <printk>
   1e214:	f640 01cd 	movw	r1, #2253	; 0x8cd
   1e218:	4853      	ldr	r0, [pc, #332]	; (1e368 <tcp_synack_received+0x184>)
   1e21a:	f015 fcd6 	bl	33bca <assert_post_action>
   1e21e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e220:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc

	switch (net_tcp_get_state(context->tcp)) {
   1e224:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e228:	2b02      	cmp	r3, #2
   1e22a:	d17d      	bne.n	1e328 <tcp_synack_received+0x144>
	case NET_TCP_SYN_SENT:
		net_context_set_iface(context, net_pkt_iface(pkt));
   1e22c:	6a31      	ldr	r1, [r6, #32]
   1e22e:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   1e232:	f7ff fbf7 	bl	1da24 <net_context_set_iface.isra.25>
		return NET_DROP;
	}

	net_pkt_set_context(pkt, context);

	NET_ASSERT(net_pkt_iface(pkt));
   1e236:	6a33      	ldr	r3, [r6, #32]
	pkt->context = ctx;
   1e238:	61f4      	str	r4, [r6, #28]
   1e23a:	b973      	cbnz	r3, 1e25a <tcp_synack_received+0x76>
   1e23c:	494d      	ldr	r1, [pc, #308]	; (1e374 <tcp_synack_received+0x190>)
   1e23e:	f640 03db 	movw	r3, #2267	; 0x8db
   1e242:	4a49      	ldr	r2, [pc, #292]	; (1e368 <tcp_synack_received+0x184>)
   1e244:	4849      	ldr	r0, [pc, #292]	; (1e36c <tcp_synack_received+0x188>)
   1e246:	f015 f9bf 	bl	335c8 <printk>
   1e24a:	4849      	ldr	r0, [pc, #292]	; (1e370 <tcp_synack_received+0x18c>)
   1e24c:	f015 f9bc 	bl	335c8 <printk>
   1e250:	f640 01db 	movw	r1, #2267	; 0x8db
   1e254:	4844      	ldr	r0, [pc, #272]	; (1e368 <tcp_synack_received+0x184>)
   1e256:	f015 fcb8 	bl	33bca <assert_post_action>

	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {
   1e25a:	7b6f      	ldrb	r7, [r5, #13]
   1e25c:	077a      	lsls	r2, r7, #29
   1e25e:	d513      	bpl.n	1e288 <tcp_synack_received+0xa4>
		/* We only accept RST packet that has valid seq field. */
		if (!net_tcp_validate_seq(context->tcp, tcp_hdr)) {
   1e260:	6be6      	ldr	r6, [r4, #60]	; 0x3c
   1e262:	4629      	mov	r1, r5
   1e264:	4630      	mov	r0, r6
   1e266:	f018 fdd9 	bl	36e1c <net_tcp_validate_seq>
   1e26a:	2800      	cmp	r0, #0
   1e26c:	d05c      	beq.n	1e328 <tcp_synack_received+0x144>
	z_impl_k_sem_give(sem);
   1e26e:	f106 00a0 	add.w	r0, r6, #160	; 0xa0
   1e272:	f00f febb 	bl	2dfec <z_impl_k_sem_give>

		net_stats_update_tcp_seg_rst(net_pkt_iface(pkt));

		k_sem_give(&context->tcp->connect_wait);

		if (context->connect_cb) {
   1e276:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1e278:	2b00      	cmp	r3, #0
   1e27a:	d055      	beq.n	1e328 <tcp_synack_received+0x144>
			context->connect_cb(context, -ECONNREFUSED,
   1e27c:	f06f 016e 	mvn.w	r1, #110	; 0x6e
   1e280:	6822      	ldr	r2, [r4, #0]
		send_ack(context, &remote_addr, false);

		k_sem_give(&context->tcp->connect_wait);

		if (context->connect_cb) {
			context->connect_cb(context, 0, context->user_data);
   1e282:	4620      	mov	r0, r4
   1e284:	4798      	blx	r3
   1e286:	e04f      	b.n	1e328 <tcp_synack_received+0x144>
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_SYN) {
   1e288:	07bb      	lsls	r3, r7, #30
   1e28a:	d506      	bpl.n	1e29a <tcp_synack_received+0xb6>
			sys_get_be32(tcp_hdr->seq) + 1;
   1e28c:	1d28      	adds	r0, r5, #4
   1e28e:	f018 f9e3 	bl	36658 <sys_get_be32>
		context->tcp->send_ack =
   1e292:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			sys_get_be32(tcp_hdr->seq) + 1;
   1e294:	3001      	adds	r0, #1
		context->tcp->send_ack =
   1e296:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	if (NET_TCP_FLAGS(tcp_hdr) == (NET_TCP_SYN | NET_TCP_ACK)) {
   1e29a:	f007 073f 	and.w	r7, r7, #63	; 0x3f
   1e29e:	2f12      	cmp	r7, #18
   1e2a0:	d142      	bne.n	1e328 <tcp_synack_received+0x144>
	return pkt->family;
   1e2a2:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e2a6:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1e2aa:	2b01      	cmp	r3, #1
   1e2ac:	d117      	bne.n	1e2de <tcp_synack_received+0xfa>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e2ae:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->src_port;
   1e2b2:	882a      	ldrh	r2, [r5, #0]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e2b4:	68c9      	ldr	r1, [r1, #12]
   1e2b6:	9109      	str	r1, [sp, #36]	; 0x24
		addr->sa_family = AF_INET;
   1e2b8:	f8ad 3020 	strh.w	r3, [sp, #32]
   1e2bc:	f896 303f 	ldrb.w	r3, [r6, #63]	; 0x3f
		addr4->sin_port = port;
   1e2c0:	f8ad 2022 	strh.w	r2, [sp, #34]	; 0x22
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e2c4:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1e2c8:	2b01      	cmp	r3, #1
   1e2ca:	d108      	bne.n	1e2de <tcp_synack_received+0xfa>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
   1e2cc:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->dst_port;
   1e2d0:	886a      	ldrh	r2, [r5, #2]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
   1e2d2:	6909      	ldr	r1, [r1, #16]
   1e2d4:	9107      	str	r1, [sp, #28]
		addr4->sin_port = port;
   1e2d6:	f8ad 201a 	strh.w	r2, [sp, #26]
		addr->sa_family = AF_INET;
   1e2da:	f8ad 3018 	strh.w	r3, [sp, #24]
	return net_conn_unregister(handle);
   1e2de:	4627      	mov	r7, r4
   1e2e0:	f857 0f2c 	ldr.w	r0, [r7, #44]!
   1e2e4:	f7ff f9da 	bl	1d69c <net_conn_unregister>
				       ntohs(tcp_hdr->dst_port),
   1e2e8:	886b      	ldrh	r3, [r5, #2]
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
   1e2ea:	4a23      	ldr	r2, [pc, #140]	; (1e378 <tcp_synack_received+0x194>)
				       ntohs(tcp_hdr->src_port),
   1e2ec:	8828      	ldrh	r0, [r5, #0]
   1e2ee:	f896 103f 	ldrb.w	r1, [r6, #63]	; 0x3f
   1e2f2:	9202      	str	r2, [sp, #8]
				       ntohs(tcp_hdr->dst_port),
   1e2f4:	021a      	lsls	r2, r3, #8
   1e2f6:	ea42 2213 	orr.w	r2, r2, r3, lsr #8
				       ntohs(tcp_hdr->src_port),
   1e2fa:	0203      	lsls	r3, r0, #8
   1e2fc:	ea43 2310 	orr.w	r3, r3, r0, lsr #8
   1e300:	b292      	uxth	r2, r2
   1e302:	b29b      	uxth	r3, r3
   1e304:	9201      	str	r2, [sp, #4]
   1e306:	9300      	str	r3, [sp, #0]
   1e308:	e9cd 4703 	strd	r4, r7, [sp, #12]
   1e30c:	ab06      	add	r3, sp, #24
   1e30e:	aa08      	add	r2, sp, #32
   1e310:	f3c1 0142 	ubfx	r1, r1, #1, #3
   1e314:	2006      	movs	r0, #6
   1e316:	f7ff f8ff 	bl	1d518 <net_conn_register>
		if (ret < 0) {
   1e31a:	2800      	cmp	r0, #0
   1e31c:	da0b      	bge.n	1e336 <tcp_synack_received+0x152>
			send_reset(context, &local_addr, &remote_addr);
   1e31e:	aa08      	add	r2, sp, #32
   1e320:	a906      	add	r1, sp, #24
   1e322:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e324:	f018 fa55 	bl	367d2 <send_reset.isra.29>
NET_CONN_CB(tcp_synack_received)
   1e328:	4620      	mov	r0, r4
   1e32a:	f017 fb3e 	bl	359aa <net_context_unref>
   1e32e:	2002      	movs	r0, #2
   1e330:	b00a      	add	sp, #40	; 0x28
   1e332:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		net_tcp_change_state(context->tcp, NET_TCP_ESTABLISHED);
   1e336:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e338:	2104      	movs	r1, #4
   1e33a:	f7ff fd17 	bl	1dd6c <net_tcp_change_state>
		net_context_set_state(context, NET_CONTEXT_CONNECTED);
   1e33e:	4620      	mov	r0, r4
   1e340:	2102      	movs	r1, #2
   1e342:	f7ff fb2b 	bl	1d99c <net_context_set_state>
		send_ack(context, &remote_addr, false);
   1e346:	2200      	movs	r2, #0
   1e348:	a908      	add	r1, sp, #32
   1e34a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e34c:	f018 fc16 	bl	36b7c <send_ack.isra.34>
		k_sem_give(&context->tcp->connect_wait);
   1e350:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e352:	30a0      	adds	r0, #160	; 0xa0
   1e354:	f00f fe4a 	bl	2dfec <z_impl_k_sem_give>
		if (context->connect_cb) {
   1e358:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1e35a:	2b00      	cmp	r3, #0
   1e35c:	d0e4      	beq.n	1e328 <tcp_synack_received+0x144>
			context->connect_cb(context, 0, context->user_data);
   1e35e:	6822      	ldr	r2, [r4, #0]
   1e360:	2100      	movs	r1, #0
   1e362:	e78e      	b.n	1e282 <tcp_synack_received+0x9e>
   1e364:	0003dc74 	.word	0x0003dc74
   1e368:	0003dc4d 	.word	0x0003dc4d
   1e36c:	0003b77f 	.word	0x0003b77f
   1e370:	0003cb8b 	.word	0x0003cb8b
   1e374:	0003dbc6 	.word	0x0003dbc6
   1e378:	0001dfb5 	.word	0x0001dfb5

0001e37c <tcp_syn_rcvd>:
 *			         struct net_pkt *pkt,
 *			         union net_ip_header *ip_hdr,
 *			         union net_proto_header *proto_hdr,
 *			         void *user_data)
 */
NET_CONN_CB(tcp_syn_rcvd)
   1e37c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1e380:	461e      	mov	r6, r3
   1e382:	b08f      	sub	sp, #60	; 0x3c
   1e384:	9c18      	ldr	r4, [sp, #96]	; 0x60
   1e386:	460d      	mov	r5, r1
   1e388:	4620      	mov	r0, r4
   1e38a:	4690      	mov	r8, r2
   1e38c:	f017 fb03 	bl	35996 <net_context_ref>
   1e390:	6836      	ldr	r6, [r6, #0]
	struct net_tcp *tcp;
	struct sockaddr_ptr pkt_src_addr;
	struct sockaddr local_addr;
	struct sockaddr remote_addr;

	NET_ASSERT(context && context->tcp);
   1e392:	b10c      	cbz	r4, 1e398 <tcp_syn_rcvd+0x1c>
   1e394:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e396:	b973      	cbnz	r3, 1e3b6 <tcp_syn_rcvd+0x3a>
   1e398:	49b6      	ldr	r1, [pc, #728]	; (1e674 <tcp_syn_rcvd+0x2f8>)
   1e39a:	f640 135a 	movw	r3, #2394	; 0x95a
   1e39e:	4ab6      	ldr	r2, [pc, #728]	; (1e678 <tcp_syn_rcvd+0x2fc>)
   1e3a0:	48b6      	ldr	r0, [pc, #728]	; (1e67c <tcp_syn_rcvd+0x300>)
   1e3a2:	f015 f911 	bl	335c8 <printk>
   1e3a6:	48b6      	ldr	r0, [pc, #728]	; (1e680 <tcp_syn_rcvd+0x304>)
   1e3a8:	f015 f90e 	bl	335c8 <printk>
   1e3ac:	f640 115a 	movw	r1, #2394	; 0x95a
   1e3b0:	48b1      	ldr	r0, [pc, #708]	; (1e678 <tcp_syn_rcvd+0x2fc>)
   1e3b2:	f015 fc0a 	bl	33bca <assert_post_action>

	tcp = context->tcp;
   1e3b6:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
	return (enum net_tcp_state)tcp->state;
   1e3ba:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
   1e3be:	f3c3 3343 	ubfx	r3, r3, #13, #4

	switch (net_tcp_get_state(tcp)) {
   1e3c2:	2b01      	cmp	r3, #1
   1e3c4:	d004      	beq.n	1e3d0 <tcp_syn_rcvd+0x54>
   1e3c6:	2b03      	cmp	r3, #3
   1e3c8:	f000 80c7 	beq.w	1e55a <tcp_syn_rcvd+0x1de>
	 */
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {

		if (tcp_backlog_rst(pkt, ip_hdr, tcp_hdr) < 0) {
			net_stats_update_tcp_seg_rsterr(net_pkt_iface(pkt));
			return NET_DROP;
   1e3cc:	2702      	movs	r7, #2
   1e3ce:	e0bd      	b.n	1e54c <tcp_syn_rcvd+0x1d0>
		net_context_set_iface(context, net_pkt_iface(pkt));
   1e3d0:	6a29      	ldr	r1, [r5, #32]
   1e3d2:	f104 007c 	add.w	r0, r4, #124	; 0x7c
   1e3d6:	f7ff fb25 	bl	1da24 <net_context_set_iface.isra.25>
	NET_ASSERT(net_pkt_iface(pkt));
   1e3da:	6a2b      	ldr	r3, [r5, #32]
	pkt->context = ctx;
   1e3dc:	61ec      	str	r4, [r5, #28]
   1e3de:	b973      	cbnz	r3, 1e3fe <tcp_syn_rcvd+0x82>
   1e3e0:	49a8      	ldr	r1, [pc, #672]	; (1e684 <tcp_syn_rcvd+0x308>)
   1e3e2:	f640 136f 	movw	r3, #2415	; 0x96f
   1e3e6:	4aa4      	ldr	r2, [pc, #656]	; (1e678 <tcp_syn_rcvd+0x2fc>)
   1e3e8:	48a4      	ldr	r0, [pc, #656]	; (1e67c <tcp_syn_rcvd+0x300>)
   1e3ea:	f015 f8ed 	bl	335c8 <printk>
   1e3ee:	48a4      	ldr	r0, [pc, #656]	; (1e680 <tcp_syn_rcvd+0x304>)
   1e3f0:	f015 f8ea 	bl	335c8 <printk>
   1e3f4:	f640 116f 	movw	r1, #2415	; 0x96f
   1e3f8:	489f      	ldr	r0, [pc, #636]	; (1e678 <tcp_syn_rcvd+0x2fc>)
   1e3fa:	f015 fbe6 	bl	33bca <assert_post_action>
	return pkt->family;
   1e3fe:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e402:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1e406:	2b01      	cmp	r3, #1
   1e408:	d117      	bne.n	1e43a <tcp_syn_rcvd+0xbe>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e40a:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->src_port;
   1e40e:	8832      	ldrh	r2, [r6, #0]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e410:	68c9      	ldr	r1, [r1, #12]
   1e412:	910d      	str	r1, [sp, #52]	; 0x34
		addr->sa_family = AF_INET;
   1e414:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
   1e418:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
		addr4->sin_port = port;
   1e41c:	f8ad 2032 	strh.w	r2, [sp, #50]	; 0x32
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e420:	f3c3 0342 	ubfx	r3, r3, #1, #3
   1e424:	2b01      	cmp	r3, #1
   1e426:	d108      	bne.n	1e43a <tcp_syn_rcvd+0xbe>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
   1e428:	f8d8 1000 	ldr.w	r1, [r8]
		port = tcp_hdr->dst_port;
   1e42c:	8872      	ldrh	r2, [r6, #2]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->dst);
   1e42e:	6909      	ldr	r1, [r1, #16]
   1e430:	910b      	str	r1, [sp, #44]	; 0x2c
		addr4->sin_port = port;
   1e432:	f8ad 202a 	strh.w	r2, [sp, #42]	; 0x2a
		addr->sa_family = AF_INET;
   1e436:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	if (NET_TCP_FLAGS(tcp_hdr) == NET_TCP_SYN) {
   1e43a:	7b73      	ldrb	r3, [r6, #13]
   1e43c:	f003 073f 	and.w	r7, r3, #63	; 0x3f
   1e440:	2f02      	cmp	r7, #2
   1e442:	f040 8092 	bne.w	1e56a <tcp_syn_rcvd+0x1ee>
		struct net_tcp_options tcp_opts = {
   1e446:	f44f 7306 	mov.w	r3, #536	; 0x218
		if (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {
   1e44a:	f06f 0113 	mvn.w	r1, #19
		struct net_tcp_options tcp_opts = {
   1e44e:	f8ad 301c 	strh.w	r3, [sp, #28]
		opt_totlen = NET_TCP_HDR_LEN(tcp_hdr)
   1e452:	7b33      	ldrb	r3, [r6, #12]
		if (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {
   1e454:	aa07      	add	r2, sp, #28
			     - sizeof(struct net_tcp_hdr);
   1e456:	091b      	lsrs	r3, r3, #4
		if (net_tcp_parse_opts(pkt, opt_totlen, &tcp_opts) < 0) {
   1e458:	eb01 0183 	add.w	r1, r1, r3, lsl #2
   1e45c:	4628      	mov	r0, r5
   1e45e:	f018 fd10 	bl	36e82 <net_tcp_parse_opts>
   1e462:	2800      	cmp	r0, #0
   1e464:	db72      	blt.n	1e54c <tcp_syn_rcvd+0x1d0>
		net_tcp_change_state(tcp, NET_TCP_SYN_RCVD);
   1e466:	2103      	movs	r1, #3
   1e468:	4648      	mov	r0, r9
   1e46a:	f7ff fc7f 	bl	1dd6c <net_tcp_change_state>
		context->tcp->send_seq = tcp_init_isn();
   1e46e:	f8d4 903c 	ldr.w	r9, [r4, #60]	; 0x3c
	return sys_rand32_get();
   1e472:	f000 fc51 	bl	1ed18 <sys_rand32_get>
   1e476:	f8c9 0090 	str.w	r0, [r9, #144]	; 0x90
			sys_get_be32(tcp_hdr->seq) + 1;
   1e47a:	1d30      	adds	r0, r6, #4
   1e47c:	f018 f8ec 	bl	36658 <sys_get_be32>
		context->tcp->send_ack =
   1e480:	6be3      	ldr	r3, [r4, #60]	; 0x3c
			sys_get_be32(tcp_hdr->seq) + 1;
   1e482:	3001      	adds	r0, #1
		context->tcp->send_ack =
   1e484:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
	int empty_slot = -1;
   1e488:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
	if (tcp_backlog_find(pkt, ip_hdr, tcp_hdr, &empty_slot) >= 0) {
   1e48c:	4632      	mov	r2, r6
	int empty_slot = -1;
   1e48e:	9308      	str	r3, [sp, #32]
	if (tcp_backlog_find(pkt, ip_hdr, tcp_hdr, &empty_slot) >= 0) {
   1e490:	4641      	mov	r1, r8
   1e492:	ab08      	add	r3, sp, #32
   1e494:	4628      	mov	r0, r5
		r = tcp_backlog_syn(pkt, ip_hdr, tcp_hdr,
   1e496:	f8bd 901c 	ldrh.w	r9, [sp, #28]
	if (tcp_backlog_find(pkt, ip_hdr, tcp_hdr, &empty_slot) >= 0) {
   1e49a:	f7ff fae3 	bl	1da64 <tcp_backlog_find.isra.26>
   1e49e:	2800      	cmp	r0, #0
   1e4a0:	da54      	bge.n	1e54c <tcp_syn_rcvd+0x1d0>
	if (empty_slot < 0) {
   1e4a2:	9a08      	ldr	r2, [sp, #32]
   1e4a4:	2a00      	cmp	r2, #0
   1e4a6:	db51      	blt.n	1e54c <tcp_syn_rcvd+0x1d0>
	tcp_backlog[empty_slot].tcp = context->tcp;
   1e4a8:	2338      	movs	r3, #56	; 0x38
   1e4aa:	4353      	muls	r3, r2
   1e4ac:	4f76      	ldr	r7, [pc, #472]	; (1e688 <tcp_syn_rcvd+0x30c>)
   1e4ae:	6be2      	ldr	r2, [r4, #60]	; 0x3c
   1e4b0:	18f8      	adds	r0, r7, r3
   1e4b2:	50fa      	str	r2, [r7, r3]
   1e4b4:	f895 203f 	ldrb.w	r2, [r5, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e4b8:	f3c2 0242 	ubfx	r2, r2, #1, #3
   1e4bc:	2a01      	cmp	r2, #1
   1e4be:	d10a      	bne.n	1e4d6 <tcp_syn_rcvd+0x15a>
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e4c0:	f8d8 1000 	ldr.w	r1, [r8]
	tcp_copy_ip_addr_from_hdr(net_pkt_family(pkt), ip_hdr, tcp_hdr,
   1e4c4:	332c      	adds	r3, #44	; 0x2c
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e4c6:	68c9      	ldr	r1, [r1, #12]
	tcp_copy_ip_addr_from_hdr(net_pkt_family(pkt), ip_hdr, tcp_hdr,
   1e4c8:	443b      	add	r3, r7
		port = tcp_hdr->src_port;
   1e4ca:	f8b6 c000 	ldrh.w	ip, [r6]
			net_ipaddr_copy(&addr4->sin_addr, &ip_hdr->ipv4->src);
   1e4ce:	6059      	str	r1, [r3, #4]
		addr4->sin_port = port;
   1e4d0:	f8a3 c002 	strh.w	ip, [r3, #2]
		addr->sa_family = AF_INET;
   1e4d4:	8582      	strh	r2, [r0, #44]	; 0x2c
	tcp_backlog[empty_slot].send_seq = context->tcp->send_seq;
   1e4d6:	f04f 0a38 	mov.w	sl, #56	; 0x38
   1e4da:	9808      	ldr	r0, [sp, #32]
   1e4dc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
   1e4de:	fb0a f000 	mul.w	r0, sl, r0
   1e4e2:	f8d1 3090 	ldr.w	r3, [r1, #144]	; 0x90
   1e4e6:	183a      	adds	r2, r7, r0
   1e4e8:	6053      	str	r3, [r2, #4]
	tcp_backlog[empty_slot].send_ack = context->tcp->send_ack;
   1e4ea:	f8d1 3094 	ldr.w	r3, [r1, #148]	; 0x94
	k_delayed_work_init(&tcp_backlog[empty_slot].ack_timer,
   1e4ee:	300c      	adds	r0, #12
	tcp_backlog[empty_slot].send_ack = context->tcp->send_ack;
   1e4f0:	6093      	str	r3, [r2, #8]
	tcp_backlog[empty_slot].send_mss = send_mss;
   1e4f2:	f8a2 9034 	strh.w	r9, [r2, #52]	; 0x34
	k_delayed_work_init(&tcp_backlog[empty_slot].ack_timer,
   1e4f6:	4965      	ldr	r1, [pc, #404]	; (1e68c <tcp_syn_rcvd+0x310>)
   1e4f8:	4438      	add	r0, r7
   1e4fa:	f01a fc93 	bl	38e24 <k_delayed_work_init>
	k_delayed_work_submit(&tcp_backlog[empty_slot].ack_timer, ACK_TIMEOUT);
   1e4fe:	9808      	ldr	r0, [sp, #32]
   1e500:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   1e504:	fb0a 7000 	mla	r0, sl, r0, r7
   1e508:	300c      	adds	r0, #12
   1e50a:	f7ff f9ff 	bl	1d90c <k_delayed_work_submit>
		get_sockaddr_ptr(ip_hdr, tcp_hdr,
   1e50e:	4620      	mov	r0, r4
   1e510:	f7ff fa04 	bl	1d91c <net_context_get_family>
	(void)memset(addr, 0, sizeof(*addr));
   1e514:	2300      	movs	r3, #0
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e516:	2801      	cmp	r0, #1
	(void)memset(addr, 0, sizeof(*addr));
   1e518:	e9cd 3308 	strd	r3, r3, [sp, #32]
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   1e51c:	d10b      	bne.n	1e536 <tcp_syn_rcvd+0x1ba>
		addr4->sin_family = AF_INET;
   1e51e:	f8ad 0020 	strh.w	r0, [sp, #32]
		addr4->sin_port = tcp_hdr->dst_port;
   1e522:	78b3      	ldrb	r3, [r6, #2]
   1e524:	78f2      	ldrb	r2, [r6, #3]
   1e526:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   1e52a:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
		addr4->sin_addr = &ip_hdr->ipv4->dst;
   1e52e:	f8d8 3000 	ldr.w	r3, [r8]
   1e532:	3310      	adds	r3, #16
   1e534:	9309      	str	r3, [sp, #36]	; 0x24
	return send_syn_segment(context, local, remote,
   1e536:	2312      	movs	r3, #18
   1e538:	aa0c      	add	r2, sp, #48	; 0x30
   1e53a:	a908      	add	r1, sp, #32
   1e53c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   1e540:	f018 fb36 	bl	36bb0 <send_syn_segment.isra.35>
		net_pkt_unref(pkt);
   1e544:	4628      	mov	r0, r5
   1e546:	f017 fbc7 	bl	35cd8 <net_pkt_unref>
		return NET_OK;
   1e54a:	2700      	movs	r7, #0
NET_CONN_CB(tcp_syn_rcvd)
   1e54c:	4620      	mov	r0, r4
   1e54e:	f017 fa2c 	bl	359aa <net_context_unref>
   1e552:	4638      	mov	r0, r7
   1e554:	b00f      	add	sp, #60	; 0x3c
   1e556:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (net_pkt_iface(pkt) != net_context_get_iface(context)) {
   1e55a:	4620      	mov	r0, r4
   1e55c:	6a2f      	ldr	r7, [r5, #32]
   1e55e:	f7ff fa41 	bl	1d9e4 <net_context_get_iface>
   1e562:	4287      	cmp	r7, r0
   1e564:	f43f af39 	beq.w	1e3da <tcp_syn_rcvd+0x5e>
   1e568:	e730      	b.n	1e3cc <tcp_syn_rcvd+0x50>
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_RST) {
   1e56a:	f013 0704 	ands.w	r7, r3, #4
   1e56e:	d01f      	beq.n	1e5b0 <tcp_syn_rcvd+0x234>
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
   1e570:	4628      	mov	r0, r5
   1e572:	2300      	movs	r3, #0
   1e574:	4632      	mov	r2, r6
   1e576:	4641      	mov	r1, r8
   1e578:	f7ff fa74 	bl	1da64 <tcp_backlog_find.isra.26>
	if (r < 0) {
   1e57c:	1e05      	subs	r5, r0, #0
   1e57e:	f6ff af25 	blt.w	1e3cc <tcp_syn_rcvd+0x50>
	if (tcp_backlog[r].send_ack != sys_get_be32(tcp_hdr->seq)) {
   1e582:	1d30      	adds	r0, r6, #4
   1e584:	2638      	movs	r6, #56	; 0x38
   1e586:	f018 f867 	bl	36658 <sys_get_be32>
   1e58a:	fb06 f305 	mul.w	r3, r6, r5
   1e58e:	4a3e      	ldr	r2, [pc, #248]	; (1e688 <tcp_syn_rcvd+0x30c>)
   1e590:	18d5      	adds	r5, r2, r3
   1e592:	68a9      	ldr	r1, [r5, #8]
   1e594:	4281      	cmp	r1, r0
   1e596:	f47f af19 	bne.w	1e3cc <tcp_syn_rcvd+0x50>
	k_delayed_work_cancel(&tcp_backlog[r].ack_timer);
   1e59a:	f103 000c 	add.w	r0, r3, #12
   1e59e:	4410      	add	r0, r2
   1e5a0:	f010 f87a 	bl	2e698 <k_delayed_work_cancel>
   1e5a4:	4632      	mov	r2, r6
   1e5a6:	2100      	movs	r1, #0
   1e5a8:	4628      	mov	r0, r5
   1e5aa:	f01a fd4f 	bl	3904c <memset>
   1e5ae:	e70d      	b.n	1e3cc <tcp_syn_rcvd+0x50>
	}

	/*
	 * If we receive ACK, we go to ESTABLISHED state.
	 */
	if (NET_TCP_FLAGS(tcp_hdr) & NET_TCP_ACK) {
   1e5b0:	06db      	lsls	r3, r3, #27
   1e5b2:	f57f af0b 	bpl.w	1e3cc <tcp_syn_rcvd+0x50>
		socklen_t addrlen;
		int ret;

		net_tcp_print_recv_info("ACK", pkt, tcp_hdr->src_port);

		if (!context->tcp->accept_cb) {
   1e5b6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e5b8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   1e5bc:	b93b      	cbnz	r3, 1e5ce <tcp_syn_rcvd+0x252>

conndrop:
	net_stats_update_tcp_seg_conndrop(net_pkt_iface(pkt));

reset:
	send_reset(tcp->context, &local_addr, &remote_addr);
   1e5be:	f8d9 3000 	ldr.w	r3, [r9]
   1e5c2:	aa0c      	add	r2, sp, #48	; 0x30
   1e5c4:	a90a      	add	r1, sp, #40	; 0x28
   1e5c6:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   1e5c8:	f018 f903 	bl	367d2 <send_reset.isra.29>

	return NET_DROP;
   1e5cc:	e6fe      	b.n	1e3cc <tcp_syn_rcvd+0x50>
   1e5ce:	f895 003f 	ldrb.w	r0, [r5, #63]	; 0x3f
		ret = net_context_get(net_pkt_family(pkt),
   1e5d2:	ab08      	add	r3, sp, #32
   1e5d4:	2206      	movs	r2, #6
   1e5d6:	2101      	movs	r1, #1
   1e5d8:	f3c0 0042 	ubfx	r0, r0, #1, #3
   1e5dc:	f7fe f94a 	bl	1c874 <net_context_get>
		if (ret < 0) {
   1e5e0:	2800      	cmp	r0, #0
   1e5e2:	dbec      	blt.n	1e5be <tcp_syn_rcvd+0x242>
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
   1e5e4:	4641      	mov	r1, r8
   1e5e6:	463b      	mov	r3, r7
   1e5e8:	4632      	mov	r2, r6
   1e5ea:	4628      	mov	r0, r5
		ret = tcp_backlog_ack(pkt, ip_hdr, tcp_hdr, new_context);
   1e5ec:	f8dd a020 	ldr.w	sl, [sp, #32]
	r = tcp_backlog_find(pkt, ip_hdr, tcp_hdr, NULL);
   1e5f0:	f7ff fa38 	bl	1da64 <tcp_backlog_find.isra.26>
	if (r < 0) {
   1e5f4:	f1b0 0800 	subs.w	r8, r0, #0
   1e5f8:	db37      	blt.n	1e66a <tcp_syn_rcvd+0x2ee>
	if (tcp_backlog[r].send_seq + 1 != sys_get_be32(tcp_hdr->ack)) {
   1e5fa:	f04f 0b38 	mov.w	fp, #56	; 0x38
   1e5fe:	f106 0008 	add.w	r0, r6, #8
   1e602:	f018 f829 	bl	36658 <sys_get_be32>
   1e606:	fb0b f308 	mul.w	r3, fp, r8
   1e60a:	4a1f      	ldr	r2, [pc, #124]	; (1e688 <tcp_syn_rcvd+0x30c>)
   1e60c:	eb02 0803 	add.w	r8, r2, r3
   1e610:	f8d8 1004 	ldr.w	r1, [r8, #4]
   1e614:	3101      	adds	r1, #1
   1e616:	4281      	cmp	r1, r0
   1e618:	d127      	bne.n	1e66a <tcp_syn_rcvd+0x2ee>
	memcpy(&context->remote, &tcp_backlog[r].remote,
   1e61a:	f103 062c 	add.w	r6, r3, #44	; 0x2c
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1e61e:	4416      	add	r6, r2
   1e620:	ce03      	ldmia	r6!, {r0, r1}
   1e622:	f8ca 1028 	str.w	r1, [sl, #40]	; 0x28
   1e626:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
	context->tcp->send_seq = tcp_backlog[r].send_seq + 1;
   1e62a:	f8d8 0004 	ldr.w	r0, [r8, #4]
   1e62e:	f8da 103c 	ldr.w	r1, [sl, #60]	; 0x3c
   1e632:	3001      	adds	r0, #1
   1e634:	f8c1 0090 	str.w	r0, [r1, #144]	; 0x90
	context->tcp->send_ack = tcp_backlog[r].send_ack;
   1e638:	f8d8 0008 	ldr.w	r0, [r8, #8]
   1e63c:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
	context->tcp->send_mss = tcp_backlog[r].send_mss;
   1e640:	f8b8 0034 	ldrh.w	r0, [r8, #52]	; 0x34
   1e644:	f8a1 00ba 	strh.w	r0, [r1, #186]	; 0xba
	k_delayed_work_cancel(&tcp_backlog[r].ack_timer);
   1e648:	f103 000c 	add.w	r0, r3, #12
   1e64c:	4410      	add	r0, r2
   1e64e:	f010 f823 	bl	2e698 <k_delayed_work_cancel>
__ssp_bos_icheck3(memset, void *, int)
   1e652:	465a      	mov	r2, fp
   1e654:	4639      	mov	r1, r7
   1e656:	4640      	mov	r0, r8
   1e658:	f01a fcf8 	bl	3904c <memset>
		ret = net_context_bind(new_context, &local_addr,
   1e65c:	2208      	movs	r2, #8
   1e65e:	a90a      	add	r1, sp, #40	; 0x28
   1e660:	9808      	ldr	r0, [sp, #32]
   1e662:	f7fe fa01 	bl	1ca68 <net_context_bind>
		if (ret < 0) {
   1e666:	2800      	cmp	r0, #0
   1e668:	da12      	bge.n	1e690 <tcp_syn_rcvd+0x314>
			net_context_unref(new_context);
   1e66a:	9808      	ldr	r0, [sp, #32]
   1e66c:	f017 f99d 	bl	359aa <net_context_unref>
			goto conndrop;
   1e670:	e7a5      	b.n	1e5be <tcp_syn_rcvd+0x242>
   1e672:	bf00      	nop
   1e674:	0003dc74 	.word	0x0003dc74
   1e678:	0003dc4d 	.word	0x0003dc4d
   1e67c:	0003b77f 	.word	0x0003b77f
   1e680:	0003cb8b 	.word	0x0003cb8b
   1e684:	0003dbc6 	.word	0x0003dbc6
   1e688:	20021d60 	.word	0x20021d60
   1e68c:	00036809 	.word	0x00036809
		new_context->flags |= NET_CONTEXT_REMOTE_ADDR_SET;
   1e690:	9b08      	ldr	r3, [sp, #32]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   1e692:	ae0c      	add	r6, sp, #48	; 0x30
   1e694:	f8b3 207a 	ldrh.w	r2, [r3, #122]	; 0x7a
   1e698:	ce03      	ldmia	r6!, {r0, r1}
   1e69a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   1e69e:	f8a3 207a 	strh.w	r2, [r3, #122]	; 0x7a
		memcpy(&new_context->remote, &remote_addr,
   1e6a2:	f103 0224 	add.w	r2, r3, #36	; 0x24
   1e6a6:	6258      	str	r0, [r3, #36]	; 0x24
   1e6a8:	6051      	str	r1, [r2, #4]
		ret = net_tcp_register(net_pkt_family(pkt),
   1e6aa:	f103 002c 	add.w	r0, r3, #44	; 0x2c
			       ntohs(net_sin(&new_context->remote)->sin_port),
   1e6ae:	8cde      	ldrh	r6, [r3, #38]	; 0x26
   1e6b0:	f895 103f 	ldrb.w	r1, [r5, #63]	; 0x3f
			       ntohs(net_sin(&local_addr)->sin_port),
   1e6b4:	f8bd c02a 	ldrh.w	ip, [sp, #42]	; 0x2a
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
   1e6b8:	e9cd 3003 	strd	r3, r0, [sp, #12]
   1e6bc:	4b31      	ldr	r3, [pc, #196]	; (1e784 <tcp_syn_rcvd+0x408>)
   1e6be:	ea4f 200c 	mov.w	r0, ip, lsl #8
   1e6c2:	9302      	str	r3, [sp, #8]
			       ntohs(net_sin(&new_context->remote)->sin_port),
   1e6c4:	0233      	lsls	r3, r6, #8
			       ntohs(net_sin(&local_addr)->sin_port),
   1e6c6:	ea40 201c 	orr.w	r0, r0, ip, lsr #8
			       ntohs(net_sin(&new_context->remote)->sin_port),
   1e6ca:	ea43 2316 	orr.w	r3, r3, r6, lsr #8
   1e6ce:	b280      	uxth	r0, r0
   1e6d0:	b29b      	uxth	r3, r3
   1e6d2:	9001      	str	r0, [sp, #4]
   1e6d4:	9300      	str	r3, [sp, #0]
   1e6d6:	f3c1 0142 	ubfx	r1, r1, #1, #3
   1e6da:	ab0a      	add	r3, sp, #40	; 0x28
   1e6dc:	2006      	movs	r0, #6
   1e6de:	f7fe ff1b 	bl	1d518 <net_conn_register>
		if (ret < 0) {
   1e6e2:	2800      	cmp	r0, #0
   1e6e4:	dbc1      	blt.n	1e66a <tcp_syn_rcvd+0x2ee>
		net_tcp_change_state(tcp, NET_TCP_LISTEN);
   1e6e6:	2101      	movs	r1, #1
   1e6e8:	4648      	mov	r0, r9
   1e6ea:	f7ff fb3f 	bl	1dd6c <net_tcp_change_state>
		net_tcp_change_state(new_context->tcp, NET_TCP_ESTABLISHED);
   1e6ee:	9b08      	ldr	r3, [sp, #32]
   1e6f0:	2104      	movs	r1, #4
   1e6f2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   1e6f4:	f7ff fb3a 	bl	1dd6c <net_tcp_change_state>
		net_context_set_accepting(new_context, true);
   1e6f8:	9e08      	ldr	r6, [sp, #32]
	NET_ASSERT(context);
   1e6fa:	b976      	cbnz	r6, 1e71a <tcp_syn_rcvd+0x39e>
   1e6fc:	4922      	ldr	r1, [pc, #136]	; (1e788 <tcp_syn_rcvd+0x40c>)
   1e6fe:	f44f 73b7 	mov.w	r3, #366	; 0x16e
   1e702:	4a22      	ldr	r2, [pc, #136]	; (1e78c <tcp_syn_rcvd+0x410>)
   1e704:	4822      	ldr	r0, [pc, #136]	; (1e790 <tcp_syn_rcvd+0x414>)
   1e706:	f014 ff5f 	bl	335c8 <printk>
   1e70a:	4822      	ldr	r0, [pc, #136]	; (1e794 <tcp_syn_rcvd+0x418>)
   1e70c:	f014 ff5c 	bl	335c8 <printk>
   1e710:	f44f 71b7 	mov.w	r1, #366	; 0x16e
   1e714:	481d      	ldr	r0, [pc, #116]	; (1e78c <tcp_syn_rcvd+0x410>)
   1e716:	f015 fa58 	bl	33bca <assert_post_action>
		context->flags |= NET_CONTEXT_ACCEPTING_SOCK;
   1e71a:	f8b6 307a 	ldrh.w	r3, [r6, #122]	; 0x7a
		net_context_set_state(new_context, NET_CONTEXT_CONNECTED);
   1e71e:	9808      	ldr	r0, [sp, #32]
   1e720:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1e724:	f8a6 307a 	strh.w	r3, [r6, #122]	; 0x7a
   1e728:	2102      	movs	r1, #2
   1e72a:	f7ff f937 	bl	1d99c <net_context_set_state>
		if (new_context->remote.sa_family == AF_INET) {
   1e72e:	9808      	ldr	r0, [sp, #32]
   1e730:	8c83      	ldrh	r3, [r0, #36]	; 0x24
   1e732:	2b01      	cmp	r3, #1
   1e734:	d016      	beq.n	1e764 <tcp_syn_rcvd+0x3e8>
		} else if (new_context->remote.sa_family == AF_INET6) {
   1e736:	2b02      	cmp	r3, #2
   1e738:	d022      	beq.n	1e780 <tcp_syn_rcvd+0x404>
			NET_ASSERT(false, "Invalid protocol family %d",
   1e73a:	4a17      	ldr	r2, [pc, #92]	; (1e798 <tcp_syn_rcvd+0x41c>)
   1e73c:	f640 2312 	movw	r3, #2578	; 0xa12
   1e740:	4916      	ldr	r1, [pc, #88]	; (1e79c <tcp_syn_rcvd+0x420>)
   1e742:	4813      	ldr	r0, [pc, #76]	; (1e790 <tcp_syn_rcvd+0x414>)
   1e744:	f014 ff40 	bl	335c8 <printk>
   1e748:	9b08      	ldr	r3, [sp, #32]
   1e74a:	4815      	ldr	r0, [pc, #84]	; (1e7a0 <tcp_syn_rcvd+0x424>)
   1e74c:	8c99      	ldrh	r1, [r3, #36]	; 0x24
   1e74e:	f014 ff3b 	bl	335c8 <printk>
   1e752:	f640 2112 	movw	r1, #2578	; 0xa12
   1e756:	4810      	ldr	r0, [pc, #64]	; (1e798 <tcp_syn_rcvd+0x41c>)
   1e758:	f015 fa37 	bl	33bca <assert_post_action>
			net_context_unref(new_context);
   1e75c:	9808      	ldr	r0, [sp, #32]
   1e75e:	f017 f924 	bl	359aa <net_context_unref>
			return NET_DROP;
   1e762:	e633      	b.n	1e3cc <tcp_syn_rcvd+0x50>
			addrlen = sizeof(struct sockaddr_in);
   1e764:	2208      	movs	r2, #8
		context->tcp->accept_cb(new_context,
   1e766:	6821      	ldr	r1, [r4, #0]
   1e768:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e76a:	9100      	str	r1, [sp, #0]
   1e76c:	f8d3 609c 	ldr.w	r6, [r3, #156]	; 0x9c
   1e770:	f100 0124 	add.w	r1, r0, #36	; 0x24
   1e774:	2300      	movs	r3, #0
   1e776:	47b0      	blx	r6
		net_pkt_unref(pkt);
   1e778:	4628      	mov	r0, r5
   1e77a:	f017 faad 	bl	35cd8 <net_pkt_unref>
		return NET_OK;
   1e77e:	e6e5      	b.n	1e54c <tcp_syn_rcvd+0x1d0>
			addrlen = sizeof(struct sockaddr_in6);
   1e780:	2218      	movs	r2, #24
   1e782:	e7f0      	b.n	1e766 <tcp_syn_rcvd+0x3ea>
   1e784:	0001dfb5 	.word	0x0001dfb5
   1e788:	0003cb83 	.word	0x0003cb83
   1e78c:	0003cb56 	.word	0x0003cb56
   1e790:	0003b77f 	.word	0x0003b77f
   1e794:	0003cb8b 	.word	0x0003cb8b
   1e798:	0003dc4d 	.word	0x0003dc4d
   1e79c:	0003fd3b 	.word	0x0003fd3b
   1e7a0:	0003dc8c 	.word	0x0003dc8c

0001e7a4 <net_tcp_recv>:
{
   1e7a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	NET_ASSERT(context->tcp);
   1e7a6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
   1e7a8:	4605      	mov	r5, r0
   1e7aa:	460f      	mov	r7, r1
   1e7ac:	4616      	mov	r6, r2
	NET_ASSERT(context->tcp);
   1e7ae:	b973      	cbnz	r3, 1e7ce <net_tcp_recv+0x2a>
   1e7b0:	4913      	ldr	r1, [pc, #76]	; (1e800 <net_tcp_recv+0x5c>)
   1e7b2:	f240 53be 	movw	r3, #1470	; 0x5be
   1e7b6:	4a13      	ldr	r2, [pc, #76]	; (1e804 <net_tcp_recv+0x60>)
   1e7b8:	4813      	ldr	r0, [pc, #76]	; (1e808 <net_tcp_recv+0x64>)
   1e7ba:	f014 ff05 	bl	335c8 <printk>
   1e7be:	4813      	ldr	r0, [pc, #76]	; (1e80c <net_tcp_recv+0x68>)
   1e7c0:	f014 ff02 	bl	335c8 <printk>
   1e7c4:	f240 51be 	movw	r1, #1470	; 0x5be
   1e7c8:	480e      	ldr	r0, [pc, #56]	; (1e804 <net_tcp_recv+0x60>)
   1e7ca:	f015 f9fe 	bl	33bca <assert_post_action>
	if (context->tcp->flags & NET_TCP_IS_SHUTDOWN) {
   1e7ce:	6beb      	ldr	r3, [r5, #60]	; 0x3c
   1e7d0:	f8b3 00bc 	ldrh.w	r0, [r3, #188]	; 0xbc
   1e7d4:	f3c0 1047 	ubfx	r0, r0, #5, #8
   1e7d8:	f010 0408 	ands.w	r4, r0, #8
   1e7dc:	d109      	bne.n	1e7f2 <net_tcp_recv+0x4e>
	} else if (net_context_get_state(context) != NET_CONTEXT_CONNECTED) {
   1e7de:	4628      	mov	r0, r5
   1e7e0:	f7ff f8bc 	bl	1d95c <net_context_get_state>
   1e7e4:	2802      	cmp	r0, #2
   1e7e6:	d107      	bne.n	1e7f8 <net_tcp_recv+0x54>
	return 0;
   1e7e8:	4620      	mov	r0, r4
	context->tcp->recv_user_data = user_data;
   1e7ea:	6beb      	ldr	r3, [r5, #60]	; 0x3c
	context->recv_cb = cb;
   1e7ec:	632f      	str	r7, [r5, #48]	; 0x30
	context->tcp->recv_user_data = user_data;
   1e7ee:	605e      	str	r6, [r3, #4]
}
   1e7f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ESHUTDOWN;
   1e7f2:	f06f 006d 	mvn.w	r0, #109	; 0x6d
   1e7f6:	e7fb      	b.n	1e7f0 <net_tcp_recv+0x4c>
		return -ENOTCONN;
   1e7f8:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   1e7fc:	e7f8      	b.n	1e7f0 <net_tcp_recv+0x4c>
   1e7fe:	bf00      	nop
   1e800:	0003dc7f 	.word	0x0003dc7f
   1e804:	0003dc4d 	.word	0x0003dc4d
   1e808:	0003b77f 	.word	0x0003b77f
   1e80c:	0003cb8b 	.word	0x0003cb8b

0001e810 <net_tcp_get>:
{
   1e810:	b510      	push	{r4, lr}
   1e812:	4604      	mov	r4, r0
	context->tcp = net_tcp_alloc(context);
   1e814:	f7ff fa4c 	bl	1dcb0 <net_tcp_alloc>
   1e818:	63e0      	str	r0, [r4, #60]	; 0x3c
	if (!context->tcp) {
   1e81a:	b988      	cbnz	r0, 1e840 <net_tcp_get+0x30>
		NET_ASSERT(context->tcp, "Cannot allocate TCP context");
   1e81c:	f240 731b 	movw	r3, #1819	; 0x71b
   1e820:	4a0f      	ldr	r2, [pc, #60]	; (1e860 <net_tcp_get+0x50>)
   1e822:	4910      	ldr	r1, [pc, #64]	; (1e864 <net_tcp_get+0x54>)
   1e824:	4810      	ldr	r0, [pc, #64]	; (1e868 <net_tcp_get+0x58>)
   1e826:	f014 fecf 	bl	335c8 <printk>
   1e82a:	4810      	ldr	r0, [pc, #64]	; (1e86c <net_tcp_get+0x5c>)
   1e82c:	f014 fecc 	bl	335c8 <printk>
   1e830:	480b      	ldr	r0, [pc, #44]	; (1e860 <net_tcp_get+0x50>)
   1e832:	f240 711b 	movw	r1, #1819	; 0x71b
   1e836:	f015 f9c8 	bl	33bca <assert_post_action>
		return -ENOBUFS;
   1e83a:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   1e83e:	bd10      	pop	{r4, pc}
	k_delayed_work_init(&context->tcp->ack_timer, handle_ack_timeout);
   1e840:	490b      	ldr	r1, [pc, #44]	; (1e870 <net_tcp_get+0x60>)
   1e842:	3008      	adds	r0, #8
   1e844:	f01a faee 	bl	38e24 <k_delayed_work_init>
	k_delayed_work_init(&context->tcp->fin_timer, handle_fin_timeout);
   1e848:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e84a:	490a      	ldr	r1, [pc, #40]	; (1e874 <net_tcp_get+0x64>)
   1e84c:	3028      	adds	r0, #40	; 0x28
   1e84e:	f01a fae9 	bl	38e24 <k_delayed_work_init>
	k_delayed_work_init(&context->tcp->timewait_timer,
   1e852:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e854:	4908      	ldr	r1, [pc, #32]	; (1e878 <net_tcp_get+0x68>)
   1e856:	3068      	adds	r0, #104	; 0x68
   1e858:	f01a fae4 	bl	38e24 <k_delayed_work_init>
	return 0;
   1e85c:	2000      	movs	r0, #0
   1e85e:	e7ee      	b.n	1e83e <net_tcp_get+0x2e>
   1e860:	0003dc4d 	.word	0x0003dc4d
   1e864:	0003dc7f 	.word	0x0003dc7f
   1e868:	0003b77f 	.word	0x0003b77f
   1e86c:	0003dc2f 	.word	0x0003dc2f
   1e870:	00036ddb 	.word	0x00036ddb
   1e874:	0003666f 	.word	0x0003666f
   1e878:	00036d9b 	.word	0x00036d9b

0001e87c <net_tcp_unref>:
{
   1e87c:	b538      	push	{r3, r4, r5, lr}
	if (!context->tcp)
   1e87e:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
   1e880:	4604      	mov	r4, r0
	if (!context->tcp)
   1e882:	b18b      	cbz	r3, 1e8a8 <net_tcp_unref+0x2c>
		if (tcp_backlog[i].tcp != context->tcp) {
   1e884:	4d09      	ldr	r5, [pc, #36]	; (1e8ac <net_tcp_unref+0x30>)
   1e886:	682a      	ldr	r2, [r5, #0]
   1e888:	4293      	cmp	r3, r2
   1e88a:	d108      	bne.n	1e89e <net_tcp_unref+0x22>
		k_delayed_work_cancel(&tcp_backlog[i].ack_timer);
   1e88c:	f105 000c 	add.w	r0, r5, #12
   1e890:	f00f ff02 	bl	2e698 <k_delayed_work_cancel>
		(void)memset(&tcp_backlog[i], 0, sizeof(tcp_backlog[i]));
   1e894:	2238      	movs	r2, #56	; 0x38
   1e896:	2100      	movs	r1, #0
   1e898:	4628      	mov	r0, r5
   1e89a:	f01a fbd7 	bl	3904c <memset>
	net_tcp_release(context->tcp);
   1e89e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1e8a0:	f7ff fab8 	bl	1de14 <net_tcp_release>
	context->tcp = NULL;
   1e8a4:	2300      	movs	r3, #0
   1e8a6:	63e3      	str	r3, [r4, #60]	; 0x3c
}
   1e8a8:	2000      	movs	r0, #0
   1e8aa:	bd38      	pop	{r3, r4, r5, pc}
   1e8ac:	20021d60 	.word	0x20021d60

0001e8b0 <net_tcp_accept>:
}

int net_tcp_accept(struct net_context *context,
		   net_tcp_accept_cb_t cb,
		   void *user_data)
{
   1e8b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct sockaddr local_addr;
	struct sockaddr *laddr = NULL;
	u16_t lport = 0U;
	int ret;

	NET_ASSERT(context->tcp);
   1e8b4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
   1e8b6:	b088      	sub	sp, #32
   1e8b8:	4604      	mov	r4, r0
   1e8ba:	460e      	mov	r6, r1
   1e8bc:	4617      	mov	r7, r2
	NET_ASSERT(context->tcp);
   1e8be:	b973      	cbnz	r3, 1e8de <net_tcp_accept+0x2e>
   1e8c0:	4933      	ldr	r1, [pc, #204]	; (1e990 <net_tcp_accept+0xe0>)
   1e8c2:	f640 2334 	movw	r3, #2612	; 0xa34
   1e8c6:	4a33      	ldr	r2, [pc, #204]	; (1e994 <net_tcp_accept+0xe4>)
   1e8c8:	4833      	ldr	r0, [pc, #204]	; (1e998 <net_tcp_accept+0xe8>)
   1e8ca:	f014 fe7d 	bl	335c8 <printk>
   1e8ce:	4833      	ldr	r0, [pc, #204]	; (1e99c <net_tcp_accept+0xec>)
   1e8d0:	f014 fe7a 	bl	335c8 <printk>
   1e8d4:	f640 2134 	movw	r1, #2612	; 0xa34
   1e8d8:	482e      	ldr	r0, [pc, #184]	; (1e994 <net_tcp_accept+0xe4>)
   1e8da:	f015 f976 	bl	33bca <assert_post_action>

	if (net_tcp_get_state(context->tcp) != NET_TCP_LISTEN) {
   1e8de:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	return (enum net_tcp_state)tcp->state;
   1e8e0:	f8d2 30bc 	ldr.w	r3, [r2, #188]	; 0xbc
   1e8e4:	f3c3 3343 	ubfx	r3, r3, #13, #4
   1e8e8:	2b01      	cmp	r3, #1
   1e8ea:	d14b      	bne.n	1e984 <net_tcp_accept+0xd4>
		NET_DBG("Context %p in wrong state %d, should be %d",
			context, context->tcp->state, NET_TCP_LISTEN);
		return -EINVAL;
	}

	if (cb == NULL) {
   1e8ec:	b93e      	cbnz	r6, 1e8fe <net_tcp_accept+0x4e>
		/* The context is being shut down */
		if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   1e8ee:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
   1e8f2:	2b06      	cmp	r3, #6
   1e8f4:	d103      	bne.n	1e8fe <net_tcp_accept+0x4e>
			context->tcp->accept_cb = NULL;
   1e8f6:	f8c2 609c 	str.w	r6, [r2, #156]	; 0x9c
	/* accept callback is only valid for TCP contexts */
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
		context->tcp->accept_cb = cb;
	}

	return 0;
   1e8fa:	2000      	movs	r0, #0
   1e8fc:	e044      	b.n	1e988 <net_tcp_accept+0xd8>
	local_addr.sa_family = net_context_get_family(context);
   1e8fe:	4620      	mov	r0, r4
   1e900:	f7ff f80c 	bl	1d91c <net_context_get_family>
   1e904:	f8ad 0018 	strh.w	r0, [sp, #24]
	if (net_context_get_family(context) == AF_INET) {
   1e908:	4620      	mov	r0, r4
   1e90a:	f7ff f807 	bl	1d91c <net_context_get_family>
   1e90e:	2801      	cmp	r0, #1
   1e910:	d135      	bne.n	1e97e <net_tcp_accept+0xce>
		if (net_sin_ptr(&context->local)->sin_addr) {
   1e912:	f8d4 8020 	ldr.w	r8, [r4, #32]
   1e916:	f1b8 0f00 	cmp.w	r8, #0
   1e91a:	d004      	beq.n	1e926 <net_tcp_accept+0x76>
			net_ipaddr_copy(&net_sin(&local_addr)->sin_addr,
   1e91c:	f8d8 3000 	ldr.w	r3, [r8]
   1e920:	9307      	str	r3, [sp, #28]
			laddr = &local_addr;
   1e922:	f10d 0818 	add.w	r8, sp, #24
		net_sin(&local_addr)->sin_port = lport =
   1e926:	8be5      	ldrh	r5, [r4, #30]
   1e928:	f8ad 501a 	strh.w	r5, [sp, #26]
	ret = net_tcp_register(net_context_get_family(context),
   1e92c:	4620      	mov	r0, r4
   1e92e:	f7fe fff5 	bl	1d91c <net_context_get_family>
   1e932:	f104 032c 	add.w	r3, r4, #44	; 0x2c
   1e936:	b2c1      	uxtb	r1, r0
	return net_conn_register(IPPROTO_TCP, family, remote_addr, local_addr,
   1e938:	e9cd 4303 	strd	r4, r3, [sp, #12]
			       ntohs(net_sin(&context->remote)->sin_port),
   1e93c:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
   1e93e:	4b18      	ldr	r3, [pc, #96]	; (1e9a0 <net_tcp_accept+0xf0>)
	ret = net_tcp_register(net_context_get_family(context),
   1e940:	f8b4 207a 	ldrh.w	r2, [r4, #122]	; 0x7a
   1e944:	9302      	str	r3, [sp, #8]
			       ntohs(net_sin(&context->remote)->sin_port),
   1e946:	0203      	lsls	r3, r0, #8
   1e948:	ea43 2310 	orr.w	r3, r3, r0, lsr #8
   1e94c:	ba6d      	rev16	r5, r5
	ret = net_tcp_register(net_context_get_family(context),
   1e94e:	f412 7280 	ands.w	r2, r2, #256	; 0x100
   1e952:	b29b      	uxth	r3, r3
   1e954:	b2ad      	uxth	r5, r5
   1e956:	bf18      	it	ne
   1e958:	f104 0224 	addne.w	r2, r4, #36	; 0x24
   1e95c:	9300      	str	r3, [sp, #0]
   1e95e:	9501      	str	r5, [sp, #4]
   1e960:	4643      	mov	r3, r8
   1e962:	2006      	movs	r0, #6
   1e964:	f7fe fdd8 	bl	1d518 <net_conn_register>
	if (ret < 0) {
   1e968:	2800      	cmp	r0, #0
   1e96a:	db0d      	blt.n	1e988 <net_tcp_accept+0xd8>
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   1e96c:	f8b4 3078 	ldrh.w	r3, [r4, #120]	; 0x78
	context->user_data = user_data;
   1e970:	6027      	str	r7, [r4, #0]
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   1e972:	2b06      	cmp	r3, #6
   1e974:	d1c1      	bne.n	1e8fa <net_tcp_accept+0x4a>
		context->tcp->accept_cb = cb;
   1e976:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1e978:	f8c3 609c 	str.w	r6, [r3, #156]	; 0x9c
   1e97c:	e7bd      	b.n	1e8fa <net_tcp_accept+0x4a>
	u16_t lport = 0U;
   1e97e:	2500      	movs	r5, #0
	struct sockaddr *laddr = NULL;
   1e980:	46a8      	mov	r8, r5
   1e982:	e7d3      	b.n	1e92c <net_tcp_accept+0x7c>
		return -EINVAL;
   1e984:	f06f 0015 	mvn.w	r0, #21
}
   1e988:	b008      	add	sp, #32
   1e98a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1e98e:	bf00      	nop
   1e990:	0003dc7f 	.word	0x0003dc7f
   1e994:	0003dc4d 	.word	0x0003dc4d
   1e998:	0003b77f 	.word	0x0003b77f
   1e99c:	0003cb8b 	.word	0x0003cb8b
   1e9a0:	0001e37d 	.word	0x0001e37d

0001e9a4 <net_tcp_connect>:
		    u16_t rport,
		    u16_t lport,
		    k_timeout_t timeout,
		    net_context_connect_cb_t cb,
		    void *user_data)
{
   1e9a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   1e9a8:	461d      	mov	r5, r3
	int ret;

	NET_ASSERT(context->tcp);
   1e9aa:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
   1e9ac:	b087      	sub	sp, #28
   1e9ae:	4604      	mov	r4, r0
   1e9b0:	460f      	mov	r7, r1
   1e9b2:	4691      	mov	r9, r2
   1e9b4:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
	NET_ASSERT(context->tcp);
   1e9b8:	b973      	cbnz	r3, 1e9d8 <net_tcp_connect+0x34>
   1e9ba:	492a      	ldr	r1, [pc, #168]	; (1ea64 <net_tcp_connect+0xc0>)
   1e9bc:	f640 2384 	movw	r3, #2692	; 0xa84
   1e9c0:	4a29      	ldr	r2, [pc, #164]	; (1ea68 <net_tcp_connect+0xc4>)
   1e9c2:	482a      	ldr	r0, [pc, #168]	; (1ea6c <net_tcp_connect+0xc8>)
   1e9c4:	f014 fe00 	bl	335c8 <printk>
   1e9c8:	4829      	ldr	r0, [pc, #164]	; (1ea70 <net_tcp_connect+0xcc>)
   1e9ca:	f014 fdfd 	bl	335c8 <printk>
   1e9ce:	f640 2184 	movw	r1, #2692	; 0xa84
   1e9d2:	4825      	ldr	r0, [pc, #148]	; (1ea68 <net_tcp_connect+0xc4>)
   1e9d4:	f015 f8f9 	bl	33bca <assert_post_action>
	return (enum net_sock_type)((context->flags & NET_CONTEXT_TYPE) >> 6);
   1e9d8:	f8b4 607a 	ldrh.w	r6, [r4, #122]	; 0x7a
   1e9dc:	f3c6 1681 	ubfx	r6, r6, #6, #2

	if (net_context_get_type(context) != SOCK_STREAM) {
   1e9e0:	2e01      	cmp	r6, #1
   1e9e2:	d002      	beq.n	1e9ea <net_tcp_connect+0x46>
		return -ENOTSUP;
   1e9e4:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1e9e8:	e036      	b.n	1ea58 <net_tcp_connect+0xb4>
	}

	/* We need to register a handler, otherwise the SYN-ACK
	 * packet would not be received.
	 */
	ret = net_tcp_register(net_context_get_family(context),
   1e9ea:	4620      	mov	r0, r4
   1e9ec:	f7fe ff96 	bl	1d91c <net_context_get_family>
   1e9f0:	f104 032c 	add.w	r3, r4, #44	; 0x2c
   1e9f4:	e9cd 4303 	strd	r4, r3, [sp, #12]
   1e9f8:	4b1e      	ldr	r3, [pc, #120]	; (1ea74 <net_tcp_connect+0xd0>)
   1e9fa:	ba6d      	rev16	r5, r5
   1e9fc:	9302      	str	r3, [sp, #8]
   1e9fe:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   1ea02:	b2ad      	uxth	r5, r5
   1ea04:	ba5b      	rev16	r3, r3
   1ea06:	b29b      	uxth	r3, r3
   1ea08:	9301      	str	r3, [sp, #4]
   1ea0a:	b2c1      	uxtb	r1, r0
   1ea0c:	9500      	str	r5, [sp, #0]
   1ea0e:	464b      	mov	r3, r9
   1ea10:	463a      	mov	r2, r7
   1ea12:	2006      	movs	r0, #6
   1ea14:	f7fe fd80 	bl	1d518 <net_conn_register>
			       ntohs(rport),
			       ntohs(lport),
			       tcp_synack_received,
			       context,
			       &context->conn_handler);
	if (ret < 0) {
   1ea18:	2800      	cmp	r0, #0
   1ea1a:	db1d      	blt.n	1ea58 <net_tcp_connect+0xb4>
	net_tcp_change_state(context->tcp, NET_TCP_SYN_SENT);
   1ea1c:	4625      	mov	r5, r4
		return ret;
	}

	context->connect_cb = cb;
   1ea1e:	9b10      	ldr	r3, [sp, #64]	; 0x40
	context->user_data = user_data;

	net_context_set_state(context, NET_CONTEXT_CONNECTING);
   1ea20:	4631      	mov	r1, r6
	context->connect_cb = cb;
   1ea22:	63a3      	str	r3, [r4, #56]	; 0x38
	context->user_data = user_data;
   1ea24:	9b11      	ldr	r3, [sp, #68]	; 0x44
	net_context_set_state(context, NET_CONTEXT_CONNECTING);
   1ea26:	4620      	mov	r0, r4
	context->user_data = user_data;
   1ea28:	6023      	str	r3, [r4, #0]
	net_context_set_state(context, NET_CONTEXT_CONNECTING);
   1ea2a:	f7fe ffb7 	bl	1d99c <net_context_set_state>
	net_tcp_change_state(context->tcp, NET_TCP_SYN_SENT);
   1ea2e:	f855 0f3c 	ldr.w	r0, [r5, #60]!
   1ea32:	2102      	movs	r1, #2
   1ea34:	f7ff f99a 	bl	1dd6c <net_tcp_change_state>
	return send_syn_segment(context, NULL, remote, NET_TCP_SYN, "SYN");
   1ea38:	2302      	movs	r3, #2
   1ea3a:	463a      	mov	r2, r7
   1ea3c:	2100      	movs	r1, #0
   1ea3e:	4628      	mov	r0, r5
   1ea40:	f018 f8b6 	bl	36bb0 <send_syn_segment.isra.35>

	send_syn(context, addr);

	/* in tcp_synack_received() we give back this semaphore */
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1ea44:	f1b8 0f00 	cmp.w	r8, #0
   1ea48:	d005      	beq.n	1ea56 <net_tcp_connect+0xb2>
	    k_sem_take(&context->tcp->connect_wait, timeout)) {
   1ea4a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   1ea4c:	30a0      	adds	r0, #160	; 0xa0
	return z_impl_k_sem_take(sem, timeout);
   1ea4e:	4641      	mov	r1, r8
   1ea50:	f00f fb10 	bl	2e074 <z_impl_k_sem_take>
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   1ea54:	b918      	cbnz	r0, 1ea5e <net_tcp_connect+0xba>
		return -ETIMEDOUT;
	}

	return 0;
   1ea56:	2000      	movs	r0, #0
}
   1ea58:	b007      	add	sp, #28
   1ea5a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return -ETIMEDOUT;
   1ea5e:	f06f 0073 	mvn.w	r0, #115	; 0x73
   1ea62:	e7f9      	b.n	1ea58 <net_tcp_connect+0xb4>
   1ea64:	0003dc7f 	.word	0x0003dc7f
   1ea68:	0003dc4d 	.word	0x0003dc4d
   1ea6c:	0003b77f 	.word	0x0003b77f
   1ea70:	0003cb8b 	.word	0x0003cb8b
   1ea74:	0001e1e5 	.word	0x0001e1e5

0001ea78 <connect_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int connect_request_encode(const struct mqtt_client *client,
			   struct buf_ctx *buf)
{
   1ea78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	} else {
		mqtt_proto_desc = &mqtt_3_1_0_proto_desc;
	}

	/* Reserve space for fixed header. */
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1ea7c:	680f      	ldr	r7, [r1, #0]
	u8_t connect_flags = client->clean_session << 1;
   1ea7e:	f890 507c 	ldrb.w	r5, [r0, #124]	; 0x7c
	start = buf->cur;

	MQTT_TRC("Encoding Protocol Description. Str:%s Size:%08x.",
		 mqtt_proto_desc->utf8, mqtt_proto_desc->size);

	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1ea82:	4b3b      	ldr	r3, [pc, #236]	; (1eb70 <connect_request_encode+0xf8>)
   1ea84:	4a3b      	ldr	r2, [pc, #236]	; (1eb74 <connect_request_encode+0xfc>)
{
   1ea86:	4606      	mov	r6, r0
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   1ea88:	f890 007a 	ldrb.w	r0, [r0, #122]	; 0x7a
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1ea8c:	3705      	adds	r7, #5
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1ea8e:	2804      	cmp	r0, #4
   1ea90:	bf0c      	ite	eq
   1ea92:	4610      	moveq	r0, r2
   1ea94:	4618      	movne	r0, r3
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   1ea96:	600f      	str	r7, [r1, #0]
{
   1ea98:	460c      	mov	r4, r1
	err_code = pack_utf8_str(mqtt_proto_desc, buf);
   1ea9a:	f018 fc0b 	bl	372b4 <pack_utf8_str>
	u8_t connect_flags = client->clean_session << 1;
   1ea9e:	f3c5 0540 	ubfx	r5, r5, #1, #1
	if (err_code != 0) {
   1eaa2:	4603      	mov	r3, r0
   1eaa4:	b938      	cbnz	r0, 1eab6 <connect_request_encode+0x3e>
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1eaa6:	e9d4 2000 	ldrd	r2, r0, [r4]
   1eaaa:	4290      	cmp	r0, r2
		return err_code;
	}

	MQTT_TRC("Encoding Protocol Version %02x.", client->protocol_version);
	err_code = pack_uint8(client->protocol_version, buf);
   1eaac:	f896 107a 	ldrb.w	r1, [r6, #122]	; 0x7a
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1eab0:	d104      	bne.n	1eabc <connect_request_encode+0x44>
		return -ENOMEM;
   1eab2:	f06f 030b 	mvn.w	r3, #11

	/* Write the flags the connect flags. */
	*connect_flags_pos = connect_flags;

	return mqtt_encode_fixed_header(message_type, start, buf);
}
   1eab6:	4618      	mov	r0, r3
   1eab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	*(buf->cur++) = val;
   1eabc:	1c50      	adds	r0, r2, #1
   1eabe:	6020      	str	r0, [r4, #0]
   1eac0:	7011      	strb	r1, [r2, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   1eac2:	e9d4 8200 	ldrd	r8, r2, [r4]
   1eac6:	4590      	cmp	r8, r2
   1eac8:	d0f3      	beq.n	1eab2 <connect_request_encode+0x3a>
	*(buf->cur++) = val;
   1eaca:	f108 0201 	add.w	r2, r8, #1
   1eace:	6022      	str	r2, [r4, #0]
   1ead0:	f888 3000 	strb.w	r3, [r8]
	err_code = pack_uint16(client->keepalive, buf);
   1ead4:	4621      	mov	r1, r4
   1ead6:	f8b6 0078 	ldrh.w	r0, [r6, #120]	; 0x78
   1eada:	f018 fbd9 	bl	37290 <pack_uint16>
	if (err_code != 0) {
   1eade:	4603      	mov	r3, r0
   1eae0:	2800      	cmp	r0, #0
   1eae2:	d1e8      	bne.n	1eab6 <connect_request_encode+0x3e>
	err_code = pack_utf8_str(&client->client_id, buf);
   1eae4:	f106 0048 	add.w	r0, r6, #72	; 0x48
   1eae8:	f018 fbe4 	bl	372b4 <pack_utf8_str>
	if (err_code != 0) {
   1eaec:	4603      	mov	r3, r0
   1eaee:	2800      	cmp	r0, #0
   1eaf0:	d1e1      	bne.n	1eab6 <connect_request_encode+0x3e>
	if (client->will_topic != NULL) {
   1eaf2:	6df0      	ldr	r0, [r6, #92]	; 0x5c
	u8_t connect_flags = client->clean_session << 1;
   1eaf4:	006d      	lsls	r5, r5, #1
	if (client->will_topic != NULL) {
   1eaf6:	b1d8      	cbz	r0, 1eb30 <connect_request_encode+0xb8>
		connect_flags |= client->will_retain << 5;
   1eaf8:	f896 307c 	ldrb.w	r3, [r6, #124]	; 0x7c
		connect_flags |= MQTT_CONNECT_FLAG_WILL_TOPIC;
   1eafc:	f045 0504 	orr.w	r5, r5, #4
		connect_flags |= client->will_retain << 5;
   1eb00:	f003 0301 	and.w	r3, r3, #1
   1eb04:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   1eb08:	7a03      	ldrb	r3, [r0, #8]
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   1eb0a:	4621      	mov	r1, r4
		connect_flags |= ((client->will_topic->qos & 0x03) << 3);
   1eb0c:	00db      	lsls	r3, r3, #3
   1eb0e:	f003 0318 	and.w	r3, r3, #24
		connect_flags |= client->will_retain << 5;
   1eb12:	431d      	orrs	r5, r3
		err_code = pack_utf8_str(&client->will_topic->topic, buf);
   1eb14:	f018 fbce 	bl	372b4 <pack_utf8_str>
		if (err_code != 0) {
   1eb18:	4603      	mov	r3, r0
   1eb1a:	2800      	cmp	r0, #0
   1eb1c:	d1cb      	bne.n	1eab6 <connect_request_encode+0x3e>
		if (client->will_message != NULL) {
   1eb1e:	6e33      	ldr	r3, [r6, #96]	; 0x60
			err_code = pack_utf8_str(client->will_message, buf);
   1eb20:	4621      	mov	r1, r4
		if (client->will_message != NULL) {
   1eb22:	b313      	cbz	r3, 1eb6a <connect_request_encode+0xf2>
			err_code = pack_utf8_str(client->will_message, buf);
   1eb24:	4618      	mov	r0, r3
   1eb26:	f018 fbc5 	bl	372b4 <pack_utf8_str>
			if (err_code != 0) {
   1eb2a:	4603      	mov	r3, r0
   1eb2c:	2800      	cmp	r0, #0
   1eb2e:	d1c2      	bne.n	1eab6 <connect_request_encode+0x3e>
	if (client->user_name != NULL) {
   1eb30:	6d70      	ldr	r0, [r6, #84]	; 0x54
   1eb32:	b138      	cbz	r0, 1eb44 <connect_request_encode+0xcc>
		err_code = pack_utf8_str(client->user_name, buf);
   1eb34:	4621      	mov	r1, r4
   1eb36:	f018 fbbd 	bl	372b4 <pack_utf8_str>
		if (err_code != 0) {
   1eb3a:	4603      	mov	r3, r0
   1eb3c:	2800      	cmp	r0, #0
   1eb3e:	d1ba      	bne.n	1eab6 <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_USERNAME;
   1eb40:	f045 0580 	orr.w	r5, r5, #128	; 0x80
	if (client->password != NULL) {
   1eb44:	6db0      	ldr	r0, [r6, #88]	; 0x58
   1eb46:	b138      	cbz	r0, 1eb58 <connect_request_encode+0xe0>
		err_code = pack_utf8_str(client->password, buf);
   1eb48:	4621      	mov	r1, r4
   1eb4a:	f018 fbb3 	bl	372b4 <pack_utf8_str>
		if (err_code != 0) {
   1eb4e:	4603      	mov	r3, r0
   1eb50:	2800      	cmp	r0, #0
   1eb52:	d1b0      	bne.n	1eab6 <connect_request_encode+0x3e>
		connect_flags |= MQTT_CONNECT_FLAG_PASSWORD;
   1eb54:	f045 0540 	orr.w	r5, r5, #64	; 0x40
	*connect_flags_pos = connect_flags;
   1eb58:	f888 5000 	strb.w	r5, [r8]
	return mqtt_encode_fixed_header(message_type, start, buf);
   1eb5c:	4622      	mov	r2, r4
   1eb5e:	4639      	mov	r1, r7
}
   1eb60:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   1eb64:	2010      	movs	r0, #16
   1eb66:	f018 bbc0 	b.w	372ea <mqtt_encode_fixed_header>
	return pack_uint16(0x0000, buf);
   1eb6a:	f018 fb91 	bl	37290 <pack_uint16>
   1eb6e:	e7dc      	b.n	1eb2a <connect_request_encode+0xb2>
   1eb70:	0003a51c 	.word	0x0003a51c
   1eb74:	0003a524 	.word	0x0003a524

0001eb78 <disconnect_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
}

int disconnect_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(disc_packet)) {
   1eb78:	e9d0 2300 	ldrd	r2, r3, [r0]
   1eb7c:	1a9b      	subs	r3, r3, r2
   1eb7e:	2b01      	cmp	r3, #1
   1eb80:	bf81      	itttt	hi
   1eb82:	4b05      	ldrhi	r3, [pc, #20]	; (1eb98 <disconnect_encode+0x20>)
   1eb84:	881b      	ldrhhi	r3, [r3, #0]
   1eb86:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, disc_packet, sizeof(disc_packet));
	buf->end = buf->cur + sizeof(disc_packet);
   1eb88:	6803      	ldrhi	r3, [r0, #0]
   1eb8a:	bf83      	ittte	hi
   1eb8c:	3302      	addhi	r3, #2
   1eb8e:	6043      	strhi	r3, [r0, #4]

	return 0;
   1eb90:	2000      	movhi	r0, #0
		return -ENOMEM;
   1eb92:	f06f 000b 	mvnls.w	r0, #11
}
   1eb96:	4770      	bx	lr
   1eb98:	0003dca9 	.word	0x0003dca9

0001eb9c <ping_request_encode>:
	return mqtt_encode_fixed_header(message_type, start, buf);
}

int ping_request_encode(struct buf_ctx *buf)
{
	if (buf->end - buf->cur < sizeof(ping_packet)) {
   1eb9c:	e9d0 2300 	ldrd	r2, r3, [r0]
   1eba0:	1a9b      	subs	r3, r3, r2
   1eba2:	2b01      	cmp	r3, #1
   1eba4:	bf81      	itttt	hi
   1eba6:	4b05      	ldrhi	r3, [pc, #20]	; (1ebbc <ping_request_encode+0x20>)
   1eba8:	881b      	ldrhhi	r3, [r3, #0]
   1ebaa:	8013      	strhhi	r3, [r2, #0]
		return -ENOMEM;
	}

	memcpy(buf->cur, ping_packet, sizeof(ping_packet));
	buf->end = buf->cur + sizeof(ping_packet);
   1ebac:	6803      	ldrhi	r3, [r0, #0]
   1ebae:	bf83      	ittte	hi
   1ebb0:	3302      	addhi	r3, #2
   1ebb2:	6043      	strhi	r3, [r0, #4]

	return 0;
   1ebb4:	2000      	movhi	r0, #0
		return -ENOMEM;
   1ebb6:	f06f 000b 	mvnls.w	r0, #11
}
   1ebba:	4770      	bx	lr
   1ebbc:	0003dcab 	.word	0x0003dcab

0001ebc0 <mqtt_transport_connect>:
#endif /* CONFIG_MQTT_LIB_WEBSOCKET */
};

int mqtt_transport_connect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].connect(client);
   1ebc0:	2314      	movs	r3, #20
   1ebc2:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
   1ebc6:	4353      	muls	r3, r2
   1ebc8:	4a01      	ldr	r2, [pc, #4]	; (1ebd0 <mqtt_transport_connect+0x10>)
   1ebca:	58d3      	ldr	r3, [r2, r3]
   1ebcc:	4718      	bx	r3
   1ebce:	bf00      	nop
   1ebd0:	0003a52c 	.word	0x0003a52c

0001ebd4 <mqtt_transport_write>:
}

int mqtt_transport_write(struct mqtt_client *client, const u8_t *data,
			 u32_t datalen)
{
   1ebd4:	b430      	push	{r4, r5}
	return transport_fn[client->transport.type].write(client, data,
   1ebd6:	2514      	movs	r5, #20
   1ebd8:	4c03      	ldr	r4, [pc, #12]	; (1ebe8 <mqtt_transport_write+0x14>)
   1ebda:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   1ebde:	fb05 4303 	mla	r3, r5, r3, r4
							  datalen);
}
   1ebe2:	bc30      	pop	{r4, r5}
	return transport_fn[client->transport.type].write(client, data,
   1ebe4:	685b      	ldr	r3, [r3, #4]
   1ebe6:	4718      	bx	r3
   1ebe8:	0003a52c 	.word	0x0003a52c

0001ebec <mqtt_transport_write_msg>:

int mqtt_transport_write_msg(struct mqtt_client *client,
			     const struct msghdr *message)
{
   1ebec:	b410      	push	{r4}
	return transport_fn[client->transport.type].write_msg(client, message);
   1ebee:	2414      	movs	r4, #20
   1ebf0:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   1ebf4:	4a03      	ldr	r2, [pc, #12]	; (1ec04 <mqtt_transport_write_msg+0x18>)
   1ebf6:	fb04 2303 	mla	r3, r4, r3, r2
}
   1ebfa:	f85d 4b04 	ldr.w	r4, [sp], #4
	return transport_fn[client->transport.type].write_msg(client, message);
   1ebfe:	689b      	ldr	r3, [r3, #8]
   1ec00:	4718      	bx	r3
   1ec02:	bf00      	nop
   1ec04:	0003a52c 	.word	0x0003a52c

0001ec08 <mqtt_transport_read>:

int mqtt_transport_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			bool shall_block)
{
   1ec08:	b470      	push	{r4, r5, r6}
	return transport_fn[client->transport.type].read(client, data, buflen,
   1ec0a:	2614      	movs	r6, #20
   1ec0c:	4d04      	ldr	r5, [pc, #16]	; (1ec20 <mqtt_transport_read+0x18>)
   1ec0e:	f890 4024 	ldrb.w	r4, [r0, #36]	; 0x24
   1ec12:	fb06 5404 	mla	r4, r6, r4, r5
   1ec16:	68e4      	ldr	r4, [r4, #12]
   1ec18:	46a4      	mov	ip, r4
							 shall_block);
}
   1ec1a:	bc70      	pop	{r4, r5, r6}
	return transport_fn[client->transport.type].read(client, data, buflen,
   1ec1c:	4760      	bx	ip
   1ec1e:	bf00      	nop
   1ec20:	0003a52c 	.word	0x0003a52c

0001ec24 <mqtt_transport_disconnect>:

int mqtt_transport_disconnect(struct mqtt_client *client)
{
	return transport_fn[client->transport.type].disconnect(client);
   1ec24:	2114      	movs	r1, #20
   1ec26:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   1ec2a:	4a02      	ldr	r2, [pc, #8]	; (1ec34 <mqtt_transport_disconnect+0x10>)
   1ec2c:	fb01 2303 	mla	r3, r1, r3, r2
   1ec30:	691b      	ldr	r3, [r3, #16]
   1ec32:	4718      	bx	r3
   1ec34:	0003a52c 	.word	0x0003a52c

0001ec38 <mqtt_mutex_unlock>:
	return k_mutex_lock(&mutex->kernel_mutex, timeout);
}

static inline int sys_mutex_unlock(struct sys_mutex *mutex)
{
	if (mutex->kernel_mutex.lock_count == 0) {
   1ec38:	68c2      	ldr	r2, [r0, #12]
}

/**@brief Release the lock on the module specific mutex, if any.
 */
static inline void mqtt_mutex_unlock(struct mqtt_client *client)
{
   1ec3a:	b510      	push	{r4, lr}
   1ec3c:	b142      	cbz	r2, 1ec50 <mqtt_mutex_unlock+0x18>
		return -EINVAL;
	}

	if (mutex->kernel_mutex.owner != _current) {
   1ec3e:	4b0f      	ldr	r3, [pc, #60]	; (1ec7c <mqtt_mutex_unlock+0x44>)
   1ec40:	6882      	ldr	r2, [r0, #8]
   1ec42:	689b      	ldr	r3, [r3, #8]
   1ec44:	429a      	cmp	r2, r3
   1ec46:	d115      	bne.n	1ec74 <mqtt_mutex_unlock+0x3c>
	int ret = sys_mutex_unlock(&client->internal.mutex);

	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
	(void)ret;
}
   1ec48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return z_impl_k_mutex_unlock(mutex);
   1ec4c:	f00d bdbc 	b.w	2c7c8 <z_impl_k_mutex_unlock>
		return -EINVAL;
   1ec50:	f06f 0415 	mvn.w	r4, #21
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   1ec54:	2343      	movs	r3, #67	; 0x43
   1ec56:	4a0a      	ldr	r2, [pc, #40]	; (1ec80 <mqtt_mutex_unlock+0x48>)
   1ec58:	490a      	ldr	r1, [pc, #40]	; (1ec84 <mqtt_mutex_unlock+0x4c>)
   1ec5a:	480b      	ldr	r0, [pc, #44]	; (1ec88 <mqtt_mutex_unlock+0x50>)
   1ec5c:	f014 fcb4 	bl	335c8 <printk>
   1ec60:	4621      	mov	r1, r4
   1ec62:	480a      	ldr	r0, [pc, #40]	; (1ec8c <mqtt_mutex_unlock+0x54>)
   1ec64:	f014 fcb0 	bl	335c8 <printk>
}
   1ec68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_unlock failed with %d", ret);
   1ec6c:	2143      	movs	r1, #67	; 0x43
   1ec6e:	4804      	ldr	r0, [pc, #16]	; (1ec80 <mqtt_mutex_unlock+0x48>)
   1ec70:	f014 bfab 	b.w	33bca <assert_post_action>
		return -EPERM;
   1ec74:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   1ec78:	e7ec      	b.n	1ec54 <mqtt_mutex_unlock+0x1c>
   1ec7a:	bf00      	nop
   1ec7c:	200274dc 	.word	0x200274dc
   1ec80:	0003dcd9 	.word	0x0003dcd9
   1ec84:	0003dd0a 	.word	0x0003dd0a
   1ec88:	0003b77f 	.word	0x0003b77f
   1ec8c:	0003dd13 	.word	0x0003dd13

0001ec90 <mqtt_mutex_lock>:
{
   1ec90:	b510      	push	{r4, lr}
	return z_impl_k_mutex_lock(mutex, timeout);
   1ec92:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1ec96:	f00d fcb9 	bl	2c60c <z_impl_k_mutex_lock>
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   1ec9a:	4604      	mov	r4, r0
   1ec9c:	b178      	cbz	r0, 1ecbe <mqtt_mutex_lock+0x2e>
   1ec9e:	2339      	movs	r3, #57	; 0x39
   1eca0:	4a07      	ldr	r2, [pc, #28]	; (1ecc0 <mqtt_mutex_lock+0x30>)
   1eca2:	4908      	ldr	r1, [pc, #32]	; (1ecc4 <mqtt_mutex_lock+0x34>)
   1eca4:	4808      	ldr	r0, [pc, #32]	; (1ecc8 <mqtt_mutex_lock+0x38>)
   1eca6:	f014 fc8f 	bl	335c8 <printk>
   1ecaa:	4621      	mov	r1, r4
   1ecac:	4807      	ldr	r0, [pc, #28]	; (1eccc <mqtt_mutex_lock+0x3c>)
   1ecae:	f014 fc8b 	bl	335c8 <printk>
}
   1ecb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	__ASSERT(ret == 0, "sys_mutex_lock failed with %d", ret);
   1ecb6:	2139      	movs	r1, #57	; 0x39
   1ecb8:	4801      	ldr	r0, [pc, #4]	; (1ecc0 <mqtt_mutex_lock+0x30>)
   1ecba:	f014 bf86 	b.w	33bca <assert_post_action>
}
   1ecbe:	bd10      	pop	{r4, pc}
   1ecc0:	0003dcd9 	.word	0x0003dcd9
   1ecc4:	0003dd0a 	.word	0x0003dd0a
   1ecc8:	0003b77f 	.word	0x0003b77f
   1eccc:	0003dcb9 	.word	0x0003dcb9

0001ecd0 <z_impl_entropy_get_entropy>:
				  u16_t length);

static inline int z_impl_entropy_get_entropy(struct device *dev,
					    u8_t *buffer,
					    u16_t length)
{
   1ecd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct entropy_driver_api *api =
   1ecd4:	6885      	ldr	r5, [r0, #8]
{
   1ecd6:	4604      	mov	r4, r0
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
   1ecd8:	682b      	ldr	r3, [r5, #0]
{
   1ecda:	460e      	mov	r6, r1
   1ecdc:	4617      	mov	r7, r2
	__ASSERT(api->get_entropy != NULL,
   1ecde:	b963      	cbnz	r3, 1ecfa <z_impl_entropy_get_entropy+0x2a>
   1ece0:	4909      	ldr	r1, [pc, #36]	; (1ed08 <z_impl_entropy_get_entropy+0x38>)
   1ece2:	234c      	movs	r3, #76	; 0x4c
   1ece4:	4a09      	ldr	r2, [pc, #36]	; (1ed0c <z_impl_entropy_get_entropy+0x3c>)
   1ece6:	480a      	ldr	r0, [pc, #40]	; (1ed10 <z_impl_entropy_get_entropy+0x40>)
   1ece8:	f014 fc6e 	bl	335c8 <printk>
   1ecec:	4809      	ldr	r0, [pc, #36]	; (1ed14 <z_impl_entropy_get_entropy+0x44>)
   1ecee:	f014 fc6b 	bl	335c8 <printk>
   1ecf2:	214c      	movs	r1, #76	; 0x4c
   1ecf4:	4805      	ldr	r0, [pc, #20]	; (1ed0c <z_impl_entropy_get_entropy+0x3c>)
   1ecf6:	f014 ff68 	bl	33bca <assert_post_action>
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
   1ecfa:	682b      	ldr	r3, [r5, #0]
   1ecfc:	463a      	mov	r2, r7
   1ecfe:	4631      	mov	r1, r6
   1ed00:	4620      	mov	r0, r4
}
   1ed02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return api->get_entropy(dev, buffer, length);
   1ed06:	4718      	bx	r3
   1ed08:	0003de21 	.word	0x0003de21
   1ed0c:	0003ddf4 	.word	0x0003ddf4
   1ed10:	0003b77f 	.word	0x0003b77f
   1ed14:	0003de41 	.word	0x0003de41

0001ed18 <sys_rand32_get>:

static struct device *entropy_driver;

#if defined(CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR)
u32_t sys_rand32_get(void)
{
   1ed18:	b537      	push	{r0, r1, r2, r4, r5, lr}
	struct device *dev = entropy_driver;
   1ed1a:	4d12      	ldr	r5, [pc, #72]	; (1ed64 <sys_rand32_get+0x4c>)
   1ed1c:	682c      	ldr	r4, [r5, #0]
	u32_t random_num;
	int ret;

	if (unlikely(!dev)) {
   1ed1e:	b99c      	cbnz	r4, 1ed48 <sys_rand32_get+0x30>
   1ed20:	4811      	ldr	r0, [pc, #68]	; (1ed68 <sys_rand32_get+0x50>)
   1ed22:	f00c fd77 	bl	2b814 <z_impl_device_get_binding>
		/* Only one entropy device exists, so this is safe even
		 * if the whole operation isn't atomic.
		 */
		dev = device_get_binding(DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		__ASSERT((dev != NULL),
   1ed26:	4604      	mov	r4, r0
   1ed28:	b968      	cbnz	r0, 1ed46 <sys_rand32_get+0x2e>
   1ed2a:	231d      	movs	r3, #29
   1ed2c:	4a0f      	ldr	r2, [pc, #60]	; (1ed6c <sys_rand32_get+0x54>)
   1ed2e:	4910      	ldr	r1, [pc, #64]	; (1ed70 <sys_rand32_get+0x58>)
   1ed30:	4810      	ldr	r0, [pc, #64]	; (1ed74 <sys_rand32_get+0x5c>)
   1ed32:	f014 fc49 	bl	335c8 <printk>
   1ed36:	490c      	ldr	r1, [pc, #48]	; (1ed68 <sys_rand32_get+0x50>)
   1ed38:	480f      	ldr	r0, [pc, #60]	; (1ed78 <sys_rand32_get+0x60>)
   1ed3a:	f014 fc45 	bl	335c8 <printk>
   1ed3e:	211d      	movs	r1, #29
   1ed40:	480a      	ldr	r0, [pc, #40]	; (1ed6c <sys_rand32_get+0x54>)
   1ed42:	f014 ff42 	bl	33bca <assert_post_action>
			"Device driver for %s (DT_CHOSEN_ZEPHYR_ENTROPY_LABEL) not found. "
			"Check your build configuration!",
			DT_CHOSEN_ZEPHYR_ENTROPY_LABEL);
		entropy_driver = dev;
   1ed46:	602c      	str	r4, [r5, #0]
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke3(*(uintptr_t *)&dev, *(uintptr_t *)&buffer, *(uintptr_t *)&length, K_SYSCALL_ENTROPY_GET_ENTROPY);
	}
#endif
	compiler_barrier();
	return z_impl_entropy_get_entropy(dev, buffer, length);
   1ed48:	2204      	movs	r2, #4
   1ed4a:	4620      	mov	r0, r4
   1ed4c:	eb0d 0102 	add.w	r1, sp, r2
   1ed50:	f7ff ffbe 	bl	1ecd0 <z_impl_entropy_get_entropy>
	}

	ret = entropy_get_entropy(dev, (u8_t *)&random_num,
				  sizeof(random_num));
	if (unlikely(ret < 0)) {
   1ed54:	2800      	cmp	r0, #0
   1ed56:	da02      	bge.n	1ed5e <sys_rand32_get+0x46>
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
   1ed58:	f7fb fbd2 	bl	1a500 <z_timer_cycle_get_32>
		 * 32-bit of data.  There's not much that can be done in this
		 * situation.  An __ASSERT() isn't used here as the HWRNG might
		 * still be gathering entropy during early boot situations.
		 */

		random_num = k_cycle_get_32();
   1ed5c:	9001      	str	r0, [sp, #4]
	}

	return random_num;
}
   1ed5e:	9801      	ldr	r0, [sp, #4]
   1ed60:	b003      	add	sp, #12
   1ed62:	bd30      	pop	{r4, r5, pc}
   1ed64:	20022218 	.word	0x20022218
   1ed68:	0003dd35 	.word	0x0003dd35
   1ed6c:	0003dd43 	.word	0x0003dd43
   1ed70:	0003dd7c 	.word	0x0003dd7c
   1ed74:	0003b77f 	.word	0x0003b77f
   1ed78:	0003dd91 	.word	0x0003dd91

0001ed7c <default_CSPRNG>:

	return res == TC_CRYPTO_SUCCESS ? 0 : -EINVAL;
}

int default_CSPRNG(u8_t *dest, unsigned int size)
{
   1ed7c:	b507      	push	{r0, r1, r2, lr}
	int res = tc_ctr_prng_generate(&prng_state, NULL, 0, dest, size);
   1ed7e:	2200      	movs	r2, #0
   1ed80:	9100      	str	r1, [sp, #0]
   1ed82:	4603      	mov	r3, r0
   1ed84:	4611      	mov	r1, r2
   1ed86:	4803      	ldr	r0, [pc, #12]	; (1ed94 <default_CSPRNG+0x18>)
   1ed88:	f016 fafd 	bl	35386 <tc_ctr_prng_generate>
	return res;
}
   1ed8c:	b003      	add	sp, #12
   1ed8e:	f85d fb04 	ldr.w	pc, [sp], #4
   1ed92:	bf00      	nop
   1ed94:	20020920 	.word	0x20020920

0001ed98 <jwt_add_payload>:
{
   1ed98:	b530      	push	{r4, r5, lr}
   1ed9a:	b087      	sub	sp, #28
	struct jwt_payload payload = {
   1ed9c:	e9cd 1203 	strd	r1, r2, [sp, #12]
	base64_outch(builder, '.');
   1eda0:	212e      	movs	r1, #46	; 0x2e
{
   1eda2:	4604      	mov	r4, r0
	struct jwt_payload payload = {
   1eda4:	9305      	str	r3, [sp, #20]
	base64_outch(builder, '.');
   1eda6:	f018 ffa4 	bl	37cf2 <base64_outch>
	int res = json_obj_encode(jwt_payload_desc,
   1edaa:	4b07      	ldr	r3, [pc, #28]	; (1edc8 <jwt_add_payload+0x30>)
   1edac:	9000      	str	r0, [sp, #0]
   1edae:	aa03      	add	r2, sp, #12
   1edb0:	2103      	movs	r1, #3
   1edb2:	4806      	ldr	r0, [pc, #24]	; (1edcc <jwt_add_payload+0x34>)
   1edb4:	f7f9 feee 	bl	18b94 <json_obj_encode>
   1edb8:	4605      	mov	r5, r0
	base64_flush(builder);
   1edba:	4620      	mov	r0, r4
   1edbc:	f018 ffac 	bl	37d18 <base64_flush>
}
   1edc0:	4628      	mov	r0, r5
   1edc2:	b007      	add	sp, #28
   1edc4:	bd30      	pop	{r4, r5, pc}
   1edc6:	bf00      	nop
   1edc8:	00037d91 	.word	0x00037d91
   1edcc:	200200e4 	.word	0x200200e4

0001edd0 <jwt_sign>:

int jwt_sign(struct jwt_builder *builder,
	     const char *der_key,
	     size_t der_key_len)
{
   1edd0:	b5f0      	push	{r4, r5, r6, r7, lr}
   1edd2:	4605      	mov	r5, r0
   1edd4:	b0b7      	sub	sp, #220	; 0xdc
	struct tc_sha256_state_struct ctx;
	u8_t hash[32], sig[64];
	int res;

	tc_sha256_init(&ctx);
   1edd6:	a81a      	add	r0, sp, #104	; 0x68
{
   1edd8:	460f      	mov	r7, r1
	tc_sha256_init(&ctx);
   1edda:	f7fb fe5b 	bl	1aa94 <tc_sha256_init>
	tc_sha256_update(&ctx, builder->base, builder->buf - builder->base);
   1edde:	e9d5 1200 	ldrd	r1, r2, [r5]
   1ede2:	a81a      	add	r0, sp, #104	; 0x68
   1ede4:	1a52      	subs	r2, r2, r1
   1ede6:	f016 f9b5 	bl	35154 <tc_sha256_update>
	tc_sha256_final(hash, &ctx);
   1edea:	a91a      	add	r1, sp, #104	; 0x68
   1edec:	a802      	add	r0, sp, #8
   1edee:	f016 f9dd 	bl	351ac <tc_sha256_final>
	if (prng_init) {
   1edf2:	4b1b      	ldr	r3, [pc, #108]	; (1ee60 <jwt_sign+0x90>)
   1edf4:	781c      	ldrb	r4, [r3, #0]
   1edf6:	b17c      	cbz	r4, 1ee18 <jwt_sign+0x48>
	res = setup_prng();

	if (res != 0) {
		return res;
	}
	uECC_set_rng(&default_CSPRNG);
   1edf8:	481a      	ldr	r0, [pc, #104]	; (1ee64 <jwt_sign+0x94>)
   1edfa:	f7fb fbd3 	bl	1a5a4 <uECC_set_rng>

	/* Note that tinycrypt only supports P-256. */
	res = uECC_sign(der_key, hash, sizeof(hash),
   1edfe:	4b1a      	ldr	r3, [pc, #104]	; (1ee68 <jwt_sign+0x98>)
   1ee00:	2220      	movs	r2, #32
   1ee02:	9300      	str	r3, [sp, #0]
   1ee04:	a902      	add	r1, sp, #8
   1ee06:	ab0a      	add	r3, sp, #40	; 0x28
   1ee08:	4638      	mov	r0, r7
   1ee0a:	f015 fadd 	bl	343c8 <uECC_sign>
			sig, &curve_secp256r1);
	if (res != TC_CRYPTO_SUCCESS) {
   1ee0e:	2801      	cmp	r0, #1
   1ee10:	d017      	beq.n	1ee42 <jwt_sign+0x72>
		return -EINVAL;
   1ee12:	f06f 0015 	mvn.w	r0, #21
   1ee16:	e021      	b.n	1ee5c <jwt_sign+0x8c>
	prng_init = true;
   1ee18:	2201      	movs	r2, #1
   1ee1a:	ae0a      	add	r6, sp, #40	; 0x28
   1ee1c:	701a      	strb	r2, [r3, #0]
		u32_t rv = sys_rand32_get();
   1ee1e:	f7ff ff7b 	bl	1ed18 <sys_rand32_get>
   1ee22:	3404      	adds	r4, #4
	for (int i = 0; i < sizeof(entropy); i += sizeof(u32_t)) {
   1ee24:	2c20      	cmp	r4, #32
   1ee26:	f846 0b04 	str.w	r0, [r6], #4
   1ee2a:	d1f8      	bne.n	1ee1e <jwt_sign+0x4e>
	int res = tc_ctr_prng_init(&prng_state,
   1ee2c:	2319      	movs	r3, #25
   1ee2e:	4622      	mov	r2, r4
   1ee30:	9300      	str	r3, [sp, #0]
   1ee32:	a90a      	add	r1, sp, #40	; 0x28
   1ee34:	4b0d      	ldr	r3, [pc, #52]	; (1ee6c <jwt_sign+0x9c>)
   1ee36:	480e      	ldr	r0, [pc, #56]	; (1ee70 <jwt_sign+0xa0>)
   1ee38:	f016 fa57 	bl	352ea <tc_ctr_prng_init>
	return res == TC_CRYPTO_SUCCESS ? 0 : -EINVAL;
   1ee3c:	2801      	cmp	r0, #1
   1ee3e:	d0db      	beq.n	1edf8 <jwt_sign+0x28>
   1ee40:	e7e7      	b.n	1ee12 <jwt_sign+0x42>
	}

	base64_outch(builder, '.');
   1ee42:	212e      	movs	r1, #46	; 0x2e
   1ee44:	4628      	mov	r0, r5
   1ee46:	f018 ff54 	bl	37cf2 <base64_outch>
	base64_append_bytes(sig, sizeof(sig), builder);
   1ee4a:	462a      	mov	r2, r5
   1ee4c:	2140      	movs	r1, #64	; 0x40
   1ee4e:	a80a      	add	r0, sp, #40	; 0x28
   1ee50:	f018 ff9e 	bl	37d90 <base64_append_bytes>
	base64_flush(builder);
   1ee54:	4628      	mov	r0, r5
   1ee56:	f018 ff5f 	bl	37d18 <base64_flush>

	return 0;
   1ee5a:	2000      	movs	r0, #0
}
   1ee5c:	b037      	add	sp, #220	; 0xdc
   1ee5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1ee60:	20027fb8 	.word	0x20027fb8
   1ee64:	0001ed7d 	.word	0x0001ed7d
   1ee68:	0003a574 	.word	0x0003a574
   1ee6c:	0003de67 	.word	0x0003de67
   1ee70:	20020920 	.word	0x20020920

0001ee74 <jwt_init_builder>:
		     size_t buffer_size)
{
	builder->base = buffer;
	builder->buf = buffer;
	builder->len = buffer_size;
	builder->overflowed = false;
   1ee74:	2300      	movs	r3, #0
{
   1ee76:	b513      	push	{r0, r1, r4, lr}
	builder->buf = buffer;
   1ee78:	e9c0 1100 	strd	r1, r1, [r0]
	builder->len = buffer_size;
   1ee7c:	6082      	str	r2, [r0, #8]
	builder->overflowed = false;
   1ee7e:	7303      	strb	r3, [r0, #12]
	builder->pending = 0;
   1ee80:	6103      	str	r3, [r0, #16]
{
   1ee82:	4604      	mov	r4, r0
	int res = json_obj_encode(jwt_header_desc, ARRAY_SIZE(jwt_header_desc),
   1ee84:	9000      	str	r0, [sp, #0]
   1ee86:	4b06      	ldr	r3, [pc, #24]	; (1eea0 <jwt_init_builder+0x2c>)
   1ee88:	4a06      	ldr	r2, [pc, #24]	; (1eea4 <jwt_init_builder+0x30>)
   1ee8a:	2102      	movs	r1, #2
   1ee8c:	4806      	ldr	r0, [pc, #24]	; (1eea8 <jwt_init_builder+0x34>)
   1ee8e:	f7f9 fe81 	bl	18b94 <json_obj_encode>
	if (res != 0) {
   1ee92:	b910      	cbnz	r0, 1ee9a <jwt_init_builder+0x26>
	base64_flush(builder);
   1ee94:	4620      	mov	r0, r4
   1ee96:	f018 ff3f 	bl	37d18 <base64_flush>

	jwt_add_header(builder);

	return 0;
}
   1ee9a:	2000      	movs	r0, #0
   1ee9c:	b002      	add	sp, #8
   1ee9e:	bd10      	pop	{r4, pc}
   1eea0:	00037d91 	.word	0x00037d91
   1eea4:	0003a624 	.word	0x0003a624
   1eea8:	200200c4 	.word	0x200200c4

0001eeac <gpio_nrfx_manage_callback>:
}

static int gpio_nrfx_manage_callback(struct device *port,
				     struct gpio_callback *callback,
				     bool set)
{
   1eeac:	b570      	push	{r4, r5, r6, lr}
   1eeae:	4616      	mov	r6, r2
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1eeb0:	68c4      	ldr	r4, [r0, #12]
 */
static inline int gpio_manage_callback(sys_slist_t *callbacks,
					struct gpio_callback *callback,
					bool set)
{
	__ASSERT(callback, "No callback!");
   1eeb2:	460d      	mov	r5, r1
   1eeb4:	b961      	cbnz	r1, 1eed0 <gpio_nrfx_manage_callback+0x24>
   1eeb6:	4922      	ldr	r1, [pc, #136]	; (1ef40 <gpio_nrfx_manage_callback+0x94>)
   1eeb8:	2324      	movs	r3, #36	; 0x24
   1eeba:	4a22      	ldr	r2, [pc, #136]	; (1ef44 <gpio_nrfx_manage_callback+0x98>)
   1eebc:	4822      	ldr	r0, [pc, #136]	; (1ef48 <gpio_nrfx_manage_callback+0x9c>)
   1eebe:	f014 fb83 	bl	335c8 <printk>
   1eec2:	4822      	ldr	r0, [pc, #136]	; (1ef4c <gpio_nrfx_manage_callback+0xa0>)
   1eec4:	f014 fb80 	bl	335c8 <printk>
   1eec8:	2124      	movs	r1, #36	; 0x24
   1eeca:	481e      	ldr	r0, [pc, #120]	; (1ef44 <gpio_nrfx_manage_callback+0x98>)
   1eecc:	f014 fe7d 	bl	33bca <assert_post_action>
	__ASSERT(callback->handler, "No callback handler!");
   1eed0:	686b      	ldr	r3, [r5, #4]
   1eed2:	b963      	cbnz	r3, 1eeee <gpio_nrfx_manage_callback+0x42>
   1eed4:	491e      	ldr	r1, [pc, #120]	; (1ef50 <gpio_nrfx_manage_callback+0xa4>)
   1eed6:	2325      	movs	r3, #37	; 0x25
   1eed8:	4a1a      	ldr	r2, [pc, #104]	; (1ef44 <gpio_nrfx_manage_callback+0x98>)
   1eeda:	481b      	ldr	r0, [pc, #108]	; (1ef48 <gpio_nrfx_manage_callback+0x9c>)
   1eedc:	f014 fb74 	bl	335c8 <printk>
   1eee0:	481c      	ldr	r0, [pc, #112]	; (1ef54 <gpio_nrfx_manage_callback+0xa8>)
   1eee2:	f014 fb71 	bl	335c8 <printk>
   1eee6:	2125      	movs	r1, #37	; 0x25
   1eee8:	4816      	ldr	r0, [pc, #88]	; (1ef44 <gpio_nrfx_manage_callback+0x98>)
   1eeea:	f014 fe6e 	bl	33bca <assert_post_action>
Z_GENLIST_IS_EMPTY(slist)
   1eeee:	6863      	ldr	r3, [r4, #4]

	if (!sys_slist_is_empty(callbacks)) {
   1eef0:	b15b      	cbz	r3, 1ef0a <gpio_nrfx_manage_callback+0x5e>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1eef2:	2200      	movs	r2, #0
   1eef4:	429d      	cmp	r5, r3
   1eef6:	d113      	bne.n	1ef20 <gpio_nrfx_manage_callback+0x74>
Z_GENLIST_REMOVE(slist, snode)
   1eef8:	682b      	ldr	r3, [r5, #0]
   1eefa:	b95a      	cbnz	r2, 1ef14 <gpio_nrfx_manage_callback+0x68>
   1eefc:	68a2      	ldr	r2, [r4, #8]
	list->head = node;
   1eefe:	6063      	str	r3, [r4, #4]
Z_GENLIST_REMOVE(slist, snode)
   1ef00:	4295      	cmp	r5, r2
   1ef02:	d100      	bne.n	1ef06 <gpio_nrfx_manage_callback+0x5a>
	list->tail = node;
   1ef04:	60a3      	str	r3, [r4, #8]
	parent->next = child;
   1ef06:	2300      	movs	r3, #0
   1ef08:	602b      	str	r3, [r5, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
   1ef0a:	b976      	cbnz	r6, 1ef2a <gpio_nrfx_manage_callback+0x7e>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
   1ef0c:	2000      	movs	r0, #0
				     callback, set);
}
   1ef0e:	bd70      	pop	{r4, r5, r6, pc}
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1ef10:	460b      	mov	r3, r1
   1ef12:	e7ef      	b.n	1eef4 <gpio_nrfx_manage_callback+0x48>
	parent->next = child;
   1ef14:	6013      	str	r3, [r2, #0]
Z_GENLIST_REMOVE(slist, snode)
   1ef16:	68a3      	ldr	r3, [r4, #8]
   1ef18:	429d      	cmp	r5, r3
	list->tail = node;
   1ef1a:	bf08      	it	eq
   1ef1c:	60a2      	streq	r2, [r4, #8]
   1ef1e:	e7f2      	b.n	1ef06 <gpio_nrfx_manage_callback+0x5a>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1ef20:	6819      	ldr	r1, [r3, #0]
	return node->next;
   1ef22:	461a      	mov	r2, r3
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1ef24:	2900      	cmp	r1, #0
   1ef26:	d1f3      	bne.n	1ef10 <gpio_nrfx_manage_callback+0x64>
			if (!set) {
   1ef28:	b13e      	cbz	r6, 1ef3a <gpio_nrfx_manage_callback+0x8e>
Z_GENLIST_PREPEND(slist, snode)
   1ef2a:	6863      	ldr	r3, [r4, #4]
	parent->next = child;
   1ef2c:	602b      	str	r3, [r5, #0]
Z_GENLIST_PREPEND(slist, snode)
   1ef2e:	68a0      	ldr	r0, [r4, #8]
	list->head = node;
   1ef30:	6065      	str	r5, [r4, #4]
Z_GENLIST_PREPEND(slist, snode)
   1ef32:	2800      	cmp	r0, #0
   1ef34:	d1ea      	bne.n	1ef0c <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
   1ef36:	60a5      	str	r5, [r4, #8]
   1ef38:	e7e9      	b.n	1ef0e <gpio_nrfx_manage_callback+0x62>
				return -EINVAL;
   1ef3a:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   1ef3e:	e7e6      	b.n	1ef0e <gpio_nrfx_manage_callback+0x62>
   1ef40:	0003dec7 	.word	0x0003dec7
   1ef44:	0003de9a 	.word	0x0003de9a
   1ef48:	0003b77f 	.word	0x0003b77f
   1ef4c:	0003ded0 	.word	0x0003ded0
   1ef50:	0003dedf 	.word	0x0003dedf
   1ef54:	0003def1 	.word	0x0003def1

0001ef58 <nrf_gpio_pin_port_decode.isra.9.part.10>:
 *
 * @param[in,out] p_pin Pointer to the absolute pin number overriden by the pin number that is relative to the port.
 *
 * @return Pointer to port register set.
 */
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   1ef58:	b510      	push	{r4, lr}
{
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1ef5a:	4c07      	ldr	r4, [pc, #28]	; (1ef78 <nrf_gpio_pin_port_decode.isra.9.part.10+0x20>)
   1ef5c:	4907      	ldr	r1, [pc, #28]	; (1ef7c <nrf_gpio_pin_port_decode.isra.9.part.10+0x24>)
   1ef5e:	4622      	mov	r2, r4
   1ef60:	4807      	ldr	r0, [pc, #28]	; (1ef80 <nrf_gpio_pin_port_decode.isra.9.part.10+0x28>)
   1ef62:	f240 230d 	movw	r3, #525	; 0x20d
   1ef66:	f014 fb2f 	bl	335c8 <printk>
   1ef6a:	4620      	mov	r0, r4
    {
        *p_pin = *p_pin & 0x1F;
        return NRF_P1;
    }
#endif
}
   1ef6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1ef70:	f240 210d 	movw	r1, #525	; 0x20d
   1ef74:	f014 be29 	b.w	33bca <assert_post_action>
   1ef78:	0003df34 	.word	0x0003df34
   1ef7c:	0003df67 	.word	0x0003df67
   1ef80:	0003b77f 	.word	0x0003b77f

0001ef84 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
   1ef84:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
   1ef86:	4b09      	ldr	r3, [pc, #36]	; (1efac <gpio_nrfx_init+0x28>)
   1ef88:	781a      	ldrb	r2, [r3, #0]
   1ef8a:	b96a      	cbnz	r2, 1efa8 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
   1ef8c:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   1ef8e:	2031      	movs	r0, #49	; 0x31
		gpio_initialized = true;
   1ef90:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
   1ef92:	2105      	movs	r1, #5
   1ef94:	f7fb fe3c 	bl	1ac10 <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
   1ef98:	2031      	movs	r0, #49	; 0x31
   1ef9a:	f7fb fe29 	bl	1abf0 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
   1ef9e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   1efa2:	4b03      	ldr	r3, [pc, #12]	; (1efb0 <gpio_nrfx_init+0x2c>)
   1efa4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
   1efa8:	2000      	movs	r0, #0
   1efaa:	bd08      	pop	{r3, pc}
   1efac:	20027fb9 	.word	0x20027fb9
   1efb0:	40031000 	.word	0x40031000

0001efb4 <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1efb4:	4b2e      	ldr	r3, [pc, #184]	; (1f070 <gpio_nrfx_config+0xbc>)
{
   1efb6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1efba:	4013      	ands	r3, r2
   1efbc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1efc0:	6840      	ldr	r0, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1efc2:	d044      	beq.n	1f04e <gpio_nrfx_config+0x9a>
   1efc4:	d808      	bhi.n	1efd8 <gpio_nrfx_config+0x24>
   1efc6:	2b02      	cmp	r3, #2
   1efc8:	d043      	beq.n	1f052 <gpio_nrfx_config+0x9e>
   1efca:	2b06      	cmp	r3, #6
   1efcc:	d043      	beq.n	1f056 <gpio_nrfx_config+0xa2>
   1efce:	2b00      	cmp	r3, #0
   1efd0:	d041      	beq.n	1f056 <gpio_nrfx_config+0xa2>
		return -EINVAL;
   1efd2:	f06f 0015 	mvn.w	r0, #21
   1efd6:	e038      	b.n	1f04a <gpio_nrfx_config+0x96>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1efd8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
   1efdc:	d03d      	beq.n	1f05a <gpio_nrfx_config+0xa6>
   1efde:	d804      	bhi.n	1efea <gpio_nrfx_config+0x36>
   1efe0:	4c24      	ldr	r4, [pc, #144]	; (1f074 <gpio_nrfx_config+0xc0>)
   1efe2:	42a3      	cmp	r3, r4
   1efe4:	d1f5      	bne.n	1efd2 <gpio_nrfx_config+0x1e>
		drive = NRF_GPIO_PIN_H0D1;
   1efe6:	2407      	movs	r4, #7
   1efe8:	e006      	b.n	1eff8 <gpio_nrfx_config+0x44>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
   1efea:	4c23      	ldr	r4, [pc, #140]	; (1f078 <gpio_nrfx_config+0xc4>)
   1efec:	42a3      	cmp	r3, r4
   1efee:	d036      	beq.n	1f05e <gpio_nrfx_config+0xaa>
   1eff0:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
   1eff4:	d1ed      	bne.n	1efd2 <gpio_nrfx_config+0x1e>
		drive = NRF_GPIO_PIN_H0H1;
   1eff6:	2403      	movs	r4, #3
	if ((flags & GPIO_PULL_UP) != 0) {
   1eff8:	06d6      	lsls	r6, r2, #27
		pull = NRF_GPIO_PIN_NOPULL;
   1effa:	bf54      	ite	pl
   1effc:	f3c2 1740 	ubfxpl	r7, r2, #5, #1
		pull = NRF_GPIO_PIN_PULLUP;
   1f000:	2703      	movmi	r7, #3
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
   1f002:	f482 7380 	eor.w	r3, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
   1f006:	0595      	lsls	r5, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
   1f008:	f3c2 2640 	ubfx	r6, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
   1f00c:	f3c3 2800 	ubfx	r8, r3, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
   1f010:	d505      	bpl.n	1f01e <gpio_nrfx_config+0x6a>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
   1f012:	0513      	lsls	r3, r2, #20
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   1f014:	6845      	ldr	r5, [r0, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
   1f016:	d524      	bpl.n	1f062 <gpio_nrfx_config+0xae>
			nrf_gpio_port_out_set(reg, BIT(pin));
   1f018:	2301      	movs	r3, #1
   1f01a:	408b      	lsls	r3, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
   1f01c:	60ab      	str	r3, [r5, #8]
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
   1f01e:	7a05      	ldrb	r5, [r0, #8]
   1f020:	f001 011f 	and.w	r1, r1, #31
   1f024:	ea41 1545 	orr.w	r5, r1, r5, lsl #5
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1f028:	4628      	mov	r0, r5
   1f02a:	f018 fec6 	bl	37dba <nrf_gpio_pin_present_check>
   1f02e:	b908      	cbnz	r0, 1f034 <gpio_nrfx_config+0x80>
   1f030:	f7ff ff92 	bl	1ef58 <nrf_gpio_pin_port_decode.isra.9.part.10>
	return 0;
   1f034:	2000      	movs	r0, #0
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1f036:	ea46 0348 	orr.w	r3, r6, r8, lsl #1
   1f03a:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1f03e:	4a0f      	ldr	r2, [pc, #60]	; (1f07c <gpio_nrfx_config+0xc8>)
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
   1f040:	ea43 0387 	orr.w	r3, r3, r7, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1f044:	3580      	adds	r5, #128	; 0x80
   1f046:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
}
   1f04a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		drive = NRF_GPIO_PIN_H0S1;
   1f04e:	2401      	movs	r4, #1
   1f050:	e7d2      	b.n	1eff8 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_D0S1;
   1f052:	2404      	movs	r4, #4
   1f054:	e7d0      	b.n	1eff8 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_S0S1;
   1f056:	461c      	mov	r4, r3
   1f058:	e7ce      	b.n	1eff8 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_S0H1;
   1f05a:	2402      	movs	r4, #2
   1f05c:	e7cc      	b.n	1eff8 <gpio_nrfx_config+0x44>
		drive = NRF_GPIO_PIN_D0H1;
   1f05e:	2405      	movs	r4, #5
   1f060:	e7ca      	b.n	1eff8 <gpio_nrfx_config+0x44>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
   1f062:	0553      	lsls	r3, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
   1f064:	bf42      	ittt	mi
   1f066:	2301      	movmi	r3, #1
   1f068:	408b      	lslmi	r3, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
   1f06a:	60eb      	strmi	r3, [r5, #12]
   1f06c:	e7d7      	b.n	1f01e <gpio_nrfx_config+0x6a>
   1f06e:	bf00      	nop
   1f070:	00f00006 	.word	0x00f00006
   1f074:	00100006 	.word	0x00100006
   1f078:	00400002 	.word	0x00400002
   1f07c:	40842500 	.word	0x40842500

0001f080 <nrf_gpio_cfg_sense_set>:
{
   1f080:	b538      	push	{r3, r4, r5, lr}
   1f082:	4605      	mov	r5, r0
   1f084:	460c      	mov	r4, r1
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1f086:	f018 fe98 	bl	37dba <nrf_gpio_pin_present_check>
   1f08a:	b908      	cbnz	r0, 1f090 <nrf_gpio_cfg_sense_set+0x10>
   1f08c:	f7ff ff64 	bl	1ef58 <nrf_gpio_pin_port_decode.isra.9.part.10>
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
   1f090:	4805      	ldr	r0, [pc, #20]	; (1f0a8 <nrf_gpio_cfg_sense_set+0x28>)
   1f092:	eb00 0085 	add.w	r0, r0, r5, lsl #2
   1f096:	f8d0 1200 	ldr.w	r1, [r0, #512]	; 0x200
   1f09a:	f421 3140 	bic.w	r1, r1, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
   1f09e:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
   1f0a2:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
}
   1f0a6:	bd38      	pop	{r3, r4, r5, pc}
   1f0a8:	40842500 	.word	0x40842500

0001f0ac <gpiote_pin_int_cfg>:
{
   1f0ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f0b0:	6843      	ldr	r3, [r0, #4]
   1f0b2:	f001 041f 	and.w	r4, r1, #31
   1f0b6:	7a1b      	ldrb	r3, [r3, #8]
{
   1f0b8:	460d      	mov	r5, r1
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f0ba:	ea44 1443 	orr.w	r4, r4, r3, lsl #5
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f0be:	2300      	movs	r3, #0
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
   1f0c0:	4e46      	ldr	r6, [pc, #280]	; (1f1dc <gpiote_pin_int_cfg+0x130>)
	struct gpio_nrfx_data *data = get_port_data(port);
   1f0c2:	68c7      	ldr	r7, [r0, #12]
   1f0c4:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
   1f0c8:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1f0ca:	f503 71a2 	add.w	r1, r3, #324	; 0x144
   1f0ce:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
   1f0d2:	f3c1 2104 	ubfx	r1, r1, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
   1f0d6:	428c      	cmp	r4, r1
   1f0d8:	d167      	bne.n	1f1aa <gpiote_pin_int_cfg+0xfe>
		    && (intenset & BIT(i))) {
   1f0da:	fa22 f103 	lsr.w	r1, r2, r3
   1f0de:	07c9      	lsls	r1, r1, #31
   1f0e0:	d563      	bpl.n	1f1aa <gpiote_pin_int_cfg+0xfe>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
   1f0e2:	009a      	lsls	r2, r3, #2
   1f0e4:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1f0e8:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
   1f0ec:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
   1f0f0:	f021 0101 	bic.w	r1, r1, #1
   1f0f4:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
   1f0f8:	2201      	movs	r2, #1
   1f0fa:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
   1f0fe:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1f102:	4620      	mov	r0, r4
   1f104:	2100      	movs	r1, #0
   1f106:	f7ff ffbb 	bl	1f080 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
   1f10a:	68f8      	ldr	r0, [r7, #12]
   1f10c:	40e8      	lsrs	r0, r5
   1f10e:	f010 0001 	ands.w	r0, r0, #1
   1f112:	d048      	beq.n	1f1a6 <gpiote_pin_int_cfg+0xfa>
   1f114:	6938      	ldr	r0, [r7, #16]
   1f116:	40e8      	lsrs	r0, r5
   1f118:	f010 0001 	ands.w	r0, r0, #1
   1f11c:	d043      	beq.n	1f1a6 <gpiote_pin_int_cfg+0xfa>
		if (data->trig_edge & BIT(pin)) {
   1f11e:	69b8      	ldr	r0, [r7, #24]
   1f120:	40e8      	lsrs	r0, r5
   1f122:	f010 0801 	ands.w	r8, r0, #1
   1f126:	d04c      	beq.n	1f1c2 <gpiote_pin_int_cfg+0x116>
			if (data->double_edge & BIT(pin)) {
   1f128:	69fb      	ldr	r3, [r7, #28]
   1f12a:	40eb      	lsrs	r3, r5
   1f12c:	07db      	lsls	r3, r3, #31
   1f12e:	d440      	bmi.n	1f1b2 <gpiote_pin_int_cfg+0x106>
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
   1f130:	697b      	ldr	r3, [r7, #20]
   1f132:	fa23 f505 	lsr.w	r5, r3, r5
				pol = NRF_GPIOTE_POLARITY_HITOLO;
   1f136:	f015 0f01 	tst.w	r5, #1
   1f13a:	bf14      	ite	ne
   1f13c:	2501      	movne	r5, #1
   1f13e:	2502      	moveq	r5, #2
   1f140:	2100      	movs	r1, #0
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
   1f142:	f501 73a2 	add.w	r3, r1, #324	; 0x144
   1f146:	f856 0023 	ldr.w	r0, [r6, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
   1f14a:	f010 0003 	ands.w	r0, r0, #3
   1f14e:	d132      	bne.n	1f1b6 <gpiote_pin_int_cfg+0x10a>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1f150:	008b      	lsls	r3, r1, #2
   1f152:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   1f156:	f503 3344 	add.w	r3, r3, #200704	; 0x31000
   1f15a:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f15e:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
   1f160:	f422 3247 	bic.w	r2, r2, #203776	; 0x31c00
   1f164:	f422 7240 	bic.w	r2, r2, #768	; 0x300
   1f168:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f16c:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   1f170:	f404 54f8 	and.w	r4, r4, #7936	; 0x1f00
   1f174:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
   1f178:	4314      	orrs	r4, r2
			nrf_gpiote_event_t evt =
   1f17a:	f101 0240 	add.w	r2, r1, #64	; 0x40
   1f17e:	0092      	lsls	r2, r2, #2
    return ((uint32_t)p_reg + event);
   1f180:	b292      	uxth	r2, r2
   1f182:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
   1f186:	f502 3244 	add.w	r2, r2, #200704	; 0x31000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
   1f18a:	f8c3 4510 	str.w	r4, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f18e:	6010      	str	r0, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
   1f190:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
   1f194:	f042 0201 	orr.w	r2, r2, #1
   1f198:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
   1f19c:	2301      	movs	r3, #1
   1f19e:	fa03 f101 	lsl.w	r1, r3, r1
    p_reg->INTENSET = mask;
   1f1a2:	f8c6 1304 	str.w	r1, [r6, #772]	; 0x304
}
   1f1a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f1aa:	3301      	adds	r3, #1
   1f1ac:	2b08      	cmp	r3, #8
   1f1ae:	d18c      	bne.n	1f0ca <gpiote_pin_int_cfg+0x1e>
   1f1b0:	e7a7      	b.n	1f102 <gpiote_pin_int_cfg+0x56>
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
   1f1b2:	2503      	movs	r5, #3
   1f1b4:	e7c4      	b.n	1f140 <gpiote_pin_int_cfg+0x94>
   1f1b6:	3101      	adds	r1, #1
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
   1f1b8:	2908      	cmp	r1, #8
   1f1ba:	d1c2      	bne.n	1f142 <gpiote_pin_int_cfg+0x96>
	return -ENODEV;
   1f1bc:	f06f 0012 	mvn.w	r0, #18
   1f1c0:	e7f1      	b.n	1f1a6 <gpiote_pin_int_cfg+0xfa>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1f1c2:	697b      	ldr	r3, [r7, #20]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1f1c4:	4620      	mov	r0, r4
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1f1c6:	fa23 f505 	lsr.w	r5, r3, r5
		return NRF_GPIO_PIN_SENSE_HIGH;
   1f1ca:	f015 0f01 	tst.w	r5, #1
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1f1ce:	bf0c      	ite	eq
   1f1d0:	2103      	moveq	r1, #3
   1f1d2:	2102      	movne	r1, #2
   1f1d4:	f7ff ff54 	bl	1f080 <nrf_gpio_cfg_sense_set>
	int res = 0;
   1f1d8:	4640      	mov	r0, r8
   1f1da:	e7e4      	b.n	1f1a6 <gpiote_pin_int_cfg+0xfa>
   1f1dc:	40031000 	.word	0x40031000

0001f1e0 <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
   1f1e0:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
   1f1e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1f1e8:	4605      	mov	r5, r0
   1f1ea:	460f      	mov	r7, r1
   1f1ec:	4690      	mov	r8, r2
   1f1ee:	461e      	mov	r6, r3
	struct gpio_nrfx_data *data = get_port_data(port);
   1f1f0:	68c4      	ldr	r4, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
   1f1f2:	d13c      	bne.n	1f26e <gpio_nrfx_pin_interrupt_configure+0x8e>
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
   1f1f4:	6843      	ldr	r3, [r0, #4]
   1f1f6:	f001 091f 	and.w	r9, r1, #31
   1f1fa:	7a1b      	ldrb	r3, [r3, #8]
   1f1fc:	ea49 1943 	orr.w	r9, r9, r3, lsl #5
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1f200:	4648      	mov	r0, r9
   1f202:	f018 fdda 	bl	37dba <nrf_gpio_pin_present_check>
   1f206:	b908      	cbnz	r0, 1f20c <gpio_nrfx_pin_interrupt_configure+0x2c>
   1f208:	f7ff fea6 	bl	1ef58 <nrf_gpio_pin_port_decode.isra.9.part.10>
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
   1f20c:	4b1f      	ldr	r3, [pc, #124]	; (1f28c <gpio_nrfx_pin_interrupt_configure+0xac>)
   1f20e:	f109 0980 	add.w	r9, r9, #128	; 0x80
   1f212:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
   1f216:	07db      	lsls	r3, r3, #31
   1f218:	d433      	bmi.n	1f282 <gpio_nrfx_pin_interrupt_configure+0xa2>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   1f21a:	2301      	movs	r3, #1
   1f21c:	68e2      	ldr	r2, [r4, #12]
   1f21e:	40bb      	lsls	r3, r7
   1f220:	4313      	orrs	r3, r2
   1f222:	60e3      	str	r3, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   1f224:	2301      	movs	r3, #1
   1f226:	6922      	ldr	r2, [r4, #16]
   1f228:	40bb      	lsls	r3, r7
   1f22a:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
   1f22e:	bf14      	ite	ne
   1f230:	431a      	orrne	r2, r3
   1f232:	439a      	biceq	r2, r3
   1f234:	6122      	str	r2, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
   1f236:	69a2      	ldr	r2, [r4, #24]
   1f238:	f5b8 3fa0 	cmp.w	r8, #81920	; 0x14000
   1f23c:	bf0c      	ite	eq
   1f23e:	431a      	orreq	r2, r3
   1f240:	439a      	bicne	r2, r3
   1f242:	61a2      	str	r2, [r4, #24]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
   1f244:	69e2      	ldr	r2, [r4, #28]
   1f246:	f5b6 2fc0 	cmp.w	r6, #393216	; 0x60000
   1f24a:	bf0c      	ite	eq
   1f24c:	431a      	orreq	r2, r3
   1f24e:	439a      	bicne	r2, r3
   1f250:	61e2      	str	r2, [r4, #28]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
   1f252:	6962      	ldr	r2, [r4, #20]
   1f254:	f5b6 2f80 	cmp.w	r6, #262144	; 0x40000
   1f258:	bf0c      	ite	eq
   1f25a:	4313      	orreq	r3, r2
   1f25c:	ea22 0303 	bicne.w	r3, r2, r3
   1f260:	6163      	str	r3, [r4, #20]
	return gpiote_pin_int_cfg(port, pin);
   1f262:	4639      	mov	r1, r7
   1f264:	4628      	mov	r0, r5
}
   1f266:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return gpiote_pin_int_cfg(port, pin);
   1f26a:	f7ff bf1f 	b.w	1f0ac <gpiote_pin_int_cfg>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
   1f26e:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
   1f272:	d1d2      	bne.n	1f21a <gpio_nrfx_pin_interrupt_configure+0x3a>
   1f274:	2301      	movs	r3, #1
   1f276:	fa03 f201 	lsl.w	r2, r3, r1
   1f27a:	68e3      	ldr	r3, [r4, #12]
   1f27c:	ea23 0302 	bic.w	r3, r3, r2
   1f280:	e7cf      	b.n	1f222 <gpio_nrfx_pin_interrupt_configure+0x42>
}
   1f282:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1f286:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1f28a:	bf00      	nop
   1f28c:	40842500 	.word	0x40842500

0001f290 <gpiote_event_handler>:
{
   1f290:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1f294:	4f53      	ldr	r7, [pc, #332]	; (1f3e4 <gpiote_event_handler+0x154>)
   1f296:	683e      	ldr	r6, [r7, #0]
	if (port_event) {
   1f298:	2e00      	cmp	r6, #0
   1f29a:	d05c      	beq.n	1f356 <gpiote_event_handler+0xc6>
	u32_t bit = 1U << pin;
   1f29c:	f04f 0801 	mov.w	r8, #1
	u32_t pin = 0U;
   1f2a0:	f04f 0900 	mov.w	r9, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   1f2a4:	4a50      	ldr	r2, [pc, #320]	; (1f3e8 <gpiote_event_handler+0x158>)
   1f2a6:	68d3      	ldr	r3, [r2, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   1f2a8:	f8d2 a004 	ldr.w	sl, [r2, #4]
	u32_t out = data->int_en & data->pin_int_en;
   1f2ac:	e9d3 2503 	ldrd	r2, r5, [r3, #12]
   1f2b0:	4015      	ands	r5, r2
	out &= ~data->trig_edge & ~data->double_edge;
   1f2b2:	e9d3 2106 	ldrd	r2, r1, [r3, #24]
   1f2b6:	430a      	orrs	r2, r1
   1f2b8:	ea25 0502 	bic.w	r5, r5, r2
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
   1f2bc:	f8da 2004 	ldr.w	r2, [sl, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
   1f2c0:	695b      	ldr	r3, [r3, #20]
    return p_reg->IN;
   1f2c2:	6914      	ldr	r4, [r2, #16]
   1f2c4:	405c      	eors	r4, r3
	u32_t out = pin_states & level_pins;
   1f2c6:	ea25 0404 	bic.w	r4, r5, r4
	while (level_pins) {
   1f2ca:	bb8d      	cbnz	r5, 1f330 <gpiote_event_handler+0xa0>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f2cc:	603d      	str	r5, [r7, #0]
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1f2ce:	2300      	movs	r3, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
   1f2d0:	2001      	movs	r0, #1
   1f2d2:	461f      	mov	r7, r3
    return p_reg->INTENSET & mask;
   1f2d4:	4945      	ldr	r1, [pc, #276]	; (1f3ec <gpiote_event_handler+0x15c>)
   1f2d6:	4d46      	ldr	r5, [pc, #280]	; (1f3f0 <gpiote_event_handler+0x160>)
   1f2d8:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
   1f2dc:	fa00 fc03 	lsl.w	ip, r0, r3
   1f2e0:	ea1c 0f02 	tst.w	ip, r2
   1f2e4:	d00d      	beq.n	1f302 <gpiote_event_handler+0x72>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   1f2e6:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
   1f2ea:	b152      	cbz	r2, 1f302 <gpiote_event_handler+0x72>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1f2ec:	f503 72a2 	add.w	r2, r3, #324	; 0x144
   1f2f0:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
   1f2f4:	f845 7023 	str.w	r7, [r5, r3, lsl #2]
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
   1f2f8:	f3c2 2204 	ubfx	r2, r2, #8, #5
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
   1f2fc:	fa00 f202 	lsl.w	r2, r0, r2
   1f300:	4314      	orrs	r4, r2
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
   1f302:	3301      	adds	r3, #1
   1f304:	2b08      	cmp	r3, #8
   1f306:	d1e7      	bne.n	1f2d8 <gpiote_event_handler+0x48>
	if (fired_triggers[0]) {
   1f308:	bb3c      	cbnz	r4, 1f35a <gpiote_event_handler+0xca>
	if (port_event) {
   1f30a:	b17e      	cbz	r6, 1f32c <gpiote_event_handler+0x9c>
	u32_t bit = 1U << pin;
   1f30c:	2601      	movs	r6, #1
	u32_t pin = 0U;
   1f30e:	2700      	movs	r7, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   1f310:	4b35      	ldr	r3, [pc, #212]	; (1f3e8 <gpiote_event_handler+0x158>)
   1f312:	68dd      	ldr	r5, [r3, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   1f314:	f8d3 8004 	ldr.w	r8, [r3, #4]
	u32_t out = data->int_en & data->pin_int_en;
   1f318:	e9d5 3403 	ldrd	r3, r4, [r5, #12]
   1f31c:	401c      	ands	r4, r3
	out &= ~data->trig_edge & ~data->double_edge;
   1f31e:	e9d5 3206 	ldrd	r3, r2, [r5, #24]
   1f322:	4313      	orrs	r3, r2
   1f324:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   1f328:	2c00      	cmp	r4, #0
   1f32a:	d145      	bne.n	1f3b8 <gpiote_event_handler+0x128>
}
   1f32c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (level_pins & bit) {
   1f330:	ea15 0f08 	tst.w	r5, r8
   1f334:	d00a      	beq.n	1f34c <gpiote_event_handler+0xbc>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f336:	f89a 3008 	ldrb.w	r3, [sl, #8]
   1f33a:	f009 001f 	and.w	r0, r9, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   1f33e:	2100      	movs	r1, #0
   1f340:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   1f344:	f7ff fe9c 	bl	1f080 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   1f348:	ea25 0508 	bic.w	r5, r5, r8
		++pin;
   1f34c:	f109 0901 	add.w	r9, r9, #1
		bit <<= 1;
   1f350:	ea4f 0848 	mov.w	r8, r8, lsl #1
   1f354:	e7b9      	b.n	1f2ca <gpiote_event_handler+0x3a>
	u32_t fired_triggers[GPIO_COUNT] = {0};
   1f356:	4634      	mov	r4, r6
   1f358:	e7b9      	b.n	1f2ce <gpiote_event_handler+0x3e>
	struct gpio_nrfx_data *data = get_port_data(port);
   1f35a:	4b23      	ldr	r3, [pc, #140]	; (1f3e8 <gpiote_event_handler+0x158>)
   1f35c:	f8d3 900c 	ldr.w	r9, [r3, #12]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1f360:	f8d9 5004 	ldr.w	r5, [r9, #4]
   1f364:	2d00      	cmp	r5, #0
   1f366:	d0d0      	beq.n	1f30a <gpiote_event_handler+0x7a>
			cb->handler(port, cb, cb->pin_mask & pins);
   1f368:	4698      	mov	r8, r3
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1f36a:	682f      	ldr	r7, [r5, #0]
			__ASSERT(cb->handler, "No callback handler!");
   1f36c:	f8df a08c 	ldr.w	sl, [pc, #140]	; 1f3fc <gpiote_event_handler+0x16c>
   1f370:	f8df b08c 	ldr.w	fp, [pc, #140]	; 1f400 <gpiote_event_handler+0x170>
		if ((cb->pin_mask & pins) & data->int_en) {
   1f374:	f8d9 3010 	ldr.w	r3, [r9, #16]
   1f378:	68aa      	ldr	r2, [r5, #8]
   1f37a:	4023      	ands	r3, r4
   1f37c:	4213      	tst	r3, r2
   1f37e:	d016      	beq.n	1f3ae <gpiote_event_handler+0x11e>
			__ASSERT(cb->handler, "No callback handler!");
   1f380:	686b      	ldr	r3, [r5, #4]
   1f382:	b973      	cbnz	r3, 1f3a2 <gpiote_event_handler+0x112>
   1f384:	4659      	mov	r1, fp
   1f386:	f240 13a7 	movw	r3, #423	; 0x1a7
   1f38a:	4652      	mov	r2, sl
   1f38c:	4819      	ldr	r0, [pc, #100]	; (1f3f4 <gpiote_event_handler+0x164>)
   1f38e:	f014 f91b 	bl	335c8 <printk>
   1f392:	4819      	ldr	r0, [pc, #100]	; (1f3f8 <gpiote_event_handler+0x168>)
   1f394:	f014 f918 	bl	335c8 <printk>
   1f398:	f240 11a7 	movw	r1, #423	; 0x1a7
   1f39c:	4650      	mov	r0, sl
   1f39e:	f014 fc14 	bl	33bca <assert_post_action>
			cb->handler(port, cb, cb->pin_mask & pins);
   1f3a2:	e9d5 3201 	ldrd	r3, r2, [r5, #4]
   1f3a6:	4629      	mov	r1, r5
   1f3a8:	4022      	ands	r2, r4
   1f3aa:	4640      	mov	r0, r8
   1f3ac:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1f3ae:	2f00      	cmp	r7, #0
   1f3b0:	d0ab      	beq.n	1f30a <gpiote_event_handler+0x7a>
   1f3b2:	463d      	mov	r5, r7
   1f3b4:	683f      	ldr	r7, [r7, #0]
   1f3b6:	e7dd      	b.n	1f374 <gpiote_event_handler+0xe4>
		if (level_pins & bit) {
   1f3b8:	4226      	tst	r6, r4
   1f3ba:	d010      	beq.n	1f3de <gpiote_event_handler+0x14e>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1f3bc:	696b      	ldr	r3, [r5, #20]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f3be:	f898 2008 	ldrb.w	r2, [r8, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   1f3c2:	40fb      	lsrs	r3, r7
		return NRF_GPIO_PIN_SENSE_HIGH;
   1f3c4:	f013 0f01 	tst.w	r3, #1
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1f3c8:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   1f3cc:	bf0c      	ite	eq
   1f3ce:	2103      	moveq	r1, #3
   1f3d0:	2102      	movne	r1, #2
   1f3d2:	ea40 1042 	orr.w	r0, r0, r2, lsl #5
   1f3d6:	f7ff fe53 	bl	1f080 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   1f3da:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   1f3de:	3701      	adds	r7, #1
		bit <<= 1;
   1f3e0:	0076      	lsls	r6, r6, #1
   1f3e2:	e7a1      	b.n	1f328 <gpiote_event_handler+0x98>
   1f3e4:	4003117c 	.word	0x4003117c
   1f3e8:	20020564 	.word	0x20020564
   1f3ec:	40031000 	.word	0x40031000
   1f3f0:	40031100 	.word	0x40031100
   1f3f4:	0003b77f 	.word	0x0003b77f
   1f3f8:	0003def1 	.word	0x0003def1
   1f3fc:	0003df08 	.word	0x0003df08
   1f400:	0003f577 	.word	0x0003f577

0001f404 <twim_2_init>:
#ifdef CONFIG_I2C_1_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(1);
#endif

#ifdef CONFIG_I2C_2_NRF_TWIM
I2C_NRFX_TWIM_DEVICE(2);
   1f404:	b510      	push	{r4, lr}
   1f406:	4604      	mov	r4, r0
   1f408:	2200      	movs	r2, #0
   1f40a:	2101      	movs	r1, #1
   1f40c:	200a      	movs	r0, #10
   1f40e:	f7fb fbff 	bl	1ac10 <z_arm_irq_priority_set>
	nrfx_err_t result = nrfx_twim_init(&get_dev_config(dev)->twim,
   1f412:	6860      	ldr	r0, [r4, #4]
   1f414:	4623      	mov	r3, r4
   1f416:	4a0e      	ldr	r2, [pc, #56]	; (1f450 <twim_2_init+0x4c>)
   1f418:	f100 0108 	add.w	r1, r0, #8
   1f41c:	f00b fd5e 	bl	2aedc <nrfx_twim_init>
	if (result != NRFX_SUCCESS) {
   1f420:	4b0c      	ldr	r3, [pc, #48]	; (1f454 <twim_2_init+0x50>)
   1f422:	4298      	cmp	r0, r3
   1f424:	d011      	beq.n	1f44a <twim_2_init+0x46>
		LOG_ERR("Failed to initialize device: %s",
   1f426:	2301      	movs	r3, #1
   1f428:	f04f 0000 	mov.w	r0, #0
   1f42c:	4a0a      	ldr	r2, [pc, #40]	; (1f458 <twim_2_init+0x54>)
   1f42e:	f363 0007 	bfi	r0, r3, #0, #8
   1f432:	4b0a      	ldr	r3, [pc, #40]	; (1f45c <twim_2_init+0x58>)
   1f434:	490a      	ldr	r1, [pc, #40]	; (1f460 <twim_2_init+0x5c>)
   1f436:	1a9b      	subs	r3, r3, r2
   1f438:	08db      	lsrs	r3, r3, #3
   1f43a:	f363 108f 	bfi	r0, r3, #6, #10
   1f43e:	6822      	ldr	r2, [r4, #0]
   1f440:	f014 fbda 	bl	33bf8 <log_string_sync>
		return -EBUSY;
   1f444:	f06f 000f 	mvn.w	r0, #15
I2C_NRFX_TWIM_DEVICE(2);
   1f448:	bd10      	pop	{r4, pc}
	return 0;
   1f44a:	2000      	movs	r0, #0
I2C_NRFX_TWIM_DEVICE(2);
   1f44c:	e7fc      	b.n	1f448 <twim_2_init+0x44>
   1f44e:	bf00      	nop
   1f450:	0001f5a9 	.word	0x0001f5a9
   1f454:	0bad0000 	.word	0x0bad0000
   1f458:	00039f60 	.word	0x00039f60
   1f45c:	00039fb0 	.word	0x00039fb0
   1f460:	0003dfd2 	.word	0x0003dfd2

0001f464 <i2c_nrfx_twim_configure>:
	if (I2C_ADDR_10_BITS & dev_config) {
   1f464:	07ca      	lsls	r2, r1, #31
{
   1f466:	b508      	push	{r3, lr}
	nrfx_twim_t const *inst = &(get_dev_config(dev)->twim);
   1f468:	6843      	ldr	r3, [r0, #4]
	if (I2C_ADDR_10_BITS & dev_config) {
   1f46a:	d413      	bmi.n	1f494 <i2c_nrfx_twim_configure+0x30>
	switch (I2C_SPEED_GET(dev_config)) {
   1f46c:	f3c1 0242 	ubfx	r2, r1, #1, #3
   1f470:	2a01      	cmp	r2, #1
   1f472:	d012      	beq.n	1f49a <i2c_nrfx_twim_configure+0x36>
   1f474:	2a02      	cmp	r2, #2
   1f476:	d019      	beq.n	1f4ac <i2c_nrfx_twim_configure+0x48>
		LOG_ERR("unsupported speed");
   1f478:	2301      	movs	r3, #1
   1f47a:	f04f 0000 	mov.w	r0, #0
   1f47e:	4a0d      	ldr	r2, [pc, #52]	; (1f4b4 <i2c_nrfx_twim_configure+0x50>)
   1f480:	f363 0007 	bfi	r0, r3, #0, #8
   1f484:	4b0c      	ldr	r3, [pc, #48]	; (1f4b8 <i2c_nrfx_twim_configure+0x54>)
   1f486:	490d      	ldr	r1, [pc, #52]	; (1f4bc <i2c_nrfx_twim_configure+0x58>)
   1f488:	1a9b      	subs	r3, r3, r2
   1f48a:	08db      	lsrs	r3, r3, #3
   1f48c:	f363 108f 	bfi	r0, r3, #6, #10
   1f490:	f014 fbb2 	bl	33bf8 <log_string_sync>
		return -EINVAL;
   1f494:	f06f 0015 	mvn.w	r0, #21
   1f498:	e007      	b.n	1f4aa <i2c_nrfx_twim_configure+0x46>
}

NRF_STATIC_INLINE void nrf_twim_frequency_set(NRF_TWIM_Type * p_reg,
                                              nrf_twim_frequency_t frequency)
{
    p_reg->FREQUENCY = frequency;
   1f49a:	f04f 72cc 	mov.w	r2, #26738688	; 0x1980000
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_100K);
   1f49e:	681b      	ldr	r3, [r3, #0]
   1f4a0:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
	get_dev_data(dev)->dev_config = dev_config;
   1f4a4:	68c3      	ldr	r3, [r0, #12]
	return 0;
   1f4a6:	2000      	movs	r0, #0
	get_dev_data(dev)->dev_config = dev_config;
   1f4a8:	6359      	str	r1, [r3, #52]	; 0x34
}
   1f4aa:	bd08      	pop	{r3, pc}
		nrf_twim_frequency_set(inst->p_twim, NRF_TWIM_FREQ_400K);
   1f4ac:	681b      	ldr	r3, [r3, #0]
   1f4ae:	f04f 62c8 	mov.w	r2, #104857600	; 0x6400000
   1f4b2:	e7f5      	b.n	1f4a0 <i2c_nrfx_twim_configure+0x3c>
   1f4b4:	00039f60 	.word	0x00039f60
   1f4b8:	00039fb0 	.word	0x00039fb0
   1f4bc:	0003df91 	.word	0x0003df91

0001f4c0 <i2c_nrfx_twim_transfer>:
{
   1f4c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1f4c4:	4604      	mov	r4, r0
   1f4c6:	b087      	sub	sp, #28
   1f4c8:	460d      	mov	r5, r1
   1f4ca:	4691      	mov	r9, r2
   1f4cc:	469a      	mov	sl, r3
	k_sem_take(&(get_dev_data(dev)->transfer_sync), K_FOREVER);
   1f4ce:	68c0      	ldr	r0, [r0, #12]
	return z_impl_k_sem_take(sem, timeout);
   1f4d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f4d4:	f00e fdce 	bl	2e074 <z_impl_k_sem_take>
	nrfx_twim_enable(&get_dev_config(dev)->twim);
   1f4d8:	6860      	ldr	r0, [r4, #4]
   1f4da:	f00b fd71 	bl	2afc0 <nrfx_twim_enable>
	for (size_t i = 0; i < num_msgs; i++) {
   1f4de:	2600      	movs	r6, #0
		if (res != NRFX_SUCCESS) {
   1f4e0:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 1f5a4 <i2c_nrfx_twim_transfer+0xe4>
	for (size_t i = 0; i < num_msgs; i++) {
   1f4e4:	454e      	cmp	r6, r9
   1f4e6:	f8d4 b004 	ldr.w	fp, [r4, #4]
   1f4ea:	d301      	bcc.n	1f4f0 <i2c_nrfx_twim_transfer+0x30>
	int ret = 0;
   1f4ec:	2500      	movs	r5, #0
   1f4ee:	e024      	b.n	1f53a <i2c_nrfx_twim_transfer+0x7a>
		if (I2C_MSG_ADDR_10_BITS & msgs[i].flags) {
   1f4f0:	7a2f      	ldrb	r7, [r5, #8]
   1f4f2:	f017 0108 	ands.w	r1, r7, #8
   1f4f6:	d149      	bne.n	1f58c <i2c_nrfx_twim_transfer+0xcc>
		nrfx_twim_xfer_desc_t cur_xfer = {
   1f4f8:	2212      	movs	r2, #18
   1f4fa:	f10d 0006 	add.w	r0, sp, #6
   1f4fe:	f019 fda5 	bl	3904c <memset>
					  NRFX_TWIM_XFER_RX : NRFX_TWIM_XFER_TX
   1f502:	f007 0301 	and.w	r3, r7, #1
		nrfx_twim_xfer_desc_t cur_xfer = {
   1f506:	f88d 3004 	strb.w	r3, [sp, #4]
   1f50a:	686b      	ldr	r3, [r5, #4]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1f50c:	f017 0f02 	tst.w	r7, #2
		nrfx_twim_xfer_desc_t cur_xfer = {
   1f510:	9302      	str	r3, [sp, #8]
   1f512:	682b      	ldr	r3, [r5, #0]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1f514:	bf0c      	ite	eq
   1f516:	2220      	moveq	r2, #32
   1f518:	2200      	movne	r2, #0
   1f51a:	a901      	add	r1, sp, #4
   1f51c:	4658      	mov	r0, fp
		nrfx_twim_xfer_desc_t cur_xfer = {
   1f51e:	f88d a005 	strb.w	sl, [sp, #5]
   1f522:	9304      	str	r3, [sp, #16]
		nrfx_err_t res = nrfx_twim_xfer(&get_dev_config(dev)->twim,
   1f524:	f00b fdac 	bl	2b080 <nrfx_twim_xfer>
		if (res != NRFX_SUCCESS) {
   1f528:	4540      	cmp	r0, r8
   1f52a:	d010      	beq.n	1f54e <i2c_nrfx_twim_transfer+0x8e>
			if (res == NRFX_ERROR_BUSY) {
   1f52c:	4b19      	ldr	r3, [pc, #100]	; (1f594 <i2c_nrfx_twim_transfer+0xd4>)
				ret = -EIO;
   1f52e:	4298      	cmp	r0, r3
   1f530:	bf0c      	ite	eq
   1f532:	f06f 050f 	mvneq.w	r5, #15
   1f536:	f06f 0504 	mvnne.w	r5, #4
	nrfx_twim_disable(&get_dev_config(dev)->twim);
   1f53a:	6860      	ldr	r0, [r4, #4]
   1f53c:	f00b fd6a 	bl	2b014 <nrfx_twim_disable>
	k_sem_give(&(get_dev_data(dev)->transfer_sync));
   1f540:	68e0      	ldr	r0, [r4, #12]
	z_impl_k_sem_give(sem);
   1f542:	f00e fd53 	bl	2dfec <z_impl_k_sem_give>
}
   1f546:	4628      	mov	r0, r5
   1f548:	b007      	add	sp, #28
   1f54a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		k_sem_take(&(get_dev_data(dev)->completion_sync), K_FOREVER);
   1f54e:	68e0      	ldr	r0, [r4, #12]
   1f550:	3018      	adds	r0, #24
	return z_impl_k_sem_take(sem, timeout);
   1f552:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f556:	f00e fd8d 	bl	2e074 <z_impl_k_sem_take>
		res = get_dev_data(dev)->res;
   1f55a:	68e3      	ldr	r3, [r4, #12]
	return dev->driver_data;
   1f55c:	350c      	adds	r5, #12
		res = get_dev_data(dev)->res;
   1f55e:	6b1a      	ldr	r2, [r3, #48]	; 0x30
		if (res != NRFX_SUCCESS) {
   1f560:	4542      	cmp	r2, r8
   1f562:	d011      	beq.n	1f588 <i2c_nrfx_twim_transfer+0xc8>
			LOG_ERR("Error %d occurred for message %d", res, i);
   1f564:	2301      	movs	r3, #1
   1f566:	f04f 0000 	mov.w	r0, #0
   1f56a:	490b      	ldr	r1, [pc, #44]	; (1f598 <i2c_nrfx_twim_transfer+0xd8>)
   1f56c:	f363 0007 	bfi	r0, r3, #0, #8
   1f570:	4b0a      	ldr	r3, [pc, #40]	; (1f59c <i2c_nrfx_twim_transfer+0xdc>)
			ret = -EIO;
   1f572:	f06f 0504 	mvn.w	r5, #4
   1f576:	1ac9      	subs	r1, r1, r3
   1f578:	08c9      	lsrs	r1, r1, #3
			LOG_ERR("Error %d occurred for message %d", res, i);
   1f57a:	f361 108f 	bfi	r0, r1, #6, #10
   1f57e:	4633      	mov	r3, r6
   1f580:	4907      	ldr	r1, [pc, #28]	; (1f5a0 <i2c_nrfx_twim_transfer+0xe0>)
   1f582:	f014 fb39 	bl	33bf8 <log_string_sync>
			break;
   1f586:	e7d8      	b.n	1f53a <i2c_nrfx_twim_transfer+0x7a>
	for (size_t i = 0; i < num_msgs; i++) {
   1f588:	3601      	adds	r6, #1
   1f58a:	e7ab      	b.n	1f4e4 <i2c_nrfx_twim_transfer+0x24>
			ret = -ENOTSUP;
   1f58c:	f06f 0585 	mvn.w	r5, #133	; 0x85
   1f590:	e7d3      	b.n	1f53a <i2c_nrfx_twim_transfer+0x7a>
   1f592:	bf00      	nop
   1f594:	0bad000b 	.word	0x0bad000b
   1f598:	00039fb0 	.word	0x00039fb0
   1f59c:	00039f60 	.word	0x00039f60
   1f5a0:	0003dfa3 	.word	0x0003dfa3
   1f5a4:	0bad0000 	.word	0x0bad0000

0001f5a8 <event_handler>:
	switch (p_event->type) {
   1f5a8:	7802      	ldrb	r2, [r0, #0]
	struct i2c_nrfx_twim_data *dev_data = get_dev_data(dev);
   1f5aa:	68cb      	ldr	r3, [r1, #12]
	switch (p_event->type) {
   1f5ac:	2a01      	cmp	r2, #1
   1f5ae:	d00a      	beq.n	1f5c6 <event_handler+0x1e>
   1f5b0:	b11a      	cbz	r2, 1f5ba <event_handler+0x12>
   1f5b2:	2a02      	cmp	r2, #2
   1f5b4:	d009      	beq.n	1f5ca <event_handler+0x22>
		dev_data->res = NRFX_ERROR_INTERNAL;
   1f5b6:	4a06      	ldr	r2, [pc, #24]	; (1f5d0 <event_handler+0x28>)
   1f5b8:	e000      	b.n	1f5bc <event_handler+0x14>
		dev_data->res = NRFX_SUCCESS;
   1f5ba:	4a06      	ldr	r2, [pc, #24]	; (1f5d4 <event_handler+0x2c>)
		dev_data->res = NRFX_ERROR_INTERNAL;
   1f5bc:	631a      	str	r2, [r3, #48]	; 0x30
	z_impl_k_sem_give(sem);
   1f5be:	f103 0018 	add.w	r0, r3, #24
   1f5c2:	f00e bd13 	b.w	2dfec <z_impl_k_sem_give>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   1f5c6:	4a04      	ldr	r2, [pc, #16]	; (1f5d8 <event_handler+0x30>)
   1f5c8:	e7f8      	b.n	1f5bc <event_handler+0x14>
		dev_data->res = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   1f5ca:	4a04      	ldr	r2, [pc, #16]	; (1f5dc <event_handler+0x34>)
   1f5cc:	e7f6      	b.n	1f5bc <event_handler+0x14>
   1f5ce:	bf00      	nop
   1f5d0:	0bad0001 	.word	0x0bad0001
   1f5d4:	0bad0000 	.word	0x0bad0000
   1f5d8:	0bae0001 	.word	0x0bae0001
   1f5dc:	0bae0002 	.word	0x0bae0002

0001f5e0 <gpio_pin_set>:
 * @retval 0 If successful.
 * @retval -EIO I/O error when accessing an external GPIO chip.
 * @retval -EWOULDBLOCK if operation would block.
 */
static inline int gpio_pin_set(struct device *port, gpio_pin_t pin, int value)
{
   1f5e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		(const struct gpio_driver_config *)port->config_info;
	const struct gpio_driver_data *const data =
			(const struct gpio_driver_data *)port->driver_data;

	(void)cfg;
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f5e4:	2501      	movs	r5, #1
   1f5e6:	6843      	ldr	r3, [r0, #4]
   1f5e8:	408d      	lsls	r5, r1
   1f5ea:	681b      	ldr	r3, [r3, #0]
{
   1f5ec:	4604      	mov	r4, r0
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f5ee:	421d      	tst	r5, r3
{
   1f5f0:	4616      	mov	r6, r2
	const struct gpio_driver_data *const data =
   1f5f2:	68c7      	ldr	r7, [r0, #12]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f5f4:	d10e      	bne.n	1f614 <gpio_pin_set+0x34>
   1f5f6:	491a      	ldr	r1, [pc, #104]	; (1f660 <gpio_pin_set+0x80>)
   1f5f8:	f240 438b 	movw	r3, #1163	; 0x48b
   1f5fc:	4a19      	ldr	r2, [pc, #100]	; (1f664 <gpio_pin_set+0x84>)
   1f5fe:	481a      	ldr	r0, [pc, #104]	; (1f668 <gpio_pin_set+0x88>)
   1f600:	f013 ffe2 	bl	335c8 <printk>
   1f604:	4819      	ldr	r0, [pc, #100]	; (1f66c <gpio_pin_set+0x8c>)
   1f606:	f013 ffdf 	bl	335c8 <printk>
   1f60a:	f240 418b 	movw	r1, #1163	; 0x48b
   1f60e:	4815      	ldr	r0, [pc, #84]	; (1f664 <gpio_pin_set+0x84>)
   1f610:	f014 fadb 	bl	33bca <assert_post_action>
		 "Unsupported pin");

	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
   1f614:	683b      	ldr	r3, [r7, #0]
   1f616:	421d      	tst	r5, r3
		value = (value != 0) ? 0 : 1;
   1f618:	bf18      	it	ne
   1f61a:	fab6 f686 	clzne	r6, r6
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f61e:	6863      	ldr	r3, [r4, #4]
		value = (value != 0) ? 0 : 1;
   1f620:	bf18      	it	ne
   1f622:	0976      	lsrne	r6, r6, #5
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f624:	681b      	ldr	r3, [r3, #0]
   1f626:	421d      	tst	r5, r3
   1f628:	d10e      	bne.n	1f648 <gpio_pin_set+0x68>
   1f62a:	490d      	ldr	r1, [pc, #52]	; (1f660 <gpio_pin_set+0x80>)
   1f62c:	f240 4362 	movw	r3, #1122	; 0x462
   1f630:	4a0c      	ldr	r2, [pc, #48]	; (1f664 <gpio_pin_set+0x84>)
   1f632:	480d      	ldr	r0, [pc, #52]	; (1f668 <gpio_pin_set+0x88>)
   1f634:	f013 ffc8 	bl	335c8 <printk>
   1f638:	480c      	ldr	r0, [pc, #48]	; (1f66c <gpio_pin_set+0x8c>)
   1f63a:	f013 ffc5 	bl	335c8 <printk>
   1f63e:	f240 4162 	movw	r1, #1122	; 0x462
   1f642:	4808      	ldr	r0, [pc, #32]	; (1f664 <gpio_pin_set+0x84>)
   1f644:	f014 fac1 	bl	33bca <assert_post_action>
	if (value != 0)	{
   1f648:	b136      	cbz	r6, 1f658 <gpio_pin_set+0x78>
	return api->port_set_bits_raw(port, pins);
   1f64a:	68a3      	ldr	r3, [r4, #8]
   1f64c:	68db      	ldr	r3, [r3, #12]
	return api->port_clear_bits_raw(port, pins);
   1f64e:	4629      	mov	r1, r5
   1f650:	4620      	mov	r0, r4
	}

	return gpio_pin_set_raw(port, pin, value);
}
   1f652:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	return api->port_clear_bits_raw(port, pins);
   1f656:	4718      	bx	r3
   1f658:	68a3      	ldr	r3, [r4, #8]
   1f65a:	691b      	ldr	r3, [r3, #16]
   1f65c:	e7f7      	b.n	1f64e <gpio_pin_set+0x6e>
   1f65e:	bf00      	nop
   1f660:	0003e03a 	.word	0x0003e03a
   1f664:	0003e010 	.word	0x0003e010
   1f668:	0003b77f 	.word	0x0003b77f
   1f66c:	0003e078 	.word	0x0003e078

0001f670 <spi_3_init>:
#ifdef CONFIG_SPI_2_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(2);
#endif

#ifdef CONFIG_SPI_3_NRF_SPIM
SPI_NRFX_SPIM_DEVICE(3);
   1f670:	b510      	push	{r4, lr}
   1f672:	4604      	mov	r4, r0
   1f674:	2200      	movs	r2, #0
   1f676:	2101      	movs	r1, #1
   1f678:	200b      	movs	r0, #11
   1f67a:	f7fb fac9 	bl	1ac10 <z_arm_irq_priority_set>
	nrfx_err_t result = nrfx_spim_init(&get_dev_config(dev)->spim,
   1f67e:	6860      	ldr	r0, [r4, #4]
   1f680:	4623      	mov	r3, r4
   1f682:	4a0f      	ldr	r2, [pc, #60]	; (1f6c0 <spi_3_init+0x50>)
   1f684:	f100 010c 	add.w	r1, r0, #12
   1f688:	f00b fa1c 	bl	2aac4 <nrfx_spim_init>
	if (result != NRFX_SUCCESS) {
   1f68c:	4b0d      	ldr	r3, [pc, #52]	; (1f6c4 <spi_3_init+0x54>)
   1f68e:	4298      	cmp	r0, r3
   1f690:	d011      	beq.n	1f6b6 <spi_3_init+0x46>
		LOG_ERR("Failed to initialize device: %s",
   1f692:	2301      	movs	r3, #1
   1f694:	f04f 0000 	mov.w	r0, #0
   1f698:	4a0b      	ldr	r2, [pc, #44]	; (1f6c8 <spi_3_init+0x58>)
   1f69a:	f363 0007 	bfi	r0, r3, #0, #8
   1f69e:	4b0b      	ldr	r3, [pc, #44]	; (1f6cc <spi_3_init+0x5c>)
   1f6a0:	490b      	ldr	r1, [pc, #44]	; (1f6d0 <spi_3_init+0x60>)
   1f6a2:	1a9b      	subs	r3, r3, r2
   1f6a4:	08db      	lsrs	r3, r3, #3
   1f6a6:	f363 108f 	bfi	r0, r3, #6, #10
   1f6aa:	6822      	ldr	r2, [r4, #0]
   1f6ac:	f014 faa4 	bl	33bf8 <log_string_sync>
		return -EBUSY;
   1f6b0:	f06f 000f 	mvn.w	r0, #15
SPI_NRFX_SPIM_DEVICE(3);
   1f6b4:	bd10      	pop	{r4, pc}
	spi_context_unlock_unconditionally(&get_dev_data(dev)->ctx);
   1f6b6:	68e0      	ldr	r0, [r4, #12]
   1f6b8:	f018 fbee 	bl	37e98 <spi_context_unlock_unconditionally>
	return 0;
   1f6bc:	2000      	movs	r0, #0
SPI_NRFX_SPIM_DEVICE(3);
   1f6be:	e7f9      	b.n	1f6b4 <spi_3_init+0x44>
   1f6c0:	0001fa39 	.word	0x0001fa39
   1f6c4:	0bad0000 	.word	0x0bad0000
   1f6c8:	00039f60 	.word	0x00039f60
   1f6cc:	0003a010 	.word	0x0003a010
   1f6d0:	0003dfd2 	.word	0x0003dfd2

0001f6d4 <transfer_next_chunk>:
{
   1f6d4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1f6d6:	68c5      	ldr	r5, [r0, #12]
	return !!(ctx->rx_buf && ctx->rx_len);
}

static inline size_t spi_context_longest_current_buf(struct spi_context *ctx)
{
	if (!ctx->tx_len) {
   1f6d8:	6cea      	ldr	r2, [r5, #76]	; 0x4c
   1f6da:	6d6b      	ldr	r3, [r5, #84]	; 0x54
   1f6dc:	b982      	cbnz	r2, 1f700 <__kernel_ram_size>
	if (chunk_len > 0) {
   1f6de:	bb93      	cbnz	r3, 1f746 <__kernel_ram_size+0x46>
	int error = 0;
   1f6e0:	461c      	mov	r4, r3
	_spi_context_cs_control(ctx, on, false);
   1f6e2:	2200      	movs	r2, #0
   1f6e4:	4628      	mov	r0, r5
   1f6e6:	4611      	mov	r1, r2
   1f6e8:	f018 fbac 	bl	37e44 <_spi_context_cs_control.isra.6>
	ctx->sync_status = status;
   1f6ec:	636c      	str	r4, [r5, #52]	; 0x34
   1f6ee:	f105 001c 	add.w	r0, r5, #28
   1f6f2:	f00e fc7b 	bl	2dfec <z_impl_k_sem_give>
	dev_data->busy = false;
   1f6f6:	2300      	movs	r3, #0
   1f6f8:	f885 305c 	strb.w	r3, [r5, #92]	; 0x5c
}
   1f6fc:	b004      	add	sp, #16
   1f6fe:	bd70      	pop	{r4, r5, r6, pc}
		return ctx->rx_len;
	} else if (!ctx->rx_len) {
   1f700:	b31b      	cbz	r3, 1f74a <__kernel_ram_size+0x4a>
		return ctx->tx_len;
	} else if (ctx->tx_len < ctx->rx_len) {
   1f702:	4293      	cmp	r3, r2
   1f704:	4619      	mov	r1, r3
   1f706:	bf28      	it	cs
   1f708:	4611      	movcs	r1, r2
	const struct spi_nrfx_config *dev_config = get_dev_config(dev);
   1f70a:	6840      	ldr	r0, [r0, #4]
		const u8_t *tx_buf = ctx->tx_buf;
   1f70c:	6cac      	ldr	r4, [r5, #72]	; 0x48
		if (chunk_len > dev_config->max_chunk_len) {
   1f70e:	6886      	ldr	r6, [r0, #8]
		xfer.p_tx_buffer = tx_buf;
   1f710:	9400      	str	r4, [sp, #0]
   1f712:	42b1      	cmp	r1, r6
   1f714:	bf28      	it	cs
   1f716:	4631      	movcs	r1, r6
		dev_data->chunk_len = chunk_len;
   1f718:	65a9      	str	r1, [r5, #88]	; 0x58
	return !!(ctx->tx_buf && ctx->tx_len);
   1f71a:	b1c4      	cbz	r4, 1f74e <__kernel_ram_size+0x4e>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1f71c:	2a00      	cmp	r2, #0
   1f71e:	bf18      	it	ne
   1f720:	460a      	movne	r2, r1
   1f722:	9201      	str	r2, [sp, #4]
		xfer.p_rx_buffer = ctx->rx_buf;
   1f724:	6d2a      	ldr	r2, [r5, #80]	; 0x50
   1f726:	9202      	str	r2, [sp, #8]
	return !!(ctx->rx_buf && ctx->rx_len);
   1f728:	b19a      	cbz	r2, 1f752 <__kernel_ram_size+0x52>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1f72a:	2b00      	cmp	r3, #0
   1f72c:	bf18      	it	ne
   1f72e:	460b      	movne	r3, r1
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   1f730:	2200      	movs	r2, #0
   1f732:	4669      	mov	r1, sp
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1f734:	9303      	str	r3, [sp, #12]
			result = nrfx_spim_xfer(&dev_config->spim, &xfer, 0);
   1f736:	f00b fa7f 	bl	2ac38 <nrfx_spim_xfer>
			if (result == NRFX_SUCCESS) {
   1f73a:	4b07      	ldr	r3, [pc, #28]	; (1f758 <__kernel_ram_size+0x58>)
   1f73c:	4298      	cmp	r0, r3
   1f73e:	d0dd      	beq.n	1f6fc <transfer_next_chunk+0x28>
			error = -EIO;
   1f740:	f06f 0404 	mvn.w	r4, #4
   1f744:	e7cd      	b.n	1f6e2 <transfer_next_chunk+0xe>
   1f746:	4619      	mov	r1, r3
   1f748:	e7df      	b.n	1f70a <__kernel_ram_size+0xa>
	} else if (!ctx->rx_len) {
   1f74a:	4611      	mov	r1, r2
   1f74c:	e7dd      	b.n	1f70a <__kernel_ram_size+0xa>
		xfer.tx_length   = spi_context_tx_buf_on(ctx) ? chunk_len : 0;
   1f74e:	4622      	mov	r2, r4
   1f750:	e7e7      	b.n	1f722 <__kernel_ram_size+0x22>
		xfer.rx_length   = spi_context_rx_buf_on(ctx) ? chunk_len : 0;
   1f752:	4613      	mov	r3, r2
   1f754:	e7ec      	b.n	1f730 <__kernel_ram_size+0x30>
   1f756:	bf00      	nop
   1f758:	0bad0000 	.word	0x0bad0000

0001f75c <spi_nrfx_transceive>:
{
   1f75c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1f760:	68c4      	ldr	r4, [r0, #12]
{
   1f762:	b085      	sub	sp, #20
   1f764:	461d      	mov	r5, r3
	k_sem_take(&ctx->lock, K_FOREVER);
   1f766:	1d23      	adds	r3, r4, #4
   1f768:	4680      	mov	r8, r0
   1f76a:	460f      	mov	r7, r1
   1f76c:	4616      	mov	r6, r2
   1f76e:	9303      	str	r3, [sp, #12]
	return z_impl_k_sem_take(sem, timeout);
   1f770:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f774:	4618      	mov	r0, r3
   1f776:	f00e fc7d 	bl	2e074 <z_impl_k_sem_take>
	struct spi_context *ctx = &get_dev_data(dev)->ctx;
   1f77a:	f8d8 a00c 	ldr.w	sl, [r8, #12]
	if (spi_context_configured(ctx, spi_cfg)) {
   1f77e:	f8da 3000 	ldr.w	r3, [sl]
   1f782:	429f      	cmp	r7, r3
   1f784:	f000 80d9 	beq.w	1f93a <spi_nrfx_transceive+0x1de>
	if (SPI_OP_MODE_GET(spi_cfg->operation) != SPI_OP_MODE_MASTER) {
   1f788:	88bb      	ldrh	r3, [r7, #4]
   1f78a:	07d9      	lsls	r1, r3, #31
   1f78c:	d518      	bpl.n	1f7c0 <spi_nrfx_transceive+0x64>
		LOG_ERR("Slave mode is not supported on %s",
   1f78e:	2301      	movs	r3, #1
   1f790:	f04f 0000 	mov.w	r0, #0
   1f794:	4a96      	ldr	r2, [pc, #600]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f796:	f363 0007 	bfi	r0, r3, #0, #8
   1f79a:	4b96      	ldr	r3, [pc, #600]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f79c:	4996      	ldr	r1, [pc, #600]	; (1f9f8 <spi_nrfx_transceive+0x29c>)
   1f79e:	1a9b      	subs	r3, r3, r2
   1f7a0:	08db      	lsrs	r3, r3, #3
   1f7a2:	f363 108f 	bfi	r0, r3, #6, #10
   1f7a6:	f8d8 2000 	ldr.w	r2, [r8]
   1f7aa:	f014 fa25 	bl	33bf8 <log_string_sync>
		return -EINVAL;
   1f7ae:	f06f 0415 	mvn.w	r4, #21
	z_impl_k_sem_give(sem);
   1f7b2:	9803      	ldr	r0, [sp, #12]
   1f7b4:	f00e fc1a 	bl	2dfec <z_impl_k_sem_give>
}
   1f7b8:	4620      	mov	r0, r4
   1f7ba:	b005      	add	sp, #20
   1f7bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (spi_cfg->operation & SPI_MODE_LOOP) {
   1f7c0:	071a      	lsls	r2, r3, #28
   1f7c2:	d50e      	bpl.n	1f7e2 <spi_nrfx_transceive+0x86>
		LOG_ERR("Loopback mode is not supported");
   1f7c4:	2301      	movs	r3, #1
   1f7c6:	f04f 0000 	mov.w	r0, #0
   1f7ca:	4a89      	ldr	r2, [pc, #548]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f7cc:	f363 0007 	bfi	r0, r3, #0, #8
   1f7d0:	4b88      	ldr	r3, [pc, #544]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f7d2:	498a      	ldr	r1, [pc, #552]	; (1f9fc <spi_nrfx_transceive+0x2a0>)
   1f7d4:	1a9b      	subs	r3, r3, r2
   1f7d6:	08db      	lsrs	r3, r3, #3
   1f7d8:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Word sizes other than 8 bits"
   1f7dc:	f014 fa0c 	bl	33bf8 <log_string_sync>
   1f7e0:	e7e5      	b.n	1f7ae <spi_nrfx_transceive+0x52>
	if ((spi_cfg->operation & SPI_LINES_MASK) != SPI_LINES_SINGLE) {
   1f7e2:	f413 5fc0 	tst.w	r3, #6144	; 0x1800
   1f7e6:	d00c      	beq.n	1f802 <spi_nrfx_transceive+0xa6>
		LOG_ERR("Only single line mode is supported");
   1f7e8:	2301      	movs	r3, #1
   1f7ea:	f04f 0000 	mov.w	r0, #0
   1f7ee:	4a80      	ldr	r2, [pc, #512]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f7f0:	f363 0007 	bfi	r0, r3, #0, #8
   1f7f4:	4b7f      	ldr	r3, [pc, #508]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f7f6:	4982      	ldr	r1, [pc, #520]	; (1fa00 <spi_nrfx_transceive+0x2a4>)
   1f7f8:	1a9b      	subs	r3, r3, r2
   1f7fa:	08db      	lsrs	r3, r3, #3
   1f7fc:	f363 108f 	bfi	r0, r3, #6, #10
   1f800:	e7ec      	b.n	1f7dc <spi_nrfx_transceive+0x80>
	if (SPI_WORD_SIZE_GET(spi_cfg->operation) != 8) {
   1f802:	f3c3 1345 	ubfx	r3, r3, #5, #6
   1f806:	2b08      	cmp	r3, #8
   1f808:	d00c      	beq.n	1f824 <spi_nrfx_transceive+0xc8>
		LOG_ERR("Word sizes other than 8 bits"
   1f80a:	2301      	movs	r3, #1
   1f80c:	f04f 0000 	mov.w	r0, #0
   1f810:	4a77      	ldr	r2, [pc, #476]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f812:	f363 0007 	bfi	r0, r3, #0, #8
   1f816:	4b77      	ldr	r3, [pc, #476]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f818:	497a      	ldr	r1, [pc, #488]	; (1fa04 <spi_nrfx_transceive+0x2a8>)
   1f81a:	1a9b      	subs	r3, r3, r2
   1f81c:	08db      	lsrs	r3, r3, #3
   1f81e:	f363 108f 	bfi	r0, r3, #6, #10
   1f822:	e7db      	b.n	1f7dc <spi_nrfx_transceive+0x80>
	if (spi_cfg->frequency < 125000) {
   1f824:	683a      	ldr	r2, [r7, #0]
   1f826:	4b78      	ldr	r3, [pc, #480]	; (1fa08 <spi_nrfx_transceive+0x2ac>)
   1f828:	429a      	cmp	r2, r3
   1f82a:	d80c      	bhi.n	1f846 <spi_nrfx_transceive+0xea>
		LOG_ERR("Frequencies lower than 125 kHz are not supported");
   1f82c:	2301      	movs	r3, #1
   1f82e:	f04f 0000 	mov.w	r0, #0
   1f832:	4a6f      	ldr	r2, [pc, #444]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f834:	f363 0007 	bfi	r0, r3, #0, #8
   1f838:	4b6e      	ldr	r3, [pc, #440]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f83a:	4974      	ldr	r1, [pc, #464]	; (1fa0c <spi_nrfx_transceive+0x2b0>)
   1f83c:	1a9b      	subs	r3, r3, r2
   1f83e:	08db      	lsrs	r3, r3, #3
   1f840:	f363 108f 	bfi	r0, r3, #6, #10
   1f844:	e7ca      	b.n	1f7dc <spi_nrfx_transceive+0x80>
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
   1f846:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ctx->config = spi_cfg;
   1f84a:	f8ca 7000 	str.w	r7, [sl]
	const nrfx_spim_t *spim = &get_dev_config(dev)->spim;
   1f84e:	9302      	str	r3, [sp, #8]
	if (ctx->config->cs && ctx->config->cs->gpio_dev) {
   1f850:	68bb      	ldr	r3, [r7, #8]
   1f852:	2b00      	cmp	r3, #0
   1f854:	f000 8099 	beq.w	1f98a <spi_nrfx_transceive+0x22e>
   1f858:	f8d3 9000 	ldr.w	r9, [r3]
   1f85c:	f1b9 0f00 	cmp.w	r9, #0
   1f860:	f000 8093 	beq.w	1f98a <spi_nrfx_transceive+0x22e>
		gpio_pin_configure(ctx->config->cs->gpio_dev,
   1f864:	791b      	ldrb	r3, [r3, #4]
	struct gpio_driver_data *data =
   1f866:	f8d9 b00c 	ldr.w	fp, [r9, #12]
   1f86a:	9300      	str	r3, [sp, #0]
	__ASSERT((cfg->port_pin_mask & (gpio_port_pins_t)BIT(pin)) != 0U,
   1f86c:	2301      	movs	r3, #1
   1f86e:	9a00      	ldr	r2, [sp, #0]
   1f870:	4093      	lsls	r3, r2
   1f872:	9301      	str	r3, [sp, #4]
   1f874:	f8d9 3004 	ldr.w	r3, [r9, #4]
   1f878:	9a01      	ldr	r2, [sp, #4]
   1f87a:	681b      	ldr	r3, [r3, #0]
   1f87c:	421a      	tst	r2, r3
   1f87e:	d10e      	bne.n	1f89e <spi_nrfx_transceive+0x142>
   1f880:	4963      	ldr	r1, [pc, #396]	; (1fa10 <spi_nrfx_transceive+0x2b4>)
   1f882:	f240 23ef 	movw	r3, #751	; 0x2ef
   1f886:	4a63      	ldr	r2, [pc, #396]	; (1fa14 <spi_nrfx_transceive+0x2b8>)
   1f888:	4863      	ldr	r0, [pc, #396]	; (1fa18 <spi_nrfx_transceive+0x2bc>)
   1f88a:	f013 fe9d 	bl	335c8 <printk>
   1f88e:	4863      	ldr	r0, [pc, #396]	; (1fa1c <spi_nrfx_transceive+0x2c0>)
   1f890:	f013 fe9a 	bl	335c8 <printk>
   1f894:	f240 21ef 	movw	r1, #751	; 0x2ef
   1f898:	485e      	ldr	r0, [pc, #376]	; (1fa14 <spi_nrfx_transceive+0x2b8>)
   1f89a:	f014 f996 	bl	33bca <assert_post_action>
	return api->pin_configure(port, pin, flags);
   1f89e:	f8d9 3008 	ldr.w	r3, [r9, #8]
   1f8a2:	f44f 7200 	mov.w	r2, #512	; 0x200
   1f8a6:	681b      	ldr	r3, [r3, #0]
   1f8a8:	9900      	ldr	r1, [sp, #0]
   1f8aa:	4648      	mov	r0, r9
   1f8ac:	4798      	blx	r3
	if (ret != 0) {
   1f8ae:	b930      	cbnz	r0, 1f8be <spi_nrfx_transceive+0x162>
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
   1f8b0:	f8db 3000 	ldr.w	r3, [fp]
   1f8b4:	9a01      	ldr	r2, [sp, #4]
   1f8b6:	ea23 0302 	bic.w	r3, r3, r2
   1f8ba:	f8cb 3000 	str.w	r3, [fp]
		gpio_pin_set(ctx->config->cs->gpio_dev,
   1f8be:	f8da 2000 	ldr.w	r2, [sl]
   1f8c2:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   1f8c4:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
		gpio_pin_set(ctx->config->cs->gpio_dev,
   1f8c8:	7919      	ldrb	r1, [r3, #4]
   1f8ca:	43d2      	mvns	r2, r2
   1f8cc:	6818      	ldr	r0, [r3, #0]
   1f8ce:	0fd2      	lsrs	r2, r2, #31
   1f8d0:	f7ff fe86 	bl	1f5e0 <gpio_pin_set>
	nrf_spim_configure(spim->p_reg,
   1f8d4:	9b02      	ldr	r3, [sp, #8]
   1f8d6:	6819      	ldr	r1, [r3, #0]
   1f8d8:	88bb      	ldrh	r3, [r7, #4]
	if (SPI_MODE_GET(operation) & SPI_MODE_CPOL) {
   1f8da:	0798      	lsls	r0, r3, #30
   1f8dc:	f003 0204 	and.w	r2, r3, #4
   1f8e0:	d562      	bpl.n	1f9a8 <spi_nrfx_transceive+0x24c>
			return NRF_SPIM_MODE_2;
   1f8e2:	2a00      	cmp	r2, #0
   1f8e4:	bf14      	ite	ne
   1f8e6:	2203      	movne	r2, #3
   1f8e8:	2202      	moveq	r2, #2
                                          nrf_spim_mode_t      spi_mode,
                                          nrf_spim_bit_order_t spi_bit_order)
{
    uint32_t config = (spi_bit_order == NRF_SPIM_BIT_ORDER_MSB_FIRST ?
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
    switch (spi_mode)
   1f8ea:	2a02      	cmp	r2, #2
	if (operation & SPI_TRANSFER_LSB) {
   1f8ec:	f3c3 1300 	ubfx	r3, r3, #4, #1
   1f8f0:	d05e      	beq.n	1f9b0 <spi_nrfx_transceive+0x254>
   1f8f2:	2a03      	cmp	r2, #3
   1f8f4:	d05f      	beq.n	1f9b6 <spi_nrfx_transceive+0x25a>
   1f8f6:	2a01      	cmp	r2, #1
   1f8f8:	d101      	bne.n	1f8fe <spi_nrfx_transceive+0x1a2>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Leading    << SPIM_CONFIG_CPHA_Pos);
        break;

    case NRF_SPIM_MODE_1:
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   1f8fa:	f043 0302 	orr.w	r3, r3, #2
    case NRF_SPIM_MODE_3:
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
                  (SPIM_CONFIG_CPHA_Trailing   << SPIM_CONFIG_CPHA_Pos);
        break;
    }
    p_reg->CONFIG = config;
   1f8fe:	f8c1 3554 	str.w	r3, [r1, #1364]	; 0x554
	if (frequency < 250000) {
   1f902:	4a47      	ldr	r2, [pc, #284]	; (1fa20 <spi_nrfx_transceive+0x2c4>)
	nrf_spim_frequency_set(spim->p_reg,
   1f904:	683b      	ldr	r3, [r7, #0]
	if (frequency < 250000) {
   1f906:	4293      	cmp	r3, r2
   1f908:	d958      	bls.n	1f9bc <spi_nrfx_transceive+0x260>
	} else if (frequency < 500000) {
   1f90a:	4a46      	ldr	r2, [pc, #280]	; (1fa24 <spi_nrfx_transceive+0x2c8>)
   1f90c:	4293      	cmp	r3, r2
   1f90e:	d958      	bls.n	1f9c2 <spi_nrfx_transceive+0x266>
	} else if (frequency < 1000000) {
   1f910:	4a45      	ldr	r2, [pc, #276]	; (1fa28 <spi_nrfx_transceive+0x2cc>)
   1f912:	4293      	cmp	r3, r2
   1f914:	d958      	bls.n	1f9c8 <spi_nrfx_transceive+0x26c>
	} else if (frequency < 2000000) {
   1f916:	4a45      	ldr	r2, [pc, #276]	; (1fa2c <spi_nrfx_transceive+0x2d0>)
   1f918:	4293      	cmp	r3, r2
   1f91a:	d958      	bls.n	1f9ce <spi_nrfx_transceive+0x272>
	} else if (frequency < 4000000) {
   1f91c:	4a44      	ldr	r2, [pc, #272]	; (1fa30 <spi_nrfx_transceive+0x2d4>)
   1f91e:	4293      	cmp	r3, r2
   1f920:	d958      	bls.n	1f9d4 <spi_nrfx_transceive+0x278>
		return NRF_SPIM_FREQ_8M;
   1f922:	f502 1274 	add.w	r2, r2, #3997696	; 0x3d0000
   1f926:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   1f92a:	4293      	cmp	r3, r2
   1f92c:	bf94      	ite	ls
   1f92e:	f04f 4380 	movls.w	r3, #1073741824	; 0x40000000
   1f932:	f04f 4300 	movhi.w	r3, #2147483648	; 0x80000000
    p_reg->FREQUENCY = (uint32_t)frequency;
   1f936:	f8c1 3524 	str.w	r3, [r1, #1316]	; 0x524
		dev_data->busy = true;
   1f93a:	2301      	movs	r3, #1
   1f93c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
	if (tx_bufs) {
   1f940:	2e00      	cmp	r6, #0
   1f942:	d04a      	beq.n	1f9da <spi_nrfx_transceive+0x27e>
		ctx->current_tx = tx_bufs->buffers;
   1f944:	6833      	ldr	r3, [r6, #0]
		ctx->tx_count = tx_bufs->count;
   1f946:	6872      	ldr	r2, [r6, #4]
		ctx->current_tx = tx_bufs->buffers;
   1f948:	63a3      	str	r3, [r4, #56]	; 0x38
		ctx->tx_count = tx_bufs->count;
   1f94a:	63e2      	str	r2, [r4, #60]	; 0x3c
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1f94c:	681a      	ldr	r2, [r3, #0]
		ctx->tx_len = ctx->current_tx->len / dfs;
   1f94e:	685b      	ldr	r3, [r3, #4]
		ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1f950:	64a2      	str	r2, [r4, #72]	; 0x48
		ctx->tx_len = ctx->current_tx->len / dfs;
   1f952:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (rx_bufs) {
   1f954:	2d00      	cmp	r5, #0
   1f956:	d045      	beq.n	1f9e4 <spi_nrfx_transceive+0x288>
		ctx->current_rx = rx_bufs->buffers;
   1f958:	682b      	ldr	r3, [r5, #0]
		ctx->rx_count = rx_bufs->count;
   1f95a:	686a      	ldr	r2, [r5, #4]
		ctx->current_rx = rx_bufs->buffers;
   1f95c:	6423      	str	r3, [r4, #64]	; 0x40
		ctx->rx_count = rx_bufs->count;
   1f95e:	6462      	str	r2, [r4, #68]	; 0x44
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1f960:	681a      	ldr	r2, [r3, #0]
		ctx->rx_len = ctx->current_rx->len / dfs;
   1f962:	685b      	ldr	r3, [r3, #4]
		ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1f964:	6522      	str	r2, [r4, #80]	; 0x50
		ctx->rx_len = ctx->current_rx->len / dfs;
   1f966:	6563      	str	r3, [r4, #84]	; 0x54
	ctx->sync_status = 0;
   1f968:	2200      	movs	r2, #0
	_spi_context_cs_control(ctx, on, false);
   1f96a:	2101      	movs	r1, #1
	ctx->sync_status = 0;
   1f96c:	6362      	str	r2, [r4, #52]	; 0x34
	_spi_context_cs_control(ctx, on, false);
   1f96e:	4620      	mov	r0, r4
   1f970:	f018 fa68 	bl	37e44 <_spi_context_cs_control.isra.6>
		transfer_next_chunk(dev);
   1f974:	4640      	mov	r0, r8
   1f976:	f7ff fead 	bl	1f6d4 <transfer_next_chunk>
	return z_impl_k_sem_take(sem, timeout);
   1f97a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   1f97e:	f104 001c 	add.w	r0, r4, #28
   1f982:	f00e fb77 	bl	2e074 <z_impl_k_sem_take>
	status = ctx->sync_status;
   1f986:	6b64      	ldr	r4, [r4, #52]	; 0x34
	return status;
   1f988:	e713      	b.n	1f7b2 <spi_nrfx_transceive+0x56>
		LOG_INF("CS control inhibited (no GPIO device)");
   1f98a:	2303      	movs	r3, #3
   1f98c:	f04f 0000 	mov.w	r0, #0
   1f990:	4a17      	ldr	r2, [pc, #92]	; (1f9f0 <spi_nrfx_transceive+0x294>)
   1f992:	f363 0007 	bfi	r0, r3, #0, #8
   1f996:	4b17      	ldr	r3, [pc, #92]	; (1f9f4 <spi_nrfx_transceive+0x298>)
   1f998:	4926      	ldr	r1, [pc, #152]	; (1fa34 <spi_nrfx_transceive+0x2d8>)
   1f99a:	1a9b      	subs	r3, r3, r2
   1f99c:	08db      	lsrs	r3, r3, #3
   1f99e:	f363 108f 	bfi	r0, r3, #6, #10
   1f9a2:	f014 f929 	bl	33bf8 <log_string_sync>
   1f9a6:	e795      	b.n	1f8d4 <spi_nrfx_transceive+0x178>
			return NRF_SPIM_MODE_0;
   1f9a8:	3200      	adds	r2, #0
   1f9aa:	bf18      	it	ne
   1f9ac:	2201      	movne	r2, #1
   1f9ae:	e79c      	b.n	1f8ea <spi_nrfx_transceive+0x18e>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   1f9b0:	f043 0304 	orr.w	r3, r3, #4
        break;
   1f9b4:	e7a3      	b.n	1f8fe <spi_nrfx_transceive+0x1a2>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   1f9b6:	f043 0306 	orr.w	r3, r3, #6
        break;
   1f9ba:	e7a0      	b.n	1f8fe <spi_nrfx_transceive+0x1a2>
		return NRF_SPIM_FREQ_125K;
   1f9bc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   1f9c0:	e7b9      	b.n	1f936 <spi_nrfx_transceive+0x1da>
		return NRF_SPIM_FREQ_250K;
   1f9c2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1f9c6:	e7b6      	b.n	1f936 <spi_nrfx_transceive+0x1da>
		return NRF_SPIM_FREQ_500K;
   1f9c8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   1f9cc:	e7b3      	b.n	1f936 <spi_nrfx_transceive+0x1da>
		return NRF_SPIM_FREQ_1M;
   1f9ce:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   1f9d2:	e7b0      	b.n	1f936 <spi_nrfx_transceive+0x1da>
		return NRF_SPIM_FREQ_2M;
   1f9d4:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   1f9d8:	e7ad      	b.n	1f936 <spi_nrfx_transceive+0x1da>
		ctx->tx_count = 0;
   1f9da:	e9c4 660e 	strd	r6, r6, [r4, #56]	; 0x38
		ctx->tx_len = 0;
   1f9de:	e9c4 6612 	strd	r6, r6, [r4, #72]	; 0x48
   1f9e2:	e7b7      	b.n	1f954 <spi_nrfx_transceive+0x1f8>
		ctx->rx_count = 0;
   1f9e4:	e9c4 5510 	strd	r5, r5, [r4, #64]	; 0x40
		ctx->rx_len = 0;
   1f9e8:	e9c4 5514 	strd	r5, r5, [r4, #80]	; 0x50
   1f9ec:	e7bc      	b.n	1f968 <spi_nrfx_transceive+0x20c>
   1f9ee:	bf00      	nop
   1f9f0:	00039f60 	.word	0x00039f60
   1f9f4:	0003a010 	.word	0x0003a010
   1f9f8:	0003e08a 	.word	0x0003e08a
   1f9fc:	0003e0ac 	.word	0x0003e0ac
   1fa00:	0003e0cb 	.word	0x0003e0cb
   1fa04:	0003e0ee 	.word	0x0003e0ee
   1fa08:	0001e847 	.word	0x0001e847
   1fa0c:	0003e11d 	.word	0x0003e11d
   1fa10:	0003e03a 	.word	0x0003e03a
   1fa14:	0003e010 	.word	0x0003e010
   1fa18:	0003b77f 	.word	0x0003b77f
   1fa1c:	0003e078 	.word	0x0003e078
   1fa20:	0003d08f 	.word	0x0003d08f
   1fa24:	0007a11f 	.word	0x0007a11f
   1fa28:	000f423f 	.word	0x000f423f
   1fa2c:	001e847f 	.word	0x001e847f
   1fa30:	003d08ff 	.word	0x003d08ff
   1fa34:	0003e14e 	.word	0x0003e14e

0001fa38 <event_handler>:
{
   1fa38:	b538      	push	{r3, r4, r5, lr}
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   1fa3a:	7803      	ldrb	r3, [r0, #0]
{
   1fa3c:	460d      	mov	r5, r1
	if (p_event->type == NRFX_SPIM_EVENT_DONE) {
   1fa3e:	2b00      	cmp	r3, #0
   1fa40:	d157      	bne.n	1faf2 <event_handler+0xba>
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   1fa42:	68cc      	ldr	r4, [r1, #12]
	if (!ctx->tx_len) {
   1fa44:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   1fa46:	b183      	cbz	r3, 1fa6a <event_handler+0x32>
		spi_context_update_tx(&dev_data->ctx, 1, dev_data->chunk_len);
   1fa48:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->tx_len) {
   1fa4a:	429a      	cmp	r2, r3
   1fa4c:	d925      	bls.n	1fa9a <event_handler+0x62>
		LOG_ERR("Update exceeds current buffer");
   1fa4e:	2301      	movs	r3, #1
   1fa50:	f04f 0000 	mov.w	r0, #0
   1fa54:	4a27      	ldr	r2, [pc, #156]	; (1faf4 <event_handler+0xbc>)
   1fa56:	f363 0007 	bfi	r0, r3, #0, #8
   1fa5a:	4b27      	ldr	r3, [pc, #156]	; (1faf8 <event_handler+0xc0>)
   1fa5c:	4927      	ldr	r1, [pc, #156]	; (1fafc <event_handler+0xc4>)
   1fa5e:	1a9b      	subs	r3, r3, r2
   1fa60:	08db      	lsrs	r3, r3, #3
   1fa62:	f363 108f 	bfi	r0, r3, #6, #10
   1fa66:	f014 f8c7 	bl	33bf8 <log_string_sync>
	if (!ctx->rx_len) {
   1fa6a:	6d63      	ldr	r3, [r4, #84]	; 0x54
   1fa6c:	b183      	cbz	r3, 1fa90 <event_handler+0x58>
		spi_context_update_rx(&dev_data->ctx, 1, dev_data->chunk_len);
   1fa6e:	6da2      	ldr	r2, [r4, #88]	; 0x58
	if (len > ctx->rx_len) {
   1fa70:	429a      	cmp	r2, r3
   1fa72:	d928      	bls.n	1fac6 <event_handler+0x8e>
		LOG_ERR("Update exceeds current buffer");
   1fa74:	2301      	movs	r3, #1
   1fa76:	f04f 0000 	mov.w	r0, #0
   1fa7a:	4a1e      	ldr	r2, [pc, #120]	; (1faf4 <event_handler+0xbc>)
   1fa7c:	f363 0007 	bfi	r0, r3, #0, #8
   1fa80:	4b1d      	ldr	r3, [pc, #116]	; (1faf8 <event_handler+0xc0>)
   1fa82:	491e      	ldr	r1, [pc, #120]	; (1fafc <event_handler+0xc4>)
   1fa84:	1a9b      	subs	r3, r3, r2
   1fa86:	08db      	lsrs	r3, r3, #3
   1fa88:	f363 108f 	bfi	r0, r3, #6, #10
   1fa8c:	f014 f8b4 	bl	33bf8 <log_string_sync>
		transfer_next_chunk(dev);
   1fa90:	4628      	mov	r0, r5
}
   1fa92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		transfer_next_chunk(dev);
   1fa96:	f7ff be1d 	b.w	1f6d4 <transfer_next_chunk>
	ctx->tx_len -= len;
   1fa9a:	1a9b      	subs	r3, r3, r2
   1fa9c:	64e3      	str	r3, [r4, #76]	; 0x4c
	if (!ctx->tx_len) {
   1fa9e:	b963      	cbnz	r3, 1faba <event_handler+0x82>
		ctx->tx_count--;
   1faa0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   1faa2:	3b01      	subs	r3, #1
   1faa4:	63e3      	str	r3, [r4, #60]	; 0x3c
		if (ctx->tx_count) {
   1faa6:	b163      	cbz	r3, 1fac2 <event_handler+0x8a>
			ctx->current_tx++;
   1faa8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   1faaa:	f103 0208 	add.w	r2, r3, #8
   1faae:	63a2      	str	r2, [r4, #56]	; 0x38
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1fab0:	689a      	ldr	r2, [r3, #8]
			ctx->tx_len = ctx->current_tx->len / dfs;
   1fab2:	68db      	ldr	r3, [r3, #12]
			ctx->tx_buf = (const u8_t *)ctx->current_tx->buf;
   1fab4:	64a2      	str	r2, [r4, #72]	; 0x48
			ctx->tx_len = ctx->current_tx->len / dfs;
   1fab6:	64e3      	str	r3, [r4, #76]	; 0x4c
   1fab8:	e7d7      	b.n	1fa6a <event_handler+0x32>
	} else if (ctx->tx_buf) {
   1faba:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   1fabc:	2b00      	cmp	r3, #0
   1fabe:	d0d4      	beq.n	1fa6a <event_handler+0x32>
		ctx->tx_buf += dfs * len;
   1fac0:	4413      	add	r3, r2
   1fac2:	64a3      	str	r3, [r4, #72]	; 0x48
   1fac4:	e7d1      	b.n	1fa6a <event_handler+0x32>
	ctx->rx_len -= len;
   1fac6:	1a9b      	subs	r3, r3, r2
   1fac8:	6563      	str	r3, [r4, #84]	; 0x54
	if (!ctx->rx_len) {
   1faca:	b963      	cbnz	r3, 1fae6 <event_handler+0xae>
		ctx->rx_count--;
   1facc:	6c63      	ldr	r3, [r4, #68]	; 0x44
   1face:	3b01      	subs	r3, #1
   1fad0:	6463      	str	r3, [r4, #68]	; 0x44
		if (ctx->rx_count) {
   1fad2:	b163      	cbz	r3, 1faee <event_handler+0xb6>
			ctx->current_rx++;
   1fad4:	6c23      	ldr	r3, [r4, #64]	; 0x40
   1fad6:	f103 0208 	add.w	r2, r3, #8
   1fada:	6422      	str	r2, [r4, #64]	; 0x40
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1fadc:	689a      	ldr	r2, [r3, #8]
			ctx->rx_len = ctx->current_rx->len / dfs;
   1fade:	68db      	ldr	r3, [r3, #12]
			ctx->rx_buf = (u8_t *)ctx->current_rx->buf;
   1fae0:	6522      	str	r2, [r4, #80]	; 0x50
			ctx->rx_len = ctx->current_rx->len / dfs;
   1fae2:	6563      	str	r3, [r4, #84]	; 0x54
   1fae4:	e7d4      	b.n	1fa90 <event_handler+0x58>
	} else if (ctx->rx_buf) {
   1fae6:	6d23      	ldr	r3, [r4, #80]	; 0x50
   1fae8:	2b00      	cmp	r3, #0
   1faea:	d0d1      	beq.n	1fa90 <event_handler+0x58>
		ctx->rx_buf += dfs * len;
   1faec:	4413      	add	r3, r2
   1faee:	6523      	str	r3, [r4, #80]	; 0x50
   1faf0:	e7ce      	b.n	1fa90 <event_handler+0x58>
}
   1faf2:	bd38      	pop	{r3, r4, r5, pc}
   1faf4:	00039f60 	.word	0x00039f60
   1faf8:	0003a010 	.word	0x0003a010
   1fafc:	0003dff2 	.word	0x0003dff2

0001fb00 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
   1fb00:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
   1fb02:	794b      	ldrb	r3, [r1, #5]
   1fb04:	2b01      	cmp	r3, #1
   1fb06:	d027      	beq.n	1fb58 <uarte_nrfx_configure+0x58>
   1fb08:	2b03      	cmp	r3, #3
   1fb0a:	d122      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
   1fb0c:	2610      	movs	r6, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
   1fb0e:	798b      	ldrb	r3, [r1, #6]
   1fb10:	2b03      	cmp	r3, #3
   1fb12:	d11e      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
   1fb14:	79cc      	ldrb	r4, [r1, #7]
   1fb16:	b124      	cbz	r4, 1fb22 <uarte_nrfx_configure+0x22>
   1fb18:	2c01      	cmp	r4, #1
   1fb1a:	d11a      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
   1fb1c:	6843      	ldr	r3, [r0, #4]
   1fb1e:	791b      	ldrb	r3, [r3, #4]
   1fb20:	b1bb      	cbz	r3, 1fb52 <uarte_nrfx_configure+0x52>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
   1fb22:	790a      	ldrb	r2, [r1, #4]
   1fb24:	b112      	cbz	r2, 1fb2c <uarte_nrfx_configure+0x2c>
   1fb26:	2a02      	cmp	r2, #2
   1fb28:	d113      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
	case UART_CFG_PARITY_NONE:
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
		break;
	case UART_CFG_PARITY_EVEN:
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
   1fb2a:	220e      	movs	r2, #14
	switch (baudrate) {
   1fb2c:	f647 2712 	movw	r7, #31250	; 0x7a12
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
   1fb30:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
   1fb32:	6845      	ldr	r5, [r0, #4]
	switch (baudrate) {
   1fb34:	42bb      	cmp	r3, r7
	return config->uarte_regs;
   1fb36:	682d      	ldr	r5, [r5, #0]
	switch (baudrate) {
   1fb38:	d062      	beq.n	1fc00 <uarte_nrfx_configure+0x100>
   1fb3a:	d829      	bhi.n	1fb90 <uarte_nrfx_configure+0x90>
   1fb3c:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
   1fb40:	d061      	beq.n	1fc06 <uarte_nrfx_configure+0x106>
   1fb42:	d814      	bhi.n	1fb6e <uarte_nrfx_configure+0x6e>
   1fb44:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
   1fb48:	d05f      	beq.n	1fc0a <uarte_nrfx_configure+0x10a>
   1fb4a:	d807      	bhi.n	1fb5c <uarte_nrfx_configure+0x5c>
   1fb4c:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
   1fb50:	d05e      	beq.n	1fc10 <uarte_nrfx_configure+0x110>
		return -ENOTSUP;
   1fb52:	f06f 0085 	mvn.w	r0, #133	; 0x85
   1fb56:	e052      	b.n	1fbfe <uarte_nrfx_configure+0xfe>
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
   1fb58:	2600      	movs	r6, #0
   1fb5a:	e7d8      	b.n	1fb0e <uarte_nrfx_configure+0xe>
	switch (baudrate) {
   1fb5c:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
   1fb60:	d059      	beq.n	1fc16 <uarte_nrfx_configure+0x116>
   1fb62:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
   1fb66:	d1f4      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
   1fb68:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
   1fb6c:	e03c      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fb6e:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
   1fb72:	d053      	beq.n	1fc1c <uarte_nrfx_configure+0x11c>
   1fb74:	d804      	bhi.n	1fb80 <uarte_nrfx_configure+0x80>
   1fb76:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
   1fb7a:	d1ea      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
   1fb7c:	4b32      	ldr	r3, [pc, #200]	; (1fc48 <uarte_nrfx_configure+0x148>)
   1fb7e:	e033      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fb80:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
   1fb84:	d04c      	beq.n	1fc20 <uarte_nrfx_configure+0x120>
   1fb86:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
   1fb8a:	d1e2      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
   1fb8c:	4b2f      	ldr	r3, [pc, #188]	; (1fc4c <uarte_nrfx_configure+0x14c>)
   1fb8e:	e02b      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fb90:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
   1fb94:	d046      	beq.n	1fc24 <uarte_nrfx_configure+0x124>
   1fb96:	d812      	bhi.n	1fbbe <uarte_nrfx_configure+0xbe>
   1fb98:	f64d 27c0 	movw	r7, #56000	; 0xdac0
   1fb9c:	42bb      	cmp	r3, r7
   1fb9e:	d044      	beq.n	1fc2a <uarte_nrfx_configure+0x12a>
   1fba0:	d805      	bhi.n	1fbae <uarte_nrfx_configure+0xae>
   1fba2:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
   1fba6:	d1d4      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
   1fba8:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
   1fbac:	e01c      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fbae:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
   1fbb2:	d03d      	beq.n	1fc30 <uarte_nrfx_configure+0x130>
   1fbb4:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
   1fbb8:	d1cb      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
   1fbba:	4b25      	ldr	r3, [pc, #148]	; (1fc50 <uarte_nrfx_configure+0x150>)
   1fbbc:	e014      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fbbe:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
   1fbc2:	d038      	beq.n	1fc36 <uarte_nrfx_configure+0x136>
   1fbc4:	d808      	bhi.n	1fbd8 <uarte_nrfx_configure+0xd8>
   1fbc6:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
   1fbca:	d037      	beq.n	1fc3c <uarte_nrfx_configure+0x13c>
   1fbcc:	4f21      	ldr	r7, [pc, #132]	; (1fc54 <uarte_nrfx_configure+0x154>)
   1fbce:	42bb      	cmp	r3, r7
   1fbd0:	d1bf      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
   1fbd2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
   1fbd6:	e007      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
	switch (baudrate) {
   1fbd8:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
   1fbdc:	d031      	beq.n	1fc42 <uarte_nrfx_configure+0x142>
   1fbde:	4f1e      	ldr	r7, [pc, #120]	; (1fc58 <uarte_nrfx_configure+0x158>)
   1fbe0:	42bb      	cmp	r3, r7
   1fbe2:	d1b6      	bne.n	1fb52 <uarte_nrfx_configure+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
   1fbe4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
   1fbe8:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
   1fbec:	4334      	orrs	r4, r6
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
   1fbee:	68c3      	ldr	r3, [r0, #12]
   1fbf0:	4322      	orrs	r2, r4
   1fbf2:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
   1fbf4:	f8c5 256c 	str.w	r2, [r5, #1388]	; 0x56c
   1fbf8:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
   1fbfc:	2000      	movs	r0, #0
}
   1fbfe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
   1fc00:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   1fc04:	e7f0      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
   1fc06:	4b15      	ldr	r3, [pc, #84]	; (1fc5c <uarte_nrfx_configure+0x15c>)
   1fc08:	e7ee      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = 0x00027000;
   1fc0a:	f44f 331c 	mov.w	r3, #159744	; 0x27000
   1fc0e:	e7eb      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = 0x00014000;
   1fc10:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
   1fc14:	e7e8      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
   1fc16:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
   1fc1a:	e7e5      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
   1fc1c:	4b10      	ldr	r3, [pc, #64]	; (1fc60 <uarte_nrfx_configure+0x160>)
   1fc1e:	e7e3      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
   1fc20:	4b10      	ldr	r3, [pc, #64]	; (1fc64 <uarte_nrfx_configure+0x164>)
   1fc22:	e7e1      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
   1fc24:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
   1fc28:	e7de      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
   1fc2a:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
   1fc2e:	e7db      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
   1fc30:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
   1fc34:	e7d8      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
   1fc36:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
   1fc3a:	e7d5      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
   1fc3c:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
   1fc40:	e7d2      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
   1fc42:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
   1fc46:	e7cf      	b.n	1fbe8 <uarte_nrfx_configure+0xe8>
   1fc48:	00275000 	.word	0x00275000
   1fc4c:	0075c000 	.word	0x0075c000
   1fc50:	013a9000 	.word	0x013a9000
   1fc54:	0003d090 	.word	0x0003d090
   1fc58:	000f4240 	.word	0x000f4240
   1fc5c:	0013b000 	.word	0x0013b000
   1fc60:	003af000 	.word	0x003af000
   1fc64:	004ea000 	.word	0x004ea000

0001fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   1fc68:	b510      	push	{r4, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fc6a:	4c07      	ldr	r4, [pc, #28]	; (1fc88 <nrf_gpio_pin_port_decode.isra.3.part.4+0x20>)
   1fc6c:	4907      	ldr	r1, [pc, #28]	; (1fc8c <nrf_gpio_pin_port_decode.isra.3.part.4+0x24>)
   1fc6e:	4622      	mov	r2, r4
   1fc70:	4807      	ldr	r0, [pc, #28]	; (1fc90 <nrf_gpio_pin_port_decode.isra.3.part.4+0x28>)
   1fc72:	f240 230d 	movw	r3, #525	; 0x20d
   1fc76:	f013 fca7 	bl	335c8 <printk>
   1fc7a:	4620      	mov	r0, r4
}
   1fc7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fc80:	f240 210d 	movw	r1, #525	; 0x20d
   1fc84:	f013 bfa1 	b.w	33bca <assert_post_action>
   1fc88:	0003df34 	.word	0x0003df34
   1fc8c:	0003df67 	.word	0x0003df67
   1fc90:	0003b77f 	.word	0x0003b77f

0001fc94 <nrf_gpio_pin_set>:
{
   1fc94:	b510      	push	{r4, lr}
   1fc96:	4604      	mov	r4, r0
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fc98:	f018 f91e 	bl	37ed8 <nrf_gpio_pin_present_check>
   1fc9c:	b908      	cbnz	r0, 1fca2 <nrf_gpio_pin_set+0xe>
   1fc9e:	f7ff ffe3 	bl	1fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1fca2:	2001      	movs	r0, #1
    p_reg->OUTSET = set_mask;
   1fca4:	4b01      	ldr	r3, [pc, #4]	; (1fcac <nrf_gpio_pin_set+0x18>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   1fca6:	40a0      	lsls	r0, r4
    p_reg->OUTSET = set_mask;
   1fca8:	6098      	str	r0, [r3, #8]
}
   1fcaa:	bd10      	pop	{r4, pc}
   1fcac:	40842500 	.word	0x40842500

0001fcb0 <uarte_instance_init.constprop.5>:
	.irq_update		= uarte_nrfx_irq_update,
	.irq_callback_set	= uarte_nrfx_irq_callback_set,
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int uarte_instance_init(struct device *dev,
   1fcb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1fcb4:	460d      	mov	r5, r1
	return config->uarte_regs;
   1fcb6:	6843      	ldr	r3, [r0, #4]
			       const struct uarte_init_config *config,
			       u8_t interrupts_active)
{
	int err;
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);
	struct uarte_nrfx_data *data = get_dev_data(dev);
   1fcb8:	f8d0 900c 	ldr.w	r9, [r0, #12]
static int uarte_instance_init(struct device *dev,
   1fcbc:	4680      	mov	r8, r0
        nrf_gpio_pin_set(pin_number);
   1fcbe:	6808      	ldr	r0, [r1, #0]
	return config->uarte_regs;
   1fcc0:	681c      	ldr	r4, [r3, #0]
   1fcc2:	f7ff ffe7 	bl	1fc94 <nrf_gpio_pin_set>

	nrf_gpio_pin_write(config->pseltxd, 1);
	nrf_gpio_cfg_output(config->pseltxd);
   1fcc6:	682f      	ldr	r7, [r5, #0]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fcc8:	4638      	mov	r0, r7
   1fcca:	f018 f905 	bl	37ed8 <nrf_gpio_pin_present_check>
   1fcce:	b908      	cbnz	r0, 1fcd4 <uarte_instance_init.constprop.5+0x24>
   1fcd0:	f7ff ffca 	bl	1fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fcd4:	2303      	movs	r3, #3
   1fcd6:	4e2f      	ldr	r6, [pc, #188]	; (1fd94 <uarte_instance_init.constprop.5+0xe4>)
   1fcd8:	3780      	adds	r7, #128	; 0x80
   1fcda:	f846 3027 	str.w	r3, [r6, r7, lsl #2]

	if (config->pselrxd !=  NRF_UARTE_PSEL_DISCONNECTED) {
   1fcde:	686f      	ldr	r7, [r5, #4]
   1fce0:	1c7a      	adds	r2, r7, #1
   1fce2:	d009      	beq.n	1fcf8 <uarte_instance_init.constprop.5+0x48>
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fce4:	4638      	mov	r0, r7
   1fce6:	f018 f8f7 	bl	37ed8 <nrf_gpio_pin_present_check>
   1fcea:	b908      	cbnz	r0, 1fcf0 <uarte_instance_init.constprop.5+0x40>
   1fcec:	f7ff ffbc 	bl	1fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fcf0:	2300      	movs	r3, #0
   1fcf2:	3780      	adds	r7, #128	; 0x80
   1fcf4:	f846 3027 	str.w	r3, [r6, r7, lsl #2]
		nrf_gpio_cfg_input(config->pselrxd, NRF_GPIO_PIN_NOPULL);
	}

	nrf_uarte_txrx_pins_set(uarte, config->pseltxd, config->pselrxd);
   1fcf8:	e9d5 2300 	ldrd	r2, r3, [r5]
    p_reg->PSEL.TXD = pseltxd;
   1fcfc:	f8c4 250c 	str.w	r2, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
   1fd00:	f8c4 3514 	str.w	r3, [r4, #1300]	; 0x514

	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
   1fd04:	68ab      	ldr	r3, [r5, #8]
   1fd06:	3301      	adds	r3, #1
   1fd08:	d020      	beq.n	1fd4c <uarte_instance_init.constprop.5+0x9c>
	    config->pselrts != NRF_UARTE_PSEL_DISCONNECTED) {
   1fd0a:	68e8      	ldr	r0, [r5, #12]
	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED &&
   1fd0c:	1c43      	adds	r3, r0, #1
   1fd0e:	d01d      	beq.n	1fd4c <uarte_instance_init.constprop.5+0x9c>
        nrf_gpio_pin_set(pin_number);
   1fd10:	f7ff ffc0 	bl	1fc94 <nrf_gpio_pin_set>
		nrf_gpio_pin_write(config->pselrts, 1);
		nrf_gpio_cfg_output(config->pselrts);
   1fd14:	68ef      	ldr	r7, [r5, #12]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fd16:	4638      	mov	r0, r7
   1fd18:	f018 f8de 	bl	37ed8 <nrf_gpio_pin_present_check>
   1fd1c:	b908      	cbnz	r0, 1fd22 <uarte_instance_init.constprop.5+0x72>
   1fd1e:	f7ff ffa3 	bl	1fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fd22:	2303      	movs	r3, #3
   1fd24:	3780      	adds	r7, #128	; 0x80
   1fd26:	f846 3027 	str.w	r3, [r6, r7, lsl #2]

		nrf_gpio_cfg_input(config->pselcts, NRF_GPIO_PIN_NOPULL);
   1fd2a:	68af      	ldr	r7, [r5, #8]
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   1fd2c:	4638      	mov	r0, r7
   1fd2e:	f018 f8d3 	bl	37ed8 <nrf_gpio_pin_present_check>
   1fd32:	b908      	cbnz	r0, 1fd38 <uarte_instance_init.constprop.5+0x88>
   1fd34:	f7ff ff98 	bl	1fc68 <nrf_gpio_pin_port_decode.isra.3.part.4>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   1fd38:	2300      	movs	r3, #0
   1fd3a:	3780      	adds	r7, #128	; 0x80
   1fd3c:	f846 3027 	str.w	r3, [r6, r7, lsl #2]

		nrf_uarte_hwfc_pins_set(uarte,
   1fd40:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
    p_reg->PSEL.RTS = pselrts;
   1fd44:	f8c4 2508 	str.w	r2, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
   1fd48:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
					config->pselrts,
					config->pselcts);
	}

	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
   1fd4c:	f8d8 100c 	ldr.w	r1, [r8, #12]
   1fd50:	4640      	mov	r0, r8
   1fd52:	f7ff fed5 	bl	1fb00 <uarte_nrfx_configure>
	if (err) {
   1fd56:	b9d0      	cbnz	r0, 1fd8e <uarte_instance_init.constprop.5+0xde>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
   1fd58:	2308      	movs	r3, #8
   1fd5a:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
	}
#endif
	/* Enable receiver and transmitter */
	nrf_uarte_enable(uarte);

	if (config->pselrxd != NRF_UARTE_PSEL_DISCONNECTED) {
   1fd5e:	686b      	ldr	r3, [r5, #4]
   1fd60:	3301      	adds	r3, #1
   1fd62:	d009      	beq.n	1fd78 <uarte_instance_init.constprop.5+0xc8>
		nrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);

		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
   1fd64:	f109 0310 	add.w	r3, r9, #16
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1fd68:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   1fd6c:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   1fd70:	2301      	movs	r3, #1
   1fd72:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fd76:	6023      	str	r3, [r4, #0]
		/* Set ENDTX event by requesting fake (zero-length) transfer.
		 * Pointer to RAM variable (data->tx_buffer) is set because
		 * otherwise such operation may result in HardFault or RAM
		 * corruption.
		 */
		nrf_uarte_tx_buffer_set(uarte, data->int_driven->tx_buffer, 0);
   1fd78:	f8d9 3008 	ldr.w	r3, [r9, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   1fd7c:	689b      	ldr	r3, [r3, #8]
   1fd7e:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   1fd82:	2300      	movs	r3, #0
   1fd84:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1fd88:	2301      	movs	r3, #1
   1fd8a:	60a3      	str	r3, [r4, #8]
   1fd8c:	60e3      	str	r3, [r4, #12]
		/* switch off transmitter to save an energy */
		nrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPTX);
	}
#endif
	return 0;
}
   1fd8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1fd92:	bf00      	nop
   1fd94:	40842500 	.word	0x40842500

0001fd98 <uarte_1_init>:
#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
#endif

#ifdef CONFIG_UART_1_NRF_UARTE
UART_NRF_UARTE_DEVICE(1);
   1fd98:	b530      	push	{r4, r5, lr}
   1fd9a:	b085      	sub	sp, #20
   1fd9c:	466c      	mov	r4, sp
   1fd9e:	4605      	mov	r5, r0
   1fda0:	4b08      	ldr	r3, [pc, #32]	; (1fdc4 <uarte_1_init+0x2c>)
   1fda2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   1fda4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   1fda8:	2200      	movs	r2, #0
   1fdaa:	2101      	movs	r1, #1
   1fdac:	2009      	movs	r0, #9
   1fdae:	f7fa ff2f 	bl	1ac10 <z_arm_irq_priority_set>
   1fdb2:	2009      	movs	r0, #9
   1fdb4:	f7fa ff1c 	bl	1abf0 <arch_irq_enable>
   1fdb8:	4621      	mov	r1, r4
   1fdba:	4628      	mov	r0, r5
   1fdbc:	f7ff ff78 	bl	1fcb0 <uarte_instance_init.constprop.5>
   1fdc0:	b005      	add	sp, #20
   1fdc2:	bd30      	pop	{r4, r5, pc}
   1fdc4:	0003a0ec 	.word	0x0003a0ec

0001fdc8 <uarte_0_init>:
UART_NRF_UARTE_DEVICE(0);
   1fdc8:	b530      	push	{r4, r5, lr}
   1fdca:	b085      	sub	sp, #20
   1fdcc:	466c      	mov	r4, sp
   1fdce:	4605      	mov	r5, r0
   1fdd0:	4b08      	ldr	r3, [pc, #32]	; (1fdf4 <uarte_0_init+0x2c>)
   1fdd2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
   1fdd4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
   1fdd8:	2200      	movs	r2, #0
   1fdda:	2101      	movs	r1, #1
   1fddc:	2008      	movs	r0, #8
   1fdde:	f7fa ff17 	bl	1ac10 <z_arm_irq_priority_set>
   1fde2:	2008      	movs	r0, #8
   1fde4:	f7fa ff04 	bl	1abf0 <arch_irq_enable>
   1fde8:	4621      	mov	r1, r4
   1fdea:	4628      	mov	r0, r5
   1fdec:	f7ff ff60 	bl	1fcb0 <uarte_instance_init.constprop.5>
   1fdf0:	b005      	add	sp, #20
   1fdf2:	bd30      	pop	{r4, r5, pc}
   1fdf4:	0003a0fc 	.word	0x0003a0fc

0001fdf8 <entropy_cc310_rng_get_entropy>:
#include "nrf_cc310_platform_entropy.h"
#endif

static int entropy_cc310_rng_get_entropy(struct device *dev, u8_t *buffer,
					 u16_t length)
{
   1fdf8:	b537      	push	{r0, r1, r2, r4, r5, lr}
   1fdfa:	460d      	mov	r5, r1
   1fdfc:	4614      	mov	r4, r2
	int res = -EINVAL;
	size_t olen;

	__ASSERT_NO_MSG(dev != NULL);
   1fdfe:	b948      	cbnz	r0, 1fe14 <entropy_cc310_rng_get_entropy+0x1c>
   1fe00:	4910      	ldr	r1, [pc, #64]	; (1fe44 <entropy_cc310_rng_get_entropy+0x4c>)
   1fe02:	4811      	ldr	r0, [pc, #68]	; (1fe48 <entropy_cc310_rng_get_entropy+0x50>)
   1fe04:	231c      	movs	r3, #28
   1fe06:	4a11      	ldr	r2, [pc, #68]	; (1fe4c <entropy_cc310_rng_get_entropy+0x54>)
   1fe08:	f013 fbde 	bl	335c8 <printk>
   1fe0c:	211c      	movs	r1, #28
   1fe0e:	480f      	ldr	r0, [pc, #60]	; (1fe4c <entropy_cc310_rng_get_entropy+0x54>)
   1fe10:	f013 fedb 	bl	33bca <assert_post_action>
	__ASSERT_NO_MSG(buffer != NULL);
   1fe14:	b94d      	cbnz	r5, 1fe2a <entropy_cc310_rng_get_entropy+0x32>
   1fe16:	490e      	ldr	r1, [pc, #56]	; (1fe50 <entropy_cc310_rng_get_entropy+0x58>)
   1fe18:	480b      	ldr	r0, [pc, #44]	; (1fe48 <entropy_cc310_rng_get_entropy+0x50>)
   1fe1a:	231d      	movs	r3, #29
   1fe1c:	4a0b      	ldr	r2, [pc, #44]	; (1fe4c <entropy_cc310_rng_get_entropy+0x54>)
   1fe1e:	f013 fbd3 	bl	335c8 <printk>
   1fe22:	211d      	movs	r1, #29
   1fe24:	4809      	ldr	r0, [pc, #36]	; (1fe4c <entropy_cc310_rng_get_entropy+0x54>)
   1fe26:	f013 fed0 	bl	33bca <assert_post_action>

#if defined(CONFIG_SPM)
	/** This is a call from a non-secure app that enables secure services,
	 *  in which case entropy is gathered by calling through SPM
	 */
	res = spm_request_random_number(buffer, length, &olen);
   1fe2a:	aa01      	add	r2, sp, #4
   1fe2c:	4621      	mov	r1, r4
   1fe2e:	4628      	mov	r0, r5
   1fe30:	f7e8 f8de 	bl	7ff0 <spm_request_random_number>
	if (olen != length) {
   1fe34:	9b01      	ldr	r3, [sp, #4]
		return -EINVAL;
   1fe36:	429c      	cmp	r4, r3
		return -EINVAL;
	}
#endif

	return res;
}
   1fe38:	bf18      	it	ne
   1fe3a:	f06f 0015 	mvnne.w	r0, #21
   1fe3e:	b003      	add	sp, #12
   1fe40:	bd30      	pop	{r4, r5, pc}
   1fe42:	bf00      	nop
   1fe44:	0003e1cf 	.word	0x0003e1cf
   1fe48:	0003b77f 	.word	0x0003b77f
   1fe4c:	0003e19f 	.word	0x0003e19f
   1fe50:	0003e1e2 	.word	0x0003e1e2

0001fe54 <_bsdlib_init>:
extern void ipc_proxy_irq_handler(void);

static int init_ret;

static int _bsdlib_init(struct device *unused)
{
   1fe54:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Setup the network IRQ used by the BSD library.
	 * Note: No call to irq_enable() here, that is done through bsd_init().
	 */
	IRQ_DIRECT_CONNECT(BSD_NETWORK_IRQ, BSD_NETWORK_IRQ_PRIORITY,
   1fe56:	2200      	movs	r2, #0
   1fe58:	202a      	movs	r0, #42	; 0x2a
   1fe5a:	4611      	mov	r1, r2
   1fe5c:	f7fa fed8 	bl	1ac10 <z_arm_irq_priority_set>
			   ipc_proxy_irq_handler, 0);

	const bsd_init_params_t init_params = {
   1fe60:	4a06      	ldr	r2, [pc, #24]	; (1fe7c <_bsdlib_init+0x28>)
   1fe62:	ab01      	add	r3, sp, #4
   1fe64:	ca07      	ldmia	r2, {r0, r1, r2}
   1fe66:	e883 0007 	stmia.w	r3, {r0, r1, r2}
		.trace_on = true,
		.bsd_memory_address = BSD_RESERVED_MEMORY_ADDRESS,
		.bsd_memory_size = BSD_RESERVED_MEMORY_SIZE
	};

	init_ret = bsd_init(&init_params);
   1fe6a:	4618      	mov	r0, r3
   1fe6c:	f008 fe10 	bl	28a90 <bsd_init>
   1fe70:	4b03      	ldr	r3, [pc, #12]	; (1fe80 <_bsdlib_init+0x2c>)
   1fe72:	6018      	str	r0, [r3, #0]
		 */
		return 0;
	}

	return init_ret;
}
   1fe74:	2000      	movs	r0, #0
   1fe76:	b005      	add	sp, #20
   1fe78:	f85d fb04 	ldr.w	pc, [sp], #4
   1fe7c:	0003a10c 	.word	0x0003a10c
   1fe80:	2002223c 	.word	0x2002223c

0001fe84 <thread_monitor_entry_get>:

/* Get thread monitor structure assigned to a specific thread id, with a RPC
 * counter value at which bsdlib last checked the 'readiness' of a thread
 */
static struct thread_monitor_entry *thread_monitor_entry_get(k_tid_t id)
{
   1fe84:	b570      	push	{r4, r5, r6, lr}
			new_entry = entry;
			break;
		}

		/* Identify oldest entry. */
		entry_age = rpc_event_cnt - entry->cnt;
   1fe86:	4b0d      	ldr	r3, [pc, #52]	; (1febc <thread_monitor_entry_get+0x38>)
	struct thread_monitor_entry *new_entry = thread_event_monitor;
   1fe88:	4c0d      	ldr	r4, [pc, #52]	; (1fec0 <thread_monitor_entry_get+0x3c>)
		entry_age = rpc_event_cnt - entry->cnt;
   1fe8a:	681a      	ldr	r2, [r3, #0]
   1fe8c:	250a      	movs	r5, #10
	int entry_age, oldest_entry_age = 0;
   1fe8e:	2600      	movs	r6, #0
	struct thread_monitor_entry *entry = thread_event_monitor;
   1fe90:	4623      	mov	r3, r4
		if (entry->id == id) {
   1fe92:	6819      	ldr	r1, [r3, #0]
   1fe94:	4281      	cmp	r1, r0
   1fe96:	d00e      	beq.n	1feb6 <thread_monitor_entry_get+0x32>
		} else if (entry->id == 0) {
   1fe98:	b151      	cbz	r1, 1feb0 <thread_monitor_entry_get+0x2c>
		entry_age = rpc_event_cnt - entry->cnt;
   1fe9a:	6859      	ldr	r1, [r3, #4]
   1fe9c:	1a51      	subs	r1, r2, r1
		if (entry_age > oldest_entry_age) {
   1fe9e:	42b1      	cmp	r1, r6
   1fea0:	bfc4      	itt	gt
   1fea2:	461c      	movgt	r4, r3
   1fea4:	460e      	movgt	r6, r1
	for ( ; PART_OF_ARRAY(thread_event_monitor, entry); entry++) {
   1fea6:	3d01      	subs	r5, #1
   1fea8:	f103 0308 	add.w	r3, r3, #8
   1feac:	d1f1      	bne.n	1fe92 <thread_monitor_entry_get+0xe>
   1feae:	4623      	mov	r3, r4
			new_entry = entry;
		}
	}

	new_entry->id = id;
	new_entry->cnt = rpc_event_cnt - 1;
   1feb0:	3a01      	subs	r2, #1
	new_entry->id = id;
   1feb2:	6018      	str	r0, [r3, #0]
	new_entry->cnt = rpc_event_cnt - 1;
   1feb4:	605a      	str	r2, [r3, #4]

	return new_entry;
}
   1feb6:	4618      	mov	r0, r3
   1feb8:	bd70      	pop	{r4, r5, r6, pc}
   1feba:	bf00      	nop
   1febc:	20022240 	.word	0x20022240
   1fec0:	2002224c 	.word	0x2002224c

0001fec4 <rpc_proxy_irq_handler>:
			  */

	return 1; /* We should check if scheduling decision should be made */
}

ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   1fec4:	4668      	mov	r0, sp
   1fec6:	f020 0107 	bic.w	r1, r0, #7
   1feca:	468d      	mov	sp, r1
   1fecc:	b519      	push	{r0, r3, r4, lr}
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   1fece:	4b0d      	ldr	r3, [pc, #52]	; (1ff04 <rpc_proxy_irq_handler+0x40>)
   1fed0:	e8d3 2fef 	ldaex	r2, [r3]
   1fed4:	3201      	adds	r2, #1
   1fed6:	e8c3 2fe1 	stlex	r1, r2, [r3]
   1feda:	2900      	cmp	r1, #0
   1fedc:	d1f8      	bne.n	1fed0 <rpc_proxy_irq_handler+0xc>
{
	atomic_inc(&rpc_event_cnt);

	bsd_os_application_irq_handler();
   1fede:	f003 f97d 	bl	231dc <bsd_os_application_irq_handler>

	struct sleeping_thread *thread;

	/* Wake up all sleeping threads. */
	SYS_SLIST_FOR_EACH_CONTAINER(&sleeping_threads, thread, node) {
   1fee2:	4b09      	ldr	r3, [pc, #36]	; (1ff08 <rpc_proxy_irq_handler+0x44>)
   1fee4:	681c      	ldr	r4, [r3, #0]
   1fee6:	b93c      	cbnz	r4, 1fef8 <rpc_proxy_irq_handler+0x34>
		k_sem_give(&thread->sem);
	}

	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   1fee8:	f7fa fec4 	bl	1ac74 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
   1feec:	f7fb fb10 	bl	1b510 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(rpc_proxy_irq_handler)
   1fef0:	e8bd 4019 	ldmia.w	sp!, {r0, r3, r4, lr}
   1fef4:	4685      	mov	sp, r0
   1fef6:	4770      	bx	lr
	z_impl_k_sem_give(sem);
   1fef8:	1d20      	adds	r0, r4, #4
   1fefa:	f00e f877 	bl	2dfec <z_impl_k_sem_give>
   1fefe:	6824      	ldr	r4, [r4, #0]
	return node->next;
   1ff00:	e7f1      	b.n	1fee6 <rpc_proxy_irq_handler+0x22>
   1ff02:	bf00      	nop
   1ff04:	20022240 	.word	0x20022240
   1ff08:	20022244 	.word	0x20022244

0001ff0c <bsd_os_timedwait>:
{
   1ff0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1ff10:	460e      	mov	r6, r1
   1ff12:	b089      	sub	sp, #36	; 0x24
	return z_impl_k_uptime_ticks();
   1ff14:	f018 ff92 	bl	38e3c <z_impl_k_uptime_ticks>
	if (*timeout == 0) {
   1ff18:	6833      	ldr	r3, [r6, #0]
   1ff1a:	4680      	mov	r8, r0
   1ff1c:	2b00      	cmp	r3, #0
   1ff1e:	460f      	mov	r7, r1
   1ff20:	d103      	bne.n	1ff2a <bsd_os_timedwait+0x1e>
	z_impl_k_yield();
   1ff22:	f00d fedf 	bl	2dce4 <z_impl_k_yield>
		return NRF_ETIMEDOUT;
   1ff26:	203c      	movs	r0, #60	; 0x3c
   1ff28:	e084      	b.n	20034 <bsd_os_timedwait+0x128>
		*timeout = SYS_FOREVER_MS;
   1ff2a:	bfbc      	itt	lt
   1ff2c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   1ff30:	6033      	strlt	r3, [r6, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
   1ff32:	2201      	movs	r2, #1
   1ff34:	2100      	movs	r1, #0
   1ff36:	a802      	add	r0, sp, #8
   1ff38:	f018 fef3 	bl	38d22 <z_impl_k_sem_init>
   1ff3c:	f10d 0a04 	add.w	sl, sp, #4
	__asm__ volatile(
   1ff40:	f04f 0320 	mov.w	r3, #32
   1ff44:	f3ef 8b11 	mrs	fp, BASEPRI
   1ff48:	f383 8811 	msr	BASEPRI, r3
   1ff4c:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   1ff50:	f00e f846 	bl	2dfe0 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   1ff54:	f7ff ff96 	bl	1fe84 <thread_monitor_entry_get>
	if (rpc_event_cnt != entry->cnt) {
   1ff58:	493f      	ldr	r1, [pc, #252]	; (20058 <bsd_os_timedwait+0x14c>)
   1ff5a:	6843      	ldr	r3, [r0, #4]
   1ff5c:	680a      	ldr	r2, [r1, #0]
   1ff5e:	4689      	mov	r9, r1
   1ff60:	4293      	cmp	r3, r2
   1ff62:	f04f 0300 	mov.w	r3, #0
   1ff66:	d108      	bne.n	1ff7a <bsd_os_timedwait+0x6e>
	parent->next = child;
   1ff68:	9301      	str	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   1ff6a:	4b3c      	ldr	r3, [pc, #240]	; (2005c <bsd_os_timedwait+0x150>)
   1ff6c:	685a      	ldr	r2, [r3, #4]
   1ff6e:	2a00      	cmp	r2, #0
   1ff70:	d163      	bne.n	2003a <bsd_os_timedwait+0x12e>
	list->head = node;
   1ff72:	e9c3 aa00 	strd	sl, sl, [r3]
		allow_to_sleep = true;
   1ff76:	2301      	movs	r3, #1
   1ff78:	e000      	b.n	1ff7c <bsd_os_timedwait+0x70>
	entry->cnt = rpc_event_cnt;
   1ff7a:	6042      	str	r2, [r0, #4]
	__asm__ volatile(
   1ff7c:	f38b 8811 	msr	BASEPRI, fp
   1ff80:	f3bf 8f6f 	isb	sy
	if (!sleeping_thread_add(&thread)) {
   1ff84:	2b00      	cmp	r3, #0
   1ff86:	d054      	beq.n	20032 <bsd_os_timedwait+0x126>
	(void)k_sem_take(&thread.sem, SYS_TIMEOUT_MS(*timeout));
   1ff88:	6831      	ldr	r1, [r6, #0]
	return z_impl_k_sem_take(sem, timeout);
   1ff8a:	a802      	add	r0, sp, #8
   1ff8c:	f00e f872 	bl	2e074 <z_impl_k_sem_take>
	__asm__ volatile(
   1ff90:	f04f 0320 	mov.w	r3, #32
   1ff94:	f3ef 8b11 	mrs	fp, BASEPRI
   1ff98:	f383 8811 	msr	BASEPRI, r3
   1ff9c:	f3bf 8f6f 	isb	sy
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1ffa0:	2000      	movs	r0, #0
   1ffa2:	4b2e      	ldr	r3, [pc, #184]	; (2005c <bsd_os_timedwait+0x150>)
   1ffa4:	681a      	ldr	r2, [r3, #0]
   1ffa6:	b15a      	cbz	r2, 1ffc0 <bsd_os_timedwait+0xb4>
   1ffa8:	4552      	cmp	r2, sl
   1ffaa:	d151      	bne.n	20050 <bsd_os_timedwait+0x144>
Z_GENLIST_REMOVE(slist, snode)
   1ffac:	9901      	ldr	r1, [sp, #4]
   1ffae:	2800      	cmp	r0, #0
   1ffb0:	d148      	bne.n	20044 <bsd_os_timedwait+0x138>
   1ffb2:	6858      	ldr	r0, [r3, #4]
	list->head = node;
   1ffb4:	6019      	str	r1, [r3, #0]
Z_GENLIST_REMOVE(slist, snode)
   1ffb6:	4290      	cmp	r0, r2
   1ffb8:	d100      	bne.n	1ffbc <bsd_os_timedwait+0xb0>
	list->tail = node;
   1ffba:	6059      	str	r1, [r3, #4]
	parent->next = child;
   1ffbc:	2300      	movs	r3, #0
   1ffbe:	9301      	str	r3, [sp, #4]
	return z_impl_k_current_get();
   1ffc0:	f00e f80e 	bl	2dfe0 <z_impl_k_current_get>
	entry = thread_monitor_entry_get(k_current_get());
   1ffc4:	f7ff ff5e 	bl	1fe84 <thread_monitor_entry_get>
	entry->cnt = rpc_event_cnt;
   1ffc8:	f8d9 3000 	ldr.w	r3, [r9]
   1ffcc:	6043      	str	r3, [r0, #4]
	__asm__ volatile(
   1ffce:	f38b 8811 	msr	BASEPRI, fp
   1ffd2:	f3bf 8f6f 	isb	sy
	if (*timeout == SYS_FOREVER_MS) {
   1ffd6:	f8d6 a000 	ldr.w	sl, [r6]
   1ffda:	f1ba 3fff 	cmp.w	sl, #4294967295	; 0xffffffff
   1ffde:	d028      	beq.n	20032 <bsd_os_timedwait+0x126>
	return z_impl_k_uptime_ticks();
   1ffe0:	f018 ff2c 	bl	38e3c <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   1ffe4:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
   1ffe8:	fba8 890c 	umull	r8, r9, r8, ip
   1ffec:	fb0c 9907 	mla	r9, ip, r7, r9
   1fff0:	ea4f 32d8 	mov.w	r2, r8, lsr #15
   1fff4:	ea42 4249 	orr.w	r2, r2, r9, lsl #17
	remaining = *timeout - k_uptime_delta(&start);
   1fff8:	eb12 080a 	adds.w	r8, r2, sl
   1fffc:	ea4f 33d9 	mov.w	r3, r9, lsr #15
   20000:	eb43 79ea 	adc.w	r9, r3, sl, asr #31
   20004:	fba0 ab0c 	umull	sl, fp, r0, ip
   20008:	fb0c bb01 	mla	fp, ip, r1, fp
   2000c:	ea4f 33da 	mov.w	r3, sl, lsr #15
   20010:	ea43 434b 	orr.w	r3, r3, fp, lsl #17
   20014:	ebb8 0403 	subs.w	r4, r8, r3
   20018:	ea4f 32db 	mov.w	r2, fp, lsr #15
   2001c:	eb69 0502 	sbc.w	r5, r9, r2
	*timeout = remaining > 0 ? remaining : 0;
   20020:	2c00      	cmp	r4, #0
   20022:	f175 0300 	sbcs.w	r3, r5, #0
   20026:	bfb8      	it	lt
   20028:	2400      	movlt	r4, #0
   2002a:	6034      	str	r4, [r6, #0]
	if (*timeout == 0) {
   2002c:	2c00      	cmp	r4, #0
   2002e:	f43f af7a 	beq.w	1ff26 <bsd_os_timedwait+0x1a>
	return 0;
   20032:	2000      	movs	r0, #0
}
   20034:	b009      	add	sp, #36	; 0x24
   20036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2003a:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
   2003e:	f8c3 a004 	str.w	sl, [r3, #4]
   20042:	e798      	b.n	1ff76 <bsd_os_timedwait+0x6a>
	parent->next = child;
   20044:	6001      	str	r1, [r0, #0]
Z_GENLIST_REMOVE(slist, snode)
   20046:	6859      	ldr	r1, [r3, #4]
   20048:	4291      	cmp	r1, r2
	list->tail = node;
   2004a:	bf08      	it	eq
   2004c:	6058      	streq	r0, [r3, #4]
   2004e:	e7b5      	b.n	1ffbc <bsd_os_timedwait+0xb0>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   20050:	4610      	mov	r0, r2
   20052:	6812      	ldr	r2, [r2, #0]
   20054:	e7a7      	b.n	1ffa6 <bsd_os_timedwait+0x9a>
   20056:	bf00      	nop
   20058:	20022240 	.word	0x20022240
   2005c:	20022244 	.word	0x20022244

00020060 <bsd_os_errno_set>:
	switch (err_code) {
   20060:	282d      	cmp	r0, #45	; 0x2d
{
   20062:	b510      	push	{r4, lr}
   20064:	4604      	mov	r4, r0
	switch (err_code) {
   20066:	f000 80a8 	beq.w	201ba <bsd_os_errno_set+0x15a>
   2006a:	dc50      	bgt.n	2010e <bsd_os_errno_set+0xae>
   2006c:	2816      	cmp	r0, #22
   2006e:	d009      	beq.n	20084 <bsd_os_errno_set+0x24>
   20070:	dc38      	bgt.n	200e4 <bsd_os_errno_set+0x84>
   20072:	2808      	cmp	r0, #8
   20074:	d006      	beq.n	20084 <bsd_os_errno_set+0x24>
   20076:	dc09      	bgt.n	2008c <bsd_os_errno_set+0x2c>
   20078:	2802      	cmp	r0, #2
   2007a:	d003      	beq.n	20084 <bsd_os_errno_set+0x24>
   2007c:	2805      	cmp	r0, #5
   2007e:	d001      	beq.n	20084 <bsd_os_errno_set+0x24>
   20080:	2801      	cmp	r0, #1
   20082:	d10c      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = ENOBUFS;
   20084:	f015 fa30 	bl	354e8 <__errno>
   20088:	6004      	str	r4, [r0, #0]
}
   2008a:	bd10      	pop	{r4, pc}
	switch (err_code) {
   2008c:	280c      	cmp	r0, #12
   2008e:	d0f9      	beq.n	20084 <bsd_os_errno_set+0x24>
   20090:	dc01      	bgt.n	20096 <bsd_os_errno_set+0x36>
   20092:	2809      	cmp	r0, #9
   20094:	e7f5      	b.n	20082 <bsd_os_errno_set+0x22>
   20096:	280d      	cmp	r0, #13
   20098:	d0f4      	beq.n	20084 <bsd_os_errno_set+0x24>
   2009a:	280e      	cmp	r0, #14
   2009c:	d074      	beq.n	20188 <bsd_os_errno_set+0x128>
		__ASSERT(false, "Untranslated errno %d set by bsdlib!", err_code);
   2009e:	f44f 73a5 	mov.w	r3, #330	; 0x14a
   200a2:	4a63      	ldr	r2, [pc, #396]	; (20230 <bsd_os_errno_set+0x1d0>)
   200a4:	4963      	ldr	r1, [pc, #396]	; (20234 <bsd_os_errno_set+0x1d4>)
   200a6:	4864      	ldr	r0, [pc, #400]	; (20238 <bsd_os_errno_set+0x1d8>)
   200a8:	f013 fa8e 	bl	335c8 <printk>
   200ac:	4621      	mov	r1, r4
   200ae:	4863      	ldr	r0, [pc, #396]	; (2023c <bsd_os_errno_set+0x1dc>)
   200b0:	f013 fa8a 	bl	335c8 <printk>
   200b4:	f44f 71a5 	mov.w	r1, #330	; 0x14a
   200b8:	485d      	ldr	r0, [pc, #372]	; (20230 <bsd_os_errno_set+0x1d0>)
   200ba:	f013 fd86 	bl	33bca <assert_post_action>
		LOG_ERR("Untranslated errno %d set by bsdlib!", err_code);
   200be:	2301      	movs	r3, #1
   200c0:	f04f 0000 	mov.w	r0, #0
   200c4:	4a5e      	ldr	r2, [pc, #376]	; (20240 <bsd_os_errno_set+0x1e0>)
   200c6:	f363 0007 	bfi	r0, r3, #0, #8
   200ca:	4b5e      	ldr	r3, [pc, #376]	; (20244 <bsd_os_errno_set+0x1e4>)
   200cc:	495e      	ldr	r1, [pc, #376]	; (20248 <bsd_os_errno_set+0x1e8>)
   200ce:	1a9b      	subs	r3, r3, r2
   200d0:	08db      	lsrs	r3, r3, #3
   200d2:	f363 108f 	bfi	r0, r3, #6, #10
   200d6:	4622      	mov	r2, r4
   200d8:	f013 fd8e 	bl	33bf8 <log_string_sync>
		errno = 0xBAADBAAD;
   200dc:	f015 fa04 	bl	354e8 <__errno>
   200e0:	4b5a      	ldr	r3, [pc, #360]	; (2024c <bsd_os_errno_set+0x1ec>)
   200e2:	e054      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   200e4:	2828      	cmp	r0, #40	; 0x28
   200e6:	f000 809f 	beq.w	20228 <bsd_os_errno_set+0x1c8>
   200ea:	dc05      	bgt.n	200f8 <bsd_os_errno_set+0x98>
   200ec:	2823      	cmp	r0, #35	; 0x23
   200ee:	d050      	beq.n	20192 <bsd_os_errno_set+0x132>
   200f0:	2825      	cmp	r0, #37	; 0x25
   200f2:	d052      	beq.n	2019a <bsd_os_errno_set+0x13a>
   200f4:	2818      	cmp	r0, #24
   200f6:	e7c4      	b.n	20082 <bsd_os_errno_set+0x22>
   200f8:	282a      	cmp	r0, #42	; 0x2a
   200fa:	d056      	beq.n	201aa <bsd_os_errno_set+0x14a>
   200fc:	db51      	blt.n	201a2 <bsd_os_errno_set+0x142>
   200fe:	282b      	cmp	r0, #43	; 0x2b
   20100:	d057      	beq.n	201b2 <bsd_os_errno_set+0x152>
   20102:	282c      	cmp	r0, #44	; 0x2c
   20104:	d1cb      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = ESOCKTNOSUPPORT;
   20106:	f015 f9ef 	bl	354e8 <__errno>
   2010a:	237c      	movs	r3, #124	; 0x7c
   2010c:	e03f      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2010e:	283c      	cmp	r0, #60	; 0x3c
   20110:	d06b      	beq.n	201ea <bsd_os_errno_set+0x18a>
   20112:	dc1d      	bgt.n	20150 <bsd_os_errno_set+0xf0>
   20114:	2833      	cmp	r0, #51	; 0x33
   20116:	d05c      	beq.n	201d2 <bsd_os_errno_set+0x172>
   20118:	dc09      	bgt.n	2012e <bsd_os_errno_set+0xce>
   2011a:	2830      	cmp	r0, #48	; 0x30
   2011c:	d051      	beq.n	201c2 <bsd_os_errno_set+0x162>
   2011e:	2832      	cmp	r0, #50	; 0x32
   20120:	d053      	beq.n	201ca <bsd_os_errno_set+0x16a>
   20122:	282f      	cmp	r0, #47	; 0x2f
   20124:	d1bb      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = EAFNOSUPPORT;
   20126:	f015 f9df 	bl	354e8 <__errno>
   2012a:	236a      	movs	r3, #106	; 0x6a
   2012c:	e02f      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   2012e:	2836      	cmp	r0, #54	; 0x36
   20130:	d053      	beq.n	201da <bsd_os_errno_set+0x17a>
   20132:	dc05      	bgt.n	20140 <bsd_os_errno_set+0xe0>
   20134:	2834      	cmp	r0, #52	; 0x34
   20136:	d1b2      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = ENETRESET;
   20138:	f015 f9d6 	bl	354e8 <__errno>
   2013c:	237e      	movs	r3, #126	; 0x7e
   2013e:	e026      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   20140:	2838      	cmp	r0, #56	; 0x38
   20142:	d04e      	beq.n	201e2 <bsd_os_errno_set+0x182>
   20144:	2839      	cmp	r0, #57	; 0x39
   20146:	d1aa      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = ENOTCONN;
   20148:	f015 f9ce 	bl	354e8 <__errno>
   2014c:	2380      	movs	r3, #128	; 0x80
   2014e:	e01e      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   20150:	287d      	cmp	r0, #125	; 0x7d
   20152:	d056      	beq.n	20202 <bsd_os_errno_set+0x1a2>
   20154:	dc0c      	bgt.n	20170 <bsd_os_errno_set+0x110>
   20156:	2870      	cmp	r0, #112	; 0x70
   20158:	d04b      	beq.n	201f2 <bsd_os_errno_set+0x192>
   2015a:	dc01      	bgt.n	20160 <bsd_os_errno_set+0x100>
   2015c:	2869      	cmp	r0, #105	; 0x69
   2015e:	e790      	b.n	20082 <bsd_os_errno_set+0x22>
   20160:	2872      	cmp	r0, #114	; 0x72
   20162:	d04a      	beq.n	201fa <bsd_os_errno_set+0x19a>
   20164:	2873      	cmp	r0, #115	; 0x73
   20166:	d19a      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = EINPROGRESS;
   20168:	f015 f9be 	bl	354e8 <__errno>
   2016c:	2377      	movs	r3, #119	; 0x77
   2016e:	e00e      	b.n	2018e <bsd_os_errno_set+0x12e>
	switch (err_code) {
   20170:	287f      	cmp	r0, #127	; 0x7f
   20172:	d04f      	beq.n	20214 <bsd_os_errno_set+0x1b4>
   20174:	db49      	blt.n	2020a <bsd_os_errno_set+0x1aa>
   20176:	2880      	cmp	r0, #128	; 0x80
   20178:	d051      	beq.n	2021e <bsd_os_errno_set+0x1be>
   2017a:	2881      	cmp	r0, #129	; 0x81
   2017c:	d18f      	bne.n	2009e <bsd_os_errno_set+0x3e>
		errno = EKEYREJECTED;
   2017e:	f015 f9b3 	bl	354e8 <__errno>
   20182:	f240 73d4 	movw	r3, #2004	; 0x7d4
   20186:	e002      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EFAULT;
   20188:	f015 f9ae 	bl	354e8 <__errno>
   2018c:	230e      	movs	r3, #14
		errno = 0xBAADBAAD;
   2018e:	6003      	str	r3, [r0, #0]
}
   20190:	e77b      	b.n	2008a <bsd_os_errno_set+0x2a>
		errno = EAGAIN;
   20192:	f015 f9a9 	bl	354e8 <__errno>
   20196:	230b      	movs	r3, #11
   20198:	e7f9      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EDOM;
   2019a:	f015 f9a5 	bl	354e8 <__errno>
   2019e:	2321      	movs	r3, #33	; 0x21
   201a0:	e7f5      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EPROTOTYPE;
   201a2:	f015 f9a1 	bl	354e8 <__errno>
   201a6:	236b      	movs	r3, #107	; 0x6b
   201a8:	e7f1      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ENOPROTOOPT;
   201aa:	f015 f99d 	bl	354e8 <__errno>
   201ae:	236d      	movs	r3, #109	; 0x6d
   201b0:	e7ed      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EPROTONOSUPPORT;
   201b2:	f015 f999 	bl	354e8 <__errno>
   201b6:	237b      	movs	r3, #123	; 0x7b
   201b8:	e7e9      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EOPNOTSUPP;
   201ba:	f015 f995 	bl	354e8 <__errno>
   201be:	235f      	movs	r3, #95	; 0x5f
   201c0:	e7e5      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EADDRINUSE;
   201c2:	f015 f991 	bl	354e8 <__errno>
   201c6:	2370      	movs	r3, #112	; 0x70
   201c8:	e7e1      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ENETDOWN;
   201ca:	f015 f98d 	bl	354e8 <__errno>
   201ce:	2373      	movs	r3, #115	; 0x73
   201d0:	e7dd      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ENETUNREACH;
   201d2:	f015 f989 	bl	354e8 <__errno>
   201d6:	2372      	movs	r3, #114	; 0x72
   201d8:	e7d9      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ECONNRESET;
   201da:	f015 f985 	bl	354e8 <__errno>
   201de:	2368      	movs	r3, #104	; 0x68
   201e0:	e7d5      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EISCONN;
   201e2:	f015 f981 	bl	354e8 <__errno>
   201e6:	237f      	movs	r3, #127	; 0x7f
   201e8:	e7d1      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ETIMEDOUT;
   201ea:	f015 f97d 	bl	354e8 <__errno>
   201ee:	2374      	movs	r3, #116	; 0x74
   201f0:	e7cd      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EHOSTDOWN;
   201f2:	f015 f979 	bl	354e8 <__errno>
   201f6:	2375      	movs	r3, #117	; 0x75
   201f8:	e7c9      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EALREADY;
   201fa:	f015 f975 	bl	354e8 <__errno>
   201fe:	2378      	movs	r3, #120	; 0x78
   20200:	e7c5      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ECANCELED;
   20202:	f015 f971 	bl	354e8 <__errno>
   20206:	238c      	movs	r3, #140	; 0x8c
   20208:	e7c1      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = ENOKEY;
   2020a:	f015 f96d 	bl	354e8 <__errno>
   2020e:	f240 73d1 	movw	r3, #2001	; 0x7d1
   20212:	e7bc      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EKEYEXPIRED;
   20214:	f015 f968 	bl	354e8 <__errno>
   20218:	f240 73d2 	movw	r3, #2002	; 0x7d2
   2021c:	e7b7      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EKEYREVOKED;
   2021e:	f015 f963 	bl	354e8 <__errno>
   20222:	f240 73d3 	movw	r3, #2003	; 0x7d3
   20226:	e7b2      	b.n	2018e <bsd_os_errno_set+0x12e>
		errno = EMSGSIZE;
   20228:	f015 f95e 	bl	354e8 <__errno>
   2022c:	237a      	movs	r3, #122	; 0x7a
   2022e:	e7ae      	b.n	2018e <bsd_os_errno_set+0x12e>
   20230:	0003e1f8 	.word	0x0003e1f8
   20234:	0003fd3b 	.word	0x0003fd3b
   20238:	0003b77f 	.word	0x0003b77f
   2023c:	0003e21c 	.word	0x0003e21c
   20240:	00039f60 	.word	0x00039f60
   20244:	00039f78 	.word	0x00039f78
   20248:	0003e243 	.word	0x0003e243
   2024c:	baadbaad 	.word	0xbaadbaad

00020250 <bsd_os_application_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20250:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   20254:	4b01      	ldr	r3, [pc, #4]	; (2025c <bsd_os_application_irq_set+0xc>)
   20256:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   2025a:	4770      	bx	lr
   2025c:	e000e100 	.word	0xe000e100

00020260 <bsd_os_application_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20260:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   20264:	4b01      	ldr	r3, [pc, #4]	; (2026c <bsd_os_application_irq_clear+0xc>)
   20266:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   2026a:	4770      	bx	lr
   2026c:	e000e100 	.word	0xe000e100

00020270 <bsd_os_trace_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20270:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   20274:	4b01      	ldr	r3, [pc, #4]	; (2027c <bsd_os_trace_irq_set+0xc>)
   20276:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
   2027a:	4770      	bx	lr
   2027c:	e000e100 	.word	0xe000e100

00020280 <bsd_os_trace_irq_clear>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   20280:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   20284:	4b01      	ldr	r3, [pc, #4]	; (2028c <bsd_os_trace_irq_clear+0xc>)
   20286:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
}
   2028a:	4770      	bx	lr
   2028c:	e000e100 	.word	0xe000e100

00020290 <bsd_os_init>:
#endif
}

/* This function is called by bsd_init and must not be called explicitly. */
void bsd_os_init(void)
{
   20290:	b508      	push	{r3, lr}
	list->head = NULL;
   20292:	2300      	movs	r3, #0
   20294:	4a07      	ldr	r2, [pc, #28]	; (202b4 <bsd_os_init+0x24>)
	list->tail = NULL;
   20296:	e9c2 3300 	strd	r3, r3, [r2]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
   2029a:	4a07      	ldr	r2, [pc, #28]	; (202b8 <bsd_os_init+0x28>)
   2029c:	e8d2 1fef 	ldaex	r1, [r2]
   202a0:	e8c2 3fe0 	stlex	r0, r3, [r2]
   202a4:	2800      	cmp	r0, #0
   202a6:	d1f9      	bne.n	2029c <bsd_os_init+0xc>
	sys_slist_init(&sleeping_threads);
	atomic_clear(&rpc_event_cnt);

	read_task_create();
   202a8:	f017 ff5c 	bl	38164 <read_task_create>

	/* Configure and enable modem tracing over UART. */
	trace_uart_init();
	trace_task_create();
}
   202ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	trace_task_create();
   202b0:	f017 bf4d 	b.w	3814e <trace_task_create>
   202b4:	20022244 	.word	0x20022244
   202b8:	20022240 	.word	0x20022240

000202bc <z_to_nrf_optname>:
static int z_to_nrf_optname(int z_in_level, int z_in_optname,
			    int *nrf_out_optname)
{
	int retval = 0;

	switch (z_in_level) {
   202bc:	f5b0 7f8d 	cmp.w	r0, #282	; 0x11a
   202c0:	d03c      	beq.n	2033c <z_to_nrf_optname+0x80>
   202c2:	dc04      	bgt.n	202ce <z_to_nrf_optname+0x12>
   202c4:	2801      	cmp	r0, #1
   202c6:	d042      	beq.n	2034e <z_to_nrf_optname+0x92>
			break;
		}
		break;

	default:
		retval = -1;
   202c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		break;
	}

	return retval;
}
   202cc:	4770      	bx	lr
	switch (z_in_level) {
   202ce:	f240 2302 	movw	r3, #514	; 0x202
   202d2:	4298      	cmp	r0, r3
   202d4:	d060      	beq.n	20398 <z_to_nrf_optname+0xdc>
   202d6:	f240 2303 	movw	r3, #515	; 0x203
   202da:	4298      	cmp	r0, r3
   202dc:	d1f4      	bne.n	202c8 <z_to_nrf_optname+0xc>
		switch (z_in_optname) {
   202de:	3901      	subs	r1, #1
   202e0:	2913      	cmp	r1, #19
   202e2:	d8f1      	bhi.n	202c8 <z_to_nrf_optname+0xc>
   202e4:	a301      	add	r3, pc, #4	; (adr r3, 202ec <z_to_nrf_optname+0x30>)
   202e6:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
   202ea:	bf00      	nop
   202ec:	000203a5 	.word	0x000203a5
   202f0:	0002037d 	.word	0x0002037d
   202f4:	00020381 	.word	0x00020381
   202f8:	00020385 	.word	0x00020385
   202fc:	00020389 	.word	0x00020389
   20300:	0002038d 	.word	0x0002038d
   20304:	00020391 	.word	0x00020391
   20308:	000202c9 	.word	0x000202c9
   2030c:	000202c9 	.word	0x000202c9
   20310:	000202c9 	.word	0x000202c9
   20314:	000202c9 	.word	0x000202c9
   20318:	000202c9 	.word	0x000202c9
   2031c:	000202c9 	.word	0x000202c9
   20320:	000202c9 	.word	0x000202c9
   20324:	000202c9 	.word	0x000202c9
   20328:	000202c9 	.word	0x000202c9
   2032c:	000202c9 	.word	0x000202c9
   20330:	000202c9 	.word	0x000202c9
   20334:	000202c9 	.word	0x000202c9
   20338:	00020395 	.word	0x00020395
		switch (z_in_optname) {
   2033c:	3901      	subs	r1, #1
   2033e:	2906      	cmp	r1, #6
   20340:	d8c2      	bhi.n	202c8 <z_to_nrf_optname+0xc>
   20342:	e8df f001 	tbb	[pc, r1]
   20346:	211b      	.short	0x211b
   20348:	2f1f2523 	.word	0x2f1f2523
   2034c:	1d          	.byte	0x1d
   2034d:	00          	.byte	0x00
		switch (z_in_optname) {
   2034e:	2915      	cmp	r1, #21
   20350:	d00d      	beq.n	2036e <z_to_nrf_optname+0xb2>
   20352:	dc07      	bgt.n	20364 <z_to_nrf_optname+0xa8>
   20354:	2904      	cmp	r1, #4
   20356:	d015      	beq.n	20384 <z_to_nrf_optname+0xc8>
   20358:	2914      	cmp	r1, #20
   2035a:	d008      	beq.n	2036e <z_to_nrf_optname+0xb2>
   2035c:	2902      	cmp	r1, #2
   2035e:	d1b3      	bne.n	202c8 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_REUSEADDR;
   20360:	2328      	movs	r3, #40	; 0x28
   20362:	e020      	b.n	203a6 <z_to_nrf_optname+0xea>
   20364:	291e      	cmp	r1, #30
   20366:	d002      	beq.n	2036e <z_to_nrf_optname+0xb2>
   20368:	dc04      	bgt.n	20374 <z_to_nrf_optname+0xb8>
   2036a:	2919      	cmp	r1, #25
   2036c:	d1ac      	bne.n	202c8 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SILENCE_IPV6_ECHO_REPLY;
   2036e:	6011      	str	r1, [r2, #0]
	int retval = 0;
   20370:	2000      	movs	r0, #0
			break;
   20372:	4770      	bx	lr
   20374:	291f      	cmp	r1, #31
   20376:	d0fa      	beq.n	2036e <z_to_nrf_optname+0xb2>
   20378:	2920      	cmp	r1, #32
   2037a:	e7f7      	b.n	2036c <z_to_nrf_optname+0xb0>
			*nrf_out_optname = NRF_SO_DFU_RESOURCES;
   2037c:	2302      	movs	r3, #2
   2037e:	e012      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_TIMEO;
   20380:	2303      	movs	r3, #3
   20382:	e010      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_APPLY;
   20384:	2304      	movs	r3, #4
   20386:	e00e      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_REVERT;
   20388:	2305      	movs	r3, #5
   2038a:	e00c      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_BACKUP_DELETE;
   2038c:	2306      	movs	r3, #6
   2038e:	e00a      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_OFFSET;
   20390:	2307      	movs	r3, #7
   20392:	e008      	b.n	203a6 <z_to_nrf_optname+0xea>
			*nrf_out_optname = NRF_SO_DFU_ERROR;
   20394:	2314      	movs	r3, #20
   20396:	e006      	b.n	203a6 <z_to_nrf_optname+0xea>
		switch (z_in_optname) {
   20398:	2902      	cmp	r1, #2
   2039a:	d0ef      	beq.n	2037c <z_to_nrf_optname+0xc0>
   2039c:	2903      	cmp	r1, #3
   2039e:	d0ef      	beq.n	20380 <z_to_nrf_optname+0xc4>
   203a0:	2901      	cmp	r1, #1
   203a2:	d191      	bne.n	202c8 <z_to_nrf_optname+0xc>
			*nrf_out_optname = NRF_SO_SEC_ROLE;
   203a4:	2301      	movs	r3, #1
			*nrf_out_optname = NRF_SO_DFU_ERROR;
   203a6:	6013      	str	r3, [r2, #0]
   203a8:	e7e2      	b.n	20370 <z_to_nrf_optname+0xb4>
   203aa:	bf00      	nop

000203ac <nrf91_socket_offload_ioctl>:
	return retval;
}

static int nrf91_socket_offload_ioctl(void *obj, unsigned int request,
				      va_list args)
{
   203ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int sd = OBJ_TO_SD(obj);

	switch (request) {
   203b0:	f5a1 7380 	sub.w	r3, r1, #256	; 0x100
{
   203b4:	b093      	sub	sp, #76	; 0x4c
	int sd = OBJ_TO_SD(obj);
   203b6:	3801      	subs	r0, #1
	switch (request) {
   203b8:	2b05      	cmp	r3, #5
   203ba:	d87a      	bhi.n	204b2 <nrf91_socket_offload_ioctl+0x106>
   203bc:	e8df f003 	tbb	[pc, r3]
   203c0:	95797909 	.word	0x95797909
   203c4:	0d03      	.short	0x0d03

	case ZFD_IOCTL_POLL_PREPARE:
		return -EXDEV;

	case ZFD_IOCTL_POLL_UPDATE:
		return -EOPNOTSUPP;
   203c6:	f06f 045e 	mvn.w	r4, #94	; 0x5e
	 * In Zephyr, fcntl() is just an alias of ioctl().
	 */
	default:
		return nrf91_socket_offload_fcntl(sd, request, args);
	}
}
   203ca:	4620      	mov	r0, r4
   203cc:	b013      	add	sp, #76	; 0x4c
   203ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return nrf_close(sd);
   203d2:	f008 fd85 	bl	28ee0 <nrf_close>
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   203d6:	4604      	mov	r4, r0
		break;
   203d8:	e7f7      	b.n	203ca <nrf91_socket_offload_ioctl+0x1e>
	for (int i = 0; i < nfds; i++) {
   203da:	f04f 0800 	mov.w	r8, #0
		nfds = va_arg(args, int);
   203de:	e9d2 a900 	ldrd	sl, r9, [r2]
		timeout = va_arg(args, int);
   203e2:	6893      	ldr	r3, [r2, #8]
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = { 0 };
   203e4:	2100      	movs	r1, #0
   203e6:	2240      	movs	r2, #64	; 0x40
   203e8:	a802      	add	r0, sp, #8
		timeout = va_arg(args, int);
   203ea:	9301      	str	r3, [sp, #4]
	struct nrf_pollfd tmp[BSD_MAX_SOCKET_COUNT] = { 0 };
   203ec:	4655      	mov	r5, sl
   203ee:	f018 fe2d 	bl	3904c <memset>
   203f2:	4657      	mov	r7, sl
	int retval = 0;
   203f4:	4644      	mov	r4, r8
		tmp[i].events = 0;
   203f6:	46c3      	mov	fp, r8
   203f8:	ae02      	add	r6, sp, #8
	for (int i = 0; i < nfds; i++) {
   203fa:	45c1      	cmp	r9, r8
   203fc:	dc33      	bgt.n	20466 <nrf91_socket_offload_ioctl+0xba>
	if (retval > 0) {
   203fe:	2c00      	cmp	r4, #0
   20400:	dce3      	bgt.n	203ca <nrf91_socket_offload_ioctl+0x1e>
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   20402:	9a01      	ldr	r2, [sp, #4]
   20404:	4649      	mov	r1, r9
   20406:	a802      	add	r0, sp, #8
   20408:	f008 fe36 	bl	29078 <nrf_poll>
	for (int i = 0; i < nfds; i++) {
   2040c:	2300      	movs	r3, #0
	retval = nrf_poll((struct nrf_pollfd *)&tmp, nfds, timeout);
   2040e:	4604      	mov	r4, r0
	for (int i = 0; i < nfds; i++) {
   20410:	4599      	cmp	r9, r3
   20412:	ddda      	ble.n	203ca <nrf91_socket_offload_ioctl+0x1e>
		if (fds[i].fd < 0) {
   20414:	f85a 2033 	ldr.w	r2, [sl, r3, lsl #3]
   20418:	2a00      	cmp	r2, #0
   2041a:	db21      	blt.n	20460 <nrf91_socket_offload_ioctl+0xb4>
		if (tmp[i].revents & NRF_POLLIN) {
   2041c:	aa02      	add	r2, sp, #8
   2041e:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
   20422:	88d2      	ldrh	r2, [r2, #6]
   20424:	07d7      	lsls	r7, r2, #31
			fds[i].revents |= POLLIN;
   20426:	bf42      	ittt	mi
   20428:	88e9      	ldrhmi	r1, [r5, #6]
   2042a:	f041 0101 	orrmi.w	r1, r1, #1
   2042e:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLOUT) {
   20430:	0796      	lsls	r6, r2, #30
			fds[i].revents |= POLLOUT;
   20432:	bf42      	ittt	mi
   20434:	88e9      	ldrhmi	r1, [r5, #6]
   20436:	f041 0104 	orrmi.w	r1, r1, #4
   2043a:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLERR) {
   2043c:	0750      	lsls	r0, r2, #29
			fds[i].revents |= POLLERR;
   2043e:	bf42      	ittt	mi
   20440:	88e9      	ldrhmi	r1, [r5, #6]
   20442:	f041 0108 	orrmi.w	r1, r1, #8
   20446:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLNVAL) {
   20448:	06d1      	lsls	r1, r2, #27
			fds[i].revents |= POLLNVAL;
   2044a:	bf42      	ittt	mi
   2044c:	88e9      	ldrhmi	r1, [r5, #6]
   2044e:	f041 0120 	orrmi.w	r1, r1, #32
   20452:	80e9      	strhmi	r1, [r5, #6]
		if (tmp[i].revents & NRF_POLLHUP) {
   20454:	0712      	lsls	r2, r2, #28
			fds[i].revents |= POLLHUP;
   20456:	bf42      	ittt	mi
   20458:	88ea      	ldrhmi	r2, [r5, #6]
   2045a:	f042 0210 	orrmi.w	r2, r2, #16
   2045e:	80ea      	strhmi	r2, [r5, #6]
	for (int i = 0; i < nfds; i++) {
   20460:	3301      	adds	r3, #1
   20462:	3508      	adds	r5, #8
   20464:	e7d4      	b.n	20410 <nrf91_socket_offload_ioctl+0x64>
		if (fds[i].fd < 0) {
   20466:	6838      	ldr	r0, [r7, #0]
		tmp[i].events = 0;
   20468:	f8a6 b004 	strh.w	fp, [r6, #4]
		if (fds[i].fd < 0) {
   2046c:	2800      	cmp	r0, #0
		fds[i].revents = 0;
   2046e:	f8a7 b006 	strh.w	fp, [r7, #6]
		if (fds[i].fd < 0) {
   20472:	da05      	bge.n	20480 <nrf91_socket_offload_ioctl+0xd4>
			tmp[i].fd = fds[i].fd;
   20474:	6030      	str	r0, [r6, #0]
	for (int i = 0; i < nfds; i++) {
   20476:	f108 0801 	add.w	r8, r8, #1
   2047a:	3608      	adds	r6, #8
   2047c:	3708      	adds	r7, #8
   2047e:	e7bc      	b.n	203fa <nrf91_socket_offload_ioctl+0x4e>
			obj = z_get_fd_obj(fds[i].fd,
   20480:	2286      	movs	r2, #134	; 0x86
   20482:	491b      	ldr	r1, [pc, #108]	; (204f0 <nrf91_socket_offload_ioctl+0x144>)
   20484:	f7f8 fa0c 	bl	188a0 <z_get_fd_obj>
			if (obj != NULL) {
   20488:	b178      	cbz	r0, 204aa <nrf91_socket_offload_ioctl+0xfe>
				tmp[i].fd = OBJ_TO_SD(obj);
   2048a:	3801      	subs	r0, #1
   2048c:	6030      	str	r0, [r6, #0]
		if (fds[i].events & POLLIN) {
   2048e:	88b9      	ldrh	r1, [r7, #4]
   20490:	07ca      	lsls	r2, r1, #31
			tmp[i].events |= NRF_POLLIN;
   20492:	bf42      	ittt	mi
   20494:	88b2      	ldrhmi	r2, [r6, #4]
   20496:	f042 0201 	orrmi.w	r2, r2, #1
   2049a:	80b2      	strhmi	r2, [r6, #4]
		if (fds[i].events & POLLOUT) {
   2049c:	074b      	lsls	r3, r1, #29
			tmp[i].events |= NRF_POLLOUT;
   2049e:	bf42      	ittt	mi
   204a0:	88b2      	ldrhmi	r2, [r6, #4]
   204a2:	f042 0202 	orrmi.w	r2, r2, #2
   204a6:	80b2      	strhmi	r2, [r6, #4]
   204a8:	e7e5      	b.n	20476 <nrf91_socket_offload_ioctl+0xca>
				fds[i].revents = POLLNVAL;
   204aa:	2220      	movs	r2, #32
				retval++;
   204ac:	3401      	adds	r4, #1
				fds[i].revents = POLLNVAL;
   204ae:	80fa      	strh	r2, [r7, #6]
				retval++;
   204b0:	e7ed      	b.n	2048e <nrf91_socket_offload_ioctl+0xe2>
	switch (cmd) {
   204b2:	2903      	cmp	r1, #3
   204b4:	d00a      	beq.n	204cc <nrf91_socket_offload_ioctl+0x120>
   204b6:	2904      	cmp	r1, #4
   204b8:	d110      	bne.n	204dc <nrf91_socket_offload_ioctl+0x130>
		flags = va_arg(args, int);
   204ba:	6812      	ldr	r2, [r2, #0]
		if (flags != 0 && flags != O_NONBLOCK)
   204bc:	f432 4380 	bics.w	r3, r2, #16384	; 0x4000
   204c0:	d10c      	bne.n	204dc <nrf91_socket_offload_ioctl+0x130>
		retval = nrf_fcntl(fd, NRF_F_SETFL, flags);
   204c2:	1392      	asrs	r2, r2, #14
   204c4:	2101      	movs	r1, #1
   204c6:	f008 fdd9 	bl	2907c <nrf_fcntl>
   204ca:	e784      	b.n	203d6 <nrf91_socket_offload_ioctl+0x2a>
		flags = nrf_fcntl(fd, NRF_F_GETFL, 0);
   204cc:	2200      	movs	r2, #0
   204ce:	2102      	movs	r1, #2
   204d0:	f008 fdd4 	bl	2907c <nrf_fcntl>
		retval = (flags & NRF_O_NONBLOCK) ? O_NONBLOCK : 0;
   204d4:	0380      	lsls	r0, r0, #14
   204d6:	f400 4480 	and.w	r4, r0, #16384	; 0x4000
		break;
   204da:	e776      	b.n	203ca <nrf91_socket_offload_ioctl+0x1e>
	errno = EINVAL;
   204dc:	f015 f804 	bl	354e8 <__errno>
   204e0:	2316      	movs	r3, #22
	return retval;
   204e2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
	errno = EINVAL;
   204e6:	6003      	str	r3, [r0, #0]
		return nrf91_socket_offload_fcntl(sd, request, args);
   204e8:	e76f      	b.n	203ca <nrf91_socket_offload_ioctl+0x1e>
		return -EXDEV;
   204ea:	f06f 0411 	mvn.w	r4, #17
   204ee:	e76c      	b.n	203ca <nrf91_socket_offload_ioctl+0x1e>
   204f0:	0003a720 	.word	0x0003a720

000204f4 <nrf91_socket_iface_init>:

static void nrf91_socket_iface_init(struct net_if *iface)
{
	nrf91_socket_iface_data.iface = iface;

	iface->if_dev->offloaded = true;
   204f4:	2201      	movs	r2, #1
	nrf91_socket_iface_data.iface = iface;
   204f6:	4b03      	ldr	r3, [pc, #12]	; (20504 <nrf91_socket_iface_init+0x10>)
   204f8:	6018      	str	r0, [r3, #0]
	iface->if_dev->offloaded = true;
   204fa:	6803      	ldr	r3, [r0, #0]

	socket_offload_dns_register(&nrf91_socket_dns_offload_ops);
   204fc:	4802      	ldr	r0, [pc, #8]	; (20508 <nrf91_socket_iface_init+0x14>)
	iface->if_dev->offloaded = true;
   204fe:	769a      	strb	r2, [r3, #26]
	socket_offload_dns_register(&nrf91_socket_dns_offload_ops);
   20500:	f7f9 bb32 	b.w	19b68 <socket_offload_dns_register>
   20504:	2002229c 	.word	0x2002229c
   20508:	0003a718 	.word	0x0003a718

0002050c <nrf91_socket_offload_accept>:
{
   2050c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20510:	b08a      	sub	sp, #40	; 0x28
   20512:	4605      	mov	r5, r0
   20514:	460c      	mov	r4, r1
   20516:	4616      	mov	r6, r2
	int fd = z_reserve_fd();
   20518:	f7f8 f9f0 	bl	188fc <z_reserve_fd>
	if (fd < 0) {
   2051c:	1e07      	subs	r7, r0, #0
	int sd = OBJ_TO_SD(obj);
   2051e:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
	if (fd < 0) {
   20522:	da05      	bge.n	20530 <nrf91_socket_offload_accept+0x24>
	return -1;
   20524:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
}
   20528:	4638      	mov	r0, r7
   2052a:	b00a      	add	sp, #40	; 0x28
   2052c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if ((addr != NULL) && (addrlen != NULL)) {
   20530:	b324      	cbz	r4, 2057c <nrf91_socket_offload_accept+0x70>
   20532:	b336      	cbz	r6, 20582 <nrf91_socket_offload_accept+0x76>
		if (*addrlen == sizeof(struct sockaddr_in)) {
   20534:	6832      	ldr	r2, [r6, #0]
		nrf_addr_ptr = (struct nrf_sockaddr *)&nrf_addr;
   20536:	ad01      	add	r5, sp, #4
		if (*addrlen == sizeof(struct sockaddr_in)) {
   20538:	2a08      	cmp	r2, #8
			nrf_addrlen = sizeof(struct nrf_sockaddr_in);
   2053a:	bf0c      	ite	eq
   2053c:	2210      	moveq	r2, #16
			nrf_addrlen = sizeof(struct nrf_sockaddr_in6);
   2053e:	2224      	movne	r2, #36	; 0x24
   20540:	9200      	str	r2, [sp, #0]
		nrf_addrlen_ptr = &nrf_addrlen;
   20542:	466a      	mov	r2, sp
	new_sd = nrf_accept(sd, nrf_addr_ptr, nrf_addrlen_ptr);
   20544:	4629      	mov	r1, r5
   20546:	4618      	mov	r0, r3
   20548:	f008 fd32 	bl	28fb0 <nrf_accept>
	if (new_sd < 0) {
   2054c:	f1b0 0800 	subs.w	r8, r0, #0
   20550:	dbe8      	blt.n	20524 <nrf91_socket_offload_accept+0x18>
	if ((addr != NULL) && (addrlen != NULL)) {
   20552:	b164      	cbz	r4, 2056e <nrf91_socket_offload_accept+0x62>
   20554:	b15e      	cbz	r6, 2056e <nrf91_socket_offload_accept+0x62>
		if (nrf_addr_ptr->sa_family == NRF_AF_INET) {
   20556:	686b      	ldr	r3, [r5, #4]
   20558:	2b02      	cmp	r3, #2
   2055a:	d115      	bne.n	20588 <nrf91_socket_offload_accept+0x7c>
			*addrlen = sizeof(struct sockaddr_in);
   2055c:	2308      	movs	r3, #8
   2055e:	6033      	str	r3, [r6, #0]
	ptr->sin_port = nrf_in->sin_port;
   20560:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   20564:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   20566:	2301      	movs	r3, #1
   20568:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   2056a:	9b04      	ldr	r3, [sp, #16]
   2056c:	6063      	str	r3, [r4, #4]
	z_finalize_fd(fd, SD_TO_OBJ(new_sd),
   2056e:	4a0d      	ldr	r2, [pc, #52]	; (205a4 <nrf91_socket_offload_accept+0x98>)
   20570:	f108 0101 	add.w	r1, r8, #1
   20574:	4638      	mov	r0, r7
   20576:	f7f8 f9e3 	bl	18940 <z_finalize_fd>
	return fd;
   2057a:	e7d5      	b.n	20528 <nrf91_socket_offload_accept+0x1c>
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   2057c:	4622      	mov	r2, r4
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   2057e:	4625      	mov	r5, r4
   20580:	e7e0      	b.n	20544 <nrf91_socket_offload_accept+0x38>
	nrf_socklen_t *nrf_addrlen_ptr = NULL;
   20582:	4632      	mov	r2, r6
	struct nrf_sockaddr *nrf_addr_ptr = NULL;
   20584:	4635      	mov	r5, r6
   20586:	e7dd      	b.n	20544 <nrf91_socket_offload_accept+0x38>
		} else if (nrf_addr_ptr->sa_family == NRF_AF_INET6) {
   20588:	2b0a      	cmp	r3, #10
   2058a:	d106      	bne.n	2059a <nrf91_socket_offload_accept+0x8e>
			*addrlen = sizeof(struct sockaddr_in6);
   2058c:	2318      	movs	r3, #24
			nrf_to_z_ipv6(
   2058e:	a901      	add	r1, sp, #4
			*addrlen = sizeof(struct sockaddr_in6);
   20590:	6033      	str	r3, [r6, #0]
			nrf_to_z_ipv6(
   20592:	4620      	mov	r0, r4
   20594:	f017 fed8 	bl	38348 <nrf_to_z_ipv6>
   20598:	e7e9      	b.n	2056e <nrf91_socket_offload_accept+0x62>
	z_free_fd(fd);
   2059a:	4638      	mov	r0, r7
   2059c:	f7f8 f9da 	bl	18954 <z_free_fd>
   205a0:	e7c0      	b.n	20524 <nrf91_socket_offload_accept+0x18>
   205a2:	bf00      	nop
   205a4:	0003a720 	.word	0x0003a720

000205a8 <nrf91_socket_offload_sendmsg>:
{
   205a8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   205ac:	4607      	mov	r7, r0
   205ae:	4690      	mov	r8, r2
	if (msg == NULL) {
   205b0:	460c      	mov	r4, r1
   205b2:	b309      	cbz	r1, 205f8 <nrf91_socket_offload_sendmsg+0x50>
	for (i = 0; i < msg->msg_iovlen; i++) {
   205b4:	2300      	movs	r3, #0
	ssize_t len = 0;
   205b6:	461a      	mov	r2, r3
   205b8:	68c8      	ldr	r0, [r1, #12]
	for (i = 0; i < msg->msg_iovlen; i++) {
   205ba:	4298      	cmp	r0, r3
   205bc:	d126      	bne.n	2060c <nrf91_socket_offload_sendmsg+0x64>
	if (len <= sizeof(buf)) {
   205be:	2a80      	cmp	r2, #128	; 0x80
   205c0:	d855      	bhi.n	2066e <nrf91_socket_offload_sendmsg+0xc6>
		for (i = 0; i < msg->msg_iovlen; i++) {
   205c2:	2500      	movs	r5, #0
	return z_impl_k_mutex_lock(mutex, timeout);
   205c4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   205c8:	482a      	ldr	r0, [pc, #168]	; (20674 <nrf91_socket_offload_sendmsg+0xcc>)
   205ca:	f00c f81f 	bl	2c60c <z_impl_k_mutex_lock>
		len = 0;
   205ce:	462e      	mov	r6, r5
			memcpy(buf + len, msg->msg_iov[i].iov_base,
   205d0:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 20678 <nrf91_socket_offload_sendmsg+0xd0>
		for (i = 0; i < msg->msg_iovlen; i++) {
   205d4:	68e3      	ldr	r3, [r4, #12]
   205d6:	42ab      	cmp	r3, r5
   205d8:	d81f      	bhi.n	2061a <nrf91_socket_offload_sendmsg+0x72>
		ret = nrf91_socket_offload_sendto(obj, buf, len,
   205da:	6863      	ldr	r3, [r4, #4]
   205dc:	4632      	mov	r2, r6
   205de:	9301      	str	r3, [sp, #4]
   205e0:	6823      	ldr	r3, [r4, #0]
   205e2:	4925      	ldr	r1, [pc, #148]	; (20678 <nrf91_socket_offload_sendmsg+0xd0>)
   205e4:	9300      	str	r3, [sp, #0]
   205e6:	4638      	mov	r0, r7
   205e8:	4643      	mov	r3, r8
   205ea:	f018 f800 	bl	385ee <nrf91_socket_offload_sendto>
   205ee:	4606      	mov	r6, r0
	return z_impl_k_mutex_unlock(mutex);
   205f0:	4820      	ldr	r0, [pc, #128]	; (20674 <nrf91_socket_offload_sendmsg+0xcc>)
   205f2:	f00c f8e9 	bl	2c7c8 <z_impl_k_mutex_unlock>
		return ret;
   205f6:	e005      	b.n	20604 <nrf91_socket_offload_sendmsg+0x5c>
		errno = EINVAL;
   205f8:	f014 ff76 	bl	354e8 <__errno>
   205fc:	2316      	movs	r3, #22
		return -1;
   205fe:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
		errno = EINVAL;
   20602:	6003      	str	r3, [r0, #0]
}
   20604:	4630      	mov	r0, r6
   20606:	b002      	add	sp, #8
   20608:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		len += msg->msg_iov[i].iov_len;
   2060c:	68a1      	ldr	r1, [r4, #8]
   2060e:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
   20612:	6849      	ldr	r1, [r1, #4]
	for (i = 0; i < msg->msg_iovlen; i++) {
   20614:	3301      	adds	r3, #1
		len += msg->msg_iov[i].iov_len;
   20616:	440a      	add	r2, r1
   20618:	e7cf      	b.n	205ba <nrf91_socket_offload_sendmsg+0x12>
			memcpy(buf + len, msg->msg_iov[i].iov_base,
   2061a:	68a3      	ldr	r3, [r4, #8]
   2061c:	ea4f 09c5 	mov.w	r9, r5, lsl #3
   20620:	eb03 0209 	add.w	r2, r3, r9
   20624:	f853 1035 	ldr.w	r1, [r3, r5, lsl #3]
   20628:	eb0a 0006 	add.w	r0, sl, r6
   2062c:	6852      	ldr	r2, [r2, #4]
   2062e:	f018 fcd3 	bl	38fd8 <memcpy>
			len += msg->msg_iov[i].iov_len;
   20632:	68a3      	ldr	r3, [r4, #8]
		for (i = 0; i < msg->msg_iovlen; i++) {
   20634:	3501      	adds	r5, #1
			len += msg->msg_iov[i].iov_len;
   20636:	444b      	add	r3, r9
   20638:	685b      	ldr	r3, [r3, #4]
   2063a:	441e      	add	r6, r3
   2063c:	e7ca      	b.n	205d4 <nrf91_socket_offload_sendmsg+0x2c>
		if (msg->msg_iov[i].iov_len == 0) {
   2063e:	68a1      	ldr	r1, [r4, #8]
   20640:	eb01 03c5 	add.w	r3, r1, r5, lsl #3
   20644:	685a      	ldr	r2, [r3, #4]
   20646:	b162      	cbz	r2, 20662 <nrf91_socket_offload_sendmsg+0xba>
		ret = nrf91_socket_offload_sendto(obj, msg->msg_iov[i].iov_base,
   20648:	6863      	ldr	r3, [r4, #4]
   2064a:	4638      	mov	r0, r7
   2064c:	9301      	str	r3, [sp, #4]
   2064e:	6823      	ldr	r3, [r4, #0]
   20650:	9300      	str	r3, [sp, #0]
   20652:	f851 1035 	ldr.w	r1, [r1, r5, lsl #3]
   20656:	4643      	mov	r3, r8
   20658:	f017 ffc9 	bl	385ee <nrf91_socket_offload_sendto>
		if (ret < 0) {
   2065c:	1e06      	subs	r6, r0, #0
   2065e:	dbd1      	blt.n	20604 <nrf91_socket_offload_sendmsg+0x5c>
		len += ret;
   20660:	44b1      	add	r9, r6
	for (i = 0; i < msg->msg_iovlen; i++) {
   20662:	3501      	adds	r5, #1
   20664:	68e3      	ldr	r3, [r4, #12]
   20666:	429d      	cmp	r5, r3
   20668:	d3e9      	bcc.n	2063e <nrf91_socket_offload_sendmsg+0x96>
   2066a:	464e      	mov	r6, r9
   2066c:	e7ca      	b.n	20604 <nrf91_socket_offload_sendmsg+0x5c>
   2066e:	2500      	movs	r5, #0
	len = 0;
   20670:	46a9      	mov	r9, r5
   20672:	e7f7      	b.n	20664 <nrf91_socket_offload_sendmsg+0xbc>
   20674:	2002075c 	.word	0x2002075c
   20678:	20027ffa 	.word	0x20027ffa

0002067c <nrf91_socket_create>:
{
   2067c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2067e:	4606      	mov	r6, r0
   20680:	460d      	mov	r5, r1
   20682:	4617      	mov	r7, r2
	int fd = z_reserve_fd();
   20684:	f7f8 f93a 	bl	188fc <z_reserve_fd>
	if (fd < 0) {
   20688:	1e04      	subs	r4, r0, #0
   2068a:	db0d      	blt.n	206a8 <nrf91_socket_create+0x2c>
	family = z_to_nrf_family(family);
   2068c:	b2b0      	uxth	r0, r6
   2068e:	f017 fd84 	bl	3819a <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   20692:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
	family = z_to_nrf_family(family);
   20696:	4606      	mov	r6, r0
	if (family == -EAFNOSUPPORT) {
   20698:	d109      	bne.n	206ae <nrf91_socket_create+0x32>
		errno = EAFNOSUPPORT;
   2069a:	f014 ff25 	bl	354e8 <__errno>
   2069e:	236a      	movs	r3, #106	; 0x6a
		errno = EPROTONOSUPPORT;
   206a0:	6003      	str	r3, [r0, #0]
		z_free_fd(fd);
   206a2:	4620      	mov	r0, r4
   206a4:	f7f8 f956 	bl	18954 <z_free_fd>
		return -1;
   206a8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   206ac:	e01b      	b.n	206e6 <nrf91_socket_create+0x6a>
	switch (socktype) {
   206ae:	2d03      	cmp	r5, #3
   206b0:	d003      	beq.n	206ba <nrf91_socket_create+0x3e>
		return NRF_SOCK_MGMT;
   206b2:	2d04      	cmp	r5, #4
   206b4:	bf08      	it	eq
   206b6:	f44f 7500 	moveq.w	r5, #512	; 0x200
	proto = z_to_nrf_protocol(proto);
   206ba:	4638      	mov	r0, r7
   206bc:	f017 fd85 	bl	381ca <z_to_nrf_protocol>
	if (proto == -EPROTONOSUPPORT) {
   206c0:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	proto = z_to_nrf_protocol(proto);
   206c4:	4602      	mov	r2, r0
	if (proto == -EPROTONOSUPPORT) {
   206c6:	d103      	bne.n	206d0 <nrf91_socket_create+0x54>
		errno = EPROTONOSUPPORT;
   206c8:	f014 ff0e 	bl	354e8 <__errno>
   206cc:	237b      	movs	r3, #123	; 0x7b
   206ce:	e7e7      	b.n	206a0 <nrf91_socket_create+0x24>
	retval = nrf_socket(family, type, proto);
   206d0:	4629      	mov	r1, r5
   206d2:	4630      	mov	r0, r6
   206d4:	f008 fbf2 	bl	28ebc <nrf_socket>
	if (sd < 0) {
   206d8:	1e01      	subs	r1, r0, #0
   206da:	dbe2      	blt.n	206a2 <nrf91_socket_create+0x26>
	z_finalize_fd(fd, SD_TO_OBJ(sd),
   206dc:	4a03      	ldr	r2, [pc, #12]	; (206ec <nrf91_socket_create+0x70>)
   206de:	3101      	adds	r1, #1
   206e0:	4620      	mov	r0, r4
   206e2:	f7f8 f92d 	bl	18940 <z_finalize_fd>
}
   206e6:	4620      	mov	r0, r4
   206e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   206ea:	bf00      	nop
   206ec:	0003a720 	.word	0x0003a720

000206f0 <callback_worker>:

	return new_len;
}

static void callback_worker(struct k_work *item)
{
   206f0:	b507      	push	{r0, r1, r2, lr}
	struct callback_work_item *data =
   206f2:	9001      	str	r0, [sp, #4]
		CONTAINER_OF(item, struct callback_work_item, work);

	if (data != NULL) {
   206f4:	b118      	cbz	r0, 206fe <callback_worker+0xe>
		data->callback(data->data);
   206f6:	f8d0 3a98 	ldr.w	r3, [r0, #2712]	; 0xa98
   206fa:	300c      	adds	r0, #12
   206fc:	4798      	blx	r3
	}

	k_mem_slab_free(&rsp_work_items, (void **)&data);
   206fe:	a901      	add	r1, sp, #4
   20700:	4802      	ldr	r0, [pc, #8]	; (2070c <callback_worker+0x1c>)
   20702:	f00b fd8b 	bl	2c21c <k_mem_slab_free>
}
   20706:	b003      	add	sp, #12
   20708:	f85d fb04 	ldr.w	pc, [sp], #4
   2070c:	200206a0 	.word	0x200206a0

00020710 <open_socket>:
{
   20710:	b508      	push	{r3, lr}
	return z_impl_zsock_socket(family, type, proto);
   20712:	f240 2201 	movw	r2, #513	; 0x201
   20716:	2102      	movs	r1, #2
   20718:	2066      	movs	r0, #102	; 0x66
   2071a:	f7f8 fe73 	bl	19404 <z_impl_zsock_socket>
	common_socket_fd = socket(AF_LTE, SOCK_DGRAM, NPROTO_AT);
   2071e:	4b05      	ldr	r3, [pc, #20]	; (20734 <open_socket+0x24>)
   20720:	6018      	str	r0, [r3, #0]
	if (common_socket_fd == -1) {
   20722:	3001      	adds	r0, #1
   20724:	d104      	bne.n	20730 <open_socket+0x20>
		return -errno;
   20726:	f014 fedf 	bl	354e8 <__errno>
   2072a:	6800      	ldr	r0, [r0, #0]
   2072c:	4240      	negs	r0, r0
}
   2072e:	bd08      	pop	{r3, pc}
	return 0;
   20730:	2000      	movs	r0, #0
   20732:	e7fc      	b.n	2072e <open_socket+0x1e>
   20734:	200222a0 	.word	0x200222a0

00020738 <at_write>:
		}
	}
}

static inline int at_write(const char *const cmd, enum at_cmd_state *state)
{
   20738:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   2073a:	4605      	mov	r5, r0
   2073c:	460c      	mov	r4, r1
	int bytes_sent;
	int bytes_to_send = strlen(cmd);
   2073e:	f7f1 fc9f 	bl	12080 <strlen>
	struct return_state_object ret;

	LOG_DBG("Sending command %s", log_strdup(cmd));

	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   20742:	4b23      	ldr	r3, [pc, #140]	; (207d0 <at_write+0x98>)
	int bytes_to_send = strlen(cmd);
   20744:	4606      	mov	r6, r0
	bytes_sent = send(common_socket_fd, cmd, bytes_to_send, 0);
   20746:	6818      	ldr	r0, [r3, #0]
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   20748:	2300      	movs	r3, #0
   2074a:	4629      	mov	r1, r5
   2074c:	e9cd 3300 	strd	r3, r3, [sp]
   20750:	4632      	mov	r2, r6
   20752:	f013 fb9d 	bl	33e90 <z_impl_zsock_sendto>

	if (bytes_sent == -1) {
   20756:	1c43      	adds	r3, r0, #1
   20758:	4605      	mov	r5, r0
   2075a:	d120      	bne.n	2079e <at_write+0x66>
		LOG_ERR("Failed to send AT command (err:%d)", errno);
   2075c:	2301      	movs	r3, #1
   2075e:	f04f 0500 	mov.w	r5, #0
   20762:	4a1c      	ldr	r2, [pc, #112]	; (207d4 <at_write+0x9c>)
   20764:	f363 0507 	bfi	r5, r3, #0, #8
   20768:	4b1b      	ldr	r3, [pc, #108]	; (207d8 <at_write+0xa0>)
   2076a:	1a9b      	subs	r3, r3, r2
   2076c:	08db      	lsrs	r3, r3, #3
   2076e:	f363 158f 	bfi	r5, r3, #6, #10
   20772:	f014 feb9 	bl	354e8 <__errno>
   20776:	4919      	ldr	r1, [pc, #100]	; (207dc <at_write+0xa4>)
   20778:	6802      	ldr	r2, [r0, #0]
   2077a:	4628      	mov	r0, r5
   2077c:	f013 fa3c 	bl	33bf8 <log_string_sync>
		ret.code  = -errno;
   20780:	f014 feb2 	bl	354e8 <__errno>
   20784:	6803      	ldr	r3, [r0, #0]
   20786:	425b      	negs	r3, r3
   20788:	9302      	str	r3, [sp, #8]
		ret.state = AT_CMD_ERROR;
   2078a:	2301      	movs	r3, #1
   2078c:	f88d 300c 	strb.w	r3, [sp, #12]
				"same as expected (%d)",
				bytes_sent, bytes_to_send);
		}
	}

	if (state) {
   20790:	b114      	cbz	r4, 20798 <at_write+0x60>
		*state = ret.state;
   20792:	f89d 300c 	ldrb.w	r3, [sp, #12]
   20796:	7023      	strb	r3, [r4, #0]
	}

	return ret.code;
}
   20798:	9802      	ldr	r0, [sp, #8]
   2079a:	b004      	add	sp, #16
   2079c:	bd70      	pop	{r4, r5, r6, pc}
	return z_impl_k_msgq_get(msgq, data, timeout);
   2079e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   207a2:	a902      	add	r1, sp, #8
   207a4:	480e      	ldr	r0, [pc, #56]	; (207e0 <at_write+0xa8>)
   207a6:	f00b fe4d 	bl	2c444 <z_impl_k_msgq_get>
		if (bytes_sent != bytes_to_send) {
   207aa:	42ae      	cmp	r6, r5
   207ac:	d0f0      	beq.n	20790 <at_write+0x58>
			LOG_ERR("Bytes sent (%d) was not the "
   207ae:	2301      	movs	r3, #1
   207b0:	f04f 0000 	mov.w	r0, #0
   207b4:	4a07      	ldr	r2, [pc, #28]	; (207d4 <at_write+0x9c>)
   207b6:	f363 0007 	bfi	r0, r3, #0, #8
   207ba:	4b07      	ldr	r3, [pc, #28]	; (207d8 <at_write+0xa0>)
   207bc:	4909      	ldr	r1, [pc, #36]	; (207e4 <at_write+0xac>)
   207be:	1a9b      	subs	r3, r3, r2
   207c0:	08db      	lsrs	r3, r3, #3
   207c2:	f363 108f 	bfi	r0, r3, #6, #10
   207c6:	462a      	mov	r2, r5
   207c8:	4633      	mov	r3, r6
   207ca:	f013 fa15 	bl	33bf8 <log_string_sync>
   207ce:	e7df      	b.n	20790 <at_write+0x58>
   207d0:	200222a0 	.word	0x200222a0
   207d4:	00039f60 	.word	0x00039f60
   207d8:	00039f60 	.word	0x00039f60
   207dc:	0003e2c7 	.word	0x0003e2c7
   207e0:	200207cc 	.word	0x200207cc
   207e4:	0003e2ea 	.word	0x0003e2ea

000207e8 <at_cmd_driver_init>:

	k_sem_give(&cmd_pending);
}

static int at_cmd_driver_init(struct device *dev)
{
   207e8:	b530      	push	{r4, r5, lr}
	static bool initialized;

	if (initialized) {
   207ea:	4d16      	ldr	r5, [pc, #88]	; (20844 <at_cmd_driver_init+0x5c>)
{
   207ec:	b087      	sub	sp, #28
	if (initialized) {
   207ee:	782b      	ldrb	r3, [r5, #0]
   207f0:	bb33      	cbnz	r3, 20840 <at_cmd_driver_init+0x58>

	int err;

	ARG_UNUSED(dev);

	err = open_socket();
   207f2:	f7ff ff8d 	bl	20710 <open_socket>
	if (err) {
   207f6:	4604      	mov	r4, r0
   207f8:	b188      	cbz	r0, 2081e <at_cmd_driver_init+0x36>
		LOG_ERR("Failed to open AT socket (err:%d)", err);
   207fa:	2301      	movs	r3, #1
   207fc:	f04f 0000 	mov.w	r0, #0
   20800:	4a11      	ldr	r2, [pc, #68]	; (20848 <at_cmd_driver_init+0x60>)
   20802:	f363 0007 	bfi	r0, r3, #0, #8
   20806:	4b11      	ldr	r3, [pc, #68]	; (2084c <at_cmd_driver_init+0x64>)
   20808:	4911      	ldr	r1, [pc, #68]	; (20850 <at_cmd_driver_init+0x68>)
   2080a:	1a9b      	subs	r3, r3, r2
   2080c:	08db      	lsrs	r3, r3, #3
   2080e:	f363 108f 	bfi	r0, r3, #6, #10
   20812:	4622      	mov	r2, r4
   20814:	f013 f9f0 	bl	33bf8 <log_string_sync>

	initialized = true;
	LOG_DBG("Common AT socket processing thread created");

	return 0;
}
   20818:	4620      	mov	r0, r4
   2081a:	b007      	add	sp, #28
   2081c:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2081e:	230a      	movs	r3, #10
   20820:	e9cd 0004 	strd	r0, r0, [sp, #16]
   20824:	e9cd 0302 	strd	r0, r3, [sp, #8]
   20828:	e9cd 0000 	strd	r0, r0, [sp]
   2082c:	4b09      	ldr	r3, [pc, #36]	; (20854 <at_cmd_driver_init+0x6c>)
   2082e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   20832:	4909      	ldr	r1, [pc, #36]	; (20858 <at_cmd_driver_init+0x70>)
   20834:	4809      	ldr	r0, [pc, #36]	; (2085c <at_cmd_driver_init+0x74>)
   20836:	f00d fd75 	bl	2e324 <z_impl_k_thread_create>
	initialized = true;
   2083a:	2301      	movs	r3, #1
   2083c:	702b      	strb	r3, [r5, #0]
	return 0;
   2083e:	e7eb      	b.n	20818 <at_cmd_driver_init+0x30>
		return 0;
   20840:	2400      	movs	r4, #0
   20842:	e7e9      	b.n	20818 <at_cmd_driver_init+0x30>
   20844:	2002807a 	.word	0x2002807a
   20848:	00039f60 	.word	0x00039f60
   2084c:	00039f60 	.word	0x00039f60
   20850:	0003e27c 	.word	0x0003e27c
   20854:	00020861 	.word	0x00020861
   20858:	20032098 	.word	0x20032098
   2085c:	200222b4 	.word	0x200222b4

00020860 <socket_thread_fn>:
{
   20860:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
					LOG_ERR("Response buffer not large "
   20864:	4b89      	ldr	r3, [pc, #548]	; (20a8c <socket_thread_fn+0x22c>)
   20866:	4d8a      	ldr	r5, [pc, #552]	; (20a90 <socket_thread_fn+0x230>)
		bytes_read = recv(common_socket_fd, item->data,
   20868:	f8df b244 	ldr.w	fp, [pc, #580]	; 20ab0 <socket_thread_fn+0x250>
					LOG_ERR("Response buffer not large "
   2086c:	1aed      	subs	r5, r5, r3
{
   2086e:	b089      	sub	sp, #36	; 0x24
					LOG_ERR("Response buffer not large "
   20870:	f3c5 05c9 	ubfx	r5, r5, #3, #10
		k_mem_slab_alloc(&rsp_work_items, (void **)&item, K_FOREVER);
   20874:	a905      	add	r1, sp, #20
   20876:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2087a:	4886      	ldr	r0, [pc, #536]	; (20a94 <socket_thread_fn+0x234>)
   2087c:	f00b fc6a 	bl	2c154 <k_mem_slab_alloc>
		ret.code  = 0;
   20880:	2300      	movs	r3, #0
		item->callback = NULL;
   20882:	9905      	ldr	r1, [sp, #20]
		ret.code  = 0;
   20884:	9306      	str	r3, [sp, #24]
		ret.state = AT_CMD_OK;
   20886:	f88d 301c 	strb.w	r3, [sp, #28]
		item->callback = NULL;
   2088a:	f8c1 3a98 	str.w	r3, [r1, #2712]	; 0xa98
		bytes_read = recv(common_socket_fd, item->data,
   2088e:	f8db 0000 	ldr.w	r0, [fp]
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   20892:	f640 228c 	movw	r2, #2700	; 0xa8c
   20896:	e9cd 3300 	strd	r3, r3, [sp]
   2089a:	310c      	adds	r1, #12
   2089c:	f013 fb4a 	bl	33f34 <z_impl_zsock_recvfrom>
		if (bytes_read < 0) {
   208a0:	1e02      	subs	r2, r0, #0
   208a2:	da58      	bge.n	20956 <socket_thread_fn+0xf6>
			LOG_ERR("AT socket recv failed with err %d",
   208a4:	f027 033f 	bic.w	r3, r7, #63	; 0x3f
   208a8:	f043 0301 	orr.w	r3, r3, #1
   208ac:	f363 0707 	bfi	r7, r3, #0, #8
   208b0:	f365 178f 	bfi	r7, r5, #6, #10
   208b4:	4638      	mov	r0, r7
   208b6:	4978      	ldr	r1, [pc, #480]	; (20a98 <socket_thread_fn+0x238>)
   208b8:	f013 f99e 	bl	33bf8 <log_string_sync>
			if ((close(common_socket_fd) == 0) &&
   208bc:	f8db 0000 	ldr.w	r0, [fp]
	return z_impl_zsock_close(sock);
   208c0:	f013 faac 	bl	33e1c <z_impl_zsock_close>
   208c4:	2800      	cmp	r0, #0
   208c6:	d131      	bne.n	2092c <socket_thread_fn+0xcc>
			    (open_socket() == 0)) {
   208c8:	f7ff ff22 	bl	20710 <open_socket>
			if ((close(common_socket_fd) == 0) &&
   208cc:	bb70      	cbnz	r0, 2092c <socket_thread_fn+0xcc>
				LOG_INF("AT socket recovered");
   208ce:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   208d2:	f043 0303 	orr.w	r3, r3, #3
   208d6:	f363 0807 	bfi	r8, r3, #0, #8
   208da:	f365 188f 	bfi	r8, r5, #6, #10
   208de:	496f      	ldr	r1, [pc, #444]	; (20a9c <socket_thread_fn+0x23c>)
   208e0:	4640      	mov	r0, r8
   208e2:	f013 f989 	bl	33bf8 <log_string_sync>
				ret.state = AT_CMD_ERROR;
   208e6:	2301      	movs	r3, #1
   208e8:	f88d 301c 	strb.w	r3, [sp, #28]
				ret.code  = -errno;
   208ec:	f014 fdfc 	bl	354e8 <__errno>
   208f0:	6803      	ldr	r3, [r0, #0]
   208f2:	425b      	negs	r3, r3
			ret.code  = -ENOBUFS;
   208f4:	9306      	str	r3, [sp, #24]
		if (item->callback == NULL) {
   208f6:	9905      	ldr	r1, [sp, #20]
   208f8:	f8d1 3a98 	ldr.w	r3, [r1, #2712]	; 0xa98
   208fc:	2b00      	cmp	r3, #0
   208fe:	f040 8087 	bne.w	20a10 <socket_thread_fn+0x1b0>
			k_mem_slab_free(&rsp_work_items, (void **)&item);
   20902:	a905      	add	r1, sp, #20
   20904:	4863      	ldr	r0, [pc, #396]	; (20a94 <socket_thread_fn+0x234>)
   20906:	f00b fc89 	bl	2c21c <k_mem_slab_free>
	return z_impl_k_sem_count_get(sem);
   2090a:	4b65      	ldr	r3, [pc, #404]	; (20aa0 <socket_thread_fn+0x240>)
		if ((k_sem_count_get(&cmd_pending) == 0) &&
   2090c:	689b      	ldr	r3, [r3, #8]
   2090e:	2b00      	cmp	r3, #0
   20910:	d1b0      	bne.n	20874 <socket_thread_fn+0x14>
   20912:	f89d 201c 	ldrb.w	r2, [sp, #28]
   20916:	2a04      	cmp	r2, #4
   20918:	d0ac      	beq.n	20874 <socket_thread_fn+0x14>
			current_cmd_handler = NULL;
   2091a:	4a62      	ldr	r2, [pc, #392]	; (20aa4 <socket_thread_fn+0x244>)
   2091c:	6013      	str	r3, [r2, #0]
	return z_impl_k_msgq_put(msgq, data, timeout);
   2091e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   20922:	a906      	add	r1, sp, #24
   20924:	4860      	ldr	r0, [pc, #384]	; (20aa8 <socket_thread_fn+0x248>)
   20926:	f00b fcf3 	bl	2c310 <z_impl_k_msgq_put>
   2092a:	e7a3      	b.n	20874 <socket_thread_fn+0x14>
			LOG_ERR("Unrecoverable reception error (err: %d), "
   2092c:	2301      	movs	r3, #1
   2092e:	f04f 0400 	mov.w	r4, #0
   20932:	f363 0407 	bfi	r4, r3, #0, #8
   20936:	f014 fdd7 	bl	354e8 <__errno>
   2093a:	f365 148f 	bfi	r4, r5, #6, #10
   2093e:	6802      	ldr	r2, [r0, #0]
   20940:	495a      	ldr	r1, [pc, #360]	; (20aac <socket_thread_fn+0x24c>)
   20942:	4620      	mov	r0, r4
   20944:	f013 f958 	bl	33bf8 <log_string_sync>
			close(common_socket_fd);
   20948:	4b59      	ldr	r3, [pc, #356]	; (20ab0 <socket_thread_fn+0x250>)
   2094a:	6818      	ldr	r0, [r3, #0]
   2094c:	f013 fa66 	bl	33e1c <z_impl_zsock_close>
}
   20950:	b009      	add	sp, #36	; 0x24
   20952:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (item->data[bytes_read - 1] != '\0') {
   20956:	9e05      	ldr	r6, [sp, #20]
   20958:	4432      	add	r2, r6
   2095a:	7ad2      	ldrb	r2, [r2, #11]
   2095c:	b172      	cbz	r2, 2097c <socket_thread_fn+0x11c>
			LOG_ERR("AT message too large for reception buffer or "
   2095e:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   20962:	f043 0301 	orr.w	r3, r3, #1
   20966:	f363 0907 	bfi	r9, r3, #0, #8
   2096a:	f365 198f 	bfi	r9, r5, #6, #10
   2096e:	4951      	ldr	r1, [pc, #324]	; (20ab4 <socket_thread_fn+0x254>)
   20970:	4648      	mov	r0, r9
   20972:	f013 f941 	bl	33bf8 <log_string_sync>
			ret.code  = -ENOBUFS;
   20976:	f06f 0368 	mvn.w	r3, #104	; 0x68
   2097a:	e7bb      	b.n	208f4 <socket_thread_fn+0x94>
	ret->state = AT_CMD_NOTIFICATION;
   2097c:	2304      	movs	r3, #4
		payload_len = get_return_code(item->data, &ret);
   2097e:	f106 040c 	add.w	r4, r6, #12
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   20982:	494d      	ldr	r1, [pc, #308]	; (20ab8 <socket_thread_fn+0x258>)
   20984:	4620      	mov	r0, r4
	ret->state = AT_CMD_NOTIFICATION;
   20986:	f88d 301c 	strb.w	r3, [sp, #28]
   2098a:	9203      	str	r2, [sp, #12]
		tmpstr = strstr(buf, AT_CMD_OK_STR);
   2098c:	f018 fccc 	bl	39328 <strstr>
		if (tmpstr) {
   20990:	4603      	mov	r3, r0
   20992:	b120      	cbz	r0, 2099e <socket_thread_fn+0x13e>
			ret->state = AT_CMD_OK;
   20994:	9a03      	ldr	r2, [sp, #12]
   20996:	f88d 201c 	strb.w	r2, [sp, #28]
			ret->code  = -ENOEXEC;
   2099a:	9206      	str	r2, [sp, #24]
			break;
   2099c:	e00e      	b.n	209bc <socket_thread_fn+0x15c>
		tmpstr = strstr(buf, AT_CMD_CMS_STR);
   2099e:	4947      	ldr	r1, [pc, #284]	; (20abc <socket_thread_fn+0x25c>)
   209a0:	4620      	mov	r0, r4
   209a2:	f018 fcc1 	bl	39328 <strstr>
		if (tmpstr) {
   209a6:	9003      	str	r0, [sp, #12]
   209a8:	b168      	cbz	r0, 209c6 <socket_thread_fn+0x166>
			ret->state = AT_CMD_ERROR_CMS;
   209aa:	2202      	movs	r2, #2
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   209ac:	f106 0017 	add.w	r0, r6, #23
			ret->state = AT_CMD_ERROR_CME;
   209b0:	f88d 201c 	strb.w	r2, [sp, #28]
			ret->code = atoi(&buf[ARRAY_SIZE(AT_CMD_CMS_STR) - 1]);
   209b4:	f018 faf0 	bl	38f98 <atoi>
   209b8:	9b03      	ldr	r3, [sp, #12]
   209ba:	9006      	str	r0, [sp, #24]
		buf[new_len++] = '\0';
   209bc:	2100      	movs	r1, #0
		new_len = tmpstr - buf;
   209be:	1b1a      	subs	r2, r3, r4
		buf[new_len++] = '\0';
   209c0:	3201      	adds	r2, #1
   209c2:	7019      	strb	r1, [r3, #0]
   209c4:	e04c      	b.n	20a60 <socket_thread_fn+0x200>
		tmpstr = strstr(buf, AT_CMD_CME_STR);
   209c6:	493e      	ldr	r1, [pc, #248]	; (20ac0 <socket_thread_fn+0x260>)
   209c8:	4620      	mov	r0, r4
   209ca:	f018 fcad 	bl	39328 <strstr>
		if (tmpstr) {
   209ce:	9003      	str	r0, [sp, #12]
   209d0:	b108      	cbz	r0, 209d6 <socket_thread_fn+0x176>
			ret->state = AT_CMD_ERROR_CME;
   209d2:	2203      	movs	r2, #3
   209d4:	e7ea      	b.n	209ac <socket_thread_fn+0x14c>
		tmpstr = strstr(buf, AT_CMD_ERROR_STR);
   209d6:	493b      	ldr	r1, [pc, #236]	; (20ac4 <socket_thread_fn+0x264>)
   209d8:	4620      	mov	r0, r4
   209da:	f018 fca5 	bl	39328 <strstr>
		if (tmpstr) {
   209de:	4603      	mov	r3, r0
   209e0:	2800      	cmp	r0, #0
   209e2:	d039      	beq.n	20a58 <socket_thread_fn+0x1f8>
			ret->state = AT_CMD_ERROR;
   209e4:	2201      	movs	r2, #1
   209e6:	f88d 201c 	strb.w	r2, [sp, #28]
			ret->code  = -ENOEXEC;
   209ea:	f06f 0207 	mvn.w	r2, #7
   209ee:	e7d4      	b.n	2099a <socket_thread_fn+0x13a>
					LOG_ERR("Response buffer not large "
   209f0:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   209f4:	f043 0301 	orr.w	r3, r3, #1
   209f8:	f363 0a07 	bfi	sl, r3, #0, #8
   209fc:	f365 1a8f 	bfi	sl, r5, #6, #10
   20a00:	4931      	ldr	r1, [pc, #196]	; (20ac8 <socket_thread_fn+0x268>)
   20a02:	4650      	mov	r0, sl
   20a04:	f013 f8f8 	bl	33bf8 <log_string_sync>
					ret.code  = -EMSGSIZE;
   20a08:	f06f 0379 	mvn.w	r3, #121	; 0x79
   20a0c:	9306      	str	r3, [sp, #24]
   20a0e:	e039      	b.n	20a84 <socket_thread_fn+0x224>
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   20a10:	4b2e      	ldr	r3, [pc, #184]	; (20acc <socket_thread_fn+0x26c>)
   20a12:	2200      	movs	r2, #0
   20a14:	604b      	str	r3, [r1, #4]
   20a16:	460b      	mov	r3, r1
   20a18:	600a      	str	r2, [r1, #0]
   20a1a:	f843 2f08 	str.w	r2, [r3, #8]!
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   20a1e:	e8d3 2fef 	ldaex	r2, [r3]
   20a22:	f042 0001 	orr.w	r0, r2, #1
   20a26:	e8c3 0fe4 	stlex	r4, r0, [r3]
   20a2a:	2c00      	cmp	r4, #0
   20a2c:	d1f7      	bne.n	20a1e <socket_thread_fn+0x1be>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   20a2e:	07d3      	lsls	r3, r2, #31
   20a30:	f53f af6b 	bmi.w	2090a <socket_thread_fn+0xaa>
		k_queue_append(&work_q->queue, work);
   20a34:	4826      	ldr	r0, [pc, #152]	; (20ad0 <socket_thread_fn+0x270>)
   20a36:	f018 f935 	bl	38ca4 <k_queue_append>
   20a3a:	e766      	b.n	2090a <socket_thread_fn+0xaa>
		if (payload_len == 0) {
   20a3c:	2a00      	cmp	r2, #0
   20a3e:	f43f af5a 	beq.w	208f6 <socket_thread_fn+0x96>
			item->callback = notification_handler;
   20a42:	4b24      	ldr	r3, [pc, #144]	; (20ad4 <socket_thread_fn+0x274>)
			item->callback = current_cmd_handler;
   20a44:	681a      	ldr	r2, [r3, #0]
   20a46:	9b05      	ldr	r3, [sp, #20]
   20a48:	f8c3 2a98 	str.w	r2, [r3, #2712]	; 0xa98
   20a4c:	e753      	b.n	208f6 <socket_thread_fn+0x96>
		if (payload_len == 0) {
   20a4e:	2a00      	cmp	r2, #0
   20a50:	f43f af51 	beq.w	208f6 <socket_thread_fn+0x96>
			item->callback = current_cmd_handler;
   20a54:	4b13      	ldr	r3, [pc, #76]	; (20aa4 <socket_thread_fn+0x244>)
   20a56:	e7f5      	b.n	20a44 <socket_thread_fn+0x1e4>
		new_len = strlen(buf) + 1;
   20a58:	4620      	mov	r0, r4
   20a5a:	f7f1 fb11 	bl	12080 <strlen>
   20a5e:	1c42      	adds	r2, r0, #1
		if (ret.state != AT_CMD_NOTIFICATION) {
   20a60:	f89d 301c 	ldrb.w	r3, [sp, #28]
   20a64:	2b04      	cmp	r3, #4
   20a66:	d0e9      	beq.n	20a3c <socket_thread_fn+0x1dc>
			if ((response_buf_len > 0) &&
   20a68:	4c1b      	ldr	r4, [pc, #108]	; (20ad8 <socket_thread_fn+0x278>)
   20a6a:	6823      	ldr	r3, [r4, #0]
   20a6c:	2b00      	cmp	r3, #0
   20a6e:	d0ee      	beq.n	20a4e <socket_thread_fn+0x1ee>
			    (response_buf != NULL)) {
   20a70:	4e1a      	ldr	r6, [pc, #104]	; (20adc <socket_thread_fn+0x27c>)
   20a72:	6830      	ldr	r0, [r6, #0]
			if ((response_buf_len > 0) &&
   20a74:	2800      	cmp	r0, #0
   20a76:	d0ea      	beq.n	20a4e <socket_thread_fn+0x1ee>
				if (response_buf_len >= payload_len) {
   20a78:	4293      	cmp	r3, r2
   20a7a:	d3b9      	bcc.n	209f0 <socket_thread_fn+0x190>
   20a7c:	9905      	ldr	r1, [sp, #20]
   20a7e:	310c      	adds	r1, #12
   20a80:	f018 faaa 	bl	38fd8 <memcpy>
				response_buf_len = 0;
   20a84:	2300      	movs	r3, #0
   20a86:	6023      	str	r3, [r4, #0]
				response_buf     = NULL;
   20a88:	6033      	str	r3, [r6, #0]
				goto next;
   20a8a:	e734      	b.n	208f6 <socket_thread_fn+0x96>
   20a8c:	00039f60 	.word	0x00039f60
   20a90:	00039f60 	.word	0x00039f60
   20a94:	200206a0 	.word	0x200206a0
   20a98:	0003e31c 	.word	0x0003e31c
   20a9c:	0003e33e 	.word	0x0003e33e
   20aa0:	200206ec 	.word	0x200206ec
   20aa4:	200222a4 	.word	0x200222a4
   20aa8:	200207cc 	.word	0x200207cc
   20aac:	0003e352 	.word	0x0003e352
   20ab0:	200222a0 	.word	0x200222a0
   20ab4:	0003e389 	.word	0x0003e389
   20ab8:	0003d811 	.word	0x0003d811
   20abc:	0003e3d4 	.word	0x0003e3d4
   20ac0:	0003e3e0 	.word	0x0003e3e0
   20ac4:	0003e3ec 	.word	0x0003e3ec
   20ac8:	0003e3f2 	.word	0x0003e3f2
   20acc:	000206f1 	.word	0x000206f1
   20ad0:	20027524 	.word	0x20027524
   20ad4:	200222a8 	.word	0x200222a8
   20ad8:	200222b0 	.word	0x200222b0
   20adc:	200222ac 	.word	0x200222ac

00020ae0 <at_cmd_write>:
{
   20ae0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   20ae4:	4605      	mov	r5, r0
   20ae6:	4688      	mov	r8, r1
   20ae8:	4617      	mov	r7, r2
   20aea:	461e      	mov	r6, r3
	return z_impl_k_sem_take(sem, timeout);
   20aec:	4c0a      	ldr	r4, [pc, #40]	; (20b18 <at_cmd_write+0x38>)
   20aee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   20af2:	4620      	mov	r0, r4
   20af4:	f00d fabe 	bl	2e074 <z_impl_k_sem_take>
	response_buf     = buf;
   20af8:	4b08      	ldr	r3, [pc, #32]	; (20b1c <at_cmd_write+0x3c>)
	int return_code = at_write(cmd, state);
   20afa:	4631      	mov	r1, r6
	response_buf     = buf;
   20afc:	f8c3 8000 	str.w	r8, [r3]
	response_buf_len = buf_len;
   20b00:	4b07      	ldr	r3, [pc, #28]	; (20b20 <at_cmd_write+0x40>)
	int return_code = at_write(cmd, state);
   20b02:	4628      	mov	r0, r5
	response_buf_len = buf_len;
   20b04:	601f      	str	r7, [r3, #0]
	int return_code = at_write(cmd, state);
   20b06:	f7ff fe17 	bl	20738 <at_write>
   20b0a:	4605      	mov	r5, r0
	z_impl_k_sem_give(sem);
   20b0c:	4620      	mov	r0, r4
   20b0e:	f00d fa6d 	bl	2dfec <z_impl_k_sem_give>
}
   20b12:	4628      	mov	r0, r5
   20b14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   20b18:	200206ec 	.word	0x200206ec
   20b1c:	200222ac 	.word	0x200222ac
   20b20:	200222b0 	.word	0x200222b0

00020b24 <at_cmd_set_notification_handler>:
{
   20b24:	b538      	push	{r3, r4, r5, lr}
	if (notification_handler != NULL && handler != notification_handler) {
   20b26:	4c0f      	ldr	r4, [pc, #60]	; (20b64 <at_cmd_set_notification_handler+0x40>)
{
   20b28:	4605      	mov	r5, r0
	if (notification_handler != NULL && handler != notification_handler) {
   20b2a:	6822      	ldr	r2, [r4, #0]
   20b2c:	b17a      	cbz	r2, 20b4e <at_cmd_set_notification_handler+0x2a>
   20b2e:	4282      	cmp	r2, r0
   20b30:	d00d      	beq.n	20b4e <at_cmd_set_notification_handler+0x2a>
		LOG_WRN("Forgetting prior notification handler %p",
   20b32:	2302      	movs	r3, #2
   20b34:	f04f 0000 	mov.w	r0, #0
   20b38:	490b      	ldr	r1, [pc, #44]	; (20b68 <at_cmd_set_notification_handler+0x44>)
   20b3a:	f363 0007 	bfi	r0, r3, #0, #8
   20b3e:	4b0b      	ldr	r3, [pc, #44]	; (20b6c <at_cmd_set_notification_handler+0x48>)
   20b40:	1a5b      	subs	r3, r3, r1
   20b42:	08db      	lsrs	r3, r3, #3
   20b44:	f363 108f 	bfi	r0, r3, #6, #10
   20b48:	4909      	ldr	r1, [pc, #36]	; (20b70 <at_cmd_set_notification_handler+0x4c>)
   20b4a:	f013 f855 	bl	33bf8 <log_string_sync>
	return z_impl_k_sem_take(sem, timeout);
   20b4e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   20b52:	4808      	ldr	r0, [pc, #32]	; (20b74 <at_cmd_set_notification_handler+0x50>)
   20b54:	f00d fa8e 	bl	2e074 <z_impl_k_sem_take>
	notification_handler = handler;
   20b58:	6025      	str	r5, [r4, #0]
	z_impl_k_sem_give(sem);
   20b5a:	4806      	ldr	r0, [pc, #24]	; (20b74 <at_cmd_set_notification_handler+0x50>)
}
   20b5c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   20b60:	f00d ba44 	b.w	2dfec <z_impl_k_sem_give>
   20b64:	200222a8 	.word	0x200222a8
   20b68:	00039f60 	.word	0x00039f60
   20b6c:	00039f60 	.word	0x00039f60
   20b70:	0003e29e 	.word	0x0003e29e
   20b74:	200206ec 	.word	0x200206ec

00020b78 <find_node>:
static struct notif_handler *find_node(struct notif_handler **prev_out,
	void *ctx, at_notif_handler_t handler)
{
	struct notif_handler *prev = NULL, *curr, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   20b78:	4b0b      	ldr	r3, [pc, #44]	; (20ba8 <find_node+0x30>)
{
   20b7a:	b570      	push	{r4, r5, r6, lr}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   20b7c:	681b      	ldr	r3, [r3, #0]
   20b7e:	b153      	cbz	r3, 20b96 <find_node+0x1e>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   20b80:	2500      	movs	r5, #0
   20b82:	461c      	mov	r4, r3
   20b84:	681b      	ldr	r3, [r3, #0]
		if (curr->ctx == ctx && curr->handler == handler) {
   20b86:	6866      	ldr	r6, [r4, #4]
   20b88:	428e      	cmp	r6, r1
   20b8a:	d106      	bne.n	20b9a <find_node+0x22>
   20b8c:	68a6      	ldr	r6, [r4, #8]
   20b8e:	4296      	cmp	r6, r2
   20b90:	d103      	bne.n	20b9a <find_node+0x22>
			*prev_out = prev;
			return curr;
   20b92:	4623      	mov	r3, r4
			*prev_out = prev;
   20b94:	6005      	str	r5, [r0, #0]
		}
		prev = curr;
	}
	return NULL;
}
   20b96:	4618      	mov	r0, r3
   20b98:	bd70      	pop	{r4, r5, r6, pc}
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   20b9a:	2b00      	cmp	r3, #0
   20b9c:	d0fb      	beq.n	20b96 <find_node+0x1e>
   20b9e:	4625      	mov	r5, r4
   20ba0:	461c      	mov	r4, r3
   20ba2:	681b      	ldr	r3, [r3, #0]
   20ba4:	e7ef      	b.n	20b86 <find_node+0xe>
   20ba6:	bf00      	nop
   20ba8:	2002236c 	.word	0x2002236c

00020bac <module_init>:
{
	ARG_UNUSED(dev);

	static bool initialized;

	if (initialized) {
   20bac:	4a0e      	ldr	r2, [pc, #56]	; (20be8 <module_init+0x3c>)
{
   20bae:	b508      	push	{r3, lr}
	if (initialized) {
   20bb0:	7813      	ldrb	r3, [r2, #0]
   20bb2:	b17b      	cbz	r3, 20bd4 <module_init+0x28>
		LOG_WRN("Already initialized. Nothing to do");
   20bb4:	2302      	movs	r3, #2
   20bb6:	f04f 0000 	mov.w	r0, #0
   20bba:	4a0c      	ldr	r2, [pc, #48]	; (20bec <module_init+0x40>)
   20bbc:	f363 0007 	bfi	r0, r3, #0, #8
   20bc0:	4b0b      	ldr	r3, [pc, #44]	; (20bf0 <module_init+0x44>)
   20bc2:	490c      	ldr	r1, [pc, #48]	; (20bf4 <module_init+0x48>)
   20bc4:	1a9b      	subs	r3, r3, r2
   20bc6:	08db      	lsrs	r3, r3, #3
   20bc8:	f363 108f 	bfi	r0, r3, #6, #10
   20bcc:	f013 f814 	bl	33bf8 <log_string_sync>

	LOG_DBG("Initialization");
	sys_slist_init(&handler_list);
	at_cmd_set_notification_handler(notif_dispatch);
	return 0;
}
   20bd0:	2000      	movs	r0, #0
   20bd2:	bd08      	pop	{r3, pc}
	initialized = true;
   20bd4:	2101      	movs	r1, #1
   20bd6:	7011      	strb	r1, [r2, #0]
	list->head = NULL;
   20bd8:	4a07      	ldr	r2, [pc, #28]	; (20bf8 <module_init+0x4c>)
	at_cmd_set_notification_handler(notif_dispatch);
   20bda:	4808      	ldr	r0, [pc, #32]	; (20bfc <module_init+0x50>)
	list->tail = NULL;
   20bdc:	e9c2 3300 	strd	r3, r3, [r2]
   20be0:	f7ff ffa0 	bl	20b24 <at_cmd_set_notification_handler>
	return 0;
   20be4:	e7f4      	b.n	20bd0 <module_init+0x24>
   20be6:	bf00      	nop
   20be8:	2002807b 	.word	0x2002807b
   20bec:	00039f60 	.word	0x00039f60
   20bf0:	00039f68 	.word	0x00039f68
   20bf4:	0003e44b 	.word	0x0003e44b
   20bf8:	2002236c 	.word	0x2002236c
   20bfc:	00020c0d 	.word	0x00020c0d

00020c00 <k_mutex_unlock.constprop.7>:
	return z_impl_k_mutex_unlock(mutex);
   20c00:	4801      	ldr	r0, [pc, #4]	; (20c08 <k_mutex_unlock.constprop.7+0x8>)
   20c02:	f00b bde1 	b.w	2c7c8 <z_impl_k_mutex_unlock>
   20c06:	bf00      	nop
   20c08:	20020770 	.word	0x20020770

00020c0c <notif_dispatch>:
{
   20c0c:	b538      	push	{r3, r4, r5, lr}
   20c0e:	4605      	mov	r5, r0
	return z_impl_k_mutex_lock(mutex, timeout);
   20c10:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   20c14:	4809      	ldr	r0, [pc, #36]	; (20c3c <notif_dispatch+0x30>)
   20c16:	f00b fcf9 	bl	2c60c <z_impl_k_mutex_lock>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   20c1a:	4b09      	ldr	r3, [pc, #36]	; (20c40 <notif_dispatch+0x34>)
   20c1c:	681b      	ldr	r3, [r3, #0]
   20c1e:	b91b      	cbnz	r3, 20c28 <notif_dispatch+0x1c>
}
   20c20:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	k_mutex_unlock(&list_mtx);
   20c24:	f7ff bfec 	b.w	20c00 <k_mutex_unlock.constprop.7>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   20c28:	681c      	ldr	r4, [r3, #0]
		curr->handler(curr->ctx, response);
   20c2a:	689a      	ldr	r2, [r3, #8]
   20c2c:	4629      	mov	r1, r5
   20c2e:	6858      	ldr	r0, [r3, #4]
   20c30:	4790      	blx	r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&handler_list, curr, tmp, node) {
   20c32:	2c00      	cmp	r4, #0
   20c34:	d0f4      	beq.n	20c20 <notif_dispatch+0x14>
   20c36:	4623      	mov	r3, r4
   20c38:	6824      	ldr	r4, [r4, #0]
   20c3a:	e7f6      	b.n	20c2a <notif_dispatch+0x1e>
   20c3c:	20020770 	.word	0x20020770
   20c40:	2002236c 	.word	0x2002236c

00020c44 <at_notif_register_handler>:
{
	return module_init(NULL);
}

int at_notif_register_handler(void *context, at_notif_handler_t handler)
{
   20c44:	b573      	push	{r0, r1, r4, r5, r6, lr}
   20c46:	4606      	mov	r6, r0
	if (handler == NULL) {
   20c48:	460d      	mov	r5, r1
   20c4a:	b999      	cbnz	r1, 20c74 <at_notif_register_handler+0x30>
		LOG_ERR("Invalid handler (context=0x%08X, handler=0x%08X)",
   20c4c:	2301      	movs	r3, #1
   20c4e:	f04f 0000 	mov.w	r0, #0
   20c52:	4a1d      	ldr	r2, [pc, #116]	; (20cc8 <at_notif_register_handler+0x84>)
   20c54:	f363 0007 	bfi	r0, r3, #0, #8
   20c58:	4b1c      	ldr	r3, [pc, #112]	; (20ccc <at_notif_register_handler+0x88>)
   20c5a:	1a9b      	subs	r3, r3, r2
   20c5c:	08db      	lsrs	r3, r3, #3
   20c5e:	f363 108f 	bfi	r0, r3, #6, #10
   20c62:	4632      	mov	r2, r6
   20c64:	460b      	mov	r3, r1
   20c66:	491a      	ldr	r1, [pc, #104]	; (20cd0 <at_notif_register_handler+0x8c>)
   20c68:	f012 ffc6 	bl	33bf8 <log_string_sync>
			(u32_t)context, (u32_t)handler);
		return -EINVAL;
   20c6c:	f06f 0015 	mvn.w	r0, #21
	}
	return append_notif_handler(context, handler);
}
   20c70:	b002      	add	sp, #8
   20c72:	bd70      	pop	{r4, r5, r6, pc}
   20c74:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   20c78:	4816      	ldr	r0, [pc, #88]	; (20cd4 <at_notif_register_handler+0x90>)
   20c7a:	f00b fcc7 	bl	2c60c <z_impl_k_mutex_lock>
	if (find_node(&to_ins, ctx, handler) != NULL) {
   20c7e:	462a      	mov	r2, r5
   20c80:	4631      	mov	r1, r6
   20c82:	a801      	add	r0, sp, #4
   20c84:	f7ff ff78 	bl	20b78 <find_node>
   20c88:	4604      	mov	r4, r0
   20c8a:	b118      	cbz	r0, 20c94 <at_notif_register_handler+0x50>
		k_mutex_unlock(&list_mtx);
   20c8c:	f7ff ffb8 	bl	20c00 <k_mutex_unlock.constprop.7>
		return 0;
   20c90:	2000      	movs	r0, #0
   20c92:	e7ed      	b.n	20c70 <at_notif_register_handler+0x2c>
	to_ins = (struct notif_handler *)k_malloc(sizeof(struct notif_handler));
   20c94:	200c      	movs	r0, #12
   20c96:	f00b fb1f 	bl	2c2d8 <k_malloc>
   20c9a:	9001      	str	r0, [sp, #4]
	if (to_ins == NULL) {
   20c9c:	b920      	cbnz	r0, 20ca8 <at_notif_register_handler+0x64>
		k_mutex_unlock(&list_mtx);
   20c9e:	f7ff ffaf 	bl	20c00 <k_mutex_unlock.constprop.7>
		return -ENOBUFS;
   20ca2:	f06f 0068 	mvn.w	r0, #104	; 0x68
   20ca6:	e7e3      	b.n	20c70 <at_notif_register_handler+0x2c>
__ssp_bos_icheck3(memset, void *, int)
   20ca8:	6004      	str	r4, [r0, #0]
	to_ins->ctx     = ctx;
   20caa:	9b01      	ldr	r3, [sp, #4]
Z_GENLIST_APPEND(slist, snode)
   20cac:	4a0a      	ldr	r2, [pc, #40]	; (20cd8 <at_notif_register_handler+0x94>)
   20cae:	6044      	str	r4, [r0, #4]
   20cb0:	6084      	str	r4, [r0, #8]
	parent->next = child;
   20cb2:	601c      	str	r4, [r3, #0]
Z_GENLIST_APPEND(slist, snode)
   20cb4:	6851      	ldr	r1, [r2, #4]
	to_ins->handler = handler;
   20cb6:	e9c3 6501 	strd	r6, r5, [r3, #4]
   20cba:	b911      	cbnz	r1, 20cc2 <at_notif_register_handler+0x7e>
	list->head = node;
   20cbc:	e9c2 3300 	strd	r3, r3, [r2]
   20cc0:	e7e4      	b.n	20c8c <at_notif_register_handler+0x48>
	parent->next = child;
   20cc2:	600b      	str	r3, [r1, #0]
	list->tail = node;
   20cc4:	6053      	str	r3, [r2, #4]
   20cc6:	e7e1      	b.n	20c8c <at_notif_register_handler+0x48>
   20cc8:	00039f60 	.word	0x00039f60
   20ccc:	00039f68 	.word	0x00039f68
   20cd0:	0003e41a 	.word	0x0003e41a
   20cd4:	20020770 	.word	0x20020770
   20cd8:	2002236c 	.word	0x2002236c

00020cdc <is_valid_notification_char>:
 * @retval true  If character is valid
 * @retval false If character is not valid
 */
static inline bool is_valid_notification_char(char chr)
{
	chr = toupper((int)chr);
   20cdc:	4b06      	ldr	r3, [pc, #24]	; (20cf8 <is_valid_notification_char+0x1c>)
   20cde:	5cc3      	ldrb	r3, [r0, r3]
   20ce0:	f003 0303 	and.w	r3, r3, #3
   20ce4:	2b02      	cmp	r3, #2
   20ce6:	bf08      	it	eq
   20ce8:	3820      	subeq	r0, #32

	if ((chr >= 'A') && (chr <= 'Z')) {
   20cea:	3841      	subs	r0, #65	; 0x41
   20cec:	b2c0      	uxtb	r0, r0
		return true;
	}

	return false;
}
   20cee:	2819      	cmp	r0, #25
   20cf0:	bf8c      	ite	hi
   20cf2:	2000      	movhi	r0, #0
   20cf4:	2001      	movls	r0, #1
   20cf6:	4770      	bx	lr
   20cf8:	00040188 	.word	0x00040188

00020cfc <at_parse_process_element>:
	return 0;
}

static int at_parse_process_element(const char **str, int index,
				    struct at_param_list *const list)
{
   20cfc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	const char *tmpstr = *str;
   20d00:	6805      	ldr	r5, [r0, #0]
{
   20d02:	b0a3      	sub	sp, #140	; 0x8c
	const char *tmpstr = *str;
   20d04:	9500      	str	r5, [sp, #0]
 * @retval true  If character is 0
 * @retval false If character is not 0
 */
static inline bool is_terminated(char chr)
{
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   20d06:	782b      	ldrb	r3, [r5, #0]
{
   20d08:	4680      	mov	r8, r0
   20d0a:	460f      	mov	r7, r1
   20d0c:	4616      	mov	r6, r2
   20d0e:	2b00      	cmp	r3, #0
   20d10:	f000 80c8 	beq.w	20ea4 <at_parse_process_element+0x1a8>

	if (is_terminated(*tmpstr)) {
		return -1;
	}

	if (state == NOTIFICATION) {
   20d14:	4b65      	ldr	r3, [pc, #404]	; (20eac <at_parse_process_element+0x1b0>)
   20d16:	781c      	ldrb	r4, [r3, #0]
   20d18:	2c06      	cmp	r4, #6
   20d1a:	d110      	bne.n	20d3e <at_parse_process_element+0x42>
		const char *start_ptr = tmpstr++;
   20d1c:	1c6b      	adds	r3, r5, #1
   20d1e:	9300      	str	r3, [sp, #0]

		while (is_valid_notification_char(*tmpstr)) {
   20d20:	9a00      	ldr	r2, [sp, #0]
   20d22:	7810      	ldrb	r0, [r2, #0]
   20d24:	f7ff ffda 	bl	20cdc <is_valid_notification_char>
   20d28:	b930      	cbnz	r0, 20d38 <at_parse_process_element+0x3c>
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   20d2a:	1b53      	subs	r3, r2, r5

		while (isxdigit((int)*tmpstr)) {
			tmpstr++;
		}

		at_params_string_put(list, index, start_ptr,
   20d2c:	462a      	mov	r2, r5
   20d2e:	4639      	mov	r1, r7
   20d30:	4630      	mov	r0, r6
   20d32:	f017 fdb4 	bl	3889e <at_params_string_put>
   20d36:	e01b      	b.n	20d70 <at_parse_process_element+0x74>
			tmpstr++;
   20d38:	3201      	adds	r2, #1
   20d3a:	9200      	str	r2, [sp, #0]
   20d3c:	e7f0      	b.n	20d20 <at_parse_process_element+0x24>
	} else if (state == COMMAND) {
   20d3e:	2c07      	cmp	r4, #7
   20d40:	d124      	bne.n	20d8c <at_parse_process_element+0x90>
		skip_command_prefix(&tmpstr);
   20d42:	4668      	mov	r0, sp
   20d44:	f017 fd3b 	bl	387be <skip_command_prefix>
		while (is_valid_notification_char(*tmpstr)) {
   20d48:	9a00      	ldr	r2, [sp, #0]
   20d4a:	7810      	ldrb	r0, [r2, #0]
   20d4c:	f7ff ffc6 	bl	20cdc <is_valid_notification_char>
   20d50:	b9a8      	cbnz	r0, 20d7e <at_parse_process_element+0x82>
		at_params_string_put(list, index, start_ptr,
   20d52:	1b53      	subs	r3, r2, r5
   20d54:	4639      	mov	r1, r7
   20d56:	462a      	mov	r2, r5
   20d58:	4630      	mov	r0, r6
   20d5a:	f017 fda0 	bl	3889e <at_params_string_put>
		if ((*tmpstr == AT_CMD_SEPARATOR) &&
   20d5e:	9b00      	ldr	r3, [sp, #0]
   20d60:	781a      	ldrb	r2, [r3, #0]
   20d62:	2a3d      	cmp	r2, #61	; 0x3d
   20d64:	d10e      	bne.n	20d84 <at_parse_process_element+0x88>
   20d66:	785a      	ldrb	r2, [r3, #1]
   20d68:	2a3f      	cmp	r2, #63	; 0x3f
   20d6a:	d101      	bne.n	20d70 <at_parse_process_element+0x74>
			tmpstr += 2;
   20d6c:	3302      	adds	r3, #2
			tmpstr++;
   20d6e:	9300      	str	r3, [sp, #0]
				     tmpstr - start_ptr);
	}

	*str = tmpstr;
	return 0;
   20d70:	2000      	movs	r0, #0
	*str = tmpstr;
   20d72:	9b00      	ldr	r3, [sp, #0]
   20d74:	f8c8 3000 	str.w	r3, [r8]
}
   20d78:	b023      	add	sp, #140	; 0x8c
   20d7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			tmpstr++;
   20d7e:	3201      	adds	r2, #1
   20d80:	9200      	str	r2, [sp, #0]
   20d82:	e7e1      	b.n	20d48 <at_parse_process_element+0x4c>
		} else if (*tmpstr == AT_CMD_READ_TEST_IDENTIFIER) {
   20d84:	2a3f      	cmp	r2, #63	; 0x3f
   20d86:	d1f3      	bne.n	20d70 <at_parse_process_element+0x74>
			tmpstr++;
   20d88:	3301      	adds	r3, #1
   20d8a:	e7f0      	b.n	20d6e <at_parse_process_element+0x72>
	} else if (state == OPTIONAL) {
   20d8c:	2c08      	cmp	r4, #8
   20d8e:	d103      	bne.n	20d98 <at_parse_process_element+0x9c>
		at_params_empty_put(list, index);
   20d90:	4610      	mov	r0, r2
   20d92:	f017 fd5b 	bl	3884c <at_params_empty_put>
   20d96:	e7eb      	b.n	20d70 <at_parse_process_element+0x74>
	} else if (state == STRING) {
   20d98:	2c02      	cmp	r4, #2
   20d9a:	d111      	bne.n	20dc0 <at_parse_process_element+0xc4>
		while (!is_lfcr(*tmpstr) && !is_terminated(*tmpstr)) {
   20d9c:	9a00      	ldr	r2, [sp, #0]
   20d9e:	7811      	ldrb	r1, [r2, #0]
   20da0:	4608      	mov	r0, r1
   20da2:	f017 fd03 	bl	387ac <is_lfcr>
   20da6:	b918      	cbnz	r0, 20db0 <at_parse_process_element+0xb4>
   20da8:	b111      	cbz	r1, 20db0 <at_parse_process_element+0xb4>
			tmpstr++;
   20daa:	3201      	adds	r2, #1
   20dac:	9200      	str	r2, [sp, #0]
   20dae:	e7f5      	b.n	20d9c <at_parse_process_element+0xa0>
		at_params_string_put(list, index, start_ptr,
   20db0:	1b53      	subs	r3, r2, r5
		at_params_string_put(list, index, start_ptr,
   20db2:	462a      	mov	r2, r5
   20db4:	4639      	mov	r1, r7
   20db6:	4630      	mov	r0, r6
   20db8:	f017 fd71 	bl	3889e <at_params_string_put>
		tmpstr++;
   20dbc:	9b00      	ldr	r3, [sp, #0]
   20dbe:	e7e3      	b.n	20d88 <at_parse_process_element+0x8c>
	} else if (state == QUOTED_STRING) {
   20dc0:	2c03      	cmp	r4, #3
   20dc2:	d109      	bne.n	20dd8 <at_parse_process_element+0xdc>
		while (!is_dblquote(*tmpstr) && !is_terminated(*tmpstr)) {
   20dc4:	9b00      	ldr	r3, [sp, #0]
   20dc6:	781a      	ldrb	r2, [r3, #0]
 * @retval true  If character is "
 * @retval false If character is something else
 */
static inline bool is_dblquote(char chr)
{
	if (chr == '"') {
   20dc8:	2a22      	cmp	r2, #34	; 0x22
   20dca:	d003      	beq.n	20dd4 <at_parse_process_element+0xd8>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   20dcc:	b112      	cbz	r2, 20dd4 <at_parse_process_element+0xd8>
			tmpstr++;
   20dce:	3301      	adds	r3, #1
   20dd0:	9300      	str	r3, [sp, #0]
   20dd2:	e7f7      	b.n	20dc4 <at_parse_process_element+0xc8>
		at_params_string_put(list, index, start_ptr,
   20dd4:	1b5b      	subs	r3, r3, r5
   20dd6:	e7ec      	b.n	20db2 <at_parse_process_element+0xb6>
	} else if (state == ARRAY) {
   20dd8:	2c01      	cmp	r4, #1
   20dda:	d13c      	bne.n	20e56 <at_parse_process_element+0x15a>
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   20ddc:	4628      	mov	r0, r5
   20dde:	220a      	movs	r2, #10
   20de0:	a901      	add	r1, sp, #4
   20de2:	f011 fa87 	bl	322f4 <strtoul>
		tmpstr = next;
   20de6:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   20de8:	4d31      	ldr	r5, [pc, #196]	; (20eb0 <at_parse_process_element+0x1b4>)
		tmparray[i++] = (u32_t)strtoul(tmpstr, &next, 10);
   20dea:	9002      	str	r0, [sp, #8]
		tmpstr = next;
   20dec:	9300      	str	r3, [sp, #0]
		while (!is_array_stop(*tmpstr) && !is_terminated(*tmpstr)) {
   20dee:	9800      	ldr	r0, [sp, #0]
   20df0:	7803      	ldrb	r3, [r0, #0]
 * @retval true  If character is )
 * @retval false If character is something else
 */
static inline bool is_array_stop(char chr)
{
	if (chr == ')') {
   20df2:	2b29      	cmp	r3, #41	; 0x29
   20df4:	d028      	beq.n	20e48 <at_parse_process_element+0x14c>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   20df6:	b33b      	cbz	r3, 20e48 <at_parse_process_element+0x14c>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   20df8:	3b2c      	subs	r3, #44	; 0x2c
   20dfa:	b2db      	uxtb	r3, r3
   20dfc:	3001      	adds	r0, #1
   20dfe:	2b11      	cmp	r3, #17
				tmparray[i++] =
   20e00:	9000      	str	r0, [sp, #0]
   20e02:	d803      	bhi.n	20e0c <at_parse_process_element+0x110>
   20e04:	fa25 f303 	lsr.w	r3, r5, r3
   20e08:	07db      	lsls	r3, r3, #31
   20e0a:	d408      	bmi.n	20e1e <at_parse_process_element+0x122>
				tmpstr++;
   20e0c:	46a1      	mov	r9, r4
   20e0e:	e004      	b.n	20e1a <at_parse_process_element+0x11e>
					tmpstr = next;
   20e10:	9b01      	ldr	r3, [sp, #4]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   20e12:	f1b9 0f20 	cmp.w	r9, #32
					tmpstr = next;
   20e16:	9300      	str	r3, [sp, #0]
			if (i == AT_CMD_MAX_ARRAY_SIZE) {
   20e18:	d015      	beq.n	20e46 <at_parse_process_element+0x14a>
				tmpstr++;
   20e1a:	464c      	mov	r4, r9
   20e1c:	e7e7      	b.n	20dee <at_parse_process_element+0xf2>
					(u32_t)strtoul(++tmpstr, &next, 10);
   20e1e:	220a      	movs	r2, #10
   20e20:	a901      	add	r1, sp, #4
   20e22:	f011 fa67 	bl	322f4 <strtoul>
				tmparray[i++] =
   20e26:	ab22      	add	r3, sp, #136	; 0x88
   20e28:	f104 0901 	add.w	r9, r4, #1
   20e2c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   20e30:	f844 0c80 	str.w	r0, [r4, #-128]
				if (strlen(tmpstr) == strlen(next)) {
   20e34:	9800      	ldr	r0, [sp, #0]
   20e36:	f7f1 f923 	bl	12080 <strlen>
   20e3a:	4604      	mov	r4, r0
   20e3c:	9801      	ldr	r0, [sp, #4]
   20e3e:	f7f1 f91f 	bl	12080 <strlen>
   20e42:	4284      	cmp	r4, r0
   20e44:	d1e4      	bne.n	20e10 <at_parse_process_element+0x114>
   20e46:	464c      	mov	r4, r9
		at_params_array_put(list, index, tmparray, i * sizeof(u32_t));
   20e48:	00a3      	lsls	r3, r4, #2
   20e4a:	aa02      	add	r2, sp, #8
   20e4c:	4639      	mov	r1, r7
   20e4e:	4630      	mov	r0, r6
   20e50:	f017 fd4b 	bl	388ea <at_params_array_put>
   20e54:	e7b2      	b.n	20dbc <at_parse_process_element+0xc0>
	} else if (state == NUMBER) {
   20e56:	2c04      	cmp	r4, #4
   20e58:	d115      	bne.n	20e86 <at_parse_process_element+0x18a>
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   20e5a:	220a      	movs	r2, #10
   20e5c:	a902      	add	r1, sp, #8
   20e5e:	4628      	mov	r0, r5
   20e60:	f011 fa48 	bl	322f4 <strtoul>
		tmpstr = next;
   20e64:	9b02      	ldr	r3, [sp, #8]
		if (value <= USHRT_MAX) {
   20e66:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
		int value = (u32_t)strtoul(tmpstr, &next, 10);
   20e6a:	4602      	mov	r2, r0
		tmpstr = next;
   20e6c:	9300      	str	r3, [sp, #0]
		if (value <= USHRT_MAX) {
   20e6e:	da05      	bge.n	20e7c <at_parse_process_element+0x180>
			at_params_short_put(list, index, (u16_t)value);
   20e70:	b282      	uxth	r2, r0
   20e72:	4639      	mov	r1, r7
   20e74:	4630      	mov	r0, r6
   20e76:	f017 fcd4 	bl	38822 <at_params_short_put>
   20e7a:	e779      	b.n	20d70 <at_parse_process_element+0x74>
			at_params_int_put(list, index, value);
   20e7c:	4639      	mov	r1, r7
   20e7e:	4630      	mov	r0, r6
   20e80:	f017 fcf8 	bl	38874 <at_params_int_put>
   20e84:	e774      	b.n	20d70 <at_parse_process_element+0x74>
	} else if (state == SMS_PDU) {
   20e86:	2c05      	cmp	r4, #5
   20e88:	f47f af72 	bne.w	20d70 <at_parse_process_element+0x74>
		while (isxdigit((int)*tmpstr)) {
   20e8c:	4909      	ldr	r1, [pc, #36]	; (20eb4 <at_parse_process_element+0x1b8>)
   20e8e:	9b00      	ldr	r3, [sp, #0]
   20e90:	781a      	ldrb	r2, [r3, #0]
   20e92:	5c52      	ldrb	r2, [r2, r1]
   20e94:	f012 0f44 	tst.w	r2, #68	; 0x44
   20e98:	d101      	bne.n	20e9e <at_parse_process_element+0x1a2>
		at_params_string_put(list, index, start_ptr,
   20e9a:	1b5b      	subs	r3, r3, r5
   20e9c:	e746      	b.n	20d2c <at_parse_process_element+0x30>
			tmpstr++;
   20e9e:	3301      	adds	r3, #1
   20ea0:	9300      	str	r3, [sp, #0]
   20ea2:	e7f4      	b.n	20e8e <at_parse_process_element+0x192>
		return -1;
   20ea4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20ea8:	e766      	b.n	20d78 <at_parse_process_element+0x7c>
   20eaa:	bf00      	nop
   20eac:	2002807c 	.word	0x2002807c
   20eb0:	00024001 	.word	0x00024001
   20eb4:	00040188 	.word	0x00040188

00020eb8 <is_command>:
 *
 * @retval true  If the string is an AT command
 * @retval false Otherwise
 */
static inline bool is_command(const char *str)
{
   20eb8:	b510      	push	{r4, lr}
   20eba:	4604      	mov	r4, r0
	if (strlen(str) < 2) {
   20ebc:	f7f1 f8e0 	bl	12080 <strlen>
   20ec0:	2801      	cmp	r0, #1
   20ec2:	d922      	bls.n	20f0a <is_command+0x52>
		return false;
	}

	if ((toupper((int)str[0]) != 'A') || (toupper((int)str[1]) != 'T')) {
   20ec4:	7821      	ldrb	r1, [r4, #0]
   20ec6:	4b13      	ldr	r3, [pc, #76]	; (20f14 <is_command+0x5c>)
   20ec8:	5cca      	ldrb	r2, [r1, r3]
   20eca:	f002 0203 	and.w	r2, r2, #3
   20ece:	2a02      	cmp	r2, #2
   20ed0:	bf08      	it	eq
   20ed2:	3920      	subeq	r1, #32
   20ed4:	2941      	cmp	r1, #65	; 0x41
   20ed6:	461a      	mov	r2, r3
   20ed8:	d117      	bne.n	20f0a <is_command+0x52>
   20eda:	7863      	ldrb	r3, [r4, #1]
   20edc:	5cd2      	ldrb	r2, [r2, r3]
   20ede:	f002 0203 	and.w	r2, r2, #3
   20ee2:	2a02      	cmp	r2, #2
   20ee4:	bf08      	it	eq
   20ee6:	3b20      	subeq	r3, #32
   20ee8:	2b54      	cmp	r3, #84	; 0x54
   20eea:	d10e      	bne.n	20f0a <is_command+0x52>
	}

	/* Third character has be one of the command special characters.
	 * The special case is a lone "AT" command.
	 */
	if ((str[2] == AT_STANDARD_NOTIFICATION_PREFIX) ||
   20eec:	78a2      	ldrb	r2, [r4, #2]
   20eee:	2a25      	cmp	r2, #37	; 0x25
   20ef0:	d00d      	beq.n	20f0e <is_command+0x56>
	    (str[2] == AT_PROP_NOTIFICATION_PREFX) ||
   20ef2:	f002 03f7 	and.w	r3, r2, #247	; 0xf7
   20ef6:	2b23      	cmp	r3, #35	; 0x23
   20ef8:	d009      	beq.n	20f0e <is_command+0x56>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
	    is_lfcr(str[2]) || is_terminated(str[2])) {
   20efa:	4610      	mov	r0, r2
   20efc:	f017 fc56 	bl	387ac <is_lfcr>
	    (str[2] == AT_CUSTOM_COMMAND_PREFX) ||
   20f00:	b910      	cbnz	r0, 20f08 <is_command+0x50>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   20f02:	fab2 f082 	clz	r0, r2
   20f06:	0940      	lsrs	r0, r0, #5
		return true;
	}

	return false;
}
   20f08:	bd10      	pop	{r4, pc}
		return false;
   20f0a:	2000      	movs	r0, #0
   20f0c:	e7fc      	b.n	20f08 <is_command+0x50>
		return true;
   20f0e:	2001      	movs	r0, #1
   20f10:	e7fa      	b.n	20f08 <is_command+0x50>
   20f12:	bf00      	nop
   20f14:	00040188 	.word	0x00040188

00020f18 <at_parse_detect_type>:
{
   20f18:	b570      	push	{r4, r5, r6, lr}
	const char *tmpstr = *str;
   20f1a:	6804      	ldr	r4, [r0, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   20f1c:	2900      	cmp	r1, #0
{
   20f1e:	4606      	mov	r6, r0
   20f20:	7822      	ldrb	r2, [r4, #0]
	if ((index == 0) && is_notification(*tmpstr)) {
   20f22:	d141      	bne.n	20fa8 <at_parse_detect_type+0x90>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   20f24:	2a2b      	cmp	r2, #43	; 0x2b
   20f26:	4d29      	ldr	r5, [pc, #164]	; (20fcc <at_parse_detect_type+0xb4>)
   20f28:	d001      	beq.n	20f2e <at_parse_detect_type+0x16>
   20f2a:	2a25      	cmp	r2, #37	; 0x25
   20f2c:	d104      	bne.n	20f38 <at_parse_detect_type+0x20>
	state = new_state;
   20f2e:	2306      	movs	r3, #6
   20f30:	702b      	strb	r3, [r5, #0]
	return 0;
   20f32:	2000      	movs	r0, #0
	*str = tmpstr;
   20f34:	6034      	str	r4, [r6, #0]
}
   20f36:	bd70      	pop	{r4, r5, r6, pc}
	} else if ((index == 0) && is_command(tmpstr)) {
   20f38:	4620      	mov	r0, r4
   20f3a:	f7ff ffbd 	bl	20eb8 <is_command>
   20f3e:	b388      	cbz	r0, 20fa4 <at_parse_detect_type+0x8c>
	state = new_state;
   20f40:	2307      	movs	r3, #7
   20f42:	e7f5      	b.n	20f30 <at_parse_detect_type+0x18>
	if (chr == '"') {
   20f44:	2a22      	cmp	r2, #34	; 0x22
   20f46:	d006      	beq.n	20f56 <at_parse_detect_type+0x3e>
	if (chr == '(') {
   20f48:	2a28      	cmp	r2, #40	; 0x28
   20f4a:	d109      	bne.n	20f60 <at_parse_detect_type+0x48>
   20f4c:	2201      	movs	r2, #1
   20f4e:	4b1f      	ldr	r3, [pc, #124]	; (20fcc <at_parse_detect_type+0xb4>)
		tmpstr++;
   20f50:	4414      	add	r4, r2
	state = new_state;
   20f52:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   20f54:	e7ed      	b.n	20f32 <at_parse_detect_type+0x1a>
	state = new_state;
   20f56:	2203      	movs	r2, #3
   20f58:	4b1c      	ldr	r3, [pc, #112]	; (20fcc <at_parse_detect_type+0xb4>)
		tmpstr++;
   20f5a:	3401      	adds	r4, #1
	state = new_state;
   20f5c:	701a      	strb	r2, [r3, #0]
		tmpstr++;
   20f5e:	e7e8      	b.n	20f32 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == NUMBER)) {
   20f60:	4610      	mov	r0, r2
   20f62:	f017 fc23 	bl	387ac <is_lfcr>
   20f66:	b170      	cbz	r0, 20f86 <at_parse_detect_type+0x6e>
   20f68:	4918      	ldr	r1, [pc, #96]	; (20fcc <at_parse_detect_type+0xb4>)
   20f6a:	7808      	ldrb	r0, [r1, #0]
   20f6c:	2804      	cmp	r0, #4
   20f6e:	d108      	bne.n	20f82 <at_parse_detect_type+0x6a>
		while (is_lfcr(*tmpstr)) {
   20f70:	f814 0f01 	ldrb.w	r0, [r4, #1]!
   20f74:	f017 fc1a 	bl	387ac <is_lfcr>
   20f78:	2800      	cmp	r0, #0
   20f7a:	d1f9      	bne.n	20f70 <at_parse_detect_type+0x58>
	state = new_state;
   20f7c:	2305      	movs	r3, #5
   20f7e:	700b      	strb	r3, [r1, #0]
   20f80:	e7d7      	b.n	20f32 <at_parse_detect_type+0x1a>
	} else if (is_lfcr(*tmpstr) && (state == OPTIONAL)) {
   20f82:	2808      	cmp	r0, #8
   20f84:	d0d5      	beq.n	20f32 <at_parse_detect_type+0x1a>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   20f86:	3a2c      	subs	r2, #44	; 0x2c
   20f88:	b2d2      	uxtb	r2, r2
   20f8a:	2a11      	cmp	r2, #17
   20f8c:	d807      	bhi.n	20f9e <at_parse_detect_type+0x86>
   20f8e:	4b10      	ldr	r3, [pc, #64]	; (20fd0 <at_parse_detect_type+0xb8>)
   20f90:	fa23 f202 	lsr.w	r2, r3, r2
   20f94:	07d3      	lsls	r3, r2, #31
   20f96:	d502      	bpl.n	20f9e <at_parse_detect_type+0x86>
	state = new_state;
   20f98:	4b0c      	ldr	r3, [pc, #48]	; (20fcc <at_parse_detect_type+0xb4>)
   20f9a:	2208      	movs	r2, #8
   20f9c:	e013      	b.n	20fc6 <at_parse_detect_type+0xae>
		return -1;
   20f9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   20fa2:	e7c8      	b.n	20f36 <at_parse_detect_type+0x1e>
	state = new_state;
   20fa4:	2302      	movs	r3, #2
   20fa6:	e7c3      	b.n	20f30 <at_parse_detect_type+0x18>
	} else if ((index > 0) && is_notification(*tmpstr)) {
   20fa8:	dd03      	ble.n	20fb2 <at_parse_detect_type+0x9a>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   20faa:	2a2b      	cmp	r2, #43	; 0x2b
   20fac:	d0f7      	beq.n	20f9e <at_parse_detect_type+0x86>
   20fae:	2a25      	cmp	r2, #37	; 0x25
   20fb0:	d0f5      	beq.n	20f9e <at_parse_detect_type+0x86>
	if (isdigit((int)chr) || (chr == '-') || (chr == '+')) {
   20fb2:	4b08      	ldr	r3, [pc, #32]	; (20fd4 <at_parse_detect_type+0xbc>)
   20fb4:	5cd3      	ldrb	r3, [r2, r3]
   20fb6:	0759      	lsls	r1, r3, #29
   20fb8:	d403      	bmi.n	20fc2 <at_parse_detect_type+0xaa>
   20fba:	2a2d      	cmp	r2, #45	; 0x2d
   20fbc:	d001      	beq.n	20fc2 <at_parse_detect_type+0xaa>
   20fbe:	2a2b      	cmp	r2, #43	; 0x2b
   20fc0:	d1c0      	bne.n	20f44 <at_parse_detect_type+0x2c>
	state = new_state;
   20fc2:	2204      	movs	r2, #4
   20fc4:	4b01      	ldr	r3, [pc, #4]	; (20fcc <at_parse_detect_type+0xb4>)
   20fc6:	701a      	strb	r2, [r3, #0]
   20fc8:	e7b3      	b.n	20f32 <at_parse_detect_type+0x1a>
   20fca:	bf00      	nop
   20fcc:	2002807c 	.word	0x2002807c
   20fd0:	00024001 	.word	0x00024001
   20fd4:	00040188 	.word	0x00040188

00020fd8 <at_parser_max_params_from_str>:

int at_parser_max_params_from_str(const char *at_params_str,
				  char **next_param_str,
				  struct at_param_list *const list,
				  size_t max_params_count)
{
   20fd8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   20fdc:	4688      	mov	r8, r1
   20fde:	4616      	mov	r6, r2
   20fe0:	461f      	mov	r7, r3
	int err = 0;

	if (at_params_str == NULL || list == NULL || list->params == NULL) {
   20fe2:	4604      	mov	r4, r0
   20fe4:	2800      	cmp	r0, #0
   20fe6:	d07e      	beq.n	210e6 <at_parser_max_params_from_str+0x10e>
   20fe8:	2a00      	cmp	r2, #0
   20fea:	d07c      	beq.n	210e6 <at_parser_max_params_from_str+0x10e>
   20fec:	6853      	ldr	r3, [r2, #4]
   20fee:	2b00      	cmp	r3, #0
   20ff0:	d079      	beq.n	210e6 <at_parser_max_params_from_str+0x10e>
	state = IDLE;
   20ff2:	2500      	movs	r5, #0
		return -EINVAL;
	}

	at_params_list_clear(list);
   20ff4:	4610      	mov	r0, r2
   20ff6:	f000 f8eb 	bl	211d0 <at_params_list_clear>

	max_params_count = MIN(max_params_count, list->param_count);
   20ffa:	6832      	ldr	r2, [r6, #0]
	const char *str = *at_params_str;
   20ffc:	9401      	str	r4, [sp, #4]
	max_params_count = MIN(max_params_count, list->param_count);
   20ffe:	4297      	cmp	r7, r2
   21000:	bf28      	it	cs
   21002:	4617      	movcs	r7, r2
	int index = 0;
   21004:	462c      	mov	r4, r5
	state = IDLE;
   21006:	4b39      	ldr	r3, [pc, #228]	; (210ec <at_parser_max_params_from_str+0x114>)
		if (isspace((int)*str)) {
   21008:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 210f0 <at_parser_max_params_from_str+0x118>
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   2100c:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 210f4 <at_parser_max_params_from_str+0x11c>
	state = IDLE;
   21010:	701d      	strb	r5, [r3, #0]
	while ((!is_terminated(*str)) && (index < max_params)) {
   21012:	9b01      	ldr	r3, [sp, #4]
   21014:	781a      	ldrb	r2, [r3, #0]
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   21016:	2a00      	cmp	r2, #0
   21018:	d04b      	beq.n	210b2 <at_parser_max_params_from_str+0xda>
   2101a:	42a7      	cmp	r7, r4
   2101c:	d949      	bls.n	210b2 <at_parser_max_params_from_str+0xda>
		if (isspace((int)*str)) {
   2101e:	f812 2009 	ldrb.w	r2, [r2, r9]
		if (at_parse_detect_type(&str, index) == -1) {
   21022:	a801      	add	r0, sp, #4
		if (isspace((int)*str)) {
   21024:	0711      	lsls	r1, r2, #28
			str++;
   21026:	bf48      	it	mi
   21028:	3301      	addmi	r3, #1
		if (at_parse_detect_type(&str, index) == -1) {
   2102a:	4621      	mov	r1, r4
			str++;
   2102c:	bf48      	it	mi
   2102e:	9301      	strmi	r3, [sp, #4]
		if (at_parse_detect_type(&str, index) == -1) {
   21030:	f7ff ff72 	bl	20f18 <at_parse_detect_type>
   21034:	1c42      	adds	r2, r0, #1
   21036:	d03c      	beq.n	210b2 <at_parser_max_params_from_str+0xda>
		if (at_parse_process_element(&str, index, list) == -1) {
   21038:	4632      	mov	r2, r6
   2103a:	4621      	mov	r1, r4
   2103c:	a801      	add	r0, sp, #4
   2103e:	f7ff fe5d 	bl	20cfc <at_parse_process_element>
   21042:	1c43      	adds	r3, r0, #1
   21044:	d035      	beq.n	210b2 <at_parser_max_params_from_str+0xda>
		if (is_separator(*str)) {
   21046:	9b01      	ldr	r3, [sp, #4]
	if ((chr == AT_PARAM_SEPARATOR) || (chr == AT_RSP_SEPARATOR) ||
   21048:	781a      	ldrb	r2, [r3, #0]
   2104a:	3a2c      	subs	r2, #44	; 0x2c
   2104c:	b2d2      	uxtb	r2, r2
   2104e:	2a11      	cmp	r2, #17
   21050:	d81a      	bhi.n	21088 <at_parser_max_params_from_str+0xb0>
   21052:	fa2a f202 	lsr.w	r2, sl, r2
   21056:	07d1      	lsls	r1, r2, #31
   21058:	d516      	bpl.n	21088 <at_parser_max_params_from_str+0xb0>
			if (is_lfcr(*(str + 1))) {
   2105a:	7858      	ldrb	r0, [r3, #1]
   2105c:	f017 fba6 	bl	387ac <is_lfcr>
   21060:	b178      	cbz	r0, 21082 <at_parser_max_params_from_str+0xaa>
				index++;
   21062:	3401      	adds	r4, #1
				if (index == max_params) {
   21064:	42bc      	cmp	r4, r7
   21066:	d039      	beq.n	210dc <at_parser_max_params_from_str+0x104>
				if (at_parse_detect_type(&str, index) == -1) {
   21068:	4621      	mov	r1, r4
   2106a:	a801      	add	r0, sp, #4
   2106c:	f7ff ff54 	bl	20f18 <at_parse_detect_type>
   21070:	1c42      	adds	r2, r0, #1
   21072:	d01e      	beq.n	210b2 <at_parser_max_params_from_str+0xda>
				if (at_parse_process_element(&str, index,
   21074:	4632      	mov	r2, r6
   21076:	4621      	mov	r1, r4
   21078:	a801      	add	r0, sp, #4
   2107a:	f7ff fe3f 	bl	20cfc <at_parse_process_element>
   2107e:	1c43      	adds	r3, r0, #1
   21080:	d017      	beq.n	210b2 <at_parser_max_params_from_str+0xda>
			str++;
   21082:	9b01      	ldr	r3, [sp, #4]
   21084:	3301      	adds	r3, #1
   21086:	9301      	str	r3, [sp, #4]
		if (is_lfcr(*str)) {
   21088:	9a01      	ldr	r2, [sp, #4]
   2108a:	7810      	ldrb	r0, [r2, #0]
   2108c:	f017 fb8e 	bl	387ac <is_lfcr>
   21090:	b1f8      	cbz	r0, 210d2 <at_parser_max_params_from_str+0xfa>
   21092:	3201      	adds	r2, #1
			while (is_lfcr(str[++i])) {
   21094:	7811      	ldrb	r1, [r2, #0]
   21096:	4693      	mov	fp, r2
   21098:	4608      	mov	r0, r1
   2109a:	3201      	adds	r2, #1
   2109c:	f017 fb86 	bl	387ac <is_lfcr>
   210a0:	2800      	cmp	r0, #0
   210a2:	d1f7      	bne.n	21094 <at_parser_max_params_from_str+0xbc>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   210a4:	b119      	cbz	r1, 210ae <at_parser_max_params_from_str+0xd6>
	if ((chr == AT_STANDARD_NOTIFICATION_PREFIX) ||
   210a6:	292b      	cmp	r1, #43	; 0x2b
   210a8:	d001      	beq.n	210ae <at_parser_max_params_from_str+0xd6>
   210aa:	2925      	cmp	r1, #37	; 0x25
   210ac:	d111      	bne.n	210d2 <at_parser_max_params_from_str+0xfa>
				str += i;
   210ae:	f8cd b004 	str.w	fp, [sp, #4]
	*at_params_str = str;
   210b2:	9b01      	ldr	r3, [sp, #4]
	if (oversized) {
   210b4:	b9a5      	cbnz	r5, 210e0 <at_parser_max_params_from_str+0x108>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   210b6:	781a      	ldrb	r2, [r3, #0]
		return -EAGAIN;
   210b8:	2a00      	cmp	r2, #0
   210ba:	bf0c      	ite	eq
   210bc:	2000      	moveq	r0, #0
   210be:	f06f 000a 	mvnne.w	r0, #10

	err = at_parse_param(&at_params_str, list, max_params_count);

	if (next_param_str) {
   210c2:	f1b8 0f00 	cmp.w	r8, #0
   210c6:	d001      	beq.n	210cc <at_parser_max_params_from_str+0xf4>
		*next_param_str = (char *)at_params_str;
   210c8:	f8c8 3000 	str.w	r3, [r8]
	}

	return err;
}
   210cc:	b003      	add	sp, #12
   210ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		index++;
   210d2:	3401      	adds	r4, #1
			oversized = true;
   210d4:	42bc      	cmp	r4, r7
   210d6:	bf08      	it	eq
   210d8:	2501      	moveq	r5, #1
   210da:	e79a      	b.n	21012 <at_parser_max_params_from_str+0x3a>
					oversized = true;
   210dc:	4605      	mov	r5, r0
   210de:	e7e8      	b.n	210b2 <at_parser_max_params_from_str+0xda>
		return -E2BIG;
   210e0:	f06f 0006 	mvn.w	r0, #6
   210e4:	e7ed      	b.n	210c2 <at_parser_max_params_from_str+0xea>
		return -EINVAL;
   210e6:	f06f 0015 	mvn.w	r0, #21
   210ea:	e7ef      	b.n	210cc <at_parser_max_params_from_str+0xf4>
   210ec:	2002807c 	.word	0x2002807c
   210f0:	00040188 	.word	0x00040188
   210f4:	00024001 	.word	0x00024001

000210f8 <at_params_get>:
}

/* Internal function. Parameter cannot be null. */
static struct at_param *at_params_get(const struct at_param_list *list,
				      size_t index)
{
   210f8:	b538      	push	{r3, r4, r5, lr}
   210fa:	460c      	mov	r4, r1
	__ASSERT(list != NULL, "Parameter list cannot be NULL.");
   210fc:	4605      	mov	r5, r0
   210fe:	b960      	cbnz	r0, 2111a <at_params_get+0x22>
   21100:	490a      	ldr	r1, [pc, #40]	; (2112c <at_params_get+0x34>)
   21102:	232b      	movs	r3, #43	; 0x2b
   21104:	4a0a      	ldr	r2, [pc, #40]	; (21130 <at_params_get+0x38>)
   21106:	480b      	ldr	r0, [pc, #44]	; (21134 <at_params_get+0x3c>)
   21108:	f012 fa5e 	bl	335c8 <printk>
   2110c:	480a      	ldr	r0, [pc, #40]	; (21138 <at_params_get+0x40>)
   2110e:	f012 fa5b 	bl	335c8 <printk>
   21112:	212b      	movs	r1, #43	; 0x2b
   21114:	4806      	ldr	r0, [pc, #24]	; (21130 <at_params_get+0x38>)
   21116:	f012 fd58 	bl	33bca <assert_post_action>

	if (index >= list->param_count) {
   2111a:	682b      	ldr	r3, [r5, #0]
   2111c:	42a3      	cmp	r3, r4
		return NULL;
	}

	struct at_param *param = list->params;

	return &param[index];
   2111e:	bf85      	ittet	hi
   21120:	230c      	movhi	r3, #12
   21122:	6868      	ldrhi	r0, [r5, #4]
		return NULL;
   21124:	2000      	movls	r0, #0
	return &param[index];
   21126:	fb03 0004 	mlahi	r0, r3, r4, r0
}
   2112a:	bd38      	pop	{r3, r4, r5, pc}
   2112c:	0003e4d6 	.word	0x0003e4d6
   21130:	0003e4a8 	.word	0x0003e4a8
   21134:	0003b77f 	.word	0x0003b77f
   21138:	0003e4ea 	.word	0x0003e4ea

0002113c <at_param_size>:

/* Internal function. Parameter cannot be null. */
static size_t at_param_size(const struct at_param *param)
{
   2113c:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2113e:	4604      	mov	r4, r0
   21140:	b960      	cbnz	r0, 2115c <at_param_size+0x20>
   21142:	490e      	ldr	r1, [pc, #56]	; (2117c <at_param_size+0x40>)
   21144:	2339      	movs	r3, #57	; 0x39
   21146:	4a0e      	ldr	r2, [pc, #56]	; (21180 <at_param_size+0x44>)
   21148:	480e      	ldr	r0, [pc, #56]	; (21184 <at_param_size+0x48>)
   2114a:	f012 fa3d 	bl	335c8 <printk>
   2114e:	480e      	ldr	r0, [pc, #56]	; (21188 <at_param_size+0x4c>)
   21150:	f012 fa3a 	bl	335c8 <printk>
   21154:	2139      	movs	r1, #57	; 0x39
   21156:	480a      	ldr	r0, [pc, #40]	; (21180 <at_param_size+0x44>)
   21158:	f012 fd37 	bl	33bca <assert_post_action>

	if (param->type == AT_PARAM_TYPE_NUM_SHORT) {
   2115c:	7823      	ldrb	r3, [r4, #0]
   2115e:	2b01      	cmp	r3, #1
   21160:	d006      	beq.n	21170 <at_param_size+0x34>
		return sizeof(u16_t);
	} else if (param->type == AT_PARAM_TYPE_NUM_INT) {
   21162:	2b02      	cmp	r3, #2
   21164:	d006      	beq.n	21174 <at_param_size+0x38>
		return sizeof(u32_t);
	} else if ((param->type == AT_PARAM_TYPE_STRING) ||
   21166:	3b03      	subs	r3, #3
   21168:	2b01      	cmp	r3, #1
   2116a:	d805      	bhi.n	21178 <at_param_size+0x3c>
		   (param->type == AT_PARAM_TYPE_ARRAY)) {
		return param->size;
   2116c:	6860      	ldr	r0, [r4, #4]
	}

	return 0;
}
   2116e:	bd10      	pop	{r4, pc}
		return sizeof(u16_t);
   21170:	2002      	movs	r0, #2
   21172:	e7fc      	b.n	2116e <at_param_size+0x32>
		return sizeof(u32_t);
   21174:	2004      	movs	r0, #4
   21176:	e7fa      	b.n	2116e <at_param_size+0x32>
	return 0;
   21178:	2000      	movs	r0, #0
   2117a:	e7f8      	b.n	2116e <at_param_size+0x32>
   2117c:	0003e477 	.word	0x0003e477
   21180:	0003e4a8 	.word	0x0003e4a8
   21184:	0003b77f 	.word	0x0003b77f
   21188:	0003e48c 	.word	0x0003e48c

0002118c <at_param_clear>:
{
   2118c:	b510      	push	{r4, lr}
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   2118e:	4604      	mov	r4, r0
   21190:	b960      	cbnz	r0, 211ac <at_param_clear+0x20>
   21192:	490b      	ldr	r1, [pc, #44]	; (211c0 <at_param_clear+0x34>)
   21194:	231d      	movs	r3, #29
   21196:	4a0b      	ldr	r2, [pc, #44]	; (211c4 <at_param_clear+0x38>)
   21198:	480b      	ldr	r0, [pc, #44]	; (211c8 <at_param_clear+0x3c>)
   2119a:	f012 fa15 	bl	335c8 <printk>
   2119e:	480b      	ldr	r0, [pc, #44]	; (211cc <at_param_clear+0x40>)
   211a0:	f012 fa12 	bl	335c8 <printk>
   211a4:	211d      	movs	r1, #29
   211a6:	4807      	ldr	r0, [pc, #28]	; (211c4 <at_param_clear+0x38>)
   211a8:	f012 fd0f 	bl	33bca <assert_post_action>
	if ((param->type == AT_PARAM_TYPE_STRING) ||
   211ac:	7823      	ldrb	r3, [r4, #0]
   211ae:	3b03      	subs	r3, #3
   211b0:	2b01      	cmp	r3, #1
   211b2:	d802      	bhi.n	211ba <at_param_clear+0x2e>
		k_free(param->value.str_val);
   211b4:	68a0      	ldr	r0, [r4, #8]
   211b6:	f017 fd2b 	bl	38c10 <k_free>
	param->value.int_val = 0;
   211ba:	2300      	movs	r3, #0
   211bc:	60a3      	str	r3, [r4, #8]
}
   211be:	bd10      	pop	{r4, pc}
   211c0:	0003e477 	.word	0x0003e477
   211c4:	0003e4a8 	.word	0x0003e4a8
   211c8:	0003b77f 	.word	0x0003b77f
   211cc:	0003e48c 	.word	0x0003e48c

000211d0 <at_params_list_clear>:
	list->param_count = max_params_count;
	return 0;
}

void at_params_list_clear(struct at_param_list *list)
{
   211d0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (list == NULL || list->params == NULL) {
   211d4:	4605      	mov	r5, r0
   211d6:	b158      	cbz	r0, 211f0 <at_params_list_clear+0x20>
   211d8:	6843      	ldr	r3, [r0, #4]
   211da:	b14b      	cbz	r3, 211f0 <at_params_list_clear+0x20>
		return;
	}

	for (size_t i = 0; i < list->param_count; ++i) {
   211dc:	2400      	movs	r4, #0
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   211de:	f8df 8054 	ldr.w	r8, [pc, #84]	; 21234 <at_params_list_clear+0x64>
   211e2:	f8df a054 	ldr.w	sl, [pc, #84]	; 21238 <at_params_list_clear+0x68>
   211e6:	f8df b054 	ldr.w	fp, [pc, #84]	; 2123c <at_params_list_clear+0x6c>
	for (size_t i = 0; i < list->param_count; ++i) {
   211ea:	682b      	ldr	r3, [r5, #0]
   211ec:	429c      	cmp	r4, r3
   211ee:	d301      	bcc.n	211f4 <at_params_list_clear+0x24>
		struct at_param *params = list->params;

		at_param_clear(&params[i]);
		at_param_init(&params[i]);
	}
}
   211f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		at_param_clear(&params[i]);
   211f4:	270c      	movs	r7, #12
   211f6:	4367      	muls	r7, r4
   211f8:	f8d5 9004 	ldr.w	r9, [r5, #4]
   211fc:	eb09 0607 	add.w	r6, r9, r7
   21200:	4630      	mov	r0, r6
   21202:	f7ff ffc3 	bl	2118c <at_param_clear>
	__ASSERT(param != NULL, "Parameter cannot be NULL.");
   21206:	b966      	cbnz	r6, 21222 <at_params_list_clear+0x52>
   21208:	4651      	mov	r1, sl
   2120a:	2314      	movs	r3, #20
   2120c:	4642      	mov	r2, r8
   2120e:	4658      	mov	r0, fp
   21210:	f012 f9da 	bl	335c8 <printk>
   21214:	4806      	ldr	r0, [pc, #24]	; (21230 <at_params_list_clear+0x60>)
   21216:	f012 f9d7 	bl	335c8 <printk>
   2121a:	2114      	movs	r1, #20
   2121c:	4640      	mov	r0, r8
   2121e:	f012 fcd4 	bl	33bca <assert_post_action>
   21222:	2300      	movs	r3, #0
	for (size_t i = 0; i < list->param_count; ++i) {
   21224:	3401      	adds	r4, #1
   21226:	f849 3007 	str.w	r3, [r9, r7]
   2122a:	6073      	str	r3, [r6, #4]
   2122c:	60b3      	str	r3, [r6, #8]
   2122e:	e7dc      	b.n	211ea <at_params_list_clear+0x1a>
   21230:	0003e48c 	.word	0x0003e48c
   21234:	0003e4a8 	.word	0x0003e4a8
   21238:	0003e477 	.word	0x0003e477
   2123c:	0003b77f 	.word	0x0003b77f

00021240 <parse_psm_cfg>:
	char timer_str[9] = {0};
   21240:	2300      	movs	r3, #0
{
   21242:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   21246:	b089      	sub	sp, #36	; 0x24
	char timer_str[9] = {0};
   21248:	e9cd 3305 	strd	r3, r3, [sp, #20]
   2124c:	f88d 301c 	strb.w	r3, [sp, #28]
	char unit_str[4] = {0};
   21250:	9303      	str	r3, [sp, #12]
	size_t timer_str_len = sizeof(timer_str) - 1;
   21252:	2308      	movs	r3, #8
	size_t tau_idx = is_notif ? AT_CEREG_TAU_INDEX :
   21254:	2900      	cmp	r1, #0
	size_t timer_str_len = sizeof(timer_str) - 1;
   21256:	9304      	str	r3, [sp, #16]
{
   21258:	4616      	mov	r6, r2
	err = at_params_string_get(at_params,
   2125a:	ab04      	add	r3, sp, #16
   2125c:	aa05      	add	r2, sp, #20
   2125e:	bf14      	ite	ne
   21260:	2108      	movne	r1, #8
   21262:	2109      	moveq	r1, #9
{
   21264:	4607      	mov	r7, r0
	size_t tau_idx = is_notif ? AT_CEREG_TAU_INDEX :
   21266:	bf14      	ite	ne
   21268:	f04f 0807 	movne.w	r8, #7
   2126c:	f04f 0808 	moveq.w	r8, #8
	err = at_params_string_get(at_params,
   21270:	f017 fb8e 	bl	38990 <at_params_string_get>
	if (err) {
   21274:	4d3e      	ldr	r5, [pc, #248]	; (21370 <parse_psm_cfg+0x130>)
   21276:	4b3f      	ldr	r3, [pc, #252]	; (21374 <parse_psm_cfg+0x134>)
   21278:	4604      	mov	r4, r0
   2127a:	1aed      	subs	r5, r5, r3
   2127c:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   21280:	b170      	cbz	r0, 212a0 <parse_psm_cfg+0x60>
		LOG_ERR("Could not get TAU, error: %d", err);
   21282:	f04f 0000 	mov.w	r0, #0
   21286:	2301      	movs	r3, #1
   21288:	f363 0007 	bfi	r0, r3, #0, #8
   2128c:	f365 108f 	bfi	r0, r5, #6, #10
   21290:	4622      	mov	r2, r4
   21292:	4939      	ldr	r1, [pc, #228]	; (21378 <parse_psm_cfg+0x138>)
   21294:	f012 fcb0 	bl	33bf8 <log_string_sync>
}
   21298:	4620      	mov	r0, r4
   2129a:	b009      	add	sp, #36	; 0x24
   2129c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	memcpy(unit_str, timer_str, unit_str_len);
   212a0:	9b05      	ldr	r3, [sp, #20]
	lut_idx = strtoul(unit_str, NULL, 2);
   212a2:	4601      	mov	r1, r0
	memcpy(unit_str, timer_str, unit_str_len);
   212a4:	f8ad 300c 	strh.w	r3, [sp, #12]
	lut_idx = strtoul(unit_str, NULL, 2);
   212a8:	2202      	movs	r2, #2
	memcpy(unit_str, timer_str, unit_str_len);
   212aa:	0c1b      	lsrs	r3, r3, #16
	lut_idx = strtoul(unit_str, NULL, 2);
   212ac:	a803      	add	r0, sp, #12
	memcpy(unit_str, timer_str, unit_str_len);
   212ae:	f88d 300e 	strb.w	r3, [sp, #14]
	lut_idx = strtoul(unit_str, NULL, 2);
   212b2:	f011 f81f 	bl	322f4 <strtoul>
	if (lut_idx > (ARRAY_SIZE(t3412_lookup) - 1)) {
   212b6:	2807      	cmp	r0, #7
   212b8:	d90c      	bls.n	212d4 <parse_psm_cfg+0x94>
		LOG_ERR("Unable to parse periodic TAU string");
   212ba:	f04f 0000 	mov.w	r0, #0
   212be:	2301      	movs	r3, #1
   212c0:	492e      	ldr	r1, [pc, #184]	; (2137c <parse_psm_cfg+0x13c>)
   212c2:	f363 0007 	bfi	r0, r3, #0, #8
   212c6:	f365 108f 	bfi	r0, r5, #6, #10
		LOG_ERR("Unable to parse active time string");
   212ca:	f012 fc95 	bl	33bf8 <log_string_sync>
		return err;
   212ce:	f06f 0415 	mvn.w	r4, #21
   212d2:	e7e1      	b.n	21298 <parse_psm_cfg+0x58>
	timer_unit = t3412_lookup[lut_idx];
   212d4:	4b2a      	ldr	r3, [pc, #168]	; (21380 <parse_psm_cfg+0x140>)
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   212d6:	2202      	movs	r2, #2
	timer_unit = t3412_lookup[lut_idx];
   212d8:	f853 9020 	ldr.w	r9, [r3, r0, lsl #2]
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   212dc:	4621      	mov	r1, r4
   212de:	f10d 0017 	add.w	r0, sp, #23
   212e2:	f011 f807 	bl	322f4 <strtoul>
	psm_cfg->tau = timer_unit ? timer_unit * timer_value : -1;
   212e6:	f1b9 0f00 	cmp.w	r9, #0
   212ea:	d021      	beq.n	21330 <parse_psm_cfg+0xf0>
   212ec:	fb00 f009 	mul.w	r0, r0, r9
   212f0:	6030      	str	r0, [r6, #0]
	err = at_params_string_get(at_params,
   212f2:	ab04      	add	r3, sp, #16
   212f4:	aa05      	add	r2, sp, #20
   212f6:	4641      	mov	r1, r8
   212f8:	4638      	mov	r0, r7
   212fa:	f017 fb49 	bl	38990 <at_params_string_get>
	if (err) {
   212fe:	4604      	mov	r4, r0
   21300:	2800      	cmp	r0, #0
   21302:	d1be      	bne.n	21282 <parse_psm_cfg+0x42>
	memcpy(unit_str, timer_str, unit_str_len);
   21304:	9b05      	ldr	r3, [sp, #20]
	lut_idx = strtoul(unit_str, NULL, 2);
   21306:	4601      	mov	r1, r0
	memcpy(unit_str, timer_str, unit_str_len);
   21308:	f8ad 300c 	strh.w	r3, [sp, #12]
	lut_idx = strtoul(unit_str, NULL, 2);
   2130c:	2202      	movs	r2, #2
	memcpy(unit_str, timer_str, unit_str_len);
   2130e:	0c1b      	lsrs	r3, r3, #16
	lut_idx = strtoul(unit_str, NULL, 2);
   21310:	a803      	add	r0, sp, #12
	memcpy(unit_str, timer_str, unit_str_len);
   21312:	f88d 300e 	strb.w	r3, [sp, #14]
	lut_idx = strtoul(unit_str, NULL, 2);
   21316:	f010 ffed 	bl	322f4 <strtoul>
	if (lut_idx > (ARRAY_SIZE(t3324_lookup) - 1)) {
   2131a:	2807      	cmp	r0, #7
   2131c:	d90b      	bls.n	21336 <parse_psm_cfg+0xf6>
		LOG_ERR("Unable to parse active time string");
   2131e:	f04f 0000 	mov.w	r0, #0
   21322:	2301      	movs	r3, #1
   21324:	f363 0007 	bfi	r0, r3, #0, #8
   21328:	f365 108f 	bfi	r0, r5, #6, #10
   2132c:	4915      	ldr	r1, [pc, #84]	; (21384 <parse_psm_cfg+0x144>)
   2132e:	e7cc      	b.n	212ca <parse_psm_cfg+0x8a>
	psm_cfg->tau = timer_unit ? timer_unit * timer_value : -1;
   21330:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   21334:	e7dc      	b.n	212f0 <parse_psm_cfg+0xb0>
	timer_unit = t3324_lookup[lut_idx];
   21336:	4b14      	ldr	r3, [pc, #80]	; (21388 <parse_psm_cfg+0x148>)
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   21338:	2202      	movs	r2, #2
	timer_unit = t3324_lookup[lut_idx];
   2133a:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
	timer_value = strtoul(timer_str + unit_str_len, NULL, 2);
   2133e:	4621      	mov	r1, r4
   21340:	f10d 0017 	add.w	r0, sp, #23
   21344:	f010 ffd6 	bl	322f4 <strtoul>
	psm_cfg->active_time = timer_unit ? timer_unit * timer_value : -1;
   21348:	b17f      	cbz	r7, 2136a <parse_psm_cfg+0x12a>
   2134a:	4347      	muls	r7, r0
	LOG_DBG("TAU: %d sec, active time: %d sec\n",
   2134c:	2204      	movs	r2, #4
   2134e:	f04f 0000 	mov.w	r0, #0
   21352:	f362 0007 	bfi	r0, r2, #0, #8
	psm_cfg->active_time = timer_unit ? timer_unit * timer_value : -1;
   21356:	6077      	str	r7, [r6, #4]
	LOG_DBG("TAU: %d sec, active time: %d sec\n",
   21358:	f365 108f 	bfi	r0, r5, #6, #10
   2135c:	9700      	str	r7, [sp, #0]
   2135e:	6833      	ldr	r3, [r6, #0]
   21360:	4a0a      	ldr	r2, [pc, #40]	; (2138c <parse_psm_cfg+0x14c>)
   21362:	490b      	ldr	r1, [pc, #44]	; (21390 <parse_psm_cfg+0x150>)
   21364:	f012 fc48 	bl	33bf8 <log_string_sync>
	return 0;
   21368:	e796      	b.n	21298 <parse_psm_cfg+0x58>
	psm_cfg->active_time = timer_unit ? timer_unit * timer_value : -1;
   2136a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2136e:	e7ed      	b.n	2134c <parse_psm_cfg+0x10c>
   21370:	00039fc0 	.word	0x00039fc0
   21374:	00039f60 	.word	0x00039f60
   21378:	0003ec0b 	.word	0x0003ec0b
   2137c:	0003ec28 	.word	0x0003ec28
   21380:	0003a794 	.word	0x0003a794
   21384:	0003ec4c 	.word	0x0003ec4c
   21388:	0003a774 	.word	0x0003a774
   2138c:	0003e516 	.word	0x0003e516
   21390:	0003ec6f 	.word	0x0003ec6f

00021394 <lte_lc_normal>:
{
   21394:	b508      	push	{r3, lr}
	if (at_cmd_write(normal, NULL, 0, NULL) != 0) {
   21396:	2300      	movs	r3, #0
   21398:	4804      	ldr	r0, [pc, #16]	; (213ac <lte_lc_normal+0x18>)
   2139a:	461a      	mov	r2, r3
   2139c:	4619      	mov	r1, r3
   2139e:	f7ff fb9f 	bl	20ae0 <at_cmd_write>
   213a2:	2800      	cmp	r0, #0
}
   213a4:	bf18      	it	ne
   213a6:	f06f 0004 	mvnne.w	r0, #4
   213aa:	bd08      	pop	{r3, pc}
   213ac:	0003ec01 	.word	0x0003ec01

000213b0 <lte_lc_psm_req>:
{
   213b0:	b500      	push	{lr}
	if (enable) {
   213b2:	4603      	mov	r3, r0
{
   213b4:	b08d      	sub	sp, #52	; 0x34
	if (enable) {
   213b6:	b1a0      	cbz	r0, 213e2 <lte_lc_psm_req+0x32>
		snprintf(psm_req, sizeof(psm_req),
   213b8:	4b0c      	ldr	r3, [pc, #48]	; (213ec <lte_lc_psm_req+0x3c>)
   213ba:	4a0d      	ldr	r2, [pc, #52]	; (213f0 <lte_lc_psm_req+0x40>)
   213bc:	9300      	str	r3, [sp, #0]
   213be:	2128      	movs	r1, #40	; 0x28
   213c0:	4b0c      	ldr	r3, [pc, #48]	; (213f4 <lte_lc_psm_req+0x44>)
   213c2:	a802      	add	r0, sp, #8
   213c4:	f010 fc5c 	bl	31c80 <sniprintf>
		err = at_cmd_write(psm_req, NULL, 0, NULL);
   213c8:	2300      	movs	r3, #0
   213ca:	461a      	mov	r2, r3
   213cc:	4619      	mov	r1, r3
   213ce:	a802      	add	r0, sp, #8
		err = at_cmd_write(psm_disable, NULL, 0, NULL);
   213d0:	f7ff fb86 	bl	20ae0 <at_cmd_write>
		return -EIO;
   213d4:	2800      	cmp	r0, #0
}
   213d6:	bf18      	it	ne
   213d8:	f06f 0004 	mvnne.w	r0, #4
   213dc:	b00d      	add	sp, #52	; 0x34
   213de:	f85d fb04 	ldr.w	pc, [sp], #4
		err = at_cmd_write(psm_disable, NULL, 0, NULL);
   213e2:	4602      	mov	r2, r0
   213e4:	4601      	mov	r1, r0
   213e6:	4804      	ldr	r0, [pc, #16]	; (213f8 <lte_lc_psm_req+0x48>)
   213e8:	e7f2      	b.n	213d0 <lte_lc_psm_req+0x20>
   213ea:	bf00      	nop
   213ec:	200204f0 	.word	0x200204f0
   213f0:	0003ea33 	.word	0x0003ea33
   213f4:	200204f9 	.word	0x200204f9
   213f8:	0003ec95 	.word	0x0003ec95

000213fc <lte_lc_system_mode_set>:

	return err;
}

int lte_lc_system_mode_set(enum lte_lc_system_mode mode)
{
   213fc:	b530      	push	{r4, r5, lr}
   213fe:	4b30      	ldr	r3, [pc, #192]	; (214c0 <lte_lc_system_mode_set+0xc4>)
   21400:	4d30      	ldr	r5, [pc, #192]	; (214c4 <lte_lc_system_mode_set+0xc8>)
   21402:	b08f      	sub	sp, #60	; 0x3c
   21404:	1aed      	subs	r5, r5, r3
   21406:	f3c5 05c9 	ubfx	r5, r5, #3, #10
	int err, len;
	char cmd[50];

	switch (mode) {
   2140a:	4604      	mov	r4, r0
   2140c:	b1c0      	cbz	r0, 21440 <lte_lc_system_mode_set+0x44>
   2140e:	2805      	cmp	r0, #5
   21410:	d822      	bhi.n	21458 <lte_lc_system_mode_set+0x5c>
	default:
		LOG_ERR("Invalid system mode requested");
		return -EINVAL;
	}

	len = snprintk(cmd, sizeof(cmd), "AT%%XSYSTEMMODE=%s",
   21412:	4b2d      	ldr	r3, [pc, #180]	; (214c8 <lte_lc_system_mode_set+0xcc>)
   21414:	4a2d      	ldr	r2, [pc, #180]	; (214cc <lte_lc_system_mode_set+0xd0>)
   21416:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   2141a:	2132      	movs	r1, #50	; 0x32
   2141c:	a801      	add	r0, sp, #4
   2141e:	f012 f8e0 	bl	335e2 <snprintk>
		       system_mode_params[mode]);
	if (len < 0) {
   21422:	2800      	cmp	r0, #0
   21424:	da27      	bge.n	21476 <lte_lc_system_mode_set+0x7a>
		LOG_ERR("Could not construct system mode command");
   21426:	2301      	movs	r3, #1
   21428:	f04f 0000 	mov.w	r0, #0
   2142c:	f363 0007 	bfi	r0, r3, #0, #8
   21430:	f365 108f 	bfi	r0, r5, #6, #10
   21434:	4926      	ldr	r1, [pc, #152]	; (214d0 <lte_lc_system_mode_set+0xd4>)
   21436:	f012 fbdf 	bl	33bf8 <log_string_sync>
		return -EFAULT;
   2143a:	f06f 040d 	mvn.w	r4, #13
   2143e:	e017      	b.n	21470 <lte_lc_system_mode_set+0x74>
		LOG_DBG("No system mode set");
   21440:	f04f 0000 	mov.w	r0, #0
   21444:	2304      	movs	r3, #4
   21446:	4a23      	ldr	r2, [pc, #140]	; (214d4 <lte_lc_system_mode_set+0xd8>)
   21448:	f363 0007 	bfi	r0, r3, #0, #8
   2144c:	4922      	ldr	r1, [pc, #136]	; (214d8 <lte_lc_system_mode_set+0xdc>)
   2144e:	f365 108f 	bfi	r0, r5, #6, #10

	LOG_DBG("Sending AT command to set system mode: %s", log_strdup(cmd));

	err = at_cmd_write(cmd, NULL, 0, NULL);
	if (err) {
		LOG_ERR("Could not send AT command, error: %d", err);
   21452:	f012 fbd1 	bl	33bf8 <log_string_sync>
   21456:	e00b      	b.n	21470 <lte_lc_system_mode_set+0x74>
		LOG_ERR("Invalid system mode requested");
   21458:	2301      	movs	r3, #1
   2145a:	f04f 0000 	mov.w	r0, #0
   2145e:	f363 0007 	bfi	r0, r3, #0, #8
   21462:	f365 108f 	bfi	r0, r5, #6, #10
   21466:	491d      	ldr	r1, [pc, #116]	; (214dc <lte_lc_system_mode_set+0xe0>)
   21468:	f012 fbc6 	bl	33bf8 <log_string_sync>
		return -EINVAL;
   2146c:	f06f 0415 	mvn.w	r4, #21
	}

	return err;
}
   21470:	4620      	mov	r0, r4
   21472:	b00f      	add	sp, #60	; 0x3c
   21474:	bd30      	pop	{r4, r5, pc}
	LOG_DBG("Sending AT command to set system mode: %s", log_strdup(cmd));
   21476:	2304      	movs	r3, #4
   21478:	f04f 0400 	mov.w	r4, #0
   2147c:	eb0d 0003 	add.w	r0, sp, r3
   21480:	f363 0407 	bfi	r4, r3, #0, #8
   21484:	f012 fbca 	bl	33c1c <log_strdup>
   21488:	f365 148f 	bfi	r4, r5, #6, #10
   2148c:	4603      	mov	r3, r0
   2148e:	4a11      	ldr	r2, [pc, #68]	; (214d4 <lte_lc_system_mode_set+0xd8>)
   21490:	4620      	mov	r0, r4
   21492:	4913      	ldr	r1, [pc, #76]	; (214e0 <lte_lc_system_mode_set+0xe4>)
   21494:	f012 fbb0 	bl	33bf8 <log_string_sync>
	err = at_cmd_write(cmd, NULL, 0, NULL);
   21498:	2300      	movs	r3, #0
   2149a:	a801      	add	r0, sp, #4
   2149c:	461a      	mov	r2, r3
   2149e:	4619      	mov	r1, r3
   214a0:	f7ff fb1e 	bl	20ae0 <at_cmd_write>
	if (err) {
   214a4:	4604      	mov	r4, r0
   214a6:	2800      	cmp	r0, #0
   214a8:	d0e2      	beq.n	21470 <lte_lc_system_mode_set+0x74>
		LOG_ERR("Could not send AT command, error: %d", err);
   214aa:	f04f 0000 	mov.w	r0, #0
   214ae:	2301      	movs	r3, #1
   214b0:	f363 0007 	bfi	r0, r3, #0, #8
   214b4:	f365 108f 	bfi	r0, r5, #6, #10
   214b8:	4622      	mov	r2, r4
   214ba:	490a      	ldr	r1, [pc, #40]	; (214e4 <lte_lc_system_mode_set+0xe8>)
   214bc:	e7c9      	b.n	21452 <lte_lc_system_mode_set+0x56>
   214be:	bf00      	nop
   214c0:	00039f60 	.word	0x00039f60
   214c4:	00039fc0 	.word	0x00039fc0
   214c8:	0003a75c 	.word	0x0003a75c
   214cc:	0003eb73 	.word	0x0003eb73
   214d0:	0003eb86 	.word	0x0003eb86
   214d4:	0003e52f 	.word	0x0003e52f
   214d8:	0003eb3e 	.word	0x0003eb3e
   214dc:	0003eb55 	.word	0x0003eb55
   214e0:	0003ebae 	.word	0x0003ebae
   214e4:	0003ebdc 	.word	0x0003ebdc

000214e8 <w_lte_lc_init>:
{
   214e8:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (is_initialized) {
   214ea:	4e54      	ldr	r6, [pc, #336]	; (2163c <w_lte_lc_init+0x154>)
{
   214ec:	b08f      	sub	sp, #60	; 0x3c
	if (is_initialized) {
   214ee:	7830      	ldrb	r0, [r6, #0]
   214f0:	2800      	cmp	r0, #0
   214f2:	f040 809f 	bne.w	21634 <w_lte_lc_init+0x14c>
	err = at_notif_register_handler(NULL, at_handler);
   214f6:	4952      	ldr	r1, [pc, #328]	; (21640 <w_lte_lc_init+0x158>)
   214f8:	f7ff fba4 	bl	20c44 <at_notif_register_handler>
	if (err) {
   214fc:	4604      	mov	r4, r0
   214fe:	b188      	cbz	r0, 21524 <w_lte_lc_init+0x3c>
		LOG_ERR("Can't register AT handler, error: %d", err);
   21500:	2301      	movs	r3, #1
   21502:	f04f 0000 	mov.w	r0, #0
   21506:	4a4f      	ldr	r2, [pc, #316]	; (21644 <w_lte_lc_init+0x15c>)
   21508:	f363 0007 	bfi	r0, r3, #0, #8
   2150c:	4b4e      	ldr	r3, [pc, #312]	; (21648 <w_lte_lc_init+0x160>)
   2150e:	494f      	ldr	r1, [pc, #316]	; (2164c <w_lte_lc_init+0x164>)
   21510:	1a9b      	subs	r3, r3, r2
   21512:	4622      	mov	r2, r4
   21514:	08db      	lsrs	r3, r3, #3
   21516:	f363 108f 	bfi	r0, r3, #6, #10
		LOG_ERR("Could not set system mode, error: %d", err);
   2151a:	f012 fb6d 	bl	33bf8 <log_string_sync>
}
   2151e:	4620      	mov	r0, r4
   21520:	b00f      	add	sp, #60	; 0x3c
   21522:	bdf0      	pop	{r4, r5, r6, r7, pc}
	err = lte_lc_system_mode_set(sys_mode_preferred);
   21524:	2002      	movs	r0, #2
   21526:	f7ff ff69 	bl	213fc <lte_lc_system_mode_set>
	if (err) {
   2152a:	4604      	mov	r4, r0
   2152c:	b168      	cbz	r0, 2154a <w_lte_lc_init+0x62>
		LOG_ERR("Could not set system mode, error: %d", err);
   2152e:	2301      	movs	r3, #1
   21530:	f04f 0000 	mov.w	r0, #0
   21534:	4a43      	ldr	r2, [pc, #268]	; (21644 <w_lte_lc_init+0x15c>)
   21536:	f363 0007 	bfi	r0, r3, #0, #8
   2153a:	4b43      	ldr	r3, [pc, #268]	; (21648 <w_lte_lc_init+0x160>)
   2153c:	4944      	ldr	r1, [pc, #272]	; (21650 <w_lte_lc_init+0x168>)
   2153e:	1a9b      	subs	r3, r3, r2
   21540:	08db      	lsrs	r3, r3, #3
   21542:	f363 108f 	bfi	r0, r3, #6, #10
   21546:	4622      	mov	r2, r4
   21548:	e7e7      	b.n	2151a <w_lte_lc_init+0x32>
	if (at_cmd_write(cereg_5_subscribe, NULL, 0, NULL) != 0) {
   2154a:	4603      	mov	r3, r0
   2154c:	4602      	mov	r2, r0
   2154e:	4601      	mov	r1, r0
   21550:	4840      	ldr	r0, [pc, #256]	; (21654 <w_lte_lc_init+0x16c>)
   21552:	f7ff fac5 	bl	20ae0 <at_cmd_write>
   21556:	b110      	cbz	r0, 2155e <w_lte_lc_init+0x76>
		return -EIO;
   21558:	f06f 0404 	mvn.w	r4, #4
   2155c:	e7df      	b.n	2151e <w_lte_lc_init+0x36>
	if (at_cmd_write(cgdcont, NULL, 0, NULL) != 0) {
   2155e:	4623      	mov	r3, r4
   21560:	4622      	mov	r2, r4
   21562:	4621      	mov	r1, r4
   21564:	483c      	ldr	r0, [pc, #240]	; (21658 <w_lte_lc_init+0x170>)
   21566:	f7ff fabb 	bl	20ae0 <at_cmd_write>
   2156a:	2800      	cmp	r0, #0
   2156c:	d1f4      	bne.n	21558 <w_lte_lc_init+0x70>
	LOG_INF("PDP Context: %s", log_strdup(cgdcont));
   2156e:	2303      	movs	r3, #3
   21570:	f04f 0700 	mov.w	r7, #0
   21574:	4d34      	ldr	r5, [pc, #208]	; (21648 <w_lte_lc_init+0x160>)
   21576:	f363 0707 	bfi	r7, r3, #0, #8
   2157a:	4b32      	ldr	r3, [pc, #200]	; (21644 <w_lte_lc_init+0x15c>)
   2157c:	4836      	ldr	r0, [pc, #216]	; (21658 <w_lte_lc_init+0x170>)
   2157e:	1aed      	subs	r5, r5, r3
   21580:	f012 fb4c 	bl	33c1c <log_strdup>
   21584:	f3c5 05c9 	ubfx	r5, r5, #3, #10
   21588:	f365 178f 	bfi	r7, r5, #6, #10
   2158c:	4602      	mov	r2, r0
   2158e:	4933      	ldr	r1, [pc, #204]	; (2165c <w_lte_lc_init+0x174>)
   21590:	4638      	mov	r0, r7
   21592:	f012 fb31 	bl	33bf8 <log_string_sync>
	if (at_cmd_write(cgauth, NULL, 0, NULL) != 0) {
   21596:	4623      	mov	r3, r4
   21598:	4622      	mov	r2, r4
   2159a:	4621      	mov	r1, r4
   2159c:	4830      	ldr	r0, [pc, #192]	; (21660 <w_lte_lc_init+0x178>)
   2159e:	f7ff fa9f 	bl	20ae0 <at_cmd_write>
   215a2:	4604      	mov	r4, r0
   215a4:	2800      	cmp	r0, #0
   215a6:	d1d7      	bne.n	21558 <w_lte_lc_init+0x70>
	LOG_INF("PDN Auth: %s", log_strdup(cgauth));
   215a8:	2303      	movs	r3, #3
   215aa:	f04f 0700 	mov.w	r7, #0
   215ae:	482c      	ldr	r0, [pc, #176]	; (21660 <w_lte_lc_init+0x178>)
   215b0:	f363 0707 	bfi	r7, r3, #0, #8
   215b4:	f012 fb32 	bl	33c1c <log_strdup>
   215b8:	f365 178f 	bfi	r7, r5, #6, #10
   215bc:	4602      	mov	r2, r0
   215be:	4929      	ldr	r1, [pc, #164]	; (21664 <w_lte_lc_init+0x17c>)
   215c0:	4638      	mov	r0, r7
   215c2:	f012 fb19 	bl	33bf8 <log_string_sync>
	err = at_cmd_write(cscon, NULL, 0, NULL);
   215c6:	4623      	mov	r3, r4
   215c8:	4622      	mov	r2, r4
   215ca:	4621      	mov	r1, r4
   215cc:	4826      	ldr	r0, [pc, #152]	; (21668 <w_lte_lc_init+0x180>)
   215ce:	f7ff fa87 	bl	20ae0 <at_cmd_write>
	if (err) {
   215d2:	4603      	mov	r3, r0
   215d4:	b358      	cbz	r0, 2162e <w_lte_lc_init+0x146>
		LOG_WRN("%s failed (%d), RRC notifications are not enabled",
   215d6:	2202      	movs	r2, #2
   215d8:	f04f 0000 	mov.w	r0, #0
   215dc:	f362 0007 	bfi	r0, r2, #0, #8
   215e0:	f365 108f 	bfi	r0, r5, #6, #10
   215e4:	4a20      	ldr	r2, [pc, #128]	; (21668 <w_lte_lc_init+0x180>)
   215e6:	4921      	ldr	r1, [pc, #132]	; (2166c <w_lte_lc_init+0x184>)
   215e8:	f012 fb06 	bl	33bf8 <log_string_sync>
		LOG_WRN("%s is supported in nRF9160 modem >= v1.1.0", cscon);
   215ec:	2302      	movs	r3, #2
   215ee:	f04f 0000 	mov.w	r0, #0
   215f2:	f363 0007 	bfi	r0, r3, #0, #8
   215f6:	f365 108f 	bfi	r0, r5, #6, #10
   215fa:	4a1b      	ldr	r2, [pc, #108]	; (21668 <w_lte_lc_init+0x180>)
   215fc:	491c      	ldr	r1, [pc, #112]	; (21670 <w_lte_lc_init+0x188>)
   215fe:	f012 fafb 	bl	33bf8 <log_string_sync>
		err = at_cmd_write("AT+CGMR", buf, sizeof(buf), NULL);
   21602:	4623      	mov	r3, r4
   21604:	2232      	movs	r2, #50	; 0x32
   21606:	a901      	add	r1, sp, #4
   21608:	481a      	ldr	r0, [pc, #104]	; (21674 <w_lte_lc_init+0x18c>)
   2160a:	f7ff fa69 	bl	20ae0 <at_cmd_write>
		if (err == 0) {
   2160e:	b970      	cbnz	r0, 2162e <w_lte_lc_init+0x146>
			LOG_WRN("Current modem firmware version: %s",
   21610:	2302      	movs	r3, #2
   21612:	f04f 0700 	mov.w	r7, #0
   21616:	a801      	add	r0, sp, #4
   21618:	f363 0707 	bfi	r7, r3, #0, #8
   2161c:	f012 fafe 	bl	33c1c <log_strdup>
   21620:	f365 178f 	bfi	r7, r5, #6, #10
   21624:	4602      	mov	r2, r0
   21626:	4914      	ldr	r1, [pc, #80]	; (21678 <w_lte_lc_init+0x190>)
   21628:	4638      	mov	r0, r7
   2162a:	f012 fae5 	bl	33bf8 <log_string_sync>
	is_initialized = true;
   2162e:	2301      	movs	r3, #1
   21630:	7033      	strb	r3, [r6, #0]
	return 0;
   21632:	e774      	b.n	2151e <w_lte_lc_init+0x36>
		return -EALREADY;
   21634:	f06f 0477 	mvn.w	r4, #119	; 0x77
   21638:	e771      	b.n	2151e <w_lte_lc_init+0x36>
   2163a:	bf00      	nop
   2163c:	2002807d 	.word	0x2002807d
   21640:	000128e1 	.word	0x000128e1
   21644:	00039f60 	.word	0x00039f60
   21648:	00039fc0 	.word	0x00039fc0
   2164c:	0003ed3c 	.word	0x0003ed3c
   21650:	0003ed61 	.word	0x0003ed61
   21654:	0003e84b 	.word	0x0003e84b
   21658:	20020460 	.word	0x20020460
   2165c:	0003ed86 	.word	0x0003ed86
   21660:	20020425 	.word	0x20020425
   21664:	0003ed96 	.word	0x0003ed96
   21668:	0003e856 	.word	0x0003e856
   2166c:	0003eda3 	.word	0x0003eda3
   21670:	0003edd5 	.word	0x0003edd5
   21674:	0003ee00 	.word	0x0003ee00
   21678:	0003ee08 	.word	0x0003ee08

0002167c <w_lte_lc_connect>:
	if (!is_initialized) {
   2167c:	4b1e      	ldr	r3, [pc, #120]	; (216f8 <w_lte_lc_connect+0x7c>)
{
   2167e:	b510      	push	{r4, lr}
	if (!is_initialized) {
   21680:	781b      	ldrb	r3, [r3, #0]
{
   21682:	4604      	mov	r4, r0
	if (!is_initialized) {
   21684:	b983      	cbnz	r3, 216a8 <w_lte_lc_connect+0x2c>
		LOG_ERR("The LTE link controller is not initialized");
   21686:	2301      	movs	r3, #1
   21688:	f04f 0000 	mov.w	r0, #0
   2168c:	4a1b      	ldr	r2, [pc, #108]	; (216fc <w_lte_lc_connect+0x80>)
   2168e:	f363 0007 	bfi	r0, r3, #0, #8
   21692:	4b1b      	ldr	r3, [pc, #108]	; (21700 <w_lte_lc_connect+0x84>)
   21694:	491b      	ldr	r1, [pc, #108]	; (21704 <w_lte_lc_connect+0x88>)
   21696:	1a9b      	subs	r3, r3, r2
   21698:	08db      	lsrs	r3, r3, #3
   2169a:	f363 108f 	bfi	r0, r3, #6, #10
   2169e:	f012 faab 	bl	33bf8 <log_string_sync>
		return -EPERM;
   216a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   216a6:	bd10      	pop	{r4, pc}
	return z_impl_k_sem_init(sem, initial_count, limit);
   216a8:	2201      	movs	r2, #1
   216aa:	2100      	movs	r1, #0
   216ac:	4816      	ldr	r0, [pc, #88]	; (21708 <w_lte_lc_connect+0x8c>)
   216ae:	f017 fb38 	bl	38d22 <z_impl_k_sem_init>
		err = lte_lc_system_mode_set(current_network_mode);
   216b2:	2002      	movs	r0, #2
   216b4:	f7ff fea2 	bl	213fc <lte_lc_system_mode_set>
		if (err) {
   216b8:	2800      	cmp	r0, #0
   216ba:	d1f4      	bne.n	216a6 <w_lte_lc_connect+0x2a>
		err = lte_lc_normal();
   216bc:	f7ff fe6a 	bl	21394 <lte_lc_normal>
		if (err || !blocking) {
   216c0:	2800      	cmp	r0, #0
   216c2:	d1f0      	bne.n	216a6 <w_lte_lc_connect+0x2a>
   216c4:	2c00      	cmp	r4, #0
   216c6:	d0ee      	beq.n	216a6 <w_lte_lc_connect+0x2a>
	return z_impl_k_sem_take(sem, timeout);
   216c8:	4910      	ldr	r1, [pc, #64]	; (2170c <w_lte_lc_connect+0x90>)
   216ca:	480f      	ldr	r0, [pc, #60]	; (21708 <w_lte_lc_connect+0x8c>)
   216cc:	f00c fcd2 	bl	2e074 <z_impl_k_sem_take>
		if (err == -EAGAIN) {
   216d0:	f110 0f0b 	cmn.w	r0, #11
   216d4:	d1e7      	bne.n	216a6 <w_lte_lc_connect+0x2a>
			LOG_INF("Network connection attempt timed out");
   216d6:	2303      	movs	r3, #3
   216d8:	f04f 0000 	mov.w	r0, #0
   216dc:	4a07      	ldr	r2, [pc, #28]	; (216fc <w_lte_lc_connect+0x80>)
   216de:	f363 0007 	bfi	r0, r3, #0, #8
   216e2:	4b07      	ldr	r3, [pc, #28]	; (21700 <w_lte_lc_connect+0x84>)
   216e4:	490a      	ldr	r1, [pc, #40]	; (21710 <w_lte_lc_connect+0x94>)
   216e6:	1a9b      	subs	r3, r3, r2
   216e8:	08db      	lsrs	r3, r3, #3
   216ea:	f363 108f 	bfi	r0, r3, #6, #10
   216ee:	f012 fa83 	bl	33bf8 <log_string_sync>
				err = -ETIMEDOUT;
   216f2:	f06f 0073 	mvn.w	r0, #115	; 0x73
   216f6:	e7d6      	b.n	216a6 <w_lte_lc_connect+0x2a>
   216f8:	2002807d 	.word	0x2002807d
   216fc:	00039f60 	.word	0x00039f60
   21700:	00039fc0 	.word	0x00039fc0
   21704:	0003ecec 	.word	0x0003ecec
   21708:	20022378 	.word	0x20022378
   2170c:	000927c0 	.word	0x000927c0
   21710:	0003ed17 	.word	0x0003ed17

00021714 <lte_lc_system_mode_get>:

int lte_lc_system_mode_get(enum lte_lc_system_mode *mode)
{
   21714:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int err, bitmask = 0;
	struct at_param_list resp_list = {0};
   21718:	2400      	movs	r4, #0
	char response[AT_XSYSTEMMODE_RESPONSE_MAX_LEN] = {0};
	char response_prefix[sizeof(AT_XSYSTEMMODE_RESPONSE_PREFIX)] = {0};
   2171a:	250d      	movs	r5, #13
{
   2171c:	4606      	mov	r6, r0
   2171e:	b090      	sub	sp, #64	; 0x40
	char response[AT_XSYSTEMMODE_RESPONSE_MAX_LEN] = {0};
   21720:	221e      	movs	r2, #30
   21722:	4621      	mov	r1, r4
   21724:	a808      	add	r0, sp, #32
	struct at_param_list resp_list = {0};
   21726:	e9cd 4402 	strd	r4, r4, [sp, #8]
	char response[AT_XSYSTEMMODE_RESPONSE_MAX_LEN] = {0};
   2172a:	f017 fc8f 	bl	3904c <memset>
	char response_prefix[sizeof(AT_XSYSTEMMODE_RESPONSE_PREFIX)] = {0};
   2172e:	462a      	mov	r2, r5
   21730:	4621      	mov	r1, r4
   21732:	a804      	add	r0, sp, #16
   21734:	f017 fc8a 	bl	3904c <memset>
	size_t response_prefix_len = sizeof(response_prefix);
   21738:	9500      	str	r5, [sp, #0]

	if (mode == NULL) {
   2173a:	2e00      	cmp	r6, #0
   2173c:	f000 80c2 	beq.w	218c4 <lte_lc_system_mode_get+0x1b0>
		return -EINVAL;
	}

	err = at_cmd_write(AT_XSYSTEMMODE_READ, response, sizeof(response),
   21740:	4623      	mov	r3, r4
   21742:	221e      	movs	r2, #30
   21744:	a908      	add	r1, sp, #32
   21746:	4861      	ldr	r0, [pc, #388]	; (218cc <lte_lc_system_mode_get+0x1b8>)
   21748:	f7ff f9ca 	bl	20ae0 <at_cmd_write>
			   NULL);
	if (err) {
   2174c:	4604      	mov	r4, r0
   2174e:	b188      	cbz	r0, 21774 <lte_lc_system_mode_get+0x60>
		LOG_ERR("Could not send AT command");
   21750:	2301      	movs	r3, #1
   21752:	f04f 0000 	mov.w	r0, #0
   21756:	4a5e      	ldr	r2, [pc, #376]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   21758:	f363 0007 	bfi	r0, r3, #0, #8
   2175c:	4b5d      	ldr	r3, [pc, #372]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   2175e:	495e      	ldr	r1, [pc, #376]	; (218d8 <lte_lc_system_mode_get+0x1c4>)
   21760:	1a9b      	subs	r3, r3, r2
   21762:	08db      	lsrs	r3, r3, #3
   21764:	f363 108f 	bfi	r0, r3, #6, #10
   21768:	f012 fa46 	bl	33bf8 <log_string_sync>

clean_exit:
	at_params_list_free(&resp_list);

	return err;
}
   2176c:	4620      	mov	r0, r4
   2176e:	b010      	add	sp, #64	; 0x40
   21770:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	err = at_params_list_init(&resp_list, AT_XSYSTEMMODE_PARAMS_COUNT);
   21774:	2105      	movs	r1, #5
   21776:	a802      	add	r0, sp, #8
   21778:	f017 f832 	bl	387e0 <at_params_list_init>
	if (err) {
   2177c:	4604      	mov	r4, r0
   2177e:	b178      	cbz	r0, 217a0 <lte_lc_system_mode_get+0x8c>
		LOG_ERR("Could init AT params list, error: %d", err);
   21780:	2301      	movs	r3, #1
   21782:	f04f 0000 	mov.w	r0, #0
   21786:	4a52      	ldr	r2, [pc, #328]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   21788:	f363 0007 	bfi	r0, r3, #0, #8
   2178c:	4b51      	ldr	r3, [pc, #324]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   2178e:	4953      	ldr	r1, [pc, #332]	; (218dc <lte_lc_system_mode_get+0x1c8>)
   21790:	1a9b      	subs	r3, r3, r2
   21792:	08db      	lsrs	r3, r3, #3
   21794:	f363 108f 	bfi	r0, r3, #6, #10
   21798:	4622      	mov	r2, r4
   2179a:	f012 fa2d 	bl	33bf8 <log_string_sync>
		return err;
   2179e:	e7e5      	b.n	2176c <lte_lc_system_mode_get+0x58>
	err = at_parser_max_params_from_str(response, NULL, &resp_list,
   217a0:	4601      	mov	r1, r0
   217a2:	2305      	movs	r3, #5
   217a4:	aa02      	add	r2, sp, #8
   217a6:	a808      	add	r0, sp, #32
   217a8:	f7ff fc16 	bl	20fd8 <at_parser_max_params_from_str>
	if (err) {
   217ac:	4604      	mov	r4, r0
   217ae:	b178      	cbz	r0, 217d0 <lte_lc_system_mode_get+0xbc>
		LOG_ERR("Could not parse AT response, error: %d", err);
   217b0:	2301      	movs	r3, #1
   217b2:	f04f 0000 	mov.w	r0, #0
   217b6:	4a46      	ldr	r2, [pc, #280]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   217b8:	f363 0007 	bfi	r0, r3, #0, #8
   217bc:	4b45      	ldr	r3, [pc, #276]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   217be:	4948      	ldr	r1, [pc, #288]	; (218e0 <lte_lc_system_mode_get+0x1cc>)
   217c0:	1a9b      	subs	r3, r3, r2
   217c2:	4622      	mov	r2, r4
   217c4:	08db      	lsrs	r3, r3, #3
   217c6:	f363 108f 	bfi	r0, r3, #6, #10
			LOG_ERR("Could not parse mode parameter, err: %d", err);
   217ca:	f012 fa15 	bl	33bf8 <log_string_sync>
			goto clean_exit;
   217ce:	e02c      	b.n	2182a <lte_lc_system_mode_get+0x116>
	err = at_params_string_get(&resp_list,
   217d0:	4601      	mov	r1, r0
   217d2:	466b      	mov	r3, sp
   217d4:	aa04      	add	r2, sp, #16
   217d6:	a802      	add	r0, sp, #8
   217d8:	f017 f8da 	bl	38990 <at_params_string_get>
	if (err) {
   217dc:	4605      	mov	r5, r0
   217de:	b180      	cbz	r0, 21802 <lte_lc_system_mode_get+0xee>
		LOG_ERR("Could not get response prefix, error: %d", err);
   217e0:	2301      	movs	r3, #1
   217e2:	f04f 0000 	mov.w	r0, #0
   217e6:	4a3a      	ldr	r2, [pc, #232]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   217e8:	f363 0007 	bfi	r0, r3, #0, #8
   217ec:	4b39      	ldr	r3, [pc, #228]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   217ee:	493d      	ldr	r1, [pc, #244]	; (218e4 <lte_lc_system_mode_get+0x1d0>)
   217f0:	1a9b      	subs	r3, r3, r2
   217f2:	08db      	lsrs	r3, r3, #3
   217f4:	f363 108f 	bfi	r0, r3, #6, #10
   217f8:	462a      	mov	r2, r5
   217fa:	f012 f9fd 	bl	33bf8 <log_string_sync>
		break;
   217fe:	462c      	mov	r4, r5
   21800:	e013      	b.n	2182a <lte_lc_system_mode_get+0x116>
	if (!response_is_valid(response_prefix, response_prefix_len,
   21802:	4a39      	ldr	r2, [pc, #228]	; (218e8 <lte_lc_system_mode_get+0x1d4>)
   21804:	9900      	ldr	r1, [sp, #0]
   21806:	a804      	add	r0, sp, #16
   21808:	f017 f900 	bl	38a0c <response_is_valid>
   2180c:	b988      	cbnz	r0, 21832 <lte_lc_system_mode_get+0x11e>
		LOG_ERR("Invalid XSYSTEMMODE response");
   2180e:	2301      	movs	r3, #1
   21810:	4a2f      	ldr	r2, [pc, #188]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   21812:	f363 0007 	bfi	r0, r3, #0, #8
   21816:	4b2f      	ldr	r3, [pc, #188]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   21818:	4934      	ldr	r1, [pc, #208]	; (218ec <lte_lc_system_mode_get+0x1d8>)
   2181a:	1a9b      	subs	r3, r3, r2
   2181c:	08db      	lsrs	r3, r3, #3
   2181e:	f363 108f 	bfi	r0, r3, #6, #10
   21822:	f012 f9e9 	bl	33bf8 <log_string_sync>
		err = -EIO;
   21826:	f06f 0404 	mvn.w	r4, #4
	at_params_list_free(&resp_list);
   2182a:	a802      	add	r0, sp, #8
   2182c:	f016 ffeb 	bl	38806 <at_params_list_free>
	return err;
   21830:	e79c      	b.n	2176c <lte_lc_system_mode_get+0x58>
	for (size_t i = 1; i < AT_XSYSTEMMODE_PARAMS_COUNT; i++) {
   21832:	2701      	movs	r7, #1
		bitmask = param ? bitmask | BIT(i) : bitmask;
   21834:	46b8      	mov	r8, r7
		err = at_params_int_get(&resp_list, i, &param);
   21836:	aa01      	add	r2, sp, #4
   21838:	4639      	mov	r1, r7
   2183a:	a802      	add	r0, sp, #8
   2183c:	f017 f891 	bl	38962 <at_params_int_get>
		if (err) {
   21840:	4604      	mov	r4, r0
   21842:	b168      	cbz	r0, 21860 <lte_lc_system_mode_get+0x14c>
			LOG_ERR("Could not parse mode parameter, err: %d", err);
   21844:	2301      	movs	r3, #1
   21846:	f04f 0000 	mov.w	r0, #0
   2184a:	4a21      	ldr	r2, [pc, #132]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   2184c:	f363 0007 	bfi	r0, r3, #0, #8
   21850:	4b20      	ldr	r3, [pc, #128]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   21852:	4927      	ldr	r1, [pc, #156]	; (218f0 <lte_lc_system_mode_get+0x1dc>)
   21854:	1a9b      	subs	r3, r3, r2
   21856:	08db      	lsrs	r3, r3, #3
   21858:	f363 108f 	bfi	r0, r3, #6, #10
   2185c:	4622      	mov	r2, r4
   2185e:	e7b4      	b.n	217ca <lte_lc_system_mode_get+0xb6>
		bitmask = param ? bitmask | BIT(i) : bitmask;
   21860:	9b01      	ldr	r3, [sp, #4]
   21862:	b113      	cbz	r3, 2186a <lte_lc_system_mode_get+0x156>
   21864:	fa08 f307 	lsl.w	r3, r8, r7
   21868:	431d      	orrs	r5, r3
	for (size_t i = 1; i < AT_XSYSTEMMODE_PARAMS_COUNT; i++) {
   2186a:	3701      	adds	r7, #1
   2186c:	2f05      	cmp	r7, #5
   2186e:	d1e2      	bne.n	21836 <lte_lc_system_mode_get+0x122>
	switch (bitmask) {
   21870:	2d0c      	cmp	r5, #12
   21872:	d816      	bhi.n	218a2 <lte_lc_system_mode_get+0x18e>
   21874:	e8df f005 	tbb	[pc, r5]
   21878:	150a1507 	.word	0x150a1507
   2187c:	1515150d 	.word	0x1515150d
   21880:	1511150f 	.word	0x1511150f
   21884:	13          	.byte	0x13
   21885:	00          	.byte	0x00
		*mode = LTE_LC_SYSTEM_MODE_NONE;
   21886:	2300      	movs	r3, #0
   21888:	7033      	strb	r3, [r6, #0]
   2188a:	e7b8      	b.n	217fe <lte_lc_system_mode_get+0xea>
		*mode = LTE_LC_SYSTEM_MODE_LTEM;
   2188c:	2301      	movs	r3, #1
		*mode = LTE_LC_SYSTEM_MODE_NBIOT_GPS;
   2188e:	7033      	strb	r3, [r6, #0]
		break;
   21890:	e7cb      	b.n	2182a <lte_lc_system_mode_get+0x116>
		*mode = LTE_LC_SYSTEM_MODE_NBIOT;
   21892:	2302      	movs	r3, #2
   21894:	e7fb      	b.n	2188e <lte_lc_system_mode_get+0x17a>
		*mode = LTE_LC_SYSTEM_MODE_GPS;
   21896:	2303      	movs	r3, #3
   21898:	e7f9      	b.n	2188e <lte_lc_system_mode_get+0x17a>
		*mode = LTE_LC_SYSTEM_MODE_LTEM_GPS;
   2189a:	2304      	movs	r3, #4
   2189c:	e7f7      	b.n	2188e <lte_lc_system_mode_get+0x17a>
		*mode = LTE_LC_SYSTEM_MODE_NBIOT_GPS;
   2189e:	2305      	movs	r3, #5
   218a0:	e7f5      	b.n	2188e <lte_lc_system_mode_get+0x17a>
		LOG_ERR("Invalid system mode, assuming parsing error");
   218a2:	2301      	movs	r3, #1
   218a4:	f04f 0000 	mov.w	r0, #0
   218a8:	4a09      	ldr	r2, [pc, #36]	; (218d0 <lte_lc_system_mode_get+0x1bc>)
   218aa:	f363 0007 	bfi	r0, r3, #0, #8
   218ae:	4b09      	ldr	r3, [pc, #36]	; (218d4 <lte_lc_system_mode_get+0x1c0>)
   218b0:	4910      	ldr	r1, [pc, #64]	; (218f4 <lte_lc_system_mode_get+0x1e0>)
   218b2:	1a9b      	subs	r3, r3, r2
   218b4:	08db      	lsrs	r3, r3, #3
   218b6:	f363 108f 	bfi	r0, r3, #6, #10
   218ba:	f012 f99d 	bl	33bf8 <log_string_sync>
		err = -EFAULT;
   218be:	f06f 040d 	mvn.w	r4, #13
		break;
   218c2:	e7b2      	b.n	2182a <lte_lc_system_mode_get+0x116>
		return -EINVAL;
   218c4:	f06f 0415 	mvn.w	r4, #21
   218c8:	e750      	b.n	2176c <lte_lc_system_mode_get+0x58>
   218ca:	bf00      	nop
   218cc:	0003ea4a 	.word	0x0003ea4a
   218d0:	00039f60 	.word	0x00039f60
   218d4:	00039fc0 	.word	0x00039fc0
   218d8:	0003ea5a 	.word	0x0003ea5a
   218dc:	0003ea74 	.word	0x0003ea74
   218e0:	0003ea99 	.word	0x0003ea99
   218e4:	0003e888 	.word	0x0003e888
   218e8:	0003eac0 	.word	0x0003eac0
   218ec:	0003eacd 	.word	0x0003eacd
   218f0:	0003eaea 	.word	0x0003eaea
   218f4:	0003eb12 	.word	0x0003eb12

000218f8 <modem_info_parse>:
	}
}

static int modem_info_parse(const struct modem_info_data *modem_data,
			    const char *buf)
{
   218f8:	b510      	push	{r4, lr}
   218fa:	4604      	mov	r4, r0
	int err;
	u32_t param_index;

	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   218fc:	4a12      	ldr	r2, [pc, #72]	; (21948 <modem_info_parse+0x50>)
{
   218fe:	4608      	mov	r0, r1
	err = at_parser_max_params_from_str(buf, NULL, &m_param_list,
   21900:	7a63      	ldrb	r3, [r4, #9]
   21902:	2100      	movs	r1, #0
   21904:	f7ff fb68 	bl	20fd8 <at_parser_max_params_from_str>
					    modem_data->param_count);

	if (err == -EAGAIN) {
   21908:	f110 0f0b 	cmn.w	r0, #11
   2190c:	d119      	bne.n	21942 <modem_info_parse+0x4a>
		LOG_DBG("More items exist to parse for: %s",
   2190e:	2304      	movs	r3, #4
   21910:	f04f 0000 	mov.w	r0, #0
   21914:	4a0d      	ldr	r2, [pc, #52]	; (2194c <modem_info_parse+0x54>)
   21916:	f363 0007 	bfi	r0, r3, #0, #8
   2191a:	4b0d      	ldr	r3, [pc, #52]	; (21950 <modem_info_parse+0x58>)
   2191c:	490d      	ldr	r1, [pc, #52]	; (21954 <modem_info_parse+0x5c>)
   2191e:	1a9b      	subs	r3, r3, r2
   21920:	08db      	lsrs	r3, r3, #3
   21922:	f363 108f 	bfi	r0, r3, #6, #10
   21926:	4a0c      	ldr	r2, [pc, #48]	; (21958 <modem_info_parse+0x60>)
   21928:	6863      	ldr	r3, [r4, #4]
   2192a:	f012 f965 	bl	33bf8 <log_string_sync>
		err = 0;
	} else if (err != 0) {
		return err;
	}

	param_index = at_params_valid_count_get(&m_param_list);
   2192e:	4806      	ldr	r0, [pc, #24]	; (21948 <modem_info_parse+0x50>)
   21930:	f017 f855 	bl	389de <at_params_valid_count_get>
	if (param_index > modem_data->param_count) {
   21934:	7a63      	ldrb	r3, [r4, #9]
		return -EAGAIN;
   21936:	4283      	cmp	r3, r0
   21938:	bf2c      	ite	cs
   2193a:	2000      	movcs	r0, #0
   2193c:	f06f 000a 	mvncc.w	r0, #10
   21940:	e001      	b.n	21946 <modem_info_parse+0x4e>
	} else if (err != 0) {
   21942:	2800      	cmp	r0, #0
   21944:	d0f3      	beq.n	2192e <modem_info_parse+0x36>
	}

	return err;
}
   21946:	bd10      	pop	{r4, pc}
   21948:	200223a0 	.word	0x200223a0
   2194c:	00039f60 	.word	0x00039f60
   21950:	00039fc8 	.word	0x00039fc8
   21954:	0003ee52 	.word	0x0003ee52
   21958:	0003ee2b 	.word	0x0003ee2b

0002195c <modem_info_short_get>:

	return len;
}

int modem_info_short_get(enum modem_info info, u16_t *buf)
{
   2195c:	b530      	push	{r4, r5, lr}
   2195e:	460d      	mov	r5, r1
   21960:	b0a1      	sub	sp, #132	; 0x84
   21962:	4604      	mov	r4, r0
	int err;
	char recv_buf[CONFIG_MODEM_INFO_BUFFER_SIZE] = {0};
   21964:	2280      	movs	r2, #128	; 0x80
   21966:	2100      	movs	r1, #0
   21968:	4668      	mov	r0, sp
   2196a:	f017 fb6f 	bl	3904c <memset>
	int cmd_length = 0;

	if (buf == NULL) {
   2196e:	b1dd      	cbz	r5, 219a8 <modem_info_short_get+0x4c>
		return -EINVAL;
	}

	if (modem_data[info]->data_type == AT_PARAM_TYPE_STRING) {
   21970:	4b10      	ldr	r3, [pc, #64]	; (219b4 <modem_info_short_get+0x58>)
   21972:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
   21976:	7aa3      	ldrb	r3, [r4, #10]
   21978:	2b03      	cmp	r3, #3
   2197a:	d015      	beq.n	219a8 <modem_info_short_get+0x4c>
		return -EINVAL;
	}

	err = at_cmd_write(modem_data[info]->cmd,
   2197c:	2300      	movs	r3, #0
   2197e:	2280      	movs	r2, #128	; 0x80
   21980:	4669      	mov	r1, sp
   21982:	6820      	ldr	r0, [r4, #0]
   21984:	f7ff f8ac 	bl	20ae0 <at_cmd_write>
			   recv_buf,
			   CONFIG_MODEM_INFO_BUFFER_SIZE,
			   NULL);

	if (err != 0) {
   21988:	b988      	cbnz	r0, 219ae <modem_info_short_get+0x52>
		return -EIO;
	}

	err = modem_info_parse(modem_data[info], &recv_buf[cmd_length]);
   2198a:	4669      	mov	r1, sp
   2198c:	4620      	mov	r0, r4
   2198e:	f7ff ffb3 	bl	218f8 <modem_info_parse>

	if (err) {
   21992:	b938      	cbnz	r0, 219a4 <modem_info_short_get+0x48>
		return err;
	}

	err = at_params_short_get(&m_param_list,
   21994:	462a      	mov	r2, r5
   21996:	7a21      	ldrb	r1, [r4, #8]
   21998:	4807      	ldr	r0, [pc, #28]	; (219b8 <modem_info_short_get+0x5c>)
   2199a:	f016 ffcc 	bl	38936 <at_params_short_get>

	if (err) {
		return err;
	}

	return sizeof(u16_t);
   2199e:	2800      	cmp	r0, #0
   219a0:	bf08      	it	eq
   219a2:	2002      	moveq	r0, #2
}
   219a4:	b021      	add	sp, #132	; 0x84
   219a6:	bd30      	pop	{r4, r5, pc}
		return -EINVAL;
   219a8:	f06f 0015 	mvn.w	r0, #21
   219ac:	e7fa      	b.n	219a4 <modem_info_short_get+0x48>
		return -EIO;
   219ae:	f06f 0004 	mvn.w	r0, #4
   219b2:	e7f7      	b.n	219a4 <modem_info_short_get+0x48>
   219b4:	0003a880 	.word	0x0003a880
   219b8:	200223a0 	.word	0x200223a0

000219bc <modem_info_string_get>:

int modem_info_string_get(enum modem_info info, char *buf,
				  const size_t buf_size)
{
   219bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   219c0:	460e      	mov	r6, r1
	/* length of each parsed IP address line */
	size_t ip_str_len = 0;
	/* tracks length of buf when parsing multiple IP addresses */
	size_t out_buf_len = 0;
	/* return value indicating length of the string written to buf */
	size_t len = 0;
   219c2:	2500      	movs	r5, #0
{
   219c4:	b0a5      	sub	sp, #148	; 0x94
   219c6:	4680      	mov	r8, r0
   219c8:	4691      	mov	r9, r2
	char recv_buf[CONFIG_MODEM_INFO_BUFFER_SIZE] = {0};
   219ca:	2100      	movs	r1, #0
   219cc:	2280      	movs	r2, #128	; 0x80
   219ce:	a804      	add	r0, sp, #16
   219d0:	f017 fb3c 	bl	3904c <memset>
	size_t len = 0;
   219d4:	9503      	str	r5, [sp, #12]

	if ((buf == NULL) || (buf_size == 0)) {
   219d6:	2e00      	cmp	r6, #0
   219d8:	f000 80f5 	beq.w	21bc6 <modem_info_string_get+0x20a>
   219dc:	f1b9 0f00 	cmp.w	r9, #0
   219e0:	f000 80f1 	beq.w	21bc6 <modem_info_string_get+0x20a>
		return -EINVAL;
	}

	err = at_cmd_write(modem_data[info]->cmd,
   219e4:	4b7c      	ldr	r3, [pc, #496]	; (21bd8 <modem_info_string_get+0x21c>)
   219e6:	2280      	movs	r2, #128	; 0x80
   219e8:	f853 a028 	ldr.w	sl, [r3, r8, lsl #2]
   219ec:	a904      	add	r1, sp, #16
   219ee:	462b      	mov	r3, r5
   219f0:	f8da 0000 	ldr.w	r0, [sl]
   219f4:	f7ff f874 	bl	20ae0 <at_cmd_write>
			  NULL);

	/* modem_info does not yet support array objects, so here we handle
	 * the supported bands independently as a string
	 */
	if (info == MODEM_INFO_SUP_BAND) {
   219f8:	f1b8 0f02 	cmp.w	r8, #2
	err = at_cmd_write(modem_data[info]->cmd,
   219fc:	4604      	mov	r4, r0
	if (info == MODEM_INFO_SUP_BAND) {
   219fe:	d10c      	bne.n	21a1a <modem_info_string_get+0x5e>
__ssp_bos_icheck2_restrict(strcpy, char *, const char *)
   21a00:	f10d 0119 	add.w	r1, sp, #25
   21a04:	4630      	mov	r0, r6
   21a06:	f017 fc75 	bl	392f4 <strcpy>
		strcpy(buf, recv_buf + sizeof("%XCBAND: ") - 1);
		return strlen(buf);
   21a0a:	4630      	mov	r0, r6
   21a0c:	f7f0 fb38 	bl	12080 <strlen>
   21a10:	4683      	mov	fp, r0
			len = out_buf_len;
		}
	}

	return len <= 0 ? -ENOTSUP : len;
}
   21a12:	4658      	mov	r0, fp
   21a14:	b025      	add	sp, #148	; 0x94
   21a16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (info == MODEM_INFO_IP_ADDRESS) {
   21a1a:	f1b8 0f09 	cmp.w	r8, #9
   21a1e:	d046      	beq.n	21aae <modem_info_string_get+0xf2>
	if (err != 0) {
   21a20:	2c00      	cmp	r4, #0
   21a22:	f040 80d3 	bne.w	21bcc <modem_info_string_get+0x210>
	size_t ip_str_len = 0;
   21a26:	4627      	mov	r7, r4
	size_t cmd_rsp_idx = 0;
   21a28:	9401      	str	r4, [sp, #4]
	if (info == MODEM_INFO_IP_ADDRESS) {
   21a2a:	9b01      	ldr	r3, [sp, #4]
   21a2c:	aa04      	add	r2, sp, #16
   21a2e:	f1b8 0f09 	cmp.w	r8, #9
   21a32:	eb02 0b03 	add.w	fp, r2, r3
   21a36:	d10e      	bne.n	21a56 <modem_info_string_get+0x9a>
		ip_str_end = strstr(&recv_buf[cmd_rsp_idx], AT_CMD_RSP_DELIM);
   21a38:	4968      	ldr	r1, [pc, #416]	; (21bdc <modem_info_string_get+0x220>)
   21a3a:	4658      	mov	r0, fp
   21a3c:	f017 fc74 	bl	39328 <strstr>
		if (ip_str_end == NULL) {
   21a40:	2800      	cmp	r0, #0
   21a42:	f000 80c6 	beq.w	21bd2 <modem_info_string_get+0x216>
		recv_buf[++ip_str_len] = 0;
   21a46:	2100      	movs	r1, #0
		ip_str_len = ip_str_end - &recv_buf[cmd_rsp_idx];
   21a48:	eba0 000b 	sub.w	r0, r0, fp
		recv_buf[++ip_str_len] = 0;
   21a4c:	1c47      	adds	r7, r0, #1
   21a4e:	ab24      	add	r3, sp, #144	; 0x90
   21a50:	19da      	adds	r2, r3, r7
   21a52:	f802 1c80 	strb.w	r1, [r2, #-128]
	err = modem_info_parse(modem_data[info], &recv_buf[cmd_rsp_idx]);
   21a56:	4659      	mov	r1, fp
   21a58:	4650      	mov	r0, sl
   21a5a:	f7ff ff4d 	bl	218f8 <modem_info_parse>
	if (err) {
   21a5e:	4683      	mov	fp, r0
   21a60:	b340      	cbz	r0, 21ab4 <modem_info_string_get+0xf8>
		LOG_ERR("Unable to parse data: %d", err);
   21a62:	2201      	movs	r2, #1
   21a64:	f04f 0000 	mov.w	r0, #0
   21a68:	495d      	ldr	r1, [pc, #372]	; (21be0 <modem_info_string_get+0x224>)
   21a6a:	f362 0007 	bfi	r0, r2, #0, #8
   21a6e:	4a5d      	ldr	r2, [pc, #372]	; (21be4 <modem_info_string_get+0x228>)
   21a70:	1a52      	subs	r2, r2, r1
   21a72:	08d2      	lsrs	r2, r2, #3
   21a74:	f362 108f 	bfi	r0, r2, #6, #10
   21a78:	465a      	mov	r2, fp
   21a7a:	495b      	ldr	r1, [pc, #364]	; (21be8 <modem_info_string_get+0x22c>)
			LOG_ERR("Unable to obtain short: %d", err);
   21a7c:	f012 f8bc 	bl	33bf8 <log_string_sync>
			return err;
   21a80:	e7c7      	b.n	21a12 <modem_info_string_get+0x56>
			++ip_str_end;
   21a82:	3001      	adds	r0, #1
			++ip_cnt;
   21a84:	3501      	adds	r5, #1
		while ((ip_str_end = strstr(ip_str_end, AT_CMD_RSP_DELIM))
   21a86:	4639      	mov	r1, r7
   21a88:	f017 fc4e 	bl	39328 <strstr>
   21a8c:	2800      	cmp	r0, #0
   21a8e:	d1f8      	bne.n	21a82 <modem_info_string_get+0xc6>
		LOG_DBG("Device contains %d IP addresses", ip_cnt);
   21a90:	2304      	movs	r3, #4
   21a92:	4a53      	ldr	r2, [pc, #332]	; (21be0 <modem_info_string_get+0x224>)
   21a94:	f363 0007 	bfi	r0, r3, #0, #8
   21a98:	4b52      	ldr	r3, [pc, #328]	; (21be4 <modem_info_string_get+0x228>)
   21a9a:	4954      	ldr	r1, [pc, #336]	; (21bec <modem_info_string_get+0x230>)
   21a9c:	1a9b      	subs	r3, r3, r2
   21a9e:	08db      	lsrs	r3, r3, #3
   21aa0:	f363 108f 	bfi	r0, r3, #6, #10
   21aa4:	4a52      	ldr	r2, [pc, #328]	; (21bf0 <modem_info_string_get+0x234>)
   21aa6:	462b      	mov	r3, r5
   21aa8:	f012 f8a6 	bl	33bf8 <log_string_sync>
   21aac:	e7b8      	b.n	21a20 <modem_info_string_get+0x64>
	char *ip_str_end = recv_buf;
   21aae:	a804      	add	r0, sp, #16
		while ((ip_str_end = strstr(ip_str_end, AT_CMD_RSP_DELIM))
   21ab0:	4f4a      	ldr	r7, [pc, #296]	; (21bdc <modem_info_string_get+0x220>)
   21ab2:	e7e8      	b.n	21a86 <modem_info_string_get+0xca>
	if (modem_data[info]->data_type == AT_PARAM_TYPE_NUM_SHORT) {
   21ab4:	f89a 300a 	ldrb.w	r3, [sl, #10]
   21ab8:	2b01      	cmp	r3, #1
   21aba:	d122      	bne.n	21b02 <modem_info_string_get+0x146>
		err = at_params_short_get(&m_param_list,
   21abc:	f10d 020a 	add.w	r2, sp, #10
   21ac0:	f89a 1008 	ldrb.w	r1, [sl, #8]
   21ac4:	484b      	ldr	r0, [pc, #300]	; (21bf4 <modem_info_string_get+0x238>)
   21ac6:	f016 ff36 	bl	38936 <at_params_short_get>
		if (err) {
   21aca:	4683      	mov	fp, r0
   21acc:	b168      	cbz	r0, 21aea <modem_info_string_get+0x12e>
			LOG_ERR("Unable to obtain short: %d", err);
   21ace:	2201      	movs	r2, #1
   21ad0:	f04f 0000 	mov.w	r0, #0
   21ad4:	4942      	ldr	r1, [pc, #264]	; (21be0 <modem_info_string_get+0x224>)
   21ad6:	f362 0007 	bfi	r0, r2, #0, #8
   21ada:	4a42      	ldr	r2, [pc, #264]	; (21be4 <modem_info_string_get+0x228>)
   21adc:	1a52      	subs	r2, r2, r1
   21ade:	08d2      	lsrs	r2, r2, #3
   21ae0:	f362 108f 	bfi	r0, r2, #6, #10
   21ae4:	4944      	ldr	r1, [pc, #272]	; (21bf8 <modem_info_string_get+0x23c>)
   21ae6:	465a      	mov	r2, fp
   21ae8:	e7c8      	b.n	21a7c <modem_info_string_get+0xc0>
		err = snprintf(buf, buf_size, "%d", param_value);
   21aea:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   21aee:	4a43      	ldr	r2, [pc, #268]	; (21bfc <modem_info_string_get+0x240>)
   21af0:	4649      	mov	r1, r9
   21af2:	4630      	mov	r0, r6
   21af4:	f010 f8c4 	bl	31c80 <sniprintf>
		if ((err <= 0) || (err > buf_size)) {
   21af8:	4548      	cmp	r0, r9
   21afa:	d916      	bls.n	21b2a <modem_info_string_get+0x16e>
			return -EMSGSIZE;
   21afc:	f06f 0b79 	mvn.w	fp, #121	; 0x79
   21b00:	e787      	b.n	21a12 <modem_info_string_get+0x56>
	} else if (modem_data[info]->data_type == AT_PARAM_TYPE_STRING) {
   21b02:	2b03      	cmp	r3, #3
   21b04:	d111      	bne.n	21b2a <modem_info_string_get+0x16e>
		len = buf_size - out_buf_len;
   21b06:	eba9 0304 	sub.w	r3, r9, r4
   21b0a:	9303      	str	r3, [sp, #12]
		err = at_params_string_get(&m_param_list,
   21b0c:	1932      	adds	r2, r6, r4
   21b0e:	ab03      	add	r3, sp, #12
   21b10:	f89a 1008 	ldrb.w	r1, [sl, #8]
   21b14:	4837      	ldr	r0, [pc, #220]	; (21bf4 <modem_info_string_get+0x238>)
   21b16:	f016 ff3b 	bl	38990 <at_params_string_get>
		if (err != 0) {
   21b1a:	4683      	mov	fp, r0
   21b1c:	2800      	cmp	r0, #0
   21b1e:	f47f af78 	bne.w	21a12 <modem_info_string_get+0x56>
		} else if (len >= buf_size) {
   21b22:	9a03      	ldr	r2, [sp, #12]
   21b24:	454a      	cmp	r2, r9
   21b26:	d2e9      	bcs.n	21afc <modem_info_string_get+0x140>
		buf[len] = 0;
   21b28:	54b0      	strb	r0, [r6, r2]
	if (info == MODEM_INFO_ICCID) {
   21b2a:	f1b8 0f0e 	cmp.w	r8, #14
   21b2e:	d122      	bne.n	21b76 <modem_info_string_get+0x1ba>
   21b30:	4634      	mov	r4, r6
	for (size_t i = 0; i < strlen(buf); i = i + 2) {
   21b32:	4630      	mov	r0, r6
   21b34:	f7f0 faa4 	bl	12080 <strlen>
   21b38:	1ca3      	adds	r3, r4, #2
   21b3a:	1ba4      	subs	r4, r4, r6
   21b3c:	42a0      	cmp	r0, r4
   21b3e:	d810      	bhi.n	21b62 <modem_info_string_get+0x1a6>
		if ((len == ICCID_LEN) &&
   21b40:	9b03      	ldr	r3, [sp, #12]
   21b42:	2b14      	cmp	r3, #20
   21b44:	d106      	bne.n	21b54 <modem_info_string_get+0x198>
   21b46:	7cf3      	ldrb	r3, [r6, #19]
   21b48:	2b46      	cmp	r3, #70	; 0x46
   21b4a:	d103      	bne.n	21b54 <modem_info_string_get+0x198>
			buf[len - 1] = '\0';
   21b4c:	2300      	movs	r3, #0
   21b4e:	74f3      	strb	r3, [r6, #19]
			--len;
   21b50:	2313      	movs	r3, #19
   21b52:	9303      	str	r3, [sp, #12]
	return len <= 0 ? -ENOTSUP : len;
   21b54:	9b03      	ldr	r3, [sp, #12]
   21b56:	2b00      	cmp	r3, #0
   21b58:	bf14      	ite	ne
   21b5a:	469b      	movne	fp, r3
   21b5c:	f06f 0b85 	mvneq.w	fp, #133	; 0x85
   21b60:	e757      	b.n	21a12 <modem_info_string_get+0x56>
		current_char = buf[i];
   21b62:	f813 2c02 	ldrb.w	r2, [r3, #-2]
		buf[i] = next_char;
   21b66:	f813 1c01 	ldrb.w	r1, [r3, #-1]
		buf[i + 1] = current_char;
   21b6a:	461c      	mov	r4, r3
		buf[i] = next_char;
   21b6c:	f803 1c02 	strb.w	r1, [r3, #-2]
		buf[i + 1] = current_char;
   21b70:	f803 2c01 	strb.w	r2, [r3, #-1]
   21b74:	e7dd      	b.n	21b32 <modem_info_string_get+0x176>
	if ((info == MODEM_INFO_IP_ADDRESS) && (ip_cnt > 0)) {
   21b76:	f1b8 0f09 	cmp.w	r8, #9
   21b7a:	d1eb      	bne.n	21b54 <modem_info_string_get+0x198>
   21b7c:	2d00      	cmp	r5, #0
   21b7e:	dde9      	ble.n	21b54 <modem_info_string_get+0x198>
		char *ip_v6_str = strstr(&buf[out_buf_len], " ");
   21b80:	eb06 0b04 	add.w	fp, r6, r4
   21b84:	491e      	ldr	r1, [pc, #120]	; (21c00 <modem_info_string_get+0x244>)
   21b86:	4658      	mov	r0, fp
   21b88:	f017 fbce 	bl	39328 <strstr>
		if (ip_v6_str) {
   21b8c:	b128      	cbz	r0, 21b9a <modem_info_string_get+0x1de>
			*ip_v6_str = 0;
   21b8e:	2200      	movs	r2, #0
   21b90:	7002      	strb	r2, [r0, #0]
			len = strlen(&buf[out_buf_len]);
   21b92:	4658      	mov	r0, fp
   21b94:	f7f0 fa74 	bl	12080 <strlen>
   21b98:	9003      	str	r0, [sp, #12]
		out_buf_len += len;
   21b9a:	9b03      	ldr	r3, [sp, #12]
		if (ip_cnt > 1) {
   21b9c:	2d01      	cmp	r5, #1
		out_buf_len += len;
   21b9e:	441c      	add	r4, r3
		if (ip_cnt > 1) {
   21ba0:	d00c      	beq.n	21bbc <modem_info_string_get+0x200>
			err = snprintf(&buf[out_buf_len],
   21ba2:	eba9 0b04 	sub.w	fp, r9, r4
   21ba6:	4a17      	ldr	r2, [pc, #92]	; (21c04 <modem_info_string_get+0x248>)
   21ba8:	4659      	mov	r1, fp
   21baa:	1930      	adds	r0, r6, r4
   21bac:	f010 f868 	bl	31c80 <sniprintf>
			if ((err <= 0) || (err > (buf_size - out_buf_len))) {
   21bb0:	f1bb 0f01 	cmp.w	fp, #1
   21bb4:	d9a2      	bls.n	21afc <modem_info_string_get+0x140>
			cmd_rsp_idx = ip_str_len + 1;
   21bb6:	1c7b      	adds	r3, r7, #1
			out_buf_len += IP_ADDR_SEPARATOR_LEN;
   21bb8:	3402      	adds	r4, #2
			cmd_rsp_idx = ip_str_len + 1;
   21bba:	9301      	str	r3, [sp, #4]
		if (--ip_cnt) {
   21bbc:	3d01      	subs	r5, #1
   21bbe:	f47f af34 	bne.w	21a2a <modem_info_string_get+0x6e>
			len = out_buf_len;
   21bc2:	9403      	str	r4, [sp, #12]
   21bc4:	e7c6      	b.n	21b54 <modem_info_string_get+0x198>
		return -EINVAL;
   21bc6:	f06f 0b15 	mvn.w	fp, #21
   21bca:	e722      	b.n	21a12 <modem_info_string_get+0x56>
		return -EIO;
   21bcc:	f06f 0b04 	mvn.w	fp, #4
   21bd0:	e71f      	b.n	21a12 <modem_info_string_get+0x56>
			return -EFAULT;
   21bd2:	f06f 0b0d 	mvn.w	fp, #13
   21bd6:	e71c      	b.n	21a12 <modem_info_string_get+0x56>
   21bd8:	0003a880 	.word	0x0003a880
   21bdc:	0003f572 	.word	0x0003f572
   21be0:	00039f60 	.word	0x00039f60
   21be4:	00039fc8 	.word	0x00039fc8
   21be8:	0003ee9c 	.word	0x0003ee9c
   21bec:	0003ee78 	.word	0x0003ee78
   21bf0:	0003ee3c 	.word	0x0003ee3c
   21bf4:	200223a0 	.word	0x200223a0
   21bf8:	0003eeb5 	.word	0x0003eeb5
   21bfc:	0003c661 	.word	0x0003c661
   21c00:	0003ca51 	.word	0x0003ca51
   21c04:	0003eed0 	.word	0x0003eed0

00021c08 <modem_info_init>:
}

int modem_info_init(void)
{
	/* Init at_cmd_parser storage module */
	int err = at_params_list_init(&m_param_list,
   21c08:	210a      	movs	r1, #10
   21c0a:	4801      	ldr	r0, [pc, #4]	; (21c10 <modem_info_init+0x8>)
   21c0c:	f016 bde8 	b.w	387e0 <at_params_list_init>
   21c10:	200223a0 	.word	0x200223a0

00021c14 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
   21c14:	b508      	push	{r3, lr}
		arch_syscall_invoke0(K_SYSCALL_LOG_PANIC);
		return;
	}
#endif
	compiler_barrier();
	z_impl_log_panic();
   21c16:	f7f7 f94f 	bl	18eb8 <z_impl_log_panic>
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
   21c1a:	2301      	movs	r3, #1
   21c1c:	f04f 0000 	mov.w	r0, #0
   21c20:	4a06      	ldr	r2, [pc, #24]	; (21c3c <k_sys_fatal_error_handler+0x28>)
   21c22:	f363 0007 	bfi	r0, r3, #0, #8
   21c26:	4b06      	ldr	r3, [pc, #24]	; (21c40 <k_sys_fatal_error_handler+0x2c>)
   21c28:	4906      	ldr	r1, [pc, #24]	; (21c44 <k_sys_fatal_error_handler+0x30>)
   21c2a:	1a9b      	subs	r3, r3, r2
   21c2c:	08db      	lsrs	r3, r3, #3
   21c2e:	f363 108f 	bfi	r0, r3, #6, #10
   21c32:	f011 ffe1 	bl	33bf8 <log_string_sync>
	sys_arch_reboot(0);
   21c36:	2000      	movs	r0, #0
   21c38:	f7f9 fc78 	bl	1b52c <sys_arch_reboot>

	CODE_UNREACHABLE;
   21c3c:	00039f60 	.word	0x00039f60
   21c40:	00039f98 	.word	0x00039f98
   21c44:	0003f02d 	.word	0x0003f02d

00021c48 <write_at_cmd_with_cme_enabled>:
	return err;
}

static int write_at_cmd_with_cme_enabled(char *cmd, char *buf, size_t buf_len,
					 enum at_cmd_state *state)
{
   21c48:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   21c4c:	4605      	mov	r5, r0
   21c4e:	460e      	mov	r6, r1
   21c50:	4617      	mov	r7, r2
   21c52:	4698      	mov	r8, r3
	err = at_cmd_write("AT+CMEE?", response, sizeof(response), NULL);
   21c54:	220b      	movs	r2, #11
   21c56:	2300      	movs	r3, #0
   21c58:	a901      	add	r1, sp, #4
   21c5a:	4814      	ldr	r0, [pc, #80]	; (21cac <write_at_cmd_with_cme_enabled+0x64>)
   21c5c:	f7fe ff40 	bl	20ae0 <at_cmd_write>
	if (err) {
   21c60:	1e04      	subs	r4, r0, #0
   21c62:	d11f      	bne.n	21ca4 <write_at_cmd_with_cme_enabled+0x5c>
	return (response[CMEE_STATUS] == '1');
   21c64:	f89d 300b 	ldrb.w	r3, [sp, #11]

	if (cmee_was_active < 0) {
		return -EFAULT;
	}

	if (!cmee_was_active) {
   21c68:	2b31      	cmp	r3, #49	; 0x31
   21c6a:	d00b      	beq.n	21c84 <write_at_cmd_with_cme_enabled+0x3c>
	return at_cmd_write("AT+CMEE=1", NULL, 0, NULL);
   21c6c:	4623      	mov	r3, r4
   21c6e:	4622      	mov	r2, r4
   21c70:	4621      	mov	r1, r4
   21c72:	480f      	ldr	r0, [pc, #60]	; (21cb0 <write_at_cmd_with_cme_enabled+0x68>)
   21c74:	f7fe ff34 	bl	20ae0 <at_cmd_write>
		err = cmee_enable();
		if (err) {
   21c78:	4604      	mov	r4, r0
   21c7a:	b120      	cbz	r0, 21c86 <write_at_cmd_with_cme_enabled+0x3e>
			return err;
		}
	}

	return err;
}
   21c7c:	4620      	mov	r0, r4
   21c7e:	b004      	add	sp, #16
   21c80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return (response[CMEE_STATUS] == '1');
   21c84:	2401      	movs	r4, #1
	err = at_cmd_write(cmd, buf, buf_len, state);
   21c86:	4643      	mov	r3, r8
   21c88:	463a      	mov	r2, r7
   21c8a:	4631      	mov	r1, r6
   21c8c:	4628      	mov	r0, r5
   21c8e:	f7fe ff27 	bl	20ae0 <at_cmd_write>
	if (!cmee_was_active) {
   21c92:	b92c      	cbnz	r4, 21ca0 <write_at_cmd_with_cme_enabled+0x58>
	return at_cmd_write("AT+CMEE=0", NULL, 0, NULL);
   21c94:	4623      	mov	r3, r4
   21c96:	4622      	mov	r2, r4
   21c98:	4621      	mov	r1, r4
   21c9a:	4806      	ldr	r0, [pc, #24]	; (21cb4 <write_at_cmd_with_cme_enabled+0x6c>)
   21c9c:	f7fe ff20 	bl	20ae0 <at_cmd_write>
	err = at_cmd_write(cmd, buf, buf_len, state);
   21ca0:	4604      	mov	r4, r0
   21ca2:	e7eb      	b.n	21c7c <write_at_cmd_with_cme_enabled+0x34>
	if (cmee_was_active < 0) {
   21ca4:	daef      	bge.n	21c86 <write_at_cmd_with_cme_enabled+0x3e>
		return -EFAULT;
   21ca6:	f06f 040d 	mvn.w	r4, #13
   21caa:	e7e7      	b.n	21c7c <write_at_cmd_with_cme_enabled+0x34>
   21cac:	0003f0dc 	.word	0x0003f0dc
   21cb0:	0003f0e5 	.word	0x0003f0e5
   21cb4:	0003f0ef 	.word	0x0003f0ef

00021cb8 <translate_error>:
{
   21cb8:	b510      	push	{r4, lr}
	if ((err > 0) && (state == AT_CMD_ERROR_CME)) {
   21cba:	1e04      	subs	r4, r0, #0
   21cbc:	dd0d      	ble.n	21cda <translate_error+0x22>
   21cbe:	2903      	cmp	r1, #3
   21cc0:	d10b      	bne.n	21cda <translate_error+0x22>
		switch (err) {
   21cc2:	f46f 7300 	mvn.w	r3, #512	; 0x200
   21cc6:	18e3      	adds	r3, r4, r3
   21cc8:	2b05      	cmp	r3, #5
   21cca:	d80e      	bhi.n	21cea <translate_error+0x32>
   21ccc:	e8df f003 	tbb	[pc, r3]
   21cd0:	0d07031d 	.word	0x0d07031d
   21cd4:	0a0d      	.short	0x0a0d
			return -EPERM;
   21cd6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
   21cda:	4620      	mov	r0, r4
   21cdc:	bd10      	pop	{r4, pc}
			return -ENOMEM;
   21cde:	f06f 040b 	mvn.w	r4, #11
   21ce2:	e7fa      	b.n	21cda <translate_error+0x22>
			return -EACCES;
   21ce4:	f06f 040c 	mvn.w	r4, #12
   21ce8:	e7f7      	b.n	21cda <translate_error+0x22>
			__ASSERT(false, "Untranslated CME error %d!", err);
   21cea:	234a      	movs	r3, #74	; 0x4a
   21cec:	4a08      	ldr	r2, [pc, #32]	; (21d10 <translate_error+0x58>)
   21cee:	4909      	ldr	r1, [pc, #36]	; (21d14 <translate_error+0x5c>)
   21cf0:	4809      	ldr	r0, [pc, #36]	; (21d18 <translate_error+0x60>)
   21cf2:	f011 fc69 	bl	335c8 <printk>
   21cf6:	4621      	mov	r1, r4
   21cf8:	4808      	ldr	r0, [pc, #32]	; (21d1c <translate_error+0x64>)
   21cfa:	f011 fc65 	bl	335c8 <printk>
   21cfe:	214a      	movs	r1, #74	; 0x4a
   21d00:	4803      	ldr	r0, [pc, #12]	; (21d10 <translate_error+0x58>)
   21d02:	f011 ff62 	bl	33bca <assert_post_action>
   21d06:	4c06      	ldr	r4, [pc, #24]	; (21d20 <translate_error+0x68>)
   21d08:	e7e7      	b.n	21cda <translate_error+0x22>
			return -ENOENT;
   21d0a:	f06f 0401 	mvn.w	r4, #1
   21d0e:	e7e4      	b.n	21cda <translate_error+0x22>
   21d10:	0003f08b 	.word	0x0003f08b
   21d14:	0003fd3b 	.word	0x0003fd3b
   21d18:	0003b77f 	.word	0x0003b77f
   21d1c:	0003f0bf 	.word	0x0003f0bf
   21d20:	baadbaad 	.word	0xbaadbaad

00021d24 <modem_key_mgmt_write>:
}

int modem_key_mgmt_write(nrf_sec_tag_t sec_tag,
			 enum modem_key_mgnt_cred_type cred_type,
			 const void *buf, size_t len)
{
   21d24:	b5f0      	push	{r4, r5, r6, r7, lr}
   21d26:	461d      	mov	r5, r3
   21d28:	b085      	sub	sp, #20
	int err;
	int written;
	enum at_cmd_state state;

	if (buf == NULL || len == 0) {
   21d2a:	4617      	mov	r7, r2
   21d2c:	b322      	cbz	r2, 21d78 <modem_key_mgmt_write+0x54>
   21d2e:	b31b      	cbz	r3, 21d78 <modem_key_mgmt_write+0x54>
		return -EINVAL;
	}

	written = snprintf(scratch_buf, sizeof(scratch_buf), "%s,%d,%d,\"",
   21d30:	4c14      	ldr	r4, [pc, #80]	; (21d84 <modem_key_mgmt_write+0x60>)
   21d32:	e9cd 0100 	strd	r0, r1, [sp]
   21d36:	4b14      	ldr	r3, [pc, #80]	; (21d88 <modem_key_mgmt_write+0x64>)
   21d38:	4a14      	ldr	r2, [pc, #80]	; (21d8c <modem_key_mgmt_write+0x68>)
   21d3a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   21d3e:	4620      	mov	r0, r4
   21d40:	f00f ff9e 	bl	31c80 <sniprintf>

	if (written < 0 || written >= sizeof(scratch_buf)) {
		return -ENOBUFS;
	}

	if (written + len + sizeof("\"") > sizeof(scratch_buf)) {
   21d44:	1946      	adds	r6, r0, r5
   21d46:	1cb3      	adds	r3, r6, #2
   21d48:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   21d4c:	d817      	bhi.n	21d7e <modem_key_mgmt_write+0x5a>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   21d4e:	462a      	mov	r2, r5
   21d50:	4639      	mov	r1, r7
   21d52:	4420      	add	r0, r4
   21d54:	f017 f940 	bl	38fd8 <memcpy>
	memcpy(&scratch_buf[written], buf, len);
	written += len;

	memcpy(&scratch_buf[written], "\"", sizeof("\""));

	err = write_at_cmd_with_cme_enabled(scratch_buf, NULL, 0, &state);
   21d58:	2200      	movs	r2, #0
   21d5a:	4b0d      	ldr	r3, [pc, #52]	; (21d90 <modem_key_mgmt_write+0x6c>)
   21d5c:	4611      	mov	r1, r2
   21d5e:	881b      	ldrh	r3, [r3, #0]
   21d60:	4620      	mov	r0, r4
   21d62:	5333      	strh	r3, [r6, r4]
   21d64:	f10d 030f 	add.w	r3, sp, #15
   21d68:	f7ff ff6e 	bl	21c48 <write_at_cmd_with_cme_enabled>

	return translate_error(err, state);
   21d6c:	f89d 100f 	ldrb.w	r1, [sp, #15]
   21d70:	f7ff ffa2 	bl	21cb8 <translate_error>
}
   21d74:	b005      	add	sp, #20
   21d76:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
   21d78:	f06f 0015 	mvn.w	r0, #21
   21d7c:	e7fa      	b.n	21d74 <modem_key_mgmt_write+0x50>
		return -ENOBUFS;
   21d7e:	f06f 0068 	mvn.w	r0, #104	; 0x68
   21d82:	e7f7      	b.n	21d74 <modem_key_mgmt_write+0x50>
   21d84:	2002807f 	.word	0x2002807f
   21d88:	0003f067 	.word	0x0003f067
   21d8c:	0003f071 	.word	0x0003f071
   21d90:	0003c517 	.word	0x0003c517

00021d94 <modem_key_mgmt_delete>:
	return 0;
}

int modem_key_mgmt_delete(nrf_sec_tag_t sec_tag,
			  enum modem_key_mgnt_cred_type cred_type)
{
   21d94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	int err;
	int written;
	enum at_cmd_state state;

	written = snprintf(scratch_buf, sizeof(scratch_buf), "%s,%d,%d",
   21d96:	4c0b      	ldr	r4, [pc, #44]	; (21dc4 <modem_key_mgmt_delete+0x30>)
   21d98:	e9cd 0100 	strd	r0, r1, [sp]
   21d9c:	4b0a      	ldr	r3, [pc, #40]	; (21dc8 <modem_key_mgmt_delete+0x34>)
   21d9e:	4a0b      	ldr	r2, [pc, #44]	; (21dcc <modem_key_mgmt_delete+0x38>)
   21da0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   21da4:	4620      	mov	r0, r4
   21da6:	f00f ff6b 	bl	31c80 <sniprintf>

	if (written < 0 || written >= sizeof(scratch_buf)) {
		return -ENOBUFS;
	}

	err = write_at_cmd_with_cme_enabled(scratch_buf, NULL, 0, &state);
   21daa:	2200      	movs	r2, #0
   21dac:	f10d 030f 	add.w	r3, sp, #15
   21db0:	4611      	mov	r1, r2
   21db2:	4620      	mov	r0, r4
   21db4:	f7ff ff48 	bl	21c48 <write_at_cmd_with_cme_enabled>

	return translate_error(err, state);
   21db8:	f89d 100f 	ldrb.w	r1, [sp, #15]
   21dbc:	f7ff ff7c 	bl	21cb8 <translate_error>
}
   21dc0:	b004      	add	sp, #16
   21dc2:	bd10      	pop	{r4, pc}
   21dc4:	2002807f 	.word	0x2002807f
   21dc8:	0003f05d 	.word	0x0003f05d
   21dcc:	0003f054 	.word	0x0003f054

00021dd0 <new_date_time_get>:

	return 0;
}

static void new_date_time_get(void)
{
   21dd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int err;

	while (true) {
		k_sem_take(&time_fetch_sem, K_FOREVER);

		LOG_DBG("Updating date time UTC...");
   21dd4:	4ba9      	ldr	r3, [pc, #676]	; (2207c <new_date_time_get+0x2ac>)
   21dd6:	4caa      	ldr	r4, [pc, #680]	; (22080 <new_date_time_get+0x2b0>)
   21dd8:	4daa      	ldr	r5, [pc, #680]	; (22084 <new_date_time_get+0x2b4>)
   21dda:	1ae4      	subs	r4, r4, r3
{
   21ddc:	b0ab      	sub	sp, #172	; 0xac
		LOG_DBG("Updating date time UTC...");
   21dde:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   21de2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   21de6:	48a8      	ldr	r0, [pc, #672]	; (22088 <new_date_time_get+0x2b8>)
   21de8:	f00c f944 	bl	2e074 <z_impl_k_sem_take>
   21dec:	f8bd 3040 	ldrh.w	r3, [sp, #64]	; 0x40
   21df0:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
   21df4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21df8:	f043 0304 	orr.w	r3, r3, #4
   21dfc:	f363 0207 	bfi	r2, r3, #0, #8
   21e00:	b293      	uxth	r3, r2
   21e02:	f364 138f 	bfi	r3, r4, #6, #10
	if (time_aux.last_date_time_update == 0 ||
   21e06:	4ea1      	ldr	r6, [pc, #644]	; (2208c <new_date_time_get+0x2bc>)
		LOG_DBG("Updating date time UTC...");
   21e08:	b298      	uxth	r0, r3
   21e0a:	462a      	mov	r2, r5
   21e0c:	49a0      	ldr	r1, [pc, #640]	; (22090 <new_date_time_get+0x2c0>)
   21e0e:	f8ad 3040 	strh.w	r3, [sp, #64]	; 0x40
   21e12:	f011 fef1 	bl	33bf8 <log_string_sync>
	if (time_aux.last_date_time_update == 0 ||
   21e16:	68b3      	ldr	r3, [r6, #8]
   21e18:	b123      	cbz	r3, 21e24 <new_date_time_get+0x54>
   21e1a:	e9d6 2300 	ldrd	r2, r3, [r6]
   21e1e:	4313      	orrs	r3, r2
   21e20:	f040 80f6 	bne.w	22010 <new_date_time_get+0x240>
		LOG_DBG("Date time never set");
   21e24:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
   21e28:	f8bd 2038 	ldrh.w	r2, [sp, #56]	; 0x38
   21e2c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21e30:	f043 0304 	orr.w	r3, r3, #4
   21e34:	f363 0207 	bfi	r2, r3, #0, #8
   21e38:	b293      	uxth	r3, r2
   21e3a:	f364 138f 	bfi	r3, r4, #6, #10
   21e3e:	4a95      	ldr	r2, [pc, #596]	; (22094 <new_date_time_get+0x2c4>)
   21e40:	4995      	ldr	r1, [pc, #596]	; (22098 <new_date_time_get+0x2c8>)
   21e42:	f8ad 3038 	strh.w	r3, [sp, #56]	; 0x38
		LOG_DBG("Current date time too old");
   21e46:	b298      	uxth	r0, r3
   21e48:	f011 fed6 	bl	33bf8 <log_string_sync>
			LOG_DBG("Time successfully obtained");
			initial_valid_time = true;
			continue;
		}

		LOG_DBG("Current time not valid");
   21e4c:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
   21e50:	f8bd 2048 	ldrh.w	r2, [sp, #72]	; 0x48
   21e54:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21e58:	f043 0304 	orr.w	r3, r3, #4
   21e5c:	f363 0207 	bfi	r2, r3, #0, #8
   21e60:	b293      	uxth	r3, r2
   21e62:	f364 138f 	bfi	r3, r4, #6, #10
   21e66:	b298      	uxth	r0, r3
   21e68:	462a      	mov	r2, r5
   21e6a:	498c      	ldr	r1, [pc, #560]	; (2209c <new_date_time_get+0x2cc>)
   21e6c:	f8ad 3048 	strh.w	r3, [sp, #72]	; 0x48
   21e70:	f011 fec2 	bl	33bf8 <log_string_sync>

#if defined(CONFIG_DATE_TIME_MODEM)
		LOG_DBG("Fallback on cellular network time");
   21e74:	f8bd 304c 	ldrh.w	r3, [sp, #76]	; 0x4c
   21e78:	f8bd 204c 	ldrh.w	r2, [sp, #76]	; 0x4c
   21e7c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21e80:	f043 0304 	orr.w	r3, r3, #4
   21e84:	f363 0207 	bfi	r2, r3, #0, #8
   21e88:	b293      	uxth	r3, r2
   21e8a:	f364 138f 	bfi	r3, r4, #6, #10
   21e8e:	b298      	uxth	r0, r3
   21e90:	462a      	mov	r2, r5
   21e92:	4983      	ldr	r1, [pc, #524]	; (220a0 <new_date_time_get+0x2d0>)
   21e94:	f8ad 304c 	strh.w	r3, [sp, #76]	; 0x4c
   21e98:	f011 feae 	bl	33bf8 <log_string_sync>
	err = at_cmd_write(AT_CMD_MODEM_DATE_TIME, buf, sizeof(buf), NULL);
   21e9c:	2300      	movs	r3, #0
   21e9e:	2221      	movs	r2, #33	; 0x21
   21ea0:	a918      	add	r1, sp, #96	; 0x60
   21ea2:	4880      	ldr	r0, [pc, #512]	; (220a4 <new_date_time_get+0x2d4>)
   21ea4:	f7fe fe1c 	bl	20ae0 <at_cmd_write>
	if (err) {
   21ea8:	4606      	mov	r6, r0
   21eaa:	2800      	cmp	r0, #0
   21eac:	f000 811e 	beq.w	220ec <new_date_time_get+0x31c>
		LOG_DBG("Could not get cellular network time, error: %d", err);
   21eb0:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   21eb4:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
   21eb8:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21ebc:	f043 0304 	orr.w	r3, r3, #4
   21ec0:	f363 0207 	bfi	r2, r3, #0, #8
   21ec4:	b293      	uxth	r3, r2
   21ec6:	f364 138f 	bfi	r3, r4, #6, #10
   21eca:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
   21ece:	4a76      	ldr	r2, [pc, #472]	; (220a8 <new_date_time_get+0x2d8>)
   21ed0:	4603      	mov	r3, r0
   21ed2:	4976      	ldr	r1, [pc, #472]	; (220ac <new_date_time_get+0x2dc>)
   21ed4:	f8bd 002c 	ldrh.w	r0, [sp, #44]	; 0x2c
   21ed8:	f011 fe8e 	bl	33bf8 <log_string_sync>
			LOG_DBG("Time from cellular network obtained");
			initial_valid_time = true;
			continue;
		}

		LOG_DBG("Not getting cellular network time");
   21edc:	f029 033f 	bic.w	r3, r9, #63	; 0x3f
   21ee0:	f043 0304 	orr.w	r3, r3, #4
   21ee4:	f363 0907 	bfi	r9, r3, #0, #8
   21ee8:	f364 198f 	bfi	r9, r4, #6, #10
   21eec:	462a      	mov	r2, r5
   21eee:	4970      	ldr	r1, [pc, #448]	; (220b0 <new_date_time_get+0x2e0>)
   21ef0:	4648      	mov	r0, r9
   21ef2:	f011 fe81 	bl	33bf8 <log_string_sync>
#endif
		LOG_DBG("Fallback on NTP server");
   21ef6:	f02a 033f 	bic.w	r3, sl, #63	; 0x3f
   21efa:	f043 0304 	orr.w	r3, r3, #4
   21efe:	f363 0a07 	bfi	sl, r3, #0, #8
   21f02:	f364 1a8f 	bfi	sl, r4, #6, #10
   21f06:	462a      	mov	r2, r5
   21f08:	496a      	ldr	r1, [pc, #424]	; (220b4 <new_date_time_get+0x2e4>)
   21f0a:	4650      	mov	r0, sl
   21f0c:	f011 fe74 	bl	33bf8 <log_string_sync>
	for (int i = 0; i < ARRAY_SIZE(servers); i++) {
   21f10:	4b69      	ldr	r3, [pc, #420]	; (220b8 <new_date_time_get+0x2e8>)
   21f12:	461f      	mov	r7, r3
   21f14:	2300      	movs	r3, #0
   21f16:	9315      	str	r3, [sp, #84]	; 0x54
	hints.ai_socktype = SOCK_DGRAM;
   21f18:	2302      	movs	r3, #2
   21f1a:	2101      	movs	r1, #1
	hints.ai_family = AF_INET;
   21f1c:	4a67      	ldr	r2, [pc, #412]	; (220bc <new_date_time_get+0x2ec>)
	hints.ai_socktype = SOCK_DGRAM;
   21f1e:	e9c2 1302 	strd	r1, r3, [r2, #8]
	hints.ai_protocol = 0;
   21f22:	2300      	movs	r3, #0
   21f24:	6113      	str	r3, [r2, #16]
	if (server->addr == NULL) {
   21f26:	687b      	ldr	r3, [r7, #4]
   21f28:	2b00      	cmp	r3, #0
   21f2a:	f040 816d 	bne.w	22208 <new_date_time_get+0x438>
	return zsock_getaddrinfo(host, service, hints, res);
   21f2e:	463b      	mov	r3, r7
   21f30:	4963      	ldr	r1, [pc, #396]	; (220c0 <new_date_time_get+0x2f0>)
   21f32:	3304      	adds	r3, #4
   21f34:	6838      	ldr	r0, [r7, #0]
   21f36:	f011 fedc 	bl	33cf2 <zsock_getaddrinfo>
		if (err) {
   21f3a:	4606      	mov	r6, r0
   21f3c:	2800      	cmp	r0, #0
   21f3e:	f000 8177 	beq.w	22230 <new_date_time_get+0x460>
			LOG_ERR("getaddrinfo, error: %d", err);
   21f42:	f8bd 300c 	ldrh.w	r3, [sp, #12]
   21f46:	495f      	ldr	r1, [pc, #380]	; (220c4 <new_date_time_get+0x2f4>)
   21f48:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
   21f4c:	f042 0201 	orr.w	r2, r2, #1
   21f50:	f362 0307 	bfi	r3, r2, #0, #8
   21f54:	b29b      	uxth	r3, r3
   21f56:	f364 138f 	bfi	r3, r4, #6, #10
   21f5a:	4602      	mov	r2, r0
   21f5c:	b298      	uxth	r0, r3
   21f5e:	f8ad 300c 	strh.w	r3, [sp, #12]
   21f62:	f011 fe49 	bl	33bf8 <log_string_sync>
			LOG_DBG("Not getting time from NTP server %s, error %d",
   21f66:	f8bd 301c 	ldrh.w	r3, [sp, #28]
   21f6a:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
   21f6e:	f042 0204 	orr.w	r2, r2, #4
   21f72:	f362 0307 	bfi	r3, r2, #0, #8
   21f76:	b29b      	uxth	r3, r3
   21f78:	f364 138f 	bfi	r3, r4, #6, #10
   21f7c:	f8ad 301c 	strh.w	r3, [sp, #28]
   21f80:	463b      	mov	r3, r7
   21f82:	f853 0b08 	ldr.w	r0, [r3], #8
   21f86:	461f      	mov	r7, r3
   21f88:	f011 fe48 	bl	33c1c <log_strdup>
   21f8c:	4a4e      	ldr	r2, [pc, #312]	; (220c8 <new_date_time_get+0x2f8>)
   21f8e:	4603      	mov	r3, r0
   21f90:	494e      	ldr	r1, [pc, #312]	; (220cc <new_date_time_get+0x2fc>)
   21f92:	f8bd 001c 	ldrh.w	r0, [sp, #28]
   21f96:	9600      	str	r6, [sp, #0]
   21f98:	f011 fe2e 	bl	33bf8 <log_string_sync>
			LOG_DBG("Trying another address...");
   21f9c:	f8bd 3020 	ldrh.w	r3, [sp, #32]
   21fa0:	f8bd 2020 	ldrh.w	r2, [sp, #32]
   21fa4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21fa8:	f043 0304 	orr.w	r3, r3, #4
   21fac:	f363 0207 	bfi	r2, r3, #0, #8
   21fb0:	b293      	uxth	r3, r2
   21fb2:	f364 138f 	bfi	r3, r4, #6, #10
   21fb6:	b298      	uxth	r0, r3
   21fb8:	4a43      	ldr	r2, [pc, #268]	; (220c8 <new_date_time_get+0x2f8>)
   21fba:	4945      	ldr	r1, [pc, #276]	; (220d0 <new_date_time_get+0x300>)
   21fbc:	f8ad 3020 	strh.w	r3, [sp, #32]
   21fc0:	f011 fe1a 	bl	33bf8 <log_string_sync>
	for (int i = 0; i < ARRAY_SIZE(servers); i++) {
   21fc4:	9b15      	ldr	r3, [sp, #84]	; 0x54
   21fc6:	3301      	adds	r3, #1
   21fc8:	2b05      	cmp	r3, #5
   21fca:	9315      	str	r3, [sp, #84]	; 0x54
   21fcc:	d1a4      	bne.n	21f18 <new_date_time_get+0x148>
	LOG_ERR("Not getting time from any NTP server");
   21fce:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   21fd2:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
   21fd6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   21fda:	f043 0301 	orr.w	r3, r3, #1
   21fde:	f363 0207 	bfi	r2, r3, #0, #8
   21fe2:	b293      	uxth	r3, r2
   21fe4:	f364 138f 	bfi	r3, r4, #6, #10
   21fe8:	b298      	uxth	r0, r3
   21fea:	493a      	ldr	r1, [pc, #232]	; (220d4 <new_date_time_get+0x304>)
   21fec:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
   21ff0:	f011 fe02 	bl	33bf8 <log_string_sync>
			LOG_DBG("Time from NTP server obtained");
			initial_valid_time = true;
			continue;
		}

		LOG_DBG("Not getting time from NTP server");
   21ff4:	f028 033f 	bic.w	r3, r8, #63	; 0x3f
   21ff8:	f043 0304 	orr.w	r3, r3, #4
   21ffc:	f363 0807 	bfi	r8, r3, #0, #8
   22000:	f364 188f 	bfi	r8, r4, #6, #10
   22004:	462a      	mov	r2, r5
   22006:	4934      	ldr	r1, [pc, #208]	; (220d8 <new_date_time_get+0x308>)
   22008:	4640      	mov	r0, r8
   2200a:	f011 fdf5 	bl	33bf8 <log_string_sync>
   2200e:	e6e8      	b.n	21de2 <new_date_time_get+0x12>
	if ((k_uptime_get() - time_aux.last_date_time_update) >
   22010:	f016 fd1a 	bl	38a48 <k_uptime_get>
   22014:	68b3      	ldr	r3, [r6, #8]
   22016:	4a31      	ldr	r2, [pc, #196]	; (220dc <new_date_time_get+0x30c>)
   22018:	1ac6      	subs	r6, r0, r3
   2201a:	eb61 77e3 	sbc.w	r7, r1, r3, asr #31
   2201e:	2300      	movs	r3, #0
   22020:	42b2      	cmp	r2, r6
   22022:	41bb      	sbcs	r3, r7
   22024:	da11      	bge.n	2204a <new_date_time_get+0x27a>
		LOG_DBG("Current date time too old");
   22026:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
   2202a:	f8bd 203c 	ldrh.w	r2, [sp, #60]	; 0x3c
   2202e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   22032:	f043 0304 	orr.w	r3, r3, #4
   22036:	f363 0207 	bfi	r2, r3, #0, #8
   2203a:	b293      	uxth	r3, r2
   2203c:	f364 138f 	bfi	r3, r4, #6, #10
   22040:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
   22044:	4a13      	ldr	r2, [pc, #76]	; (22094 <new_date_time_get+0x2c4>)
   22046:	4926      	ldr	r1, [pc, #152]	; (220e0 <new_date_time_get+0x310>)
   22048:	e6fd      	b.n	21e46 <new_date_time_get+0x76>
			LOG_DBG("Time successfully obtained");
   2204a:	f8bd 3044 	ldrh.w	r3, [sp, #68]	; 0x44
   2204e:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
   22052:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   22056:	f043 0304 	orr.w	r3, r3, #4
   2205a:	f363 0207 	bfi	r2, r3, #0, #8
   2205e:	b293      	uxth	r3, r2
   22060:	462a      	mov	r2, r5
   22062:	f364 138f 	bfi	r3, r4, #6, #10
   22066:	491f      	ldr	r1, [pc, #124]	; (220e4 <new_date_time_get+0x314>)
   22068:	f8ad 3044 	strh.w	r3, [sp, #68]	; 0x44
			LOG_DBG("Time from cellular network obtained");
   2206c:	b298      	uxth	r0, r3
			LOG_DBG("Time from NTP server obtained");
   2206e:	f011 fdc3 	bl	33bf8 <log_string_sync>
			initial_valid_time = true;
   22072:	2201      	movs	r2, #1
   22074:	4b1c      	ldr	r3, [pc, #112]	; (220e8 <new_date_time_get+0x318>)
   22076:	701a      	strb	r2, [r3, #0]
			continue;
   22078:	e6b3      	b.n	21de2 <new_date_time_get+0x12>
   2207a:	bf00      	nop
   2207c:	00039f60 	.word	0x00039f60
   22080:	00039f90 	.word	0x00039f90
   22084:	0003f141 	.word	0x0003f141
   22088:	20020704 	.word	0x20020704
   2208c:	200209f8 	.word	0x200209f8
   22090:	0003f1c1 	.word	0x0003f1c1
   22094:	0003f12e 	.word	0x0003f12e
   22098:	0003f1df 	.word	0x0003f1df
   2209c:	0003f234 	.word	0x0003f234
   220a0:	0003f24f 	.word	0x0003f24f
   220a4:	0003eeec 	.word	0x0003eeec
   220a8:	0003f0f9 	.word	0x0003f0f9
   220ac:	0003f275 	.word	0x0003f275
   220b0:	0003f305 	.word	0x0003f305
   220b4:	0003f32b 	.word	0x0003f32b
   220b8:	200201f8 	.word	0x200201f8
   220bc:	20022460 	.word	0x20022460
   220c0:	0003f346 	.word	0x0003f346
   220c4:	0003f34a 	.word	0x0003f34a
   220c8:	0003f11a 	.word	0x0003f11a
   220cc:	0003f3c5 	.word	0x0003f3c5
   220d0:	0003f3f7 	.word	0x0003f3f7
   220d4:	0003f460 	.word	0x0003f460
   220d8:	0003f485 	.word	0x0003f485
   220dc:	0036ee80 	.word	0x0036ee80
   220e0:	0003f1f7 	.word	0x0003f1f7
   220e4:	0003f215 	.word	0x0003f215
   220e8:	2002907f 	.word	0x2002907f
	LOG_DBG("Response from modem: %s", log_strdup(buf));
   220ec:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   220f0:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
   220f4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   220f8:	f043 0304 	orr.w	r3, r3, #4
   220fc:	f363 0207 	bfi	r2, r3, #0, #8
   22100:	b293      	uxth	r3, r2
   22102:	f364 138f 	bfi	r3, r4, #6, #10
	buf[AT_CMD_MODEM_DATE_TIME_RESPONSE_LEN - 4] = '\0';
   22106:	f88d 007c 	strb.w	r0, [sp, #124]	; 0x7c
	LOG_DBG("Response from modem: %s", log_strdup(buf));
   2210a:	a818      	add	r0, sp, #96	; 0x60
   2210c:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
   22110:	f011 fd84 	bl	33c1c <log_strdup>
   22114:	4a7f      	ldr	r2, [pc, #508]	; (22314 <new_date_time_get+0x544>)
   22116:	4603      	mov	r3, r0
   22118:	497f      	ldr	r1, [pc, #508]	; (22318 <new_date_time_get+0x548>)
   2211a:	f8bd 0030 	ldrh.w	r0, [sp, #48]	; 0x30
   2211e:	f011 fd6b 	bl	33bf8 <log_string_sync>
		if (buf[i] == '/' || buf[i] == ',' || buf[i] == ':') {
   22122:	f244 0109 	movw	r1, #16393	; 0x4009
			buf[i] = ' ';
   22126:	2020      	movs	r0, #32
   22128:	aa18      	add	r2, sp, #96	; 0x60
		if (buf[i] == '/' || buf[i] == ',' || buf[i] == ':') {
   2212a:	f812 3b01 	ldrb.w	r3, [r2], #1
   2212e:	3b2c      	subs	r3, #44	; 0x2c
   22130:	b2db      	uxtb	r3, r3
   22132:	2b0e      	cmp	r3, #14
   22134:	d805      	bhi.n	22142 <new_date_time_get+0x372>
   22136:	fa21 f303 	lsr.w	r3, r1, r3
   2213a:	07df      	lsls	r7, r3, #31
			buf[i] = ' ';
   2213c:	bf48      	it	mi
   2213e:	f802 0c01 	strbmi.w	r0, [r2, #-1]
	for (int i = 0; i < AT_CMD_MODEM_DATE_TIME_RESPONSE_LEN; i++) {
   22142:	3601      	adds	r6, #1
   22144:	2e20      	cmp	r6, #32
   22146:	d1f0      	bne.n	2212a <new_date_time_get+0x35a>
	char *ptr_index = &buf[8];
   22148:	a81a      	add	r0, sp, #104	; 0x68
	date_time.tm_year = strtol(ptr_index, &ptr_index, base) + 2000 - 1900;
   2214a:	220a      	movs	r2, #10
   2214c:	a917      	add	r1, sp, #92	; 0x5c
	char *ptr_index = &buf[8];
   2214e:	9017      	str	r0, [sp, #92]	; 0x5c
	date_time.tm_year = strtol(ptr_index, &ptr_index, base) + 2000 - 1900;
   22150:	f010 f852 	bl	321f8 <strtol>
   22154:	3064      	adds	r0, #100	; 0x64
   22156:	9026      	str	r0, [sp, #152]	; 0x98
	date_time.tm_mon = strtol(ptr_index, &ptr_index, base) - 1;
   22158:	220a      	movs	r2, #10
   2215a:	a917      	add	r1, sp, #92	; 0x5c
   2215c:	9817      	ldr	r0, [sp, #92]	; 0x5c
   2215e:	f010 f84b 	bl	321f8 <strtol>
   22162:	3801      	subs	r0, #1
   22164:	9025      	str	r0, [sp, #148]	; 0x94
	date_time.tm_mday = strtol(ptr_index, &ptr_index, base);
   22166:	220a      	movs	r2, #10
   22168:	a917      	add	r1, sp, #92	; 0x5c
   2216a:	9817      	ldr	r0, [sp, #92]	; 0x5c
   2216c:	f010 f844 	bl	321f8 <strtol>
	date_time.tm_hour = strtol(ptr_index, &ptr_index, base);
   22170:	220a      	movs	r2, #10
	date_time.tm_mday = strtol(ptr_index, &ptr_index, base);
   22172:	9024      	str	r0, [sp, #144]	; 0x90
	date_time.tm_hour = strtol(ptr_index, &ptr_index, base);
   22174:	a917      	add	r1, sp, #92	; 0x5c
   22176:	9817      	ldr	r0, [sp, #92]	; 0x5c
   22178:	f010 f83e 	bl	321f8 <strtol>
	date_time.tm_min = strtol(ptr_index, &ptr_index, base);
   2217c:	220a      	movs	r2, #10
	date_time.tm_hour = strtol(ptr_index, &ptr_index, base);
   2217e:	9023      	str	r0, [sp, #140]	; 0x8c
	date_time.tm_min = strtol(ptr_index, &ptr_index, base);
   22180:	a917      	add	r1, sp, #92	; 0x5c
   22182:	9817      	ldr	r0, [sp, #92]	; 0x5c
   22184:	f010 f838 	bl	321f8 <strtol>
	date_time.tm_sec = strtol(ptr_index, &ptr_index, base);
   22188:	220a      	movs	r2, #10
	date_time.tm_min = strtol(ptr_index, &ptr_index, base);
   2218a:	9022      	str	r0, [sp, #136]	; 0x88
	date_time.tm_sec = strtol(ptr_index, &ptr_index, base);
   2218c:	a917      	add	r1, sp, #92	; 0x5c
   2218e:	9817      	ldr	r0, [sp, #92]	; 0x5c
   22190:	f010 f832 	bl	321f8 <strtol>
	if (date_time.tm_year == MODEM_TIME_DEFAULT) {
   22194:	9b26      	ldr	r3, [sp, #152]	; 0x98
	date_time.tm_sec = strtol(ptr_index, &ptr_index, base);
   22196:	9021      	str	r0, [sp, #132]	; 0x84
	if (date_time.tm_year == MODEM_TIME_DEFAULT) {
   22198:	2b73      	cmp	r3, #115	; 0x73
   2219a:	d114      	bne.n	221c6 <new_date_time_get+0x3f6>
		LOG_DBG("Modem time never set");
   2219c:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
   221a0:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
   221a4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   221a8:	f043 0304 	orr.w	r3, r3, #4
   221ac:	f363 0207 	bfi	r2, r3, #0, #8
   221b0:	b293      	uxth	r3, r2
   221b2:	f364 138f 	bfi	r3, r4, #6, #10
   221b6:	4a57      	ldr	r2, [pc, #348]	; (22314 <new_date_time_get+0x544>)
   221b8:	4958      	ldr	r1, [pc, #352]	; (2231c <new_date_time_get+0x54c>)
   221ba:	b298      	uxth	r0, r3
   221bc:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
   221c0:	f011 fd1a 	bl	33bf8 <log_string_sync>
		if (err == 0) {
   221c4:	e68a      	b.n	21edc <new_date_time_get+0x10c>
	time_aux.date_time_utc = (s64_t)timeutil_timegm64(&date_time) * 1000;
   221c6:	a821      	add	r0, sp, #132	; 0x84
   221c8:	f7f6 fc32 	bl	18a30 <timeutil_timegm64>
   221cc:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
   221d0:	fba0 230c 	umull	r2, r3, r0, ip
   221d4:	fb0c 3301 	mla	r3, ip, r1, r3
   221d8:	4e51      	ldr	r6, [pc, #324]	; (22320 <new_date_time_get+0x550>)
   221da:	e9c6 2300 	strd	r2, r3, [r6]
	time_aux.last_date_time_update = k_uptime_get();
   221de:	f016 fc33 	bl	38a48 <k_uptime_get>
			LOG_DBG("Time from cellular network obtained");
   221e2:	f8bd 3050 	ldrh.w	r3, [sp, #80]	; 0x50
   221e6:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
   221ea:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   221ee:	f043 0304 	orr.w	r3, r3, #4
   221f2:	f363 0207 	bfi	r2, r3, #0, #8
   221f6:	b293      	uxth	r3, r2
   221f8:	f364 138f 	bfi	r3, r4, #6, #10
	time_aux.last_date_time_update = k_uptime_get();
   221fc:	60b0      	str	r0, [r6, #8]
			LOG_DBG("Time from cellular network obtained");
   221fe:	f8ad 3050 	strh.w	r3, [sp, #80]	; 0x50
   22202:	462a      	mov	r2, r5
   22204:	4947      	ldr	r1, [pc, #284]	; (22324 <new_date_time_get+0x554>)
   22206:	e731      	b.n	2206c <new_date_time_get+0x29c>
		LOG_DBG("Server address already obtained, skipping DNS lookup");
   22208:	f8bd 3010 	ldrh.w	r3, [sp, #16]
   2220c:	f8bd 2010 	ldrh.w	r2, [sp, #16]
   22210:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   22214:	f043 0304 	orr.w	r3, r3, #4
   22218:	f363 0207 	bfi	r2, r3, #0, #8
   2221c:	b293      	uxth	r3, r2
   2221e:	f364 138f 	bfi	r3, r4, #6, #10
   22222:	4a41      	ldr	r2, [pc, #260]	; (22328 <new_date_time_get+0x558>)
   22224:	4941      	ldr	r1, [pc, #260]	; (2232c <new_date_time_get+0x55c>)
   22226:	b298      	uxth	r0, r3
   22228:	f8ad 3010 	strh.w	r3, [sp, #16]
   2222c:	f011 fce4 	bl	33bf8 <log_string_sync>
	err = sntp_init(&sntp_ctx, server->addr->ai_addr,
   22230:	687b      	ldr	r3, [r7, #4]
   22232:	a821      	add	r0, sp, #132	; 0x84
   22234:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   22238:	f011 fd27 	bl	33c8a <sntp_init>
	if (err) {
   2223c:	4606      	mov	r6, r0
   2223e:	2800      	cmp	r0, #0
   22240:	d04e      	beq.n	222e0 <new_date_time_get+0x510>
		LOG_ERR("sntp_init, error: %d", err);
   22242:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   22246:	493a      	ldr	r1, [pc, #232]	; (22330 <new_date_time_get+0x560>)
   22248:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
   2224c:	f042 0201 	orr.w	r2, r2, #1
   22250:	f362 0307 	bfi	r3, r2, #0, #8
   22254:	4602      	mov	r2, r0
   22256:	b29b      	uxth	r3, r3
   22258:	f364 138f 	bfi	r3, r4, #6, #10
   2225c:	f8ad 3014 	strh.w	r3, [sp, #20]
		LOG_ERR("sntp_query, error: %d", err);
   22260:	b298      	uxth	r0, r3
   22262:	f011 fcc9 	bl	33bf8 <log_string_sync>
	sntp_close(&sntp_ctx);
   22266:	a821      	add	r0, sp, #132	; 0x84
   22268:	f011 fd3e 	bl	33ce8 <sntp_close>
		if (err) {
   2226c:	2e00      	cmp	r6, #0
   2226e:	f47f ae7a 	bne.w	21f66 <new_date_time_get+0x196>
		LOG_DBG("Got time response from NTP server %s",
   22272:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
   22276:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   2227a:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
   2227e:	f043 0304 	orr.w	r3, r3, #4
   22282:	f363 0207 	bfi	r2, r3, #0, #8
   22286:	b293      	uxth	r3, r2
   22288:	f364 138f 	bfi	r3, r4, #6, #10
   2228c:	9a15      	ldr	r2, [sp, #84]	; 0x54
   2228e:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
   22292:	4b28      	ldr	r3, [pc, #160]	; (22334 <new_date_time_get+0x564>)
		time_aux.date_time_utc = (s64_t)sntp_time.seconds * 1000;
   22294:	4e22      	ldr	r6, [pc, #136]	; (22320 <new_date_time_get+0x550>)
		LOG_DBG("Got time response from NTP server %s",
   22296:	f853 0032 	ldr.w	r0, [r3, r2, lsl #3]
   2229a:	f011 fcbf 	bl	33c1c <log_strdup>
   2229e:	4a26      	ldr	r2, [pc, #152]	; (22338 <new_date_time_get+0x568>)
   222a0:	4603      	mov	r3, r0
   222a2:	4926      	ldr	r1, [pc, #152]	; (2233c <new_date_time_get+0x56c>)
   222a4:	f8bd 0024 	ldrh.w	r0, [sp, #36]	; 0x24
   222a8:	f011 fca6 	bl	33bf8 <log_string_sync>
		time_aux.date_time_utc = (s64_t)sntp_time.seconds * 1000;
   222ac:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   222b0:	4b23      	ldr	r3, [pc, #140]	; (22340 <new_date_time_get+0x570>)
   222b2:	681a      	ldr	r2, [r3, #0]
   222b4:	6858      	ldr	r0, [r3, #4]
   222b6:	fba2 2301 	umull	r2, r3, r2, r1
   222ba:	fb01 3300 	mla	r3, r1, r0, r3
   222be:	e9c6 2300 	strd	r2, r3, [r6]
		time_aux.last_date_time_update = k_uptime_get();
   222c2:	f016 fbc1 	bl	38a48 <k_uptime_get>
			LOG_DBG("Time from NTP server obtained");
   222c6:	f02b 033f 	bic.w	r3, fp, #63	; 0x3f
   222ca:	f043 0304 	orr.w	r3, r3, #4
   222ce:	f363 0b07 	bfi	fp, r3, #0, #8
   222d2:	f364 1b8f 	bfi	fp, r4, #6, #10
		time_aux.last_date_time_update = k_uptime_get();
   222d6:	60b0      	str	r0, [r6, #8]
			LOG_DBG("Time from NTP server obtained");
   222d8:	462a      	mov	r2, r5
   222da:	491a      	ldr	r1, [pc, #104]	; (22344 <new_date_time_get+0x574>)
   222dc:	4658      	mov	r0, fp
   222de:	e6c6      	b.n	2206e <new_date_time_get+0x29e>
	err = sntp_query(&sntp_ctx, timeout, time);
   222e0:	4a17      	ldr	r2, [pc, #92]	; (22340 <new_date_time_get+0x570>)
   222e2:	f241 3188 	movw	r1, #5000	; 0x1388
   222e6:	a821      	add	r0, sp, #132	; 0x84
   222e8:	f7f0 fa56 	bl	12798 <sntp_query>
	if (err) {
   222ec:	4606      	mov	r6, r0
   222ee:	2800      	cmp	r0, #0
   222f0:	d0b9      	beq.n	22266 <new_date_time_get+0x496>
		LOG_ERR("sntp_query, error: %d", err);
   222f2:	f8bd 3018 	ldrh.w	r3, [sp, #24]
   222f6:	4914      	ldr	r1, [pc, #80]	; (22348 <new_date_time_get+0x578>)
   222f8:	f023 023f 	bic.w	r2, r3, #63	; 0x3f
   222fc:	f042 0201 	orr.w	r2, r2, #1
   22300:	f362 0307 	bfi	r3, r2, #0, #8
   22304:	b29b      	uxth	r3, r3
   22306:	f364 138f 	bfi	r3, r4, #6, #10
   2230a:	f8ad 3018 	strh.w	r3, [sp, #24]
   2230e:	4602      	mov	r2, r0
   22310:	e7a6      	b.n	22260 <new_date_time_get+0x490>
   22312:	bf00      	nop
   22314:	0003f0f9 	.word	0x0003f0f9
   22318:	0003f2a8 	.word	0x0003f2a8
   2231c:	0003f2c4 	.word	0x0003f2c4
   22320:	200209f8 	.word	0x200209f8
   22324:	0003f2dd 	.word	0x0003f2dd
   22328:	0003f108 	.word	0x0003f108
   2232c:	0003f361 	.word	0x0003f361
   22330:	0003f39a 	.word	0x0003f39a
   22334:	200201f8 	.word	0x200201f8
   22338:	0003f11a 	.word	0x0003f11a
   2233c:	0003f415 	.word	0x0003f415
   22340:	200209e8 	.word	0x200209e8
   22344:	0003f43e 	.word	0x0003f43e
   22348:	0003f3af 	.word	0x0003f3af

0002234c <date_time_handler>:
K_THREAD_DEFINE(time_thread, CONFIG_DATE_TIME_THREAD_SIZE,
		new_date_time_get, NULL, NULL, NULL,
		K_HIGHEST_APPLICATION_THREAD_PRIO, 0, 0);

static void date_time_handler(struct k_work *work)
{
   2234c:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   2234e:	480d      	ldr	r0, [pc, #52]	; (22384 <date_time_handler+0x38>)
   22350:	f00b fe4c 	bl	2dfec <z_impl_k_sem_give>
	k_sem_give(&time_fetch_sem);

	LOG_DBG("New date time update in: %d seconds",
   22354:	2304      	movs	r3, #4
   22356:	f04f 0000 	mov.w	r0, #0
   2235a:	4a0b      	ldr	r2, [pc, #44]	; (22388 <date_time_handler+0x3c>)
   2235c:	f363 0007 	bfi	r0, r3, #0, #8
   22360:	4b0a      	ldr	r3, [pc, #40]	; (2238c <date_time_handler+0x40>)
   22362:	490b      	ldr	r1, [pc, #44]	; (22390 <date_time_handler+0x44>)
   22364:	1a9b      	subs	r3, r3, r2
   22366:	08db      	lsrs	r3, r3, #3
   22368:	f363 108f 	bfi	r0, r3, #6, #10
   2236c:	4a09      	ldr	r2, [pc, #36]	; (22394 <date_time_handler+0x48>)
   2236e:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   22372:	f011 fc41 	bl	33bf8 <log_string_sync>
		CONFIG_DATE_TIME_UPDATE_INTERVAL_SECONDS);

	k_delayed_work_submit(&time_work,
			K_SECONDS(CONFIG_DATE_TIME_UPDATE_INTERVAL_SECONDS));
}
   22376:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
   2237a:	4a07      	ldr	r2, [pc, #28]	; (22398 <date_time_handler+0x4c>)
   2237c:	4907      	ldr	r1, [pc, #28]	; (2239c <date_time_handler+0x50>)
   2237e:	4808      	ldr	r0, [pc, #32]	; (223a0 <date_time_handler+0x54>)
   22380:	f00c b8f8 	b.w	2e574 <k_delayed_work_submit_to_queue>
   22384:	20020704 	.word	0x20020704
   22388:	00039f60 	.word	0x00039f60
   2238c:	00039f90 	.word	0x00039f90
   22390:	0003f165 	.word	0x0003f165
   22394:	0003f153 	.word	0x0003f153
   22398:	0036ee80 	.word	0x0036ee80
   2239c:	200224a0 	.word	0x200224a0
   223a0:	20027524 	.word	0x20027524

000223a4 <date_time_init>:

static int date_time_init(struct device *unused)
{
   223a4:	b510      	push	{r4, lr}
	k_delayed_work_init(&time_work, date_time_handler);
   223a6:	4c06      	ldr	r4, [pc, #24]	; (223c0 <date_time_init+0x1c>)
   223a8:	4906      	ldr	r1, [pc, #24]	; (223c4 <date_time_init+0x20>)
   223aa:	4620      	mov	r0, r4
   223ac:	f016 fd3a 	bl	38e24 <k_delayed_work_init>
   223b0:	4a05      	ldr	r2, [pc, #20]	; (223c8 <date_time_init+0x24>)
   223b2:	4621      	mov	r1, r4
   223b4:	4805      	ldr	r0, [pc, #20]	; (223cc <date_time_init+0x28>)
   223b6:	f00c f8dd 	bl	2e574 <k_delayed_work_submit_to_queue>
	k_delayed_work_submit(&time_work,
			K_SECONDS(CONFIG_DATE_TIME_UPDATE_INTERVAL_SECONDS));

	return 0;
}
   223ba:	2000      	movs	r0, #0
   223bc:	bd10      	pop	{r4, pc}
   223be:	bf00      	nop
   223c0:	200224a0 	.word	0x200224a0
   223c4:	0002234d 	.word	0x0002234d
   223c8:	0036ee80 	.word	0x0036ee80
   223cc:	20027524 	.word	0x20027524

000223d0 <date_time_uptime_to_unix_time_ms>:
	time_aux.date_time_utc = (s64_t)timeutil_timegm64(new_date_time) * 1000;
}

int date_time_uptime_to_unix_time_ms(s64_t *uptime)
{
	if (!initial_valid_time) {
   223d0:	4b15      	ldr	r3, [pc, #84]	; (22428 <date_time_uptime_to_unix_time_ms+0x58>)
{
   223d2:	e92d 4830 	stmdb	sp!, {r4, r5, fp, lr}
	if (!initial_valid_time) {
   223d6:	781b      	ldrb	r3, [r3, #0]
   223d8:	b9a3      	cbnz	r3, 22404 <date_time_uptime_to_unix_time_ms+0x34>
		LOG_ERR("Valid time not currently available, requesting time");
   223da:	2301      	movs	r3, #1
   223dc:	f04f 0000 	mov.w	r0, #0
   223e0:	4a12      	ldr	r2, [pc, #72]	; (2242c <date_time_uptime_to_unix_time_ms+0x5c>)
   223e2:	f363 0007 	bfi	r0, r3, #0, #8
   223e6:	4b12      	ldr	r3, [pc, #72]	; (22430 <date_time_uptime_to_unix_time_ms+0x60>)
   223e8:	4912      	ldr	r1, [pc, #72]	; (22434 <date_time_uptime_to_unix_time_ms+0x64>)
   223ea:	1a9b      	subs	r3, r3, r2
   223ec:	08db      	lsrs	r3, r3, #3
   223ee:	f363 108f 	bfi	r0, r3, #6, #10
   223f2:	f011 fc01 	bl	33bf8 <log_string_sync>
   223f6:	4810      	ldr	r0, [pc, #64]	; (22438 <date_time_uptime_to_unix_time_ms+0x68>)
   223f8:	f00b fdf8 	bl	2dfec <z_impl_k_sem_give>
   223fc:	f06f 003c 	mvn.w	r0, #60	; 0x3c
	}

	*uptime += time_aux.date_time_utc - time_aux.last_date_time_update;

	return 0;
}
   22400:	e8bd 8830 	ldmia.w	sp!, {r4, r5, fp, pc}
	*uptime += time_aux.date_time_utc - time_aux.last_date_time_update;
   22404:	4b0d      	ldr	r3, [pc, #52]	; (2243c <date_time_uptime_to_unix_time_ms+0x6c>)
   22406:	689a      	ldr	r2, [r3, #8]
   22408:	e9d3 4500 	ldrd	r4, r5, [r3]
   2240c:	ebb4 0b02 	subs.w	fp, r4, r2
   22410:	eb65 7ce2 	sbc.w	ip, r5, r2, asr #31
   22414:	e9d0 3200 	ldrd	r3, r2, [r0]
   22418:	eb13 030b 	adds.w	r3, r3, fp
   2241c:	eb4c 0202 	adc.w	r2, ip, r2
   22420:	e9c0 3200 	strd	r3, r2, [r0]
	return 0;
   22424:	2000      	movs	r0, #0
   22426:	e7eb      	b.n	22400 <date_time_uptime_to_unix_time_ms+0x30>
   22428:	2002907f 	.word	0x2002907f
   2242c:	00039f60 	.word	0x00039f60
   22430:	00039f90 	.word	0x00039f90
   22434:	0003f18d 	.word	0x0003f18d
   22438:	20020704 	.word	0x20020704
   2243c:	200209f8 	.word	0x200209f8

00022440 <check_ext_api_requests>:
	}
};
#endif

static int check_ext_api_requests(struct device *dev)
{
   22440:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	(void)dev;

	const struct fw_info_ext_api_request *ext_api_req =
			skip_ext_apis(&m_firmware_info);

	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   22444:	2500      	movs	r5, #0
			skip_ext_apis(&m_firmware_info);
   22446:	4c21      	ldr	r4, [pc, #132]	; (224cc <check_ext_api_requests+0x8c>)
 */
static inline const struct fw_info_ext_api *fw_info_ext_api_check(
							u32_t ext_api_addr)
{
	const struct fw_info_ext_api *ext_api;
	const u32_t ext_api_magic[] = {EXT_API_MAGIC};
   22448:	4e21      	ldr	r6, [pc, #132]	; (224d0 <check_ext_api_requests+0x90>)
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   2244a:	f854 8c04 	ldr.w	r8, [r4, #-4]
			/* EXT_API hard requirement not met. */
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
			k_panic();
		} else {
			/* EXT_API soft requirement not met. */
			printk("WARNING: Optional EXT_API request not "
   2244e:	f8df 9088 	ldr.w	r9, [pc, #136]	; 224d8 <check_ext_api_requests+0x98>
{
   22452:	b085      	sub	sp, #20
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   22454:	45a8      	cmp	r8, r5
   22456:	d803      	bhi.n	22460 <check_ext_api_requests+0x20>
		}
		ADVANCE_EXT_API_REQ(ext_api_req);
	}

	return 0;
}
   22458:	2000      	movs	r0, #0
   2245a:	b005      	add	sp, #20
   2245c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (fw_info_ext_api_check((u32_t)*(ext_api_req->ext_api))
   22460:	6a63      	ldr	r3, [r4, #36]	; 0x24
   22462:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
   22466:	681f      	ldr	r7, [r3, #0]
   22468:	ab01      	add	r3, sp, #4
   2246a:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	ext_api = (const struct fw_info_ext_api *)(ext_api_addr);
	if (memcmp(ext_api->magic, ext_api_magic, CONFIG_FW_INFO_MAGIC_LEN)
   2246e:	220c      	movs	r2, #12
   22470:	4619      	mov	r1, r3
   22472:	4638      	mov	r0, r7
   22474:	f016 fda2 	bl	38fbc <memcmp>
   22478:	b990      	cbnz	r0, 224a0 <check_ext_api_requests+0x60>
   2247a:	b18f      	cbz	r7, 224a0 <check_ext_api_requests+0x60>
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   2247c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	const u32_t req_id = ext_api_req->request.ext_api_id;
   2247e:	6921      	ldr	r1, [r4, #16]
			&& ext_api_satisfies_req(*(ext_api_req->ext_api),
   22480:	681b      	ldr	r3, [r3, #0]
	return ((ext_api->ext_api_id == req_id)
   22482:	691a      	ldr	r2, [r3, #16]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   22484:	4291      	cmp	r1, r2
   22486:	d10b      	bne.n	224a0 <check_ext_api_requests+0x60>
		&&  (ext_api->ext_api_version >= req_min_version)
   22488:	699a      	ldr	r2, [r3, #24]
	const u32_t req_min_version = ext_api_req->request.ext_api_version;
   2248a:	69a1      	ldr	r1, [r4, #24]
		&&  (ext_api->ext_api_version >= req_min_version)
   2248c:	4291      	cmp	r1, r2
   2248e:	d807      	bhi.n	224a0 <check_ext_api_requests+0x60>
	const u32_t req_max_version = ext_api_req->ext_api_max_version;
   22490:	69e1      	ldr	r1, [r4, #28]
		&&  (ext_api->ext_api_version <  req_max_version)
   22492:	4291      	cmp	r1, r2
   22494:	d904      	bls.n	224a0 <check_ext_api_requests+0x60>
	const u32_t req_flags = ext_api_req->request.ext_api_flags;
   22496:	6962      	ldr	r2, [r4, #20]
		&& ((ext_api->ext_api_flags & req_flags) == req_flags));
   22498:	695b      	ldr	r3, [r3, #20]
   2249a:	ea32 0303 	bics.w	r3, r2, r3
   2249e:	d00a      	beq.n	224b6 <check_ext_api_requests+0x76>
		} else if (ext_api_req->required) {
   224a0:	6a27      	ldr	r7, [r4, #32]
   224a2:	b167      	cbz	r7, 224be <check_ext_api_requests+0x7e>
			printk("ERROR: Cannot fulfill EXT_API request.\r\n");
   224a4:	480b      	ldr	r0, [pc, #44]	; (224d4 <check_ext_api_requests+0x94>)
   224a6:	f011 f88f 	bl	335c8 <printk>
			k_panic();
   224aa:	4040      	eors	r0, r0
   224ac:	f380 8811 	msr	BASEPRI, r0
   224b0:	f04f 0004 	mov.w	r0, #4
   224b4:	df02      	svc	2
		ADVANCE_EXT_API_REQ(ext_api_req);
   224b6:	68e3      	ldr	r3, [r4, #12]
	for (u32_t i = 0; i < m_firmware_info.ext_api_request_num; i++) {
   224b8:	3501      	adds	r5, #1
		ADVANCE_EXT_API_REQ(ext_api_req);
   224ba:	441c      	add	r4, r3
   224bc:	e7ca      	b.n	22454 <check_ext_api_requests+0x14>
			printk("WARNING: Optional EXT_API request not "
   224be:	4648      	mov	r0, r9
   224c0:	f011 f882 	bl	335c8 <printk>
			*ext_api_req->ext_api = NULL;
   224c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
   224c6:	601f      	str	r7, [r3, #0]
   224c8:	e7f5      	b.n	224b6 <check_ext_api_requests+0x76>
   224ca:	bf00      	nop
   224cc:	0000c23c 	.word	0x0000c23c
   224d0:	0003a118 	.word	0x0003a118
   224d4:	0003f519 	.word	0x0003f519
   224d8:	0003f542 	.word	0x0003f542

000224dc <packet_free_cb>:
   224dc:	b510      	push	{r4, lr}
   224de:	4604      	mov	r4, r0
   224e0:	6800      	ldr	r0, [r0, #0]
   224e2:	f004 ff7d 	bl	273e0 <rpc_logobj_client_data_free>
   224e6:	68a0      	ldr	r0, [r4, #8]
   224e8:	b118      	cbz	r0, 224f2 <packet_free_cb+0x16>
   224ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   224ee:	f007 bd2d 	b.w	29f4c <nrf_free>
   224f2:	bd10      	pop	{r4, pc}

000224f4 <logobj_event_handler>:
   224f4:	b530      	push	{r4, r5, lr}
   224f6:	4b3b      	ldr	r3, [pc, #236]	; (225e4 <logobj_event_handler+0xf0>)
   224f8:	b085      	sub	sp, #20
   224fa:	681d      	ldr	r5, [r3, #0]
   224fc:	2d00      	cmp	r5, #0
   224fe:	d04c      	beq.n	2259a <logobj_event_handler+0xa6>
   22500:	f248 0302 	movw	r3, #32770	; 0x8002
   22504:	4299      	cmp	r1, r3
   22506:	d053      	beq.n	225b0 <logobj_event_handler+0xbc>
   22508:	d91c      	bls.n	22544 <logobj_event_handler+0x50>
   2250a:	f248 0303 	movw	r3, #32771	; 0x8003
   2250e:	4299      	cmp	r1, r3
   22510:	d05a      	beq.n	225c8 <logobj_event_handler+0xd4>
   22512:	f249 0301 	movw	r3, #36865	; 0x9001
   22516:	4299      	cmp	r1, r3
   22518:	d147      	bne.n	225aa <logobj_event_handler+0xb6>
   2251a:	2400      	movs	r4, #0
   2251c:	6843      	ldr	r3, [r0, #4]
   2251e:	6802      	ldr	r2, [r0, #0]
   22520:	e9cd 4402 	strd	r4, r4, [sp, #8]
   22524:	e9cd 2300 	strd	r2, r3, [sp]
   22528:	69e8      	ldr	r0, [r5, #28]
   2252a:	4669      	mov	r1, sp
   2252c:	6803      	ldr	r3, [r0, #0]
   2252e:	685b      	ldr	r3, [r3, #4]
   22530:	4798      	blx	r3
   22532:	3001      	adds	r0, #1
   22534:	d04e      	beq.n	225d4 <logobj_event_handler+0xe0>
   22536:	4620      	mov	r0, r4
   22538:	682b      	ldr	r3, [r5, #0]
   2253a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   2253e:	602b      	str	r3, [r5, #0]
   22540:	b005      	add	sp, #20
   22542:	bd30      	pop	{r4, r5, pc}
   22544:	f248 0301 	movw	r3, #32769	; 0x8001
   22548:	4299      	cmp	r1, r3
   2254a:	d12e      	bne.n	225aa <logobj_event_handler+0xb6>
   2254c:	68c3      	ldr	r3, [r0, #12]
   2254e:	2b00      	cmp	r3, #0
   22550:	d135      	bne.n	225be <logobj_event_handler+0xca>
   22552:	6828      	ldr	r0, [r5, #0]
   22554:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
   22558:	d03e      	beq.n	225d8 <logobj_event_handler+0xe4>
   2255a:	682b      	ldr	r3, [r5, #0]
   2255c:	b29b      	uxth	r3, r3
   2255e:	2b01      	cmp	r3, #1
   22560:	d105      	bne.n	2256e <logobj_event_handler+0x7a>
   22562:	682b      	ldr	r3, [r5, #0]
   22564:	0c1b      	lsrs	r3, r3, #16
   22566:	041b      	lsls	r3, r3, #16
   22568:	f043 0302 	orr.w	r3, r3, #2
   2256c:	602b      	str	r3, [r5, #0]
   2256e:	4b1e      	ldr	r3, [pc, #120]	; (225e8 <logobj_event_handler+0xf4>)
   22570:	781a      	ldrb	r2, [r3, #0]
   22572:	f002 01ff 	and.w	r1, r2, #255	; 0xff
   22576:	2a00      	cmp	r2, #0
   22578:	d031      	beq.n	225de <logobj_event_handler+0xea>
   2257a:	4a1c      	ldr	r2, [pc, #112]	; (225ec <logobj_event_handler+0xf8>)
   2257c:	7811      	ldrb	r1, [r2, #0]
   2257e:	b909      	cbnz	r1, 22584 <logobj_event_handler+0x90>
   22580:	2101      	movs	r1, #1
   22582:	7011      	strb	r1, [r2, #0]
   22584:	2000      	movs	r0, #0
   22586:	7018      	strb	r0, [r3, #0]
   22588:	682b      	ldr	r3, [r5, #0]
   2258a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2258e:	602b      	str	r3, [r5, #0]
   22590:	682b      	ldr	r3, [r5, #0]
   22592:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   22596:	602b      	str	r3, [r5, #0]
   22598:	e7d2      	b.n	22540 <logobj_event_handler+0x4c>
   2259a:	6800      	ldr	r0, [r0, #0]
   2259c:	2800      	cmp	r0, #0
   2259e:	d0cf      	beq.n	22540 <logobj_event_handler+0x4c>
   225a0:	f004 ff1e 	bl	273e0 <rpc_logobj_client_data_free>
   225a4:	4628      	mov	r0, r5
   225a6:	b005      	add	sp, #20
   225a8:	bd30      	pop	{r4, r5, pc}
   225aa:	2000      	movs	r0, #0
   225ac:	b005      	add	sp, #20
   225ae:	bd30      	pop	{r4, r5, pc}
   225b0:	682b      	ldr	r3, [r5, #0]
   225b2:	f413 0380 	ands.w	r3, r3, #4194304	; 0x400000
   225b6:	d00b      	beq.n	225d0 <logobj_event_handler+0xdc>
   225b8:	68c0      	ldr	r0, [r0, #12]
   225ba:	2800      	cmp	r0, #0
   225bc:	d0e4      	beq.n	22588 <logobj_event_handler+0x94>
   225be:	230e      	movs	r3, #14
   225c0:	2000      	movs	r0, #0
   225c2:	606b      	str	r3, [r5, #4]
   225c4:	b005      	add	sp, #20
   225c6:	bd30      	pop	{r4, r5, pc}
   225c8:	68c3      	ldr	r3, [r0, #12]
   225ca:	2b01      	cmp	r3, #1
   225cc:	d1a5      	bne.n	2251a <logobj_event_handler+0x26>
   225ce:	e7f6      	b.n	225be <logobj_event_handler+0xca>
   225d0:	4618      	mov	r0, r3
   225d2:	e7b5      	b.n	22540 <logobj_event_handler+0x4c>
   225d4:	2002      	movs	r0, #2
   225d6:	e7b3      	b.n	22540 <logobj_event_handler+0x4c>
   225d8:	230e      	movs	r3, #14
   225da:	606b      	str	r3, [r5, #4]
   225dc:	e7b0      	b.n	22540 <logobj_event_handler+0x4c>
   225de:	4a03      	ldr	r2, [pc, #12]	; (225ec <logobj_event_handler+0xf8>)
   225e0:	7011      	strb	r1, [r2, #0]
   225e2:	e7cf      	b.n	22584 <logobj_event_handler+0x90>
   225e4:	200224c4 	.word	0x200224c4
   225e8:	20029080 	.word	0x20029080
   225ec:	20029081 	.word	0x20029081

000225f0 <logobj_interface_init>:
   225f0:	2300      	movs	r3, #0
   225f2:	b510      	push	{r4, lr}
   225f4:	4808      	ldr	r0, [pc, #32]	; (22618 <logobj_interface_init+0x28>)
   225f6:	4c09      	ldr	r4, [pc, #36]	; (2261c <logobj_interface_init+0x2c>)
   225f8:	4909      	ldr	r1, [pc, #36]	; (22620 <logobj_interface_init+0x30>)
   225fa:	4a0a      	ldr	r2, [pc, #40]	; (22624 <logobj_interface_init+0x34>)
   225fc:	7023      	strb	r3, [r4, #0]
   225fe:	6003      	str	r3, [r0, #0]
   22600:	700b      	strb	r3, [r1, #0]
   22602:	6013      	str	r3, [r2, #0]
   22604:	f004 feb0 	bl	27368 <rpc_logobj_client_init>
   22608:	b918      	cbnz	r0, 22612 <logobj_interface_init+0x22>
   2260a:	2201      	movs	r2, #1
   2260c:	4b06      	ldr	r3, [pc, #24]	; (22628 <logobj_interface_init+0x38>)
   2260e:	701a      	strb	r2, [r3, #0]
   22610:	bd10      	pop	{r4, pc}
   22612:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22616:	bd10      	pop	{r4, pc}
   22618:	200224c4 	.word	0x200224c4
   2261c:	20029081 	.word	0x20029081
   22620:	20029080 	.word	0x20029080
   22624:	200224c0 	.word	0x200224c0
   22628:	20029082 	.word	0x20029082

0002262c <logobj_interface_open>:
   2262c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   22630:	2400      	movs	r4, #0
   22632:	4b5b      	ldr	r3, [pc, #364]	; (227a0 <logobj_interface_open+0x174>)
   22634:	b084      	sub	sp, #16
   22636:	781b      	ldrb	r3, [r3, #0]
   22638:	9401      	str	r4, [sp, #4]
   2263a:	2b00      	cmp	r3, #0
   2263c:	f000 809f 	beq.w	2277e <logobj_interface_open+0x152>
   22640:	2866      	cmp	r0, #102	; 0x66
   22642:	4680      	mov	r8, r0
   22644:	f040 808f 	bne.w	22766 <logobj_interface_open+0x13a>
   22648:	2902      	cmp	r1, #2
   2264a:	4689      	mov	r9, r1
   2264c:	f040 808b 	bne.w	22766 <logobj_interface_open+0x13a>
   22650:	f240 2305 	movw	r3, #517	; 0x205
   22654:	429a      	cmp	r2, r3
   22656:	4692      	mov	sl, r2
   22658:	f040 8085 	bne.w	22766 <logobj_interface_open+0x13a>
   2265c:	4f51      	ldr	r7, [pc, #324]	; (227a4 <logobj_interface_open+0x178>)
   2265e:	683d      	ldr	r5, [r7, #0]
   22660:	2d00      	cmp	r5, #0
   22662:	f040 8086 	bne.w	22772 <logobj_interface_open+0x146>
   22666:	4a50      	ldr	r2, [pc, #320]	; (227a8 <logobj_interface_open+0x17c>)
   22668:	a801      	add	r0, sp, #4
   2266a:	f007 ff97 	bl	2a59c <interface_socket_allocate>
   2266e:	9b01      	ldr	r3, [sp, #4]
   22670:	4606      	mov	r6, r0
   22672:	2b00      	cmp	r3, #0
   22674:	f000 808d 	beq.w	22792 <logobj_interface_open+0x166>
   22678:	4629      	mov	r1, r5
   2267a:	2204      	movs	r2, #4
   2267c:	484b      	ldr	r0, [pc, #300]	; (227ac <logobj_interface_open+0x180>)
   2267e:	603b      	str	r3, [r7, #0]
   22680:	f016 fce4 	bl	3904c <memset>
   22684:	9c01      	ldr	r4, [sp, #4]
   22686:	4629      	mov	r1, r5
   22688:	e9c4 8903 	strd	r8, r9, [r4, #12]
   2268c:	f8c4 a014 	str.w	sl, [r4, #20]
   22690:	a802      	add	r0, sp, #8
   22692:	f004 fe6f 	bl	27374 <rpc_logobj_client_request_alloc>
   22696:	2800      	cmp	r0, #0
   22698:	d142      	bne.n	22720 <logobj_interface_open+0xf4>
   2269a:	2201      	movs	r2, #1
   2269c:	2104      	movs	r1, #4
   2269e:	9b02      	ldr	r3, [sp, #8]
   226a0:	4d43      	ldr	r5, [pc, #268]	; (227b0 <logobj_interface_open+0x184>)
   226a2:	7358      	strb	r0, [r3, #13]
   226a4:	7398      	strb	r0, [r3, #14]
   226a6:	73d8      	strb	r0, [r3, #15]
   226a8:	7258      	strb	r0, [r3, #9]
   226aa:	7298      	strb	r0, [r3, #10]
   226ac:	72d8      	strb	r0, [r3, #11]
   226ae:	7219      	strb	r1, [r3, #8]
   226b0:	702a      	strb	r2, [r5, #0]
   226b2:	731a      	strb	r2, [r3, #12]
   226b4:	6822      	ldr	r2, [r4, #0]
   226b6:	4618      	mov	r0, r3
   226b8:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   226bc:	6022      	str	r2, [r4, #0]
   226be:	f247 0101 	movw	r1, #28673	; 0x7001
   226c2:	f004 fe6f 	bl	273a4 <rpc_logobj_client_request_send>
   226c6:	bb68      	cbnz	r0, 22724 <logobj_interface_open+0xf8>
   226c8:	6a61      	ldr	r1, [r4, #36]	; 0x24
   226ca:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   226ce:	2900      	cmp	r1, #0
   226d0:	bf08      	it	eq
   226d2:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   226d6:	ab04      	add	r3, sp, #16
   226d8:	f843 1d04 	str.w	r1, [r3, #-4]!
   226dc:	4630      	mov	r0, r6
   226de:	4611      	mov	r1, r2
   226e0:	f008 f80e 	bl	2a700 <interface_socket_wait>
   226e4:	4604      	mov	r4, r0
   226e6:	b310      	cbz	r0, 2272e <logobj_interface_open+0x102>
   226e8:	9a01      	ldr	r2, [sp, #4]
   226ea:	2e00      	cmp	r6, #0
   226ec:	6813      	ldr	r3, [r2, #0]
   226ee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   226f2:	6013      	str	r3, [r2, #0]
   226f4:	9a01      	ldr	r2, [sp, #4]
   226f6:	6813      	ldr	r3, [r2, #0]
   226f8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   226fc:	6013      	str	r3, [r2, #0]
   226fe:	9a01      	ldr	r2, [sp, #4]
   22700:	6813      	ldr	r3, [r2, #0]
   22702:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   22706:	6013      	str	r3, [r2, #0]
   22708:	da3f      	bge.n	2278a <logobj_interface_open+0x15e>
   2270a:	2300      	movs	r3, #0
   2270c:	4620      	mov	r0, r4
   2270e:	603b      	str	r3, [r7, #0]
   22710:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   22714:	f7fd fca4 	bl	20060 <bsd_os_errno_set>
   22718:	4630      	mov	r0, r6
   2271a:	b004      	add	sp, #16
   2271c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   22720:	240c      	movs	r4, #12
   22722:	e7e1      	b.n	226e8 <logobj_interface_open+0xbc>
   22724:	9802      	ldr	r0, [sp, #8]
   22726:	f004 fe53 	bl	273d0 <rpc_logobj_client_message_free>
   2272a:	2405      	movs	r4, #5
   2272c:	e7dc      	b.n	226e8 <logobj_interface_open+0xbc>
   2272e:	4630      	mov	r0, r6
   22730:	f008 f85a 	bl	2a7e8 <interface_socket_from_handle_get>
   22734:	b120      	cbz	r0, 22740 <logobj_interface_open+0x114>
   22736:	6844      	ldr	r4, [r0, #4]
   22738:	b114      	cbz	r4, 22740 <logobj_interface_open+0x114>
   2273a:	2300      	movs	r3, #0
   2273c:	6043      	str	r3, [r0, #4]
   2273e:	e7d3      	b.n	226e8 <logobj_interface_open+0xbc>
   22740:	4630      	mov	r0, r6
   22742:	9a01      	ldr	r2, [sp, #4]
   22744:	6813      	ldr	r3, [r2, #0]
   22746:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2274a:	6013      	str	r3, [r2, #0]
   2274c:	9a01      	ldr	r2, [sp, #4]
   2274e:	6813      	ldr	r3, [r2, #0]
   22750:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   22754:	6013      	str	r3, [r2, #0]
   22756:	9a01      	ldr	r2, [sp, #4]
   22758:	6813      	ldr	r3, [r2, #0]
   2275a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   2275e:	6013      	str	r3, [r2, #0]
   22760:	b004      	add	sp, #16
   22762:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   22766:	2016      	movs	r0, #22
   22768:	f7fd fc7a 	bl	20060 <bsd_os_errno_set>
   2276c:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   22770:	e7d2      	b.n	22718 <logobj_interface_open+0xec>
   22772:	2001      	movs	r0, #1
   22774:	f7fd fc74 	bl	20060 <bsd_os_errno_set>
   22778:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2277c:	e7cc      	b.n	22718 <logobj_interface_open+0xec>
   2277e:	2070      	movs	r0, #112	; 0x70
   22780:	f7fd fc6e 	bl	20060 <bsd_os_errno_set>
   22784:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   22788:	e7c6      	b.n	22718 <logobj_interface_open+0xec>
   2278a:	4630      	mov	r0, r6
   2278c:	f007 ff6a 	bl	2a664 <interface_socket_free>
   22790:	e7bb      	b.n	2270a <logobj_interface_open+0xde>
   22792:	2018      	movs	r0, #24
   22794:	f7fd fc64 	bl	20060 <bsd_os_errno_set>
   22798:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   2279c:	e7bc      	b.n	22718 <logobj_interface_open+0xec>
   2279e:	bf00      	nop
   227a0:	20029082 	.word	0x20029082
   227a4:	200224c4 	.word	0x200224c4
   227a8:	000224dd 	.word	0x000224dd
   227ac:	200224c0 	.word	0x200224c0
   227b0:	20029080 	.word	0x20029080

000227b4 <logobj_interface_read>:
   227b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   227b8:	b087      	sub	sp, #28
   227ba:	2900      	cmp	r1, #0
   227bc:	d06b      	beq.n	22896 <logobj_interface_read+0xe2>
   227be:	2a00      	cmp	r2, #0
   227c0:	4617      	mov	r7, r2
   227c2:	dd68      	ble.n	22896 <logobj_interface_read+0xe2>
   227c4:	461d      	mov	r5, r3
   227c6:	4680      	mov	r8, r0
   227c8:	460e      	mov	r6, r1
   227ca:	f008 f80d 	bl	2a7e8 <interface_socket_from_handle_get>
   227ce:	4604      	mov	r4, r0
   227d0:	2800      	cmp	r0, #0
   227d2:	d066      	beq.n	228a2 <logobj_interface_read+0xee>
   227d4:	bb4d      	cbnz	r5, 2282a <logobj_interface_read+0x76>
   227d6:	69e0      	ldr	r0, [r4, #28]
   227d8:	07aa      	lsls	r2, r5, #30
   227da:	6803      	ldr	r3, [r0, #0]
   227dc:	68db      	ldr	r3, [r3, #12]
   227de:	d52d      	bpl.n	2283c <logobj_interface_read+0x88>
   227e0:	4798      	blx	r3
   227e2:	3001      	adds	r0, #1
   227e4:	d047      	beq.n	22876 <logobj_interface_read+0xc2>
   227e6:	6823      	ldr	r3, [r4, #0]
   227e8:	69e0      	ldr	r0, [r4, #28]
   227ea:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
   227ee:	d044      	beq.n	2287a <logobj_interface_read+0xc6>
   227f0:	2100      	movs	r1, #0
   227f2:	6823      	ldr	r3, [r4, #0]
   227f4:	462a      	mov	r2, r5
   227f6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   227fa:	6023      	str	r3, [r4, #0]
   227fc:	e9cd 1104 	strd	r1, r1, [sp, #16]
   22800:	e9cd 6702 	strd	r6, r7, [sp, #8]
   22804:	6803      	ldr	r3, [r0, #0]
   22806:	a902      	add	r1, sp, #8
   22808:	689b      	ldr	r3, [r3, #8]
   2280a:	4798      	blx	r3
   2280c:	4605      	mov	r5, r0
   2280e:	69e0      	ldr	r0, [r4, #28]
   22810:	6803      	ldr	r3, [r0, #0]
   22812:	68db      	ldr	r3, [r3, #12]
   22814:	4798      	blx	r3
   22816:	3001      	adds	r0, #1
   22818:	d003      	beq.n	22822 <logobj_interface_read+0x6e>
   2281a:	6823      	ldr	r3, [r4, #0]
   2281c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   22820:	6023      	str	r3, [r4, #0]
   22822:	4628      	mov	r0, r5
   22824:	b007      	add	sp, #28
   22826:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2282a:	f015 0f2a 	tst.w	r5, #42	; 0x2a
   2282e:	d1d2      	bne.n	227d6 <logobj_interface_read+0x22>
   22830:	202d      	movs	r0, #45	; 0x2d
   22832:	f7fd fc15 	bl	20060 <bsd_os_errno_set>
   22836:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2283a:	e7f2      	b.n	22822 <logobj_interface_read+0x6e>
   2283c:	6822      	ldr	r2, [r4, #0]
   2283e:	f012 5980 	ands.w	r9, r2, #268435456	; 0x10000000
   22842:	d1cd      	bne.n	227e0 <logobj_interface_read+0x2c>
   22844:	4798      	blx	r3
   22846:	1c43      	adds	r3, r0, #1
   22848:	d1cd      	bne.n	227e6 <logobj_interface_read+0x32>
   2284a:	6a22      	ldr	r2, [r4, #32]
   2284c:	ab06      	add	r3, sp, #24
   2284e:	2a00      	cmp	r2, #0
   22850:	bf18      	it	ne
   22852:	4610      	movne	r0, r2
   22854:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   22858:	f843 0d14 	str.w	r0, [r3, #-20]!
   2285c:	4611      	mov	r1, r2
   2285e:	4640      	mov	r0, r8
   22860:	f007 ff4e 	bl	2a700 <interface_socket_wait>
   22864:	b158      	cbz	r0, 2287e <logobj_interface_read+0xca>
   22866:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2286a:	f7fd fbf9 	bl	20060 <bsd_os_errno_set>
   2286e:	4628      	mov	r0, r5
   22870:	b007      	add	sp, #28
   22872:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   22876:	2023      	movs	r0, #35	; 0x23
   22878:	e7f5      	b.n	22866 <logobj_interface_read+0xb2>
   2287a:	461d      	mov	r5, r3
   2287c:	e7c8      	b.n	22810 <logobj_interface_read+0x5c>
   2287e:	4640      	mov	r0, r8
   22880:	f007 ffb2 	bl	2a7e8 <interface_socket_from_handle_get>
   22884:	4603      	mov	r3, r0
   22886:	2800      	cmp	r0, #0
   22888:	d0ad      	beq.n	227e6 <logobj_interface_read+0x32>
   2288a:	6840      	ldr	r0, [r0, #4]
   2288c:	2800      	cmp	r0, #0
   2288e:	d0aa      	beq.n	227e6 <logobj_interface_read+0x32>
   22890:	f8c3 9004 	str.w	r9, [r3, #4]
   22894:	e7e7      	b.n	22866 <logobj_interface_read+0xb2>
   22896:	2016      	movs	r0, #22
   22898:	f7fd fbe2 	bl	20060 <bsd_os_errno_set>
   2289c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   228a0:	e7bf      	b.n	22822 <logobj_interface_read+0x6e>
   228a2:	2009      	movs	r0, #9
   228a4:	f7fd fbdc 	bl	20060 <bsd_os_errno_set>
   228a8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   228ac:	e7b9      	b.n	22822 <logobj_interface_read+0x6e>
   228ae:	bf00      	nop

000228b0 <logobj_interface_write>:
   228b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   228b4:	b082      	sub	sp, #8
   228b6:	2900      	cmp	r1, #0
   228b8:	d06b      	beq.n	22992 <logobj_interface_write+0xe2>
   228ba:	2a04      	cmp	r2, #4
   228bc:	d169      	bne.n	22992 <logobj_interface_write+0xe2>
   228be:	461f      	mov	r7, r3
   228c0:	4606      	mov	r6, r0
   228c2:	460d      	mov	r5, r1
   228c4:	f007 ff90 	bl	2a7e8 <interface_socket_from_handle_get>
   228c8:	4604      	mov	r4, r0
   228ca:	2800      	cmp	r0, #0
   228cc:	d074      	beq.n	229b8 <logobj_interface_write+0x108>
   228ce:	b1e7      	cbz	r7, 2290a <logobj_interface_write+0x5a>
   228d0:	07b8      	lsls	r0, r7, #30
   228d2:	d56b      	bpl.n	229ac <logobj_interface_write+0xfc>
   228d4:	6823      	ldr	r3, [r4, #0]
   228d6:	039b      	lsls	r3, r3, #14
   228d8:	d564      	bpl.n	229a4 <logobj_interface_write+0xf4>
   228da:	2700      	movs	r7, #0
   228dc:	6823      	ldr	r3, [r4, #0]
   228de:	2100      	movs	r1, #0
   228e0:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   228e4:	6023      	str	r3, [r4, #0]
   228e6:	4668      	mov	r0, sp
   228e8:	f8d5 8000 	ldr.w	r8, [r5]
   228ec:	f004 fd42 	bl	27374 <rpc_logobj_client_request_alloc>
   228f0:	b198      	cbz	r0, 2291a <logobj_interface_write+0x6a>
   228f2:	200c      	movs	r0, #12
   228f4:	6823      	ldr	r3, [r4, #0]
   228f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   228fa:	6023      	str	r3, [r4, #0]
   228fc:	f7fd fbb0 	bl	20060 <bsd_os_errno_set>
   22900:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22904:	b002      	add	sp, #8
   22906:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2290a:	6803      	ldr	r3, [r0, #0]
   2290c:	00d9      	lsls	r1, r3, #3
   2290e:	d4e1      	bmi.n	228d4 <logobj_interface_write+0x24>
   22910:	6803      	ldr	r3, [r0, #0]
   22912:	039a      	lsls	r2, r3, #14
   22914:	d548      	bpl.n	229a8 <logobj_interface_write+0xf8>
   22916:	2701      	movs	r7, #1
   22918:	e7e0      	b.n	228dc <logobj_interface_write+0x2c>
   2291a:	2504      	movs	r5, #4
   2291c:	9b00      	ldr	r3, [sp, #0]
   2291e:	f247 0103 	movw	r1, #28675	; 0x7003
   22922:	f8c3 800c 	str.w	r8, [r3, #12]
   22926:	7258      	strb	r0, [r3, #9]
   22928:	7298      	strb	r0, [r3, #10]
   2292a:	72d8      	strb	r0, [r3, #11]
   2292c:	721d      	strb	r5, [r3, #8]
   2292e:	4618      	mov	r0, r3
   22930:	f004 fd38 	bl	273a4 <rpc_logobj_client_request_send>
   22934:	4680      	mov	r8, r0
   22936:	bb18      	cbnz	r0, 22980 <logobj_interface_write+0xd0>
   22938:	b1d7      	cbz	r7, 22970 <logobj_interface_write+0xc0>
   2293a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   2293c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   22940:	2900      	cmp	r1, #0
   22942:	bf08      	it	eq
   22944:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   22948:	ab02      	add	r3, sp, #8
   2294a:	f843 1d04 	str.w	r1, [r3, #-4]!
   2294e:	4630      	mov	r0, r6
   22950:	4611      	mov	r1, r2
   22952:	f007 fed5 	bl	2a700 <interface_socket_wait>
   22956:	b120      	cbz	r0, 22962 <logobj_interface_write+0xb2>
   22958:	6823      	ldr	r3, [r4, #0]
   2295a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2295e:	6023      	str	r3, [r4, #0]
   22960:	e7cc      	b.n	228fc <logobj_interface_write+0x4c>
   22962:	4630      	mov	r0, r6
   22964:	f007 ff40 	bl	2a7e8 <interface_socket_from_handle_get>
   22968:	4603      	mov	r3, r0
   2296a:	b108      	cbz	r0, 22970 <logobj_interface_write+0xc0>
   2296c:	6840      	ldr	r0, [r0, #4]
   2296e:	b9b0      	cbnz	r0, 2299e <logobj_interface_write+0xee>
   22970:	4628      	mov	r0, r5
   22972:	6823      	ldr	r3, [r4, #0]
   22974:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   22978:	6023      	str	r3, [r4, #0]
   2297a:	b002      	add	sp, #8
   2297c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   22980:	9800      	ldr	r0, [sp, #0]
   22982:	f004 fd25 	bl	273d0 <rpc_logobj_client_message_free>
   22986:	6823      	ldr	r3, [r4, #0]
   22988:	2005      	movs	r0, #5
   2298a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2298e:	6023      	str	r3, [r4, #0]
   22990:	e7b4      	b.n	228fc <logobj_interface_write+0x4c>
   22992:	2016      	movs	r0, #22
   22994:	f7fd fb64 	bl	20060 <bsd_os_errno_set>
   22998:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2299c:	e7b2      	b.n	22904 <logobj_interface_write+0x54>
   2299e:	f8c3 8004 	str.w	r8, [r3, #4]
   229a2:	e7d9      	b.n	22958 <logobj_interface_write+0xa8>
   229a4:	2073      	movs	r0, #115	; 0x73
   229a6:	e7a9      	b.n	228fc <logobj_interface_write+0x4c>
   229a8:	2009      	movs	r0, #9
   229aa:	e7a7      	b.n	228fc <logobj_interface_write+0x4c>
   229ac:	202d      	movs	r0, #45	; 0x2d
   229ae:	f7fd fb57 	bl	20060 <bsd_os_errno_set>
   229b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   229b6:	e7a5      	b.n	22904 <logobj_interface_write+0x54>
   229b8:	2009      	movs	r0, #9
   229ba:	f7fd fb51 	bl	20060 <bsd_os_errno_set>
   229be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   229c2:	e79f      	b.n	22904 <logobj_interface_write+0x54>

000229c4 <logobj_interface_setopt>:
   229c4:	b5f0      	push	{r4, r5, r6, r7, lr}
   229c6:	2901      	cmp	r1, #1
   229c8:	b085      	sub	sp, #20
   229ca:	d06d      	beq.n	22aa8 <logobj_interface_setopt+0xe4>
   229cc:	461e      	mov	r6, r3
   229ce:	f240 2305 	movw	r3, #517	; 0x205
   229d2:	4299      	cmp	r1, r3
   229d4:	f040 80a0 	bne.w	22b18 <logobj_interface_setopt+0x154>
   229d8:	4607      	mov	r7, r0
   229da:	4615      	mov	r5, r2
   229dc:	f007 ff04 	bl	2a7e8 <interface_socket_from_handle_get>
   229e0:	4604      	mov	r4, r0
   229e2:	2800      	cmp	r0, #0
   229e4:	f000 80c3 	beq.w	22b6e <logobj_interface_setopt+0x1aa>
   229e8:	2d01      	cmp	r5, #1
   229ea:	d019      	beq.n	22a20 <logobj_interface_setopt+0x5c>
   229ec:	2d02      	cmp	r5, #2
   229ee:	d010      	beq.n	22a12 <logobj_interface_setopt+0x4e>
   229f0:	252a      	movs	r5, #42	; 0x2a
   229f2:	6803      	ldr	r3, [r0, #0]
   229f4:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   229f8:	6023      	str	r3, [r4, #0]
   229fa:	6823      	ldr	r3, [r4, #0]
   229fc:	4628      	mov	r0, r5
   229fe:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   22a02:	6023      	str	r3, [r4, #0]
   22a04:	f7fd fb2c 	bl	20060 <bsd_os_errno_set>
   22a08:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   22a0c:	4628      	mov	r0, r5
   22a0e:	b005      	add	sp, #20
   22a10:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22a12:	b116      	cbz	r6, 22a1a <logobj_interface_setopt+0x56>
   22a14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   22a16:	2b01      	cmp	r3, #1
   22a18:	d04e      	beq.n	22ab8 <logobj_interface_setopt+0xf4>
   22a1a:	6823      	ldr	r3, [r4, #0]
   22a1c:	2516      	movs	r5, #22
   22a1e:	e7e9      	b.n	229f4 <logobj_interface_setopt+0x30>
   22a20:	2e00      	cmp	r6, #0
   22a22:	d0fa      	beq.n	22a1a <logobj_interface_setopt+0x56>
   22a24:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   22a26:	2b04      	cmp	r3, #4
   22a28:	d1f7      	bne.n	22a1a <logobj_interface_setopt+0x56>
   22a2a:	2100      	movs	r1, #0
   22a2c:	a803      	add	r0, sp, #12
   22a2e:	f004 fca1 	bl	27374 <rpc_logobj_client_request_alloc>
   22a32:	4605      	mov	r5, r0
   22a34:	2800      	cmp	r0, #0
   22a36:	d175      	bne.n	22b24 <logobj_interface_setopt+0x160>
   22a38:	9803      	ldr	r0, [sp, #12]
   22a3a:	2208      	movs	r2, #8
   22a3c:	4629      	mov	r1, r5
   22a3e:	300c      	adds	r0, #12
   22a40:	f016 fb04 	bl	3904c <memset>
   22a44:	9803      	ldr	r0, [sp, #12]
   22a46:	4631      	mov	r1, r6
   22a48:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   22a4a:	300c      	adds	r0, #12
   22a4c:	f016 fac4 	bl	38fd8 <memcpy>
   22a50:	2308      	movs	r3, #8
   22a52:	9803      	ldr	r0, [sp, #12]
   22a54:	f247 0102 	movw	r1, #28674	; 0x7002
   22a58:	7203      	strb	r3, [r0, #8]
   22a5a:	7245      	strb	r5, [r0, #9]
   22a5c:	7285      	strb	r5, [r0, #10]
   22a5e:	72c5      	strb	r5, [r0, #11]
   22a60:	6823      	ldr	r3, [r4, #0]
   22a62:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   22a66:	6023      	str	r3, [r4, #0]
   22a68:	f004 fc9c 	bl	273a4 <rpc_logobj_client_request_send>
   22a6c:	2800      	cmp	r0, #0
   22a6e:	d178      	bne.n	22b62 <logobj_interface_setopt+0x19e>
   22a70:	6a61      	ldr	r1, [r4, #36]	; 0x24
   22a72:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   22a76:	2900      	cmp	r1, #0
   22a78:	bf08      	it	eq
   22a7a:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   22a7e:	ab04      	add	r3, sp, #16
   22a80:	f843 1d08 	str.w	r1, [r3, #-8]!
   22a84:	4638      	mov	r0, r7
   22a86:	4611      	mov	r1, r2
   22a88:	f007 fe3a 	bl	2a700 <interface_socket_wait>
   22a8c:	4605      	mov	r5, r0
   22a8e:	2800      	cmp	r0, #0
   22a90:	d140      	bne.n	22b14 <logobj_interface_setopt+0x150>
   22a92:	4638      	mov	r0, r7
   22a94:	f007 fea8 	bl	2a7e8 <interface_socket_from_handle_get>
   22a98:	2800      	cmp	r0, #0
   22a9a:	d04e      	beq.n	22b3a <logobj_interface_setopt+0x176>
   22a9c:	6843      	ldr	r3, [r0, #4]
   22a9e:	2b00      	cmp	r3, #0
   22aa0:	d04b      	beq.n	22b3a <logobj_interface_setopt+0x176>
   22aa2:	6045      	str	r5, [r0, #4]
   22aa4:	461d      	mov	r5, r3
   22aa6:	e035      	b.n	22b14 <logobj_interface_setopt+0x150>
   22aa8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   22aaa:	9400      	str	r4, [sp, #0]
   22aac:	f007 fec4 	bl	2a838 <interface_socket_setopt>
   22ab0:	4605      	mov	r5, r0
   22ab2:	4628      	mov	r0, r5
   22ab4:	b005      	add	sp, #20
   22ab6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22ab8:	2100      	movs	r1, #0
   22aba:	a802      	add	r0, sp, #8
   22abc:	7835      	ldrb	r5, [r6, #0]
   22abe:	f004 fc59 	bl	27374 <rpc_logobj_client_request_alloc>
   22ac2:	bb78      	cbnz	r0, 22b24 <logobj_interface_setopt+0x160>
   22ac4:	2d01      	cmp	r5, #1
   22ac6:	bf08      	it	eq
   22ac8:	4b2c      	ldreq	r3, [pc, #176]	; (22b7c <logobj_interface_setopt+0x1b8>)
   22aca:	f04f 0204 	mov.w	r2, #4
   22ace:	bf08      	it	eq
   22ad0:	701d      	strbeq	r5, [r3, #0]
   22ad2:	2300      	movs	r3, #0
   22ad4:	9802      	ldr	r0, [sp, #8]
   22ad6:	f247 0101 	movw	r1, #28673	; 0x7001
   22ada:	7243      	strb	r3, [r0, #9]
   22adc:	60c5      	str	r5, [r0, #12]
   22ade:	7283      	strb	r3, [r0, #10]
   22ae0:	72c3      	strb	r3, [r0, #11]
   22ae2:	7202      	strb	r2, [r0, #8]
   22ae4:	6823      	ldr	r3, [r4, #0]
   22ae6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   22aea:	6023      	str	r3, [r4, #0]
   22aec:	f004 fc5a 	bl	273a4 <rpc_logobj_client_request_send>
   22af0:	4606      	mov	r6, r0
   22af2:	bb80      	cbnz	r0, 22b56 <logobj_interface_setopt+0x192>
   22af4:	6a61      	ldr	r1, [r4, #36]	; 0x24
   22af6:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   22afa:	2900      	cmp	r1, #0
   22afc:	bf08      	it	eq
   22afe:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   22b02:	ab04      	add	r3, sp, #16
   22b04:	f843 1d04 	str.w	r1, [r3, #-4]!
   22b08:	4638      	mov	r0, r7
   22b0a:	4611      	mov	r1, r2
   22b0c:	f007 fdf8 	bl	2a700 <interface_socket_wait>
   22b10:	4605      	mov	r5, r0
   22b12:	b150      	cbz	r0, 22b2a <logobj_interface_setopt+0x166>
   22b14:	6823      	ldr	r3, [r4, #0]
   22b16:	e76d      	b.n	229f4 <logobj_interface_setopt+0x30>
   22b18:	202a      	movs	r0, #42	; 0x2a
   22b1a:	f7fd faa1 	bl	20060 <bsd_os_errno_set>
   22b1e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   22b22:	e773      	b.n	22a0c <logobj_interface_setopt+0x48>
   22b24:	6823      	ldr	r3, [r4, #0]
   22b26:	250c      	movs	r5, #12
   22b28:	e764      	b.n	229f4 <logobj_interface_setopt+0x30>
   22b2a:	4638      	mov	r0, r7
   22b2c:	f007 fe5c 	bl	2a7e8 <interface_socket_from_handle_get>
   22b30:	b140      	cbz	r0, 22b44 <logobj_interface_setopt+0x180>
   22b32:	6845      	ldr	r5, [r0, #4]
   22b34:	b135      	cbz	r5, 22b44 <logobj_interface_setopt+0x180>
   22b36:	6046      	str	r6, [r0, #4]
   22b38:	e7ec      	b.n	22b14 <logobj_interface_setopt+0x150>
   22b3a:	4631      	mov	r1, r6
   22b3c:	2204      	movs	r2, #4
   22b3e:	4810      	ldr	r0, [pc, #64]	; (22b80 <logobj_interface_setopt+0x1bc>)
   22b40:	f016 fa4a 	bl	38fd8 <memcpy>
   22b44:	6823      	ldr	r3, [r4, #0]
   22b46:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   22b4a:	6023      	str	r3, [r4, #0]
   22b4c:	6823      	ldr	r3, [r4, #0]
   22b4e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   22b52:	6023      	str	r3, [r4, #0]
   22b54:	e75a      	b.n	22a0c <logobj_interface_setopt+0x48>
   22b56:	9802      	ldr	r0, [sp, #8]
   22b58:	f004 fc3a 	bl	273d0 <rpc_logobj_client_message_free>
   22b5c:	2505      	movs	r5, #5
   22b5e:	6823      	ldr	r3, [r4, #0]
   22b60:	e748      	b.n	229f4 <logobj_interface_setopt+0x30>
   22b62:	9803      	ldr	r0, [sp, #12]
   22b64:	f004 fc34 	bl	273d0 <rpc_logobj_client_message_free>
   22b68:	2505      	movs	r5, #5
   22b6a:	6823      	ldr	r3, [r4, #0]
   22b6c:	e742      	b.n	229f4 <logobj_interface_setopt+0x30>
   22b6e:	2009      	movs	r0, #9
   22b70:	f7fd fa76 	bl	20060 <bsd_os_errno_set>
   22b74:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   22b78:	e748      	b.n	22a0c <logobj_interface_setopt+0x48>
   22b7a:	bf00      	nop
   22b7c:	20029080 	.word	0x20029080
   22b80:	200224c0 	.word	0x200224c0

00022b84 <logobj_interface_getopt>:
   22b84:	b5f0      	push	{r4, r5, r6, r7, lr}
   22b86:	2901      	cmp	r1, #1
   22b88:	b083      	sub	sp, #12
   22b8a:	9e08      	ldr	r6, [sp, #32]
   22b8c:	d030      	beq.n	22bf0 <logobj_interface_getopt+0x6c>
   22b8e:	461f      	mov	r7, r3
   22b90:	f240 2305 	movw	r3, #517	; 0x205
   22b94:	4299      	cmp	r1, r3
   22b96:	d134      	bne.n	22c02 <logobj_interface_getopt+0x7e>
   22b98:	4615      	mov	r5, r2
   22b9a:	f007 fe25 	bl	2a7e8 <interface_socket_from_handle_get>
   22b9e:	2800      	cmp	r0, #0
   22ba0:	d037      	beq.n	22c12 <logobj_interface_getopt+0x8e>
   22ba2:	2d01      	cmp	r5, #1
   22ba4:	d015      	beq.n	22bd2 <logobj_interface_getopt+0x4e>
   22ba6:	2d02      	cmp	r5, #2
   22ba8:	d10b      	bne.n	22bc2 <logobj_interface_getopt+0x3e>
   22baa:	b387      	cbz	r7, 22c0e <logobj_interface_getopt+0x8a>
   22bac:	6833      	ldr	r3, [r6, #0]
   22bae:	b373      	cbz	r3, 22c0e <logobj_interface_getopt+0x8a>
   22bb0:	2300      	movs	r3, #0
   22bb2:	2201      	movs	r2, #1
   22bb4:	4618      	mov	r0, r3
   22bb6:	491a      	ldr	r1, [pc, #104]	; (22c20 <logobj_interface_getopt+0x9c>)
   22bb8:	7809      	ldrb	r1, [r1, #0]
   22bba:	7039      	strb	r1, [r7, #0]
   22bbc:	6032      	str	r2, [r6, #0]
   22bbe:	b003      	add	sp, #12
   22bc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22bc2:	2009      	movs	r0, #9
   22bc4:	f7fd fa4c 	bl	20060 <bsd_os_errno_set>
   22bc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22bcc:	4618      	mov	r0, r3
   22bce:	b003      	add	sp, #12
   22bd0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22bd2:	b1e7      	cbz	r7, 22c0e <logobj_interface_getopt+0x8a>
   22bd4:	6833      	ldr	r3, [r6, #0]
   22bd6:	2b03      	cmp	r3, #3
   22bd8:	d919      	bls.n	22c0e <logobj_interface_getopt+0x8a>
   22bda:	4638      	mov	r0, r7
   22bdc:	2204      	movs	r2, #4
   22bde:	4911      	ldr	r1, [pc, #68]	; (22c24 <logobj_interface_getopt+0xa0>)
   22be0:	f016 f9fa 	bl	38fd8 <memcpy>
   22be4:	2300      	movs	r3, #0
   22be6:	2204      	movs	r2, #4
   22be8:	4618      	mov	r0, r3
   22bea:	6032      	str	r2, [r6, #0]
   22bec:	b003      	add	sp, #12
   22bee:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22bf0:	9600      	str	r6, [sp, #0]
   22bf2:	f007 fe67 	bl	2a8c4 <interface_socket_getopt>
   22bf6:	4603      	mov	r3, r0
   22bf8:	2800      	cmp	r0, #0
   22bfa:	d1e3      	bne.n	22bc4 <logobj_interface_getopt+0x40>
   22bfc:	4618      	mov	r0, r3
   22bfe:	b003      	add	sp, #12
   22c00:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22c02:	202a      	movs	r0, #42	; 0x2a
   22c04:	f7fd fa2c 	bl	20060 <bsd_os_errno_set>
   22c08:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22c0c:	e7de      	b.n	22bcc <logobj_interface_getopt+0x48>
   22c0e:	2016      	movs	r0, #22
   22c10:	e7d8      	b.n	22bc4 <logobj_interface_getopt+0x40>
   22c12:	2009      	movs	r0, #9
   22c14:	f7fd fa24 	bl	20060 <bsd_os_errno_set>
   22c18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   22c1c:	e7d6      	b.n	22bcc <logobj_interface_getopt+0x48>
   22c1e:	bf00      	nop
   22c20:	20029081 	.word	0x20029081
   22c24:	200224c0 	.word	0x200224c0

00022c28 <logobj_interface_close>:
   22c28:	b510      	push	{r4, lr}
   22c2a:	4604      	mov	r4, r0
   22c2c:	f007 fddc 	bl	2a7e8 <interface_socket_from_handle_get>
   22c30:	b138      	cbz	r0, 22c42 <logobj_interface_close+0x1a>
   22c32:	4620      	mov	r0, r4
   22c34:	f007 fd16 	bl	2a664 <interface_socket_free>
   22c38:	2300      	movs	r3, #0
   22c3a:	4a05      	ldr	r2, [pc, #20]	; (22c50 <logobj_interface_close+0x28>)
   22c3c:	4618      	mov	r0, r3
   22c3e:	6013      	str	r3, [r2, #0]
   22c40:	bd10      	pop	{r4, pc}
   22c42:	2009      	movs	r0, #9
   22c44:	f7fd fa0c 	bl	20060 <bsd_os_errno_set>
   22c48:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   22c4c:	bd10      	pop	{r4, pc}
   22c4e:	bf00      	nop
   22c50:	200224c4 	.word	0x200224c4

00022c54 <rpc_transport_send>:
   22c54:	f000 bece 	b.w	239f4 <rpc_transport_ipc_send>

00022c58 <rpc_transport_rpc_alloc>:
   22c58:	f000 bf4e 	b.w	23af8 <rpc_transport_ipc_tx_rpc_data_alloc>

00022c5c <rpc_transport_data_alloc>:
   22c5c:	f000 bfb4 	b.w	23bc8 <rpc_transport_ipc_tx_data_alloc>

00022c60 <rpc_transport_rpc_free>:
   22c60:	f000 bdac 	b.w	237bc <rpc_transport_ipc_msg_free>

00022c64 <rpc_transport_data_free>:
   22c64:	f000 ba64 	b.w	23130 <rpc_transport_ipc_data_free>

00022c68 <ipc_trace_init>:
   22c68:	4b01      	ldr	r3, [pc, #4]	; (22c70 <ipc_trace_init+0x8>)
   22c6a:	6018      	str	r0, [r3, #0]
   22c6c:	4770      	bx	lr
   22c6e:	bf00      	nop
   22c70:	200224d4 	.word	0x200224d4

00022c74 <bsd_os_trace_irq_handler>:
   22c74:	b5f0      	push	{r4, r5, r6, r7, lr}
   22c76:	4b6e      	ldr	r3, [pc, #440]	; (22e30 <bsd_os_trace_irq_handler+0x1bc>)
   22c78:	b083      	sub	sp, #12
   22c7a:	781b      	ldrb	r3, [r3, #0]
   22c7c:	2b00      	cmp	r3, #0
   22c7e:	f000 80d3 	beq.w	22e28 <bsd_os_trace_irq_handler+0x1b4>
   22c82:	4b6c      	ldr	r3, [pc, #432]	; (22e34 <bsd_os_trace_irq_handler+0x1c0>)
   22c84:	681c      	ldr	r4, [r3, #0]
   22c86:	b124      	cbz	r4, 22c92 <bsd_os_trace_irq_handler+0x1e>
   22c88:	68a3      	ldr	r3, [r4, #8]
   22c8a:	6862      	ldr	r2, [r4, #4]
   22c8c:	4293      	cmp	r3, r2
   22c8e:	f040 808c 	bne.w	22daa <bsd_os_trace_irq_handler+0x136>
   22c92:	4b69      	ldr	r3, [pc, #420]	; (22e38 <bsd_os_trace_irq_handler+0x1c4>)
   22c94:	681c      	ldr	r4, [r3, #0]
   22c96:	b11c      	cbz	r4, 22ca0 <bsd_os_trace_irq_handler+0x2c>
   22c98:	68a3      	ldr	r3, [r4, #8]
   22c9a:	6862      	ldr	r2, [r4, #4]
   22c9c:	4293      	cmp	r3, r2
   22c9e:	d146      	bne.n	22d2e <bsd_os_trace_irq_handler+0xba>
   22ca0:	4b66      	ldr	r3, [pc, #408]	; (22e3c <bsd_os_trace_irq_handler+0x1c8>)
   22ca2:	681c      	ldr	r4, [r3, #0]
   22ca4:	b11c      	cbz	r4, 22cae <bsd_os_trace_irq_handler+0x3a>
   22ca6:	68a3      	ldr	r3, [r4, #8]
   22ca8:	6862      	ldr	r2, [r4, #4]
   22caa:	4293      	cmp	r3, r2
   22cac:	d101      	bne.n	22cb2 <bsd_os_trace_irq_handler+0x3e>
   22cae:	b003      	add	sp, #12
   22cb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22cb2:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   22cb6:	f8ad 2000 	strh.w	r2, [sp]
   22cba:	7822      	ldrb	r2, [r4, #0]
   22cbc:	466e      	mov	r6, sp
   22cbe:	f88d 2004 	strb.w	r2, [sp, #4]
   22cc2:	6862      	ldr	r2, [r4, #4]
   22cc4:	2105      	movs	r1, #5
   22cc6:	4293      	cmp	r3, r2
   22cc8:	bf2a      	itet	cs
   22cca:	6927      	ldrcs	r7, [r4, #16]
   22ccc:	1ad7      	subcc	r7, r2, r3
   22cce:	1aff      	subcs	r7, r7, r3
   22cd0:	4293      	cmp	r3, r2
   22cd2:	bf94      	ite	ls
   22cd4:	2500      	movls	r5, #0
   22cd6:	68e5      	ldrhi	r5, [r4, #12]
   22cd8:	b2bf      	uxth	r7, r7
   22cda:	bf88      	it	hi
   22cdc:	1b52      	subhi	r2, r2, r5
   22cde:	4630      	mov	r0, r6
   22ce0:	bf88      	it	hi
   22ce2:	b295      	uxthhi	r5, r2
   22ce4:	f8ad 7002 	strh.w	r7, [sp, #2]
   22ce8:	f015 fa47 	bl	3817a <bsd_os_trace_put>
   22cec:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22cf0:	68a0      	ldr	r0, [r4, #8]
   22cf2:	f015 fa42 	bl	3817a <bsd_os_trace_put>
   22cf6:	68a3      	ldr	r3, [r4, #8]
   22cf8:	6922      	ldr	r2, [r4, #16]
   22cfa:	441f      	add	r7, r3
   22cfc:	4297      	cmp	r7, r2
   22cfe:	bf08      	it	eq
   22d00:	68e3      	ldreq	r3, [r4, #12]
   22d02:	60a7      	str	r7, [r4, #8]
   22d04:	bf08      	it	eq
   22d06:	60a3      	streq	r3, [r4, #8]
   22d08:	2d00      	cmp	r5, #0
   22d0a:	d0d0      	beq.n	22cae <bsd_os_trace_irq_handler+0x3a>
   22d0c:	2105      	movs	r1, #5
   22d0e:	4630      	mov	r0, r6
   22d10:	f8ad 5002 	strh.w	r5, [sp, #2]
   22d14:	f015 fa31 	bl	3817a <bsd_os_trace_put>
   22d18:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22d1c:	68e0      	ldr	r0, [r4, #12]
   22d1e:	f015 fa2c 	bl	3817a <bsd_os_trace_put>
   22d22:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   22d26:	68e3      	ldr	r3, [r4, #12]
   22d28:	4413      	add	r3, r2
   22d2a:	60a3      	str	r3, [r4, #8]
   22d2c:	e7bf      	b.n	22cae <bsd_os_trace_irq_handler+0x3a>
   22d2e:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   22d32:	f8ad 2000 	strh.w	r2, [sp]
   22d36:	7822      	ldrb	r2, [r4, #0]
   22d38:	466e      	mov	r6, sp
   22d3a:	f88d 2004 	strb.w	r2, [sp, #4]
   22d3e:	6862      	ldr	r2, [r4, #4]
   22d40:	2105      	movs	r1, #5
   22d42:	4293      	cmp	r3, r2
   22d44:	bf2a      	itet	cs
   22d46:	6927      	ldrcs	r7, [r4, #16]
   22d48:	1ad7      	subcc	r7, r2, r3
   22d4a:	1aff      	subcs	r7, r7, r3
   22d4c:	4293      	cmp	r3, r2
   22d4e:	bf94      	ite	ls
   22d50:	2500      	movls	r5, #0
   22d52:	68e5      	ldrhi	r5, [r4, #12]
   22d54:	b2bf      	uxth	r7, r7
   22d56:	bf88      	it	hi
   22d58:	1b52      	subhi	r2, r2, r5
   22d5a:	4630      	mov	r0, r6
   22d5c:	bf88      	it	hi
   22d5e:	b295      	uxthhi	r5, r2
   22d60:	f8ad 7002 	strh.w	r7, [sp, #2]
   22d64:	f015 fa09 	bl	3817a <bsd_os_trace_put>
   22d68:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22d6c:	68a0      	ldr	r0, [r4, #8]
   22d6e:	f015 fa04 	bl	3817a <bsd_os_trace_put>
   22d72:	68a3      	ldr	r3, [r4, #8]
   22d74:	6922      	ldr	r2, [r4, #16]
   22d76:	441f      	add	r7, r3
   22d78:	4297      	cmp	r7, r2
   22d7a:	bf08      	it	eq
   22d7c:	68e3      	ldreq	r3, [r4, #12]
   22d7e:	60a7      	str	r7, [r4, #8]
   22d80:	bf08      	it	eq
   22d82:	60a3      	streq	r3, [r4, #8]
   22d84:	2d00      	cmp	r5, #0
   22d86:	d08b      	beq.n	22ca0 <bsd_os_trace_irq_handler+0x2c>
   22d88:	2105      	movs	r1, #5
   22d8a:	4630      	mov	r0, r6
   22d8c:	f8ad 5002 	strh.w	r5, [sp, #2]
   22d90:	f015 f9f3 	bl	3817a <bsd_os_trace_put>
   22d94:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22d98:	68e0      	ldr	r0, [r4, #12]
   22d9a:	f015 f9ee 	bl	3817a <bsd_os_trace_put>
   22d9e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   22da2:	68e3      	ldr	r3, [r4, #12]
   22da4:	4413      	add	r3, r2
   22da6:	60a3      	str	r3, [r4, #8]
   22da8:	e77a      	b.n	22ca0 <bsd_os_trace_irq_handler+0x2c>
   22daa:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   22dae:	f8ad 2000 	strh.w	r2, [sp]
   22db2:	7822      	ldrb	r2, [r4, #0]
   22db4:	466e      	mov	r6, sp
   22db6:	f88d 2004 	strb.w	r2, [sp, #4]
   22dba:	6862      	ldr	r2, [r4, #4]
   22dbc:	2105      	movs	r1, #5
   22dbe:	4293      	cmp	r3, r2
   22dc0:	bf2a      	itet	cs
   22dc2:	6927      	ldrcs	r7, [r4, #16]
   22dc4:	1ad7      	subcc	r7, r2, r3
   22dc6:	1aff      	subcs	r7, r7, r3
   22dc8:	4293      	cmp	r3, r2
   22dca:	bf94      	ite	ls
   22dcc:	2500      	movls	r5, #0
   22dce:	68e5      	ldrhi	r5, [r4, #12]
   22dd0:	b2bf      	uxth	r7, r7
   22dd2:	bf88      	it	hi
   22dd4:	1b52      	subhi	r2, r2, r5
   22dd6:	4630      	mov	r0, r6
   22dd8:	bf88      	it	hi
   22dda:	b295      	uxthhi	r5, r2
   22ddc:	f8ad 7002 	strh.w	r7, [sp, #2]
   22de0:	f015 f9cb 	bl	3817a <bsd_os_trace_put>
   22de4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22de8:	68a0      	ldr	r0, [r4, #8]
   22dea:	f015 f9c6 	bl	3817a <bsd_os_trace_put>
   22dee:	68a3      	ldr	r3, [r4, #8]
   22df0:	6922      	ldr	r2, [r4, #16]
   22df2:	441f      	add	r7, r3
   22df4:	4297      	cmp	r7, r2
   22df6:	bf08      	it	eq
   22df8:	68e3      	ldreq	r3, [r4, #12]
   22dfa:	60a7      	str	r7, [r4, #8]
   22dfc:	bf08      	it	eq
   22dfe:	60a3      	streq	r3, [r4, #8]
   22e00:	2d00      	cmp	r5, #0
   22e02:	f43f af46 	beq.w	22c92 <bsd_os_trace_irq_handler+0x1e>
   22e06:	2105      	movs	r1, #5
   22e08:	4630      	mov	r0, r6
   22e0a:	f8ad 5002 	strh.w	r5, [sp, #2]
   22e0e:	f015 f9b4 	bl	3817a <bsd_os_trace_put>
   22e12:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22e16:	68e0      	ldr	r0, [r4, #12]
   22e18:	f015 f9af 	bl	3817a <bsd_os_trace_put>
   22e1c:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   22e20:	68e3      	ldr	r3, [r4, #12]
   22e22:	4413      	add	r3, r2
   22e24:	60a3      	str	r3, [r4, #8]
   22e26:	e734      	b.n	22c92 <bsd_os_trace_irq_handler+0x1e>
   22e28:	f7fd fa2a 	bl	20280 <bsd_os_trace_irq_clear>
   22e2c:	e729      	b.n	22c82 <bsd_os_trace_irq_handler+0xe>
   22e2e:	bf00      	nop
   22e30:	20029083 	.word	0x20029083
   22e34:	200224d0 	.word	0x200224d0
   22e38:	200224c8 	.word	0x200224c8
   22e3c:	200224cc 	.word	0x200224cc

00022e40 <ipc_trace_handle>:
   22e40:	2200      	movs	r2, #0
   22e42:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22e46:	4bb2      	ldr	r3, [pc, #712]	; (23110 <ipc_trace_handle+0x2d0>)
   22e48:	b083      	sub	sp, #12
   22e4a:	681b      	ldr	r3, [r3, #0]
   22e4c:	6919      	ldr	r1, [r3, #16]
   22e4e:	695c      	ldr	r4, [r3, #20]
   22e50:	7c18      	ldrb	r0, [r3, #16]
   22e52:	741a      	strb	r2, [r3, #16]
   22e54:	7c58      	ldrb	r0, [r3, #17]
   22e56:	745a      	strb	r2, [r3, #17]
   22e58:	7c98      	ldrb	r0, [r3, #18]
   22e5a:	749a      	strb	r2, [r3, #18]
   22e5c:	7cd8      	ldrb	r0, [r3, #19]
   22e5e:	74da      	strb	r2, [r3, #19]
   22e60:	7d18      	ldrb	r0, [r3, #20]
   22e62:	751a      	strb	r2, [r3, #20]
   22e64:	7d58      	ldrb	r0, [r3, #21]
   22e66:	755a      	strb	r2, [r3, #21]
   22e68:	7d98      	ldrb	r0, [r3, #22]
   22e6a:	759a      	strb	r2, [r3, #22]
   22e6c:	7dd8      	ldrb	r0, [r3, #23]
   22e6e:	75da      	strb	r2, [r3, #23]
   22e70:	b1a9      	cbz	r1, 22e9e <ipc_trace_handle+0x5e>
   22e72:	3901      	subs	r1, #1
   22e74:	2903      	cmp	r1, #3
   22e76:	d812      	bhi.n	22e9e <ipc_trace_handle+0x5e>
   22e78:	e8df f001 	tbb	[pc, r1]
   22e7c:	1402a97c 	.word	0x1402a97c
   22e80:	2501      	movs	r5, #1
   22e82:	2003      	movs	r0, #3
   22e84:	2200      	movs	r2, #0
   22e86:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   22e8a:	4ca2      	ldr	r4, [pc, #648]	; (23114 <ipc_trace_handle+0x2d4>)
   22e8c:	7025      	strb	r5, [r4, #0]
   22e8e:	7a1c      	ldrb	r4, [r3, #8]
   22e90:	7218      	strb	r0, [r3, #8]
   22e92:	7a58      	ldrb	r0, [r3, #9]
   22e94:	725a      	strb	r2, [r3, #9]
   22e96:	7a98      	ldrb	r0, [r3, #10]
   22e98:	729a      	strb	r2, [r3, #10]
   22e9a:	7ada      	ldrb	r2, [r3, #11]
   22e9c:	72d9      	strb	r1, [r3, #11]
   22e9e:	b003      	add	sp, #12
   22ea0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22ea4:	2104      	movs	r1, #4
   22ea6:	2200      	movs	r2, #0
   22ea8:	f06f 005f 	mvn.w	r0, #95	; 0x5f
   22eac:	7a1c      	ldrb	r4, [r3, #8]
   22eae:	7219      	strb	r1, [r3, #8]
   22eb0:	7a59      	ldrb	r1, [r3, #9]
   22eb2:	725a      	strb	r2, [r3, #9]
   22eb4:	4997      	ldr	r1, [pc, #604]	; (23114 <ipc_trace_handle+0x2d4>)
   22eb6:	7a9c      	ldrb	r4, [r3, #10]
   22eb8:	729a      	strb	r2, [r3, #10]
   22eba:	7adc      	ldrb	r4, [r3, #11]
   22ebc:	72d8      	strb	r0, [r3, #11]
   22ebe:	700a      	strb	r2, [r1, #0]
   22ec0:	780b      	ldrb	r3, [r1, #0]
   22ec2:	2b00      	cmp	r3, #0
   22ec4:	f000 809f 	beq.w	23006 <ipc_trace_handle+0x1c6>
   22ec8:	4b93      	ldr	r3, [pc, #588]	; (23118 <ipc_trace_handle+0x2d8>)
   22eca:	681c      	ldr	r4, [r3, #0]
   22ecc:	b124      	cbz	r4, 22ed8 <ipc_trace_handle+0x98>
   22ece:	68a3      	ldr	r3, [r4, #8]
   22ed0:	6862      	ldr	r2, [r4, #4]
   22ed2:	4293      	cmp	r3, r2
   22ed4:	f040 80d9 	bne.w	2308a <ipc_trace_handle+0x24a>
   22ed8:	4b90      	ldr	r3, [pc, #576]	; (2311c <ipc_trace_handle+0x2dc>)
   22eda:	681c      	ldr	r4, [r3, #0]
   22edc:	b124      	cbz	r4, 22ee8 <ipc_trace_handle+0xa8>
   22ede:	68a3      	ldr	r3, [r4, #8]
   22ee0:	6862      	ldr	r2, [r4, #4]
   22ee2:	4293      	cmp	r3, r2
   22ee4:	f040 8092 	bne.w	2300c <ipc_trace_handle+0x1cc>
   22ee8:	4b8d      	ldr	r3, [pc, #564]	; (23120 <ipc_trace_handle+0x2e0>)
   22eea:	681c      	ldr	r4, [r3, #0]
   22eec:	2c00      	cmp	r4, #0
   22eee:	d0d6      	beq.n	22e9e <ipc_trace_handle+0x5e>
   22ef0:	68a3      	ldr	r3, [r4, #8]
   22ef2:	6862      	ldr	r2, [r4, #4]
   22ef4:	4293      	cmp	r3, r2
   22ef6:	d0d2      	beq.n	22e9e <ipc_trace_handle+0x5e>
   22ef8:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   22efc:	f8ad 2000 	strh.w	r2, [sp]
   22f00:	7822      	ldrb	r2, [r4, #0]
   22f02:	466e      	mov	r6, sp
   22f04:	f88d 2004 	strb.w	r2, [sp, #4]
   22f08:	6862      	ldr	r2, [r4, #4]
   22f0a:	2105      	movs	r1, #5
   22f0c:	4293      	cmp	r3, r2
   22f0e:	bf2a      	itet	cs
   22f10:	6927      	ldrcs	r7, [r4, #16]
   22f12:	1ad7      	subcc	r7, r2, r3
   22f14:	1aff      	subcs	r7, r7, r3
   22f16:	4293      	cmp	r3, r2
   22f18:	bf94      	ite	ls
   22f1a:	2500      	movls	r5, #0
   22f1c:	68e5      	ldrhi	r5, [r4, #12]
   22f1e:	b2bf      	uxth	r7, r7
   22f20:	bf88      	it	hi
   22f22:	1b52      	subhi	r2, r2, r5
   22f24:	4630      	mov	r0, r6
   22f26:	bf88      	it	hi
   22f28:	b295      	uxthhi	r5, r2
   22f2a:	f8ad 7002 	strh.w	r7, [sp, #2]
   22f2e:	f015 f924 	bl	3817a <bsd_os_trace_put>
   22f32:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22f36:	68a0      	ldr	r0, [r4, #8]
   22f38:	f015 f91f 	bl	3817a <bsd_os_trace_put>
   22f3c:	68a3      	ldr	r3, [r4, #8]
   22f3e:	6922      	ldr	r2, [r4, #16]
   22f40:	441f      	add	r7, r3
   22f42:	4297      	cmp	r7, r2
   22f44:	bf08      	it	eq
   22f46:	68e3      	ldreq	r3, [r4, #12]
   22f48:	60a7      	str	r7, [r4, #8]
   22f4a:	bf08      	it	eq
   22f4c:	60a3      	streq	r3, [r4, #8]
   22f4e:	2d00      	cmp	r5, #0
   22f50:	d0a5      	beq.n	22e9e <ipc_trace_handle+0x5e>
   22f52:	2105      	movs	r1, #5
   22f54:	4630      	mov	r0, r6
   22f56:	f8ad 5002 	strh.w	r5, [sp, #2]
   22f5a:	f015 f90e 	bl	3817a <bsd_os_trace_put>
   22f5e:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   22f62:	68e0      	ldr	r0, [r4, #12]
   22f64:	f015 f909 	bl	3817a <bsd_os_trace_put>
   22f68:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   22f6c:	68e3      	ldr	r3, [r4, #12]
   22f6e:	4413      	add	r3, r2
   22f70:	60a3      	str	r3, [r4, #8]
   22f72:	e794      	b.n	22e9e <ipc_trace_handle+0x5e>
   22f74:	4a67      	ldr	r2, [pc, #412]	; (23114 <ipc_trace_handle+0x2d4>)
   22f76:	7811      	ldrb	r1, [r2, #0]
   22f78:	b109      	cbz	r1, 22f7e <ipc_trace_handle+0x13e>
   22f7a:	2100      	movs	r1, #0
   22f7c:	7011      	strb	r1, [r2, #0]
   22f7e:	68a5      	ldr	r5, [r4, #8]
   22f80:	2d00      	cmp	r5, #0
   22f82:	d03b      	beq.n	22ffc <ipc_trace_handle+0x1bc>
   22f84:	f04f 0c00 	mov.w	ip, #0
   22f88:	f8df a190 	ldr.w	sl, [pc, #400]	; 2311c <ipc_trace_handle+0x2dc>
   22f8c:	f8df b188 	ldr.w	fp, [pc, #392]	; 23118 <ipc_trace_handle+0x2d8>
   22f90:	4963      	ldr	r1, [pc, #396]	; (23120 <ipc_trace_handle+0x2e0>)
   22f92:	46e1      	mov	r9, ip
   22f94:	4666      	mov	r6, ip
   22f96:	4662      	mov	r2, ip
   22f98:	f8d1 e000 	ldr.w	lr, [r1]
   22f9c:	f8da 8000 	ldr.w	r8, [sl]
   22fa0:	f8db 7000 	ldr.w	r7, [fp]
   22fa4:	e008      	b.n	22fb8 <ipc_trace_handle+0x178>
   22fa6:	2963      	cmp	r1, #99	; 0x63
   22fa8:	d016      	beq.n	22fd8 <ipc_trace_handle+0x198>
   22faa:	2961      	cmp	r1, #97	; 0x61
   22fac:	bf04      	itt	eq
   22fae:	4607      	moveq	r7, r0
   22fb0:	2601      	moveq	r6, #1
   22fb2:	3201      	adds	r2, #1
   22fb4:	42aa      	cmp	r2, r5
   22fb6:	d013      	beq.n	22fe0 <ipc_trace_handle+0x1a0>
   22fb8:	1c91      	adds	r1, r2, #2
   22fba:	eb04 0181 	add.w	r1, r4, r1, lsl #2
   22fbe:	6848      	ldr	r0, [r1, #4]
   22fc0:	7801      	ldrb	r1, [r0, #0]
   22fc2:	2962      	cmp	r1, #98	; 0x62
   22fc4:	d1ef      	bne.n	22fa6 <ipc_trace_handle+0x166>
   22fc6:	4680      	mov	r8, r0
   22fc8:	f04f 0901 	mov.w	r9, #1
   22fcc:	e7f1      	b.n	22fb2 <ipc_trace_handle+0x172>
   22fce:	f7fd f94f 	bl	20270 <bsd_os_trace_irq_set>
   22fd2:	b003      	add	sp, #12
   22fd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   22fd8:	4686      	mov	lr, r0
   22fda:	f04f 0c01 	mov.w	ip, #1
   22fde:	e7e8      	b.n	22fb2 <ipc_trace_handle+0x172>
   22fe0:	2e00      	cmp	r6, #0
   22fe2:	f040 8091 	bne.w	23108 <ipc_trace_handle+0x2c8>
   22fe6:	f1b9 0f00 	cmp.w	r9, #0
   22fea:	d001      	beq.n	22ff0 <ipc_trace_handle+0x1b0>
   22fec:	f8ca 8000 	str.w	r8, [sl]
   22ff0:	f1bc 0f00 	cmp.w	ip, #0
   22ff4:	d002      	beq.n	22ffc <ipc_trace_handle+0x1bc>
   22ff6:	4a4a      	ldr	r2, [pc, #296]	; (23120 <ipc_trace_handle+0x2e0>)
   22ff8:	f8c2 e000 	str.w	lr, [r2]
   22ffc:	2001      	movs	r0, #1
   22ffe:	2200      	movs	r2, #0
   23000:	f06f 015f 	mvn.w	r1, #95	; 0x5f
   23004:	e743      	b.n	22e8e <ipc_trace_handle+0x4e>
   23006:	f7fd f93b 	bl	20280 <bsd_os_trace_irq_clear>
   2300a:	e75d      	b.n	22ec8 <ipc_trace_handle+0x88>
   2300c:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   23010:	f8ad 2000 	strh.w	r2, [sp]
   23014:	7822      	ldrb	r2, [r4, #0]
   23016:	466e      	mov	r6, sp
   23018:	f88d 2004 	strb.w	r2, [sp, #4]
   2301c:	6862      	ldr	r2, [r4, #4]
   2301e:	2105      	movs	r1, #5
   23020:	4293      	cmp	r3, r2
   23022:	bf2a      	itet	cs
   23024:	6927      	ldrcs	r7, [r4, #16]
   23026:	1ad7      	subcc	r7, r2, r3
   23028:	1aff      	subcs	r7, r7, r3
   2302a:	4293      	cmp	r3, r2
   2302c:	bf94      	ite	ls
   2302e:	2500      	movls	r5, #0
   23030:	68e5      	ldrhi	r5, [r4, #12]
   23032:	b2bf      	uxth	r7, r7
   23034:	bf88      	it	hi
   23036:	1b52      	subhi	r2, r2, r5
   23038:	4630      	mov	r0, r6
   2303a:	bf88      	it	hi
   2303c:	b295      	uxthhi	r5, r2
   2303e:	f8ad 7002 	strh.w	r7, [sp, #2]
   23042:	f015 f89a 	bl	3817a <bsd_os_trace_put>
   23046:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   2304a:	68a0      	ldr	r0, [r4, #8]
   2304c:	f015 f895 	bl	3817a <bsd_os_trace_put>
   23050:	68a3      	ldr	r3, [r4, #8]
   23052:	6922      	ldr	r2, [r4, #16]
   23054:	441f      	add	r7, r3
   23056:	4297      	cmp	r7, r2
   23058:	bf08      	it	eq
   2305a:	68e3      	ldreq	r3, [r4, #12]
   2305c:	60a7      	str	r7, [r4, #8]
   2305e:	bf08      	it	eq
   23060:	60a3      	streq	r3, [r4, #8]
   23062:	2d00      	cmp	r5, #0
   23064:	f43f af40 	beq.w	22ee8 <ipc_trace_handle+0xa8>
   23068:	2105      	movs	r1, #5
   2306a:	4630      	mov	r0, r6
   2306c:	f8ad 5002 	strh.w	r5, [sp, #2]
   23070:	f015 f883 	bl	3817a <bsd_os_trace_put>
   23074:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   23078:	68e0      	ldr	r0, [r4, #12]
   2307a:	f015 f87e 	bl	3817a <bsd_os_trace_put>
   2307e:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   23082:	68e3      	ldr	r3, [r4, #12]
   23084:	4413      	add	r3, r2
   23086:	60a3      	str	r3, [r4, #8]
   23088:	e72e      	b.n	22ee8 <ipc_trace_handle+0xa8>
   2308a:	f64b 62ef 	movw	r2, #48879	; 0xbeef
   2308e:	f8ad 2000 	strh.w	r2, [sp]
   23092:	7822      	ldrb	r2, [r4, #0]
   23094:	466e      	mov	r6, sp
   23096:	f88d 2004 	strb.w	r2, [sp, #4]
   2309a:	6862      	ldr	r2, [r4, #4]
   2309c:	2105      	movs	r1, #5
   2309e:	4293      	cmp	r3, r2
   230a0:	bf2a      	itet	cs
   230a2:	6927      	ldrcs	r7, [r4, #16]
   230a4:	1ad7      	subcc	r7, r2, r3
   230a6:	1aff      	subcs	r7, r7, r3
   230a8:	4293      	cmp	r3, r2
   230aa:	bf94      	ite	ls
   230ac:	2500      	movls	r5, #0
   230ae:	68e5      	ldrhi	r5, [r4, #12]
   230b0:	b2bf      	uxth	r7, r7
   230b2:	bf88      	it	hi
   230b4:	1b52      	subhi	r2, r2, r5
   230b6:	4630      	mov	r0, r6
   230b8:	bf88      	it	hi
   230ba:	b295      	uxthhi	r5, r2
   230bc:	f8ad 7002 	strh.w	r7, [sp, #2]
   230c0:	f015 f85b 	bl	3817a <bsd_os_trace_put>
   230c4:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   230c8:	68a0      	ldr	r0, [r4, #8]
   230ca:	f015 f856 	bl	3817a <bsd_os_trace_put>
   230ce:	68a3      	ldr	r3, [r4, #8]
   230d0:	6922      	ldr	r2, [r4, #16]
   230d2:	441f      	add	r7, r3
   230d4:	4297      	cmp	r7, r2
   230d6:	bf08      	it	eq
   230d8:	68e3      	ldreq	r3, [r4, #12]
   230da:	60a7      	str	r7, [r4, #8]
   230dc:	bf08      	it	eq
   230de:	60a3      	streq	r3, [r4, #8]
   230e0:	2d00      	cmp	r5, #0
   230e2:	f43f aef9 	beq.w	22ed8 <ipc_trace_handle+0x98>
   230e6:	2105      	movs	r1, #5
   230e8:	4630      	mov	r0, r6
   230ea:	f8ad 5002 	strh.w	r5, [sp, #2]
   230ee:	f015 f844 	bl	3817a <bsd_os_trace_put>
   230f2:	f8bd 1002 	ldrh.w	r1, [sp, #2]
   230f6:	68e0      	ldr	r0, [r4, #12]
   230f8:	f015 f83f 	bl	3817a <bsd_os_trace_put>
   230fc:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   23100:	68e3      	ldr	r3, [r4, #12]
   23102:	4413      	add	r3, r2
   23104:	60a3      	str	r3, [r4, #8]
   23106:	e6e7      	b.n	22ed8 <ipc_trace_handle+0x98>
   23108:	f8cb 7000 	str.w	r7, [fp]
   2310c:	e76b      	b.n	22fe6 <ipc_trace_handle+0x1a6>
   2310e:	bf00      	nop
   23110:	200224d4 	.word	0x200224d4
   23114:	20029083 	.word	0x20029083
   23118:	200224d0 	.word	0x200224d0
   2311c:	200224c8 	.word	0x200224c8
   23120:	200224cc 	.word	0x200224cc

00023124 <rpc_trace_coredump_in_progress>:
   23124:	4b01      	ldr	r3, [pc, #4]	; (2312c <rpc_trace_coredump_in_progress+0x8>)
   23126:	7818      	ldrb	r0, [r3, #0]
   23128:	4770      	bx	lr
   2312a:	bf00      	nop
   2312c:	20029083 	.word	0x20029083

00023130 <rpc_transport_ipc_data_free>:
   23130:	b510      	push	{r4, lr}
   23132:	4b0e      	ldr	r3, [pc, #56]	; (2316c <rpc_transport_ipc_data_free+0x3c>)
   23134:	4604      	mov	r4, r0
   23136:	e9d3 2300 	ldrd	r2, r3, [r3]
   2313a:	4413      	add	r3, r2
   2313c:	4298      	cmp	r0, r3
   2313e:	d20d      	bcs.n	2315c <rpc_transport_ipc_data_free+0x2c>
   23140:	4282      	cmp	r2, r0
   23142:	d80b      	bhi.n	2315c <rpc_transport_ipc_data_free+0x2c>
   23144:	f000 fd10 	bl	23b68 <rpc_transport_ipc_tx_rpc_ctrl_alloc>
   23148:	b158      	cbz	r0, 23162 <rpc_transport_ipc_data_free+0x32>
   2314a:	4a09      	ldr	r2, [pc, #36]	; (23170 <rpc_transport_ipc_data_free+0x40>)
   2314c:	6084      	str	r4, [r0, #8]
   2314e:	6002      	str	r2, [r0, #0]
   23150:	f7ff fd80 	bl	22c54 <rpc_transport_send>
   23154:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   23158:	f7fd b87a 	b.w	20250 <bsd_os_application_irq_set>
   2315c:	4620      	mov	r0, r4
   2315e:	f006 ff0b 	bl	29f78 <nrf_shared_free>
   23162:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   23166:	f7fd b873 	b.w	20250 <bsd_os_application_irq_set>
   2316a:	bf00      	nop
   2316c:	200224d8 	.word	0x200224d8
   23170:	00020001 	.word	0x00020001

00023174 <rpc_transport_ipc_init>:
   23174:	b188      	cbz	r0, 2319a <rpc_transport_ipc_init+0x26>
   23176:	b510      	push	{r4, lr}
   23178:	b082      	sub	sp, #8
   2317a:	aa01      	add	r2, sp, #4
   2317c:	4669      	mov	r1, sp
   2317e:	4604      	mov	r4, r0
   23180:	f000 fb4e 	bl	23820 <rpc_transport_ipc_tx_init>
   23184:	4602      	mov	r2, r0
   23186:	b148      	cbz	r0, 2319c <rpc_transport_ipc_init+0x28>
   23188:	4b12      	ldr	r3, [pc, #72]	; (231d4 <rpc_transport_ipc_init+0x60>)
   2318a:	3428      	adds	r4, #40	; 0x28
   2318c:	e894 0003 	ldmia.w	r4, {r0, r1}
   23190:	e883 0003 	stmia.w	r3, {r0, r1}
   23194:	4610      	mov	r0, r2
   23196:	b002      	add	sp, #8
   23198:	bd10      	pop	{r4, pc}
   2319a:	e7fe      	b.n	2319a <rpc_transport_ipc_init+0x26>
   2319c:	e9dd 1200 	ldrd	r1, r2, [sp]
   231a0:	4620      	mov	r0, r4
   231a2:	f000 f9e9 	bl	23578 <rpc_transport_ipc_rx_init>
   231a6:	4602      	mov	r2, r0
   231a8:	4b0a      	ldr	r3, [pc, #40]	; (231d4 <rpc_transport_ipc_init+0x60>)
   231aa:	f104 0128 	add.w	r1, r4, #40	; 0x28
   231ae:	c903      	ldmia	r1, {r0, r1}
   231b0:	e883 0003 	stmia.w	r3, {r0, r1}
   231b4:	2a00      	cmp	r2, #0
   231b6:	d1ed      	bne.n	23194 <rpc_transport_ipc_init+0x20>
   231b8:	f44f 6080 	mov.w	r0, #1024	; 0x400
   231bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   231be:	4906      	ldr	r1, [pc, #24]	; (231d8 <rpc_transport_ipc_init+0x64>)
   231c0:	015b      	lsls	r3, r3, #5
   231c2:	b2db      	uxtb	r3, r3
   231c4:	f881 332a 	strb.w	r3, [r1, #810]	; 0x32a
   231c8:	f8c1 0184 	str.w	r0, [r1, #388]	; 0x184
   231cc:	6048      	str	r0, [r1, #4]
   231ce:	4610      	mov	r0, r2
   231d0:	b002      	add	sp, #8
   231d2:	bd10      	pop	{r4, pc}
   231d4:	200224d8 	.word	0x200224d8
   231d8:	e000e100 	.word	0xe000e100

000231dc <bsd_os_application_irq_handler>:
   231dc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   231e0:	f7fd f83e 	bl	20260 <bsd_os_application_irq_clear>
   231e4:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 232bc <bsd_os_application_irq_handler+0xe0>
   231e8:	f8df b0d4 	ldr.w	fp, [pc, #212]	; 232c0 <bsd_os_application_irq_handler+0xe4>
   231ec:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 232c4 <bsd_os_application_irq_handler+0xe8>
   231f0:	f108 0908 	add.w	r9, r8, #8
   231f4:	f858 7b04 	ldr.w	r7, [r8], #4
   231f8:	6839      	ldr	r1, [r7, #0]
   231fa:	b361      	cbz	r1, 23256 <bsd_os_application_irq_handler+0x7a>
   231fc:	2400      	movs	r4, #0
   231fe:	e002      	b.n	23206 <bsd_os_application_irq_handler+0x2a>
   23200:	3401      	adds	r4, #1
   23202:	428c      	cmp	r4, r1
   23204:	d227      	bcs.n	23256 <bsd_os_application_irq_handler+0x7a>
   23206:	00e6      	lsls	r6, r4, #3
   23208:	19bd      	adds	r5, r7, r6
   2320a:	68aa      	ldr	r2, [r5, #8]
   2320c:	2a00      	cmp	r2, #0
   2320e:	d0f7      	beq.n	23200 <bsd_os_application_irq_handler+0x24>
   23210:	686a      	ldr	r2, [r5, #4]
   23212:	b2d2      	uxtb	r2, r2
   23214:	2a01      	cmp	r2, #1
   23216:	d1f3      	bne.n	23200 <bsd_os_application_irq_handler+0x24>
   23218:	6868      	ldr	r0, [r5, #4]
   2321a:	f8bb 2000 	ldrh.w	r2, [fp]
   2321e:	ebb2 4f10 	cmp.w	r2, r0, lsr #16
   23222:	d1ed      	bne.n	23200 <bsd_os_application_irq_handler+0x24>
   23224:	68a8      	ldr	r0, [r5, #8]
   23226:	6841      	ldr	r1, [r0, #4]
   23228:	b2c9      	uxtb	r1, r1
   2322a:	2902      	cmp	r1, #2
   2322c:	d02c      	beq.n	23288 <bsd_os_application_irq_handler+0xac>
   2322e:	2901      	cmp	r1, #1
   23230:	d015      	beq.n	2325e <bsd_os_application_irq_handler+0x82>
   23232:	3604      	adds	r6, #4
   23234:	59b9      	ldr	r1, [r7, r6]
   23236:	3201      	adds	r2, #1
   23238:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
   2323c:	f041 0103 	orr.w	r1, r1, #3
   23240:	51b9      	str	r1, [r7, r6]
   23242:	f8ab 2000 	strh.w	r2, [fp]
   23246:	f7fd f803 	bl	20250 <bsd_os_application_irq_set>
   2324a:	f858 7c04 	ldr.w	r7, [r8, #-4]
   2324e:	3401      	adds	r4, #1
   23250:	6839      	ldr	r1, [r7, #0]
   23252:	428c      	cmp	r4, r1
   23254:	d3d7      	bcc.n	23206 <bsd_os_application_irq_handler+0x2a>
   23256:	45c1      	cmp	r9, r8
   23258:	d1cc      	bne.n	231f4 <bsd_os_application_irq_handler+0x18>
   2325a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2325e:	6801      	ldr	r1, [r0, #0]
   23260:	0c09      	lsrs	r1, r1, #16
   23262:	f003 f855 	bl	26310 <rpc_handle_ctrl_message>
   23266:	2801      	cmp	r0, #1
   23268:	d014      	beq.n	23294 <bsd_os_application_irq_handler+0xb8>
   2326a:	d310      	bcc.n	2328e <bsd_os_application_irq_handler+0xb2>
   2326c:	2802      	cmp	r0, #2
   2326e:	d007      	beq.n	23280 <bsd_os_application_irq_handler+0xa4>
   23270:	2203      	movs	r2, #3
   23272:	4b11      	ldr	r3, [pc, #68]	; (232b8 <bsd_os_application_irq_handler+0xdc>)
   23274:	4610      	mov	r0, r2
   23276:	f8ca 2000 	str.w	r2, [sl]
   2327a:	601a      	str	r2, [r3, #0]
   2327c:	f005 fc28 	bl	28ad0 <rpc_transport_ipc_fault_handler>
   23280:	f858 7c04 	ldr.w	r7, [r8, #-4]
   23284:	6839      	ldr	r1, [r7, #0]
   23286:	e7bb      	b.n	23200 <bsd_os_application_irq_handler+0x24>
   23288:	f003 f85a 	bl	26340 <rpc_handle_data_message>
   2328c:	e7eb      	b.n	23266 <bsd_os_application_irq_handler+0x8a>
   2328e:	f8bb 2000 	ldrh.w	r2, [fp]
   23292:	e7ce      	b.n	23232 <bsd_os_application_irq_handler+0x56>
   23294:	686a      	ldr	r2, [r5, #4]
   23296:	f8bb 1000 	ldrh.w	r1, [fp]
   2329a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   2329e:	f042 0202 	orr.w	r2, r2, #2
   232a2:	606a      	str	r2, [r5, #4]
   232a4:	1c4a      	adds	r2, r1, #1
   232a6:	f8ab 2000 	strh.w	r2, [fp]
   232aa:	f7fc ffd1 	bl	20250 <bsd_os_application_irq_set>
   232ae:	f858 7c04 	ldr.w	r7, [r8, #-4]
   232b2:	6839      	ldr	r1, [r7, #0]
   232b4:	e7a4      	b.n	23200 <bsd_os_application_irq_handler+0x24>
   232b6:	bf00      	nop
   232b8:	200224e0 	.word	0x200224e0
   232bc:	200224e8 	.word	0x200224e8
   232c0:	20027618 	.word	0x20027618
   232c4:	200224f0 	.word	0x200224f0

000232c8 <IPC_IRQHandler>:
   232c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   232cc:	f44f 6680 	mov.w	r6, #1024	; 0x400
   232d0:	4d95      	ldr	r5, [pc, #596]	; (23528 <IPC_IRQHandler+0x260>)
   232d2:	4c96      	ldr	r4, [pc, #600]	; (2352c <IPC_IRQHandler+0x264>)
   232d4:	f8c5 6184 	str.w	r6, [r5, #388]	; 0x184
   232d8:	f8d4 330c 	ldr.w	r3, [r4, #780]	; 0x30c
   232dc:	b092      	sub	sp, #72	; 0x48
   232de:	0618      	lsls	r0, r3, #24
   232e0:	d50b      	bpl.n	232fa <IPC_IRQHandler+0x32>
   232e2:	f7ff fdad 	bl	22e40 <ipc_trace_handle>
   232e6:	f7ff ff1d 	bl	23124 <rpc_trace_coredump_in_progress>
   232ea:	2800      	cmp	r0, #0
   232ec:	d159      	bne.n	233a2 <IPC_IRQHandler+0xda>
   232ee:	4b90      	ldr	r3, [pc, #576]	; (23530 <IPC_IRQHandler+0x268>)
   232f0:	f8c4 011c 	str.w	r0, [r4, #284]	; 0x11c
   232f4:	681b      	ldr	r3, [r3, #0]
   232f6:	9301      	str	r3, [sp, #4]
   232f8:	9b01      	ldr	r3, [sp, #4]
   232fa:	4c8c      	ldr	r4, [pc, #560]	; (2352c <IPC_IRQHandler+0x264>)
   232fc:	f8d4 530c 	ldr.w	r5, [r4, #780]	; 0x30c
   23300:	f015 0501 	ands.w	r5, r5, #1
   23304:	d11f      	bne.n	23346 <IPC_IRQHandler+0x7e>
   23306:	f8d4 330c 	ldr.w	r3, [r4, #780]	; 0x30c
   2330a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
   2330e:	d14d      	bne.n	233ac <IPC_IRQHandler+0xe4>
   23310:	f8d4 230c 	ldr.w	r2, [r4, #780]	; 0x30c
   23314:	0751      	lsls	r1, r2, #29
   23316:	d50e      	bpl.n	23336 <IPC_IRQHandler+0x6e>
   23318:	4a86      	ldr	r2, [pc, #536]	; (23534 <IPC_IRQHandler+0x26c>)
   2331a:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
   2331e:	6812      	ldr	r2, [r2, #0]
   23320:	4b85      	ldr	r3, [pc, #532]	; (23538 <IPC_IRQHandler+0x270>)
   23322:	9206      	str	r2, [sp, #24]
   23324:	9a06      	ldr	r2, [sp, #24]
   23326:	681a      	ldr	r2, [r3, #0]
   23328:	2a02      	cmp	r2, #2
   2332a:	f000 80e0 	beq.w	234ee <IPC_IRQHandler+0x226>
   2332e:	681a      	ldr	r2, [r3, #0]
   23330:	2a01      	cmp	r2, #1
   23332:	f000 80c1 	beq.w	234b8 <IPC_IRQHandler+0x1f0>
   23336:	4b7d      	ldr	r3, [pc, #500]	; (2352c <IPC_IRQHandler+0x264>)
   23338:	f8d3 230c 	ldr.w	r2, [r3, #780]	; 0x30c
   2333c:	06d2      	lsls	r2, r2, #27
   2333e:	d424      	bmi.n	2338a <IPC_IRQHandler+0xc2>
   23340:	b012      	add	sp, #72	; 0x48
   23342:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23346:	2100      	movs	r1, #0
   23348:	f248 0202 	movw	r2, #32770	; 0x8002
   2334c:	4b7b      	ldr	r3, [pc, #492]	; (2353c <IPC_IRQHandler+0x274>)
   2334e:	f8c4 1100 	str.w	r1, [r4, #256]	; 0x100
   23352:	681b      	ldr	r3, [r3, #0]
   23354:	9302      	str	r3, [sp, #8]
   23356:	9b02      	ldr	r3, [sp, #8]
   23358:	f8d4 3614 	ldr.w	r3, [r4, #1556]	; 0x614
   2335c:	4293      	cmp	r3, r2
   2335e:	f000 80cf 	beq.w	23500 <IPC_IRQHandler+0x238>
   23362:	f200 808d 	bhi.w	23480 <IPC_IRQHandler+0x1b8>
   23366:	2b00      	cmp	r3, #0
   23368:	f000 80c4 	beq.w	234f4 <IPC_IRQHandler+0x22c>
   2336c:	2b02      	cmp	r3, #2
   2336e:	f240 8098 	bls.w	234a2 <IPC_IRQHandler+0x1da>
   23372:	f248 0201 	movw	r2, #32769	; 0x8001
   23376:	4293      	cmp	r3, r2
   23378:	f040 80bc 	bne.w	234f4 <IPC_IRQHandler+0x22c>
   2337c:	2003      	movs	r0, #3
   2337e:	2207      	movs	r2, #7
   23380:	496d      	ldr	r1, [pc, #436]	; (23538 <IPC_IRQHandler+0x270>)
   23382:	4b6f      	ldr	r3, [pc, #444]	; (23540 <IPC_IRQHandler+0x278>)
   23384:	6008      	str	r0, [r1, #0]
   23386:	601a      	str	r2, [r3, #0]
   23388:	e7da      	b.n	23340 <IPC_IRQHandler+0x78>
   2338a:	2100      	movs	r1, #0
   2338c:	4a6d      	ldr	r2, [pc, #436]	; (23544 <IPC_IRQHandler+0x27c>)
   2338e:	f8c3 1110 	str.w	r1, [r3, #272]	; 0x110
   23392:	6813      	ldr	r3, [r2, #0]
   23394:	9307      	str	r3, [sp, #28]
   23396:	9b07      	ldr	r3, [sp, #28]
   23398:	b012      	add	sp, #72	; 0x48
   2339a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2339e:	f7fc bf57 	b.w	20250 <bsd_os_application_irq_set>
   233a2:	23e0      	movs	r3, #224	; 0xe0
   233a4:	f885 332a 	strb.w	r3, [r5, #810]	; 0x32a
   233a8:	606e      	str	r6, [r5, #4]
   233aa:	e7c9      	b.n	23340 <IPC_IRQHandler+0x78>
   233ac:	4b66      	ldr	r3, [pc, #408]	; (23548 <IPC_IRQHandler+0x280>)
   233ae:	f8c4 5118 	str.w	r5, [r4, #280]	; 0x118
   233b2:	681b      	ldr	r3, [r3, #0]
   233b4:	2704      	movs	r7, #4
   233b6:	9305      	str	r3, [sp, #20]
   233b8:	9b05      	ldr	r3, [sp, #20]
   233ba:	f000 fc0f 	bl	23bdc <rpc_transport_ipc_tx_suspend>
   233be:	2210      	movs	r2, #16
   233c0:	f04f 0c01 	mov.w	ip, #1
   233c4:	4961      	ldr	r1, [pc, #388]	; (2354c <IPC_IRQHandler+0x284>)
   233c6:	f8c4 55a0 	str.w	r5, [r4, #1440]	; 0x5a0
   233ca:	680b      	ldr	r3, [r1, #0]
   233cc:	9303      	str	r3, [sp, #12]
   233ce:	4b60      	ldr	r3, [pc, #384]	; (23550 <IPC_IRQHandler+0x288>)
   233d0:	9803      	ldr	r0, [sp, #12]
   233d2:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
   233d6:	6818      	ldr	r0, [r3, #0]
   233d8:	9004      	str	r0, [sp, #16]
   233da:	485e      	ldr	r0, [pc, #376]	; (23554 <IPC_IRQHandler+0x28c>)
   233dc:	9e04      	ldr	r6, [sp, #16]
   233de:	f8c4 5590 	str.w	r5, [r4, #1424]	; 0x590
   233e2:	6800      	ldr	r0, [r0, #0]
   233e4:	2640      	movs	r6, #64	; 0x40
   233e6:	9008      	str	r0, [sp, #32]
   233e8:	485b      	ldr	r0, [pc, #364]	; (23558 <IPC_IRQHandler+0x290>)
   233ea:	f8dd e020 	ldr.w	lr, [sp, #32]
   233ee:	f8c4 5598 	str.w	r5, [r4, #1432]	; 0x598
   233f2:	f8d0 e000 	ldr.w	lr, [r0]
   233f6:	2080      	movs	r0, #128	; 0x80
   233f8:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
   233fc:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
   23400:	f8c4 55a0 	str.w	r5, [r4, #1440]	; 0x5a0
   23404:	f8d1 e000 	ldr.w	lr, [r1]
   23408:	2105      	movs	r1, #5
   2340a:	f8cd e028 	str.w	lr, [sp, #40]	; 0x28
   2340e:	f8df e160 	ldr.w	lr, [pc, #352]	; 23570 <IPC_IRQHandler+0x2a8>
   23412:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
   23416:	f8c4 55a8 	str.w	r5, [r4, #1448]	; 0x5a8
   2341a:	f8de e000 	ldr.w	lr, [lr]
   2341e:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
   23422:	f8df e150 	ldr.w	lr, [pc, #336]	; 23574 <IPC_IRQHandler+0x2ac>
   23426:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
   2342a:	f8c4 55ac 	str.w	r5, [r4, #1452]	; 0x5ac
   2342e:	f8de e000 	ldr.w	lr, [lr]
   23432:	f8cd e030 	str.w	lr, [sp, #48]	; 0x30
   23436:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
   2343a:	f8c4 c308 	str.w	ip, [r4, #776]	; 0x308
   2343e:	f8d3 c000 	ldr.w	ip, [r3]
   23442:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
   23446:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
   2344a:	f8c4 7308 	str.w	r7, [r4, #776]	; 0x308
   2344e:	681f      	ldr	r7, [r3, #0]
   23450:	970e      	str	r7, [sp, #56]	; 0x38
   23452:	9f0e      	ldr	r7, [sp, #56]	; 0x38
   23454:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
   23458:	681a      	ldr	r2, [r3, #0]
   2345a:	920f      	str	r2, [sp, #60]	; 0x3c
   2345c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
   2345e:	f8c4 6308 	str.w	r6, [r4, #776]	; 0x308
   23462:	681e      	ldr	r6, [r3, #0]
   23464:	4a34      	ldr	r2, [pc, #208]	; (23538 <IPC_IRQHandler+0x270>)
   23466:	9610      	str	r6, [sp, #64]	; 0x40
   23468:	9e10      	ldr	r6, [sp, #64]	; 0x40
   2346a:	f8c4 0308 	str.w	r0, [r4, #776]	; 0x308
   2346e:	6818      	ldr	r0, [r3, #0]
   23470:	4b3a      	ldr	r3, [pc, #232]	; (2355c <IPC_IRQHandler+0x294>)
   23472:	9011      	str	r0, [sp, #68]	; 0x44
   23474:	9811      	ldr	r0, [sp, #68]	; 0x44
   23476:	801d      	strh	r5, [r3, #0]
   23478:	6011      	str	r1, [r2, #0]
   2347a:	b012      	add	sp, #72	; 0x48
   2347c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   23480:	4a37      	ldr	r2, [pc, #220]	; (23560 <IPC_IRQHandler+0x298>)
   23482:	4293      	cmp	r3, r2
   23484:	d82a      	bhi.n	234dc <IPC_IRQHandler+0x214>
   23486:	f1b3 6f88 	cmp.w	r3, #71303168	; 0x4400000
   2348a:	d82a      	bhi.n	234e2 <IPC_IRQHandler+0x21a>
   2348c:	f248 0203 	movw	r2, #32771	; 0x8003
   23490:	4293      	cmp	r3, r2
   23492:	d12f      	bne.n	234f4 <IPC_IRQHandler+0x22c>
   23494:	2003      	movs	r0, #3
   23496:	2204      	movs	r2, #4
   23498:	4927      	ldr	r1, [pc, #156]	; (23538 <IPC_IRQHandler+0x270>)
   2349a:	4b29      	ldr	r3, [pc, #164]	; (23540 <IPC_IRQHandler+0x278>)
   2349c:	6008      	str	r0, [r1, #0]
   2349e:	601a      	str	r2, [r3, #0]
   234a0:	e74e      	b.n	23340 <IPC_IRQHandler+0x78>
   234a2:	2303      	movs	r3, #3
   234a4:	4618      	mov	r0, r3
   234a6:	4924      	ldr	r1, [pc, #144]	; (23538 <IPC_IRQHandler+0x270>)
   234a8:	4a25      	ldr	r2, [pc, #148]	; (23540 <IPC_IRQHandler+0x278>)
   234aa:	600b      	str	r3, [r1, #0]
   234ac:	6013      	str	r3, [r2, #0]
   234ae:	b012      	add	sp, #72	; 0x48
   234b0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   234b4:	f005 bb0c 	b.w	28ad0 <rpc_transport_ipc_fault_handler>
   234b8:	4a2a      	ldr	r2, [pc, #168]	; (23564 <IPC_IRQHandler+0x29c>)
   234ba:	482b      	ldr	r0, [pc, #172]	; (23568 <IPC_IRQHandler+0x2a0>)
   234bc:	6811      	ldr	r1, [r2, #0]
   234be:	688a      	ldr	r2, [r1, #8]
   234c0:	6002      	str	r2, [r0, #0]
   234c2:	6849      	ldr	r1, [r1, #4]
   234c4:	6041      	str	r1, [r0, #4]
   234c6:	b312      	cbz	r2, 2350e <IPC_IRQHandler+0x246>
   234c8:	b309      	cbz	r1, 2350e <IPC_IRQHandler+0x246>
   234ca:	6812      	ldr	r2, [r2, #0]
   234cc:	2a10      	cmp	r2, #16
   234ce:	d824      	bhi.n	2351a <IPC_IRQHandler+0x252>
   234d0:	680a      	ldr	r2, [r1, #0]
   234d2:	2a10      	cmp	r2, #16
   234d4:	d821      	bhi.n	2351a <IPC_IRQHandler+0x252>
   234d6:	2202      	movs	r2, #2
   234d8:	601a      	str	r2, [r3, #0]
   234da:	e72c      	b.n	23336 <IPC_IRQHandler+0x6e>
   234dc:	4a23      	ldr	r2, [pc, #140]	; (2356c <IPC_IRQHandler+0x2a4>)
   234de:	4293      	cmp	r3, r2
   234e0:	d108      	bne.n	234f4 <IPC_IRQHandler+0x22c>
   234e2:	2003      	movs	r0, #3
   234e4:	4914      	ldr	r1, [pc, #80]	; (23538 <IPC_IRQHandler+0x270>)
   234e6:	4a16      	ldr	r2, [pc, #88]	; (23540 <IPC_IRQHandler+0x278>)
   234e8:	6008      	str	r0, [r1, #0]
   234ea:	6013      	str	r3, [r2, #0]
   234ec:	e728      	b.n	23340 <IPC_IRQHandler+0x78>
   234ee:	f7fc feaf 	bl	20250 <bsd_os_application_irq_set>
   234f2:	e720      	b.n	23336 <IPC_IRQHandler+0x6e>
   234f4:	2303      	movs	r3, #3
   234f6:	4910      	ldr	r1, [pc, #64]	; (23538 <IPC_IRQHandler+0x270>)
   234f8:	4a11      	ldr	r2, [pc, #68]	; (23540 <IPC_IRQHandler+0x278>)
   234fa:	600b      	str	r3, [r1, #0]
   234fc:	6013      	str	r3, [r2, #0]
   234fe:	e71f      	b.n	23340 <IPC_IRQHandler+0x78>
   23500:	2003      	movs	r0, #3
   23502:	2206      	movs	r2, #6
   23504:	490c      	ldr	r1, [pc, #48]	; (23538 <IPC_IRQHandler+0x270>)
   23506:	4b0e      	ldr	r3, [pc, #56]	; (23540 <IPC_IRQHandler+0x278>)
   23508:	6008      	str	r0, [r1, #0]
   2350a:	601a      	str	r2, [r3, #0]
   2350c:	e718      	b.n	23340 <IPC_IRQHandler+0x78>
   2350e:	2003      	movs	r0, #3
   23510:	2110      	movs	r1, #16
   23512:	4a0b      	ldr	r2, [pc, #44]	; (23540 <IPC_IRQHandler+0x278>)
   23514:	6018      	str	r0, [r3, #0]
   23516:	6011      	str	r1, [r2, #0]
   23518:	e70d      	b.n	23336 <IPC_IRQHandler+0x6e>
   2351a:	2003      	movs	r0, #3
   2351c:	f24c 0106 	movw	r1, #49158	; 0xc006
   23520:	4a07      	ldr	r2, [pc, #28]	; (23540 <IPC_IRQHandler+0x278>)
   23522:	6018      	str	r0, [r3, #0]
   23524:	6011      	str	r1, [r2, #0]
   23526:	e706      	b.n	23336 <IPC_IRQHandler+0x6e>
   23528:	e000e100 	.word	0xe000e100
   2352c:	4002a000 	.word	0x4002a000
   23530:	4002a11c 	.word	0x4002a11c
   23534:	4002a108 	.word	0x4002a108
   23538:	200224f0 	.word	0x200224f0
   2353c:	4002a100 	.word	0x4002a100
   23540:	200224e0 	.word	0x200224e0
   23544:	4002a110 	.word	0x4002a110
   23548:	4002a118 	.word	0x4002a118
   2354c:	4002a5a0 	.word	0x4002a5a0
   23550:	4002a308 	.word	0x4002a308
   23554:	4002a590 	.word	0x4002a590
   23558:	4002a598 	.word	0x4002a598
   2355c:	20027618 	.word	0x20027618
   23560:	04400004 	.word	0x04400004
   23564:	200224f4 	.word	0x200224f4
   23568:	200224e8 	.word	0x200224e8
   2356c:	05500001 	.word	0x05500001
   23570:	4002a5a8 	.word	0x4002a5a8
   23574:	4002a5ac 	.word	0x4002a5ac

00023578 <rpc_transport_ipc_rx_init>:
   23578:	2800      	cmp	r0, #0
   2357a:	f000 8108 	beq.w	2378e <rpc_transport_ipc_rx_init+0x216>
   2357e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23582:	6805      	ldr	r5, [r0, #0]
   23584:	b097      	sub	sp, #92	; 0x5c
   23586:	2d00      	cmp	r5, #0
   23588:	f000 80f7 	beq.w	2377a <rpc_transport_ipc_rx_init+0x202>
   2358c:	6883      	ldr	r3, [r0, #8]
   2358e:	2b00      	cmp	r3, #0
   23590:	f000 80f3 	beq.w	2377a <rpc_transport_ipc_rx_init+0x202>
   23594:	6906      	ldr	r6, [r0, #16]
   23596:	2e00      	cmp	r6, #0
   23598:	f000 80ef 	beq.w	2377a <rpc_transport_ipc_rx_init+0x202>
   2359c:	6a84      	ldr	r4, [r0, #40]	; 0x28
   2359e:	2c00      	cmp	r4, #0
   235a0:	f000 80eb 	beq.w	2377a <rpc_transport_ipc_rx_init+0x202>
   235a4:	6844      	ldr	r4, [r0, #4]
   235a6:	2c1b      	cmp	r4, #27
   235a8:	f240 80ec 	bls.w	23784 <rpc_transport_ipc_rx_init+0x20c>
   235ac:	68c4      	ldr	r4, [r0, #12]
   235ae:	2c0b      	cmp	r4, #11
   235b0:	f240 80e8 	bls.w	23784 <rpc_transport_ipc_rx_init+0x20c>
   235b4:	f8d0 c014 	ldr.w	ip, [r0, #20]
   235b8:	f1bc 0f17 	cmp.w	ip, #23
   235bc:	f240 80e2 	bls.w	23784 <rpc_transport_ipc_rx_init+0x20c>
   235c0:	2700      	movs	r7, #0
   235c2:	4604      	mov	r4, r0
   235c4:	f8df a1e4 	ldr.w	sl, [pc, #484]	; 237ac <rpc_transport_ipc_rx_init+0x234>
   235c8:	6b80      	ldr	r0, [r0, #56]	; 0x38
   235ca:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 237b0 <rpc_transport_ipc_rx_init+0x238>
   235ce:	f8df b1e4 	ldr.w	fp, [pc, #484]	; 237b4 <rpc_transport_ipc_rx_init+0x23c>
   235d2:	f8df 91e4 	ldr.w	r9, [pc, #484]	; 237b8 <rpc_transport_ipc_rx_init+0x240>
   235d6:	e9cd 1200 	strd	r1, r2, [sp]
   235da:	f8ca 0000 	str.w	r0, [sl]
   235de:	4662      	mov	r2, ip
   235e0:	4639      	mov	r1, r7
   235e2:	4630      	mov	r0, r6
   235e4:	f8cb 3000 	str.w	r3, [fp]
   235e8:	f8c8 7000 	str.w	r7, [r8]
   235ec:	f8c9 7000 	str.w	r7, [r9]
   235f0:	f015 fd2c 	bl	3904c <memset>
   235f4:	69e3      	ldr	r3, [r4, #28]
   235f6:	4630      	mov	r0, r6
   235f8:	6033      	str	r3, [r6, #0]
   235fa:	69a3      	ldr	r3, [r4, #24]
   235fc:	6073      	str	r3, [r6, #4]
   235fe:	f7ff fb33 	bl	22c68 <ipc_trace_init>
   23602:	2201      	movs	r2, #1
   23604:	f04f 0c04 	mov.w	ip, #4
   23608:	4b62      	ldr	r3, [pc, #392]	; (23794 <rpc_transport_ipc_rx_init+0x21c>)
   2360a:	4963      	ldr	r1, [pc, #396]	; (23798 <rpc_transport_ipc_rx_init+0x220>)
   2360c:	f8c3 5610 	str.w	r5, [r3, #1552]	; 0x610
   23610:	6809      	ldr	r1, [r1, #0]
   23612:	2080      	movs	r0, #128	; 0x80
   23614:	9106      	str	r1, [sp, #24]
   23616:	4961      	ldr	r1, [pc, #388]	; (2379c <rpc_transport_ipc_rx_init+0x224>)
   23618:	f8dd e018 	ldr.w	lr, [sp, #24]
   2361c:	f8c3 7614 	str.w	r7, [r3, #1556]	; 0x614
   23620:	6809      	ldr	r1, [r1, #0]
   23622:	702f      	strb	r7, [r5, #0]
   23624:	9105      	str	r1, [sp, #20]
   23626:	706f      	strb	r7, [r5, #1]
   23628:	70ef      	strb	r7, [r5, #3]
   2362a:	70aa      	strb	r2, [r5, #2]
   2362c:	9905      	ldr	r1, [sp, #20]
   2362e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
   23630:	f8db e000 	ldr.w	lr, [fp]
   23634:	6069      	str	r1, [r5, #4]
   23636:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   23638:	9c01      	ldr	r4, [sp, #4]
   2363a:	60a9      	str	r1, [r5, #8]
   2363c:	60ec      	str	r4, [r5, #12]
   2363e:	9c00      	ldr	r4, [sp, #0]
   23640:	4957      	ldr	r1, [pc, #348]	; (237a0 <rpc_transport_ipc_rx_init+0x228>)
   23642:	61ae      	str	r6, [r5, #24]
   23644:	f8c5 e014 	str.w	lr, [r5, #20]
   23648:	612c      	str	r4, [r5, #16]
   2364a:	f8c3 2590 	str.w	r2, [r3, #1424]	; 0x590
   2364e:	680c      	ldr	r4, [r1, #0]
   23650:	f5a1 6192 	sub.w	r1, r1, #1168	; 0x490
   23654:	9407      	str	r4, [sp, #28]
   23656:	9c07      	ldr	r4, [sp, #28]
   23658:	f8c3 c598 	str.w	ip, [r3, #1432]	; 0x598
   2365c:	f8d1 4498 	ldr.w	r4, [r1, #1176]	; 0x498
   23660:	f44f 6680 	mov.w	r6, #1024	; 0x400
   23664:	9408      	str	r4, [sp, #32]
   23666:	9c08      	ldr	r4, [sp, #32]
   23668:	2410      	movs	r4, #16
   2366a:	f8c3 45a0 	str.w	r4, [r3, #1440]	; 0x5a0
   2366e:	f8d1 44a0 	ldr.w	r4, [r1, #1184]	; 0x4a0
   23672:	4d4c      	ldr	r5, [pc, #304]	; (237a4 <rpc_transport_ipc_rx_init+0x22c>)
   23674:	9409      	str	r4, [sp, #36]	; 0x24
   23676:	9c09      	ldr	r4, [sp, #36]	; 0x24
   23678:	2440      	movs	r4, #64	; 0x40
   2367a:	f8c3 45a8 	str.w	r4, [r3, #1448]	; 0x5a8
   2367e:	f8d1 44a8 	ldr.w	r4, [r1, #1192]	; 0x4a8
   23682:	940a      	str	r4, [sp, #40]	; 0x28
   23684:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   23686:	f8c3 05ac 	str.w	r0, [r3, #1452]	; 0x5ac
   2368a:	f8d1 04ac 	ldr.w	r0, [r1, #1196]	; 0x4ac
   2368e:	900b      	str	r0, [sp, #44]	; 0x2c
   23690:	980b      	ldr	r0, [sp, #44]	; 0x2c
   23692:	f8c3 7100 	str.w	r7, [r3, #256]	; 0x100
   23696:	6808      	ldr	r0, [r1, #0]
   23698:	900c      	str	r0, [sp, #48]	; 0x30
   2369a:	980c      	ldr	r0, [sp, #48]	; 0x30
   2369c:	f8c3 7108 	str.w	r7, [r3, #264]	; 0x108
   236a0:	6888      	ldr	r0, [r1, #8]
   236a2:	900d      	str	r0, [sp, #52]	; 0x34
   236a4:	980d      	ldr	r0, [sp, #52]	; 0x34
   236a6:	f8c3 7110 	str.w	r7, [r3, #272]	; 0x110
   236aa:	6908      	ldr	r0, [r1, #16]
   236ac:	900e      	str	r0, [sp, #56]	; 0x38
   236ae:	980e      	ldr	r0, [sp, #56]	; 0x38
   236b0:	f8c3 7118 	str.w	r7, [r3, #280]	; 0x118
   236b4:	6988      	ldr	r0, [r1, #24]
   236b6:	900f      	str	r0, [sp, #60]	; 0x3c
   236b8:	980f      	ldr	r0, [sp, #60]	; 0x3c
   236ba:	f8c3 711c 	str.w	r7, [r3, #284]	; 0x11c
   236be:	69c8      	ldr	r0, [r1, #28]
   236c0:	f501 7101 	add.w	r1, r1, #516	; 0x204
   236c4:	9010      	str	r0, [sp, #64]	; 0x40
   236c6:	9810      	ldr	r0, [sp, #64]	; 0x40
   236c8:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
   236cc:	4310      	orrs	r0, r2
   236ce:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
   236d2:	680c      	ldr	r4, [r1, #0]
   236d4:	4834      	ldr	r0, [pc, #208]	; (237a8 <rpc_transport_ipc_rx_init+0x230>)
   236d6:	9411      	str	r4, [sp, #68]	; 0x44
   236d8:	9c11      	ldr	r4, [sp, #68]	; 0x44
   236da:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   236de:	ea44 040c 	orr.w	r4, r4, ip
   236e2:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   236e6:	680c      	ldr	r4, [r1, #0]
   236e8:	9412      	str	r4, [sp, #72]	; 0x48
   236ea:	9c12      	ldr	r4, [sp, #72]	; 0x48
   236ec:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   236f0:	f044 0410 	orr.w	r4, r4, #16
   236f4:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   236f8:	680c      	ldr	r4, [r1, #0]
   236fa:	9413      	str	r4, [sp, #76]	; 0x4c
   236fc:	9c13      	ldr	r4, [sp, #76]	; 0x4c
   236fe:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   23702:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   23706:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2370a:	680c      	ldr	r4, [r1, #0]
   2370c:	9414      	str	r4, [sp, #80]	; 0x50
   2370e:	9c14      	ldr	r4, [sp, #80]	; 0x50
   23710:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
   23714:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   23718:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   2371c:	f8da 3000 	ldr.w	r3, [sl]
   23720:	6809      	ldr	r1, [r1, #0]
   23722:	015b      	lsls	r3, r3, #5
   23724:	9115      	str	r1, [sp, #84]	; 0x54
   23726:	b2db      	uxtb	r3, r3
   23728:	9915      	ldr	r1, [sp, #84]	; 0x54
   2372a:	f8c8 2000 	str.w	r2, [r8]
   2372e:	f880 332a 	strb.w	r3, [r0, #810]	; 0x32a
   23732:	f8c0 6184 	str.w	r6, [r0, #388]	; 0x184
   23736:	6046      	str	r6, [r0, #4]
   23738:	9704      	str	r7, [sp, #16]
   2373a:	f8c5 7610 	str.w	r7, [r5, #1552]	; 0x610
   2373e:	f8d5 3610 	ldr.w	r3, [r5, #1552]	; 0x610
   23742:	9304      	str	r3, [sp, #16]
   23744:	9b04      	ldr	r3, [sp, #16]
   23746:	f8d8 3000 	ldr.w	r3, [r8]
   2374a:	4293      	cmp	r3, r2
   2374c:	d110      	bne.n	23770 <rpc_transport_ipc_rx_init+0x1f8>
   2374e:	f247 5430 	movw	r4, #30000	; 0x7530
   23752:	2564      	movs	r5, #100	; 0x64
   23754:	e000      	b.n	23758 <rpc_transport_ipc_rx_init+0x1e0>
   23756:	b15c      	cbz	r4, 23770 <rpc_transport_ipc_rx_init+0x1f8>
   23758:	a903      	add	r1, sp, #12
   2375a:	2000      	movs	r0, #0
   2375c:	9503      	str	r5, [sp, #12]
   2375e:	f7fc fbd5 	bl	1ff0c <bsd_os_timedwait>
   23762:	9b03      	ldr	r3, [sp, #12]
   23764:	f8d8 2000 	ldr.w	r2, [r8]
   23768:	3b64      	subs	r3, #100	; 0x64
   2376a:	2a01      	cmp	r2, #1
   2376c:	441c      	add	r4, r3
   2376e:	d0f2      	beq.n	23756 <rpc_transport_ipc_rx_init+0x1de>
   23770:	f8d9 0000 	ldr.w	r0, [r9]
   23774:	b017      	add	sp, #92	; 0x5c
   23776:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2377a:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2377e:	b017      	add	sp, #92	; 0x5c
   23780:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23784:	f24c 0009 	movw	r0, #49161	; 0xc009
   23788:	b017      	add	sp, #92	; 0x5c
   2378a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2378e:	f24c 000e 	movw	r0, #49166	; 0xc00e
   23792:	4770      	bx	lr
   23794:	4002a000 	.word	0x4002a000
   23798:	4002a610 	.word	0x4002a610
   2379c:	4002a614 	.word	0x4002a614
   237a0:	4002a590 	.word	0x4002a590
   237a4:	40005000 	.word	0x40005000
   237a8:	e000e100 	.word	0xe000e100
   237ac:	200224e4 	.word	0x200224e4
   237b0:	200224f0 	.word	0x200224f0
   237b4:	200224f4 	.word	0x200224f4
   237b8:	200224e0 	.word	0x200224e0

000237bc <rpc_transport_ipc_msg_free>:
   237bc:	b470      	push	{r4, r5, r6}
   237be:	4e17      	ldr	r6, [pc, #92]	; (2381c <rpc_transport_ipc_msg_free+0x60>)
   237c0:	6831      	ldr	r1, [r6, #0]
   237c2:	680d      	ldr	r5, [r1, #0]
   237c4:	b1ad      	cbz	r5, 237f2 <rpc_transport_ipc_msg_free+0x36>
   237c6:	688b      	ldr	r3, [r1, #8]
   237c8:	4283      	cmp	r3, r0
   237ca:	d024      	beq.n	23816 <rpc_transport_ipc_msg_free+0x5a>
   237cc:	2300      	movs	r3, #0
   237ce:	3301      	adds	r3, #1
   237d0:	00da      	lsls	r2, r3, #3
   237d2:	429d      	cmp	r5, r3
   237d4:	eb01 0402 	add.w	r4, r1, r2
   237d8:	d00b      	beq.n	237f2 <rpc_transport_ipc_msg_free+0x36>
   237da:	68a4      	ldr	r4, [r4, #8]
   237dc:	42a0      	cmp	r0, r4
   237de:	d1f6      	bne.n	237ce <rpc_transport_ipc_msg_free+0x12>
   237e0:	3204      	adds	r2, #4
   237e2:	588b      	ldr	r3, [r1, r2]
   237e4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   237e8:	f043 0303 	orr.w	r3, r3, #3
   237ec:	508b      	str	r3, [r1, r2]
   237ee:	bc70      	pop	{r4, r5, r6}
   237f0:	4770      	bx	lr
   237f2:	6871      	ldr	r1, [r6, #4]
   237f4:	680d      	ldr	r5, [r1, #0]
   237f6:	2d00      	cmp	r5, #0
   237f8:	d0f9      	beq.n	237ee <rpc_transport_ipc_msg_free+0x32>
   237fa:	688b      	ldr	r3, [r1, #8]
   237fc:	4283      	cmp	r3, r0
   237fe:	d00a      	beq.n	23816 <rpc_transport_ipc_msg_free+0x5a>
   23800:	2300      	movs	r3, #0
   23802:	3301      	adds	r3, #1
   23804:	00da      	lsls	r2, r3, #3
   23806:	429d      	cmp	r5, r3
   23808:	eb01 0402 	add.w	r4, r1, r2
   2380c:	d0ef      	beq.n	237ee <rpc_transport_ipc_msg_free+0x32>
   2380e:	68a4      	ldr	r4, [r4, #8]
   23810:	42a0      	cmp	r0, r4
   23812:	d1f6      	bne.n	23802 <rpc_transport_ipc_msg_free+0x46>
   23814:	e7e4      	b.n	237e0 <rpc_transport_ipc_msg_free+0x24>
   23816:	2204      	movs	r2, #4
   23818:	e7e3      	b.n	237e2 <rpc_transport_ipc_msg_free+0x26>
   2381a:	bf00      	nop
   2381c:	200224e8 	.word	0x200224e8

00023820 <rpc_transport_ipc_tx_init>:
   23820:	2800      	cmp	r0, #0
   23822:	f000 80b8 	beq.w	23996 <rpc_transport_ipc_tx_init+0x176>
   23826:	2900      	cmp	r1, #0
   23828:	f000 80b5 	beq.w	23996 <rpc_transport_ipc_tx_init+0x176>
   2382c:	2a00      	cmp	r2, #0
   2382e:	f000 80b2 	beq.w	23996 <rpc_transport_ipc_tx_init+0x176>
   23832:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   23836:	6a04      	ldr	r4, [r0, #32]
   23838:	b085      	sub	sp, #20
   2383a:	2c00      	cmp	r4, #0
   2383c:	f000 80a6 	beq.w	2398c <rpc_transport_ipc_tx_init+0x16c>
   23840:	6a40      	ldr	r0, [r0, #36]	; 0x24
   23842:	2800      	cmp	r0, #0
   23844:	f000 80a2 	beq.w	2398c <rpc_transport_ipc_tx_init+0x16c>
   23848:	f642 4587 	movw	r5, #11399	; 0x2c87
   2384c:	f04f 0a00 	mov.w	sl, #0
   23850:	4e55      	ldr	r6, [pc, #340]	; (239a8 <rpc_transport_ipc_tx_init+0x188>)
   23852:	42a8      	cmp	r0, r5
   23854:	f886 a000 	strb.w	sl, [r6]
   23858:	f240 80a0 	bls.w	2399c <rpc_transport_ipc_tx_init+0x17c>
   2385c:	2708      	movs	r7, #8
   2385e:	f8df 9180 	ldr.w	r9, [pc, #384]	; 239e0 <rpc_transport_ipc_tx_init+0x1c0>
   23862:	4620      	mov	r0, r4
   23864:	4616      	mov	r6, r2
   23866:	460d      	mov	r5, r1
   23868:	2244      	movs	r2, #68	; 0x44
   2386a:	4651      	mov	r1, sl
   2386c:	f8c9 4000 	str.w	r4, [r9]
   23870:	f015 fbec 	bl	3904c <memset>
   23874:	f8d9 2000 	ldr.w	r2, [r9]
   23878:	f104 0344 	add.w	r3, r4, #68	; 0x44
   2387c:	f8df 8164 	ldr.w	r8, [pc, #356]	; 239e4 <rpc_transport_ipc_tx_init+0x1c4>
   23880:	f882 a001 	strb.w	sl, [r2, #1]
   23884:	f882 a002 	strb.w	sl, [r2, #2]
   23888:	f882 a003 	strb.w	sl, [r2, #3]
   2388c:	7017      	strb	r7, [r2, #0]
   2388e:	4618      	mov	r0, r3
   23890:	2244      	movs	r2, #68	; 0x44
   23892:	4651      	mov	r1, sl
   23894:	f8c8 3000 	str.w	r3, [r8]
   23898:	f015 fbd8 	bl	3904c <memset>
   2389c:	f8d8 2000 	ldr.w	r2, [r8]
   238a0:	f104 0388 	add.w	r3, r4, #136	; 0x88
   238a4:	f8df b140 	ldr.w	fp, [pc, #320]	; 239e8 <rpc_transport_ipc_tx_init+0x1c8>
   238a8:	7017      	strb	r7, [r2, #0]
   238aa:	f882 a001 	strb.w	sl, [r2, #1]
   238ae:	f882 a002 	strb.w	sl, [r2, #2]
   238b2:	f882 a003 	strb.w	sl, [r2, #3]
   238b6:	4618      	mov	r0, r3
   238b8:	f44f 7200 	mov.w	r2, #512	; 0x200
   238bc:	4651      	mov	r1, sl
   238be:	f8cb 3000 	str.w	r3, [fp]
   238c2:	f015 fbc3 	bl	3904c <memset>
   238c6:	4b39      	ldr	r3, [pc, #228]	; (239ac <rpc_transport_ipc_tx_init+0x18c>)
   238c8:	f504 7c22 	add.w	ip, r4, #648	; 0x288
   238cc:	f8c3 c000 	str.w	ip, [r3]
   238d0:	4651      	mov	r1, sl
   238d2:	4660      	mov	r0, ip
   238d4:	f44f 7200 	mov.w	r2, #512	; 0x200
   238d8:	f015 fbb8 	bl	3904c <memset>
   238dc:	f44f 5c20 	mov.w	ip, #10240	; 0x2800
   238e0:	2106      	movs	r1, #6
   238e2:	f04f 0e01 	mov.w	lr, #1
   238e6:	f44f 3001 	mov.w	r0, #132096	; 0x20400
   238ea:	f44f 3288 	mov.w	r2, #69632	; 0x11000
   238ee:	4b30      	ldr	r3, [pc, #192]	; (239b0 <rpc_transport_ipc_tx_init+0x190>)
   238f0:	f504 6491 	add.w	r4, r4, #1160	; 0x488
   238f4:	605c      	str	r4, [r3, #4]
   238f6:	4c2f      	ldr	r4, [pc, #188]	; (239b4 <rpc_transport_ipc_tx_init+0x194>)
   238f8:	f8c3 c008 	str.w	ip, [r3, #8]
   238fc:	8199      	strh	r1, [r3, #12]
   238fe:	f8a3 e000 	strh.w	lr, [r3]
   23902:	4619      	mov	r1, r3
   23904:	611c      	str	r4, [r3, #16]
   23906:	4b2c      	ldr	r3, [pc, #176]	; (239b8 <rpc_transport_ipc_tx_init+0x198>)
   23908:	f8df c0e0 	ldr.w	ip, [pc, #224]	; 239ec <rpc_transport_ipc_tx_init+0x1cc>
   2390c:	6120      	str	r0, [r4, #16]
   2390e:	482b      	ldr	r0, [pc, #172]	; (239bc <rpc_transport_ipc_tx_init+0x19c>)
   23910:	6063      	str	r3, [r4, #4]
   23912:	f503 73c0 	add.w	r3, r3, #384	; 0x180
   23916:	60a0      	str	r0, [r4, #8]
   23918:	f8c4 c000 	str.w	ip, [r4]
   2391c:	4828      	ldr	r0, [pc, #160]	; (239c0 <rpc_transport_ipc_tx_init+0x1a0>)
   2391e:	60e3      	str	r3, [r4, #12]
   23920:	6162      	str	r2, [r4, #20]
   23922:	f006 f9ef 	bl	29d04 <nrf_mem_register>
   23926:	2800      	cmp	r0, #0
   23928:	d132      	bne.n	23990 <rpc_transport_ipc_tx_init+0x170>
   2392a:	f04f 0c02 	mov.w	ip, #2
   2392e:	2420      	movs	r4, #32
   23930:	f8d9 1000 	ldr.w	r1, [r9]
   23934:	f8db 2000 	ldr.w	r2, [fp]
   23938:	6029      	str	r1, [r5, #0]
   2393a:	4b1c      	ldr	r3, [pc, #112]	; (239ac <rpc_transport_ipc_tx_init+0x18c>)
   2393c:	f8d8 1000 	ldr.w	r1, [r8]
   23940:	f8df e0ac 	ldr.w	lr, [pc, #172]	; 239f0 <rpc_transport_ipc_tx_init+0x1d0>
   23944:	4d1f      	ldr	r5, [pc, #124]	; (239c4 <rpc_transport_ipc_tx_init+0x1a4>)
   23946:	6031      	str	r1, [r6, #0]
   23948:	f8ce 2000 	str.w	r2, [lr]
   2394c:	681b      	ldr	r3, [r3, #0]
   2394e:	491e      	ldr	r1, [pc, #120]	; (239c8 <rpc_transport_ipc_tx_init+0x1a8>)
   23950:	f502 7200 	add.w	r2, r2, #512	; 0x200
   23954:	602a      	str	r2, [r5, #0]
   23956:	4e1d      	ldr	r6, [pc, #116]	; (239cc <rpc_transport_ipc_tx_init+0x1ac>)
   23958:	4a1d      	ldr	r2, [pc, #116]	; (239d0 <rpc_transport_ipc_tx_init+0x1b0>)
   2395a:	4d1e      	ldr	r5, [pc, #120]	; (239d4 <rpc_transport_ipc_tx_init+0x1b4>)
   2395c:	600b      	str	r3, [r1, #0]
   2395e:	f503 7300 	add.w	r3, r3, #512	; 0x200
   23962:	491d      	ldr	r1, [pc, #116]	; (239d8 <rpc_transport_ipc_tx_init+0x1b8>)
   23964:	6033      	str	r3, [r6, #0]
   23966:	8028      	strh	r0, [r5, #0]
   23968:	f8c2 c514 	str.w	ip, [r2, #1300]	; 0x514
   2396c:	6809      	ldr	r1, [r1, #0]
   2396e:	4b1b      	ldr	r3, [pc, #108]	; (239dc <rpc_transport_ipc_tx_init+0x1bc>)
   23970:	9103      	str	r1, [sp, #12]
   23972:	9903      	ldr	r1, [sp, #12]
   23974:	f8c2 751c 	str.w	r7, [r2, #1308]	; 0x51c
   23978:	6819      	ldr	r1, [r3, #0]
   2397a:	443b      	add	r3, r7
   2397c:	9102      	str	r1, [sp, #8]
   2397e:	9902      	ldr	r1, [sp, #8]
   23980:	f8c2 4524 	str.w	r4, [r2, #1316]	; 0x524
   23984:	681b      	ldr	r3, [r3, #0]
   23986:	9301      	str	r3, [sp, #4]
   23988:	9b01      	ldr	r3, [sp, #4]
   2398a:	e001      	b.n	23990 <rpc_transport_ipc_tx_init+0x170>
   2398c:	f24c 0007 	movw	r0, #49159	; 0xc007
   23990:	b005      	add	sp, #20
   23992:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   23996:	f24c 000e 	movw	r0, #49166	; 0xc00e
   2399a:	4770      	bx	lr
   2399c:	f24c 0004 	movw	r0, #49156	; 0xc004
   239a0:	b005      	add	sp, #20
   239a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   239a6:	bf00      	nop
   239a8:	20029084 	.word	0x20029084
   239ac:	20022520 	.word	0x20022520
   239b0:	2002250c 	.word	0x2002250c
   239b4:	20022530 	.word	0x20022530
   239b8:	00040080 	.word	0x00040080
   239bc:	00040100 	.word	0x00040100
   239c0:	200224f8 	.word	0x200224f8
   239c4:	20022504 	.word	0x20022504
   239c8:	20022500 	.word	0x20022500
   239cc:	200224fc 	.word	0x200224fc
   239d0:	4002a000 	.word	0x4002a000
   239d4:	2002761a 	.word	0x2002761a
   239d8:	4002a514 	.word	0x4002a514
   239dc:	4002a51c 	.word	0x4002a51c
   239e0:	2002252c 	.word	0x2002252c
   239e4:	20022524 	.word	0x20022524
   239e8:	20022528 	.word	0x20022528
   239ec:	00080040 	.word	0x00080040
   239f0:	20022508 	.word	0x20022508

000239f4 <rpc_transport_ipc_send>:
   239f4:	2800      	cmp	r0, #0
   239f6:	d061      	beq.n	23abc <rpc_transport_ipc_send+0xc8>
   239f8:	b4f0      	push	{r4, r5, r6, r7}
   239fa:	4b34      	ldr	r3, [pc, #208]	; (23acc <rpc_transport_ipc_send+0xd8>)
   239fc:	b082      	sub	sp, #8
   239fe:	681a      	ldr	r2, [r3, #0]
   23a00:	4b33      	ldr	r3, [pc, #204]	; (23ad0 <rpc_transport_ipc_send+0xdc>)
   23a02:	4282      	cmp	r2, r0
   23a04:	d81e      	bhi.n	23a44 <rpc_transport_ipc_send+0x50>
   23a06:	681b      	ldr	r3, [r3, #0]
   23a08:	4932      	ldr	r1, [pc, #200]	; (23ad4 <rpc_transport_ipc_send+0xe0>)
   23a0a:	4283      	cmp	r3, r0
   23a0c:	6809      	ldr	r1, [r1, #0]
   23a0e:	d803      	bhi.n	23a18 <rpc_transport_ipc_send+0x24>
   23a10:	4c31      	ldr	r4, [pc, #196]	; (23ad8 <rpc_transport_ipc_send+0xe4>)
   23a12:	6824      	ldr	r4, [r4, #0]
   23a14:	4284      	cmp	r4, r0
   23a16:	d849      	bhi.n	23aac <rpc_transport_ipc_send+0xb8>
   23a18:	4281      	cmp	r1, r0
   23a1a:	d90e      	bls.n	23a3a <rpc_transport_ipc_send+0x46>
   23a1c:	4b2f      	ldr	r3, [pc, #188]	; (23adc <rpc_transport_ipc_send+0xe8>)
   23a1e:	781b      	ldrb	r3, [r3, #0]
   23a20:	2b00      	cmp	r3, #0
   23a22:	d14e      	bne.n	23ac2 <rpc_transport_ipc_send+0xce>
   23a24:	1a83      	subs	r3, r0, r2
   23a26:	492e      	ldr	r1, [pc, #184]	; (23ae0 <rpc_transport_ipc_send+0xec>)
   23a28:	099f      	lsrs	r7, r3, #6
   23a2a:	069b      	lsls	r3, r3, #26
   23a2c:	680a      	ldr	r2, [r1, #0]
   23a2e:	4d2d      	ldr	r5, [pc, #180]	; (23ae4 <rpc_transport_ipc_send+0xf0>)
   23a30:	f04f 0403 	mov.w	r4, #3
   23a34:	f04f 0602 	mov.w	r6, #2
   23a38:	d014      	beq.n	23a64 <rpc_transport_ipc_send+0x70>
   23a3a:	f24c 0010 	movw	r0, #49168	; 0xc010
   23a3e:	b002      	add	sp, #8
   23a40:	bcf0      	pop	{r4, r5, r6, r7}
   23a42:	4770      	bx	lr
   23a44:	681b      	ldr	r3, [r3, #0]
   23a46:	4298      	cmp	r0, r3
   23a48:	d3f7      	bcc.n	23a3a <rpc_transport_ipc_send+0x46>
   23a4a:	4a23      	ldr	r2, [pc, #140]	; (23ad8 <rpc_transport_ipc_send+0xe4>)
   23a4c:	6812      	ldr	r2, [r2, #0]
   23a4e:	4290      	cmp	r0, r2
   23a50:	d2f3      	bcs.n	23a3a <rpc_transport_ipc_send+0x46>
   23a52:	2401      	movs	r4, #1
   23a54:	1ac3      	subs	r3, r0, r3
   23a56:	4a24      	ldr	r2, [pc, #144]	; (23ae8 <rpc_transport_ipc_send+0xf4>)
   23a58:	099f      	lsrs	r7, r3, #6
   23a5a:	069b      	lsls	r3, r3, #26
   23a5c:	4626      	mov	r6, r4
   23a5e:	6812      	ldr	r2, [r2, #0]
   23a60:	4d22      	ldr	r5, [pc, #136]	; (23aec <rpc_transport_ipc_send+0xf8>)
   23a62:	d1ea      	bne.n	23a3a <rpc_transport_ipc_send+0x46>
   23a64:	6841      	ldr	r1, [r0, #4]
   23a66:	b2c9      	uxtb	r1, r1
   23a68:	428e      	cmp	r6, r1
   23a6a:	d122      	bne.n	23ab2 <rpc_transport_ipc_send+0xbe>
   23a6c:	2020      	movs	r0, #32
   23a6e:	eb02 03c7 	add.w	r3, r2, r7, lsl #3
   23a72:	491f      	ldr	r1, [pc, #124]	; (23af0 <rpc_transport_ipc_send+0xfc>)
   23a74:	685a      	ldr	r2, [r3, #4]
   23a76:	880e      	ldrh	r6, [r1, #0]
   23a78:	b292      	uxth	r2, r2
   23a7a:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
   23a7e:	605a      	str	r2, [r3, #4]
   23a80:	685a      	ldr	r2, [r3, #4]
   23a82:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   23a86:	f042 0201 	orr.w	r2, r2, #1
   23a8a:	605a      	str	r2, [r3, #4]
   23a8c:	bf00      	nop
   23a8e:	3801      	subs	r0, #1
   23a90:	d1fc      	bne.n	23a8c <rpc_transport_ipc_send+0x98>
   23a92:	2201      	movs	r2, #1
   23a94:	4b17      	ldr	r3, [pc, #92]	; (23af4 <rpc_transport_ipc_send+0x100>)
   23a96:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
   23a9a:	682a      	ldr	r2, [r5, #0]
   23a9c:	880b      	ldrh	r3, [r1, #0]
   23a9e:	9201      	str	r2, [sp, #4]
   23aa0:	9a01      	ldr	r2, [sp, #4]
   23aa2:	3301      	adds	r3, #1
   23aa4:	800b      	strh	r3, [r1, #0]
   23aa6:	b002      	add	sp, #8
   23aa8:	bcf0      	pop	{r4, r5, r6, r7}
   23aaa:	4770      	bx	lr
   23aac:	4281      	cmp	r1, r0
   23aae:	d9d0      	bls.n	23a52 <rpc_transport_ipc_send+0x5e>
   23ab0:	e7b4      	b.n	23a1c <rpc_transport_ipc_send+0x28>
   23ab2:	f24c 0007 	movw	r0, #49159	; 0xc007
   23ab6:	b002      	add	sp, #8
   23ab8:	bcf0      	pop	{r4, r5, r6, r7}
   23aba:	4770      	bx	lr
   23abc:	f24c 000e 	movw	r0, #49166	; 0xc00e
   23ac0:	4770      	bx	lr
   23ac2:	f24c 000f 	movw	r0, #49167	; 0xc00f
   23ac6:	b002      	add	sp, #8
   23ac8:	bcf0      	pop	{r4, r5, r6, r7}
   23aca:	4770      	bx	lr
   23acc:	20022508 	.word	0x20022508
   23ad0:	20022500 	.word	0x20022500
   23ad4:	20022504 	.word	0x20022504
   23ad8:	200224fc 	.word	0x200224fc
   23adc:	20029084 	.word	0x20029084
   23ae0:	2002252c 	.word	0x2002252c
   23ae4:	4002a00c 	.word	0x4002a00c
   23ae8:	20022524 	.word	0x20022524
   23aec:	4002a004 	.word	0x4002a004
   23af0:	2002761a 	.word	0x2002761a
   23af4:	4002a000 	.word	0x4002a000

00023af8 <rpc_transport_ipc_tx_rpc_data_alloc>:
   23af8:	4b18      	ldr	r3, [pc, #96]	; (23b5c <rpc_transport_ipc_tx_rpc_data_alloc+0x64>)
   23afa:	781b      	ldrb	r3, [r3, #0]
   23afc:	bb63      	cbnz	r3, 23b58 <rpc_transport_ipc_tx_rpc_data_alloc+0x60>
   23afe:	b4f0      	push	{r4, r5, r6, r7}
   23b00:	4a17      	ldr	r2, [pc, #92]	; (23b60 <rpc_transport_ipc_tx_rpc_data_alloc+0x68>)
   23b02:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   23b06:	6814      	ldr	r4, [r2, #0]
   23b08:	4b16      	ldr	r3, [pc, #88]	; (23b64 <rpc_transport_ipc_tx_rpc_data_alloc+0x6c>)
   23b0a:	6825      	ldr	r5, [r4, #0]
   23b0c:	681e      	ldr	r6, [r3, #0]
   23b0e:	b1a5      	cbz	r5, 23b3a <rpc_transport_ipc_tx_rpc_data_alloc+0x42>
   23b10:	4607      	mov	r7, r0
   23b12:	00c1      	lsls	r1, r0, #3
   23b14:	1863      	adds	r3, r4, r1
   23b16:	685a      	ldr	r2, [r3, #4]
   23b18:	b2d2      	uxtb	r2, r2
   23b1a:	2a03      	cmp	r2, #3
   23b1c:	d104      	bne.n	23b28 <rpc_transport_ipc_tx_rpc_data_alloc+0x30>
   23b1e:	609f      	str	r7, [r3, #8]
   23b20:	685a      	ldr	r2, [r3, #4]
   23b22:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   23b26:	605a      	str	r2, [r3, #4]
   23b28:	685a      	ldr	r2, [r3, #4]
   23b2a:	f012 0fff 	tst.w	r2, #255	; 0xff
   23b2e:	d101      	bne.n	23b34 <rpc_transport_ipc_tx_rpc_data_alloc+0x3c>
   23b30:	689b      	ldr	r3, [r3, #8]
   23b32:	b12b      	cbz	r3, 23b40 <rpc_transport_ipc_tx_rpc_data_alloc+0x48>
   23b34:	3001      	adds	r0, #1
   23b36:	42a8      	cmp	r0, r5
   23b38:	d1eb      	bne.n	23b12 <rpc_transport_ipc_tx_rpc_data_alloc+0x1a>
   23b3a:	2000      	movs	r0, #0
   23b3c:	bcf0      	pop	{r4, r5, r6, r7}
   23b3e:	4770      	bx	lr
   23b40:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   23b44:	4421      	add	r1, r4
   23b46:	6088      	str	r0, [r1, #8]
   23b48:	6843      	ldr	r3, [r0, #4]
   23b4a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   23b4e:	f043 0302 	orr.w	r3, r3, #2
   23b52:	6043      	str	r3, [r0, #4]
   23b54:	bcf0      	pop	{r4, r5, r6, r7}
   23b56:	4770      	bx	lr
   23b58:	2000      	movs	r0, #0
   23b5a:	4770      	bx	lr
   23b5c:	20029084 	.word	0x20029084
   23b60:	2002252c 	.word	0x2002252c
   23b64:	20022528 	.word	0x20022528

00023b68 <rpc_transport_ipc_tx_rpc_ctrl_alloc>:
   23b68:	b4f0      	push	{r4, r5, r6, r7}
   23b6a:	4a15      	ldr	r2, [pc, #84]	; (23bc0 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x58>)
   23b6c:	4b15      	ldr	r3, [pc, #84]	; (23bc4 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x5c>)
   23b6e:	6814      	ldr	r4, [r2, #0]
   23b70:	681e      	ldr	r6, [r3, #0]
   23b72:	6825      	ldr	r5, [r4, #0]
   23b74:	b1ad      	cbz	r5, 23ba2 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x3a>
   23b76:	2000      	movs	r0, #0
   23b78:	4607      	mov	r7, r0
   23b7a:	00c1      	lsls	r1, r0, #3
   23b7c:	1863      	adds	r3, r4, r1
   23b7e:	685a      	ldr	r2, [r3, #4]
   23b80:	b2d2      	uxtb	r2, r2
   23b82:	2a03      	cmp	r2, #3
   23b84:	d104      	bne.n	23b90 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x28>
   23b86:	609f      	str	r7, [r3, #8]
   23b88:	685a      	ldr	r2, [r3, #4]
   23b8a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
   23b8e:	605a      	str	r2, [r3, #4]
   23b90:	685a      	ldr	r2, [r3, #4]
   23b92:	f012 0fff 	tst.w	r2, #255	; 0xff
   23b96:	d101      	bne.n	23b9c <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x34>
   23b98:	689b      	ldr	r3, [r3, #8]
   23b9a:	b12b      	cbz	r3, 23ba8 <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x40>
   23b9c:	3001      	adds	r0, #1
   23b9e:	4285      	cmp	r5, r0
   23ba0:	d1eb      	bne.n	23b7a <rpc_transport_ipc_tx_rpc_ctrl_alloc+0x12>
   23ba2:	2000      	movs	r0, #0
   23ba4:	bcf0      	pop	{r4, r5, r6, r7}
   23ba6:	4770      	bx	lr
   23ba8:	eb06 1080 	add.w	r0, r6, r0, lsl #6
   23bac:	4421      	add	r1, r4
   23bae:	6088      	str	r0, [r1, #8]
   23bb0:	6843      	ldr	r3, [r0, #4]
   23bb2:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   23bb6:	f043 0301 	orr.w	r3, r3, #1
   23bba:	6043      	str	r3, [r0, #4]
   23bbc:	bcf0      	pop	{r4, r5, r6, r7}
   23bbe:	4770      	bx	lr
   23bc0:	20022524 	.word	0x20022524
   23bc4:	20022520 	.word	0x20022520

00023bc8 <rpc_transport_ipc_tx_data_alloc>:
   23bc8:	4b03      	ldr	r3, [pc, #12]	; (23bd8 <rpc_transport_ipc_tx_data_alloc+0x10>)
   23bca:	781b      	ldrb	r3, [r3, #0]
   23bcc:	b90b      	cbnz	r3, 23bd2 <rpc_transport_ipc_tx_data_alloc+0xa>
   23bce:	f006 b9c9 	b.w	29f64 <nrf_shared_malloc>
   23bd2:	2000      	movs	r0, #0
   23bd4:	4770      	bx	lr
   23bd6:	bf00      	nop
   23bd8:	20029084 	.word	0x20029084

00023bdc <rpc_transport_ipc_tx_suspend>:
   23bdc:	2201      	movs	r2, #1
   23bde:	4b01      	ldr	r3, [pc, #4]	; (23be4 <rpc_transport_ipc_tx_suspend+0x8>)
   23be0:	701a      	strb	r2, [r3, #0]
   23be2:	4770      	bx	lr
   23be4:	20029084 	.word	0x20029084

00023be8 <secure_client_socket>:
   23be8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23bec:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   23bf0:	460c      	mov	r4, r1
   23bf2:	680b      	ldr	r3, [r1, #0]
   23bf4:	4f46      	ldr	r7, [pc, #280]	; (23d10 <secure_client_socket+0x128>)
   23bf6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   23bfa:	600b      	str	r3, [r1, #0]
   23bfc:	680b      	ldr	r3, [r1, #0]
   23bfe:	00c6      	lsls	r6, r0, #3
   23c00:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   23c04:	600b      	str	r3, [r1, #0]
   23c06:	eb07 0a06 	add.w	sl, r7, r6
   23c0a:	b084      	sub	sp, #16
   23c0c:	f8da 3004 	ldr.w	r3, [sl, #4]
   23c10:	6989      	ldr	r1, [r1, #24]
   23c12:	f247 0281 	movw	r2, #28801	; 0x7081
   23c16:	4605      	mov	r5, r0
   23c18:	f8d4 8000 	ldr.w	r8, [r4]
   23c1c:	e9cd cc02 	strd	ip, ip, [sp, #8]
   23c20:	f000 fd92 	bl	24748 <ip_interface_request_create>
   23c24:	2800      	cmp	r0, #0
   23c26:	d06d      	beq.n	23d04 <secure_client_socket+0x11c>
   23c28:	f8da 2004 	ldr.w	r2, [sl, #4]
   23c2c:	4681      	mov	r9, r0
   23c2e:	2a00      	cmp	r2, #0
   23c30:	d15d      	bne.n	23cee <secure_client_socket+0x106>
   23c32:	4b38      	ldr	r3, [pc, #224]	; (23d14 <secure_client_socket+0x12c>)
   23c34:	1971      	adds	r1, r6, r5
   23c36:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   23c3a:	2224      	movs	r2, #36	; 0x24
   23c3c:	f109 0014 	add.w	r0, r9, #20
   23c40:	f015 f9ca 	bl	38fd8 <memcpy>
   23c44:	f8d9 3008 	ldr.w	r3, [r9, #8]
   23c48:	4649      	mov	r1, r9
   23c4a:	3324      	adds	r3, #36	; 0x24
   23c4c:	f8c9 3008 	str.w	r3, [r9, #8]
   23c50:	6822      	ldr	r2, [r4, #0]
   23c52:	4643      	mov	r3, r8
   23c54:	0c12      	lsrs	r2, r2, #16
   23c56:	0412      	lsls	r2, r2, #16
   23c58:	f042 020a 	orr.w	r2, r2, #10
   23c5c:	6022      	str	r2, [r4, #0]
   23c5e:	4620      	mov	r0, r4
   23c60:	f247 0281 	movw	r2, #28801	; 0x7081
   23c64:	f000 fd90 	bl	24788 <ip_interface_request_send>
   23c68:	4603      	mov	r3, r0
   23c6a:	b968      	cbnz	r0, 23c88 <secure_client_socket+0xa0>
   23c6c:	6823      	ldr	r3, [r4, #0]
   23c6e:	00db      	lsls	r3, r3, #3
   23c70:	d40e      	bmi.n	23c90 <secure_client_socket+0xa8>
   23c72:	ab03      	add	r3, sp, #12
   23c74:	f64f 72ff 	movw	r2, #65535	; 0xffff
   23c78:	210b      	movs	r1, #11
   23c7a:	4628      	mov	r0, r5
   23c7c:	f000 fd98 	bl	247b0 <ip_interface_wait>
   23c80:	4603      	mov	r3, r0
   23c82:	b150      	cbz	r0, 23c9a <secure_client_socket+0xb2>
   23c84:	f8c4 8000 	str.w	r8, [r4]
   23c88:	4618      	mov	r0, r3
   23c8a:	b004      	add	sp, #16
   23c8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23c90:	2373      	movs	r3, #115	; 0x73
   23c92:	4618      	mov	r0, r3
   23c94:	b004      	add	sp, #16
   23c96:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23c9a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
   23c9e:	ab02      	add	r3, sp, #8
   23ca0:	4611      	mov	r1, r2
   23ca2:	4628      	mov	r0, r5
   23ca4:	f000 fd84 	bl	247b0 <ip_interface_wait>
   23ca8:	4603      	mov	r3, r0
   23caa:	bb30      	cbnz	r0, 23cfa <secure_client_socket+0x112>
   23cac:	f857 0035 	ldr.w	r0, [r7, r5, lsl #3]
   23cb0:	b138      	cbz	r0, 23cc2 <secure_client_socket+0xda>
   23cb2:	9301      	str	r3, [sp, #4]
   23cb4:	f006 f94a 	bl	29f4c <nrf_free>
   23cb8:	9b01      	ldr	r3, [sp, #4]
   23cba:	443e      	add	r6, r7
   23cbc:	6073      	str	r3, [r6, #4]
   23cbe:	f847 3035 	str.w	r3, [r7, r5, lsl #3]
   23cc2:	4618      	mov	r0, r3
   23cc4:	6822      	ldr	r2, [r4, #0]
   23cc6:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
   23cca:	6022      	str	r2, [r4, #0]
   23ccc:	6822      	ldr	r2, [r4, #0]
   23cce:	0c12      	lsrs	r2, r2, #16
   23cd0:	0412      	lsls	r2, r2, #16
   23cd2:	f042 020c 	orr.w	r2, r2, #12
   23cd6:	6022      	str	r2, [r4, #0]
   23cd8:	6822      	ldr	r2, [r4, #0]
   23cda:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   23cde:	6022      	str	r2, [r4, #0]
   23ce0:	6822      	ldr	r2, [r4, #0]
   23ce2:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   23ce6:	6022      	str	r2, [r4, #0]
   23ce8:	b004      	add	sp, #16
   23cea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23cee:	f857 1035 	ldr.w	r1, [r7, r5, lsl #3]
   23cf2:	6800      	ldr	r0, [r0, #0]
   23cf4:	f015 f970 	bl	38fd8 <memcpy>
   23cf8:	e79b      	b.n	23c32 <secure_client_socket+0x4a>
   23cfa:	2b73      	cmp	r3, #115	; 0x73
   23cfc:	d0c4      	beq.n	23c88 <secure_client_socket+0xa0>
   23cfe:	f8c4 8000 	str.w	r8, [r4]
   23d02:	e7c1      	b.n	23c88 <secure_client_socket+0xa0>
   23d04:	230c      	movs	r3, #12
   23d06:	4618      	mov	r0, r3
   23d08:	b004      	add	sp, #16
   23d0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23d0e:	bf00      	nop
   23d10:	2002268c 	.word	0x2002268c
   23d14:	20022548 	.word	0x20022548

00023d18 <tls_interface_init>:
   23d18:	2201      	movs	r2, #1
   23d1a:	4b02      	ldr	r3, [pc, #8]	; (23d24 <tls_interface_init+0xc>)
   23d1c:	2000      	movs	r0, #0
   23d1e:	701a      	strb	r2, [r3, #0]
   23d20:	4770      	bx	lr
   23d22:	bf00      	nop
   23d24:	20029085 	.word	0x20029085

00023d28 <tls_interface_open>:
   23d28:	b538      	push	{r3, r4, r5, lr}
   23d2a:	4b23      	ldr	r3, [pc, #140]	; (23db8 <tls_interface_open+0x90>)
   23d2c:	781b      	ldrb	r3, [r3, #0]
   23d2e:	2b00      	cmp	r3, #0
   23d30:	d03c      	beq.n	23dac <tls_interface_open+0x84>
   23d32:	1e4b      	subs	r3, r1, #1
   23d34:	2b01      	cmp	r3, #1
   23d36:	d808      	bhi.n	23d4a <tls_interface_open+0x22>
   23d38:	4614      	mov	r4, r2
   23d3a:	b162      	cbz	r2, 23d56 <tls_interface_open+0x2e>
   23d3c:	2901      	cmp	r1, #1
   23d3e:	d02d      	beq.n	23d9c <tls_interface_open+0x74>
   23d40:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   23d44:	bf08      	it	eq
   23d46:	2202      	moveq	r2, #2
   23d48:	d00d      	beq.n	23d66 <tls_interface_open+0x3e>
   23d4a:	2029      	movs	r0, #41	; 0x29
   23d4c:	f7fc f988 	bl	20060 <bsd_os_errno_set>
   23d50:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   23d54:	e020      	b.n	23d98 <tls_interface_open+0x70>
   23d56:	2901      	cmp	r1, #1
   23d58:	bf0b      	itete	eq
   23d5a:	2201      	moveq	r2, #1
   23d5c:	2202      	movne	r2, #2
   23d5e:	f44f 7482 	moveq.w	r4, #260	; 0x104
   23d62:	f44f 7487 	movne.w	r4, #270	; 0x10e
   23d66:	f000 fd55 	bl	24814 <ip_interface_open>
   23d6a:	1e05      	subs	r5, r0, #0
   23d6c:	db1b      	blt.n	23da6 <tls_interface_open+0x7e>
   23d6e:	4b13      	ldr	r3, [pc, #76]	; (23dbc <tls_interface_open+0x94>)
   23d70:	eb05 00c5 	add.w	r0, r5, r5, lsl #3
   23d74:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   23d78:	2224      	movs	r2, #36	; 0x24
   23d7a:	4911      	ldr	r1, [pc, #68]	; (23dc0 <tls_interface_open+0x98>)
   23d7c:	f015 f92c 	bl	38fd8 <memcpy>
   23d80:	4628      	mov	r0, r5
   23d82:	f006 fd31 	bl	2a7e8 <interface_socket_from_handle_get>
   23d86:	6803      	ldr	r3, [r0, #0]
   23d88:	6144      	str	r4, [r0, #20]
   23d8a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   23d8e:	6003      	str	r3, [r0, #0]
   23d90:	6803      	ldr	r3, [r0, #0]
   23d92:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   23d96:	6003      	str	r3, [r0, #0]
   23d98:	4628      	mov	r0, r5
   23d9a:	bd38      	pop	{r3, r4, r5, pc}
   23d9c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   23da0:	d1d3      	bne.n	23d4a <tls_interface_open+0x22>
   23da2:	460a      	mov	r2, r1
   23da4:	e7df      	b.n	23d66 <tls_interface_open+0x3e>
   23da6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   23daa:	e7f5      	b.n	23d98 <tls_interface_open+0x70>
   23dac:	2070      	movs	r0, #112	; 0x70
   23dae:	f7fc f957 	bl	20060 <bsd_os_errno_set>
   23db2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   23db6:	e7ef      	b.n	23d98 <tls_interface_open+0x70>
   23db8:	20029085 	.word	0x20029085
   23dbc:	20022548 	.word	0x20022548
   23dc0:	0003a914 	.word	0x0003a914

00023dc4 <tls_interface_close>:
   23dc4:	b538      	push	{r3, r4, r5, lr}
   23dc6:	4604      	mov	r4, r0
   23dc8:	f006 fd0e 	bl	2a7e8 <interface_socket_from_handle_get>
   23dcc:	b180      	cbz	r0, 23df0 <tls_interface_close+0x2c>
   23dce:	4d0b      	ldr	r5, [pc, #44]	; (23dfc <tls_interface_close+0x38>)
   23dd0:	f855 0034 	ldr.w	r0, [r5, r4, lsl #3]
   23dd4:	b138      	cbz	r0, 23de6 <tls_interface_close+0x22>
   23dd6:	f006 f8b9 	bl	29f4c <nrf_free>
   23dda:	2300      	movs	r3, #0
   23ddc:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
   23de0:	f845 3034 	str.w	r3, [r5, r4, lsl #3]
   23de4:	6053      	str	r3, [r2, #4]
   23de6:	4620      	mov	r0, r4
   23de8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   23dec:	f000 bdd8 	b.w	249a0 <ip_interface_close>
   23df0:	2009      	movs	r0, #9
   23df2:	f7fc f935 	bl	20060 <bsd_os_errno_set>
   23df6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   23dfa:	bd38      	pop	{r3, r4, r5, pc}
   23dfc:	2002268c 	.word	0x2002268c

00023e00 <tls_interface_sendto>:
   23e00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23e04:	460d      	mov	r5, r1
   23e06:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   23e0a:	4616      	mov	r6, r2
   23e0c:	461f      	mov	r7, r3
   23e0e:	4604      	mov	r4, r0
   23e10:	f006 fcea 	bl	2a7e8 <interface_socket_from_handle_get>
   23e14:	2800      	cmp	r0, #0
   23e16:	d03b      	beq.n	23e90 <tls_interface_sendto+0x90>
   23e18:	6803      	ldr	r3, [r0, #0]
   23e1a:	b29b      	uxth	r3, r3
   23e1c:	2b0c      	cmp	r3, #12
   23e1e:	d039      	beq.n	23e94 <tls_interface_sendto+0x94>
   23e20:	6803      	ldr	r3, [r0, #0]
   23e22:	b29b      	uxth	r3, r3
   23e24:	2b0b      	cmp	r3, #11
   23e26:	d111      	bne.n	23e4c <tls_interface_sendto+0x4c>
   23e28:	4b20      	ldr	r3, [pc, #128]	; (23eac <tls_interface_sendto+0xac>)
   23e2a:	eb04 04c4 	add.w	r4, r4, r4, lsl #3
   23e2e:	f813 3024 	ldrb.w	r3, [r3, r4, lsl #2]
   23e32:	2b02      	cmp	r3, #2
   23e34:	d038      	beq.n	23ea8 <tls_interface_sendto+0xa8>
   23e36:	6903      	ldr	r3, [r0, #16]
   23e38:	2b01      	cmp	r3, #1
   23e3a:	bf14      	ite	ne
   23e3c:	2039      	movne	r0, #57	; 0x39
   23e3e:	202a      	moveq	r0, #42	; 0x2a
   23e40:	f7fc f90e 	bl	20060 <bsd_os_errno_set>
   23e44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   23e48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23e4c:	6903      	ldr	r3, [r0, #16]
   23e4e:	2b01      	cmp	r3, #1
   23e50:	d00b      	beq.n	23e6a <tls_interface_sendto+0x6a>
   23e52:	2b02      	cmp	r3, #2
   23e54:	d001      	beq.n	23e5a <tls_interface_sendto+0x5a>
   23e56:	2039      	movs	r0, #57	; 0x39
   23e58:	e7f2      	b.n	23e40 <tls_interface_sendto+0x40>
   23e5a:	6803      	ldr	r3, [r0, #0]
   23e5c:	b29b      	uxth	r3, r3
   23e5e:	2b02      	cmp	r3, #2
   23e60:	d007      	beq.n	23e72 <tls_interface_sendto+0x72>
   23e62:	6803      	ldr	r3, [r0, #0]
   23e64:	b29b      	uxth	r3, r3
   23e66:	2b04      	cmp	r3, #4
   23e68:	d003      	beq.n	23e72 <tls_interface_sendto+0x72>
   23e6a:	6803      	ldr	r3, [r0, #0]
   23e6c:	b29b      	uxth	r3, r3
   23e6e:	2b05      	cmp	r3, #5
   23e70:	d1f1      	bne.n	23e56 <tls_interface_sendto+0x56>
   23e72:	4b0e      	ldr	r3, [pc, #56]	; (23eac <tls_interface_sendto+0xac>)
   23e74:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   23e78:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   23e7c:	2b02      	cmp	r3, #2
   23e7e:	d1ea      	bne.n	23e56 <tls_interface_sendto+0x56>
   23e80:	4601      	mov	r1, r0
   23e82:	4620      	mov	r0, r4
   23e84:	f7ff feb0 	bl	23be8 <secure_client_socket>
   23e88:	2800      	cmp	r0, #0
   23e8a:	d003      	beq.n	23e94 <tls_interface_sendto+0x94>
   23e8c:	dcd8      	bgt.n	23e40 <tls_interface_sendto+0x40>
   23e8e:	e7d9      	b.n	23e44 <tls_interface_sendto+0x44>
   23e90:	2009      	movs	r0, #9
   23e92:	e7d5      	b.n	23e40 <tls_interface_sendto+0x40>
   23e94:	e9cd 8908 	strd	r8, r9, [sp, #32]
   23e98:	463b      	mov	r3, r7
   23e9a:	4632      	mov	r2, r6
   23e9c:	4629      	mov	r1, r5
   23e9e:	4620      	mov	r0, r4
   23ea0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23ea4:	f000 bdee 	b.w	24a84 <ip_interface_sendto>
   23ea8:	2023      	movs	r0, #35	; 0x23
   23eaa:	e7c9      	b.n	23e40 <tls_interface_sendto+0x40>
   23eac:	20022548 	.word	0x20022548

00023eb0 <tls_interface_recvfrom>:
   23eb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23eb4:	460d      	mov	r5, r1
   23eb6:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   23eba:	4616      	mov	r6, r2
   23ebc:	461f      	mov	r7, r3
   23ebe:	4604      	mov	r4, r0
   23ec0:	f006 fc92 	bl	2a7e8 <interface_socket_from_handle_get>
   23ec4:	2800      	cmp	r0, #0
   23ec6:	d038      	beq.n	23f3a <tls_interface_recvfrom+0x8a>
   23ec8:	6803      	ldr	r3, [r0, #0]
   23eca:	b29b      	uxth	r3, r3
   23ecc:	2b0c      	cmp	r3, #12
   23ece:	d00f      	beq.n	23ef0 <tls_interface_recvfrom+0x40>
   23ed0:	6803      	ldr	r3, [r0, #0]
   23ed2:	b29b      	uxth	r3, r3
   23ed4:	2b0d      	cmp	r3, #13
   23ed6:	d00b      	beq.n	23ef0 <tls_interface_recvfrom+0x40>
   23ed8:	6903      	ldr	r3, [r0, #16]
   23eda:	2b01      	cmp	r3, #1
   23edc:	d01a      	beq.n	23f14 <tls_interface_recvfrom+0x64>
   23ede:	2b02      	cmp	r3, #2
   23ee0:	d010      	beq.n	23f04 <tls_interface_recvfrom+0x54>
   23ee2:	2023      	movs	r0, #35	; 0x23
   23ee4:	f7fc f8bc 	bl	20060 <bsd_os_errno_set>
   23ee8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   23eec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23ef0:	e9cd 8908 	strd	r8, r9, [sp, #32]
   23ef4:	463b      	mov	r3, r7
   23ef6:	4632      	mov	r2, r6
   23ef8:	4629      	mov	r1, r5
   23efa:	4620      	mov	r0, r4
   23efc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23f00:	f000 bf26 	b.w	24d50 <ip_interface_recvfrom>
   23f04:	6803      	ldr	r3, [r0, #0]
   23f06:	b29b      	uxth	r3, r3
   23f08:	2b02      	cmp	r3, #2
   23f0a:	d007      	beq.n	23f1c <tls_interface_recvfrom+0x6c>
   23f0c:	6803      	ldr	r3, [r0, #0]
   23f0e:	b29b      	uxth	r3, r3
   23f10:	2b04      	cmp	r3, #4
   23f12:	d003      	beq.n	23f1c <tls_interface_recvfrom+0x6c>
   23f14:	6803      	ldr	r3, [r0, #0]
   23f16:	b29b      	uxth	r3, r3
   23f18:	2b05      	cmp	r3, #5
   23f1a:	d1e2      	bne.n	23ee2 <tls_interface_recvfrom+0x32>
   23f1c:	4b08      	ldr	r3, [pc, #32]	; (23f40 <tls_interface_recvfrom+0x90>)
   23f1e:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   23f22:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   23f26:	2b02      	cmp	r3, #2
   23f28:	d1db      	bne.n	23ee2 <tls_interface_recvfrom+0x32>
   23f2a:	4601      	mov	r1, r0
   23f2c:	4620      	mov	r0, r4
   23f2e:	f7ff fe5b 	bl	23be8 <secure_client_socket>
   23f32:	2800      	cmp	r0, #0
   23f34:	d0dc      	beq.n	23ef0 <tls_interface_recvfrom+0x40>
   23f36:	dcd5      	bgt.n	23ee4 <tls_interface_recvfrom+0x34>
   23f38:	e7d6      	b.n	23ee8 <tls_interface_recvfrom+0x38>
   23f3a:	2009      	movs	r0, #9
   23f3c:	e7d2      	b.n	23ee4 <tls_interface_recvfrom+0x34>
   23f3e:	bf00      	nop
   23f40:	20022548 	.word	0x20022548

00023f44 <tls_interface_bind>:
   23f44:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   23f48:	b082      	sub	sp, #8
   23f4a:	460e      	mov	r6, r1
   23f4c:	4617      	mov	r7, r2
   23f4e:	4605      	mov	r5, r0
   23f50:	f006 fc4a 	bl	2a7e8 <interface_socket_from_handle_get>
   23f54:	2800      	cmp	r0, #0
   23f56:	d069      	beq.n	2402c <tls_interface_bind+0xe8>
   23f58:	6803      	ldr	r3, [r0, #0]
   23f5a:	4604      	mov	r4, r0
   23f5c:	b29b      	uxth	r3, r3
   23f5e:	2b02      	cmp	r3, #2
   23f60:	d158      	bne.n	24014 <tls_interface_bind+0xd0>
   23f62:	463a      	mov	r2, r7
   23f64:	4631      	mov	r1, r6
   23f66:	4628      	mov	r0, r5
   23f68:	f001 f8dc 	bl	25124 <ip_interface_bind>
   23f6c:	2800      	cmp	r0, #0
   23f6e:	d148      	bne.n	24002 <tls_interface_bind+0xbe>
   23f70:	00ee      	lsls	r6, r5, #3
   23f72:	4f2f      	ldr	r7, [pc, #188]	; (24030 <tls_interface_bind+0xec>)
   23f74:	1973      	adds	r3, r6, r5
   23f76:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   23f7a:	2b01      	cmp	r3, #1
   23f7c:	d002      	beq.n	23f84 <tls_interface_bind+0x40>
   23f7e:	b002      	add	sp, #8
   23f80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   23f84:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   23f88:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 24034 <tls_interface_bind+0xf0>
   23f8c:	f247 0281 	movw	r2, #28801	; 0x7081
   23f90:	eb0a 0906 	add.w	r9, sl, r6
   23f94:	f8d9 3004 	ldr.w	r3, [r9, #4]
   23f98:	69a1      	ldr	r1, [r4, #24]
   23f9a:	4628      	mov	r0, r5
   23f9c:	f8cd c004 	str.w	ip, [sp, #4]
   23fa0:	f000 fbd2 	bl	24748 <ip_interface_request_create>
   23fa4:	4680      	mov	r8, r0
   23fa6:	2800      	cmp	r0, #0
   23fa8:	d03e      	beq.n	24028 <tls_interface_bind+0xe4>
   23faa:	f8d9 2004 	ldr.w	r2, [r9, #4]
   23fae:	bbaa      	cbnz	r2, 2401c <tls_interface_bind+0xd8>
   23fb0:	1971      	adds	r1, r6, r5
   23fb2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   23fb6:	2224      	movs	r2, #36	; 0x24
   23fb8:	f108 0014 	add.w	r0, r8, #20
   23fbc:	f015 f80c 	bl	38fd8 <memcpy>
   23fc0:	f8d8 3008 	ldr.w	r3, [r8, #8]
   23fc4:	4641      	mov	r1, r8
   23fc6:	3324      	adds	r3, #36	; 0x24
   23fc8:	f8c8 3008 	str.w	r3, [r8, #8]
   23fcc:	6822      	ldr	r2, [r4, #0]
   23fce:	2304      	movs	r3, #4
   23fd0:	0c12      	lsrs	r2, r2, #16
   23fd2:	0412      	lsls	r2, r2, #16
   23fd4:	f042 020a 	orr.w	r2, r2, #10
   23fd8:	6022      	str	r2, [r4, #0]
   23fda:	4620      	mov	r0, r4
   23fdc:	f247 0281 	movw	r2, #28801	; 0x7081
   23fe0:	f000 fbd2 	bl	24788 <ip_interface_request_send>
   23fe4:	b968      	cbnz	r0, 24002 <tls_interface_bind+0xbe>
   23fe6:	6823      	ldr	r3, [r4, #0]
   23fe8:	00db      	lsls	r3, r3, #3
   23fea:	d415      	bmi.n	24018 <tls_interface_bind+0xd4>
   23fec:	4628      	mov	r0, r5
   23fee:	ab01      	add	r3, sp, #4
   23ff0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   23ff4:	210b      	movs	r1, #11
   23ff6:	f000 fbdb 	bl	247b0 <ip_interface_wait>
   23ffa:	2800      	cmp	r0, #0
   23ffc:	d0bf      	beq.n	23f7e <tls_interface_bind+0x3a>
   23ffe:	2304      	movs	r3, #4
   24000:	6023      	str	r3, [r4, #0]
   24002:	2800      	cmp	r0, #0
   24004:	ddbb      	ble.n	23f7e <tls_interface_bind+0x3a>
   24006:	f7fc f82b 	bl	20060 <bsd_os_errno_set>
   2400a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2400e:	b002      	add	sp, #8
   24010:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   24014:	202d      	movs	r0, #45	; 0x2d
   24016:	e7f6      	b.n	24006 <tls_interface_bind+0xc2>
   24018:	2073      	movs	r0, #115	; 0x73
   2401a:	e7f4      	b.n	24006 <tls_interface_bind+0xc2>
   2401c:	f85a 1035 	ldr.w	r1, [sl, r5, lsl #3]
   24020:	6800      	ldr	r0, [r0, #0]
   24022:	f014 ffd9 	bl	38fd8 <memcpy>
   24026:	e7c3      	b.n	23fb0 <tls_interface_bind+0x6c>
   24028:	200c      	movs	r0, #12
   2402a:	e7ec      	b.n	24006 <tls_interface_bind+0xc2>
   2402c:	2009      	movs	r0, #9
   2402e:	e7ea      	b.n	24006 <tls_interface_bind+0xc2>
   24030:	20022548 	.word	0x20022548
   24034:	2002268c 	.word	0x2002268c

00024038 <tls_interface_connect>:
   24038:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2403a:	460e      	mov	r6, r1
   2403c:	4617      	mov	r7, r2
   2403e:	4604      	mov	r4, r0
   24040:	f006 fbd2 	bl	2a7e8 <interface_socket_from_handle_get>
   24044:	b1e8      	cbz	r0, 24082 <tls_interface_connect+0x4a>
   24046:	4b13      	ldr	r3, [pc, #76]	; (24094 <tls_interface_connect+0x5c>)
   24048:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
   2404c:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   24050:	2b02      	cmp	r3, #2
   24052:	d11c      	bne.n	2408e <tls_interface_connect+0x56>
   24054:	6803      	ldr	r3, [r0, #0]
   24056:	4605      	mov	r5, r0
   24058:	b29b      	uxth	r3, r3
   2405a:	2b02      	cmp	r3, #2
   2405c:	d003      	beq.n	24066 <tls_interface_connect+0x2e>
   2405e:	6803      	ldr	r3, [r0, #0]
   24060:	b29b      	uxth	r3, r3
   24062:	2b04      	cmp	r3, #4
   24064:	d113      	bne.n	2408e <tls_interface_connect+0x56>
   24066:	463a      	mov	r2, r7
   24068:	4631      	mov	r1, r6
   2406a:	4620      	mov	r0, r4
   2406c:	f000 ff98 	bl	24fa0 <ip_interface_connect>
   24070:	b110      	cbz	r0, 24078 <tls_interface_connect+0x40>
   24072:	2800      	cmp	r0, #0
   24074:	dc06      	bgt.n	24084 <tls_interface_connect+0x4c>
   24076:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24078:	4629      	mov	r1, r5
   2407a:	4620      	mov	r0, r4
   2407c:	f7ff fdb4 	bl	23be8 <secure_client_socket>
   24080:	e7f7      	b.n	24072 <tls_interface_connect+0x3a>
   24082:	2009      	movs	r0, #9
   24084:	f7fb ffec 	bl	20060 <bsd_os_errno_set>
   24088:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2408c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2408e:	202d      	movs	r0, #45	; 0x2d
   24090:	e7f8      	b.n	24084 <tls_interface_connect+0x4c>
   24092:	bf00      	nop
   24094:	20022548 	.word	0x20022548

00024098 <tls_interface_listen>:
   24098:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2409c:	b085      	sub	sp, #20
   2409e:	9101      	str	r1, [sp, #4]
   240a0:	4605      	mov	r5, r0
   240a2:	f006 fba1 	bl	2a7e8 <interface_socket_from_handle_get>
   240a6:	2800      	cmp	r0, #0
   240a8:	d07c      	beq.n	241a4 <tls_interface_listen+0x10c>
   240aa:	6903      	ldr	r3, [r0, #16]
   240ac:	4604      	mov	r4, r0
   240ae:	2b01      	cmp	r3, #1
   240b0:	d176      	bne.n	241a0 <tls_interface_listen+0x108>
   240b2:	6803      	ldr	r3, [r0, #0]
   240b4:	b29b      	uxth	r3, r3
   240b6:	2b04      	cmp	r3, #4
   240b8:	d062      	beq.n	24180 <tls_interface_listen+0xe8>
   240ba:	6823      	ldr	r3, [r4, #0]
   240bc:	b29b      	uxth	r3, r3
   240be:	2b0b      	cmp	r3, #11
   240c0:	d16e      	bne.n	241a0 <tls_interface_listen+0x108>
   240c2:	00ee      	lsls	r6, r5, #3
   240c4:	4f38      	ldr	r7, [pc, #224]	; (241a8 <tls_interface_listen+0x110>)
   240c6:	1973      	adds	r3, r6, r5
   240c8:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   240cc:	2b01      	cmp	r3, #1
   240ce:	d167      	bne.n	241a0 <tls_interface_listen+0x108>
   240d0:	2201      	movs	r2, #1
   240d2:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   240d6:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 241ac <tls_interface_listen+0x114>
   240da:	1973      	adds	r3, r6, r5
   240dc:	00ee      	lsls	r6, r5, #3
   240de:	f807 2023 	strb.w	r2, [r7, r3, lsl #2]
   240e2:	eb09 0806 	add.w	r8, r9, r6
   240e6:	69a1      	ldr	r1, [r4, #24]
   240e8:	f8d8 3004 	ldr.w	r3, [r8, #4]
   240ec:	f247 0281 	movw	r2, #28801	; 0x7081
   240f0:	4628      	mov	r0, r5
   240f2:	f8d4 a000 	ldr.w	sl, [r4]
   240f6:	f8cd c00c 	str.w	ip, [sp, #12]
   240fa:	f000 fb25 	bl	24748 <ip_interface_request_create>
   240fe:	4683      	mov	fp, r0
   24100:	2800      	cmp	r0, #0
   24102:	d04b      	beq.n	2419c <tls_interface_listen+0x104>
   24104:	f8d8 2004 	ldr.w	r2, [r8, #4]
   24108:	2a00      	cmp	r2, #0
   2410a:	d141      	bne.n	24190 <tls_interface_listen+0xf8>
   2410c:	1971      	adds	r1, r6, r5
   2410e:	eb07 0181 	add.w	r1, r7, r1, lsl #2
   24112:	2224      	movs	r2, #36	; 0x24
   24114:	f10b 0014 	add.w	r0, fp, #20
   24118:	f014 ff5e 	bl	38fd8 <memcpy>
   2411c:	f8db 2008 	ldr.w	r2, [fp, #8]
   24120:	4659      	mov	r1, fp
   24122:	3224      	adds	r2, #36	; 0x24
   24124:	f8cb 2008 	str.w	r2, [fp, #8]
   24128:	6822      	ldr	r2, [r4, #0]
   2412a:	4653      	mov	r3, sl
   2412c:	0c12      	lsrs	r2, r2, #16
   2412e:	0412      	lsls	r2, r2, #16
   24130:	f042 020a 	orr.w	r2, r2, #10
   24134:	6022      	str	r2, [r4, #0]
   24136:	4620      	mov	r0, r4
   24138:	f247 0281 	movw	r2, #28801	; 0x7081
   2413c:	f000 fb24 	bl	24788 <ip_interface_request_send>
   24140:	b960      	cbnz	r0, 2415c <tls_interface_listen+0xc4>
   24142:	6823      	ldr	r3, [r4, #0]
   24144:	00db      	lsls	r3, r3, #3
   24146:	d40e      	bmi.n	24166 <tls_interface_listen+0xce>
   24148:	ab03      	add	r3, sp, #12
   2414a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2414e:	210b      	movs	r1, #11
   24150:	4628      	mov	r0, r5
   24152:	f000 fb2d 	bl	247b0 <ip_interface_wait>
   24156:	b170      	cbz	r0, 24176 <tls_interface_listen+0xde>
   24158:	f8c4 a000 	str.w	sl, [r4]
   2415c:	2800      	cmp	r0, #0
   2415e:	dc03      	bgt.n	24168 <tls_interface_listen+0xd0>
   24160:	b005      	add	sp, #20
   24162:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24166:	2073      	movs	r0, #115	; 0x73
   24168:	f7fb ff7a 	bl	20060 <bsd_os_errno_set>
   2416c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24170:	b005      	add	sp, #20
   24172:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24176:	9901      	ldr	r1, [sp, #4]
   24178:	4628      	mov	r0, r5
   2417a:	f001 f875 	bl	25268 <ip_interface_listen>
   2417e:	e7ed      	b.n	2415c <tls_interface_listen+0xc4>
   24180:	00ee      	lsls	r6, r5, #3
   24182:	4f09      	ldr	r7, [pc, #36]	; (241a8 <tls_interface_listen+0x110>)
   24184:	1973      	adds	r3, r6, r5
   24186:	f817 3023 	ldrb.w	r3, [r7, r3, lsl #2]
   2418a:	2b02      	cmp	r3, #2
   2418c:	d195      	bne.n	240ba <tls_interface_listen+0x22>
   2418e:	e79f      	b.n	240d0 <tls_interface_listen+0x38>
   24190:	f859 1035 	ldr.w	r1, [r9, r5, lsl #3]
   24194:	6800      	ldr	r0, [r0, #0]
   24196:	f014 ff1f 	bl	38fd8 <memcpy>
   2419a:	e7b7      	b.n	2410c <tls_interface_listen+0x74>
   2419c:	200c      	movs	r0, #12
   2419e:	e7e3      	b.n	24168 <tls_interface_listen+0xd0>
   241a0:	202d      	movs	r0, #45	; 0x2d
   241a2:	e7e1      	b.n	24168 <tls_interface_listen+0xd0>
   241a4:	2009      	movs	r0, #9
   241a6:	e7df      	b.n	24168 <tls_interface_listen+0xd0>
   241a8:	20022548 	.word	0x20022548
   241ac:	2002268c 	.word	0x2002268c

000241b0 <tls_interface_accept>:
   241b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   241b4:	b082      	sub	sp, #8
   241b6:	460e      	mov	r6, r1
   241b8:	4617      	mov	r7, r2
   241ba:	4698      	mov	r8, r3
   241bc:	4605      	mov	r5, r0
   241be:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   241c2:	f006 fb11 	bl	2a7e8 <interface_socket_from_handle_get>
   241c6:	9401      	str	r4, [sp, #4]
   241c8:	2800      	cmp	r0, #0
   241ca:	d03c      	beq.n	24246 <tls_interface_accept+0x96>
   241cc:	6800      	ldr	r0, [r0, #0]
   241ce:	b280      	uxth	r0, r0
   241d0:	2806      	cmp	r0, #6
   241d2:	d138      	bne.n	24246 <tls_interface_accept+0x96>
   241d4:	4643      	mov	r3, r8
   241d6:	463a      	mov	r2, r7
   241d8:	4631      	mov	r1, r6
   241da:	4628      	mov	r0, r5
   241dc:	f001 f8bc 	bl	25358 <ip_interface_accept>
   241e0:	4604      	mov	r4, r0
   241e2:	b128      	cbz	r0, 241f0 <tls_interface_accept+0x40>
   241e4:	2c00      	cmp	r4, #0
   241e6:	dc2f      	bgt.n	24248 <tls_interface_accept+0x98>
   241e8:	4620      	mov	r0, r4
   241ea:	b002      	add	sp, #8
   241ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   241f0:	4628      	mov	r0, r5
   241f2:	f006 faf9 	bl	2a7e8 <interface_socket_from_handle_get>
   241f6:	6803      	ldr	r3, [r0, #0]
   241f8:	4f18      	ldr	r7, [pc, #96]	; (2425c <tls_interface_accept+0xac>)
   241fa:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   241fe:	6003      	str	r3, [r0, #0]
   24200:	6803      	ldr	r3, [r0, #0]
   24202:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   24206:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   2420a:	4606      	mov	r6, r0
   2420c:	6003      	str	r3, [r0, #0]
   2420e:	eb07 0185 	add.w	r1, r7, r5, lsl #2
   24212:	2224      	movs	r2, #36	; 0x24
   24214:	4638      	mov	r0, r7
   24216:	f014 fedf 	bl	38fd8 <memcpy>
   2421a:	2302      	movs	r3, #2
   2421c:	703b      	strb	r3, [r7, #0]
   2421e:	6833      	ldr	r3, [r6, #0]
   24220:	4620      	mov	r0, r4
   24222:	0c1b      	lsrs	r3, r3, #16
   24224:	041b      	lsls	r3, r3, #16
   24226:	f043 030b 	orr.w	r3, r3, #11
   2422a:	6033      	str	r3, [r6, #0]
   2422c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24230:	ab01      	add	r3, sp, #4
   24232:	210c      	movs	r1, #12
   24234:	f000 fabc 	bl	247b0 <ip_interface_wait>
   24238:	4604      	mov	r4, r0
   2423a:	2800      	cmp	r0, #0
   2423c:	d0d4      	beq.n	241e8 <tls_interface_accept+0x38>
   2423e:	2000      	movs	r0, #0
   24240:	f000 fbae 	bl	249a0 <ip_interface_close>
   24244:	e7ce      	b.n	241e4 <tls_interface_accept+0x34>
   24246:	2409      	movs	r4, #9
   24248:	4620      	mov	r0, r4
   2424a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   2424e:	f7fb ff07 	bl	20060 <bsd_os_errno_set>
   24252:	4620      	mov	r0, r4
   24254:	b002      	add	sp, #8
   24256:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2425a:	bf00      	nop
   2425c:	20022548 	.word	0x20022548

00024260 <tls_interface_setopt>:
   24260:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24264:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   24268:	9e06      	ldr	r6, [sp, #24]
   2426a:	d11e      	bne.n	242aa <tls_interface_setopt+0x4a>
   2426c:	461f      	mov	r7, r3
   2426e:	4605      	mov	r5, r0
   24270:	2b00      	cmp	r3, #0
   24272:	f000 808c 	beq.w	2438e <tls_interface_setopt+0x12e>
   24276:	4690      	mov	r8, r2
   24278:	f006 fab6 	bl	2a7e8 <interface_socket_from_handle_get>
   2427c:	2800      	cmp	r0, #0
   2427e:	d07b      	beq.n	24378 <tls_interface_setopt+0x118>
   24280:	6804      	ldr	r4, [r0, #0]
   24282:	b2a4      	uxth	r4, r4
   24284:	2c02      	cmp	r4, #2
   24286:	d007      	beq.n	24298 <tls_interface_setopt+0x38>
   24288:	6803      	ldr	r3, [r0, #0]
   2428a:	b29b      	uxth	r3, r3
   2428c:	2b04      	cmp	r3, #4
   2428e:	d003      	beq.n	24298 <tls_interface_setopt+0x38>
   24290:	6803      	ldr	r3, [r0, #0]
   24292:	b29b      	uxth	r3, r3
   24294:	2b05      	cmp	r3, #5
   24296:	d16f      	bne.n	24378 <tls_interface_setopt+0x118>
   24298:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
   2429c:	2a04      	cmp	r2, #4
   2429e:	d87c      	bhi.n	2439a <tls_interface_setopt+0x13a>
   242a0:	e8df f002 	tbb	[pc, r2]
   242a4:	41324e24 	.word	0x41324e24
   242a8:	07          	.byte	0x07
   242a9:	00          	.byte	0x00
   242aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   242ae:	f001 b995 	b.w	255dc <ip_interface_setopt>
   242b2:	4c3b      	ldr	r4, [pc, #236]	; (243a0 <tls_interface_setopt+0x140>)
   242b4:	f854 0035 	ldr.w	r0, [r4, r5, lsl #3]
   242b8:	b138      	cbz	r0, 242ca <tls_interface_setopt+0x6a>
   242ba:	f005 fe47 	bl	29f4c <nrf_free>
   242be:	2200      	movs	r2, #0
   242c0:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   242c4:	f844 2035 	str.w	r2, [r4, r5, lsl #3]
   242c8:	605a      	str	r2, [r3, #4]
   242ca:	4630      	mov	r0, r6
   242cc:	b34e      	cbz	r6, 24322 <tls_interface_setopt+0xc2>
   242ce:	f005 fe33 	bl	29f38 <nrf_malloc>
   242d2:	f844 0035 	str.w	r0, [r4, r5, lsl #3]
   242d6:	2800      	cmp	r0, #0
   242d8:	d057      	beq.n	2438a <tls_interface_setopt+0x12a>
   242da:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   242de:	4632      	mov	r2, r6
   242e0:	4639      	mov	r1, r7
   242e2:	6066      	str	r6, [r4, #4]
   242e4:	f014 fe78 	bl	38fd8 <memcpy>
   242e8:	2000      	movs	r0, #0
   242ea:	e01a      	b.n	24322 <tls_interface_setopt+0xc2>
   242ec:	2e04      	cmp	r6, #4
   242ee:	d14a      	bne.n	24386 <tls_interface_setopt+0x126>
   242f0:	6838      	ldr	r0, [r7, #0]
   242f2:	2800      	cmp	r0, #0
   242f4:	d039      	beq.n	2436a <tls_interface_setopt+0x10a>
   242f6:	2801      	cmp	r0, #1
   242f8:	d145      	bne.n	24386 <tls_interface_setopt+0x126>
   242fa:	4a2a      	ldr	r2, [pc, #168]	; (243a4 <tls_interface_setopt+0x144>)
   242fc:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   24300:	f802 0024 	strb.w	r0, [r2, r4, lsl #2]
   24304:	2000      	movs	r0, #0
   24306:	e00c      	b.n	24322 <tls_interface_setopt+0xc2>
   24308:	2e01      	cmp	r6, #1
   2430a:	d13c      	bne.n	24386 <tls_interface_setopt+0x126>
   2430c:	783a      	ldrb	r2, [r7, #0]
   2430e:	2000      	movs	r0, #0
   24310:	3200      	adds	r2, #0
   24312:	bf18      	it	ne
   24314:	2201      	movne	r2, #1
   24316:	4b23      	ldr	r3, [pc, #140]	; (243a4 <tls_interface_setopt+0x144>)
   24318:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   2431c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   24320:	7062      	strb	r2, [r4, #1]
   24322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24326:	2e04      	cmp	r6, #4
   24328:	d12d      	bne.n	24386 <tls_interface_setopt+0x126>
   2432a:	683a      	ldr	r2, [r7, #0]
   2432c:	2a02      	cmp	r2, #2
   2432e:	d82a      	bhi.n	24386 <tls_interface_setopt+0x126>
   24330:	4b1c      	ldr	r3, [pc, #112]	; (243a4 <tls_interface_setopt+0x144>)
   24332:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   24336:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   2433a:	70a2      	strb	r2, [r4, #2]
   2433c:	2000      	movs	r0, #0
   2433e:	e7f0      	b.n	24322 <tls_interface_setopt+0xc2>
   24340:	ea5f 0c96 	movs.w	ip, r6, lsr #2
   24344:	d01f      	beq.n	24386 <tls_interface_setopt+0x126>
   24346:	f016 0403 	ands.w	r4, r6, #3
   2434a:	d11c      	bne.n	24386 <tls_interface_setopt+0x126>
   2434c:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
   24350:	00ad      	lsls	r5, r5, #2
   24352:	4b14      	ldr	r3, [pc, #80]	; (243a4 <tls_interface_setopt+0x144>)
   24354:	1d28      	adds	r0, r5, #4
   24356:	4418      	add	r0, r3
   24358:	442b      	add	r3, r5
   2435a:	4632      	mov	r2, r6
   2435c:	4639      	mov	r1, r7
   2435e:	f883 c003 	strb.w	ip, [r3, #3]
   24362:	f014 fe39 	bl	38fd8 <memcpy>
   24366:	4620      	mov	r0, r4
   24368:	e7db      	b.n	24322 <tls_interface_setopt+0xc2>
   2436a:	2102      	movs	r1, #2
   2436c:	4a0d      	ldr	r2, [pc, #52]	; (243a4 <tls_interface_setopt+0x144>)
   2436e:	eb05 04c5 	add.w	r4, r5, r5, lsl #3
   24372:	f802 1024 	strb.w	r1, [r2, r4, lsl #2]
   24376:	e7d4      	b.n	24322 <tls_interface_setopt+0xc2>
   24378:	2009      	movs	r0, #9
   2437a:	f7fb fe71 	bl	20060 <bsd_os_errno_set>
   2437e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24382:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24386:	2016      	movs	r0, #22
   24388:	e7f7      	b.n	2437a <tls_interface_setopt+0x11a>
   2438a:	200c      	movs	r0, #12
   2438c:	e7f5      	b.n	2437a <tls_interface_setopt+0x11a>
   2438e:	200e      	movs	r0, #14
   24390:	f7fb fe66 	bl	20060 <bsd_os_errno_set>
   24394:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24398:	e7c3      	b.n	24322 <tls_interface_setopt+0xc2>
   2439a:	202a      	movs	r0, #42	; 0x2a
   2439c:	e7ed      	b.n	2437a <tls_interface_setopt+0x11a>
   2439e:	bf00      	nop
   243a0:	2002268c 	.word	0x2002268c
   243a4:	20022548 	.word	0x20022548

000243a8 <tls_interface_getopt>:
   243a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   243ac:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
   243b0:	9f06      	ldr	r7, [sp, #24]
   243b2:	d112      	bne.n	243da <tls_interface_getopt+0x32>
   243b4:	461d      	mov	r5, r3
   243b6:	b16b      	cbz	r3, 243d4 <tls_interface_getopt+0x2c>
   243b8:	b167      	cbz	r7, 243d4 <tls_interface_getopt+0x2c>
   243ba:	4606      	mov	r6, r0
   243bc:	4614      	mov	r4, r2
   243be:	f006 fa13 	bl	2a7e8 <interface_socket_from_handle_get>
   243c2:	2800      	cmp	r0, #0
   243c4:	d04f      	beq.n	24466 <tls_interface_getopt+0xbe>
   243c6:	3c01      	subs	r4, #1
   243c8:	2c03      	cmp	r4, #3
   243ca:	d852      	bhi.n	24472 <tls_interface_getopt+0xca>
   243cc:	e8df f004 	tbb	[pc, r4]
   243d0:	09152139 	.word	0x09152139
   243d4:	200e      	movs	r0, #14
   243d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   243da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   243de:	f001 ba0f 	b.w	25800 <ip_interface_getopt>
   243e2:	683b      	ldr	r3, [r7, #0]
   243e4:	2b04      	cmp	r3, #4
   243e6:	d13c      	bne.n	24462 <tls_interface_getopt+0xba>
   243e8:	4b23      	ldr	r3, [pc, #140]	; (24478 <tls_interface_getopt+0xd0>)
   243ea:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   243ee:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   243f2:	78b3      	ldrb	r3, [r6, #2]
   243f4:	2000      	movs	r0, #0
   243f6:	602b      	str	r3, [r5, #0]
   243f8:	e7ed      	b.n	243d6 <tls_interface_getopt+0x2e>
   243fa:	683b      	ldr	r3, [r7, #0]
   243fc:	2b01      	cmp	r3, #1
   243fe:	d130      	bne.n	24462 <tls_interface_getopt+0xba>
   24400:	4b1d      	ldr	r3, [pc, #116]	; (24478 <tls_interface_getopt+0xd0>)
   24402:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   24406:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   2440a:	7873      	ldrb	r3, [r6, #1]
   2440c:	2000      	movs	r0, #0
   2440e:	702b      	strb	r3, [r5, #0]
   24410:	e7e1      	b.n	243d6 <tls_interface_getopt+0x2e>
   24412:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   24416:	4918      	ldr	r1, [pc, #96]	; (24478 <tls_interface_getopt+0xd0>)
   24418:	683b      	ldr	r3, [r7, #0]
   2441a:	00b6      	lsls	r6, r6, #2
   2441c:	198a      	adds	r2, r1, r6
   2441e:	f013 0403 	ands.w	r4, r3, #3
   24422:	78d0      	ldrb	r0, [r2, #3]
   24424:	d121      	bne.n	2446a <tls_interface_getopt+0xc2>
   24426:	089b      	lsrs	r3, r3, #2
   24428:	4283      	cmp	r3, r0
   2442a:	bf28      	it	cs
   2442c:	4603      	movcs	r3, r0
   2442e:	009a      	lsls	r2, r3, #2
   24430:	b1db      	cbz	r3, 2446a <tls_interface_getopt+0xc2>
   24432:	3604      	adds	r6, #4
   24434:	4431      	add	r1, r6
   24436:	603a      	str	r2, [r7, #0]
   24438:	4628      	mov	r0, r5
   2443a:	f014 fdcd 	bl	38fd8 <memcpy>
   2443e:	4620      	mov	r0, r4
   24440:	e7c9      	b.n	243d6 <tls_interface_getopt+0x2e>
   24442:	683b      	ldr	r3, [r7, #0]
   24444:	2b04      	cmp	r3, #4
   24446:	d10c      	bne.n	24462 <tls_interface_getopt+0xba>
   24448:	4b0b      	ldr	r3, [pc, #44]	; (24478 <tls_interface_getopt+0xd0>)
   2444a:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
   2444e:	f813 3026 	ldrb.w	r3, [r3, r6, lsl #2]
   24452:	2000      	movs	r0, #0
   24454:	f1a3 0301 	sub.w	r3, r3, #1
   24458:	fab3 f383 	clz	r3, r3
   2445c:	095b      	lsrs	r3, r3, #5
   2445e:	602b      	str	r3, [r5, #0]
   24460:	e7b9      	b.n	243d6 <tls_interface_getopt+0x2e>
   24462:	2016      	movs	r0, #22
   24464:	e7b7      	b.n	243d6 <tls_interface_getopt+0x2e>
   24466:	2009      	movs	r0, #9
   24468:	e7b5      	b.n	243d6 <tls_interface_getopt+0x2e>
   2446a:	2800      	cmp	r0, #0
   2446c:	d1f9      	bne.n	24462 <tls_interface_getopt+0xba>
   2446e:	6038      	str	r0, [r7, #0]
   24470:	e7b1      	b.n	243d6 <tls_interface_getopt+0x2e>
   24472:	202a      	movs	r0, #42	; 0x2a
   24474:	e7af      	b.n	243d6 <tls_interface_getopt+0x2e>
   24476:	bf00      	nop
   24478:	20022548 	.word	0x20022548

0002447c <tls_rpc_ip_event_handler>:
   2447c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2447e:	f248 0581 	movw	r5, #32897	; 0x8081
   24482:	42ab      	cmp	r3, r5
   24484:	460c      	mov	r4, r1
   24486:	d062      	beq.n	2454e <tls_rpc_ip_event_handler+0xd2>
   24488:	f249 0182 	movw	r1, #36994	; 0x9082
   2448c:	428b      	cmp	r3, r1
   2448e:	4606      	mov	r6, r0
   24490:	d02e      	beq.n	244f0 <tls_rpc_ip_event_handler+0x74>
   24492:	f248 0102 	movw	r1, #32770	; 0x8002
   24496:	428b      	cmp	r3, r1
   24498:	d001      	beq.n	2449e <tls_rpc_ip_event_handler+0x22>
   2449a:	2001      	movs	r0, #1
   2449c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2449e:	2c00      	cmp	r4, #0
   244a0:	d0fb      	beq.n	2449a <tls_rpc_ip_event_handler+0x1e>
   244a2:	6963      	ldr	r3, [r4, #20]
   244a4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   244a8:	d002      	beq.n	244b0 <tls_rpc_ip_event_handler+0x34>
   244aa:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   244ae:	d1f4      	bne.n	2449a <tls_rpc_ip_event_handler+0x1e>
   244b0:	6823      	ldr	r3, [r4, #0]
   244b2:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   244b6:	6023      	str	r3, [r4, #0]
   244b8:	6955      	ldr	r5, [r2, #20]
   244ba:	2d00      	cmp	r5, #0
   244bc:	d156      	bne.n	2456c <tls_rpc_ip_event_handler+0xf0>
   244be:	6823      	ldr	r3, [r4, #0]
   244c0:	0c1b      	lsrs	r3, r3, #16
   244c2:	041b      	lsls	r3, r3, #16
   244c4:	f043 0305 	orr.w	r3, r3, #5
   244c8:	6023      	str	r3, [r4, #0]
   244ca:	6823      	ldr	r3, [r4, #0]
   244cc:	00da      	lsls	r2, r3, #3
   244ce:	d50d      	bpl.n	244ec <tls_rpc_ip_event_handler+0x70>
   244d0:	4b2b      	ldr	r3, [pc, #172]	; (24580 <tls_rpc_ip_event_handler+0x104>)
   244d2:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
   244d6:	f813 3022 	ldrb.w	r3, [r3, r2, lsl #2]
   244da:	2b02      	cmp	r3, #2
   244dc:	d106      	bne.n	244ec <tls_rpc_ip_event_handler+0x70>
   244de:	4630      	mov	r0, r6
   244e0:	4621      	mov	r1, r4
   244e2:	f7ff fb81 	bl	23be8 <secure_client_socket>
   244e6:	b108      	cbz	r0, 244ec <tls_rpc_ip_event_handler+0x70>
   244e8:	2873      	cmp	r0, #115	; 0x73
   244ea:	d142      	bne.n	24572 <tls_rpc_ip_event_handler+0xf6>
   244ec:	2000      	movs	r0, #0
   244ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   244f0:	2c00      	cmp	r4, #0
   244f2:	d0fb      	beq.n	244ec <tls_rpc_ip_event_handler+0x70>
   244f4:	6823      	ldr	r3, [r4, #0]
   244f6:	b29b      	uxth	r3, r3
   244f8:	2b0b      	cmp	r3, #11
   244fa:	d1f7      	bne.n	244ec <tls_rpc_ip_event_handler+0x70>
   244fc:	6915      	ldr	r5, [r2, #16]
   244fe:	2d00      	cmp	r5, #0
   24500:	d134      	bne.n	2456c <tls_rpc_ip_event_handler+0xf0>
   24502:	6823      	ldr	r3, [r4, #0]
   24504:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   24508:	6023      	str	r3, [r4, #0]
   2450a:	6823      	ldr	r3, [r4, #0]
   2450c:	00db      	lsls	r3, r3, #3
   2450e:	d5ed      	bpl.n	244ec <tls_rpc_ip_event_handler+0x70>
   24510:	4f1c      	ldr	r7, [pc, #112]	; (24584 <tls_rpc_ip_event_handler+0x108>)
   24512:	f857 0030 	ldr.w	r0, [r7, r0, lsl #3]
   24516:	b130      	cbz	r0, 24526 <tls_rpc_ip_event_handler+0xaa>
   24518:	f005 fd18 	bl	29f4c <nrf_free>
   2451c:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
   24520:	f847 5036 	str.w	r5, [r7, r6, lsl #3]
   24524:	605d      	str	r5, [r3, #4]
   24526:	6823      	ldr	r3, [r4, #0]
   24528:	2000      	movs	r0, #0
   2452a:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
   2452e:	6023      	str	r3, [r4, #0]
   24530:	6823      	ldr	r3, [r4, #0]
   24532:	0c1b      	lsrs	r3, r3, #16
   24534:	041b      	lsls	r3, r3, #16
   24536:	f043 030c 	orr.w	r3, r3, #12
   2453a:	6023      	str	r3, [r4, #0]
   2453c:	6823      	ldr	r3, [r4, #0]
   2453e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   24542:	6023      	str	r3, [r4, #0]
   24544:	6823      	ldr	r3, [r4, #0]
   24546:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   2454a:	6023      	str	r3, [r4, #0]
   2454c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2454e:	2900      	cmp	r1, #0
   24550:	d0cc      	beq.n	244ec <tls_rpc_ip_event_handler+0x70>
   24552:	680b      	ldr	r3, [r1, #0]
   24554:	b29b      	uxth	r3, r3
   24556:	2b0a      	cmp	r3, #10
   24558:	d1c8      	bne.n	244ec <tls_rpc_ip_event_handler+0x70>
   2455a:	6950      	ldr	r0, [r2, #20]
   2455c:	b938      	cbnz	r0, 2456e <tls_rpc_ip_event_handler+0xf2>
   2455e:	680b      	ldr	r3, [r1, #0]
   24560:	0c1b      	lsrs	r3, r3, #16
   24562:	041b      	lsls	r3, r3, #16
   24564:	f043 030b 	orr.w	r3, r3, #11
   24568:	600b      	str	r3, [r1, #0]
   2456a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2456c:	4628      	mov	r0, r5
   2456e:	f000 f8e1 	bl	24734 <rpc_error_to_nrf_bsd_error>
   24572:	6060      	str	r0, [r4, #4]
   24574:	6823      	ldr	r3, [r4, #0]
   24576:	2000      	movs	r0, #0
   24578:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   2457c:	6023      	str	r3, [r4, #0]
   2457e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   24580:	20022548 	.word	0x20022548
   24584:	2002268c 	.word	0x2002268c

00024588 <ip_client_event_handler>:
   24588:	f850 1b08 	ldr.w	r1, [r0], #8
   2458c:	0c09      	lsrs	r1, r1, #16
   2458e:	f001 bc29 	b.w	25de4 <rpc_ip_event_handler>
   24592:	bf00      	nop

00024594 <rpc_ip_client_init>:
   24594:	4801      	ldr	r0, [pc, #4]	; (2459c <rpc_ip_client_init+0x8>)
   24596:	f001 bf27 	b.w	263e8 <rpc_client_register>
   2459a:	bf00      	nop
   2459c:	0003a938 	.word	0x0003a938

000245a0 <rpc_ip_client_request_alloc>:
   245a0:	2300      	movs	r3, #0
   245a2:	b510      	push	{r4, lr}
   245a4:	b082      	sub	sp, #8
   245a6:	9301      	str	r3, [sp, #4]
   245a8:	b158      	cbz	r0, 245c2 <rpc_ip_client_request_alloc+0x22>
   245aa:	4604      	mov	r4, r0
   245ac:	aa01      	add	r2, sp, #4
   245ae:	2004      	movs	r0, #4
   245b0:	f001 ff94 	bl	264dc <rpc_message_alloc>
   245b4:	b918      	cbnz	r0, 245be <rpc_ip_client_request_alloc+0x1e>
   245b6:	9b01      	ldr	r3, [sp, #4]
   245b8:	b10b      	cbz	r3, 245be <rpc_ip_client_request_alloc+0x1e>
   245ba:	3308      	adds	r3, #8
   245bc:	6023      	str	r3, [r4, #0]
   245be:	b002      	add	sp, #8
   245c0:	bd10      	pop	{r4, pc}
   245c2:	2007      	movs	r0, #7
   245c4:	b002      	add	sp, #8
   245c6:	bd10      	pop	{r4, pc}

000245c8 <rpc_ip_client_request_send>:
   245c8:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   245cc:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   245d0:	d10b      	bne.n	245ea <rpc_ip_client_request_send+0x22>
   245d2:	b160      	cbz	r0, 245ee <rpc_ip_client_request_send+0x26>
   245d4:	4603      	mov	r3, r0
   245d6:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   245da:	2004      	movs	r0, #4
   245dc:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   245e0:	f843 1d08 	str.w	r1, [r3, #-8]!
   245e4:	4619      	mov	r1, r3
   245e6:	f001 bf69 	b.w	264bc <rpc_message_send>
   245ea:	200f      	movs	r0, #15
   245ec:	4770      	bx	lr
   245ee:	2007      	movs	r0, #7
   245f0:	4770      	bx	lr
   245f2:	bf00      	nop

000245f4 <rpc_ip_client_message_free>:
   245f4:	b120      	cbz	r0, 24600 <rpc_ip_client_message_free+0xc>
   245f6:	f1a0 0108 	sub.w	r1, r0, #8
   245fa:	2004      	movs	r0, #4
   245fc:	f001 bf9a 	b.w	26534 <rpc_message_free>
   24600:	2007      	movs	r0, #7
   24602:	4770      	bx	lr

00024604 <rpc_ip_client_data_free>:
   24604:	b118      	cbz	r0, 2460e <rpc_ip_client_data_free+0xa>
   24606:	4601      	mov	r1, r0
   24608:	2004      	movs	r0, #4
   2460a:	f001 bf9f 	b.w	2654c <rpc_message_data_free>
   2460e:	2007      	movs	r0, #7
   24610:	4770      	bx	lr
   24612:	bf00      	nop

00024614 <ip_recvd_packet_free_cb>:
   24614:	b510      	push	{r4, lr}
   24616:	4604      	mov	r4, r0
   24618:	6800      	ldr	r0, [r0, #0]
   2461a:	f7ff fff3 	bl	24604 <rpc_ip_client_data_free>
   2461e:	68a0      	ldr	r0, [r4, #8]
   24620:	b118      	cbz	r0, 2462a <ip_recvd_packet_free_cb+0x16>
   24622:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   24626:	f005 bc91 	b.w	29f4c <nrf_free>
   2462a:	bd10      	pop	{r4, pc}

0002462c <setopt_check_and_send_int>:
   2462c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24630:	b082      	sub	sp, #8
   24632:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
   24634:	2d04      	cmp	r5, #4
   24636:	d15e      	bne.n	246f6 <setopt_check_and_send_int+0xca>
   24638:	461e      	mov	r6, r3
   2463a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2463c:	2b00      	cmp	r3, #0
   2463e:	d05a      	beq.n	246f6 <setopt_check_and_send_int+0xca>
   24640:	4614      	mov	r4, r2
   24642:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   24646:	6823      	ldr	r3, [r4, #0]
   24648:	9200      	str	r2, [sp, #0]
   2464a:	025f      	lsls	r7, r3, #9
   2464c:	d444      	bmi.n	246d8 <setopt_check_and_send_int+0xac>
   2464e:	6823      	ldr	r3, [r4, #0]
   24650:	021a      	lsls	r2, r3, #8
   24652:	d441      	bmi.n	246d8 <setopt_check_and_send_int+0xac>
   24654:	6823      	ldr	r3, [r4, #0]
   24656:	01db      	lsls	r3, r3, #7
   24658:	d43e      	bmi.n	246d8 <setopt_check_and_send_int+0xac>
   2465a:	6823      	ldr	r3, [r4, #0]
   2465c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   24660:	d13a      	bne.n	246d8 <setopt_check_and_send_int+0xac>
   24662:	f8d4 9000 	ldr.w	r9, [r4]
   24666:	6822      	ldr	r2, [r4, #0]
   24668:	4680      	mov	r8, r0
   2466a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   2466e:	a802      	add	r0, sp, #8
   24670:	460f      	mov	r7, r1
   24672:	f840 3d04 	str.w	r3, [r0, #-4]!
   24676:	4629      	mov	r1, r5
   24678:	6022      	str	r2, [r4, #0]
   2467a:	f8d4 a018 	ldr.w	sl, [r4, #24]
   2467e:	f7ff ff8f 	bl	245a0 <rpc_ip_client_request_alloc>
   24682:	bb88      	cbnz	r0, 246e8 <setopt_check_and_send_int+0xbc>
   24684:	f247 0303 	movw	r3, #28675	; 0x7003
   24688:	2208      	movs	r2, #8
   2468a:	9d01      	ldr	r5, [sp, #4]
   2468c:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   24690:	60eb      	str	r3, [r5, #12]
   24692:	f8c5 a010 	str.w	sl, [r5, #16]
   24696:	7268      	strb	r0, [r5, #9]
   24698:	72a8      	strb	r0, [r5, #10]
   2469a:	72e8      	strb	r0, [r5, #11]
   2469c:	722a      	strb	r2, [r5, #8]
   2469e:	68ab      	ldr	r3, [r5, #8]
   246a0:	61af      	str	r7, [r5, #24]
   246a2:	3308      	adds	r3, #8
   246a4:	60ab      	str	r3, [r5, #8]
   246a6:	2204      	movs	r2, #4
   246a8:	990a      	ldr	r1, [sp, #40]	; 0x28
   246aa:	f8c5 8014 	str.w	r8, [r5, #20]
   246ae:	6828      	ldr	r0, [r5, #0]
   246b0:	f014 fc92 	bl	38fd8 <memcpy>
   246b4:	f247 0103 	movw	r1, #28675	; 0x7003
   246b8:	4628      	mov	r0, r5
   246ba:	f7ff ff85 	bl	245c8 <rpc_ip_client_request_send>
   246be:	4607      	mov	r7, r0
   246c0:	b9d8      	cbnz	r0, 246fa <setopt_check_and_send_int+0xce>
   246c2:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   246c6:	466b      	mov	r3, sp
   246c8:	4611      	mov	r1, r2
   246ca:	4630      	mov	r0, r6
   246cc:	f006 f818 	bl	2a700 <interface_socket_wait>
   246d0:	b300      	cbz	r0, 24714 <setopt_check_and_send_int+0xe8>
   246d2:	f8c4 9000 	str.w	r9, [r4]
   246d6:	e000      	b.n	246da <setopt_check_and_send_int+0xae>
   246d8:	2023      	movs	r0, #35	; 0x23
   246da:	f7fb fcc1 	bl	20060 <bsd_os_errno_set>
   246de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   246e2:	b002      	add	sp, #8
   246e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   246e8:	9d01      	ldr	r5, [sp, #4]
   246ea:	2d00      	cmp	r5, #0
   246ec:	d1d7      	bne.n	2469e <setopt_check_and_send_int+0x72>
   246ee:	f8c4 9000 	str.w	r9, [r4]
   246f2:	200c      	movs	r0, #12
   246f4:	e7f1      	b.n	246da <setopt_check_and_send_int+0xae>
   246f6:	2016      	movs	r0, #22
   246f8:	e7ef      	b.n	246da <setopt_check_and_send_int+0xae>
   246fa:	6828      	ldr	r0, [r5, #0]
   246fc:	b108      	cbz	r0, 24702 <setopt_check_and_send_int+0xd6>
   246fe:	f7ff ff81 	bl	24604 <rpc_ip_client_data_free>
   24702:	4628      	mov	r0, r5
   24704:	f7ff ff76 	bl	245f4 <rpc_ip_client_message_free>
   24708:	f8c4 9000 	str.w	r9, [r4]
   2470c:	2023      	movs	r0, #35	; 0x23
   2470e:	f8c4 9000 	str.w	r9, [r4]
   24712:	e7e2      	b.n	246da <setopt_check_and_send_int+0xae>
   24714:	4630      	mov	r0, r6
   24716:	f006 f867 	bl	2a7e8 <interface_socket_from_handle_get>
   2471a:	4603      	mov	r3, r0
   2471c:	b130      	cbz	r0, 2472c <setopt_check_and_send_int+0x100>
   2471e:	6840      	ldr	r0, [r0, #4]
   24720:	b108      	cbz	r0, 24726 <setopt_check_and_send_int+0xfa>
   24722:	605f      	str	r7, [r3, #4]
   24724:	e7d5      	b.n	246d2 <setopt_check_and_send_int+0xa6>
   24726:	f8c4 9000 	str.w	r9, [r4]
   2472a:	e7da      	b.n	246e2 <setopt_check_and_send_int+0xb6>
   2472c:	f8c4 9000 	str.w	r9, [r4]
   24730:	e7d7      	b.n	246e2 <setopt_check_and_send_int+0xb6>
   24732:	bf00      	nop

00024734 <rpc_error_to_nrf_bsd_error>:
   24734:	2810      	cmp	r0, #16
   24736:	bf9a      	itte	ls
   24738:	4b02      	ldrls	r3, [pc, #8]	; (24744 <rpc_error_to_nrf_bsd_error+0x10>)
   2473a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   2473e:	202d      	movhi	r0, #45	; 0x2d
   24740:	4770      	bx	lr
   24742:	bf00      	nop
   24744:	0003a948 	.word	0x0003a948

00024748 <ip_interface_request_create>:
   24748:	b570      	push	{r4, r5, r6, lr}
   2474a:	2500      	movs	r5, #0
   2474c:	b082      	sub	sp, #8
   2474e:	ac02      	add	r4, sp, #8
   24750:	f844 5d04 	str.w	r5, [r4, #-4]!
   24754:	4606      	mov	r6, r0
   24756:	460d      	mov	r5, r1
   24758:	4620      	mov	r0, r4
   2475a:	4619      	mov	r1, r3
   2475c:	4614      	mov	r4, r2
   2475e:	f7ff ff1f 	bl	245a0 <rpc_ip_client_request_alloc>
   24762:	b960      	cbnz	r0, 2477e <ip_interface_request_create+0x36>
   24764:	9b01      	ldr	r3, [sp, #4]
   24766:	2208      	movs	r2, #8
   24768:	7258      	strb	r0, [r3, #9]
   2476a:	7298      	strb	r0, [r3, #10]
   2476c:	72d8      	strb	r0, [r3, #11]
   2476e:	4618      	mov	r0, r3
   24770:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
   24774:	60dc      	str	r4, [r3, #12]
   24776:	611d      	str	r5, [r3, #16]
   24778:	721a      	strb	r2, [r3, #8]
   2477a:	b002      	add	sp, #8
   2477c:	bd70      	pop	{r4, r5, r6, pc}
   2477e:	9b01      	ldr	r3, [sp, #4]
   24780:	4618      	mov	r0, r3
   24782:	b002      	add	sp, #8
   24784:	bd70      	pop	{r4, r5, r6, pc}
   24786:	bf00      	nop

00024788 <ip_interface_request_send>:
   24788:	b570      	push	{r4, r5, r6, lr}
   2478a:	460c      	mov	r4, r1
   2478c:	4605      	mov	r5, r0
   2478e:	4611      	mov	r1, r2
   24790:	4620      	mov	r0, r4
   24792:	461e      	mov	r6, r3
   24794:	f7ff ff18 	bl	245c8 <rpc_ip_client_request_send>
   24798:	b900      	cbnz	r0, 2479c <ip_interface_request_send+0x14>
   2479a:	bd70      	pop	{r4, r5, r6, pc}
   2479c:	6820      	ldr	r0, [r4, #0]
   2479e:	b108      	cbz	r0, 247a4 <ip_interface_request_send+0x1c>
   247a0:	f7ff ff30 	bl	24604 <rpc_ip_client_data_free>
   247a4:	4620      	mov	r0, r4
   247a6:	f7ff ff25 	bl	245f4 <rpc_ip_client_message_free>
   247aa:	602e      	str	r6, [r5, #0]
   247ac:	2023      	movs	r0, #35	; 0x23
   247ae:	bd70      	pop	{r4, r5, r6, pc}

000247b0 <ip_interface_wait>:
   247b0:	b538      	push	{r3, r4, r5, lr}
   247b2:	4605      	mov	r5, r0
   247b4:	f005 ffa4 	bl	2a700 <interface_socket_wait>
   247b8:	4604      	mov	r4, r0
   247ba:	b108      	cbz	r0, 247c0 <ip_interface_wait+0x10>
   247bc:	4620      	mov	r0, r4
   247be:	bd38      	pop	{r3, r4, r5, pc}
   247c0:	4628      	mov	r0, r5
   247c2:	f006 f811 	bl	2a7e8 <interface_socket_from_handle_get>
   247c6:	2800      	cmp	r0, #0
   247c8:	d0f8      	beq.n	247bc <ip_interface_wait+0xc>
   247ca:	6844      	ldr	r4, [r0, #4]
   247cc:	2c00      	cmp	r4, #0
   247ce:	d0f5      	beq.n	247bc <ip_interface_wait+0xc>
   247d0:	2300      	movs	r3, #0
   247d2:	6043      	str	r3, [r0, #4]
   247d4:	4620      	mov	r0, r4
   247d6:	bd38      	pop	{r3, r4, r5, pc}

000247d8 <ip_interface_init>:
   247d8:	b538      	push	{r3, r4, r5, lr}
   247da:	2300      	movs	r3, #0
   247dc:	4d09      	ldr	r5, [pc, #36]	; (24804 <ip_interface_init+0x2c>)
   247de:	4c0a      	ldr	r4, [pc, #40]	; (24808 <ip_interface_init+0x30>)
   247e0:	4619      	mov	r1, r3
   247e2:	2224      	movs	r2, #36	; 0x24
   247e4:	4809      	ldr	r0, [pc, #36]	; (2480c <ip_interface_init+0x34>)
   247e6:	602b      	str	r3, [r5, #0]
   247e8:	6023      	str	r3, [r4, #0]
   247ea:	f014 fc2f 	bl	3904c <memset>
   247ee:	f7ff fed1 	bl	24594 <rpc_ip_client_init>
   247f2:	b918      	cbnz	r0, 247fc <ip_interface_init+0x24>
   247f4:	2201      	movs	r2, #1
   247f6:	4b06      	ldr	r3, [pc, #24]	; (24810 <ip_interface_init+0x38>)
   247f8:	701a      	strb	r2, [r3, #0]
   247fa:	bd38      	pop	{r3, r4, r5, pc}
   247fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24800:	bd38      	pop	{r3, r4, r5, pc}
   24802:	bf00      	nop
   24804:	200226dc 	.word	0x200226dc
   24808:	200226d8 	.word	0x200226d8
   2480c:	200226e0 	.word	0x200226e0
   24810:	20029086 	.word	0x20029086

00024814 <ip_interface_open>:
   24814:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   24818:	2500      	movs	r5, #0
   2481a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2481e:	4c5e      	ldr	r4, [pc, #376]	; (24998 <ip_interface_open+0x184>)
   24820:	4606      	mov	r6, r0
   24822:	7820      	ldrb	r0, [r4, #0]
   24824:	b084      	sub	sp, #16
   24826:	e9cd 5701 	strd	r5, r7, [sp, #4]
   2482a:	2800      	cmp	r0, #0
   2482c:	f000 80b0 	beq.w	24990 <ip_interface_open+0x17c>
   24830:	4690      	mov	r8, r2
   24832:	f026 0208 	bic.w	r2, r6, #8
   24836:	2a02      	cmp	r2, #2
   24838:	460c      	mov	r4, r1
   2483a:	d002      	beq.n	24842 <ip_interface_open+0x2e>
   2483c:	2e05      	cmp	r6, #5
   2483e:	f040 808d 	bne.w	2495c <ip_interface_open+0x148>
   24842:	1e63      	subs	r3, r4, #1
   24844:	2b02      	cmp	r3, #2
   24846:	f200 809d 	bhi.w	24984 <ip_interface_open+0x170>
   2484a:	f1b8 0f00 	cmp.w	r8, #0
   2484e:	d159      	bne.n	24904 <ip_interface_open+0xf0>
   24850:	2c01      	cmp	r4, #1
   24852:	d06f      	beq.n	24934 <ip_interface_open+0x120>
   24854:	2c03      	cmp	r4, #3
   24856:	bf18      	it	ne
   24858:	f04f 0802 	movne.w	r8, #2
   2485c:	4a4f      	ldr	r2, [pc, #316]	; (2499c <ip_interface_open+0x188>)
   2485e:	4621      	mov	r1, r4
   24860:	a801      	add	r0, sp, #4
   24862:	f005 fe9b 	bl	2a59c <interface_socket_allocate>
   24866:	9b01      	ldr	r3, [sp, #4]
   24868:	4607      	mov	r7, r0
   2486a:	2b00      	cmp	r3, #0
   2486c:	d060      	beq.n	24930 <ip_interface_open+0x11c>
   2486e:	2100      	movs	r1, #0
   24870:	a804      	add	r0, sp, #16
   24872:	f840 1d04 	str.w	r1, [r0, #-4]!
   24876:	e9c3 6403 	strd	r6, r4, [r3, #12]
   2487a:	f8c3 8014 	str.w	r8, [r3, #20]
   2487e:	f7ff fe8f 	bl	245a0 <rpc_ip_client_request_alloc>
   24882:	2800      	cmp	r0, #0
   24884:	d151      	bne.n	2492a <ip_interface_open+0x116>
   24886:	f247 0201 	movw	r2, #28673	; 0x7001
   2488a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2488e:	2108      	movs	r1, #8
   24890:	9d03      	ldr	r5, [sp, #12]
   24892:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
   24896:	60ea      	str	r2, [r5, #12]
   24898:	7268      	strb	r0, [r5, #9]
   2489a:	72a8      	strb	r0, [r5, #10]
   2489c:	72e8      	strb	r0, [r5, #11]
   2489e:	7229      	strb	r1, [r5, #8]
   248a0:	742b      	strb	r3, [r5, #16]
   248a2:	746b      	strb	r3, [r5, #17]
   248a4:	74ab      	strb	r3, [r5, #18]
   248a6:	74eb      	strb	r3, [r5, #19]
   248a8:	68ab      	ldr	r3, [r5, #8]
   248aa:	2e05      	cmp	r6, #5
   248ac:	f103 030c 	add.w	r3, r3, #12
   248b0:	60ab      	str	r3, [r5, #8]
   248b2:	d003      	beq.n	248bc <ip_interface_open+0xa8>
   248b4:	2e0a      	cmp	r6, #10
   248b6:	bf14      	ite	ne
   248b8:	2601      	movne	r6, #1
   248ba:	2602      	moveq	r6, #2
   248bc:	616e      	str	r6, [r5, #20]
   248be:	f8c5 801c 	str.w	r8, [r5, #28]
   248c2:	61ac      	str	r4, [r5, #24]
   248c4:	f247 0101 	movw	r1, #28673	; 0x7001
   248c8:	4628      	mov	r0, r5
   248ca:	f8dd 8004 	ldr.w	r8, [sp, #4]
   248ce:	f7ff fe7b 	bl	245c8 <rpc_ip_client_request_send>
   248d2:	4606      	mov	r6, r0
   248d4:	b380      	cbz	r0, 24938 <ip_interface_open+0x124>
   248d6:	6828      	ldr	r0, [r5, #0]
   248d8:	b108      	cbz	r0, 248de <ip_interface_open+0xca>
   248da:	f7ff fe93 	bl	24604 <rpc_ip_client_data_free>
   248de:	4628      	mov	r0, r5
   248e0:	f7ff fe88 	bl	245f4 <rpc_ip_client_message_free>
   248e4:	2301      	movs	r3, #1
   248e6:	2523      	movs	r5, #35	; 0x23
   248e8:	f8c8 3000 	str.w	r3, [r8]
   248ec:	4638      	mov	r0, r7
   248ee:	f005 feb9 	bl	2a664 <interface_socket_free>
   248f2:	4628      	mov	r0, r5
   248f4:	f7fb fbb4 	bl	20060 <bsd_os_errno_set>
   248f8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   248fc:	4638      	mov	r0, r7
   248fe:	b004      	add	sp, #16
   24900:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24904:	2c01      	cmp	r4, #1
   24906:	d00a      	beq.n	2491e <ip_interface_open+0x10a>
   24908:	2c02      	cmp	r4, #2
   2490a:	d10b      	bne.n	24924 <ip_interface_open+0x110>
   2490c:	f1b8 0f02 	cmp.w	r8, #2
   24910:	d0a4      	beq.n	2485c <ip_interface_open+0x48>
   24912:	2029      	movs	r0, #41	; 0x29
   24914:	f7fb fba4 	bl	20060 <bsd_os_errno_set>
   24918:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2491c:	e7ee      	b.n	248fc <ip_interface_open+0xe8>
   2491e:	f1b8 0f01 	cmp.w	r8, #1
   24922:	d1f6      	bne.n	24912 <ip_interface_open+0xfe>
   24924:	f04f 0802 	mov.w	r8, #2
   24928:	e798      	b.n	2485c <ip_interface_open+0x48>
   2492a:	9d03      	ldr	r5, [sp, #12]
   2492c:	2d00      	cmp	r5, #0
   2492e:	d1bb      	bne.n	248a8 <ip_interface_open+0x94>
   24930:	2569      	movs	r5, #105	; 0x69
   24932:	e7db      	b.n	248ec <ip_interface_open+0xd8>
   24934:	46a0      	mov	r8, r4
   24936:	e791      	b.n	2485c <ip_interface_open+0x48>
   24938:	ab02      	add	r3, sp, #8
   2493a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2493e:	2102      	movs	r1, #2
   24940:	4638      	mov	r0, r7
   24942:	f005 fedd 	bl	2a700 <interface_socket_wait>
   24946:	4605      	mov	r5, r0
   24948:	2800      	cmp	r0, #0
   2494a:	d1cf      	bne.n	248ec <ip_interface_open+0xd8>
   2494c:	4638      	mov	r0, r7
   2494e:	f005 ff4b 	bl	2a7e8 <interface_socket_from_handle_get>
   24952:	b138      	cbz	r0, 24964 <ip_interface_open+0x150>
   24954:	6845      	ldr	r5, [r0, #4]
   24956:	b12d      	cbz	r5, 24964 <ip_interface_open+0x150>
   24958:	6046      	str	r6, [r0, #4]
   2495a:	e7c7      	b.n	248ec <ip_interface_open+0xd8>
   2495c:	202f      	movs	r0, #47	; 0x2f
   2495e:	f7fb fb7f 	bl	20060 <bsd_os_errno_set>
   24962:	e7cb      	b.n	248fc <ip_interface_open+0xe8>
   24964:	3c02      	subs	r4, #2
   24966:	2c01      	cmp	r4, #1
   24968:	d8c8      	bhi.n	248fc <ip_interface_open+0xe8>
   2496a:	4638      	mov	r0, r7
   2496c:	9b01      	ldr	r3, [sp, #4]
   2496e:	681a      	ldr	r2, [r3, #0]
   24970:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   24974:	601a      	str	r2, [r3, #0]
   24976:	681a      	ldr	r2, [r3, #0]
   24978:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
   2497c:	601a      	str	r2, [r3, #0]
   2497e:	b004      	add	sp, #16
   24980:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24984:	2016      	movs	r0, #22
   24986:	f7fb fb6b 	bl	20060 <bsd_os_errno_set>
   2498a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2498e:	e7b5      	b.n	248fc <ip_interface_open+0xe8>
   24990:	2070      	movs	r0, #112	; 0x70
   24992:	f7fb fb65 	bl	20060 <bsd_os_errno_set>
   24996:	e7b1      	b.n	248fc <ip_interface_open+0xe8>
   24998:	20029086 	.word	0x20029086
   2499c:	00024615 	.word	0x00024615

000249a0 <ip_interface_close>:
   249a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   249a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   249a8:	b082      	sub	sp, #8
   249aa:	4606      	mov	r6, r0
   249ac:	9300      	str	r3, [sp, #0]
   249ae:	f005 ff1b 	bl	2a7e8 <interface_socket_from_handle_get>
   249b2:	2800      	cmp	r0, #0
   249b4:	d062      	beq.n	24a7c <ip_interface_close+0xdc>
   249b6:	4604      	mov	r4, r0
   249b8:	2100      	movs	r1, #0
   249ba:	a802      	add	r0, sp, #8
   249bc:	6827      	ldr	r7, [r4, #0]
   249be:	f840 1d04 	str.w	r1, [r0, #-4]!
   249c2:	f8d4 8018 	ldr.w	r8, [r4, #24]
   249c6:	f7ff fdeb 	bl	245a0 <rpc_ip_client_request_alloc>
   249ca:	2800      	cmp	r0, #0
   249cc:	d139      	bne.n	24a42 <ip_interface_close+0xa2>
   249ce:	f247 0309 	movw	r3, #28681	; 0x7009
   249d2:	2208      	movs	r2, #8
   249d4:	9d01      	ldr	r5, [sp, #4]
   249d6:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   249da:	60eb      	str	r3, [r5, #12]
   249dc:	f8c5 8010 	str.w	r8, [r5, #16]
   249e0:	7268      	strb	r0, [r5, #9]
   249e2:	72a8      	strb	r0, [r5, #10]
   249e4:	72e8      	strb	r0, [r5, #11]
   249e6:	722a      	strb	r2, [r5, #8]
   249e8:	6823      	ldr	r3, [r4, #0]
   249ea:	f247 0109 	movw	r1, #28681	; 0x7009
   249ee:	0c1b      	lsrs	r3, r3, #16
   249f0:	041b      	lsls	r3, r3, #16
   249f2:	f043 030d 	orr.w	r3, r3, #13
   249f6:	6023      	str	r3, [r4, #0]
   249f8:	6823      	ldr	r3, [r4, #0]
   249fa:	4628      	mov	r0, r5
   249fc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   24a00:	6023      	str	r3, [r4, #0]
   24a02:	6823      	ldr	r3, [r4, #0]
   24a04:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   24a08:	6023      	str	r3, [r4, #0]
   24a0a:	f7ff fddd 	bl	245c8 <rpc_ip_client_request_send>
   24a0e:	bb38      	cbnz	r0, 24a60 <ip_interface_close+0xc0>
   24a10:	466b      	mov	r3, sp
   24a12:	f64f 72ff 	movw	r2, #65535	; 0xffff
   24a16:	210e      	movs	r1, #14
   24a18:	4630      	mov	r0, r6
   24a1a:	f005 fe71 	bl	2a700 <interface_socket_wait>
   24a1e:	4604      	mov	r4, r0
   24a20:	b1a0      	cbz	r0, 24a4c <ip_interface_close+0xac>
   24a22:	4c17      	ldr	r4, [pc, #92]	; (24a80 <ip_interface_close+0xe0>)
   24a24:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
   24a28:	b120      	cbz	r0, 24a34 <ip_interface_close+0x94>
   24a2a:	f7ff fde3 	bl	245f4 <rpc_ip_client_message_free>
   24a2e:	2300      	movs	r3, #0
   24a30:	f844 3026 	str.w	r3, [r4, r6, lsl #2]
   24a34:	4630      	mov	r0, r6
   24a36:	f005 fe15 	bl	2a664 <interface_socket_free>
   24a3a:	2000      	movs	r0, #0
   24a3c:	b002      	add	sp, #8
   24a3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   24a42:	9d01      	ldr	r5, [sp, #4]
   24a44:	200c      	movs	r0, #12
   24a46:	2d00      	cmp	r5, #0
   24a48:	d1ce      	bne.n	249e8 <ip_interface_close+0x48>
   24a4a:	e012      	b.n	24a72 <ip_interface_close+0xd2>
   24a4c:	4630      	mov	r0, r6
   24a4e:	f005 fecb 	bl	2a7e8 <interface_socket_from_handle_get>
   24a52:	2800      	cmp	r0, #0
   24a54:	d0e5      	beq.n	24a22 <ip_interface_close+0x82>
   24a56:	6843      	ldr	r3, [r0, #4]
   24a58:	2b00      	cmp	r3, #0
   24a5a:	d0e2      	beq.n	24a22 <ip_interface_close+0x82>
   24a5c:	6044      	str	r4, [r0, #4]
   24a5e:	e7e0      	b.n	24a22 <ip_interface_close+0x82>
   24a60:	6828      	ldr	r0, [r5, #0]
   24a62:	b108      	cbz	r0, 24a68 <ip_interface_close+0xc8>
   24a64:	f7ff fdce 	bl	24604 <rpc_ip_client_data_free>
   24a68:	4628      	mov	r0, r5
   24a6a:	f7ff fdc3 	bl	245f4 <rpc_ip_client_message_free>
   24a6e:	2023      	movs	r0, #35	; 0x23
   24a70:	6027      	str	r7, [r4, #0]
   24a72:	f7fb faf5 	bl	20060 <bsd_os_errno_set>
   24a76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   24a7a:	e7df      	b.n	24a3c <ip_interface_close+0x9c>
   24a7c:	2009      	movs	r0, #9
   24a7e:	e7f8      	b.n	24a72 <ip_interface_close+0xd2>
   24a80:	200226e0 	.word	0x200226e0

00024a84 <ip_interface_sendto>:
   24a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24a88:	2400      	movs	r4, #0
   24a8a:	b089      	sub	sp, #36	; 0x24
   24a8c:	9102      	str	r1, [sp, #8]
   24a8e:	4615      	mov	r5, r2
   24a90:	4699      	mov	r9, r3
   24a92:	9406      	str	r4, [sp, #24]
   24a94:	4607      	mov	r7, r0
   24a96:	9e12      	ldr	r6, [sp, #72]	; 0x48
   24a98:	f005 fea6 	bl	2a7e8 <interface_socket_from_handle_get>
   24a9c:	2800      	cmp	r0, #0
   24a9e:	f000 814c 	beq.w	24d3a <ip_interface_sendto+0x2b6>
   24aa2:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
   24aa6:	f300 8139 	bgt.w	24d1c <ip_interface_sendto+0x298>
   24aaa:	6903      	ldr	r3, [r0, #16]
   24aac:	4604      	mov	r4, r0
   24aae:	2b01      	cmp	r3, #1
   24ab0:	f000 80ea 	beq.w	24c88 <ip_interface_sendto+0x204>
   24ab4:	6822      	ldr	r2, [r4, #0]
   24ab6:	0391      	lsls	r1, r2, #14
   24ab8:	d56a      	bpl.n	24b90 <ip_interface_sendto+0x10c>
   24aba:	f1b9 0f00 	cmp.w	r9, #0
   24abe:	f000 80f3 	beq.w	24ca8 <ip_interface_sendto+0x224>
   24ac2:	f019 0f02 	tst.w	r9, #2
   24ac6:	f000 8133 	beq.w	24d30 <ip_interface_sendto+0x2ac>
   24aca:	2300      	movs	r3, #0
   24acc:	9303      	str	r3, [sp, #12]
   24ace:	6a63      	ldr	r3, [r4, #36]	; 0x24
   24ad0:	f247 0806 	movw	r8, #28678	; 0x7006
   24ad4:	2b00      	cmp	r3, #0
   24ad6:	bf08      	it	eq
   24ad8:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   24adc:	f04f 0b0c 	mov.w	fp, #12
   24ae0:	4a9a      	ldr	r2, [pc, #616]	; (24d4c <ip_interface_sendto+0x2c8>)
   24ae2:	9307      	str	r3, [sp, #28]
   24ae4:	043b      	lsls	r3, r7, #16
   24ae6:	9200      	str	r2, [sp, #0]
   24ae8:	9304      	str	r3, [sp, #16]
   24aea:	4629      	mov	r1, r5
   24aec:	a806      	add	r0, sp, #24
   24aee:	f7ff fd57 	bl	245a0 <rpc_ip_client_request_alloc>
   24af2:	2804      	cmp	r0, #4
   24af4:	f000 8098 	beq.w	24c28 <ip_interface_sendto+0x1a4>
   24af8:	2800      	cmp	r0, #0
   24afa:	f040 8123 	bne.w	24d44 <ip_interface_sendto+0x2c0>
   24afe:	9b06      	ldr	r3, [sp, #24]
   24b00:	f883 b008 	strb.w	fp, [r3, #8]
   24b04:	7258      	strb	r0, [r3, #9]
   24b06:	7298      	strb	r0, [r3, #10]
   24b08:	72d8      	strb	r0, [r3, #11]
   24b0a:	2e00      	cmp	r6, #0
   24b0c:	d053      	beq.n	24bb6 <ip_interface_sendto+0x132>
   24b0e:	68e2      	ldr	r2, [r4, #12]
   24b10:	6871      	ldr	r1, [r6, #4]
   24b12:	428a      	cmp	r2, r1
   24b14:	f040 809a 	bne.w	24c4c <ip_interface_sendto+0x1c8>
   24b18:	7831      	ldrb	r1, [r6, #0]
   24b1a:	9813      	ldr	r0, [sp, #76]	; 0x4c
   24b1c:	4288      	cmp	r0, r1
   24b1e:	d10a      	bne.n	24b36 <ip_interface_sendto+0xb2>
   24b20:	2a02      	cmp	r2, #2
   24b22:	f103 001c 	add.w	r0, r3, #28
   24b26:	f000 80e7 	beq.w	24cf8 <ip_interface_sendto+0x274>
   24b2a:	2a0a      	cmp	r2, #10
   24b2c:	d103      	bne.n	24b36 <ip_interface_sendto+0xb2>
   24b2e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   24b30:	2a24      	cmp	r2, #36	; 0x24
   24b32:	f000 80ce 	beq.w	24cd2 <ip_interface_sendto+0x24e>
   24b36:	f04f 0a16 	mov.w	sl, #22
   24b3a:	6818      	ldr	r0, [r3, #0]
   24b3c:	b110      	cbz	r0, 24b44 <ip_interface_sendto+0xc0>
   24b3e:	f7ff fd61 	bl	24604 <rpc_ip_client_data_free>
   24b42:	9b06      	ldr	r3, [sp, #24]
   24b44:	4618      	mov	r0, r3
   24b46:	f7ff fd55 	bl	245f4 <rpc_ip_client_message_free>
   24b4a:	6823      	ldr	r3, [r4, #0]
   24b4c:	0318      	lsls	r0, r3, #12
   24b4e:	d40b      	bmi.n	24b68 <ip_interface_sendto+0xe4>
   24b50:	6823      	ldr	r3, [r4, #0]
   24b52:	b29b      	uxth	r3, r3
   24b54:	2b0d      	cmp	r3, #13
   24b56:	d007      	beq.n	24b68 <ip_interface_sendto+0xe4>
   24b58:	6823      	ldr	r3, [r4, #0]
   24b5a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   24b5e:	6023      	str	r3, [r4, #0]
   24b60:	6823      	ldr	r3, [r4, #0]
   24b62:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   24b66:	6023      	str	r3, [r4, #0]
   24b68:	f1ba 0f00 	cmp.w	sl, #0
   24b6c:	f040 8093 	bne.w	24c96 <ip_interface_sendto+0x212>
   24b70:	6823      	ldr	r3, [r4, #0]
   24b72:	0119      	lsls	r1, r3, #4
   24b74:	d56d      	bpl.n	24c52 <ip_interface_sendto+0x1ce>
   24b76:	6823      	ldr	r3, [r4, #0]
   24b78:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
   24b7c:	6023      	str	r3, [r4, #0]
   24b7e:	9b00      	ldr	r3, [sp, #0]
   24b80:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   24b84:	2800      	cmp	r0, #0
   24b86:	d168      	bne.n	24c5a <ip_interface_sendto+0x1d6>
   24b88:	4628      	mov	r0, r5
   24b8a:	b009      	add	sp, #36	; 0x24
   24b8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24b90:	6822      	ldr	r2, [r4, #0]
   24b92:	0092      	lsls	r2, r2, #2
   24b94:	d406      	bmi.n	24ba4 <ip_interface_sendto+0x120>
   24b96:	2b01      	cmp	r3, #1
   24b98:	f000 8095 	beq.w	24cc6 <ip_interface_sendto+0x242>
   24b9c:	6823      	ldr	r3, [r4, #0]
   24b9e:	031b      	lsls	r3, r3, #12
   24ba0:	f140 80b7 	bpl.w	24d12 <ip_interface_sendto+0x28e>
   24ba4:	6823      	ldr	r3, [r4, #0]
   24ba6:	031e      	lsls	r6, r3, #12
   24ba8:	f140 80bd 	bpl.w	24d26 <ip_interface_sendto+0x2a2>
   24bac:	4b67      	ldr	r3, [pc, #412]	; (24d4c <ip_interface_sendto+0x2c8>)
   24bae:	f8d4 a008 	ldr.w	sl, [r4, #8]
   24bb2:	9300      	str	r3, [sp, #0]
   24bb4:	e7d8      	b.n	24b68 <ip_interface_sendto+0xe4>
   24bb6:	4642      	mov	r2, r8
   24bb8:	f8c3 9014 	str.w	r9, [r3, #20]
   24bbc:	69a1      	ldr	r1, [r4, #24]
   24bbe:	9804      	ldr	r0, [sp, #16]
   24bc0:	6119      	str	r1, [r3, #16]
   24bc2:	9902      	ldr	r1, [sp, #8]
   24bc4:	4302      	orrs	r2, r0
   24bc6:	60da      	str	r2, [r3, #12]
   24bc8:	605d      	str	r5, [r3, #4]
   24bca:	b119      	cbz	r1, 24bd4 <ip_interface_sendto+0x150>
   24bcc:	6818      	ldr	r0, [r3, #0]
   24bce:	462a      	mov	r2, r5
   24bd0:	f014 fa02 	bl	38fd8 <memcpy>
   24bd4:	6823      	ldr	r3, [r4, #0]
   24bd6:	4641      	mov	r1, r8
   24bd8:	9305      	str	r3, [sp, #20]
   24bda:	6823      	ldr	r3, [r4, #0]
   24bdc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   24be0:	6023      	str	r3, [r4, #0]
   24be2:	6823      	ldr	r3, [r4, #0]
   24be4:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   24be8:	6023      	str	r3, [r4, #0]
   24bea:	9b06      	ldr	r3, [sp, #24]
   24bec:	4618      	mov	r0, r3
   24bee:	9301      	str	r3, [sp, #4]
   24bf0:	f7ff fcea 	bl	245c8 <rpc_ip_client_request_send>
   24bf4:	9b01      	ldr	r3, [sp, #4]
   24bf6:	4682      	mov	sl, r0
   24bf8:	2800      	cmp	r0, #0
   24bfa:	d138      	bne.n	24c6e <ip_interface_sendto+0x1ea>
   24bfc:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   24c00:	ab07      	add	r3, sp, #28
   24c02:	4611      	mov	r1, r2
   24c04:	4638      	mov	r0, r7
   24c06:	f005 fd7b 	bl	2a700 <interface_socket_wait>
   24c0a:	4603      	mov	r3, r0
   24c0c:	b198      	cbz	r0, 24c36 <ip_interface_sendto+0x1b2>
   24c0e:	6822      	ldr	r2, [r4, #0]
   24c10:	0312      	lsls	r2, r2, #12
   24c12:	d455      	bmi.n	24cc0 <ip_interface_sendto+0x23c>
   24c14:	2b3c      	cmp	r3, #60	; 0x3c
   24c16:	d017      	beq.n	24c48 <ip_interface_sendto+0x1c4>
   24c18:	2b0c      	cmp	r3, #12
   24c1a:	d115      	bne.n	24c48 <ip_interface_sendto+0x1c4>
   24c1c:	9b00      	ldr	r3, [sp, #0]
   24c1e:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   24c22:	b108      	cbz	r0, 24c28 <ip_interface_sendto+0x1a4>
   24c24:	f7ff fce6 	bl	245f4 <rpc_ip_client_message_free>
   24c28:	9b03      	ldr	r3, [sp, #12]
   24c2a:	2b00      	cmp	r3, #0
   24c2c:	f47f af5d 	bne.w	24aea <ip_interface_sendto+0x66>
   24c30:	f04f 0a23 	mov.w	sl, #35	; 0x23
   24c34:	e789      	b.n	24b4a <ip_interface_sendto+0xc6>
   24c36:	9001      	str	r0, [sp, #4]
   24c38:	4638      	mov	r0, r7
   24c3a:	f005 fdd5 	bl	2a7e8 <interface_socket_from_handle_get>
   24c3e:	9b01      	ldr	r3, [sp, #4]
   24c40:	b110      	cbz	r0, 24c48 <ip_interface_sendto+0x1c4>
   24c42:	6843      	ldr	r3, [r0, #4]
   24c44:	2b00      	cmp	r3, #0
   24c46:	d136      	bne.n	24cb6 <ip_interface_sendto+0x232>
   24c48:	469a      	mov	sl, r3
   24c4a:	e77e      	b.n	24b4a <ip_interface_sendto+0xc6>
   24c4c:	f04f 0a2f 	mov.w	sl, #47	; 0x2f
   24c50:	e773      	b.n	24b3a <ip_interface_sendto+0xb6>
   24c52:	9b00      	ldr	r3, [sp, #0]
   24c54:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   24c58:	6985      	ldr	r5, [r0, #24]
   24c5a:	f7ff fccb 	bl	245f4 <rpc_ip_client_message_free>
   24c5e:	2300      	movs	r3, #0
   24c60:	4628      	mov	r0, r5
   24c62:	9a00      	ldr	r2, [sp, #0]
   24c64:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
   24c68:	b009      	add	sp, #36	; 0x24
   24c6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24c6e:	6818      	ldr	r0, [r3, #0]
   24c70:	469a      	mov	sl, r3
   24c72:	b108      	cbz	r0, 24c78 <ip_interface_sendto+0x1f4>
   24c74:	f7ff fcc6 	bl	24604 <rpc_ip_client_data_free>
   24c78:	4650      	mov	r0, sl
   24c7a:	f7ff fcbb 	bl	245f4 <rpc_ip_client_message_free>
   24c7e:	9b05      	ldr	r3, [sp, #20]
   24c80:	f04f 0a23 	mov.w	sl, #35	; 0x23
   24c84:	6023      	str	r3, [r4, #0]
   24c86:	e760      	b.n	24b4a <ip_interface_sendto+0xc6>
   24c88:	2e00      	cmp	r6, #0
   24c8a:	f43f af13 	beq.w	24ab4 <ip_interface_sendto+0x30>
   24c8e:	f04f 0a38 	mov.w	sl, #56	; 0x38
   24c92:	4b2e      	ldr	r3, [pc, #184]	; (24d4c <ip_interface_sendto+0x2c8>)
   24c94:	9300      	str	r3, [sp, #0]
   24c96:	4650      	mov	r0, sl
   24c98:	f7fb f9e2 	bl	20060 <bsd_os_errno_set>
   24c9c:	9b00      	ldr	r3, [sp, #0]
   24c9e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   24ca2:	f853 0027 	ldr.w	r0, [r3, r7, lsl #2]
   24ca6:	e76d      	b.n	24b84 <ip_interface_sendto+0x100>
   24ca8:	6823      	ldr	r3, [r4, #0]
   24caa:	f083 5380 	eor.w	r3, r3, #268435456	; 0x10000000
   24cae:	f3c3 7300 	ubfx	r3, r3, #28, #1
   24cb2:	9303      	str	r3, [sp, #12]
   24cb4:	e70b      	b.n	24ace <ip_interface_sendto+0x4a>
   24cb6:	f8c0 a004 	str.w	sl, [r0, #4]
   24cba:	6822      	ldr	r2, [r4, #0]
   24cbc:	0312      	lsls	r2, r2, #12
   24cbe:	d5a9      	bpl.n	24c14 <ip_interface_sendto+0x190>
   24cc0:	f8d4 a008 	ldr.w	sl, [r4, #8]
   24cc4:	e741      	b.n	24b4a <ip_interface_sendto+0xc6>
   24cc6:	6823      	ldr	r3, [r4, #0]
   24cc8:	b29b      	uxth	r3, r3
   24cca:	2b05      	cmp	r3, #5
   24ccc:	f47f af6a 	bne.w	24ba4 <ip_interface_sendto+0x120>
   24cd0:	e764      	b.n	24b9c <ip_interface_sendto+0x118>
   24cd2:	2210      	movs	r2, #16
   24cd4:	8931      	ldrh	r1, [r6, #8]
   24cd6:	835a      	strh	r2, [r3, #26]
   24cd8:	8319      	strh	r1, [r3, #24]
   24cda:	18b1      	adds	r1, r6, r2
   24cdc:	f014 f97c 	bl	38fd8 <memcpy>
   24ce0:	f247 0207 	movw	r2, #28679	; 0x7007
   24ce4:	9b06      	ldr	r3, [sp, #24]
   24ce6:	4690      	mov	r8, r2
   24ce8:	6899      	ldr	r1, [r3, #8]
   24cea:	8b58      	ldrh	r0, [r3, #26]
   24cec:	3104      	adds	r1, #4
   24cee:	4401      	add	r1, r0
   24cf0:	f8c3 9014 	str.w	r9, [r3, #20]
   24cf4:	6099      	str	r1, [r3, #8]
   24cf6:	e761      	b.n	24bbc <ip_interface_sendto+0x138>
   24cf8:	9a13      	ldr	r2, [sp, #76]	; 0x4c
   24cfa:	2a10      	cmp	r2, #16
   24cfc:	f47f af1b 	bne.w	24b36 <ip_interface_sendto+0xb2>
   24d00:	2204      	movs	r2, #4
   24d02:	8931      	ldrh	r1, [r6, #8]
   24d04:	835a      	strh	r2, [r3, #26]
   24d06:	8319      	strh	r1, [r3, #24]
   24d08:	f106 010c 	add.w	r1, r6, #12
   24d0c:	f014 f964 	bl	38fd8 <memcpy>
   24d10:	e7e6      	b.n	24ce0 <ip_interface_sendto+0x25c>
   24d12:	4b0e      	ldr	r3, [pc, #56]	; (24d4c <ip_interface_sendto+0x2c8>)
   24d14:	f04f 0a23 	mov.w	sl, #35	; 0x23
   24d18:	9300      	str	r3, [sp, #0]
   24d1a:	e7bc      	b.n	24c96 <ip_interface_sendto+0x212>
   24d1c:	4b0b      	ldr	r3, [pc, #44]	; (24d4c <ip_interface_sendto+0x2c8>)
   24d1e:	f04f 0a28 	mov.w	sl, #40	; 0x28
   24d22:	9300      	str	r3, [sp, #0]
   24d24:	e7b7      	b.n	24c96 <ip_interface_sendto+0x212>
   24d26:	4b09      	ldr	r3, [pc, #36]	; (24d4c <ip_interface_sendto+0x2c8>)
   24d28:	f04f 0a39 	mov.w	sl, #57	; 0x39
   24d2c:	9300      	str	r3, [sp, #0]
   24d2e:	e7b2      	b.n	24c96 <ip_interface_sendto+0x212>
   24d30:	4b06      	ldr	r3, [pc, #24]	; (24d4c <ip_interface_sendto+0x2c8>)
   24d32:	f04f 0a2d 	mov.w	sl, #45	; 0x2d
   24d36:	9300      	str	r3, [sp, #0]
   24d38:	e7ad      	b.n	24c96 <ip_interface_sendto+0x212>
   24d3a:	4b04      	ldr	r3, [pc, #16]	; (24d4c <ip_interface_sendto+0x2c8>)
   24d3c:	f04f 0a09 	mov.w	sl, #9
   24d40:	9300      	str	r3, [sp, #0]
   24d42:	e7a8      	b.n	24c96 <ip_interface_sendto+0x212>
   24d44:	f04f 0a0c 	mov.w	sl, #12
   24d48:	e6ff      	b.n	24b4a <ip_interface_sendto+0xc6>
   24d4a:	bf00      	nop
   24d4c:	200226e0 	.word	0x200226e0

00024d50 <ip_interface_recvfrom>:
   24d50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   24d54:	b087      	sub	sp, #28
   24d56:	2a00      	cmp	r2, #0
   24d58:	f000 8112 	beq.w	24f80 <ip_interface_recvfrom+0x230>
   24d5c:	4680      	mov	r8, r0
   24d5e:	468b      	mov	fp, r1
   24d60:	469a      	mov	sl, r3
   24d62:	4691      	mov	r9, r2
   24d64:	b11b      	cbz	r3, 24d6e <ip_interface_recvfrom+0x1e>
   24d66:	f013 0f3a 	tst.w	r3, #58	; 0x3a
   24d6a:	f000 8107 	beq.w	24f7c <ip_interface_recvfrom+0x22c>
   24d6e:	4640      	mov	r0, r8
   24d70:	f005 fd3a 	bl	2a7e8 <interface_socket_from_handle_get>
   24d74:	4604      	mov	r4, r0
   24d76:	2800      	cmp	r0, #0
   24d78:	f000 8104 	beq.w	24f84 <ip_interface_recvfrom+0x234>
   24d7c:	6803      	ldr	r3, [r0, #0]
   24d7e:	02db      	lsls	r3, r3, #11
   24d80:	d562      	bpl.n	24e48 <ip_interface_recvfrom+0xf8>
   24d82:	f01a 0f02 	tst.w	sl, #2
   24d86:	bf18      	it	ne
   24d88:	2600      	movne	r6, #0
   24d8a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   24d8e:	bf08      	it	eq
   24d90:	6806      	ldreq	r6, [r0, #0]
   24d92:	f00a 0310 	and.w	r3, sl, #16
   24d96:	bf04      	itt	eq
   24d98:	f086 5680 	eoreq.w	r6, r6, #268435456	; 0x10000000
   24d9c:	f3c6 7600 	ubfxeq	r6, r6, #28, #1
   24da0:	9301      	str	r3, [sp, #4]
   24da2:	6823      	ldr	r3, [r4, #0]
   24da4:	03df      	lsls	r7, r3, #15
   24da6:	d567      	bpl.n	24e78 <ip_interface_recvfrom+0x128>
   24da8:	6823      	ldr	r3, [r4, #0]
   24daa:	69e0      	ldr	r0, [r4, #28]
   24dac:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   24db0:	6023      	str	r3, [r4, #0]
   24db2:	6803      	ldr	r3, [r0, #0]
   24db4:	68db      	ldr	r3, [r3, #12]
   24db6:	4798      	blx	r3
   24db8:	4605      	mov	r5, r0
   24dba:	3001      	adds	r0, #1
   24dbc:	d07d      	beq.n	24eba <ip_interface_recvfrom+0x16a>
   24dbe:	45a9      	cmp	r9, r5
   24dc0:	dd03      	ble.n	24dca <ip_interface_recvfrom+0x7a>
   24dc2:	6923      	ldr	r3, [r4, #16]
   24dc4:	2b01      	cmp	r3, #1
   24dc6:	f000 80a3 	beq.w	24f10 <ip_interface_recvfrom+0x1c0>
   24dca:	f04f 0800 	mov.w	r8, #0
   24dce:	af02      	add	r7, sp, #8
   24dd0:	9b11      	ldr	r3, [sp, #68]	; 0x44
   24dd2:	b103      	cbz	r3, 24dd6 <ip_interface_recvfrom+0x86>
   24dd4:	681b      	ldr	r3, [r3, #0]
   24dd6:	9a10      	ldr	r2, [sp, #64]	; 0x40
   24dd8:	e9cd b902 	strd	fp, r9, [sp, #8]
   24ddc:	e9cd 2304 	strd	r2, r3, [sp, #16]
   24de0:	69e0      	ldr	r0, [r4, #28]
   24de2:	4639      	mov	r1, r7
   24de4:	6803      	ldr	r3, [r0, #0]
   24de6:	4652      	mov	r2, sl
   24de8:	689b      	ldr	r3, [r3, #8]
   24dea:	4798      	blx	r3
   24dec:	4605      	mov	r5, r0
   24dee:	69e0      	ldr	r0, [r4, #28]
   24df0:	1c6b      	adds	r3, r5, #1
   24df2:	6803      	ldr	r3, [r0, #0]
   24df4:	bf18      	it	ne
   24df6:	2701      	movne	r7, #1
   24df8:	68db      	ldr	r3, [r3, #12]
   24dfa:	bf0a      	itet	eq
   24dfc:	2700      	moveq	r7, #0
   24dfe:	2600      	movne	r6, #0
   24e00:	2623      	moveq	r6, #35	; 0x23
   24e02:	4798      	blx	r3
   24e04:	3001      	adds	r0, #1
   24e06:	d132      	bne.n	24e6e <ip_interface_recvfrom+0x11e>
   24e08:	f1b8 0f00 	cmp.w	r8, #0
   24e0c:	f000 80b0 	beq.w	24f70 <ip_interface_recvfrom+0x220>
   24e10:	2f00      	cmp	r7, #0
   24e12:	f000 80a1 	beq.w	24f58 <ip_interface_recvfrom+0x208>
   24e16:	6823      	ldr	r3, [r4, #0]
   24e18:	0318      	lsls	r0, r3, #12
   24e1a:	d506      	bpl.n	24e2a <ip_interface_recvfrom+0xda>
   24e1c:	6823      	ldr	r3, [r4, #0]
   24e1e:	b29b      	uxth	r3, r3
   24e20:	2b0d      	cmp	r3, #13
   24e22:	d002      	beq.n	24e2a <ip_interface_recvfrom+0xda>
   24e24:	6923      	ldr	r3, [r4, #16]
   24e26:	2b01      	cmp	r3, #1
   24e28:	d021      	beq.n	24e6e <ip_interface_recvfrom+0x11e>
   24e2a:	6823      	ldr	r3, [r4, #0]
   24e2c:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   24e30:	6823      	ldr	r3, [r4, #0]
   24e32:	f040 80a9 	bne.w	24f88 <ip_interface_recvfrom+0x238>
   24e36:	0319      	lsls	r1, r3, #12
   24e38:	d473      	bmi.n	24f22 <ip_interface_recvfrom+0x1d2>
   24e3a:	2e00      	cmp	r6, #0
   24e3c:	f040 8086 	bne.w	24f4c <ip_interface_recvfrom+0x1fc>
   24e40:	4628      	mov	r0, r5
   24e42:	b007      	add	sp, #28
   24e44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   24e48:	6803      	ldr	r3, [r0, #0]
   24e4a:	b29b      	uxth	r3, r3
   24e4c:	2b06      	cmp	r3, #6
   24e4e:	d071      	beq.n	24f34 <ip_interface_recvfrom+0x1e4>
   24e50:	6803      	ldr	r3, [r0, #0]
   24e52:	b29b      	uxth	r3, r3
   24e54:	2b07      	cmp	r3, #7
   24e56:	bf0c      	ite	eq
   24e58:	2609      	moveq	r6, #9
   24e5a:	2639      	movne	r6, #57	; 0x39
   24e5c:	69e0      	ldr	r0, [r4, #28]
   24e5e:	6803      	ldr	r3, [r0, #0]
   24e60:	68db      	ldr	r3, [r3, #12]
   24e62:	4798      	blx	r3
   24e64:	1c43      	adds	r3, r0, #1
   24e66:	4605      	mov	r5, r0
   24e68:	d0df      	beq.n	24e2a <ip_interface_recvfrom+0xda>
   24e6a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   24e6e:	6823      	ldr	r3, [r4, #0]
   24e70:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   24e74:	6023      	str	r3, [r4, #0]
   24e76:	e7e0      	b.n	24e3a <ip_interface_recvfrom+0xea>
   24e78:	2e00      	cmp	r6, #0
   24e7a:	d07d      	beq.n	24f78 <ip_interface_recvfrom+0x228>
   24e7c:	6a26      	ldr	r6, [r4, #32]
   24e7e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   24e82:	2e00      	cmp	r6, #0
   24e84:	bf08      	it	eq
   24e86:	f04f 36ff 	moveq.w	r6, #4294967295	; 0xffffffff
   24e8a:	af02      	add	r7, sp, #8
   24e8c:	463b      	mov	r3, r7
   24e8e:	4611      	mov	r1, r2
   24e90:	4640      	mov	r0, r8
   24e92:	9602      	str	r6, [sp, #8]
   24e94:	f005 fc34 	bl	2a700 <interface_socket_wait>
   24e98:	4606      	mov	r6, r0
   24e9a:	b350      	cbz	r0, 24ef2 <ip_interface_recvfrom+0x1a2>
   24e9c:	6823      	ldr	r3, [r4, #0]
   24e9e:	031a      	lsls	r2, r3, #12
   24ea0:	d532      	bpl.n	24f08 <ip_interface_recvfrom+0x1b8>
   24ea2:	6823      	ldr	r3, [r4, #0]
   24ea4:	b29b      	uxth	r3, r3
   24ea6:	2b0d      	cmp	r3, #13
   24ea8:	d02e      	beq.n	24f08 <ip_interface_recvfrom+0x1b8>
   24eaa:	6923      	ldr	r3, [r4, #16]
   24eac:	f1a3 0801 	sub.w	r8, r3, #1
   24eb0:	fab8 f888 	clz	r8, r8
   24eb4:	ea4f 1858 	mov.w	r8, r8, lsr #5
   24eb8:	e78a      	b.n	24dd0 <ip_interface_recvfrom+0x80>
   24eba:	6823      	ldr	r3, [r4, #0]
   24ebc:	031a      	lsls	r2, r3, #12
   24ebe:	d5db      	bpl.n	24e78 <ip_interface_recvfrom+0x128>
   24ec0:	6823      	ldr	r3, [r4, #0]
   24ec2:	b29b      	uxth	r3, r3
   24ec4:	2b0d      	cmp	r3, #13
   24ec6:	d0d7      	beq.n	24e78 <ip_interface_recvfrom+0x128>
   24ec8:	6923      	ldr	r3, [r4, #16]
   24eca:	69e0      	ldr	r0, [r4, #28]
   24ecc:	2b01      	cmp	r3, #1
   24ece:	d033      	beq.n	24f38 <ip_interface_recvfrom+0x1e8>
   24ed0:	2639      	movs	r6, #57	; 0x39
   24ed2:	6823      	ldr	r3, [r4, #0]
   24ed4:	0c1b      	lsrs	r3, r3, #16
   24ed6:	041b      	lsls	r3, r3, #16
   24ed8:	f043 030d 	orr.w	r3, r3, #13
   24edc:	6023      	str	r3, [r4, #0]
   24ede:	6823      	ldr	r3, [r4, #0]
   24ee0:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   24ee4:	6023      	str	r3, [r4, #0]
   24ee6:	6803      	ldr	r3, [r0, #0]
   24ee8:	68db      	ldr	r3, [r3, #12]
   24eea:	4798      	blx	r3
   24eec:	3001      	adds	r0, #1
   24eee:	d1be      	bne.n	24e6e <ip_interface_recvfrom+0x11e>
   24ef0:	e79b      	b.n	24e2a <ip_interface_recvfrom+0xda>
   24ef2:	4640      	mov	r0, r8
   24ef4:	f005 fc78 	bl	2a7e8 <interface_socket_from_handle_get>
   24ef8:	b140      	cbz	r0, 24f0c <ip_interface_recvfrom+0x1bc>
   24efa:	6846      	ldr	r6, [r0, #4]
   24efc:	b136      	cbz	r6, 24f0c <ip_interface_recvfrom+0x1bc>
   24efe:	2300      	movs	r3, #0
   24f00:	6043      	str	r3, [r0, #4]
   24f02:	6823      	ldr	r3, [r4, #0]
   24f04:	031a      	lsls	r2, r3, #12
   24f06:	d4cc      	bmi.n	24ea2 <ip_interface_recvfrom+0x152>
   24f08:	69e0      	ldr	r0, [r4, #28]
   24f0a:	e7ec      	b.n	24ee6 <ip_interface_recvfrom+0x196>
   24f0c:	2601      	movs	r6, #1
   24f0e:	e748      	b.n	24da2 <ip_interface_recvfrom+0x52>
   24f10:	9b01      	ldr	r3, [sp, #4]
   24f12:	b11b      	cbz	r3, 24f1c <ip_interface_recvfrom+0x1cc>
   24f14:	6823      	ldr	r3, [r4, #0]
   24f16:	00d9      	lsls	r1, r3, #3
   24f18:	d5b0      	bpl.n	24e7c <ip_interface_recvfrom+0x12c>
   24f1a:	e756      	b.n	24dca <ip_interface_recvfrom+0x7a>
   24f1c:	4698      	mov	r8, r3
   24f1e:	af02      	add	r7, sp, #8
   24f20:	e756      	b.n	24dd0 <ip_interface_recvfrom+0x80>
   24f22:	6823      	ldr	r3, [r4, #0]
   24f24:	b29b      	uxth	r3, r3
   24f26:	2b0d      	cmp	r3, #13
   24f28:	d187      	bne.n	24e3a <ip_interface_recvfrom+0xea>
   24f2a:	68a3      	ldr	r3, [r4, #8]
   24f2c:	2b00      	cmp	r3, #0
   24f2e:	d084      	beq.n	24e3a <ip_interface_recvfrom+0xea>
   24f30:	68a6      	ldr	r6, [r4, #8]
   24f32:	e782      	b.n	24e3a <ip_interface_recvfrom+0xea>
   24f34:	2609      	movs	r6, #9
   24f36:	e791      	b.n	24e5c <ip_interface_recvfrom+0x10c>
   24f38:	6803      	ldr	r3, [r0, #0]
   24f3a:	68db      	ldr	r3, [r3, #12]
   24f3c:	4798      	blx	r3
   24f3e:	3001      	adds	r0, #1
   24f40:	d00a      	beq.n	24f58 <ip_interface_recvfrom+0x208>
   24f42:	2623      	movs	r6, #35	; 0x23
   24f44:	6823      	ldr	r3, [r4, #0]
   24f46:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   24f4a:	6023      	str	r3, [r4, #0]
   24f4c:	4630      	mov	r0, r6
   24f4e:	f7fb f887 	bl	20060 <bsd_os_errno_set>
   24f52:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   24f56:	e773      	b.n	24e40 <ip_interface_recvfrom+0xf0>
   24f58:	6823      	ldr	r3, [r4, #0]
   24f5a:	2500      	movs	r5, #0
   24f5c:	0c1b      	lsrs	r3, r3, #16
   24f5e:	041b      	lsls	r3, r3, #16
   24f60:	f043 030d 	orr.w	r3, r3, #13
   24f64:	6023      	str	r3, [r4, #0]
   24f66:	6823      	ldr	r3, [r4, #0]
   24f68:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
   24f6c:	6023      	str	r3, [r4, #0]
   24f6e:	e767      	b.n	24e40 <ip_interface_recvfrom+0xf0>
   24f70:	2f00      	cmp	r7, #0
   24f72:	f47f af50 	bne.w	24e16 <ip_interface_recvfrom+0xc6>
   24f76:	e758      	b.n	24e2a <ip_interface_recvfrom+0xda>
   24f78:	2623      	movs	r6, #35	; 0x23
   24f7a:	e7c5      	b.n	24f08 <ip_interface_recvfrom+0x1b8>
   24f7c:	262d      	movs	r6, #45	; 0x2d
   24f7e:	e7e5      	b.n	24f4c <ip_interface_recvfrom+0x1fc>
   24f80:	2616      	movs	r6, #22
   24f82:	e7e3      	b.n	24f4c <ip_interface_recvfrom+0x1fc>
   24f84:	2609      	movs	r6, #9
   24f86:	e7e1      	b.n	24f4c <ip_interface_recvfrom+0x1fc>
   24f88:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
   24f8c:	6023      	str	r3, [r4, #0]
   24f8e:	6823      	ldr	r3, [r4, #0]
   24f90:	2669      	movs	r6, #105	; 0x69
   24f92:	0c1b      	lsrs	r3, r3, #16
   24f94:	041b      	lsls	r3, r3, #16
   24f96:	f043 030d 	orr.w	r3, r3, #13
   24f9a:	6023      	str	r3, [r4, #0]
   24f9c:	e7d6      	b.n	24f4c <ip_interface_recvfrom+0x1fc>
   24f9e:	bf00      	nop

00024fa0 <ip_interface_connect>:
   24fa0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   24fa4:	b082      	sub	sp, #8
   24fa6:	2900      	cmp	r1, #0
   24fa8:	d04b      	beq.n	25042 <ip_interface_connect+0xa2>
   24faa:	4617      	mov	r7, r2
   24fac:	2a00      	cmp	r2, #0
   24fae:	d048      	beq.n	25042 <ip_interface_connect+0xa2>
   24fb0:	4680      	mov	r8, r0
   24fb2:	4689      	mov	r9, r1
   24fb4:	f005 fc18 	bl	2a7e8 <interface_socket_from_handle_get>
   24fb8:	4605      	mov	r5, r0
   24fba:	2800      	cmp	r0, #0
   24fbc:	f000 80af 	beq.w	2511e <ip_interface_connect+0x17e>
   24fc0:	6803      	ldr	r3, [r0, #0]
   24fc2:	b29b      	uxth	r3, r3
   24fc4:	2b02      	cmp	r3, #2
   24fc6:	d004      	beq.n	24fd2 <ip_interface_connect+0x32>
   24fc8:	6803      	ldr	r3, [r0, #0]
   24fca:	b29b      	uxth	r3, r3
   24fcc:	2b04      	cmp	r3, #4
   24fce:	f040 809d 	bne.w	2510c <ip_interface_connect+0x16c>
   24fd2:	6829      	ldr	r1, [r5, #0]
   24fd4:	f011 5100 	ands.w	r1, r1, #536870912	; 0x20000000
   24fd8:	f040 8089 	bne.w	250ee <ip_interface_connect+0x14e>
   24fdc:	ae02      	add	r6, sp, #8
   24fde:	f8d5 a018 	ldr.w	sl, [r5, #24]
   24fe2:	f846 1d04 	str.w	r1, [r6, #-4]!
   24fe6:	4630      	mov	r0, r6
   24fe8:	f7ff fada 	bl	245a0 <rpc_ip_client_request_alloc>
   24fec:	bb98      	cbnz	r0, 25056 <ip_interface_connect+0xb6>
   24fee:	2108      	movs	r1, #8
   24ff0:	ea4f 4208 	mov.w	r2, r8, lsl #16
   24ff4:	9c01      	ldr	r4, [sp, #4]
   24ff6:	f442 43e0 	orr.w	r3, r2, #28672	; 0x7000
   24ffa:	f043 0302 	orr.w	r3, r3, #2
   24ffe:	60e3      	str	r3, [r4, #12]
   25000:	f8c4 a010 	str.w	sl, [r4, #16]
   25004:	7260      	strb	r0, [r4, #9]
   25006:	72a0      	strb	r0, [r4, #10]
   25008:	72e0      	strb	r0, [r4, #11]
   2500a:	7221      	strb	r1, [r4, #8]
   2500c:	f442 42e0 	orr.w	r2, r2, #28672	; 0x7000
   25010:	f042 0202 	orr.w	r2, r2, #2
   25014:	60e2      	str	r2, [r4, #12]
   25016:	68a3      	ldr	r3, [r4, #8]
   25018:	69aa      	ldr	r2, [r5, #24]
   2501a:	3304      	adds	r3, #4
   2501c:	6122      	str	r2, [r4, #16]
   2501e:	60a3      	str	r3, [r4, #8]
   25020:	68eb      	ldr	r3, [r5, #12]
   25022:	f8d9 2004 	ldr.w	r2, [r9, #4]
   25026:	4293      	cmp	r3, r2
   25028:	d11b      	bne.n	25062 <ip_interface_connect+0xc2>
   2502a:	f899 2000 	ldrb.w	r2, [r9]
   2502e:	4297      	cmp	r7, r2
   25030:	d107      	bne.n	25042 <ip_interface_connect+0xa2>
   25032:	2b02      	cmp	r3, #2
   25034:	f104 0018 	add.w	r0, r4, #24
   25038:	d015      	beq.n	25066 <ip_interface_connect+0xc6>
   2503a:	2b0a      	cmp	r3, #10
   2503c:	d101      	bne.n	25042 <ip_interface_connect+0xa2>
   2503e:	2f24      	cmp	r7, #36	; 0x24
   25040:	d01d      	beq.n	2507e <ip_interface_connect+0xde>
   25042:	2416      	movs	r4, #22
   25044:	4620      	mov	r0, r4
   25046:	f7fb f80b 	bl	20060 <bsd_os_errno_set>
   2504a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   2504e:	4620      	mov	r0, r4
   25050:	b002      	add	sp, #8
   25052:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   25056:	9c01      	ldr	r4, [sp, #4]
   25058:	2c00      	cmp	r4, #0
   2505a:	d05e      	beq.n	2511a <ip_interface_connect+0x17a>
   2505c:	ea4f 4208 	mov.w	r2, r8, lsl #16
   25060:	e7d4      	b.n	2500c <ip_interface_connect+0x6c>
   25062:	242f      	movs	r4, #47	; 0x2f
   25064:	e7ee      	b.n	25044 <ip_interface_connect+0xa4>
   25066:	2f10      	cmp	r7, #16
   25068:	d1eb      	bne.n	25042 <ip_interface_connect+0xa2>
   2506a:	2204      	movs	r2, #4
   2506c:	f8b9 3008 	ldrh.w	r3, [r9, #8]
   25070:	f109 010c 	add.w	r1, r9, #12
   25074:	82e2      	strh	r2, [r4, #22]
   25076:	82a3      	strh	r3, [r4, #20]
   25078:	f013 ffae 	bl	38fd8 <memcpy>
   2507c:	e008      	b.n	25090 <ip_interface_connect+0xf0>
   2507e:	2210      	movs	r2, #16
   25080:	f8b9 3008 	ldrh.w	r3, [r9, #8]
   25084:	eb09 0102 	add.w	r1, r9, r2
   25088:	82e2      	strh	r2, [r4, #22]
   2508a:	82a3      	strh	r3, [r4, #20]
   2508c:	f013 ffa4 	bl	38fd8 <memcpy>
   25090:	68a3      	ldr	r3, [r4, #8]
   25092:	8ae2      	ldrh	r2, [r4, #22]
   25094:	f247 0102 	movw	r1, #28674	; 0x7002
   25098:	4413      	add	r3, r2
   2509a:	60a3      	str	r3, [r4, #8]
   2509c:	682f      	ldr	r7, [r5, #0]
   2509e:	682b      	ldr	r3, [r5, #0]
   250a0:	4620      	mov	r0, r4
   250a2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   250a6:	602b      	str	r3, [r5, #0]
   250a8:	f7ff fa8e 	bl	245c8 <rpc_ip_client_request_send>
   250ac:	b9a8      	cbnz	r0, 250da <ip_interface_connect+0x13a>
   250ae:	682b      	ldr	r3, [r5, #0]
   250b0:	00db      	lsls	r3, r3, #3
   250b2:	d429      	bmi.n	25108 <ip_interface_connect+0x168>
   250b4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
   250b6:	4633      	mov	r3, r6
   250b8:	2c00      	cmp	r4, #0
   250ba:	bf08      	it	eq
   250bc:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
   250c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   250c4:	2105      	movs	r1, #5
   250c6:	4640      	mov	r0, r8
   250c8:	9401      	str	r4, [sp, #4]
   250ca:	f005 fb19 	bl	2a700 <interface_socket_wait>
   250ce:	4604      	mov	r4, r0
   250d0:	b178      	cbz	r0, 250f2 <ip_interface_connect+0x152>
   250d2:	2c73      	cmp	r4, #115	; 0x73
   250d4:	d0b6      	beq.n	25044 <ip_interface_connect+0xa4>
   250d6:	602f      	str	r7, [r5, #0]
   250d8:	e7b4      	b.n	25044 <ip_interface_connect+0xa4>
   250da:	6820      	ldr	r0, [r4, #0]
   250dc:	b108      	cbz	r0, 250e2 <ip_interface_connect+0x142>
   250de:	f7ff fa91 	bl	24604 <rpc_ip_client_data_free>
   250e2:	4620      	mov	r0, r4
   250e4:	f7ff fa86 	bl	245f4 <rpc_ip_client_message_free>
   250e8:	2423      	movs	r4, #35	; 0x23
   250ea:	602f      	str	r7, [r5, #0]
   250ec:	e7aa      	b.n	25044 <ip_interface_connect+0xa4>
   250ee:	2472      	movs	r4, #114	; 0x72
   250f0:	e7a8      	b.n	25044 <ip_interface_connect+0xa4>
   250f2:	4640      	mov	r0, r8
   250f4:	f005 fb78 	bl	2a7e8 <interface_socket_from_handle_get>
   250f8:	2800      	cmp	r0, #0
   250fa:	d0a8      	beq.n	2504e <ip_interface_connect+0xae>
   250fc:	6843      	ldr	r3, [r0, #4]
   250fe:	2b00      	cmp	r3, #0
   25100:	d0a5      	beq.n	2504e <ip_interface_connect+0xae>
   25102:	6044      	str	r4, [r0, #4]
   25104:	461c      	mov	r4, r3
   25106:	e7e4      	b.n	250d2 <ip_interface_connect+0x132>
   25108:	2473      	movs	r4, #115	; 0x73
   2510a:	e79b      	b.n	25044 <ip_interface_connect+0xa4>
   2510c:	6803      	ldr	r3, [r0, #0]
   2510e:	b29b      	uxth	r3, r3
   25110:	2b05      	cmp	r3, #5
   25112:	bf14      	ite	ne
   25114:	2409      	movne	r4, #9
   25116:	2438      	moveq	r4, #56	; 0x38
   25118:	e794      	b.n	25044 <ip_interface_connect+0xa4>
   2511a:	240c      	movs	r4, #12
   2511c:	e792      	b.n	25044 <ip_interface_connect+0xa4>
   2511e:	2409      	movs	r4, #9
   25120:	e790      	b.n	25044 <ip_interface_connect+0xa4>
   25122:	bf00      	nop

00025124 <ip_interface_bind>:
   25124:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25128:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2512c:	b083      	sub	sp, #12
   2512e:	9300      	str	r3, [sp, #0]
   25130:	b3b1      	cbz	r1, 251a0 <ip_interface_bind+0x7c>
   25132:	4616      	mov	r6, r2
   25134:	b3a2      	cbz	r2, 251a0 <ip_interface_bind+0x7c>
   25136:	4607      	mov	r7, r0
   25138:	4688      	mov	r8, r1
   2513a:	f005 fb55 	bl	2a7e8 <interface_socket_from_handle_get>
   2513e:	4605      	mov	r5, r0
   25140:	2800      	cmp	r0, #0
   25142:	d04a      	beq.n	251da <ip_interface_bind+0xb6>
   25144:	6803      	ldr	r3, [r0, #0]
   25146:	b29b      	uxth	r3, r3
   25148:	2b02      	cmp	r3, #2
   2514a:	d146      	bne.n	251da <ip_interface_bind+0xb6>
   2514c:	2100      	movs	r1, #0
   2514e:	a802      	add	r0, sp, #8
   25150:	f840 1d04 	str.w	r1, [r0, #-4]!
   25154:	f8d5 9018 	ldr.w	r9, [r5, #24]
   25158:	f7ff fa22 	bl	245a0 <rpc_ip_client_request_alloc>
   2515c:	bb50      	cbnz	r0, 251b4 <ip_interface_bind+0x90>
   2515e:	f247 0305 	movw	r3, #28677	; 0x7005
   25162:	2208      	movs	r2, #8
   25164:	9c01      	ldr	r4, [sp, #4]
   25166:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   2516a:	60e3      	str	r3, [r4, #12]
   2516c:	f8c4 9010 	str.w	r9, [r4, #16]
   25170:	7260      	strb	r0, [r4, #9]
   25172:	72a0      	strb	r0, [r4, #10]
   25174:	72e0      	strb	r0, [r4, #11]
   25176:	7222      	strb	r2, [r4, #8]
   25178:	68a3      	ldr	r3, [r4, #8]
   2517a:	3304      	adds	r3, #4
   2517c:	60a3      	str	r3, [r4, #8]
   2517e:	68eb      	ldr	r3, [r5, #12]
   25180:	f8d8 2004 	ldr.w	r2, [r8, #4]
   25184:	4293      	cmp	r3, r2
   25186:	d11a      	bne.n	251be <ip_interface_bind+0x9a>
   25188:	f898 2000 	ldrb.w	r2, [r8]
   2518c:	4296      	cmp	r6, r2
   2518e:	d107      	bne.n	251a0 <ip_interface_bind+0x7c>
   25190:	2b02      	cmp	r3, #2
   25192:	f104 0018 	add.w	r0, r4, #24
   25196:	d014      	beq.n	251c2 <ip_interface_bind+0x9e>
   25198:	2b0a      	cmp	r3, #10
   2519a:	d101      	bne.n	251a0 <ip_interface_bind+0x7c>
   2519c:	2e24      	cmp	r6, #36	; 0x24
   2519e:	d01e      	beq.n	251de <ip_interface_bind+0xba>
   251a0:	2416      	movs	r4, #22
   251a2:	4620      	mov	r0, r4
   251a4:	f7fa ff5c 	bl	20060 <bsd_os_errno_set>
   251a8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   251ac:	4620      	mov	r0, r4
   251ae:	b003      	add	sp, #12
   251b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   251b4:	9c01      	ldr	r4, [sp, #4]
   251b6:	2c00      	cmp	r4, #0
   251b8:	d1de      	bne.n	25178 <ip_interface_bind+0x54>
   251ba:	240c      	movs	r4, #12
   251bc:	e7f1      	b.n	251a2 <ip_interface_bind+0x7e>
   251be:	242f      	movs	r4, #47	; 0x2f
   251c0:	e7ef      	b.n	251a2 <ip_interface_bind+0x7e>
   251c2:	2e10      	cmp	r6, #16
   251c4:	d1ec      	bne.n	251a0 <ip_interface_bind+0x7c>
   251c6:	2204      	movs	r2, #4
   251c8:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   251cc:	f108 010c 	add.w	r1, r8, #12
   251d0:	82e2      	strh	r2, [r4, #22]
   251d2:	82a3      	strh	r3, [r4, #20]
   251d4:	f013 ff00 	bl	38fd8 <memcpy>
   251d8:	e00a      	b.n	251f0 <ip_interface_bind+0xcc>
   251da:	2409      	movs	r4, #9
   251dc:	e7e1      	b.n	251a2 <ip_interface_bind+0x7e>
   251de:	2210      	movs	r2, #16
   251e0:	f8b8 3008 	ldrh.w	r3, [r8, #8]
   251e4:	eb08 0102 	add.w	r1, r8, r2
   251e8:	82e2      	strh	r2, [r4, #22]
   251ea:	82a3      	strh	r3, [r4, #20]
   251ec:	f013 fef4 	bl	38fd8 <memcpy>
   251f0:	68a3      	ldr	r3, [r4, #8]
   251f2:	8ae2      	ldrh	r2, [r4, #22]
   251f4:	f247 0105 	movw	r1, #28677	; 0x7005
   251f8:	4413      	add	r3, r2
   251fa:	60a3      	str	r3, [r4, #8]
   251fc:	682b      	ldr	r3, [r5, #0]
   251fe:	4620      	mov	r0, r4
   25200:	0c1b      	lsrs	r3, r3, #16
   25202:	041b      	lsls	r3, r3, #16
   25204:	f043 0303 	orr.w	r3, r3, #3
   25208:	602b      	str	r3, [r5, #0]
   2520a:	682e      	ldr	r6, [r5, #0]
   2520c:	f7ff f9dc 	bl	245c8 <rpc_ip_client_request_send>
   25210:	4680      	mov	r8, r0
   25212:	b978      	cbnz	r0, 25234 <ip_interface_bind+0x110>
   25214:	466b      	mov	r3, sp
   25216:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2521a:	2104      	movs	r1, #4
   2521c:	4638      	mov	r0, r7
   2521e:	f005 fa6f 	bl	2a700 <interface_socket_wait>
   25222:	4604      	mov	r4, r0
   25224:	b1a0      	cbz	r0, 25250 <ip_interface_bind+0x12c>
   25226:	682b      	ldr	r3, [r5, #0]
   25228:	0c1b      	lsrs	r3, r3, #16
   2522a:	041b      	lsls	r3, r3, #16
   2522c:	f043 0302 	orr.w	r3, r3, #2
   25230:	602b      	str	r3, [r5, #0]
   25232:	e7b6      	b.n	251a2 <ip_interface_bind+0x7e>
   25234:	6820      	ldr	r0, [r4, #0]
   25236:	b108      	cbz	r0, 2523c <ip_interface_bind+0x118>
   25238:	f7ff f9e4 	bl	24604 <rpc_ip_client_data_free>
   2523c:	0c36      	lsrs	r6, r6, #16
   2523e:	0436      	lsls	r6, r6, #16
   25240:	4620      	mov	r0, r4
   25242:	f046 0602 	orr.w	r6, r6, #2
   25246:	f7ff f9d5 	bl	245f4 <rpc_ip_client_message_free>
   2524a:	2423      	movs	r4, #35	; 0x23
   2524c:	602e      	str	r6, [r5, #0]
   2524e:	e7a8      	b.n	251a2 <ip_interface_bind+0x7e>
   25250:	4638      	mov	r0, r7
   25252:	f005 fac9 	bl	2a7e8 <interface_socket_from_handle_get>
   25256:	2800      	cmp	r0, #0
   25258:	d0a8      	beq.n	251ac <ip_interface_bind+0x88>
   2525a:	6844      	ldr	r4, [r0, #4]
   2525c:	2c00      	cmp	r4, #0
   2525e:	d0a5      	beq.n	251ac <ip_interface_bind+0x88>
   25260:	f8c0 8004 	str.w	r8, [r0, #4]
   25264:	e7df      	b.n	25226 <ip_interface_bind+0x102>
   25266:	bf00      	nop

00025268 <ip_interface_listen>:
   25268:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2526c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   25270:	b082      	sub	sp, #8
   25272:	4606      	mov	r6, r0
   25274:	9300      	str	r3, [sp, #0]
   25276:	f005 fab7 	bl	2a7e8 <interface_socket_from_handle_get>
   2527a:	2800      	cmp	r0, #0
   2527c:	d066      	beq.n	2534c <ip_interface_listen+0xe4>
   2527e:	6803      	ldr	r3, [r0, #0]
   25280:	4605      	mov	r5, r0
   25282:	b29b      	uxth	r3, r3
   25284:	2b04      	cmp	r3, #4
   25286:	d161      	bne.n	2534c <ip_interface_listen+0xe4>
   25288:	2100      	movs	r1, #0
   2528a:	4a32      	ldr	r2, [pc, #200]	; (25354 <ip_interface_listen+0xec>)
   2528c:	4630      	mov	r0, r6
   2528e:	f005 f9ff 	bl	2a690 <interface_socket_packet_handler_update>
   25292:	4601      	mov	r1, r0
   25294:	2800      	cmp	r0, #0
   25296:	d15b      	bne.n	25350 <ip_interface_listen+0xe8>
   25298:	a802      	add	r0, sp, #8
   2529a:	f840 1d04 	str.w	r1, [r0, #-4]!
   2529e:	69af      	ldr	r7, [r5, #24]
   252a0:	f7ff f97e 	bl	245a0 <rpc_ip_client_request_alloc>
   252a4:	bba0      	cbnz	r0, 25310 <ip_interface_listen+0xa8>
   252a6:	f247 0308 	movw	r3, #28680	; 0x7008
   252aa:	2208      	movs	r2, #8
   252ac:	9c01      	ldr	r4, [sp, #4]
   252ae:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   252b2:	60e3      	str	r3, [r4, #12]
   252b4:	6127      	str	r7, [r4, #16]
   252b6:	7260      	strb	r0, [r4, #9]
   252b8:	72a0      	strb	r0, [r4, #10]
   252ba:	72e0      	strb	r0, [r4, #11]
   252bc:	7222      	strb	r2, [r4, #8]
   252be:	68a3      	ldr	r3, [r4, #8]
   252c0:	f247 0108 	movw	r1, #28680	; 0x7008
   252c4:	3304      	adds	r3, #4
   252c6:	60a3      	str	r3, [r4, #8]
   252c8:	682b      	ldr	r3, [r5, #0]
   252ca:	4620      	mov	r0, r4
   252cc:	0c1b      	lsrs	r3, r3, #16
   252ce:	041b      	lsls	r3, r3, #16
   252d0:	f043 0306 	orr.w	r3, r3, #6
   252d4:	602b      	str	r3, [r5, #0]
   252d6:	682f      	ldr	r7, [r5, #0]
   252d8:	f7ff f976 	bl	245c8 <rpc_ip_client_request_send>
   252dc:	4680      	mov	r8, r0
   252de:	b9e0      	cbnz	r0, 2531a <ip_interface_listen+0xb2>
   252e0:	466b      	mov	r3, sp
   252e2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   252e6:	2107      	movs	r1, #7
   252e8:	4630      	mov	r0, r6
   252ea:	f005 fa09 	bl	2a700 <interface_socket_wait>
   252ee:	4604      	mov	r4, r0
   252f0:	b308      	cbz	r0, 25336 <ip_interface_listen+0xce>
   252f2:	682b      	ldr	r3, [r5, #0]
   252f4:	0c1b      	lsrs	r3, r3, #16
   252f6:	041b      	lsls	r3, r3, #16
   252f8:	f043 0304 	orr.w	r3, r3, #4
   252fc:	602b      	str	r3, [r5, #0]
   252fe:	4620      	mov	r0, r4
   25300:	f7fa feae 	bl	20060 <bsd_os_errno_set>
   25304:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   25308:	4620      	mov	r0, r4
   2530a:	b002      	add	sp, #8
   2530c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25310:	9c01      	ldr	r4, [sp, #4]
   25312:	2c00      	cmp	r4, #0
   25314:	d1d3      	bne.n	252be <ip_interface_listen+0x56>
   25316:	240c      	movs	r4, #12
   25318:	e7f1      	b.n	252fe <ip_interface_listen+0x96>
   2531a:	6820      	ldr	r0, [r4, #0]
   2531c:	b108      	cbz	r0, 25322 <ip_interface_listen+0xba>
   2531e:	f7ff f971 	bl	24604 <rpc_ip_client_data_free>
   25322:	0c3f      	lsrs	r7, r7, #16
   25324:	043f      	lsls	r7, r7, #16
   25326:	4620      	mov	r0, r4
   25328:	f047 0704 	orr.w	r7, r7, #4
   2532c:	f7ff f962 	bl	245f4 <rpc_ip_client_message_free>
   25330:	2423      	movs	r4, #35	; 0x23
   25332:	602f      	str	r7, [r5, #0]
   25334:	e7e3      	b.n	252fe <ip_interface_listen+0x96>
   25336:	4630      	mov	r0, r6
   25338:	f005 fa56 	bl	2a7e8 <interface_socket_from_handle_get>
   2533c:	2800      	cmp	r0, #0
   2533e:	d0e3      	beq.n	25308 <ip_interface_listen+0xa0>
   25340:	6844      	ldr	r4, [r0, #4]
   25342:	2c00      	cmp	r4, #0
   25344:	d0e0      	beq.n	25308 <ip_interface_listen+0xa0>
   25346:	f8c0 8004 	str.w	r8, [r0, #4]
   2534a:	e7d2      	b.n	252f2 <ip_interface_listen+0x8a>
   2534c:	2409      	movs	r4, #9
   2534e:	e7d6      	b.n	252fe <ip_interface_listen+0x96>
   25350:	2423      	movs	r4, #35	; 0x23
   25352:	e7d4      	b.n	252fe <ip_interface_listen+0x96>
   25354:	00024615 	.word	0x00024615

00025358 <ip_interface_accept>:
   25358:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2535c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25360:	2500      	movs	r5, #0
   25362:	b087      	sub	sp, #28
   25364:	460f      	mov	r7, r1
   25366:	4690      	mov	r8, r2
   25368:	e9cd 5303 	strd	r5, r3, [sp, #12]
   2536c:	4606      	mov	r6, r0
   2536e:	f005 fa3b 	bl	2a7e8 <interface_socket_from_handle_get>
   25372:	4604      	mov	r4, r0
   25374:	2800      	cmp	r0, #0
   25376:	f000 8123 	beq.w	255c0 <ip_interface_accept+0x268>
   2537a:	6803      	ldr	r3, [r0, #0]
   2537c:	b29b      	uxth	r3, r3
   2537e:	2b07      	cmp	r3, #7
   25380:	d10a      	bne.n	25398 <ip_interface_accept+0x40>
   25382:	6803      	ldr	r3, [r0, #0]
   25384:	6805      	ldr	r5, [r0, #0]
   25386:	00db      	lsls	r3, r3, #3
   25388:	d416      	bmi.n	253b8 <ip_interface_accept+0x60>
   2538a:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   2538e:	d019      	beq.n	253c4 <ip_interface_accept+0x6c>
   25390:	6805      	ldr	r5, [r0, #0]
   25392:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   25396:	d124      	bne.n	253e2 <ip_interface_accept+0x8a>
   25398:	f04f 0909 	mov.w	r9, #9
   2539c:	9b03      	ldr	r3, [sp, #12]
   2539e:	b113      	cbz	r3, 253a6 <ip_interface_accept+0x4e>
   253a0:	4628      	mov	r0, r5
   253a2:	f005 f95f 	bl	2a664 <interface_socket_free>
   253a6:	4648      	mov	r0, r9
   253a8:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   253ac:	f7fa fe58 	bl	20060 <bsd_os_errno_set>
   253b0:	4648      	mov	r0, r9
   253b2:	b007      	add	sp, #28
   253b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   253b8:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   253bc:	d170      	bne.n	254a0 <ip_interface_accept+0x148>
   253be:	f04f 0923 	mov.w	r9, #35	; 0x23
   253c2:	e7eb      	b.n	2539c <ip_interface_accept+0x44>
   253c4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   253c8:	ab04      	add	r3, sp, #16
   253ca:	4611      	mov	r1, r2
   253cc:	4630      	mov	r0, r6
   253ce:	f005 f997 	bl	2a700 <interface_socket_wait>
   253d2:	4681      	mov	r9, r0
   253d4:	2800      	cmp	r0, #0
   253d6:	f000 8082 	beq.w	254de <ip_interface_accept+0x186>
   253da:	6825      	ldr	r5, [r4, #0]
   253dc:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
   253e0:	d0dc      	beq.n	2539c <ip_interface_accept+0x44>
   253e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   253e6:	2300      	movs	r3, #0
   253e8:	e9cd 0300 	strd	r0, r3, [sp]
   253ec:	4a78      	ldr	r2, [pc, #480]	; (255d0 <ip_interface_accept+0x278>)
   253ee:	6921      	ldr	r1, [r4, #16]
   253f0:	a803      	add	r0, sp, #12
   253f2:	f005 f8d3 	bl	2a59c <interface_socket_allocate>
   253f6:	9b03      	ldr	r3, [sp, #12]
   253f8:	4605      	mov	r5, r0
   253fa:	2b00      	cmp	r3, #0
   253fc:	f000 80e4 	beq.w	255c8 <ip_interface_accept+0x270>
   25400:	2100      	movs	r1, #0
   25402:	6962      	ldr	r2, [r4, #20]
   25404:	a806      	add	r0, sp, #24
   25406:	615a      	str	r2, [r3, #20]
   25408:	68e2      	ldr	r2, [r4, #12]
   2540a:	f840 1d04 	str.w	r1, [r0, #-4]!
   2540e:	60da      	str	r2, [r3, #12]
   25410:	6922      	ldr	r2, [r4, #16]
   25412:	611a      	str	r2, [r3, #16]
   25414:	f8d4 9018 	ldr.w	r9, [r4, #24]
   25418:	f7ff f8c2 	bl	245a0 <rpc_ip_client_request_alloc>
   2541c:	2800      	cmp	r0, #0
   2541e:	d146      	bne.n	254ae <ip_interface_accept+0x156>
   25420:	f247 030c 	movw	r3, #28684	; 0x700c
   25424:	2108      	movs	r1, #8
   25426:	f8dd b014 	ldr.w	fp, [sp, #20]
   2542a:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
   2542e:	f8cb 300c 	str.w	r3, [fp, #12]
   25432:	f8cb 9010 	str.w	r9, [fp, #16]
   25436:	f88b 0009 	strb.w	r0, [fp, #9]
   2543a:	f88b 000a 	strb.w	r0, [fp, #10]
   2543e:	f88b 000b 	strb.w	r0, [fp, #11]
   25442:	f88b 1008 	strb.w	r1, [fp, #8]
   25446:	6823      	ldr	r3, [r4, #0]
   25448:	f247 010c 	movw	r1, #28684	; 0x700c
   2544c:	0c1b      	lsrs	r3, r3, #16
   2544e:	041b      	lsls	r3, r3, #16
   25450:	f043 0308 	orr.w	r3, r3, #8
   25454:	6023      	str	r3, [r4, #0]
   25456:	4658      	mov	r0, fp
   25458:	f8d4 9000 	ldr.w	r9, [r4]
   2545c:	f7ff f8b4 	bl	245c8 <rpc_ip_client_request_send>
   25460:	4682      	mov	sl, r0
   25462:	bb60      	cbnz	r0, 254be <ip_interface_accept+0x166>
   25464:	6822      	ldr	r2, [r4, #0]
   25466:	9900      	ldr	r1, [sp, #0]
   25468:	ab04      	add	r3, sp, #16
   2546a:	400a      	ands	r2, r1
   2546c:	6022      	str	r2, [r4, #0]
   2546e:	2109      	movs	r1, #9
   25470:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25474:	4630      	mov	r0, r6
   25476:	f005 f943 	bl	2a700 <interface_socket_wait>
   2547a:	4681      	mov	r9, r0
   2547c:	2800      	cmp	r0, #0
   2547e:	f000 808d 	beq.w	2559c <ip_interface_accept+0x244>
   25482:	6823      	ldr	r3, [r4, #0]
   25484:	9a01      	ldr	r2, [sp, #4]
   25486:	431a      	orrs	r2, r3
   25488:	6022      	str	r2, [r4, #0]
   2548a:	6823      	ldr	r3, [r4, #0]
   2548c:	0c1b      	lsrs	r3, r3, #16
   2548e:	041b      	lsls	r3, r3, #16
   25490:	f043 0307 	orr.w	r3, r3, #7
   25494:	6023      	str	r3, [r4, #0]
   25496:	6823      	ldr	r3, [r4, #0]
   25498:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2549c:	6023      	str	r3, [r4, #0]
   2549e:	e77d      	b.n	2539c <ip_interface_accept+0x44>
   254a0:	f06f 5280 	mvn.w	r2, #268435456	; 0x10000000
   254a4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   254a8:	e9cd 2300 	strd	r2, r3, [sp]
   254ac:	e79e      	b.n	253ec <ip_interface_accept+0x94>
   254ae:	f8dd b014 	ldr.w	fp, [sp, #20]
   254b2:	f04f 090c 	mov.w	r9, #12
   254b6:	f1bb 0f00 	cmp.w	fp, #0
   254ba:	d1c4      	bne.n	25446 <ip_interface_accept+0xee>
   254bc:	e76e      	b.n	2539c <ip_interface_accept+0x44>
   254be:	f8db 0000 	ldr.w	r0, [fp]
   254c2:	b108      	cbz	r0, 254c8 <ip_interface_accept+0x170>
   254c4:	f7ff f89e 	bl	24604 <rpc_ip_client_data_free>
   254c8:	ea4f 4919 	mov.w	r9, r9, lsr #16
   254cc:	4658      	mov	r0, fp
   254ce:	ea4f 4909 	mov.w	r9, r9, lsl #16
   254d2:	f7ff f88f 	bl	245f4 <rpc_ip_client_message_free>
   254d6:	f049 0307 	orr.w	r3, r9, #7
   254da:	6023      	str	r3, [r4, #0]
   254dc:	e76f      	b.n	253be <ip_interface_accept+0x66>
   254de:	4630      	mov	r0, r6
   254e0:	f005 f982 	bl	2a7e8 <interface_socket_from_handle_get>
   254e4:	b130      	cbz	r0, 254f4 <ip_interface_accept+0x19c>
   254e6:	f8d0 9004 	ldr.w	r9, [r0, #4]
   254ea:	f1b9 0f00 	cmp.w	r9, #0
   254ee:	d001      	beq.n	254f4 <ip_interface_accept+0x19c>
   254f0:	6045      	str	r5, [r0, #4]
   254f2:	e772      	b.n	253da <ip_interface_accept+0x82>
   254f4:	6823      	ldr	r3, [r4, #0]
   254f6:	03d9      	lsls	r1, r3, #15
   254f8:	f53f af73 	bmi.w	253e2 <ip_interface_accept+0x8a>
   254fc:	4d35      	ldr	r5, [pc, #212]	; (255d4 <ip_interface_accept+0x27c>)
   254fe:	9903      	ldr	r1, [sp, #12]
   25500:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   25504:	699b      	ldr	r3, [r3, #24]
   25506:	618b      	str	r3, [r1, #24]
   25508:	b147      	cbz	r7, 2551c <ip_interface_accept+0x1c4>
   2550a:	68cb      	ldr	r3, [r1, #12]
   2550c:	2b0a      	cmp	r3, #10
   2550e:	d028      	beq.n	25562 <ip_interface_accept+0x20a>
   25510:	2b02      	cmp	r3, #2
   25512:	d103      	bne.n	2551c <ip_interface_accept+0x1c4>
   25514:	f8d8 2000 	ldr.w	r2, [r8]
   25518:	2a10      	cmp	r2, #16
   2551a:	d036      	beq.n	2558a <ip_interface_accept+0x232>
   2551c:	680a      	ldr	r2, [r1, #0]
   2551e:	482e      	ldr	r0, [pc, #184]	; (255d8 <ip_interface_accept+0x280>)
   25520:	4002      	ands	r2, r0
   25522:	f042 0205 	orr.w	r2, r2, #5
   25526:	600a      	str	r2, [r1, #0]
   25528:	9a03      	ldr	r2, [sp, #12]
   2552a:	6811      	ldr	r1, [r2, #0]
   2552c:	f441 3100 	orr.w	r1, r1, #131072	; 0x20000
   25530:	6011      	str	r1, [r2, #0]
   25532:	6811      	ldr	r1, [r2, #0]
   25534:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   25538:	6011      	str	r1, [r2, #0]
   2553a:	6823      	ldr	r3, [r4, #0]
   2553c:	4003      	ands	r3, r0
   2553e:	f043 0307 	orr.w	r3, r3, #7
   25542:	6023      	str	r3, [r4, #0]
   25544:	6823      	ldr	r3, [r4, #0]
   25546:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2554a:	6023      	str	r3, [r4, #0]
   2554c:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
   25550:	f7ff f850 	bl	245f4 <rpc_ip_client_message_free>
   25554:	2300      	movs	r3, #0
   25556:	4648      	mov	r0, r9
   25558:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
   2555c:	b007      	add	sp, #28
   2555e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25562:	f8d8 2000 	ldr.w	r2, [r8]
   25566:	2a24      	cmp	r2, #36	; 0x24
   25568:	d1d8      	bne.n	2551c <ip_interface_accept+0x1c4>
   2556a:	703a      	strb	r2, [r7, #0]
   2556c:	2210      	movs	r2, #16
   2556e:	607b      	str	r3, [r7, #4]
   25570:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   25574:	f107 0010 	add.w	r0, r7, #16
   25578:	8b9b      	ldrh	r3, [r3, #28]
   2557a:	813b      	strh	r3, [r7, #8]
   2557c:	f855 1026 	ldr.w	r1, [r5, r6, lsl #2]
   25580:	3120      	adds	r1, #32
   25582:	f013 fd29 	bl	38fd8 <memcpy>
   25586:	9903      	ldr	r1, [sp, #12]
   25588:	e7c8      	b.n	2551c <ip_interface_accept+0x1c4>
   2558a:	703a      	strb	r2, [r7, #0]
   2558c:	607b      	str	r3, [r7, #4]
   2558e:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
   25592:	f107 000c 	add.w	r0, r7, #12
   25596:	8b9b      	ldrh	r3, [r3, #28]
   25598:	2204      	movs	r2, #4
   2559a:	e7ee      	b.n	2557a <ip_interface_accept+0x222>
   2559c:	4630      	mov	r0, r6
   2559e:	f005 f923 	bl	2a7e8 <interface_socket_from_handle_get>
   255a2:	b138      	cbz	r0, 255b4 <ip_interface_accept+0x25c>
   255a4:	f8d0 9004 	ldr.w	r9, [r0, #4]
   255a8:	f1b9 0f00 	cmp.w	r9, #0
   255ac:	d002      	beq.n	255b4 <ip_interface_accept+0x25c>
   255ae:	f8c0 a004 	str.w	sl, [r0, #4]
   255b2:	e766      	b.n	25482 <ip_interface_accept+0x12a>
   255b4:	6823      	ldr	r3, [r4, #0]
   255b6:	9a01      	ldr	r2, [sp, #4]
   255b8:	46a9      	mov	r9, r5
   255ba:	4313      	orrs	r3, r2
   255bc:	6023      	str	r3, [r4, #0]
   255be:	e79d      	b.n	254fc <ip_interface_accept+0x1a4>
   255c0:	4605      	mov	r5, r0
   255c2:	f04f 0909 	mov.w	r9, #9
   255c6:	e6e9      	b.n	2539c <ip_interface_accept+0x44>
   255c8:	f04f 090c 	mov.w	r9, #12
   255cc:	e6eb      	b.n	253a6 <ip_interface_accept+0x4e>
   255ce:	bf00      	nop
   255d0:	00024615 	.word	0x00024615
   255d4:	200226e0 	.word	0x200226e0
   255d8:	ffff0000 	.word	0xffff0000

000255dc <ip_interface_setopt>:
   255dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   255e0:	2901      	cmp	r1, #1
   255e2:	b086      	sub	sp, #24
   255e4:	f040 80df 	bne.w	257a6 <ip_interface_setopt+0x1ca>
   255e8:	4616      	mov	r6, r2
   255ea:	461d      	mov	r5, r3
   255ec:	4607      	mov	r7, r0
   255ee:	f005 f8fb 	bl	2a7e8 <interface_socket_from_handle_get>
   255f2:	4604      	mov	r4, r0
   255f4:	2800      	cmp	r0, #0
   255f6:	f000 80f1 	beq.w	257dc <ip_interface_setopt+0x200>
   255fa:	f1a6 0119 	sub.w	r1, r6, #25
   255fe:	290f      	cmp	r1, #15
   25600:	f200 80bd 	bhi.w	2577e <ip_interface_setopt+0x1a2>
   25604:	e8df f001 	tbb	[pc, r1]
   25608:	bbbbbb17 	.word	0xbbbbbb17
   2560c:	ab9b8bbb 	.word	0xab9b8bbb
   25610:	bbbbbbbb 	.word	0xbbbbbbbb
   25614:	08bbbbbb 	.word	0x08bbbbbb
   25618:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2561a:	4602      	mov	r2, r0
   2561c:	e9cd 5300 	strd	r5, r3, [sp]
   25620:	f241 0104 	movw	r1, #4100	; 0x1004
   25624:	463b      	mov	r3, r7
   25626:	2008      	movs	r0, #8
   25628:	f7ff f800 	bl	2462c <setopt_check_and_send_int>
   2562c:	4605      	mov	r5, r0
   2562e:	4628      	mov	r0, r5
   25630:	b006      	add	sp, #24
   25632:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25636:	2d00      	cmp	r5, #0
   25638:	f000 80c3 	beq.w	257c2 <ip_interface_setopt+0x1e6>
   2563c:	4628      	mov	r0, r5
   2563e:	f7ec fd1f 	bl	12080 <strlen>
   25642:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25644:	4298      	cmp	r0, r3
   25646:	f040 80bc 	bne.w	257c2 <ip_interface_setopt+0x1e6>
   2564a:	6823      	ldr	r3, [r4, #0]
   2564c:	b29b      	uxth	r3, r3
   2564e:	2b02      	cmp	r3, #2
   25650:	f040 80af 	bne.w	257b2 <ip_interface_setopt+0x1d6>
   25654:	4629      	mov	r1, r5
   25656:	68e0      	ldr	r0, [r4, #12]
   25658:	f002 fe3a 	bl	282d0 <pdn_interface_pdn_id_get>
   2565c:	9003      	str	r0, [sp, #12]
   2565e:	3001      	adds	r0, #1
   25660:	bf08      	it	eq
   25662:	2516      	moveq	r5, #22
   25664:	f000 8099 	beq.w	2579a <ip_interface_setopt+0x1be>
   25668:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2566c:	9304      	str	r3, [sp, #16]
   2566e:	6823      	ldr	r3, [r4, #0]
   25670:	0259      	lsls	r1, r3, #9
   25672:	f100 8091 	bmi.w	25798 <ip_interface_setopt+0x1bc>
   25676:	6823      	ldr	r3, [r4, #0]
   25678:	021a      	lsls	r2, r3, #8
   2567a:	f100 808d 	bmi.w	25798 <ip_interface_setopt+0x1bc>
   2567e:	6823      	ldr	r3, [r4, #0]
   25680:	01db      	lsls	r3, r3, #7
   25682:	f100 8089 	bmi.w	25798 <ip_interface_setopt+0x1bc>
   25686:	6823      	ldr	r3, [r4, #0]
   25688:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   2568c:	f040 8084 	bne.w	25798 <ip_interface_setopt+0x1bc>
   25690:	6826      	ldr	r6, [r4, #0]
   25692:	6822      	ldr	r2, [r4, #0]
   25694:	a806      	add	r0, sp, #24
   25696:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
   2569a:	6022      	str	r2, [r4, #0]
   2569c:	2104      	movs	r1, #4
   2569e:	f840 3d04 	str.w	r3, [r0, #-4]!
   256a2:	f8d4 8018 	ldr.w	r8, [r4, #24]
   256a6:	f7fe ff7b 	bl	245a0 <rpc_ip_client_request_alloc>
   256aa:	2800      	cmp	r0, #0
   256ac:	f040 8083 	bne.w	257b6 <ip_interface_setopt+0x1da>
   256b0:	f247 0303 	movw	r3, #28675	; 0x7003
   256b4:	2208      	movs	r2, #8
   256b6:	9d05      	ldr	r5, [sp, #20]
   256b8:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
   256bc:	60eb      	str	r3, [r5, #12]
   256be:	f8c5 8010 	str.w	r8, [r5, #16]
   256c2:	7268      	strb	r0, [r5, #9]
   256c4:	72a8      	strb	r0, [r5, #10]
   256c6:	72e8      	strb	r0, [r5, #11]
   256c8:	722a      	strb	r2, [r5, #8]
   256ca:	f04f 0c08 	mov.w	ip, #8
   256ce:	2300      	movs	r3, #0
   256d0:	2010      	movs	r0, #16
   256d2:	2130      	movs	r1, #48	; 0x30
   256d4:	68aa      	ldr	r2, [r5, #8]
   256d6:	756b      	strb	r3, [r5, #21]
   256d8:	4462      	add	r2, ip
   256da:	60aa      	str	r2, [r5, #8]
   256dc:	75ab      	strb	r3, [r5, #22]
   256de:	75eb      	strb	r3, [r5, #23]
   256e0:	76ab      	strb	r3, [r5, #26]
   256e2:	76eb      	strb	r3, [r5, #27]
   256e4:	f885 c014 	strb.w	ip, [r5, #20]
   256e8:	7628      	strb	r0, [r5, #24]
   256ea:	7669      	strb	r1, [r5, #25]
   256ec:	2204      	movs	r2, #4
   256ee:	a903      	add	r1, sp, #12
   256f0:	6828      	ldr	r0, [r5, #0]
   256f2:	f013 fc71 	bl	38fd8 <memcpy>
   256f6:	f247 0103 	movw	r1, #28675	; 0x7003
   256fa:	4628      	mov	r0, r5
   256fc:	f7fe ff64 	bl	245c8 <rpc_ip_client_request_send>
   25700:	4680      	mov	r8, r0
   25702:	2800      	cmp	r0, #0
   25704:	d15f      	bne.n	257c6 <ip_interface_setopt+0x1ea>
   25706:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
   2570a:	ab04      	add	r3, sp, #16
   2570c:	4611      	mov	r1, r2
   2570e:	4638      	mov	r0, r7
   25710:	f004 fff6 	bl	2a700 <interface_socket_wait>
   25714:	4605      	mov	r5, r0
   25716:	2800      	cmp	r0, #0
   25718:	d066      	beq.n	257e8 <ip_interface_setopt+0x20c>
   2571a:	6026      	str	r6, [r4, #0]
   2571c:	e03d      	b.n	2579a <ip_interface_setopt+0x1be>
   2571e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25720:	4602      	mov	r2, r0
   25722:	e9cd 5300 	strd	r5, r3, [sp]
   25726:	f248 0101 	movw	r1, #32769	; 0x8001
   2572a:	463b      	mov	r3, r7
   2572c:	f44f 7000 	mov.w	r0, #512	; 0x200
   25730:	f7fe ff7c 	bl	2462c <setopt_check_and_send_int>
   25734:	4605      	mov	r5, r0
   25736:	4628      	mov	r0, r5
   25738:	b006      	add	sp, #24
   2573a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2573e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25740:	4602      	mov	r2, r0
   25742:	e9cd 5300 	strd	r5, r3, [sp]
   25746:	f244 0110 	movw	r1, #16400	; 0x4010
   2574a:	463b      	mov	r3, r7
   2574c:	f44f 7000 	mov.w	r0, #512	; 0x200
   25750:	f7fe ff6c 	bl	2462c <setopt_check_and_send_int>
   25754:	4605      	mov	r5, r0
   25756:	4628      	mov	r0, r5
   25758:	b006      	add	sp, #24
   2575a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2575e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25760:	4602      	mov	r2, r0
   25762:	e9cd 5300 	strd	r5, r3, [sp]
   25766:	f246 0110 	movw	r1, #24592	; 0x6010
   2576a:	463b      	mov	r3, r7
   2576c:	f44f 7000 	mov.w	r0, #512	; 0x200
   25770:	f7fe ff5c 	bl	2462c <setopt_check_and_send_int>
   25774:	4605      	mov	r5, r0
   25776:	4628      	mov	r0, r5
   25778:	b006      	add	sp, #24
   2577a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2577e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   25780:	4632      	mov	r2, r6
   25782:	9300      	str	r3, [sp, #0]
   25784:	4638      	mov	r0, r7
   25786:	462b      	mov	r3, r5
   25788:	2101      	movs	r1, #1
   2578a:	f005 f855 	bl	2a838 <interface_socket_setopt>
   2578e:	4605      	mov	r5, r0
   25790:	4628      	mov	r0, r5
   25792:	b006      	add	sp, #24
   25794:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   25798:	2523      	movs	r5, #35	; 0x23
   2579a:	4628      	mov	r0, r5
   2579c:	f7fa fc60 	bl	20060 <bsd_os_errno_set>
   257a0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   257a4:	e743      	b.n	2562e <ip_interface_setopt+0x52>
   257a6:	202a      	movs	r0, #42	; 0x2a
   257a8:	f7fa fc5a 	bl	20060 <bsd_os_errno_set>
   257ac:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   257b0:	e73d      	b.n	2562e <ip_interface_setopt+0x52>
   257b2:	2509      	movs	r5, #9
   257b4:	e7f1      	b.n	2579a <ip_interface_setopt+0x1be>
   257b6:	9d05      	ldr	r5, [sp, #20]
   257b8:	2d00      	cmp	r5, #0
   257ba:	d186      	bne.n	256ca <ip_interface_setopt+0xee>
   257bc:	6026      	str	r6, [r4, #0]
   257be:	250c      	movs	r5, #12
   257c0:	e7eb      	b.n	2579a <ip_interface_setopt+0x1be>
   257c2:	250e      	movs	r5, #14
   257c4:	e7e9      	b.n	2579a <ip_interface_setopt+0x1be>
   257c6:	6828      	ldr	r0, [r5, #0]
   257c8:	b108      	cbz	r0, 257ce <ip_interface_setopt+0x1f2>
   257ca:	f7fe ff1b 	bl	24604 <rpc_ip_client_data_free>
   257ce:	4628      	mov	r0, r5
   257d0:	f7fe ff10 	bl	245f4 <rpc_ip_client_message_free>
   257d4:	2523      	movs	r5, #35	; 0x23
   257d6:	6026      	str	r6, [r4, #0]
   257d8:	6026      	str	r6, [r4, #0]
   257da:	e7de      	b.n	2579a <ip_interface_setopt+0x1be>
   257dc:	2009      	movs	r0, #9
   257de:	f7fa fc3f 	bl	20060 <bsd_os_errno_set>
   257e2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   257e6:	e722      	b.n	2562e <ip_interface_setopt+0x52>
   257e8:	4638      	mov	r0, r7
   257ea:	f004 fffd 	bl	2a7e8 <interface_socket_from_handle_get>
   257ee:	b120      	cbz	r0, 257fa <ip_interface_setopt+0x21e>
   257f0:	6845      	ldr	r5, [r0, #4]
   257f2:	b115      	cbz	r5, 257fa <ip_interface_setopt+0x21e>
   257f4:	f8c0 8004 	str.w	r8, [r0, #4]
   257f8:	e78f      	b.n	2571a <ip_interface_setopt+0x13e>
   257fa:	6026      	str	r6, [r4, #0]
   257fc:	e717      	b.n	2562e <ip_interface_setopt+0x52>
   257fe:	bf00      	nop

00025800 <ip_interface_getopt>:
   25800:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25804:	2901      	cmp	r1, #1
   25806:	b085      	sub	sp, #20
   25808:	9d0e      	ldr	r5, [sp, #56]	; 0x38
   2580a:	f040 8158 	bne.w	25abe <ip_interface_getopt+0x2be>
   2580e:	4616      	mov	r6, r2
   25810:	461f      	mov	r7, r3
   25812:	4680      	mov	r8, r0
   25814:	f004 ffe8 	bl	2a7e8 <interface_socket_from_handle_get>
   25818:	4604      	mov	r4, r0
   2581a:	2800      	cmp	r0, #0
   2581c:	f000 819d 	beq.w	25b5a <ip_interface_getopt+0x35a>
   25820:	f1a6 031e 	sub.w	r3, r6, #30
   25824:	2b0a      	cmp	r3, #10
   25826:	f200 8133 	bhi.w	25a90 <ip_interface_getopt+0x290>
   2582a:	e8df f013 	tbh	[pc, r3, lsl #1]
   2582e:	0055      	.short	0x0055
   25830:	00d60096 	.word	0x00d60096
   25834:	01310131 	.word	0x01310131
   25838:	01310131 	.word	0x01310131
   2583c:	01310131 	.word	0x01310131
   25840:	000b0131 	.word	0x000b0131
   25844:	2d00      	cmp	r5, #0
   25846:	f000 8134 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   2584a:	6829      	ldr	r1, [r5, #0]
   2584c:	2904      	cmp	r1, #4
   2584e:	f040 8130 	bne.w	25ab2 <ip_interface_getopt+0x2b2>
   25852:	2f00      	cmp	r7, #0
   25854:	f000 812d 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   25858:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2585c:	9302      	str	r3, [sp, #8]
   2585e:	6803      	ldr	r3, [r0, #0]
   25860:	0258      	lsls	r0, r3, #9
   25862:	f100 811f 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   25866:	6823      	ldr	r3, [r4, #0]
   25868:	021a      	lsls	r2, r3, #8
   2586a:	f100 811b 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   2586e:	6823      	ldr	r3, [r4, #0]
   25870:	01db      	lsls	r3, r3, #7
   25872:	f100 8117 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   25876:	6823      	ldr	r3, [r4, #0]
   25878:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   2587c:	f040 8112 	bne.w	25aa4 <ip_interface_getopt+0x2a4>
   25880:	6826      	ldr	r6, [r4, #0]
   25882:	6822      	ldr	r2, [r4, #0]
   25884:	a804      	add	r0, sp, #16
   25886:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   2588a:	6022      	str	r2, [r4, #0]
   2588c:	f8d4 9018 	ldr.w	r9, [r4, #24]
   25890:	f840 3d04 	str.w	r3, [r0, #-4]!
   25894:	f7fe fe84 	bl	245a0 <rpc_ip_client_request_alloc>
   25898:	2800      	cmp	r0, #0
   2589a:	f040 812b 	bne.w	25af4 <ip_interface_getopt+0x2f4>
   2589e:	f247 0304 	movw	r3, #28676	; 0x7004
   258a2:	2208      	movs	r2, #8
   258a4:	9d03      	ldr	r5, [sp, #12]
   258a6:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   258aa:	60eb      	str	r3, [r5, #12]
   258ac:	f8c5 9010 	str.w	r9, [r5, #16]
   258b0:	7268      	strb	r0, [r5, #9]
   258b2:	72a8      	strb	r0, [r5, #10]
   258b4:	72e8      	strb	r0, [r5, #11]
   258b6:	722a      	strb	r2, [r5, #8]
   258b8:	f04f 0c08 	mov.w	ip, #8
   258bc:	2300      	movs	r3, #0
   258be:	68aa      	ldr	r2, [r5, #8]
   258c0:	2004      	movs	r0, #4
   258c2:	4462      	add	r2, ip
   258c4:	2110      	movs	r1, #16
   258c6:	756b      	strb	r3, [r5, #21]
   258c8:	60aa      	str	r2, [r5, #8]
   258ca:	75ab      	strb	r3, [r5, #22]
   258cc:	75eb      	strb	r3, [r5, #23]
   258ce:	76ab      	strb	r3, [r5, #26]
   258d0:	76eb      	strb	r3, [r5, #27]
   258d2:	f885 c014 	strb.w	ip, [r5, #20]
   258d6:	e0c1      	b.n	25a5c <ip_interface_getopt+0x25c>
   258d8:	2d00      	cmp	r5, #0
   258da:	f000 80ea 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   258de:	6829      	ldr	r1, [r5, #0]
   258e0:	2904      	cmp	r1, #4
   258e2:	f040 80e6 	bne.w	25ab2 <ip_interface_getopt+0x2b2>
   258e6:	2f00      	cmp	r7, #0
   258e8:	f000 80e3 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   258ec:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   258f0:	9302      	str	r3, [sp, #8]
   258f2:	6803      	ldr	r3, [r0, #0]
   258f4:	025a      	lsls	r2, r3, #9
   258f6:	f100 80d5 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   258fa:	6803      	ldr	r3, [r0, #0]
   258fc:	021b      	lsls	r3, r3, #8
   258fe:	f100 80d1 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   25902:	6803      	ldr	r3, [r0, #0]
   25904:	01de      	lsls	r6, r3, #7
   25906:	f100 80cd 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   2590a:	6803      	ldr	r3, [r0, #0]
   2590c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   25910:	f040 80c8 	bne.w	25aa4 <ip_interface_getopt+0x2a4>
   25914:	6826      	ldr	r6, [r4, #0]
   25916:	6822      	ldr	r2, [r4, #0]
   25918:	a804      	add	r0, sp, #16
   2591a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   2591e:	6022      	str	r2, [r4, #0]
   25920:	f8d4 9018 	ldr.w	r9, [r4, #24]
   25924:	f840 3d04 	str.w	r3, [r0, #-4]!
   25928:	f7fe fe3a 	bl	245a0 <rpc_ip_client_request_alloc>
   2592c:	2800      	cmp	r0, #0
   2592e:	f040 80da 	bne.w	25ae6 <ip_interface_getopt+0x2e6>
   25932:	f247 0304 	movw	r3, #28676	; 0x7004
   25936:	2208      	movs	r2, #8
   25938:	9d03      	ldr	r5, [sp, #12]
   2593a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   2593e:	60eb      	str	r3, [r5, #12]
   25940:	f8c5 9010 	str.w	r9, [r5, #16]
   25944:	7268      	strb	r0, [r5, #9]
   25946:	72a8      	strb	r0, [r5, #10]
   25948:	72e8      	strb	r0, [r5, #11]
   2594a:	722a      	strb	r2, [r5, #8]
   2594c:	2300      	movs	r3, #0
   2594e:	f04f 0c02 	mov.w	ip, #2
   25952:	2001      	movs	r0, #1
   25954:	f06f 017f 	mvn.w	r1, #127	; 0x7f
   25958:	e076      	b.n	25a48 <ip_interface_getopt+0x248>
   2595a:	2d00      	cmp	r5, #0
   2595c:	f000 80a9 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   25960:	6829      	ldr	r1, [r5, #0]
   25962:	2904      	cmp	r1, #4
   25964:	f040 80a5 	bne.w	25ab2 <ip_interface_getopt+0x2b2>
   25968:	2f00      	cmp	r7, #0
   2596a:	f000 80a2 	beq.w	25ab2 <ip_interface_getopt+0x2b2>
   2596e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25972:	9302      	str	r3, [sp, #8]
   25974:	6803      	ldr	r3, [r0, #0]
   25976:	025d      	lsls	r5, r3, #9
   25978:	f100 8094 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   2597c:	6803      	ldr	r3, [r0, #0]
   2597e:	0218      	lsls	r0, r3, #8
   25980:	f100 8090 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   25984:	6823      	ldr	r3, [r4, #0]
   25986:	01da      	lsls	r2, r3, #7
   25988:	f100 808c 	bmi.w	25aa4 <ip_interface_getopt+0x2a4>
   2598c:	6823      	ldr	r3, [r4, #0]
   2598e:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   25992:	f040 8087 	bne.w	25aa4 <ip_interface_getopt+0x2a4>
   25996:	6826      	ldr	r6, [r4, #0]
   25998:	6822      	ldr	r2, [r4, #0]
   2599a:	a804      	add	r0, sp, #16
   2599c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   259a0:	6022      	str	r2, [r4, #0]
   259a2:	f8d4 9018 	ldr.w	r9, [r4, #24]
   259a6:	f840 3d04 	str.w	r3, [r0, #-4]!
   259aa:	f7fe fdf9 	bl	245a0 <rpc_ip_client_request_alloc>
   259ae:	2800      	cmp	r0, #0
   259b0:	f040 80a8 	bne.w	25b04 <ip_interface_getopt+0x304>
   259b4:	f247 0304 	movw	r3, #28676	; 0x7004
   259b8:	2208      	movs	r2, #8
   259ba:	9d03      	ldr	r5, [sp, #12]
   259bc:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   259c0:	60eb      	str	r3, [r5, #12]
   259c2:	f8c5 9010 	str.w	r9, [r5, #16]
   259c6:	7268      	strb	r0, [r5, #9]
   259c8:	72a8      	strb	r0, [r5, #10]
   259ca:	72e8      	strb	r0, [r5, #11]
   259cc:	722a      	strb	r2, [r5, #8]
   259ce:	2300      	movs	r3, #0
   259d0:	f04f 0c02 	mov.w	ip, #2
   259d4:	2010      	movs	r0, #16
   259d6:	2140      	movs	r1, #64	; 0x40
   259d8:	e036      	b.n	25a48 <ip_interface_getopt+0x248>
   259da:	2d00      	cmp	r5, #0
   259dc:	d069      	beq.n	25ab2 <ip_interface_getopt+0x2b2>
   259de:	6829      	ldr	r1, [r5, #0]
   259e0:	2904      	cmp	r1, #4
   259e2:	d166      	bne.n	25ab2 <ip_interface_getopt+0x2b2>
   259e4:	2f00      	cmp	r7, #0
   259e6:	d064      	beq.n	25ab2 <ip_interface_getopt+0x2b2>
   259e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   259ec:	9302      	str	r3, [sp, #8]
   259ee:	6803      	ldr	r3, [r0, #0]
   259f0:	025b      	lsls	r3, r3, #9
   259f2:	d457      	bmi.n	25aa4 <ip_interface_getopt+0x2a4>
   259f4:	6803      	ldr	r3, [r0, #0]
   259f6:	021e      	lsls	r6, r3, #8
   259f8:	d454      	bmi.n	25aa4 <ip_interface_getopt+0x2a4>
   259fa:	6803      	ldr	r3, [r0, #0]
   259fc:	01dd      	lsls	r5, r3, #7
   259fe:	d451      	bmi.n	25aa4 <ip_interface_getopt+0x2a4>
   25a00:	6803      	ldr	r3, [r0, #0]
   25a02:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
   25a06:	d14d      	bne.n	25aa4 <ip_interface_getopt+0x2a4>
   25a08:	6826      	ldr	r6, [r4, #0]
   25a0a:	6822      	ldr	r2, [r4, #0]
   25a0c:	a804      	add	r0, sp, #16
   25a0e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
   25a12:	6022      	str	r2, [r4, #0]
   25a14:	f8d4 9018 	ldr.w	r9, [r4, #24]
   25a18:	f840 3d04 	str.w	r3, [r0, #-4]!
   25a1c:	f7fe fdc0 	bl	245a0 <rpc_ip_client_request_alloc>
   25a20:	2800      	cmp	r0, #0
   25a22:	d16b      	bne.n	25afc <ip_interface_getopt+0x2fc>
   25a24:	f247 0304 	movw	r3, #28676	; 0x7004
   25a28:	2208      	movs	r2, #8
   25a2a:	9d03      	ldr	r5, [sp, #12]
   25a2c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
   25a30:	60eb      	str	r3, [r5, #12]
   25a32:	f8c5 9010 	str.w	r9, [r5, #16]
   25a36:	7268      	strb	r0, [r5, #9]
   25a38:	72a8      	strb	r0, [r5, #10]
   25a3a:	72e8      	strb	r0, [r5, #11]
   25a3c:	722a      	strb	r2, [r5, #8]
   25a3e:	2300      	movs	r3, #0
   25a40:	f04f 0c02 	mov.w	ip, #2
   25a44:	2010      	movs	r0, #16
   25a46:	2160      	movs	r1, #96	; 0x60
   25a48:	68aa      	ldr	r2, [r5, #8]
   25a4a:	752b      	strb	r3, [r5, #20]
   25a4c:	3208      	adds	r2, #8
   25a4e:	60aa      	str	r2, [r5, #8]
   25a50:	75ab      	strb	r3, [r5, #22]
   25a52:	75eb      	strb	r3, [r5, #23]
   25a54:	76ab      	strb	r3, [r5, #26]
   25a56:	76eb      	strb	r3, [r5, #27]
   25a58:	f885 c015 	strb.w	ip, [r5, #21]
   25a5c:	7628      	strb	r0, [r5, #24]
   25a5e:	7669      	strb	r1, [r5, #25]
   25a60:	4628      	mov	r0, r5
   25a62:	f247 0104 	movw	r1, #28676	; 0x7004
   25a66:	f8d5 9000 	ldr.w	r9, [r5]
   25a6a:	f7fe fdad 	bl	245c8 <rpc_ip_client_request_send>
   25a6e:	4682      	mov	sl, r0
   25a70:	bb58      	cbnz	r0, 25aca <ip_interface_getopt+0x2ca>
   25a72:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   25a76:	ab02      	add	r3, sp, #8
   25a78:	4611      	mov	r1, r2
   25a7a:	4640      	mov	r0, r8
   25a7c:	f004 fe40 	bl	2a700 <interface_socket_wait>
   25a80:	4605      	mov	r5, r0
   25a82:	2800      	cmp	r0, #0
   25a84:	d042      	beq.n	25b0c <ip_interface_getopt+0x30c>
   25a86:	4648      	mov	r0, r9
   25a88:	f7fe fdbc 	bl	24604 <rpc_ip_client_data_free>
   25a8c:	6026      	str	r6, [r4, #0]
   25a8e:	e00a      	b.n	25aa6 <ip_interface_getopt+0x2a6>
   25a90:	9500      	str	r5, [sp, #0]
   25a92:	463b      	mov	r3, r7
   25a94:	4632      	mov	r2, r6
   25a96:	4640      	mov	r0, r8
   25a98:	2101      	movs	r1, #1
   25a9a:	f004 ff13 	bl	2a8c4 <interface_socket_getopt>
   25a9e:	b005      	add	sp, #20
   25aa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25aa4:	2523      	movs	r5, #35	; 0x23
   25aa6:	4628      	mov	r0, r5
   25aa8:	f7fa fada 	bl	20060 <bsd_os_errno_set>
   25aac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25ab0:	e7f5      	b.n	25a9e <ip_interface_getopt+0x29e>
   25ab2:	2016      	movs	r0, #22
   25ab4:	f7fa fad4 	bl	20060 <bsd_os_errno_set>
   25ab8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25abc:	e7ef      	b.n	25a9e <ip_interface_getopt+0x29e>
   25abe:	202a      	movs	r0, #42	; 0x2a
   25ac0:	f7fa face 	bl	20060 <bsd_os_errno_set>
   25ac4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25ac8:	e7e9      	b.n	25a9e <ip_interface_getopt+0x29e>
   25aca:	6828      	ldr	r0, [r5, #0]
   25acc:	b108      	cbz	r0, 25ad2 <ip_interface_getopt+0x2d2>
   25ace:	f7fe fd99 	bl	24604 <rpc_ip_client_data_free>
   25ad2:	4628      	mov	r0, r5
   25ad4:	f7fe fd8e 	bl	245f4 <rpc_ip_client_message_free>
   25ad8:	6026      	str	r6, [r4, #0]
   25ada:	4648      	mov	r0, r9
   25adc:	f7fe fd92 	bl	24604 <rpc_ip_client_data_free>
   25ae0:	2523      	movs	r5, #35	; 0x23
   25ae2:	6026      	str	r6, [r4, #0]
   25ae4:	e7df      	b.n	25aa6 <ip_interface_getopt+0x2a6>
   25ae6:	9d03      	ldr	r5, [sp, #12]
   25ae8:	2d00      	cmp	r5, #0
   25aea:	f47f af2f 	bne.w	2594c <ip_interface_getopt+0x14c>
   25aee:	6026      	str	r6, [r4, #0]
   25af0:	250c      	movs	r5, #12
   25af2:	e7d8      	b.n	25aa6 <ip_interface_getopt+0x2a6>
   25af4:	9d03      	ldr	r5, [sp, #12]
   25af6:	2d00      	cmp	r5, #0
   25af8:	d0f9      	beq.n	25aee <ip_interface_getopt+0x2ee>
   25afa:	e6dd      	b.n	258b8 <ip_interface_getopt+0xb8>
   25afc:	9d03      	ldr	r5, [sp, #12]
   25afe:	2d00      	cmp	r5, #0
   25b00:	d0f5      	beq.n	25aee <ip_interface_getopt+0x2ee>
   25b02:	e79c      	b.n	25a3e <ip_interface_getopt+0x23e>
   25b04:	9d03      	ldr	r5, [sp, #12]
   25b06:	2d00      	cmp	r5, #0
   25b08:	d0f1      	beq.n	25aee <ip_interface_getopt+0x2ee>
   25b0a:	e760      	b.n	259ce <ip_interface_getopt+0x1ce>
   25b0c:	4640      	mov	r0, r8
   25b0e:	f004 fe6b 	bl	2a7e8 <interface_socket_from_handle_get>
   25b12:	b120      	cbz	r0, 25b1e <ip_interface_getopt+0x31e>
   25b14:	6845      	ldr	r5, [r0, #4]
   25b16:	b115      	cbz	r5, 25b1e <ip_interface_getopt+0x31e>
   25b18:	f8c0 a004 	str.w	sl, [r0, #4]
   25b1c:	e7b3      	b.n	25a86 <ip_interface_getopt+0x286>
   25b1e:	f8df a08c 	ldr.w	sl, [pc, #140]	; 25bac <ip_interface_getopt+0x3ac>
   25b22:	f85a 5028 	ldr.w	r5, [sl, r8, lsl #2]
   25b26:	b3ad      	cbz	r5, 25b94 <ip_interface_getopt+0x394>
   25b28:	686a      	ldr	r2, [r5, #4]
   25b2a:	2a04      	cmp	r2, #4
   25b2c:	d81b      	bhi.n	25b66 <ip_interface_getopt+0x366>
   25b2e:	f8d5 b000 	ldr.w	fp, [r5]
   25b32:	f1bb 0f00 	cmp.w	fp, #0
   25b36:	d022      	beq.n	25b7e <ip_interface_getopt+0x37e>
   25b38:	2500      	movs	r5, #0
   25b3a:	4659      	mov	r1, fp
   25b3c:	4638      	mov	r0, r7
   25b3e:	f013 fa4b 	bl	38fd8 <memcpy>
   25b42:	f85a 0028 	ldr.w	r0, [sl, r8, lsl #2]
   25b46:	f7fe fd55 	bl	245f4 <rpc_ip_client_message_free>
   25b4a:	4648      	mov	r0, r9
   25b4c:	f84a 5028 	str.w	r5, [sl, r8, lsl #2]
   25b50:	f7fe fd58 	bl	24604 <rpc_ip_client_data_free>
   25b54:	4628      	mov	r0, r5
   25b56:	6026      	str	r6, [r4, #0]
   25b58:	e7a1      	b.n	25a9e <ip_interface_getopt+0x29e>
   25b5a:	2009      	movs	r0, #9
   25b5c:	f7fa fa80 	bl	20060 <bsd_os_errno_set>
   25b60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25b64:	e79b      	b.n	25a9e <ip_interface_getopt+0x29e>
   25b66:	4628      	mov	r0, r5
   25b68:	f7fe fd44 	bl	245f4 <rpc_ip_client_message_free>
   25b6c:	2300      	movs	r3, #0
   25b6e:	4648      	mov	r0, r9
   25b70:	f84a 3028 	str.w	r3, [sl, r8, lsl #2]
   25b74:	2516      	movs	r5, #22
   25b76:	f7fe fd45 	bl	24604 <rpc_ip_client_data_free>
   25b7a:	6026      	str	r6, [r4, #0]
   25b7c:	e793      	b.n	25aa6 <ip_interface_getopt+0x2a6>
   25b7e:	4628      	mov	r0, r5
   25b80:	f7fe fd38 	bl	245f4 <rpc_ip_client_message_free>
   25b84:	4648      	mov	r0, r9
   25b86:	f84a b028 	str.w	fp, [sl, r8, lsl #2]
   25b8a:	2516      	movs	r5, #22
   25b8c:	f7fe fd3a 	bl	24604 <rpc_ip_client_data_free>
   25b90:	6026      	str	r6, [r4, #0]
   25b92:	e788      	b.n	25aa6 <ip_interface_getopt+0x2a6>
   25b94:	2204      	movs	r2, #4
   25b96:	4649      	mov	r1, r9
   25b98:	4638      	mov	r0, r7
   25b9a:	f013 fa1d 	bl	38fd8 <memcpy>
   25b9e:	4648      	mov	r0, r9
   25ba0:	f7fe fd30 	bl	24604 <rpc_ip_client_data_free>
   25ba4:	6026      	str	r6, [r4, #0]
   25ba6:	4628      	mov	r0, r5
   25ba8:	e779      	b.n	25a9e <ip_interface_getopt+0x29e>
   25baa:	bf00      	nop
   25bac:	200226e0 	.word	0x200226e0

00025bb0 <ip_interface_getaddrinfo>:
   25bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25bb4:	f04f 0c00 	mov.w	ip, #0
   25bb8:	2401      	movs	r4, #1
   25bba:	4e75      	ldr	r6, [pc, #468]	; (25d90 <ip_interface_getaddrinfo+0x1e0>)
   25bbc:	4d75      	ldr	r5, [pc, #468]	; (25d94 <ip_interface_getaddrinfo+0x1e4>)
   25bbe:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 25da4 <ip_interface_getaddrinfo+0x1f4>
   25bc2:	4f75      	ldr	r7, [pc, #468]	; (25d98 <ip_interface_getaddrinfo+0x1e8>)
   25bc4:	7836      	ldrb	r6, [r6, #0]
   25bc6:	b085      	sub	sp, #20
   25bc8:	f8a5 c000 	strh.w	ip, [r5]
   25bcc:	f8c8 4000 	str.w	r4, [r8]
   25bd0:	603c      	str	r4, [r7, #0]
   25bd2:	2e00      	cmp	r6, #0
   25bd4:	d05b      	beq.n	25c8e <ip_interface_getaddrinfo+0xde>
   25bd6:	9301      	str	r3, [sp, #4]
   25bd8:	4614      	mov	r4, r2
   25bda:	460b      	mov	r3, r1
   25bdc:	4606      	mov	r6, r0
   25bde:	b171      	cbz	r1, 25bfe <ip_interface_getaddrinfo+0x4e>
   25be0:	4618      	mov	r0, r3
   25be2:	220a      	movs	r2, #10
   25be4:	4661      	mov	r1, ip
   25be6:	f00c fb07 	bl	321f8 <strtol>
   25bea:	f64f 73fe 	movw	r3, #65534	; 0xfffe
   25bee:	1e42      	subs	r2, r0, #1
   25bf0:	429a      	cmp	r2, r3
   25bf2:	f200 8097 	bhi.w	25d24 <ip_interface_getaddrinfo+0x174>
   25bf6:	0203      	lsls	r3, r0, #8
   25bf8:	ea43 2020 	orr.w	r0, r3, r0, asr #8
   25bfc:	8028      	strh	r0, [r5, #0]
   25bfe:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 25da8 <ip_interface_getaddrinfo+0x1f8>
   25c02:	f8da 3000 	ldr.w	r3, [sl]
   25c06:	2b00      	cmp	r3, #0
   25c08:	d145      	bne.n	25c96 <ip_interface_getaddrinfo+0xe6>
   25c0a:	4a64      	ldr	r2, [pc, #400]	; (25d9c <ip_interface_getaddrinfo+0x1ec>)
   25c0c:	6013      	str	r3, [r2, #0]
   25c0e:	4a64      	ldr	r2, [pc, #400]	; (25da0 <ip_interface_getaddrinfo+0x1f0>)
   25c10:	6013      	str	r3, [r2, #0]
   25c12:	2e00      	cmp	r6, #0
   25c14:	d07a      	beq.n	25d0c <ip_interface_getaddrinfo+0x15c>
   25c16:	4630      	mov	r0, r6
   25c18:	f7ec fa32 	bl	12080 <strlen>
   25c1c:	4683      	mov	fp, r0
   25c1e:	b144      	cbz	r4, 25c32 <ip_interface_getaddrinfo+0x82>
   25c20:	69e2      	ldr	r2, [r4, #28]
   25c22:	b132      	cbz	r2, 25c32 <ip_interface_getaddrinfo+0x82>
   25c24:	6851      	ldr	r1, [r2, #4]
   25c26:	2966      	cmp	r1, #102	; 0x66
   25c28:	d103      	bne.n	25c32 <ip_interface_getaddrinfo+0x82>
   25c2a:	6891      	ldr	r1, [r2, #8]
   25c2c:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   25c30:	d07e      	beq.n	25d30 <ip_interface_getaddrinfo+0x180>
   25c32:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   25c36:	2100      	movs	r1, #0
   25c38:	f10d 0910 	add.w	r9, sp, #16
   25c3c:	f849 1d04 	str.w	r1, [r9, #-4]!
   25c40:	4648      	mov	r0, r9
   25c42:	4659      	mov	r1, fp
   25c44:	9200      	str	r2, [sp, #0]
   25c46:	f7fe fcab 	bl	245a0 <rpc_ip_client_request_alloc>
   25c4a:	9a00      	ldr	r2, [sp, #0]
   25c4c:	2800      	cmp	r0, #0
   25c4e:	d15f      	bne.n	25d10 <ip_interface_getaddrinfo+0x160>
   25c50:	f247 010d 	movw	r1, #28685	; 0x700d
   25c54:	f04f 0c08 	mov.w	ip, #8
   25c58:	9d03      	ldr	r5, [sp, #12]
   25c5a:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   25c5e:	60e9      	str	r1, [r5, #12]
   25c60:	612a      	str	r2, [r5, #16]
   25c62:	7268      	strb	r0, [r5, #9]
   25c64:	72a8      	strb	r0, [r5, #10]
   25c66:	72e8      	strb	r0, [r5, #11]
   25c68:	f885 c008 	strb.w	ip, [r5, #8]
   25c6c:	2c00      	cmp	r4, #0
   25c6e:	d076      	beq.n	25d5e <ip_interface_getaddrinfo+0x1ae>
   25c70:	6862      	ldr	r2, [r4, #4]
   25c72:	f022 0108 	bic.w	r1, r2, #8
   25c76:	2902      	cmp	r1, #2
   25c78:	d011      	beq.n	25c9e <ip_interface_getaddrinfo+0xee>
   25c7a:	2a05      	cmp	r2, #5
   25c7c:	d176      	bne.n	25d6c <ip_interface_getaddrinfo+0x1bc>
   25c7e:	68a1      	ldr	r1, [r4, #8]
   25c80:	2902      	cmp	r1, #2
   25c82:	6039      	str	r1, [r7, #0]
   25c84:	d115      	bne.n	25cb2 <ip_interface_getaddrinfo+0x102>
   25c86:	2102      	movs	r1, #2
   25c88:	f8c8 1000 	str.w	r1, [r8]
   25c8c:	e00b      	b.n	25ca6 <ip_interface_getaddrinfo+0xf6>
   25c8e:	2070      	movs	r0, #112	; 0x70
   25c90:	b005      	add	sp, #20
   25c92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25c96:	2073      	movs	r0, #115	; 0x73
   25c98:	b005      	add	sp, #20
   25c9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25c9e:	68a1      	ldr	r1, [r4, #8]
   25ca0:	2902      	cmp	r1, #2
   25ca2:	6039      	str	r1, [r7, #0]
   25ca4:	d0ef      	beq.n	25c86 <ip_interface_getaddrinfo+0xd6>
   25ca6:	2a05      	cmp	r2, #5
   25ca8:	d003      	beq.n	25cb2 <ip_interface_getaddrinfo+0x102>
   25caa:	2a0a      	cmp	r2, #10
   25cac:	bf14      	ite	ne
   25cae:	2201      	movne	r2, #1
   25cb0:	2202      	moveq	r2, #2
   25cb2:	61aa      	str	r2, [r5, #24]
   25cb4:	68e2      	ldr	r2, [r4, #12]
   25cb6:	622a      	str	r2, [r5, #32]
   25cb8:	68a2      	ldr	r2, [r4, #8]
   25cba:	61ea      	str	r2, [r5, #28]
   25cbc:	6822      	ldr	r2, [r4, #0]
   25cbe:	616a      	str	r2, [r5, #20]
   25cc0:	68aa      	ldr	r2, [r5, #8]
   25cc2:	3210      	adds	r2, #16
   25cc4:	60aa      	str	r2, [r5, #8]
   25cc6:	b12e      	cbz	r6, 25cd4 <ip_interface_getaddrinfo+0x124>
   25cc8:	6828      	ldr	r0, [r5, #0]
   25cca:	b118      	cbz	r0, 25cd4 <ip_interface_getaddrinfo+0x124>
   25ccc:	465a      	mov	r2, fp
   25cce:	4631      	mov	r1, r6
   25cd0:	f013 f982 	bl	38fd8 <memcpy>
   25cd4:	2301      	movs	r3, #1
   25cd6:	f247 010d 	movw	r1, #28685	; 0x700d
   25cda:	4628      	mov	r0, r5
   25cdc:	f8ca 3000 	str.w	r3, [sl]
   25ce0:	f7fe fc72 	bl	245c8 <rpc_ip_client_request_send>
   25ce4:	bb10      	cbnz	r0, 25d2c <ip_interface_getaddrinfo+0x17c>
   25ce6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   25cea:	9303      	str	r3, [sp, #12]
   25cec:	4649      	mov	r1, r9
   25cee:	4628      	mov	r0, r5
   25cf0:	f7fa f90c 	bl	1ff0c <bsd_os_timedwait>
   25cf4:	f8da 3000 	ldr.w	r3, [sl]
   25cf8:	2b01      	cmp	r3, #1
   25cfa:	d0f7      	beq.n	25cec <ip_interface_getaddrinfo+0x13c>
   25cfc:	4b28      	ldr	r3, [pc, #160]	; (25da0 <ip_interface_getaddrinfo+0x1f0>)
   25cfe:	6818      	ldr	r0, [r3, #0]
   25d00:	bb40      	cbnz	r0, 25d54 <ip_interface_getaddrinfo+0x1a4>
   25d02:	4b26      	ldr	r3, [pc, #152]	; (25d9c <ip_interface_getaddrinfo+0x1ec>)
   25d04:	9a01      	ldr	r2, [sp, #4]
   25d06:	681b      	ldr	r3, [r3, #0]
   25d08:	6013      	str	r3, [r2, #0]
   25d0a:	e7c1      	b.n	25c90 <ip_interface_getaddrinfo+0xe0>
   25d0c:	46b3      	mov	fp, r6
   25d0e:	e786      	b.n	25c1e <ip_interface_getaddrinfo+0x6e>
   25d10:	9d03      	ldr	r5, [sp, #12]
   25d12:	2d00      	cmp	r5, #0
   25d14:	d1aa      	bne.n	25c6c <ip_interface_getaddrinfo+0xbc>
   25d16:	200c      	movs	r0, #12
   25d18:	2300      	movs	r3, #0
   25d1a:	f8ca 3000 	str.w	r3, [sl]
   25d1e:	b005      	add	sp, #20
   25d20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25d24:	2016      	movs	r0, #22
   25d26:	b005      	add	sp, #20
   25d28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25d2c:	2023      	movs	r0, #35	; 0x23
   25d2e:	e7f3      	b.n	25d18 <ip_interface_getaddrinfo+0x168>
   25d30:	f240 2002 	movw	r0, #514	; 0x202
   25d34:	68d1      	ldr	r1, [r2, #12]
   25d36:	4281      	cmp	r1, r0
   25d38:	f47f af7b 	bne.w	25c32 <ip_interface_getaddrinfo+0x82>
   25d3c:	6991      	ldr	r1, [r2, #24]
   25d3e:	2900      	cmp	r1, #0
   25d40:	f43f af77 	beq.w	25c32 <ip_interface_getaddrinfo+0x82>
   25d44:	6860      	ldr	r0, [r4, #4]
   25d46:	f002 fac3 	bl	282d0 <pdn_interface_pdn_id_get>
   25d4a:	1c43      	adds	r3, r0, #1
   25d4c:	f43f af71 	beq.w	25c32 <ip_interface_getaddrinfo+0x82>
   25d50:	4602      	mov	r2, r0
   25d52:	e770      	b.n	25c36 <ip_interface_getaddrinfo+0x86>
   25d54:	4b12      	ldr	r3, [pc, #72]	; (25da0 <ip_interface_getaddrinfo+0x1f0>)
   25d56:	6818      	ldr	r0, [r3, #0]
   25d58:	2800      	cmp	r0, #0
   25d5a:	d099      	beq.n	25c90 <ip_interface_getaddrinfo+0xe0>
   25d5c:	e7dc      	b.n	25d18 <ip_interface_getaddrinfo+0x168>
   25d5e:	4621      	mov	r1, r4
   25d60:	2210      	movs	r2, #16
   25d62:	f105 0014 	add.w	r0, r5, #20
   25d66:	f013 f971 	bl	3904c <memset>
   25d6a:	e7a9      	b.n	25cc0 <ip_interface_getaddrinfo+0x110>
   25d6c:	202f      	movs	r0, #47	; 0x2f
   25d6e:	f7fa f977 	bl	20060 <bsd_os_errno_set>
   25d72:	68aa      	ldr	r2, [r5, #8]
   25d74:	3210      	adds	r2, #16
   25d76:	60aa      	str	r2, [r5, #8]
   25d78:	b916      	cbnz	r6, 25d80 <ip_interface_getaddrinfo+0x1d0>
   25d7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   25d7e:	e7cb      	b.n	25d18 <ip_interface_getaddrinfo+0x168>
   25d80:	6828      	ldr	r0, [r5, #0]
   25d82:	2800      	cmp	r0, #0
   25d84:	d0f9      	beq.n	25d7a <ip_interface_getaddrinfo+0x1ca>
   25d86:	465a      	mov	r2, fp
   25d88:	4631      	mov	r1, r6
   25d8a:	f013 f925 	bl	38fd8 <memcpy>
   25d8e:	e7f4      	b.n	25d7a <ip_interface_getaddrinfo+0x1ca>
   25d90:	20029086 	.word	0x20029086
   25d94:	2002761c 	.word	0x2002761c
   25d98:	200226d0 	.word	0x200226d0
   25d9c:	200226dc 	.word	0x200226dc
   25da0:	200226d4 	.word	0x200226d4
   25da4:	200226cc 	.word	0x200226cc
   25da8:	200226d8 	.word	0x200226d8

00025dac <ip_interface_freeaddrinfo>:
   25dac:	b538      	push	{r3, r4, r5, lr}
   25dae:	4d0b      	ldr	r5, [pc, #44]	; (25ddc <ip_interface_freeaddrinfo+0x30>)
   25db0:	682b      	ldr	r3, [r5, #0]
   25db2:	2b02      	cmp	r3, #2
   25db4:	d000      	beq.n	25db8 <ip_interface_freeaddrinfo+0xc>
   25db6:	bd38      	pop	{r3, r4, r5, pc}
   25db8:	b150      	cbz	r0, 25dd0 <ip_interface_freeaddrinfo+0x24>
   25dba:	4604      	mov	r4, r0
   25dbc:	6940      	ldr	r0, [r0, #20]
   25dbe:	f004 f8c5 	bl	29f4c <nrf_free>
   25dc2:	69a0      	ldr	r0, [r4, #24]
   25dc4:	b108      	cbz	r0, 25dca <ip_interface_freeaddrinfo+0x1e>
   25dc6:	f004 f8c1 	bl	29f4c <nrf_free>
   25dca:	4620      	mov	r0, r4
   25dcc:	f004 f8be 	bl	29f4c <nrf_free>
   25dd0:	2300      	movs	r3, #0
   25dd2:	4a03      	ldr	r2, [pc, #12]	; (25de0 <ip_interface_freeaddrinfo+0x34>)
   25dd4:	602b      	str	r3, [r5, #0]
   25dd6:	6013      	str	r3, [r2, #0]
   25dd8:	bd38      	pop	{r3, r4, r5, pc}
   25dda:	bf00      	nop
   25ddc:	200226d8 	.word	0x200226d8
   25de0:	200226d4 	.word	0x200226d4

00025de4 <rpc_ip_event_handler>:
   25de4:	f248 030d 	movw	r3, #32781	; 0x800d
   25de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   25dec:	4299      	cmp	r1, r3
   25dee:	b089      	sub	sp, #36	; 0x24
   25df0:	4604      	mov	r4, r0
   25df2:	d05c      	beq.n	25eae <rpc_ip_event_handler+0xca>
   25df4:	f248 030f 	movw	r3, #32783	; 0x800f
   25df8:	4299      	cmp	r1, r3
   25dfa:	460d      	mov	r5, r1
   25dfc:	d045      	beq.n	25e8a <rpc_ip_event_handler+0xa6>
   25dfe:	f401 4310 	and.w	r3, r1, #36864	; 0x9000
   25e02:	f5b3 4f10 	cmp.w	r3, #36864	; 0x9000
   25e06:	68c0      	ldr	r0, [r0, #12]
   25e08:	d075      	beq.n	25ef6 <rpc_ip_event_handler+0x112>
   25e0a:	0c06      	lsrs	r6, r0, #16
   25e0c:	4630      	mov	r0, r6
   25e0e:	f004 fceb 	bl	2a7e8 <interface_socket_from_handle_get>
   25e12:	4607      	mov	r7, r0
   25e14:	2800      	cmp	r0, #0
   25e16:	d059      	beq.n	25ecc <rpc_ip_event_handler+0xe8>
   25e18:	4601      	mov	r1, r0
   25e1a:	462b      	mov	r3, r5
   25e1c:	4622      	mov	r2, r4
   25e1e:	4630      	mov	r0, r6
   25e20:	f7fe fb2c 	bl	2447c <tls_rpc_ip_event_handler>
   25e24:	2800      	cmp	r0, #0
   25e26:	d04d      	beq.n	25ec4 <rpc_ip_event_handler+0xe0>
   25e28:	f248 0307 	movw	r3, #32775	; 0x8007
   25e2c:	429d      	cmp	r5, r3
   25e2e:	d866      	bhi.n	25efe <rpc_ip_event_handler+0x11a>
   25e30:	f248 0306 	movw	r3, #32774	; 0x8006
   25e34:	429d      	cmp	r5, r3
   25e36:	f080 81e7 	bcs.w	26208 <rpc_ip_event_handler+0x424>
   25e3a:	f248 0303 	movw	r3, #32771	; 0x8003
   25e3e:	429d      	cmp	r5, r3
   25e40:	f000 81c5 	beq.w	261ce <rpc_ip_event_handler+0x3ea>
   25e44:	f200 811b 	bhi.w	2607e <rpc_ip_event_handler+0x29a>
   25e48:	f248 0301 	movw	r3, #32769	; 0x8001
   25e4c:	429d      	cmp	r5, r3
   25e4e:	f000 8154 	beq.w	260fa <rpc_ip_event_handler+0x316>
   25e52:	f248 0302 	movw	r3, #32770	; 0x8002
   25e56:	429d      	cmp	r5, r3
   25e58:	d138      	bne.n	25ecc <rpc_ip_event_handler+0xe8>
   25e5a:	683b      	ldr	r3, [r7, #0]
   25e5c:	0098      	lsls	r0, r3, #2
   25e5e:	d531      	bpl.n	25ec4 <rpc_ip_event_handler+0xe0>
   25e60:	683b      	ldr	r3, [r7, #0]
   25e62:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
   25e66:	603b      	str	r3, [r7, #0]
   25e68:	6963      	ldr	r3, [r4, #20]
   25e6a:	2b00      	cmp	r3, #0
   25e6c:	f000 81ea 	beq.w	26244 <rpc_ip_event_handler+0x460>
   25e70:	2b10      	cmp	r3, #16
   25e72:	bf8e      	itee	hi
   25e74:	232d      	movhi	r3, #45	; 0x2d
   25e76:	4ab9      	ldrls	r2, [pc, #740]	; (2615c <rpc_ip_event_handler+0x378>)
   25e78:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   25e7c:	607b      	str	r3, [r7, #4]
   25e7e:	683b      	ldr	r3, [r7, #0]
   25e80:	2000      	movs	r0, #0
   25e82:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   25e86:	603b      	str	r3, [r7, #0]
   25e88:	e00e      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   25e8a:	6943      	ldr	r3, [r0, #20]
   25e8c:	2001      	movs	r0, #1
   25e8e:	2b10      	cmp	r3, #16
   25e90:	49b3      	ldr	r1, [pc, #716]	; (26160 <rpc_ip_event_handler+0x37c>)
   25e92:	bf88      	it	hi
   25e94:	222d      	movhi	r2, #45	; 0x2d
   25e96:	7008      	strb	r0, [r1, #0]
   25e98:	f04f 0000 	mov.w	r0, #0
   25e9c:	bf9c      	itt	ls
   25e9e:	4aaf      	ldrls	r2, [pc, #700]	; (2615c <rpc_ip_event_handler+0x378>)
   25ea0:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
   25ea4:	4baf      	ldr	r3, [pc, #700]	; (26164 <rpc_ip_event_handler+0x380>)
   25ea6:	601a      	str	r2, [r3, #0]
   25ea8:	b009      	add	sp, #36	; 0x24
   25eaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25eae:	f8df a2c8 	ldr.w	sl, [pc, #712]	; 26178 <rpc_ip_event_handler+0x394>
   25eb2:	6807      	ldr	r7, [r0, #0]
   25eb4:	f8da 2000 	ldr.w	r2, [sl]
   25eb8:	2a01      	cmp	r2, #1
   25eba:	d00b      	beq.n	25ed4 <rpc_ip_event_handler+0xf0>
   25ebc:	b117      	cbz	r7, 25ec4 <rpc_ip_event_handler+0xe0>
   25ebe:	4638      	mov	r0, r7
   25ec0:	f7fe fba0 	bl	24604 <rpc_ip_client_data_free>
   25ec4:	2000      	movs	r0, #0
   25ec6:	b009      	add	sp, #36	; 0x24
   25ec8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   25ecc:	6820      	ldr	r0, [r4, #0]
   25ece:	2800      	cmp	r0, #0
   25ed0:	d1f6      	bne.n	25ec0 <rpc_ip_event_handler+0xdc>
   25ed2:	e7f7      	b.n	25ec4 <rpc_ip_event_handler+0xe0>
   25ed4:	6942      	ldr	r2, [r0, #20]
   25ed6:	2a00      	cmp	r2, #0
   25ed8:	d045      	beq.n	25f66 <rpc_ip_event_handler+0x182>
   25eda:	2a10      	cmp	r2, #16
   25edc:	bf8e      	itee	hi
   25ede:	222d      	movhi	r2, #45	; 0x2d
   25ee0:	499e      	ldrls	r1, [pc, #632]	; (2615c <rpc_ip_event_handler+0x378>)
   25ee2:	f851 2022 	ldrls.w	r2, [r1, r2, lsl #2]
   25ee6:	49a0      	ldr	r1, [pc, #640]	; (26168 <rpc_ip_event_handler+0x384>)
   25ee8:	600a      	str	r2, [r1, #0]
   25eea:	2202      	movs	r2, #2
   25eec:	f8ca 2000 	str.w	r2, [sl]
   25ef0:	2f00      	cmp	r7, #0
   25ef2:	d1e4      	bne.n	25ebe <rpc_ip_event_handler+0xda>
   25ef4:	e7e6      	b.n	25ec4 <rpc_ip_event_handler+0xe0>
   25ef6:	f004 fc25 	bl	2a744 <interface_from_internal_id_search>
   25efa:	4606      	mov	r6, r0
   25efc:	e786      	b.n	25e0c <rpc_ip_event_handler+0x28>
   25efe:	f248 030c 	movw	r3, #32780	; 0x800c
   25f02:	429d      	cmp	r5, r3
   25f04:	f000 813c 	beq.w	26180 <rpc_ip_event_handler+0x39c>
   25f08:	f240 80d5 	bls.w	260b6 <rpc_ip_event_handler+0x2d2>
   25f0c:	f249 0302 	movw	r3, #36866	; 0x9002
   25f10:	429d      	cmp	r5, r3
   25f12:	f000 811d 	beq.w	26150 <rpc_ip_event_handler+0x36c>
   25f16:	f249 0303 	movw	r3, #36867	; 0x9003
   25f1a:	429d      	cmp	r5, r3
   25f1c:	f000 80f9 	beq.w	26112 <rpc_ip_event_handler+0x32e>
   25f20:	f249 0301 	movw	r3, #36865	; 0x9001
   25f24:	429d      	cmp	r5, r3
   25f26:	d1d1      	bne.n	25ecc <rpc_ip_event_handler+0xe8>
   25f28:	683d      	ldr	r5, [r7, #0]
   25f2a:	f415 1580 	ands.w	r5, r5, #1048576	; 0x100000
   25f2e:	f000 8184 	beq.w	2623a <rpc_ip_event_handler+0x456>
   25f32:	68a3      	ldr	r3, [r4, #8]
   25f34:	2b04      	cmp	r3, #4
   25f36:	f200 81af 	bhi.w	26298 <rpc_ip_event_handler+0x4b4>
   25f3a:	2500      	movs	r5, #0
   25f3c:	462e      	mov	r6, r5
   25f3e:	6821      	ldr	r1, [r4, #0]
   25f40:	6862      	ldr	r2, [r4, #4]
   25f42:	e9cd 6506 	strd	r6, r5, [sp, #24]
   25f46:	e9cd 1204 	strd	r1, r2, [sp, #16]
   25f4a:	69f8      	ldr	r0, [r7, #28]
   25f4c:	a904      	add	r1, sp, #16
   25f4e:	6803      	ldr	r3, [r0, #0]
   25f50:	685b      	ldr	r3, [r3, #4]
   25f52:	4798      	blx	r3
   25f54:	3001      	adds	r0, #1
   25f56:	f000 818e 	beq.w	26276 <rpc_ip_event_handler+0x492>
   25f5a:	683b      	ldr	r3, [r7, #0]
   25f5c:	2000      	movs	r0, #0
   25f5e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   25f62:	603b      	str	r3, [r7, #0]
   25f64:	e7a0      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   25f66:	6985      	ldr	r5, [r0, #24]
   25f68:	016b      	lsls	r3, r5, #5
   25f6a:	4618      	mov	r0, r3
   25f6c:	9303      	str	r3, [sp, #12]
   25f6e:	f003 ffe3 	bl	29f38 <nrf_malloc>
   25f72:	9002      	str	r0, [sp, #8]
   25f74:	2800      	cmp	r0, #0
   25f76:	d078      	beq.n	2606a <rpc_ip_event_handler+0x286>
   25f78:	00ee      	lsls	r6, r5, #3
   25f7a:	1970      	adds	r0, r6, r5
   25f7c:	0080      	lsls	r0, r0, #2
   25f7e:	f003 ffdb 	bl	29f38 <nrf_malloc>
   25f82:	2800      	cmp	r0, #0
   25f84:	d073      	beq.n	2606e <rpc_ip_event_handler+0x28a>
   25f86:	2d00      	cmp	r5, #0
   25f88:	d074      	beq.n	26074 <rpc_ip_event_handler+0x290>
   25f8a:	3610      	adds	r6, #16
   25f8c:	1983      	adds	r3, r0, r6
   25f8e:	9301      	str	r3, [sp, #4]
   25f90:	9b02      	ldr	r3, [sp, #8]
   25f92:	2204      	movs	r2, #4
   25f94:	f8df b1e4 	ldr.w	fp, [pc, #484]	; 2617c <rpc_ip_event_handler+0x398>
   25f98:	f100 0810 	add.w	r8, r0, #16
   25f9c:	f103 0520 	add.w	r5, r3, #32
   25fa0:	e013      	b.n	25fca <rpc_ip_event_handler+0x1e6>
   25fa2:	464a      	mov	r2, r9
   25fa4:	f013 f818 	bl	38fd8 <memcpy>
   25fa8:	2100      	movs	r1, #0
   25faa:	f855 3c08 	ldr.w	r3, [r5, #-8]
   25fae:	f108 0808 	add.w	r8, r8, #8
   25fb2:	eb09 0206 	add.w	r2, r9, r6
   25fb6:	f803 1009 	strb.w	r1, [r3, r9]
   25fba:	9b01      	ldr	r3, [sp, #4]
   25fbc:	f845 5c04 	str.w	r5, [r5, #-4]
   25fc0:	4598      	cmp	r8, r3
   25fc2:	f105 0520 	add.w	r5, r5, #32
   25fc6:	f000 8090 	beq.w	260ea <rpc_ip_event_handler+0x306>
   25fca:	58bb      	ldr	r3, [r7, r2]
   25fcc:	18b9      	adds	r1, r7, r2
   25fce:	f845 3c20 	str.w	r3, [r5, #-32]
   25fd2:	684b      	ldr	r3, [r1, #4]
   25fd4:	f8db 0000 	ldr.w	r0, [fp]
   25fd8:	2b02      	cmp	r3, #2
   25fda:	bf14      	ite	ne
   25fdc:	2602      	movne	r6, #2
   25fde:	260a      	moveq	r6, #10
   25fe0:	4b62      	ldr	r3, [pc, #392]	; (2616c <rpc_ip_event_handler+0x388>)
   25fe2:	e945 6007 	strd	r6, r0, [r5, #-28]
   25fe6:	681b      	ldr	r3, [r3, #0]
   25fe8:	f102 0614 	add.w	r6, r2, #20
   25fec:	f845 3c14 	str.w	r3, [r5, #-20]
   25ff0:	8a08      	ldrh	r0, [r1, #16]
   25ff2:	f1a8 0310 	sub.w	r3, r8, #16
   25ff6:	f845 0c10 	str.w	r0, [r5, #-16]
   25ffa:	f8b1 9012 	ldrh.w	r9, [r1, #18]
   25ffe:	f845 3c0c 	str.w	r3, [r5, #-12]
   26002:	4b5b      	ldr	r3, [pc, #364]	; (26170 <rpc_ip_event_handler+0x38c>)
   26004:	2804      	cmp	r0, #4
   26006:	eb07 0106 	add.w	r1, r7, r6
   2600a:	881b      	ldrh	r3, [r3, #0]
   2600c:	d01e      	beq.n	2604c <rpc_ip_event_handler+0x268>
   2600e:	220a      	movs	r2, #10
   26010:	f848 2c0c 	str.w	r2, [r8, #-12]
   26014:	f04f 0224 	mov.w	r2, #36	; 0x24
   26018:	f828 3c08 	strh.w	r3, [r8, #-8]
   2601c:	f808 2c10 	strb.w	r2, [r8, #-16]
   26020:	f855 2c10 	ldr.w	r2, [r5, #-16]
   26024:	4640      	mov	r0, r8
   26026:	f012 ffd7 	bl	38fd8 <memcpy>
   2602a:	f855 3c10 	ldr.w	r3, [r5, #-16]
   2602e:	f109 0001 	add.w	r0, r9, #1
   26032:	441e      	add	r6, r3
   26034:	f003 ff80 	bl	29f38 <nrf_malloc>
   26038:	19b9      	adds	r1, r7, r6
   2603a:	eb09 0206 	add.w	r2, r9, r6
   2603e:	f845 0c08 	str.w	r0, [r5, #-8]
   26042:	2800      	cmp	r0, #0
   26044:	d1ad      	bne.n	25fa2 <rpc_ip_event_handler+0x1be>
   26046:	f108 0808 	add.w	r8, r8, #8
   2604a:	e7b6      	b.n	25fba <rpc_ip_event_handler+0x1d6>
   2604c:	2210      	movs	r2, #16
   2604e:	2002      	movs	r0, #2
   26050:	f828 3c08 	strh.w	r3, [r8, #-8]
   26054:	f848 0c0c 	str.w	r0, [r8, #-12]
   26058:	f808 2c10 	strb.w	r2, [r8, #-16]
   2605c:	f855 2c10 	ldr.w	r2, [r5, #-16]
   26060:	f1a8 0004 	sub.w	r0, r8, #4
   26064:	f012 ffb8 	bl	38fd8 <memcpy>
   26068:	e7df      	b.n	2602a <rpc_ip_event_handler+0x246>
   2606a:	f003 ff6f 	bl	29f4c <nrf_free>
   2606e:	210c      	movs	r1, #12
   26070:	4a3d      	ldr	r2, [pc, #244]	; (26168 <rpc_ip_event_handler+0x384>)
   26072:	6011      	str	r1, [r2, #0]
   26074:	9b02      	ldr	r3, [sp, #8]
   26076:	4a3f      	ldr	r2, [pc, #252]	; (26174 <rpc_ip_event_handler+0x390>)
   26078:	6827      	ldr	r7, [r4, #0]
   2607a:	6013      	str	r3, [r2, #0]
   2607c:	e735      	b.n	25eea <rpc_ip_event_handler+0x106>
   2607e:	f248 0304 	movw	r3, #32772	; 0x8004
   26082:	429d      	cmp	r5, r3
   26084:	f000 808f 	beq.w	261a6 <rpc_ip_event_handler+0x3c2>
   26088:	f248 0305 	movw	r3, #32773	; 0x8005
   2608c:	429d      	cmp	r5, r3
   2608e:	f47f af1d 	bne.w	25ecc <rpc_ip_event_handler+0xe8>
   26092:	683b      	ldr	r3, [r7, #0]
   26094:	b29b      	uxth	r3, r3
   26096:	2b03      	cmp	r3, #3
   26098:	f47f af14 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   2609c:	6963      	ldr	r3, [r4, #20]
   2609e:	2b00      	cmp	r3, #0
   260a0:	f000 80eb 	beq.w	2627a <rpc_ip_event_handler+0x496>
   260a4:	2b10      	cmp	r3, #16
   260a6:	f200 80bd 	bhi.w	26224 <rpc_ip_event_handler+0x440>
   260aa:	4a2c      	ldr	r2, [pc, #176]	; (2615c <rpc_ip_event_handler+0x378>)
   260ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   260b0:	607b      	str	r3, [r7, #4]
   260b2:	2000      	movs	r0, #0
   260b4:	e6f8      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   260b6:	f248 0308 	movw	r3, #32776	; 0x8008
   260ba:	429d      	cmp	r5, r3
   260bc:	f000 8094 	beq.w	261e8 <rpc_ip_event_handler+0x404>
   260c0:	f248 0309 	movw	r3, #32777	; 0x8009
   260c4:	429d      	cmp	r5, r3
   260c6:	f47f af01 	bne.w	25ecc <rpc_ip_event_handler+0xe8>
   260ca:	683b      	ldr	r3, [r7, #0]
   260cc:	b29b      	uxth	r3, r3
   260ce:	2b0d      	cmp	r3, #13
   260d0:	f47f aef8 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   260d4:	6960      	ldr	r0, [r4, #20]
   260d6:	2800      	cmp	r0, #0
   260d8:	f000 80d7 	beq.w	2628a <rpc_ip_event_handler+0x4a6>
   260dc:	2810      	cmp	r0, #16
   260de:	f200 80a1 	bhi.w	26224 <rpc_ip_event_handler+0x440>
   260e2:	4b1e      	ldr	r3, [pc, #120]	; (2615c <rpc_ip_event_handler+0x378>)
   260e4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   260e8:	e7e2      	b.n	260b0 <rpc_ip_event_handler+0x2cc>
   260ea:	2100      	movs	r1, #0
   260ec:	e9dd 0302 	ldrd	r0, r3, [sp, #8]
   260f0:	4403      	add	r3, r0
   260f2:	f843 1c04 	str.w	r1, [r3, #-4]
   260f6:	4603      	mov	r3, r0
   260f8:	e7bd      	b.n	26076 <rpc_ip_event_handler+0x292>
   260fa:	683b      	ldr	r3, [r7, #0]
   260fc:	2b01      	cmp	r3, #1
   260fe:	f47f aee1 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   26102:	6960      	ldr	r0, [r4, #20]
   26104:	2800      	cmp	r0, #0
   26106:	d1e9      	bne.n	260dc <rpc_ip_event_handler+0x2f8>
   26108:	2302      	movs	r3, #2
   2610a:	603b      	str	r3, [r7, #0]
   2610c:	69a3      	ldr	r3, [r4, #24]
   2610e:	61bb      	str	r3, [r7, #24]
   26110:	e6ca      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26112:	683b      	ldr	r3, [r7, #0]
   26114:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
   26118:	603b      	str	r3, [r7, #0]
   2611a:	683b      	ldr	r3, [r7, #0]
   2611c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   26120:	603b      	str	r3, [r7, #0]
   26122:	683b      	ldr	r3, [r7, #0]
   26124:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   26128:	603b      	str	r3, [r7, #0]
   2612a:	683b      	ldr	r3, [r7, #0]
   2612c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   26130:	603b      	str	r3, [r7, #0]
   26132:	6923      	ldr	r3, [r4, #16]
   26134:	2b6c      	cmp	r3, #108	; 0x6c
   26136:	d077      	beq.n	26228 <rpc_ip_event_handler+0x444>
   26138:	2b10      	cmp	r3, #16
   2613a:	bf8c      	ite	hi
   2613c:	232d      	movhi	r3, #45	; 0x2d
   2613e:	4a07      	ldrls	r2, [pc, #28]	; (2615c <rpc_ip_event_handler+0x378>)
   26140:	f04f 0000 	mov.w	r0, #0
   26144:	bf98      	it	ls
   26146:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
   2614a:	607b      	str	r3, [r7, #4]
   2614c:	60bb      	str	r3, [r7, #8]
   2614e:	e6ab      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26150:	683b      	ldr	r3, [r7, #0]
   26152:	b29b      	uxth	r3, r3
   26154:	2b07      	cmp	r3, #7
   26156:	f47f aeb5 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   2615a:	e6fe      	b.n	25f5a <rpc_ip_event_handler+0x176>
   2615c:	0003a948 	.word	0x0003a948
   26160:	20029087 	.word	0x20029087
   26164:	20022704 	.word	0x20022704
   26168:	200226d4 	.word	0x200226d4
   2616c:	200226cc 	.word	0x200226cc
   26170:	2002761c 	.word	0x2002761c
   26174:	200226dc 	.word	0x200226dc
   26178:	200226d8 	.word	0x200226d8
   2617c:	200226d0 	.word	0x200226d0
   26180:	683b      	ldr	r3, [r7, #0]
   26182:	b29b      	uxth	r3, r3
   26184:	2b08      	cmp	r3, #8
   26186:	f47f ae9d 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   2618a:	6963      	ldr	r3, [r4, #20]
   2618c:	2b00      	cmp	r3, #0
   2618e:	d189      	bne.n	260a4 <rpc_ip_event_handler+0x2c0>
   26190:	4b5e      	ldr	r3, [pc, #376]	; (2630c <rpc_ip_event_handler+0x528>)
   26192:	2001      	movs	r0, #1
   26194:	f843 4026 	str.w	r4, [r3, r6, lsl #2]
   26198:	683b      	ldr	r3, [r7, #0]
   2619a:	0c1b      	lsrs	r3, r3, #16
   2619c:	041b      	lsls	r3, r3, #16
   2619e:	f043 0309 	orr.w	r3, r3, #9
   261a2:	603b      	str	r3, [r7, #0]
   261a4:	e680      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   261a6:	683b      	ldr	r3, [r7, #0]
   261a8:	01db      	lsls	r3, r3, #7
   261aa:	f57f ae8b 	bpl.w	25ec4 <rpc_ip_event_handler+0xe0>
   261ae:	6963      	ldr	r3, [r4, #20]
   261b0:	2b00      	cmp	r3, #0
   261b2:	f47f af77 	bne.w	260a4 <rpc_ip_event_handler+0x2c0>
   261b6:	6823      	ldr	r3, [r4, #0]
   261b8:	2b00      	cmp	r3, #0
   261ba:	d071      	beq.n	262a0 <rpc_ip_event_handler+0x4bc>
   261bc:	2001      	movs	r0, #1
   261be:	4b53      	ldr	r3, [pc, #332]	; (2630c <rpc_ip_event_handler+0x528>)
   261c0:	f843 4026 	str.w	r4, [r3, r6, lsl #2]
   261c4:	683b      	ldr	r3, [r7, #0]
   261c6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   261ca:	603b      	str	r3, [r7, #0]
   261cc:	e66c      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   261ce:	683b      	ldr	r3, [r7, #0]
   261d0:	025a      	lsls	r2, r3, #9
   261d2:	f57f ae77 	bpl.w	25ec4 <rpc_ip_event_handler+0xe0>
   261d6:	6960      	ldr	r0, [r4, #20]
   261d8:	2800      	cmp	r0, #0
   261da:	f47f af7f 	bne.w	260dc <rpc_ip_event_handler+0x2f8>
   261de:	683b      	ldr	r3, [r7, #0]
   261e0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   261e4:	603b      	str	r3, [r7, #0]
   261e6:	e65f      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   261e8:	683b      	ldr	r3, [r7, #0]
   261ea:	b29b      	uxth	r3, r3
   261ec:	2b06      	cmp	r3, #6
   261ee:	f47f ae69 	bne.w	25ec4 <rpc_ip_event_handler+0xe0>
   261f2:	6960      	ldr	r0, [r4, #20]
   261f4:	2800      	cmp	r0, #0
   261f6:	f47f af71 	bne.w	260dc <rpc_ip_event_handler+0x2f8>
   261fa:	683b      	ldr	r3, [r7, #0]
   261fc:	0c1b      	lsrs	r3, r3, #16
   261fe:	041b      	lsls	r3, r3, #16
   26200:	f043 0307 	orr.w	r3, r3, #7
   26204:	603b      	str	r3, [r7, #0]
   26206:	e64f      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26208:	683b      	ldr	r3, [r7, #0]
   2620a:	0299      	lsls	r1, r3, #10
   2620c:	f57f ae5a 	bpl.w	25ec4 <rpc_ip_event_handler+0xe0>
   26210:	6963      	ldr	r3, [r4, #20]
   26212:	b33b      	cbz	r3, 26264 <rpc_ip_event_handler+0x480>
   26214:	2b6b      	cmp	r3, #107	; 0x6b
   26216:	f47f ae2b 	bne.w	25e70 <rpc_ip_event_handler+0x8c>
   2621a:	693b      	ldr	r3, [r7, #16]
   2621c:	2b01      	cmp	r3, #1
   2621e:	d041      	beq.n	262a4 <rpc_ip_event_handler+0x4c0>
   26220:	230c      	movs	r3, #12
   26222:	e62b      	b.n	25e7c <rpc_ip_event_handler+0x98>
   26224:	232d      	movs	r3, #45	; 0x2d
   26226:	e743      	b.n	260b0 <rpc_ip_event_handler+0x2cc>
   26228:	2239      	movs	r2, #57	; 0x39
   2622a:	683b      	ldr	r3, [r7, #0]
   2622c:	2000      	movs	r0, #0
   2622e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   26232:	603b      	str	r3, [r7, #0]
   26234:	607a      	str	r2, [r7, #4]
   26236:	60ba      	str	r2, [r7, #8]
   26238:	e636      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   2623a:	6820      	ldr	r0, [r4, #0]
   2623c:	f7fe f9e2 	bl	24604 <rpc_ip_client_data_free>
   26240:	4628      	mov	r0, r5
   26242:	e631      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26244:	683b      	ldr	r3, [r7, #0]
   26246:	2000      	movs	r0, #0
   26248:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2624c:	603b      	str	r3, [r7, #0]
   2624e:	683b      	ldr	r3, [r7, #0]
   26250:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   26254:	603b      	str	r3, [r7, #0]
   26256:	683b      	ldr	r3, [r7, #0]
   26258:	0c1b      	lsrs	r3, r3, #16
   2625a:	041b      	lsls	r3, r3, #16
   2625c:	f043 0305 	orr.w	r3, r3, #5
   26260:	603b      	str	r3, [r7, #0]
   26262:	e621      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26264:	683b      	ldr	r3, [r7, #0]
   26266:	4a29      	ldr	r2, [pc, #164]	; (2630c <rpc_ip_event_handler+0x528>)
   26268:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2626c:	603b      	str	r3, [r7, #0]
   2626e:	2001      	movs	r0, #1
   26270:	f842 4026 	str.w	r4, [r2, r6, lsl #2]
   26274:	e618      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26276:	2002      	movs	r0, #2
   26278:	e616      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   2627a:	683b      	ldr	r3, [r7, #0]
   2627c:	2000      	movs	r0, #0
   2627e:	0c1b      	lsrs	r3, r3, #16
   26280:	041b      	lsls	r3, r3, #16
   26282:	f043 0304 	orr.w	r3, r3, #4
   26286:	603b      	str	r3, [r7, #0]
   26288:	e60e      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   2628a:	683b      	ldr	r3, [r7, #0]
   2628c:	0c1b      	lsrs	r3, r3, #16
   2628e:	041b      	lsls	r3, r3, #16
   26290:	f043 030e 	orr.w	r3, r3, #14
   26294:	603b      	str	r3, [r7, #0]
   26296:	e607      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   26298:	8a65      	ldrh	r5, [r4, #18]
   2629a:	b95d      	cbnz	r5, 262b4 <rpc_ip_event_handler+0x4d0>
   2629c:	462e      	mov	r6, r5
   2629e:	e64e      	b.n	25f3e <rpc_ip_event_handler+0x15a>
   262a0:	2000      	movs	r0, #0
   262a2:	e78f      	b.n	261c4 <rpc_ip_event_handler+0x3e0>
   262a4:	220c      	movs	r2, #12
   262a6:	683b      	ldr	r3, [r7, #0]
   262a8:	2000      	movs	r0, #0
   262aa:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
   262ae:	603b      	str	r3, [r7, #0]
   262b0:	607a      	str	r2, [r7, #4]
   262b2:	e5f9      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   262b4:	2024      	movs	r0, #36	; 0x24
   262b6:	f003 fe3f 	bl	29f38 <nrf_malloc>
   262ba:	4606      	mov	r6, r0
   262bc:	2800      	cmp	r0, #0
   262be:	d0da      	beq.n	26276 <rpc_ip_event_handler+0x492>
   262c0:	8a62      	ldrh	r2, [r4, #18]
   262c2:	2a10      	cmp	r2, #16
   262c4:	d009      	beq.n	262da <rpc_ip_event_handler+0x4f6>
   262c6:	2a04      	cmp	r2, #4
   262c8:	d013      	beq.n	262f2 <rpc_ip_event_handler+0x50e>
   262ca:	6820      	ldr	r0, [r4, #0]
   262cc:	f7fe f99a 	bl	24604 <rpc_ip_client_data_free>
   262d0:	4630      	mov	r0, r6
   262d2:	f003 fe3b 	bl	29f4c <nrf_free>
   262d6:	2000      	movs	r0, #0
   262d8:	e5e6      	b.n	25ea8 <rpc_ip_event_handler+0xc4>
   262da:	230a      	movs	r3, #10
   262dc:	2524      	movs	r5, #36	; 0x24
   262de:	6043      	str	r3, [r0, #4]
   262e0:	7005      	strb	r5, [r0, #0]
   262e2:	8a23      	ldrh	r3, [r4, #16]
   262e4:	f104 0114 	add.w	r1, r4, #20
   262e8:	8103      	strh	r3, [r0, #8]
   262ea:	3010      	adds	r0, #16
   262ec:	f012 fe74 	bl	38fd8 <memcpy>
   262f0:	e625      	b.n	25f3e <rpc_ip_event_handler+0x15a>
   262f2:	2302      	movs	r3, #2
   262f4:	2510      	movs	r5, #16
   262f6:	6043      	str	r3, [r0, #4]
   262f8:	7005      	strb	r5, [r0, #0]
   262fa:	8a23      	ldrh	r3, [r4, #16]
   262fc:	f104 0114 	add.w	r1, r4, #20
   26300:	8103      	strh	r3, [r0, #8]
   26302:	300c      	adds	r0, #12
   26304:	f012 fe68 	bl	38fd8 <memcpy>
   26308:	e619      	b.n	25f3e <rpc_ip_event_handler+0x15a>
   2630a:	bf00      	nop
   2630c:	200226e0 	.word	0x200226e0

00026310 <rpc_handle_ctrl_message>:
   26310:	2902      	cmp	r1, #2
   26312:	b510      	push	{r4, lr}
   26314:	4604      	mov	r4, r0
   26316:	d00c      	beq.n	26332 <rpc_handle_ctrl_message+0x22>
   26318:	2904      	cmp	r1, #4
   2631a:	d008      	beq.n	2632e <rpc_handle_ctrl_message+0x1e>
   2631c:	2901      	cmp	r1, #1
   2631e:	d006      	beq.n	2632e <rpc_handle_ctrl_message+0x1e>
   26320:	6880      	ldr	r0, [r0, #8]
   26322:	b108      	cbz	r0, 26328 <rpc_handle_ctrl_message+0x18>
   26324:	f7fc fc9e 	bl	22c64 <rpc_transport_data_free>
   26328:	4620      	mov	r0, r4
   2632a:	f7fc fc99 	bl	22c60 <rpc_transport_rpc_free>
   2632e:	2000      	movs	r0, #0
   26330:	bd10      	pop	{r4, pc}
   26332:	6880      	ldr	r0, [r0, #8]
   26334:	2800      	cmp	r0, #0
   26336:	d0fa      	beq.n	2632e <rpc_handle_ctrl_message+0x1e>
   26338:	f7fc fc94 	bl	22c64 <rpc_transport_data_free>
   2633c:	2000      	movs	r0, #0
   2633e:	bd10      	pop	{r4, pc}

00026340 <rpc_handle_data_message>:
   26340:	4b23      	ldr	r3, [pc, #140]	; (263d0 <rpc_handle_data_message+0x90>)
   26342:	6802      	ldr	r2, [r0, #0]
   26344:	8819      	ldrh	r1, [r3, #0]
   26346:	b292      	uxth	r2, r2
   26348:	4291      	cmp	r1, r2
   2634a:	d027      	beq.n	2639c <rpc_handle_data_message+0x5c>
   2634c:	8a19      	ldrh	r1, [r3, #16]
   2634e:	4291      	cmp	r1, r2
   26350:	d02a      	beq.n	263a8 <rpc_handle_data_message+0x68>
   26352:	8c19      	ldrh	r1, [r3, #32]
   26354:	4291      	cmp	r1, r2
   26356:	d02b      	beq.n	263b0 <rpc_handle_data_message+0x70>
   26358:	8e19      	ldrh	r1, [r3, #48]	; 0x30
   2635a:	4291      	cmp	r1, r2
   2635c:	d02a      	beq.n	263b4 <rpc_handle_data_message+0x74>
   2635e:	f8b3 1040 	ldrh.w	r1, [r3, #64]	; 0x40
   26362:	4291      	cmp	r1, r2
   26364:	d028      	beq.n	263b8 <rpc_handle_data_message+0x78>
   26366:	f8b3 1050 	ldrh.w	r1, [r3, #80]	; 0x50
   2636a:	4291      	cmp	r1, r2
   2636c:	d026      	beq.n	263bc <rpc_handle_data_message+0x7c>
   2636e:	f8b3 1060 	ldrh.w	r1, [r3, #96]	; 0x60
   26372:	4291      	cmp	r1, r2
   26374:	d026      	beq.n	263c4 <rpc_handle_data_message+0x84>
   26376:	f8b3 1070 	ldrh.w	r1, [r3, #112]	; 0x70
   2637a:	4291      	cmp	r1, r2
   2637c:	d024      	beq.n	263c8 <rpc_handle_data_message+0x88>
   2637e:	f8b3 1080 	ldrh.w	r1, [r3, #128]	; 0x80
   26382:	4291      	cmp	r1, r2
   26384:	d01c      	beq.n	263c0 <rpc_handle_data_message+0x80>
   26386:	f8b3 1090 	ldrh.w	r1, [r3, #144]	; 0x90
   2638a:	4291      	cmp	r1, r2
   2638c:	d01e      	beq.n	263cc <rpc_handle_data_message+0x8c>
   2638e:	6880      	ldr	r0, [r0, #8]
   26390:	b160      	cbz	r0, 263ac <rpc_handle_data_message+0x6c>
   26392:	b510      	push	{r4, lr}
   26394:	f7fc fc66 	bl	22c64 <rpc_transport_data_free>
   26398:	2000      	movs	r0, #0
   2639a:	bd10      	pop	{r4, pc}
   2639c:	2200      	movs	r2, #0
   2639e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   263a2:	685a      	ldr	r2, [r3, #4]
   263a4:	68d9      	ldr	r1, [r3, #12]
   263a6:	4710      	bx	r2
   263a8:	2201      	movs	r2, #1
   263aa:	e7f8      	b.n	2639e <rpc_handle_data_message+0x5e>
   263ac:	2000      	movs	r0, #0
   263ae:	4770      	bx	lr
   263b0:	2202      	movs	r2, #2
   263b2:	e7f4      	b.n	2639e <rpc_handle_data_message+0x5e>
   263b4:	2203      	movs	r2, #3
   263b6:	e7f2      	b.n	2639e <rpc_handle_data_message+0x5e>
   263b8:	2204      	movs	r2, #4
   263ba:	e7f0      	b.n	2639e <rpc_handle_data_message+0x5e>
   263bc:	2205      	movs	r2, #5
   263be:	e7ee      	b.n	2639e <rpc_handle_data_message+0x5e>
   263c0:	2208      	movs	r2, #8
   263c2:	e7ec      	b.n	2639e <rpc_handle_data_message+0x5e>
   263c4:	2206      	movs	r2, #6
   263c6:	e7ea      	b.n	2639e <rpc_handle_data_message+0x5e>
   263c8:	2207      	movs	r2, #7
   263ca:	e7e8      	b.n	2639e <rpc_handle_data_message+0x5e>
   263cc:	2209      	movs	r2, #9
   263ce:	e7e6      	b.n	2639e <rpc_handle_data_message+0x5e>
   263d0:	20022708 	.word	0x20022708

000263d4 <rpc_framework_init>:
   263d4:	b508      	push	{r3, lr}
   263d6:	22a0      	movs	r2, #160	; 0xa0
   263d8:	2100      	movs	r1, #0
   263da:	4802      	ldr	r0, [pc, #8]	; (263e4 <rpc_framework_init+0x10>)
   263dc:	f012 fe36 	bl	3904c <memset>
   263e0:	2000      	movs	r0, #0
   263e2:	bd08      	pop	{r3, pc}
   263e4:	20022708 	.word	0x20022708

000263e8 <rpc_client_register>:
   263e8:	8803      	ldrh	r3, [r0, #0]
   263ea:	2b00      	cmp	r3, #0
   263ec:	d045      	beq.n	2647a <rpc_client_register+0x92>
   263ee:	6842      	ldr	r2, [r0, #4]
   263f0:	4601      	mov	r1, r0
   263f2:	2a00      	cmp	r2, #0
   263f4:	d050      	beq.n	26498 <rpc_client_register+0xb0>
   263f6:	4a30      	ldr	r2, [pc, #192]	; (264b8 <rpc_client_register+0xd0>)
   263f8:	8810      	ldrh	r0, [r2, #0]
   263fa:	4283      	cmp	r3, r0
   263fc:	d03d      	beq.n	2647a <rpc_client_register+0x92>
   263fe:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26402:	8a14      	ldrh	r4, [r2, #16]
   26404:	42a3      	cmp	r3, r4
   26406:	d035      	beq.n	26474 <rpc_client_register+0x8c>
   26408:	8c15      	ldrh	r5, [r2, #32]
   2640a:	42ab      	cmp	r3, r5
   2640c:	d032      	beq.n	26474 <rpc_client_register+0x8c>
   2640e:	8e16      	ldrh	r6, [r2, #48]	; 0x30
   26410:	42b3      	cmp	r3, r6
   26412:	d02f      	beq.n	26474 <rpc_client_register+0x8c>
   26414:	f8b2 7040 	ldrh.w	r7, [r2, #64]	; 0x40
   26418:	42bb      	cmp	r3, r7
   2641a:	d02b      	beq.n	26474 <rpc_client_register+0x8c>
   2641c:	f8b2 c050 	ldrh.w	ip, [r2, #80]	; 0x50
   26420:	4563      	cmp	r3, ip
   26422:	d027      	beq.n	26474 <rpc_client_register+0x8c>
   26424:	f8b2 e060 	ldrh.w	lr, [r2, #96]	; 0x60
   26428:	4573      	cmp	r3, lr
   2642a:	d023      	beq.n	26474 <rpc_client_register+0x8c>
   2642c:	f8b2 8070 	ldrh.w	r8, [r2, #112]	; 0x70
   26430:	4543      	cmp	r3, r8
   26432:	d01f      	beq.n	26474 <rpc_client_register+0x8c>
   26434:	f8b2 9080 	ldrh.w	r9, [r2, #128]	; 0x80
   26438:	454b      	cmp	r3, r9
   2643a:	d01b      	beq.n	26474 <rpc_client_register+0x8c>
   2643c:	f8b2 a090 	ldrh.w	sl, [r2, #144]	; 0x90
   26440:	4553      	cmp	r3, sl
   26442:	d017      	beq.n	26474 <rpc_client_register+0x8c>
   26444:	b1e0      	cbz	r0, 26480 <rpc_client_register+0x98>
   26446:	b35c      	cbz	r4, 264a0 <rpc_client_register+0xb8>
   26448:	b365      	cbz	r5, 264a4 <rpc_client_register+0xbc>
   2644a:	b36e      	cbz	r6, 264a8 <rpc_client_register+0xc0>
   2644c:	b377      	cbz	r7, 264ac <rpc_client_register+0xc4>
   2644e:	f1bc 0f00 	cmp.w	ip, #0
   26452:	d02d      	beq.n	264b0 <rpc_client_register+0xc8>
   26454:	f1be 0f00 	cmp.w	lr, #0
   26458:	d020      	beq.n	2649c <rpc_client_register+0xb4>
   2645a:	f1b8 0f00 	cmp.w	r8, #0
   2645e:	d029      	beq.n	264b4 <rpc_client_register+0xcc>
   26460:	f1b9 0f00 	cmp.w	r9, #0
   26464:	d00b      	beq.n	2647e <rpc_client_register+0x96>
   26466:	2009      	movs	r0, #9
   26468:	f1ba 0f00 	cmp.w	sl, #0
   2646c:	d008      	beq.n	26480 <rpc_client_register+0x98>
   2646e:	2004      	movs	r0, #4
   26470:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   26474:	2007      	movs	r0, #7
   26476:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2647a:	2007      	movs	r0, #7
   2647c:	4770      	bx	lr
   2647e:	2008      	movs	r0, #8
   26480:	0100      	lsls	r0, r0, #4
   26482:	5213      	strh	r3, [r2, r0]
   26484:	684b      	ldr	r3, [r1, #4]
   26486:	4402      	add	r2, r0
   26488:	6053      	str	r3, [r2, #4]
   2648a:	688b      	ldr	r3, [r1, #8]
   2648c:	2000      	movs	r0, #0
   2648e:	6093      	str	r3, [r2, #8]
   26490:	68cb      	ldr	r3, [r1, #12]
   26492:	60d3      	str	r3, [r2, #12]
   26494:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   26498:	200e      	movs	r0, #14
   2649a:	4770      	bx	lr
   2649c:	2006      	movs	r0, #6
   2649e:	e7ef      	b.n	26480 <rpc_client_register+0x98>
   264a0:	2001      	movs	r0, #1
   264a2:	e7ed      	b.n	26480 <rpc_client_register+0x98>
   264a4:	2002      	movs	r0, #2
   264a6:	e7eb      	b.n	26480 <rpc_client_register+0x98>
   264a8:	2003      	movs	r0, #3
   264aa:	e7e9      	b.n	26480 <rpc_client_register+0x98>
   264ac:	2004      	movs	r0, #4
   264ae:	e7e7      	b.n	26480 <rpc_client_register+0x98>
   264b0:	2005      	movs	r0, #5
   264b2:	e7e5      	b.n	26480 <rpc_client_register+0x98>
   264b4:	2007      	movs	r0, #7
   264b6:	e7e3      	b.n	26480 <rpc_client_register+0x98>
   264b8:	20022708 	.word	0x20022708

000264bc <rpc_message_send>:
   264bc:	b150      	cbz	r0, 264d4 <rpc_message_send+0x18>
   264be:	b159      	cbz	r1, 264d8 <rpc_message_send+0x1c>
   264c0:	684b      	ldr	r3, [r1, #4]
   264c2:	8008      	strh	r0, [r1, #0]
   264c4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   264c8:	f043 0302 	orr.w	r3, r3, #2
   264cc:	604b      	str	r3, [r1, #4]
   264ce:	4608      	mov	r0, r1
   264d0:	f7fc bbc0 	b.w	22c54 <rpc_transport_send>
   264d4:	2007      	movs	r0, #7
   264d6:	4770      	bx	lr
   264d8:	200e      	movs	r0, #14
   264da:	4770      	bx	lr

000264dc <rpc_message_alloc>:
   264dc:	b342      	cbz	r2, 26530 <rpc_message_alloc+0x54>
   264de:	b328      	cbz	r0, 2652c <rpc_message_alloc+0x50>
   264e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   264e2:	2300      	movs	r3, #0
   264e4:	4616      	mov	r6, r2
   264e6:	460c      	mov	r4, r1
   264e8:	4605      	mov	r5, r0
   264ea:	6013      	str	r3, [r2, #0]
   264ec:	b171      	cbz	r1, 2650c <rpc_message_alloc+0x30>
   264ee:	4608      	mov	r0, r1
   264f0:	f7fc fbb4 	bl	22c5c <rpc_transport_data_alloc>
   264f4:	4607      	mov	r7, r0
   264f6:	b1b8      	cbz	r0, 26528 <rpc_message_alloc+0x4c>
   264f8:	f7fc fbae 	bl	22c58 <rpc_transport_rpc_alloc>
   264fc:	4603      	mov	r3, r0
   264fe:	b180      	cbz	r0, 26522 <rpc_message_alloc+0x46>
   26500:	2000      	movs	r0, #0
   26502:	60dc      	str	r4, [r3, #12]
   26504:	609f      	str	r7, [r3, #8]
   26506:	801d      	strh	r5, [r3, #0]
   26508:	6033      	str	r3, [r6, #0]
   2650a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2650c:	f7fc fba4 	bl	22c58 <rpc_transport_rpc_alloc>
   26510:	4603      	mov	r3, r0
   26512:	b148      	cbz	r0, 26528 <rpc_message_alloc+0x4c>
   26514:	4627      	mov	r7, r4
   26516:	60dc      	str	r4, [r3, #12]
   26518:	609f      	str	r7, [r3, #8]
   2651a:	801d      	strh	r5, [r3, #0]
   2651c:	2000      	movs	r0, #0
   2651e:	6033      	str	r3, [r6, #0]
   26520:	e7f3      	b.n	2650a <rpc_message_alloc+0x2e>
   26522:	4638      	mov	r0, r7
   26524:	f7fc fb9e 	bl	22c64 <rpc_transport_data_free>
   26528:	2004      	movs	r0, #4
   2652a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2652c:	2007      	movs	r0, #7
   2652e:	4770      	bx	lr
   26530:	200e      	movs	r0, #14
   26532:	4770      	bx	lr

00026534 <rpc_message_free>:
   26534:	b130      	cbz	r0, 26544 <rpc_message_free+0x10>
   26536:	b139      	cbz	r1, 26548 <rpc_message_free+0x14>
   26538:	b508      	push	{r3, lr}
   2653a:	4608      	mov	r0, r1
   2653c:	f7fc fb90 	bl	22c60 <rpc_transport_rpc_free>
   26540:	2000      	movs	r0, #0
   26542:	bd08      	pop	{r3, pc}
   26544:	2007      	movs	r0, #7
   26546:	4770      	bx	lr
   26548:	200e      	movs	r0, #14
   2654a:	4770      	bx	lr

0002654c <rpc_message_data_free>:
   2654c:	b130      	cbz	r0, 2655c <rpc_message_data_free+0x10>
   2654e:	b139      	cbz	r1, 26560 <rpc_message_data_free+0x14>
   26550:	b508      	push	{r3, lr}
   26552:	4608      	mov	r0, r1
   26554:	f7fc fb86 	bl	22c64 <rpc_transport_data_free>
   26558:	2000      	movs	r0, #0
   2655a:	bd08      	pop	{r3, pc}
   2655c:	2007      	movs	r0, #7
   2655e:	4770      	bx	lr
   26560:	200e      	movs	r0, #14
   26562:	4770      	bx	lr

00026564 <packet_free_cb>:
   26564:	b510      	push	{r4, lr}
   26566:	4604      	mov	r4, r0
   26568:	b118      	cbz	r0, 26572 <packet_free_cb+0xe>
   2656a:	6800      	ldr	r0, [r0, #0]
   2656c:	b108      	cbz	r0, 26572 <packet_free_cb+0xe>
   2656e:	f002 feff 	bl	29370 <rpc_gnss_client_data_free>
   26572:	68a0      	ldr	r0, [r4, #8]
   26574:	b118      	cbz	r0, 2657e <packet_free_cb+0x1a>
   26576:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2657a:	f003 bce7 	b.w	29f4c <nrf_free>
   2657e:	bd10      	pop	{r4, pc}

00026580 <rpc_gnss_event_handler>:
   26580:	b5f0      	push	{r4, r5, r6, r7, lr}
   26582:	4b64      	ldr	r3, [pc, #400]	; (26714 <rpc_gnss_event_handler+0x194>)
   26584:	4606      	mov	r6, r0
   26586:	6800      	ldr	r0, [r0, #0]
   26588:	881b      	ldrh	r3, [r3, #0]
   2658a:	6802      	ldr	r2, [r0, #0]
   2658c:	b085      	sub	sp, #20
   2658e:	ebb3 4f12 	cmp.w	r3, r2, lsr #16
   26592:	460d      	mov	r5, r1
   26594:	d037      	beq.n	26606 <rpc_gnss_event_handler+0x86>
   26596:	f505 433f 	add.w	r3, r5, #48896	; 0xbf00
   2659a:	33ff      	adds	r3, #255	; 0xff
   2659c:	b29b      	uxth	r3, r3
   2659e:	2b02      	cmp	r3, #2
   265a0:	d811      	bhi.n	265c6 <rpc_gnss_event_handler+0x46>
   265a2:	4c5d      	ldr	r4, [pc, #372]	; (26718 <rpc_gnss_event_handler+0x198>)
   265a4:	6823      	ldr	r3, [r4, #0]
   265a6:	075a      	lsls	r2, r3, #29
   265a8:	d410      	bmi.n	265cc <rpc_gnss_event_handler+0x4c>
   265aa:	6823      	ldr	r3, [r4, #0]
   265ac:	079b      	lsls	r3, r3, #30
   265ae:	d503      	bpl.n	265b8 <rpc_gnss_event_handler+0x38>
   265b0:	f244 0303 	movw	r3, #16387	; 0x4003
   265b4:	429d      	cmp	r5, r3
   265b6:	d009      	beq.n	265cc <rpc_gnss_event_handler+0x4c>
   265b8:	6830      	ldr	r0, [r6, #0]
   265ba:	b120      	cbz	r0, 265c6 <rpc_gnss_event_handler+0x46>
   265bc:	f002 fed8 	bl	29370 <rpc_gnss_client_data_free>
   265c0:	2200      	movs	r2, #0
   265c2:	4b56      	ldr	r3, [pc, #344]	; (2671c <rpc_gnss_event_handler+0x19c>)
   265c4:	601a      	str	r2, [r3, #0]
   265c6:	2000      	movs	r0, #0
   265c8:	b005      	add	sp, #20
   265ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
   265cc:	2002      	movs	r0, #2
   265ce:	f003 fcb3 	bl	29f38 <nrf_malloc>
   265d2:	4607      	mov	r7, r0
   265d4:	2800      	cmp	r0, #0
   265d6:	f000 8094 	beq.w	26702 <rpc_gnss_event_handler+0x182>
   265da:	2302      	movs	r3, #2
   265dc:	8005      	strh	r5, [r0, #0]
   265de:	6831      	ldr	r1, [r6, #0]
   265e0:	6872      	ldr	r2, [r6, #4]
   265e2:	484f      	ldr	r0, [pc, #316]	; (26720 <rpc_gnss_event_handler+0x1a0>)
   265e4:	e88d 0086 	stmia.w	sp, {r1, r2, r7}
   265e8:	6800      	ldr	r0, [r0, #0]
   265ea:	9303      	str	r3, [sp, #12]
   265ec:	6803      	ldr	r3, [r0, #0]
   265ee:	4669      	mov	r1, sp
   265f0:	685b      	ldr	r3, [r3, #4]
   265f2:	4798      	blx	r3
   265f4:	3001      	adds	r0, #1
   265f6:	d071      	beq.n	266dc <rpc_gnss_event_handler+0x15c>
   265f8:	2000      	movs	r0, #0
   265fa:	6823      	ldr	r3, [r4, #0]
   265fc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   26600:	6023      	str	r3, [r4, #0]
   26602:	b005      	add	sp, #20
   26604:	bdf0      	pop	{r4, r5, r6, r7, pc}
   26606:	4c44      	ldr	r4, [pc, #272]	; (26718 <rpc_gnss_event_handler+0x198>)
   26608:	4f44      	ldr	r7, [pc, #272]	; (2671c <rpc_gnss_event_handler+0x19c>)
   2660a:	6823      	ldr	r3, [r4, #0]
   2660c:	6038      	str	r0, [r7, #0]
   2660e:	01d9      	lsls	r1, r3, #7
   26610:	d523      	bpl.n	2665a <rpc_gnss_event_handler+0xda>
   26612:	f242 1302 	movw	r3, #8450	; 0x2102
   26616:	429d      	cmp	r5, r3
   26618:	d11f      	bne.n	2665a <rpc_gnss_event_handler+0xda>
   2661a:	6843      	ldr	r3, [r0, #4]
   2661c:	b91b      	cbnz	r3, 26626 <rpc_gnss_event_handler+0xa6>
   2661e:	6823      	ldr	r3, [r4, #0]
   26620:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   26624:	6023      	str	r3, [r4, #0]
   26626:	6823      	ldr	r3, [r4, #0]
   26628:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   2662c:	6023      	str	r3, [r4, #0]
   2662e:	6823      	ldr	r3, [r4, #0]
   26630:	025a      	lsls	r2, r3, #9
   26632:	d430      	bmi.n	26696 <rpc_gnss_event_handler+0x116>
   26634:	f242 0305 	movw	r3, #8197	; 0x2005
   26638:	429d      	cmp	r5, r3
   2663a:	d12c      	bne.n	26696 <rpc_gnss_event_handler+0x116>
   2663c:	6823      	ldr	r3, [r4, #0]
   2663e:	0299      	lsls	r1, r3, #10
   26640:	d529      	bpl.n	26696 <rpc_gnss_event_handler+0x116>
   26642:	6843      	ldr	r3, [r0, #4]
   26644:	2b00      	cmp	r3, #0
   26646:	d157      	bne.n	266f8 <rpc_gnss_event_handler+0x178>
   26648:	6823      	ldr	r3, [r4, #0]
   2664a:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   2664e:	6023      	str	r3, [r4, #0]
   26650:	6823      	ldr	r3, [r4, #0]
   26652:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   26656:	6023      	str	r3, [r4, #0]
   26658:	e01d      	b.n	26696 <rpc_gnss_event_handler+0x116>
   2665a:	6823      	ldr	r3, [r4, #0]
   2665c:	025b      	lsls	r3, r3, #9
   2665e:	d50e      	bpl.n	2667e <rpc_gnss_event_handler+0xfe>
   26660:	f242 1303 	movw	r3, #8451	; 0x2103
   26664:	429d      	cmp	r5, r3
   26666:	d10a      	bne.n	2667e <rpc_gnss_event_handler+0xfe>
   26668:	6843      	ldr	r3, [r0, #4]
   2666a:	b91b      	cbnz	r3, 26674 <rpc_gnss_event_handler+0xf4>
   2666c:	6823      	ldr	r3, [r4, #0]
   2666e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   26672:	6023      	str	r3, [r4, #0]
   26674:	6823      	ldr	r3, [r4, #0]
   26676:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   2667a:	6023      	str	r3, [r4, #0]
   2667c:	e00b      	b.n	26696 <rpc_gnss_event_handler+0x116>
   2667e:	f242 0301 	movw	r3, #8193	; 0x2001
   26682:	429d      	cmp	r5, r3
   26684:	d10c      	bne.n	266a0 <rpc_gnss_event_handler+0x120>
   26686:	6843      	ldr	r3, [r0, #4]
   26688:	b92b      	cbnz	r3, 26696 <rpc_gnss_event_handler+0x116>
   2668a:	6823      	ldr	r3, [r4, #0]
   2668c:	0c1b      	lsrs	r3, r3, #16
   2668e:	041b      	lsls	r3, r3, #16
   26690:	f043 0302 	orr.w	r3, r3, #2
   26694:	6023      	str	r3, [r4, #0]
   26696:	f002 fe6b 	bl	29370 <rpc_gnss_client_data_free>
   2669a:	2300      	movs	r3, #0
   2669c:	603b      	str	r3, [r7, #0]
   2669e:	e77a      	b.n	26596 <rpc_gnss_event_handler+0x16>
   266a0:	f242 0304 	movw	r3, #8196	; 0x2004
   266a4:	429d      	cmp	r5, r3
   266a6:	d1c5      	bne.n	26634 <rpc_gnss_event_handler+0xb4>
   266a8:	6843      	ldr	r3, [r0, #4]
   266aa:	b993      	cbnz	r3, 266d2 <rpc_gnss_event_handler+0x152>
   266ac:	6823      	ldr	r3, [r4, #0]
   266ae:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   266b2:	6023      	str	r3, [r4, #0]
   266b4:	6823      	ldr	r3, [r4, #0]
   266b6:	b29b      	uxth	r3, r3
   266b8:	2b03      	cmp	r3, #3
   266ba:	6823      	ldr	r3, [r4, #0]
   266bc:	d016      	beq.n	266ec <rpc_gnss_event_handler+0x16c>
   266be:	b29b      	uxth	r3, r3
   266c0:	2b04      	cmp	r3, #4
   266c2:	d1d7      	bne.n	26674 <rpc_gnss_event_handler+0xf4>
   266c4:	6823      	ldr	r3, [r4, #0]
   266c6:	0c1b      	lsrs	r3, r3, #16
   266c8:	041b      	lsls	r3, r3, #16
   266ca:	f043 0302 	orr.w	r3, r3, #2
   266ce:	6023      	str	r3, [r4, #0]
   266d0:	e7d0      	b.n	26674 <rpc_gnss_event_handler+0xf4>
   266d2:	6823      	ldr	r3, [r4, #0]
   266d4:	b29b      	uxth	r3, r3
   266d6:	2b03      	cmp	r3, #3
   266d8:	d1cc      	bne.n	26674 <rpc_gnss_event_handler+0xf4>
   266da:	e7f3      	b.n	266c4 <rpc_gnss_event_handler+0x144>
   266dc:	4638      	mov	r0, r7
   266de:	f003 fc35 	bl	29f4c <nrf_free>
   266e2:	6830      	ldr	r0, [r6, #0]
   266e4:	2800      	cmp	r0, #0
   266e6:	f47f af69 	bne.w	265bc <rpc_gnss_event_handler+0x3c>
   266ea:	e76c      	b.n	265c6 <rpc_gnss_event_handler+0x46>
   266ec:	0c1b      	lsrs	r3, r3, #16
   266ee:	041b      	lsls	r3, r3, #16
   266f0:	f043 0304 	orr.w	r3, r3, #4
   266f4:	6023      	str	r3, [r4, #0]
   266f6:	e7bd      	b.n	26674 <rpc_gnss_event_handler+0xf4>
   266f8:	6823      	ldr	r3, [r4, #0]
   266fa:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   266fe:	6023      	str	r3, [r4, #0]
   26700:	e7c9      	b.n	26696 <rpc_gnss_event_handler+0x116>
   26702:	6830      	ldr	r0, [r6, #0]
   26704:	2800      	cmp	r0, #0
   26706:	f43f af5e 	beq.w	265c6 <rpc_gnss_event_handler+0x46>
   2670a:	f002 fe31 	bl	29370 <rpc_gnss_client_data_free>
   2670e:	4b03      	ldr	r3, [pc, #12]	; (2671c <rpc_gnss_event_handler+0x19c>)
   26710:	601f      	str	r7, [r3, #0]
   26712:	e758      	b.n	265c6 <rpc_gnss_event_handler+0x46>
   26714:	2002761e 	.word	0x2002761e
   26718:	200227a8 	.word	0x200227a8
   2671c:	200227ac 	.word	0x200227ac
   26720:	200227b0 	.word	0x200227b0

00026724 <gnss_interface_write>:
   26724:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   26728:	4a74      	ldr	r2, [pc, #464]	; (268fc <gnss_interface_write+0x1d8>)
   2672a:	b09f      	sub	sp, #124	; 0x7c
   2672c:	4290      	cmp	r0, r2
   2672e:	9d26      	ldr	r5, [sp, #152]	; 0x98
   26730:	f040 80d7 	bne.w	268e2 <gnss_interface_write+0x1be>
   26734:	2900      	cmp	r1, #0
   26736:	f000 80c6 	beq.w	268c6 <gnss_interface_write+0x1a2>
   2673a:	2d00      	cmp	r5, #0
   2673c:	f000 80c3 	beq.w	268c6 <gnss_interface_write+0x1a2>
   26740:	9a27      	ldr	r2, [sp, #156]	; 0x9c
   26742:	2a02      	cmp	r2, #2
   26744:	f040 80bf 	bne.w	268c6 <gnss_interface_write+0x1a2>
   26748:	4c6d      	ldr	r4, [pc, #436]	; (26900 <gnss_interface_write+0x1dc>)
   2674a:	6822      	ldr	r2, [r4, #0]
   2674c:	b292      	uxth	r2, r2
   2674e:	2a02      	cmp	r2, #2
   26750:	d004      	beq.n	2675c <gnss_interface_write+0x38>
   26752:	6822      	ldr	r2, [r4, #0]
   26754:	b292      	uxth	r2, r2
   26756:	2a04      	cmp	r2, #4
   26758:	f040 80bd 	bne.w	268d6 <gnss_interface_write+0x1b2>
   2675c:	2b00      	cmp	r3, #0
   2675e:	f040 80c6 	bne.w	268ee <gnss_interface_write+0x1ca>
   26762:	6822      	ldr	r2, [r4, #0]
   26764:	0390      	lsls	r0, r2, #14
   26766:	d512      	bpl.n	2678e <gnss_interface_write+0x6a>
   26768:	6822      	ldr	r2, [r4, #0]
   2676a:	882b      	ldrh	r3, [r5, #0]
   2676c:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
   26770:	6022      	str	r2, [r4, #0]
   26772:	6822      	ldr	r2, [r4, #0]
   26774:	3b01      	subs	r3, #1
   26776:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   2677a:	6022      	str	r2, [r4, #0]
   2677c:	2b07      	cmp	r3, #7
   2677e:	f200 80a2 	bhi.w	268c6 <gnss_interface_write+0x1a2>
   26782:	e8df f003 	tbb	[pc, r3]
   26786:	7d82      	.short	0x7d82
   26788:	646e7378 	.word	0x646e7378
   2678c:	0869      	.short	0x0869
   2678e:	2000      	movs	r0, #0
   26790:	b01f      	add	sp, #124	; 0x7c
   26792:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   26796:	4608      	mov	r0, r1
   26798:	a902      	add	r1, sp, #8
   2679a:	f002 fd9d 	bl	292d8 <rpc_gnss_serialize_integrity>
   2679e:	2172      	movs	r1, #114	; 0x72
   267a0:	4668      	mov	r0, sp
   267a2:	f002 fdb3 	bl	2930c <rpc_gnss_client_request_alloc>
   267a6:	4605      	mov	r5, r0
   267a8:	9800      	ldr	r0, [sp, #0]
   267aa:	2d00      	cmp	r5, #0
   267ac:	d172      	bne.n	26894 <gnss_interface_write+0x170>
   267ae:	2800      	cmp	r0, #0
   267b0:	d077      	beq.n	268a2 <gnss_interface_write+0x17e>
   267b2:	f241 0605 	movw	r6, #4101	; 0x1005
   267b6:	f04f 0c49 	mov.w	ip, #73	; 0x49
   267ba:	2272      	movs	r2, #114	; 0x72
   267bc:	f04f 0e76 	mov.w	lr, #118	; 0x76
   267c0:	f04f 0943 	mov.w	r9, #67	; 0x43
   267c4:	f04f 0854 	mov.w	r8, #84	; 0x54
   267c8:	4f4e      	ldr	r7, [pc, #312]	; (26904 <gnss_interface_write+0x1e0>)
   267ca:	a91e      	add	r1, sp, #120	; 0x78
   267cc:	883b      	ldrh	r3, [r7, #0]
   267ce:	f880 c00f 	strb.w	ip, [r0, #15]
   267d2:	3301      	adds	r3, #1
   267d4:	b29b      	uxth	r3, r3
   267d6:	ea46 4c03 	orr.w	ip, r6, r3, lsl #16
   267da:	f841 cd74 	str.w	ip, [r1, #-116]!
   267de:	7145      	strb	r5, [r0, #5]
   267e0:	7185      	strb	r5, [r0, #6]
   267e2:	71c5      	strb	r5, [r0, #7]
   267e4:	7205      	strb	r5, [r0, #8]
   267e6:	7245      	strb	r5, [r0, #9]
   267e8:	7285      	strb	r5, [r0, #10]
   267ea:	72c5      	strb	r5, [r0, #11]
   267ec:	7102      	strb	r2, [r0, #4]
   267ee:	f880 900c 	strb.w	r9, [r0, #12]
   267f2:	f880 800d 	strb.w	r8, [r0, #13]
   267f6:	f880 e00e 	strb.w	lr, [r0, #14]
   267fa:	6800      	ldr	r0, [r0, #0]
   267fc:	803b      	strh	r3, [r7, #0]
   267fe:	f012 fbeb 	bl	38fd8 <memcpy>
   26802:	4b41      	ldr	r3, [pc, #260]	; (26908 <gnss_interface_write+0x1e4>)
   26804:	4631      	mov	r1, r6
   26806:	9800      	ldr	r0, [sp, #0]
   26808:	601d      	str	r5, [r3, #0]
   2680a:	f002 fd93 	bl	29334 <rpc_gnss_client_request_send>
   2680e:	2800      	cmp	r0, #0
   26810:	d14e      	bne.n	268b0 <gnss_interface_write+0x18c>
   26812:	6823      	ldr	r3, [r4, #0]
   26814:	0299      	lsls	r1, r3, #10
   26816:	d50b      	bpl.n	26830 <gnss_interface_write+0x10c>
   26818:	4e3c      	ldr	r6, [pc, #240]	; (2690c <gnss_interface_write+0x1e8>)
   2681a:	4d38      	ldr	r5, [pc, #224]	; (268fc <gnss_interface_write+0x1d8>)
   2681c:	e000      	b.n	26820 <gnss_interface_write+0xfc>
   2681e:	b978      	cbnz	r0, 26840 <gnss_interface_write+0x11c>
   26820:	4631      	mov	r1, r6
   26822:	4628      	mov	r0, r5
   26824:	f7f9 fb72 	bl	1ff0c <bsd_os_timedwait>
   26828:	6823      	ldr	r3, [r4, #0]
   2682a:	029a      	lsls	r2, r3, #10
   2682c:	d4f7      	bmi.n	2681e <gnss_interface_write+0xfa>
   2682e:	b938      	cbnz	r0, 26840 <gnss_interface_write+0x11c>
   26830:	6823      	ldr	r3, [r4, #0]
   26832:	039b      	lsls	r3, r3, #14
   26834:	d4ab      	bmi.n	2678e <gnss_interface_write+0x6a>
   26836:	2005      	movs	r0, #5
   26838:	6823      	ldr	r3, [r4, #0]
   2683a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2683e:	6023      	str	r3, [r4, #0]
   26840:	f7f9 fc0e 	bl	20060 <bsd_os_errno_set>
   26844:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26848:	b01f      	add	sp, #124	; 0x7c
   2684a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2684e:	4608      	mov	r0, r1
   26850:	a902      	add	r1, sp, #8
   26852:	f002 fcf9 	bl	29248 <rpc_gnss_serialize_time_and_sv_tow>
   26856:	e7a2      	b.n	2679e <gnss_interface_write+0x7a>
   26858:	4608      	mov	r0, r1
   2685a:	a902      	add	r1, sp, #8
   2685c:	f002 fd1c 	bl	29298 <rpc_gnss_serialize_location>
   26860:	e79d      	b.n	2679e <gnss_interface_write+0x7a>
   26862:	4608      	mov	r0, r1
   26864:	a902      	add	r1, sp, #8
   26866:	f002 fcd5 	bl	29214 <rpc_gnss_serialize_nequick>
   2686a:	e798      	b.n	2679e <gnss_interface_write+0x7a>
   2686c:	4608      	mov	r0, r1
   2686e:	a902      	add	r1, sp, #8
   26870:	f002 fcac 	bl	291cc <rpc_gnss_serialize_klob>
   26874:	e793      	b.n	2679e <gnss_interface_write+0x7a>
   26876:	4608      	mov	r0, r1
   26878:	a902      	add	r1, sp, #8
   2687a:	f002 fc75 	bl	29168 <rpc_gnss_serialize_alm>
   2687e:	e78e      	b.n	2679e <gnss_interface_write+0x7a>
   26880:	4608      	mov	r0, r1
   26882:	a902      	add	r1, sp, #8
   26884:	f002 fc1e 	bl	290c4 <rpc_gnss_serialize_ephe>
   26888:	e789      	b.n	2679e <gnss_interface_write+0x7a>
   2688a:	4608      	mov	r0, r1
   2688c:	a902      	add	r1, sp, #8
   2688e:	f002 fbf7 	bl	29080 <rpc_gnss_serialize_utc>
   26892:	e784      	b.n	2679e <gnss_interface_write+0x7a>
   26894:	b128      	cbz	r0, 268a2 <gnss_interface_write+0x17e>
   26896:	6803      	ldr	r3, [r0, #0]
   26898:	b11b      	cbz	r3, 268a2 <gnss_interface_write+0x17e>
   2689a:	4618      	mov	r0, r3
   2689c:	f002 fd68 	bl	29370 <rpc_gnss_client_data_free>
   268a0:	9800      	ldr	r0, [sp, #0]
   268a2:	f002 fd5d 	bl	29360 <rpc_gnss_client_message_free>
   268a6:	2023      	movs	r0, #35	; 0x23
   268a8:	f7f9 fbda 	bl	20060 <bsd_os_errno_set>
   268ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   268b0:	6823      	ldr	r3, [r4, #0]
   268b2:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   268b6:	6023      	str	r3, [r4, #0]
   268b8:	6823      	ldr	r3, [r4, #0]
   268ba:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   268be:	6023      	str	r3, [r4, #0]
   268c0:	b01f      	add	sp, #124	; 0x7c
   268c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   268c6:	2016      	movs	r0, #22
   268c8:	f7f9 fbca 	bl	20060 <bsd_os_errno_set>
   268cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   268d0:	b01f      	add	sp, #124	; 0x7c
   268d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   268d6:	2039      	movs	r0, #57	; 0x39
   268d8:	f7f9 fbc2 	bl	20060 <bsd_os_errno_set>
   268dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   268e0:	e756      	b.n	26790 <gnss_interface_write+0x6c>
   268e2:	2009      	movs	r0, #9
   268e4:	f7f9 fbbc 	bl	20060 <bsd_os_errno_set>
   268e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   268ec:	e750      	b.n	26790 <gnss_interface_write+0x6c>
   268ee:	202d      	movs	r0, #45	; 0x2d
   268f0:	f7f9 fbb6 	bl	20060 <bsd_os_errno_set>
   268f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   268f8:	e74a      	b.n	26790 <gnss_interface_write+0x6c>
   268fa:	bf00      	nop
   268fc:	49765443 	.word	0x49765443
   26900:	200227a8 	.word	0x200227a8
   26904:	2002761e 	.word	0x2002761e
   26908:	200227ac 	.word	0x200227ac
   2690c:	20020220 	.word	0x20020220

00026910 <gnss_interface_read>:
   26910:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   26914:	4c55      	ldr	r4, [pc, #340]	; (26a6c <gnss_interface_read+0x15c>)
   26916:	b0b7      	sub	sp, #220	; 0xdc
   26918:	42a0      	cmp	r0, r4
   2691a:	f040 81fa 	bne.w	26d12 <gnss_interface_read+0x402>
   2691e:	460e      	mov	r6, r1
   26920:	2900      	cmp	r1, #0
   26922:	f000 81f0 	beq.w	26d06 <gnss_interface_read+0x3f6>
   26926:	2ad7      	cmp	r2, #215	; 0xd7
   26928:	f240 81ed 	bls.w	26d06 <gnss_interface_read+0x3f6>
   2692c:	4d50      	ldr	r5, [pc, #320]	; (26a70 <gnss_interface_read+0x160>)
   2692e:	469a      	mov	sl, r3
   26930:	682b      	ldr	r3, [r5, #0]
   26932:	b29b      	uxth	r3, r3
   26934:	2b04      	cmp	r3, #4
   26936:	d004      	beq.n	26942 <gnss_interface_read+0x32>
   26938:	682b      	ldr	r3, [r5, #0]
   2693a:	b29b      	uxth	r3, r3
   2693c:	2b02      	cmp	r3, #2
   2693e:	f040 81dc 	bne.w	26cfa <gnss_interface_read+0x3ea>
   26942:	f1ba 0f00 	cmp.w	sl, #0
   26946:	d178      	bne.n	26a3a <gnss_interface_read+0x12a>
   26948:	2102      	movs	r1, #2
   2694a:	20b6      	movs	r0, #182	; 0xb6
   2694c:	2400      	movs	r4, #0
   2694e:	682b      	ldr	r3, [r5, #0]
   26950:	f10d 020e 	add.w	r2, sp, #14
   26954:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   26958:	602b      	str	r3, [r5, #0]
   2695a:	ab08      	add	r3, sp, #32
   2695c:	9304      	str	r3, [sp, #16]
   2695e:	f8df b118 	ldr.w	fp, [pc, #280]	; 26a78 <gnss_interface_read+0x168>
   26962:	ea0a 0301 	and.w	r3, sl, r1
   26966:	4f43      	ldr	r7, [pc, #268]	; (26a74 <gnss_interface_read+0x164>)
   26968:	f8df 9110 	ldr.w	r9, [pc, #272]	; 26a7c <gnss_interface_read+0x16c>
   2696c:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 26a6c <gnss_interface_read+0x15c>
   26970:	9005      	str	r0, [sp, #20]
   26972:	9107      	str	r1, [sp, #28]
   26974:	9206      	str	r2, [sp, #24]
   26976:	9301      	str	r3, [sp, #4]
   26978:	f8db 0000 	ldr.w	r0, [fp]
   2697c:	4652      	mov	r2, sl
   2697e:	6803      	ldr	r3, [r0, #0]
   26980:	a904      	add	r1, sp, #16
   26982:	689b      	ldr	r3, [r3, #8]
   26984:	4798      	blx	r3
   26986:	2800      	cmp	r0, #0
   26988:	da2a      	bge.n	269e0 <gnss_interface_read+0xd0>
   2698a:	9b01      	ldr	r3, [sp, #4]
   2698c:	b15b      	cbz	r3, 269a6 <gnss_interface_read+0x96>
   2698e:	1c42      	adds	r2, r0, #1
   26990:	4603      	mov	r3, r0
   26992:	d125      	bne.n	269e0 <gnss_interface_read+0xd0>
   26994:	b9dc      	cbnz	r4, 269ce <gnss_interface_read+0xbe>
   26996:	2023      	movs	r0, #35	; 0x23
   26998:	461c      	mov	r4, r3
   2699a:	f7f9 fb61 	bl	20060 <bsd_os_errno_set>
   2699e:	4620      	mov	r0, r4
   269a0:	b037      	add	sp, #220	; 0xdc
   269a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   269a6:	682a      	ldr	r2, [r5, #0]
   269a8:	783b      	ldrb	r3, [r7, #0]
   269aa:	03d1      	lsls	r1, r2, #15
   269ac:	d40c      	bmi.n	269c8 <gnss_interface_read+0xb8>
   269ae:	b95c      	cbnz	r4, 269c8 <gnss_interface_read+0xb8>
   269b0:	b163      	cbz	r3, 269cc <gnss_interface_read+0xbc>
   269b2:	4649      	mov	r1, r9
   269b4:	4640      	mov	r0, r8
   269b6:	f7f9 faa9 	bl	1ff0c <bsd_os_timedwait>
   269ba:	682b      	ldr	r3, [r5, #0]
   269bc:	03db      	lsls	r3, r3, #15
   269be:	d437      	bmi.n	26a30 <gnss_interface_read+0x120>
   269c0:	783b      	ldrb	r3, [r7, #0]
   269c2:	2800      	cmp	r0, #0
   269c4:	d0f4      	beq.n	269b0 <gnss_interface_read+0xa0>
   269c6:	4604      	mov	r4, r0
   269c8:	2b00      	cmp	r3, #0
   269ca:	d1d5      	bne.n	26978 <gnss_interface_read+0x68>
   269cc:	2470      	movs	r4, #112	; 0x70
   269ce:	4620      	mov	r0, r4
   269d0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   269d4:	f7f9 fb44 	bl	20060 <bsd_os_errno_set>
   269d8:	4620      	mov	r0, r4
   269da:	b037      	add	sp, #220	; 0xdc
   269dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   269e0:	f244 0202 	movw	r2, #16386	; 0x4002
   269e4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   269e8:	4293      	cmp	r3, r2
   269ea:	d02f      	beq.n	26a4c <gnss_interface_read+0x13c>
   269ec:	f244 0201 	movw	r2, #16385	; 0x4001
   269f0:	4293      	cmp	r3, r2
   269f2:	d045      	beq.n	26a80 <gnss_interface_read+0x170>
   269f4:	f244 0203 	movw	r2, #16387	; 0x4003
   269f8:	4293      	cmp	r3, r2
   269fa:	f040 8184 	bne.w	26d06 <gnss_interface_read+0x3f6>
   269fe:	2203      	movs	r2, #3
   26a00:	2414      	movs	r4, #20
   26a02:	9b08      	ldr	r3, [sp, #32]
   26a04:	7032      	strb	r2, [r6, #0]
   26a06:	9a09      	ldr	r2, [sp, #36]	; 0x24
   26a08:	60b3      	str	r3, [r6, #8]
   26a0a:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
   26a0e:	e9c6 2303 	strd	r2, r3, [r6, #12]
   26a12:	f8db 0000 	ldr.w	r0, [fp]
   26a16:	6803      	ldr	r3, [r0, #0]
   26a18:	68db      	ldr	r3, [r3, #12]
   26a1a:	4798      	blx	r3
   26a1c:	2800      	cmp	r0, #0
   26a1e:	ddbe      	ble.n	2699e <gnss_interface_read+0x8e>
   26a20:	4620      	mov	r0, r4
   26a22:	682b      	ldr	r3, [r5, #0]
   26a24:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   26a28:	602b      	str	r3, [r5, #0]
   26a2a:	b037      	add	sp, #220	; 0xdc
   26a2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   26a30:	783b      	ldrb	r3, [r7, #0]
   26a32:	4604      	mov	r4, r0
   26a34:	2b00      	cmp	r3, #0
   26a36:	d19f      	bne.n	26978 <gnss_interface_read+0x68>
   26a38:	e7c8      	b.n	269cc <gnss_interface_read+0xbc>
   26a3a:	f01a 0f2a 	tst.w	sl, #42	; 0x2a
   26a3e:	d183      	bne.n	26948 <gnss_interface_read+0x38>
   26a40:	202d      	movs	r0, #45	; 0x2d
   26a42:	f7f9 fb0d 	bl	20060 <bsd_os_errno_set>
   26a46:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   26a4a:	e7a8      	b.n	2699e <gnss_interface_read+0x8e>
   26a4c:	a808      	add	r0, sp, #32
   26a4e:	f7eb fb17 	bl	12080 <strlen>
   26a52:	2302      	movs	r3, #2
   26a54:	1c44      	adds	r4, r0, #1
   26a56:	b2a4      	uxth	r4, r4
   26a58:	f806 3b08 	strb.w	r3, [r6], #8
   26a5c:	4622      	mov	r2, r4
   26a5e:	a908      	add	r1, sp, #32
   26a60:	4630      	mov	r0, r6
   26a62:	f012 fab9 	bl	38fd8 <memcpy>
   26a66:	3408      	adds	r4, #8
   26a68:	e7d3      	b.n	26a12 <gnss_interface_read+0x102>
   26a6a:	bf00      	nop
   26a6c:	49765443 	.word	0x49765443
   26a70:	200227a8 	.word	0x200227a8
   26a74:	20029088 	.word	0x20029088
   26a78:	200227b0 	.word	0x200227b0
   26a7c:	20020220 	.word	0x20020220
   26a80:	2401      	movs	r4, #1
   26a82:	a809      	add	r0, sp, #36	; 0x24
   26a84:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   26a86:	e9c6 0102 	strd	r0, r1, [r6, #8]
   26a8a:	e9c6 2304 	strd	r2, r3, [r6, #16]
   26a8e:	990d      	ldr	r1, [sp, #52]	; 0x34
   26a90:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26a92:	7034      	strb	r4, [r6, #0]
   26a94:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   26a96:	61b1      	str	r1, [r6, #24]
   26a98:	9910      	ldr	r1, [sp, #64]	; 0x40
   26a9a:	61f2      	str	r2, [r6, #28]
   26a9c:	6233      	str	r3, [r6, #32]
   26a9e:	f89d 205d 	ldrb.w	r2, [sp, #93]	; 0x5d
   26aa2:	f8dd 304d 	ldr.w	r3, [sp, #77]	; 0x4d
   26aa6:	6271      	str	r1, [r6, #36]	; 0x24
   26aa8:	f8dd 1051 	ldr.w	r1, [sp, #81]	; 0x51
   26aac:	f886 2044 	strb.w	r2, [r6, #68]	; 0x44
   26ab0:	f8dd 2055 	ldr.w	r2, [sp, #85]	; 0x55
   26ab4:	6373      	str	r3, [r6, #52]	; 0x34
   26ab6:	f8dd 3059 	ldr.w	r3, [sp, #89]	; 0x59
   26aba:	63b1      	str	r1, [r6, #56]	; 0x38
   26abc:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
   26ac0:	63f2      	str	r2, [r6, #60]	; 0x3c
   26ac2:	6433      	str	r3, [r6, #64]	; 0x40
   26ac4:	f8dd 2046 	ldr.w	r2, [sp, #70]	; 0x46
   26ac8:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   26acc:	8531      	strh	r1, [r6, #40]	; 0x28
   26ace:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
   26ad2:	f8c6 202a 	str.w	r2, [r6, #42]	; 0x2a
   26ad6:	f89d 004b 	ldrb.w	r0, [sp, #75]	; 0x4b
   26ada:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   26ade:	9b18      	ldr	r3, [sp, #96]	; 0x60
   26ae0:	f89d 406c 	ldrb.w	r4, [sp, #108]	; 0x6c
   26ae4:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
   26ae8:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   26aec:	f3c3 210f 	ubfx	r1, r3, #8, #16
   26af0:	9b1d      	ldr	r3, [sp, #116]	; 0x74
   26af2:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   26af6:	8630      	strh	r0, [r6, #48]	; 0x30
   26af8:	f8a6 104a 	strh.w	r1, [r6, #74]	; 0x4a
   26afc:	f8bd 105e 	ldrh.w	r1, [sp, #94]	; 0x5e
   26b00:	f3c3 230f 	ubfx	r3, r3, #8, #16
   26b04:	f8a6 2056 	strh.w	r2, [r6, #86]	; 0x56
   26b08:	f89d 2060 	ldrb.w	r2, [sp, #96]	; 0x60
   26b0c:	f8a6 3062 	strh.w	r3, [r6, #98]	; 0x62
   26b10:	f8dd 3063 	ldr.w	r3, [sp, #99]	; 0x63
   26b14:	f8a6 1046 	strh.w	r1, [r6, #70]	; 0x46
   26b18:	f886 2048 	strb.w	r2, [r6, #72]	; 0x48
   26b1c:	f8bd 2068 	ldrh.w	r2, [sp, #104]	; 0x68
   26b20:	f89d 1067 	ldrb.w	r1, [sp, #103]	; 0x67
   26b24:	64f3      	str	r3, [r6, #76]	; 0x4c
   26b26:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   26b2a:	f886 1050 	strb.w	r1, [r6, #80]	; 0x50
   26b2e:	f8a6 2052 	strh.w	r2, [r6, #82]	; 0x52
   26b32:	f886 3054 	strb.w	r3, [r6, #84]	; 0x54
   26b36:	f8bd 3072 	ldrh.w	r3, [sp, #114]	; 0x72
   26b3a:	f8dd 106d 	ldr.w	r1, [sp, #109]	; 0x6d
   26b3e:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   26b42:	65b1      	str	r1, [r6, #88]	; 0x58
   26b44:	f886 205c 	strb.w	r2, [r6, #92]	; 0x5c
   26b48:	f89d 1074 	ldrb.w	r1, [sp, #116]	; 0x74
   26b4c:	f8dd 2077 	ldr.w	r2, [sp, #119]	; 0x77
   26b50:	f8a6 305e 	strh.w	r3, [r6, #94]	; 0x5e
   26b54:	f89d 307b 	ldrb.w	r3, [sp, #123]	; 0x7b
   26b58:	f886 1060 	strb.w	r1, [r6, #96]	; 0x60
   26b5c:	6672      	str	r2, [r6, #100]	; 0x64
   26b5e:	f886 3068 	strb.w	r3, [r6, #104]	; 0x68
   26b62:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
   26b66:	f89d 107f 	ldrb.w	r1, [sp, #127]	; 0x7f
   26b6a:	9a22      	ldr	r2, [sp, #136]	; 0x88
   26b6c:	f89d 0094 	ldrb.w	r0, [sp, #148]	; 0x94
   26b70:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   26b74:	f89d 3093 	ldrb.w	r3, [sp, #147]	; 0x93
   26b78:	f3c2 220f 	ubfx	r2, r2, #8, #16
   26b7c:	f8a6 106e 	strh.w	r1, [r6, #110]	; 0x6e
   26b80:	f8bd 107c 	ldrh.w	r1, [sp, #124]	; 0x7c
   26b84:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   26b88:	f8a6 207a 	strh.w	r2, [r6, #122]	; 0x7a
   26b8c:	f89d 207e 	ldrb.w	r2, [sp, #126]	; 0x7e
   26b90:	f8a6 3086 	strh.w	r3, [r6, #134]	; 0x86
   26b94:	f8dd 3081 	ldr.w	r3, [sp, #129]	; 0x81
   26b98:	f8a6 106a 	strh.w	r1, [r6, #106]	; 0x6a
   26b9c:	f886 206c 	strb.w	r2, [r6, #108]	; 0x6c
   26ba0:	f8bd 2086 	ldrh.w	r2, [sp, #134]	; 0x86
   26ba4:	f89d 1085 	ldrb.w	r1, [sp, #133]	; 0x85
   26ba8:	6733      	str	r3, [r6, #112]	; 0x70
   26baa:	f89d 3088 	ldrb.w	r3, [sp, #136]	; 0x88
   26bae:	f886 1074 	strb.w	r1, [r6, #116]	; 0x74
   26bb2:	f8a6 2076 	strh.w	r2, [r6, #118]	; 0x76
   26bb6:	f886 3078 	strb.w	r3, [r6, #120]	; 0x78
   26bba:	f8bd 3090 	ldrh.w	r3, [sp, #144]	; 0x90
   26bbe:	f8dd 108b 	ldr.w	r1, [sp, #139]	; 0x8b
   26bc2:	f89d 208f 	ldrb.w	r2, [sp, #143]	; 0x8f
   26bc6:	67f1      	str	r1, [r6, #124]	; 0x7c
   26bc8:	f886 2080 	strb.w	r2, [r6, #128]	; 0x80
   26bcc:	f89d 1092 	ldrb.w	r1, [sp, #146]	; 0x92
   26bd0:	f8dd 2095 	ldr.w	r2, [sp, #149]	; 0x95
   26bd4:	f8a6 3082 	strh.w	r3, [r6, #130]	; 0x82
   26bd8:	f89d 3099 	ldrb.w	r3, [sp, #153]	; 0x99
   26bdc:	f886 1084 	strb.w	r1, [r6, #132]	; 0x84
   26be0:	f8c6 2088 	str.w	r2, [r6, #136]	; 0x88
   26be4:	f886 308c 	strb.w	r3, [r6, #140]	; 0x8c
   26be8:	f8bd 009a 	ldrh.w	r0, [sp, #154]	; 0x9a
   26bec:	9b27      	ldr	r3, [sp, #156]	; 0x9c
   26bee:	f89d 40a8 	ldrb.w	r4, [sp, #168]	; 0xa8
   26bf2:	f89d 20a7 	ldrb.w	r2, [sp, #167]	; 0xa7
   26bf6:	f3c3 210f 	ubfx	r1, r3, #8, #16
   26bfa:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
   26bfc:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
   26c00:	f8a6 1092 	strh.w	r1, [r6, #146]	; 0x92
   26c04:	f89d 109c 	ldrb.w	r1, [sp, #156]	; 0x9c
   26c08:	f8a6 209e 	strh.w	r2, [r6, #158]	; 0x9e
   26c0c:	f3c3 230f 	ubfx	r3, r3, #8, #16
   26c10:	f8dd 209f 	ldr.w	r2, [sp, #159]	; 0x9f
   26c14:	f8a6 008e 	strh.w	r0, [r6, #142]	; 0x8e
   26c18:	f8a6 30aa 	strh.w	r3, [r6, #170]	; 0xaa
   26c1c:	f886 1090 	strb.w	r1, [r6, #144]	; 0x90
   26c20:	f89d 30a3 	ldrb.w	r3, [sp, #163]	; 0xa3
   26c24:	f8bd 10a4 	ldrh.w	r1, [sp, #164]	; 0xa4
   26c28:	f8c6 2094 	str.w	r2, [r6, #148]	; 0x94
   26c2c:	f89d 20a6 	ldrb.w	r2, [sp, #166]	; 0xa6
   26c30:	f886 3098 	strb.w	r3, [r6, #152]	; 0x98
   26c34:	f8dd 30a9 	ldr.w	r3, [sp, #169]	; 0xa9
   26c38:	f8a6 109a 	strh.w	r1, [r6, #154]	; 0x9a
   26c3c:	f886 209c 	strb.w	r2, [r6, #156]	; 0x9c
   26c40:	f8bd 20ae 	ldrh.w	r2, [sp, #174]	; 0xae
   26c44:	f89d 10ad 	ldrb.w	r1, [sp, #173]	; 0xad
   26c48:	f8c6 30a0 	str.w	r3, [r6, #160]	; 0xa0
   26c4c:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   26c50:	f886 10a4 	strb.w	r1, [r6, #164]	; 0xa4
   26c54:	f8a6 20a6 	strh.w	r2, [r6, #166]	; 0xa6
   26c58:	f886 30a8 	strb.w	r3, [r6, #168]	; 0xa8
   26c5c:	f8bd 30b8 	ldrh.w	r3, [sp, #184]	; 0xb8
   26c60:	f8dd 10b3 	ldr.w	r1, [sp, #179]	; 0xb3
   26c64:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   26c68:	f8c6 10ac 	str.w	r1, [r6, #172]	; 0xac
   26c6c:	f886 20b0 	strb.w	r2, [r6, #176]	; 0xb0
   26c70:	f8a6 30b2 	strh.w	r3, [r6, #178]	; 0xb2
   26c74:	f89d 30bc 	ldrb.w	r3, [sp, #188]	; 0xbc
   26c78:	f89d 10bb 	ldrb.w	r1, [sp, #187]	; 0xbb
   26c7c:	f89d 00d0 	ldrb.w	r0, [sp, #208]	; 0xd0
   26c80:	9a31      	ldr	r2, [sp, #196]	; 0xc4
   26c82:	ea41 2103 	orr.w	r1, r1, r3, lsl #8
   26c86:	f89d 30cf 	ldrb.w	r3, [sp, #207]	; 0xcf
   26c8a:	f89d 40ba 	ldrb.w	r4, [sp, #186]	; 0xba
   26c8e:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   26c92:	f3c2 220f 	ubfx	r2, r2, #8, #16
   26c96:	f8a6 10b6 	strh.w	r1, [r6, #182]	; 0xb6
   26c9a:	f8a6 30ce 	strh.w	r3, [r6, #206]	; 0xce
   26c9e:	f886 40b4 	strb.w	r4, [r6, #180]	; 0xb4
   26ca2:	f8a6 20c2 	strh.w	r2, [r6, #194]	; 0xc2
   26ca6:	f8bd 20c2 	ldrh.w	r2, [sp, #194]	; 0xc2
   26caa:	f89d 10c1 	ldrb.w	r1, [sp, #193]	; 0xc1
   26cae:	f89d 30c4 	ldrb.w	r3, [sp, #196]	; 0xc4
   26cb2:	f8dd 00bd 	ldr.w	r0, [sp, #189]	; 0xbd
   26cb6:	f886 10bc 	strb.w	r1, [r6, #188]	; 0xbc
   26cba:	f8a6 20be 	strh.w	r2, [r6, #190]	; 0xbe
   26cbe:	f8c6 00b8 	str.w	r0, [r6, #184]	; 0xb8
   26cc2:	f886 30c0 	strb.w	r3, [r6, #192]	; 0xc0
   26cc6:	f8bd 30cc 	ldrh.w	r3, [sp, #204]	; 0xcc
   26cca:	f8dd 10c7 	ldr.w	r1, [sp, #199]	; 0xc7
   26cce:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   26cd2:	f8c6 10c4 	str.w	r1, [r6, #196]	; 0xc4
   26cd6:	f886 20c8 	strb.w	r2, [r6, #200]	; 0xc8
   26cda:	f89d 10ce 	ldrb.w	r1, [sp, #206]	; 0xce
   26cde:	f8dd 20d1 	ldr.w	r2, [sp, #209]	; 0xd1
   26ce2:	f8a6 30ca 	strh.w	r3, [r6, #202]	; 0xca
   26ce6:	f89d 30d5 	ldrb.w	r3, [sp, #213]	; 0xd5
   26cea:	f886 10cc 	strb.w	r1, [r6, #204]	; 0xcc
   26cee:	f8c6 20d0 	str.w	r2, [r6, #208]	; 0xd0
   26cf2:	f886 30d4 	strb.w	r3, [r6, #212]	; 0xd4
   26cf6:	24d8      	movs	r4, #216	; 0xd8
   26cf8:	e68b      	b.n	26a12 <gnss_interface_read+0x102>
   26cfa:	2039      	movs	r0, #57	; 0x39
   26cfc:	f7f9 f9b0 	bl	20060 <bsd_os_errno_set>
   26d00:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   26d04:	e64b      	b.n	2699e <gnss_interface_read+0x8e>
   26d06:	2016      	movs	r0, #22
   26d08:	f7f9 f9aa 	bl	20060 <bsd_os_errno_set>
   26d0c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   26d10:	e645      	b.n	2699e <gnss_interface_read+0x8e>
   26d12:	2009      	movs	r0, #9
   26d14:	f7f9 f9a4 	bl	20060 <bsd_os_errno_set>
   26d18:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   26d1c:	e63f      	b.n	2699e <gnss_interface_read+0x8e>
   26d1e:	bf00      	nop

00026d20 <gnss_interface_setopt>:
   26d20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   26d24:	4db3      	ldr	r5, [pc, #716]	; (26ff4 <gnss_interface_setopt+0x2d4>)
   26d26:	b086      	sub	sp, #24
   26d28:	682c      	ldr	r4, [r5, #0]
   26d2a:	b2a4      	uxth	r4, r4
   26d2c:	2c02      	cmp	r4, #2
   26d2e:	d00d      	beq.n	26d4c <gnss_interface_setopt+0x2c>
   26d30:	2a08      	cmp	r2, #8
   26d32:	d00b      	beq.n	26d4c <gnss_interface_setopt+0x2c>
   26d34:	f1a2 040a 	sub.w	r4, r2, #10
   26d38:	2c01      	cmp	r4, #1
   26d3a:	d907      	bls.n	26d4c <gnss_interface_setopt+0x2c>
   26d3c:	200e      	movs	r0, #14
   26d3e:	f7f9 f98f 	bl	20060 <bsd_os_errno_set>
   26d42:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26d46:	b006      	add	sp, #24
   26d48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   26d4c:	682c      	ldr	r4, [r5, #0]
   26d4e:	0264      	lsls	r4, r4, #9
   26d50:	f100 8149 	bmi.w	26fe6 <gnss_interface_setopt+0x2c6>
   26d54:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   26d58:	f040 8139 	bne.w	26fce <gnss_interface_setopt+0x2ae>
   26d5c:	49a6      	ldr	r1, [pc, #664]	; (26ff8 <gnss_interface_setopt+0x2d8>)
   26d5e:	4288      	cmp	r0, r1
   26d60:	f040 813b 	bne.w	26fda <gnss_interface_setopt+0x2ba>
   26d64:	f1a2 010a 	sub.w	r1, r2, #10
   26d68:	2901      	cmp	r1, #1
   26d6a:	d902      	bls.n	26d72 <gnss_interface_setopt+0x52>
   26d6c:	2b00      	cmp	r3, #0
   26d6e:	f000 8112 	beq.w	26f96 <gnss_interface_setopt+0x276>
   26d72:	3a01      	subs	r2, #1
   26d74:	2a0a      	cmp	r2, #10
   26d76:	f200 810e 	bhi.w	26f96 <gnss_interface_setopt+0x276>
   26d7a:	e8df f012 	tbh	[pc, r2, lsl #1]
   26d7e:	007f      	.short	0x007f
   26d80:	0098008c 	.word	0x0098008c
   26d84:	00ae00a2 	.word	0x00ae00a2
   26d88:	00c500b9 	.word	0x00c500b9
   26d8c:	00f300dd 	.word	0x00f300dd
   26d90:	000b00ff 	.word	0x000b00ff
   26d94:	682b      	ldr	r3, [r5, #0]
   26d96:	b29b      	uxth	r3, r3
   26d98:	2b04      	cmp	r3, #4
   26d9a:	d1cf      	bne.n	26d3c <gnss_interface_setopt+0x1c>
   26d9c:	2203      	movs	r2, #3
   26d9e:	f241 0604 	movw	r6, #4100	; 0x1004
   26da2:	2300      	movs	r3, #0
   26da4:	4637      	mov	r7, r6
   26da6:	f88d 2008 	strb.w	r2, [sp, #8]
   26daa:	f88d 3009 	strb.w	r3, [sp, #9]
   26dae:	f88d 300a 	strb.w	r3, [sp, #10]
   26db2:	f88d 300b 	strb.w	r3, [sp, #11]
   26db6:	f88d 300c 	strb.w	r3, [sp, #12]
   26dba:	682b      	ldr	r3, [r5, #0]
   26dbc:	2112      	movs	r1, #18
   26dbe:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
   26dc2:	4668      	mov	r0, sp
   26dc4:	602b      	str	r3, [r5, #0]
   26dc6:	f002 faa1 	bl	2930c <rpc_gnss_client_request_alloc>
   26dca:	4604      	mov	r4, r0
   26dcc:	9800      	ldr	r0, [sp, #0]
   26dce:	2c00      	cmp	r4, #0
   26dd0:	f040 80e7 	bne.w	26fa2 <gnss_interface_setopt+0x282>
   26dd4:	2800      	cmp	r0, #0
   26dd6:	f000 80eb 	beq.w	26fb0 <gnss_interface_setopt+0x290>
   26dda:	2212      	movs	r2, #18
   26ddc:	f04f 0876 	mov.w	r8, #118	; 0x76
   26de0:	f04f 0e49 	mov.w	lr, #73	; 0x49
   26de4:	f04f 0a43 	mov.w	sl, #67	; 0x43
   26de8:	f04f 0954 	mov.w	r9, #84	; 0x54
   26dec:	f8df c210 	ldr.w	ip, [pc, #528]	; 27000 <gnss_interface_setopt+0x2e0>
   26df0:	a906      	add	r1, sp, #24
   26df2:	f8bc 3000 	ldrh.w	r3, [ip]
   26df6:	f880 800e 	strb.w	r8, [r0, #14]
   26dfa:	3301      	adds	r3, #1
   26dfc:	b29b      	uxth	r3, r3
   26dfe:	ea46 4603 	orr.w	r6, r6, r3, lsl #16
   26e02:	f841 6d14 	str.w	r6, [r1, #-20]!
   26e06:	7144      	strb	r4, [r0, #5]
   26e08:	7184      	strb	r4, [r0, #6]
   26e0a:	71c4      	strb	r4, [r0, #7]
   26e0c:	7204      	strb	r4, [r0, #8]
   26e0e:	7244      	strb	r4, [r0, #9]
   26e10:	7284      	strb	r4, [r0, #10]
   26e12:	72c4      	strb	r4, [r0, #11]
   26e14:	7102      	strb	r2, [r0, #4]
   26e16:	f880 a00c 	strb.w	sl, [r0, #12]
   26e1a:	f880 900d 	strb.w	r9, [r0, #13]
   26e1e:	f880 e00f 	strb.w	lr, [r0, #15]
   26e22:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 27004 <gnss_interface_setopt+0x2e4>
   26e26:	6800      	ldr	r0, [r0, #0]
   26e28:	f8ac 3000 	strh.w	r3, [ip]
   26e2c:	f012 f8d4 	bl	38fd8 <memcpy>
   26e30:	4639      	mov	r1, r7
   26e32:	9800      	ldr	r0, [sp, #0]
   26e34:	f8c8 4000 	str.w	r4, [r8]
   26e38:	f002 fa7c 	bl	29334 <rpc_gnss_client_request_send>
   26e3c:	2800      	cmp	r0, #0
   26e3e:	f040 80bc 	bne.w	26fba <gnss_interface_setopt+0x29a>
   26e42:	4f6e      	ldr	r7, [pc, #440]	; (26ffc <gnss_interface_setopt+0x2dc>)
   26e44:	4e6c      	ldr	r6, [pc, #432]	; (26ff8 <gnss_interface_setopt+0x2d8>)
   26e46:	4639      	mov	r1, r7
   26e48:	4630      	mov	r0, r6
   26e4a:	f7f9 f85f 	bl	1ff0c <bsd_os_timedwait>
   26e4e:	682c      	ldr	r4, [r5, #0]
   26e50:	f414 0480 	ands.w	r4, r4, #4194304	; 0x400000
   26e54:	d1f7      	bne.n	26e46 <gnss_interface_setopt+0x126>
   26e56:	f8d8 0000 	ldr.w	r0, [r8]
   26e5a:	b118      	cbz	r0, 26e64 <gnss_interface_setopt+0x144>
   26e5c:	f002 fa88 	bl	29370 <rpc_gnss_client_data_free>
   26e60:	f8c8 4000 	str.w	r4, [r8]
   26e64:	682b      	ldr	r3, [r5, #0]
   26e66:	021b      	lsls	r3, r3, #8
   26e68:	f140 808f 	bpl.w	26f8a <gnss_interface_setopt+0x26a>
   26e6c:	2000      	movs	r0, #0
   26e6e:	682b      	ldr	r3, [r5, #0]
   26e70:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
   26e74:	602b      	str	r3, [r5, #0]
   26e76:	b006      	add	sp, #24
   26e78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   26e7c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26e7e:	2a02      	cmp	r2, #2
   26e80:	f040 8089 	bne.w	26f96 <gnss_interface_setopt+0x276>
   26e84:	2208      	movs	r2, #8
   26e86:	f241 1603 	movw	r6, #4355	; 0x1103
   26e8a:	881b      	ldrh	r3, [r3, #0]
   26e8c:	9202      	str	r2, [sp, #8]
   26e8e:	f8ad 300f 	strh.w	r3, [sp, #15]
   26e92:	4637      	mov	r7, r6
   26e94:	e791      	b.n	26dba <gnss_interface_setopt+0x9a>
   26e96:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26e98:	2a02      	cmp	r2, #2
   26e9a:	d17c      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26e9c:	2210      	movs	r2, #16
   26e9e:	f241 1603 	movw	r6, #4355	; 0x1103
   26ea2:	881b      	ldrh	r3, [r3, #0]
   26ea4:	9202      	str	r2, [sp, #8]
   26ea6:	f8ad 3011 	strh.w	r3, [sp, #17]
   26eaa:	4637      	mov	r7, r6
   26eac:	e785      	b.n	26dba <gnss_interface_setopt+0x9a>
   26eae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26eb0:	2a01      	cmp	r2, #1
   26eb2:	d170      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26eb4:	781b      	ldrb	r3, [r3, #0]
   26eb6:	2b01      	cmp	r3, #1
   26eb8:	d16d      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26eba:	f241 1603 	movw	r6, #4355	; 0x1103
   26ebe:	4637      	mov	r7, r6
   26ec0:	e77b      	b.n	26dba <gnss_interface_setopt+0x9a>
   26ec2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26ec4:	2a02      	cmp	r2, #2
   26ec6:	d166      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26ec8:	2220      	movs	r2, #32
   26eca:	f241 1603 	movw	r6, #4355	; 0x1103
   26ece:	881b      	ldrh	r3, [r3, #0]
   26ed0:	9202      	str	r2, [sp, #8]
   26ed2:	f8ad 3013 	strh.w	r3, [sp, #19]
   26ed6:	4637      	mov	r7, r6
   26ed8:	e76f      	b.n	26dba <gnss_interface_setopt+0x9a>
   26eda:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26edc:	2a01      	cmp	r2, #1
   26ede:	d15a      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26ee0:	f241 1603 	movw	r6, #4355	; 0x1103
   26ee4:	781b      	ldrb	r3, [r3, #0]
   26ee6:	9202      	str	r2, [sp, #8]
   26ee8:	f88d 300c 	strb.w	r3, [sp, #12]
   26eec:	4637      	mov	r7, r6
   26eee:	e764      	b.n	26dba <gnss_interface_setopt+0x9a>
   26ef0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26ef2:	2a01      	cmp	r2, #1
   26ef4:	d14f      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26ef6:	2202      	movs	r2, #2
   26ef8:	f241 1603 	movw	r6, #4355	; 0x1103
   26efc:	781b      	ldrb	r3, [r3, #0]
   26efe:	9202      	str	r2, [sp, #8]
   26f00:	f88d 300d 	strb.w	r3, [sp, #13]
   26f04:	4637      	mov	r7, r6
   26f06:	e758      	b.n	26dba <gnss_interface_setopt+0x9a>
   26f08:	682a      	ldr	r2, [r5, #0]
   26f0a:	b292      	uxth	r2, r2
   26f0c:	2a02      	cmp	r2, #2
   26f0e:	f47f af15 	bne.w	26d3c <gnss_interface_setopt+0x1c>
   26f12:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26f14:	2a04      	cmp	r2, #4
   26f16:	d13e      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26f18:	2101      	movs	r1, #1
   26f1a:	f241 0604 	movw	r6, #4100	; 0x1004
   26f1e:	682a      	ldr	r2, [r5, #0]
   26f20:	6818      	ldr	r0, [r3, #0]
   26f22:	0c13      	lsrs	r3, r2, #16
   26f24:	041b      	lsls	r3, r3, #16
   26f26:	f043 0303 	orr.w	r3, r3, #3
   26f2a:	f8cd 0009 	str.w	r0, [sp, #9]
   26f2e:	602b      	str	r3, [r5, #0]
   26f30:	f88d 1008 	strb.w	r1, [sp, #8]
   26f34:	4637      	mov	r7, r6
   26f36:	e740      	b.n	26dba <gnss_interface_setopt+0x9a>
   26f38:	682a      	ldr	r2, [r5, #0]
   26f3a:	b292      	uxth	r2, r2
   26f3c:	2a04      	cmp	r2, #4
   26f3e:	d004      	beq.n	26f4a <gnss_interface_setopt+0x22a>
   26f40:	682a      	ldr	r2, [r5, #0]
   26f42:	b292      	uxth	r2, r2
   26f44:	2a02      	cmp	r2, #2
   26f46:	f47f aef9 	bne.w	26d3c <gnss_interface_setopt+0x1c>
   26f4a:	2200      	movs	r2, #0
   26f4c:	f88d 2008 	strb.w	r2, [sp, #8]
   26f50:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26f52:	2a04      	cmp	r2, #4
   26f54:	d11f      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26f56:	f241 0604 	movw	r6, #4100	; 0x1004
   26f5a:	681b      	ldr	r3, [r3, #0]
   26f5c:	4637      	mov	r7, r6
   26f5e:	f8cd 3009 	str.w	r3, [sp, #9]
   26f62:	e72a      	b.n	26dba <gnss_interface_setopt+0x9a>
   26f64:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   26f66:	2a01      	cmp	r2, #1
   26f68:	d115      	bne.n	26f96 <gnss_interface_setopt+0x276>
   26f6a:	2240      	movs	r2, #64	; 0x40
   26f6c:	f241 1603 	movw	r6, #4355	; 0x1103
   26f70:	781b      	ldrb	r3, [r3, #0]
   26f72:	9202      	str	r2, [sp, #8]
   26f74:	f88d 3015 	strb.w	r3, [sp, #21]
   26f78:	4637      	mov	r7, r6
   26f7a:	e71e      	b.n	26dba <gnss_interface_setopt+0x9a>
   26f7c:	682b      	ldr	r3, [r5, #0]
   26f7e:	b29b      	uxth	r3, r3
   26f80:	2b04      	cmp	r3, #4
   26f82:	f47f aedb 	bne.w	26d3c <gnss_interface_setopt+0x1c>
   26f86:	2202      	movs	r2, #2
   26f88:	e709      	b.n	26d9e <gnss_interface_setopt+0x7e>
   26f8a:	200e      	movs	r0, #14
   26f8c:	f7f9 f868 	bl	20060 <bsd_os_errno_set>
   26f90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26f94:	e76b      	b.n	26e6e <gnss_interface_setopt+0x14e>
   26f96:	2016      	movs	r0, #22
   26f98:	f7f9 f862 	bl	20060 <bsd_os_errno_set>
   26f9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26fa0:	e6d1      	b.n	26d46 <gnss_interface_setopt+0x26>
   26fa2:	b128      	cbz	r0, 26fb0 <gnss_interface_setopt+0x290>
   26fa4:	6803      	ldr	r3, [r0, #0]
   26fa6:	b11b      	cbz	r3, 26fb0 <gnss_interface_setopt+0x290>
   26fa8:	4618      	mov	r0, r3
   26faa:	f002 f9e1 	bl	29370 <rpc_gnss_client_data_free>
   26fae:	9800      	ldr	r0, [sp, #0]
   26fb0:	f002 f9d6 	bl	29360 <rpc_gnss_client_message_free>
   26fb4:	2023      	movs	r0, #35	; 0x23
   26fb6:	f7f9 f853 	bl	20060 <bsd_os_errno_set>
   26fba:	682b      	ldr	r3, [r5, #0]
   26fbc:	200e      	movs	r0, #14
   26fbe:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
   26fc2:	602b      	str	r3, [r5, #0]
   26fc4:	f7f9 f84c 	bl	20060 <bsd_os_errno_set>
   26fc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26fcc:	e6bb      	b.n	26d46 <gnss_interface_setopt+0x26>
   26fce:	202a      	movs	r0, #42	; 0x2a
   26fd0:	f7f9 f846 	bl	20060 <bsd_os_errno_set>
   26fd4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26fd8:	e6b5      	b.n	26d46 <gnss_interface_setopt+0x26>
   26fda:	2009      	movs	r0, #9
   26fdc:	f7f9 f840 	bl	20060 <bsd_os_errno_set>
   26fe0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26fe4:	e6af      	b.n	26d46 <gnss_interface_setopt+0x26>
   26fe6:	2073      	movs	r0, #115	; 0x73
   26fe8:	f7f9 f83a 	bl	20060 <bsd_os_errno_set>
   26fec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   26ff0:	e6a9      	b.n	26d46 <gnss_interface_setopt+0x26>
   26ff2:	bf00      	nop
   26ff4:	200227a8 	.word	0x200227a8
   26ff8:	49765443 	.word	0x49765443
   26ffc:	20020220 	.word	0x20020220
   27000:	2002761e 	.word	0x2002761e
   27004:	200227ac 	.word	0x200227ac

00027008 <gnss_interface_getopt>:
   27008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2700c:	4c81      	ldr	r4, [pc, #516]	; (27214 <gnss_interface_getopt+0x20c>)
   2700e:	b087      	sub	sp, #28
   27010:	6825      	ldr	r5, [r4, #0]
   27012:	4698      	mov	r8, r3
   27014:	b2ad      	uxth	r5, r5
   27016:	2d02      	cmp	r5, #2
   27018:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2701a:	f040 80dd 	bne.w	271d8 <gnss_interface_getopt+0x1d0>
   2701e:	6825      	ldr	r5, [r4, #0]
   27020:	03ee      	lsls	r6, r5, #15
   27022:	f100 80eb 	bmi.w	271fc <gnss_interface_getopt+0x1f4>
   27026:	6825      	ldr	r5, [r4, #0]
   27028:	01ed      	lsls	r5, r5, #7
   2702a:	f100 80ed 	bmi.w	27208 <gnss_interface_getopt+0x200>
   2702e:	f5b1 7f01 	cmp.w	r1, #516	; 0x204
   27032:	f040 80d7 	bne.w	271e4 <gnss_interface_getopt+0x1dc>
   27036:	4978      	ldr	r1, [pc, #480]	; (27218 <gnss_interface_getopt+0x210>)
   27038:	4288      	cmp	r0, r1
   2703a:	f040 80d9 	bne.w	271f0 <gnss_interface_getopt+0x1e8>
   2703e:	f1b8 0f00 	cmp.w	r8, #0
   27042:	d00b      	beq.n	2705c <gnss_interface_getopt+0x54>
   27044:	b153      	cbz	r3, 2705c <gnss_interface_getopt+0x54>
   27046:	1e57      	subs	r7, r2, #1
   27048:	2f05      	cmp	r7, #5
   2704a:	d807      	bhi.n	2705c <gnss_interface_getopt+0x54>
   2704c:	e8df f007 	tbb	[pc, r7]
   27050:	0f030f0f 	.word	0x0f030f0f
   27054:	0303      	.short	0x0303
   27056:	681b      	ldr	r3, [r3, #0]
   27058:	2b01      	cmp	r3, #1
   2705a:	d00b      	beq.n	27074 <gnss_interface_getopt+0x6c>
   2705c:	2016      	movs	r0, #22
   2705e:	f7f8 ffff 	bl	20060 <bsd_os_errno_set>
   27062:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   27066:	4628      	mov	r0, r5
   27068:	b007      	add	sp, #28
   2706a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2706e:	681b      	ldr	r3, [r3, #0]
   27070:	2b02      	cmp	r3, #2
   27072:	d1f3      	bne.n	2705c <gnss_interface_getopt+0x54>
   27074:	6823      	ldr	r3, [r4, #0]
   27076:	2212      	movs	r2, #18
   27078:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   2707c:	2100      	movs	r1, #0
   2707e:	a801      	add	r0, sp, #4
   27080:	6023      	str	r3, [r4, #0]
   27082:	f011 ffe3 	bl	3904c <memset>
   27086:	2112      	movs	r1, #18
   27088:	4668      	mov	r0, sp
   2708a:	f002 f93f 	bl	2930c <rpc_gnss_client_request_alloc>
   2708e:	4605      	mov	r5, r0
   27090:	9800      	ldr	r0, [sp, #0]
   27092:	2d00      	cmp	r5, #0
   27094:	f040 808a 	bne.w	271ac <gnss_interface_getopt+0x1a4>
   27098:	2800      	cmp	r0, #0
   2709a:	f000 808e 	beq.w	271ba <gnss_interface_getopt+0x1b2>
   2709e:	f241 1602 	movw	r6, #4354	; 0x1102
   270a2:	f04f 0e49 	mov.w	lr, #73	; 0x49
   270a6:	2212      	movs	r2, #18
   270a8:	f04f 0976 	mov.w	r9, #118	; 0x76
   270ac:	f04f 0b43 	mov.w	fp, #67	; 0x43
   270b0:	f04f 0a54 	mov.w	sl, #84	; 0x54
   270b4:	f8df c168 	ldr.w	ip, [pc, #360]	; 27220 <gnss_interface_getopt+0x218>
   270b8:	f880 e00f 	strb.w	lr, [r0, #15]
   270bc:	f8bc 3000 	ldrh.w	r3, [ip]
   270c0:	f880 900e 	strb.w	r9, [r0, #14]
   270c4:	3301      	adds	r3, #1
   270c6:	b29b      	uxth	r3, r3
   270c8:	ea46 4e03 	orr.w	lr, r6, r3, lsl #16
   270cc:	f8cd e004 	str.w	lr, [sp, #4]
   270d0:	7145      	strb	r5, [r0, #5]
   270d2:	7185      	strb	r5, [r0, #6]
   270d4:	71c5      	strb	r5, [r0, #7]
   270d6:	7205      	strb	r5, [r0, #8]
   270d8:	7245      	strb	r5, [r0, #9]
   270da:	7285      	strb	r5, [r0, #10]
   270dc:	72c5      	strb	r5, [r0, #11]
   270de:	a901      	add	r1, sp, #4
   270e0:	7102      	strb	r2, [r0, #4]
   270e2:	f880 b00c 	strb.w	fp, [r0, #12]
   270e6:	f880 a00d 	strb.w	sl, [r0, #13]
   270ea:	f8df 9138 	ldr.w	r9, [pc, #312]	; 27224 <gnss_interface_getopt+0x21c>
   270ee:	6800      	ldr	r0, [r0, #0]
   270f0:	f8ac 3000 	strh.w	r3, [ip]
   270f4:	f011 ff70 	bl	38fd8 <memcpy>
   270f8:	4631      	mov	r1, r6
   270fa:	9800      	ldr	r0, [sp, #0]
   270fc:	f8c9 5000 	str.w	r5, [r9]
   27100:	f002 f918 	bl	29334 <rpc_gnss_client_request_send>
   27104:	2800      	cmp	r0, #0
   27106:	d15d      	bne.n	271c4 <gnss_interface_getopt+0x1bc>
   27108:	4e44      	ldr	r6, [pc, #272]	; (2721c <gnss_interface_getopt+0x214>)
   2710a:	4d43      	ldr	r5, [pc, #268]	; (27218 <gnss_interface_getopt+0x210>)
   2710c:	4631      	mov	r1, r6
   2710e:	4628      	mov	r0, r5
   27110:	f7f8 fefc 	bl	1ff0c <bsd_os_timedwait>
   27114:	6823      	ldr	r3, [r4, #0]
   27116:	01db      	lsls	r3, r3, #7
   27118:	d4f8      	bmi.n	2710c <gnss_interface_getopt+0x104>
   2711a:	f8d9 0000 	ldr.w	r0, [r9]
   2711e:	b1d8      	cbz	r0, 27158 <gnss_interface_getopt+0x150>
   27120:	6825      	ldr	r5, [r4, #0]
   27122:	f015 7500 	ands.w	r5, r5, #33554432	; 0x2000000
   27126:	d00f      	beq.n	27148 <gnss_interface_getopt+0x140>
   27128:	2f05      	cmp	r7, #5
   2712a:	d837      	bhi.n	2719c <gnss_interface_getopt+0x194>
   2712c:	e8df f007 	tbb	[pc, r7]
   27130:	2b26201a 	.word	0x2b26201a
   27134:	0331      	.short	0x0331
   27136:	2500      	movs	r5, #0
   27138:	7b43      	ldrb	r3, [r0, #13]
   2713a:	f888 3000 	strb.w	r3, [r8]
   2713e:	f002 f917 	bl	29370 <rpc_gnss_client_data_free>
   27142:	2300      	movs	r3, #0
   27144:	f8c9 3000 	str.w	r3, [r9]
   27148:	6823      	ldr	r3, [r4, #0]
   2714a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   2714e:	6023      	str	r3, [r4, #0]
   27150:	4628      	mov	r0, r5
   27152:	b007      	add	sp, #28
   27154:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27158:	6823      	ldr	r3, [r4, #0]
   2715a:	4605      	mov	r5, r0
   2715c:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
   27160:	6023      	str	r3, [r4, #0]
   27162:	e7f5      	b.n	27150 <gnss_interface_getopt+0x148>
   27164:	f8b0 300f 	ldrh.w	r3, [r0, #15]
   27168:	2500      	movs	r5, #0
   2716a:	f8a8 3000 	strh.w	r3, [r8]
   2716e:	e7e6      	b.n	2713e <gnss_interface_getopt+0x136>
   27170:	f8b0 3011 	ldrh.w	r3, [r0, #17]
   27174:	2500      	movs	r5, #0
   27176:	f8a8 3000 	strh.w	r3, [r8]
   2717a:	e7e0      	b.n	2713e <gnss_interface_getopt+0x136>
   2717c:	7b83      	ldrb	r3, [r0, #14]
   2717e:	2500      	movs	r5, #0
   27180:	f888 3000 	strb.w	r3, [r8]
   27184:	e7db      	b.n	2713e <gnss_interface_getopt+0x136>
   27186:	f8b0 3013 	ldrh.w	r3, [r0, #19]
   2718a:	2500      	movs	r5, #0
   2718c:	f8a8 3000 	strh.w	r3, [r8]
   27190:	e7d5      	b.n	2713e <gnss_interface_getopt+0x136>
   27192:	7b03      	ldrb	r3, [r0, #12]
   27194:	2500      	movs	r5, #0
   27196:	f888 3000 	strb.w	r3, [r8]
   2719a:	e7d0      	b.n	2713e <gnss_interface_getopt+0x136>
   2719c:	2016      	movs	r0, #22
   2719e:	f7f8 ff5f 	bl	20060 <bsd_os_errno_set>
   271a2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   271a6:	f8d9 0000 	ldr.w	r0, [r9]
   271aa:	e7c8      	b.n	2713e <gnss_interface_getopt+0x136>
   271ac:	b128      	cbz	r0, 271ba <gnss_interface_getopt+0x1b2>
   271ae:	6803      	ldr	r3, [r0, #0]
   271b0:	b11b      	cbz	r3, 271ba <gnss_interface_getopt+0x1b2>
   271b2:	4618      	mov	r0, r3
   271b4:	f002 f8dc 	bl	29370 <rpc_gnss_client_data_free>
   271b8:	9800      	ldr	r0, [sp, #0]
   271ba:	f002 f8d1 	bl	29360 <rpc_gnss_client_message_free>
   271be:	2023      	movs	r0, #35	; 0x23
   271c0:	f7f8 ff4e 	bl	20060 <bsd_os_errno_set>
   271c4:	6823      	ldr	r3, [r4, #0]
   271c6:	200e      	movs	r0, #14
   271c8:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
   271cc:	6023      	str	r3, [r4, #0]
   271ce:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   271d2:	f7f8 ff45 	bl	20060 <bsd_os_errno_set>
   271d6:	e746      	b.n	27066 <gnss_interface_getopt+0x5e>
   271d8:	200e      	movs	r0, #14
   271da:	f7f8 ff41 	bl	20060 <bsd_os_errno_set>
   271de:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   271e2:	e740      	b.n	27066 <gnss_interface_getopt+0x5e>
   271e4:	202a      	movs	r0, #42	; 0x2a
   271e6:	f7f8 ff3b 	bl	20060 <bsd_os_errno_set>
   271ea:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   271ee:	e73a      	b.n	27066 <gnss_interface_getopt+0x5e>
   271f0:	2009      	movs	r0, #9
   271f2:	f7f8 ff35 	bl	20060 <bsd_os_errno_set>
   271f6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   271fa:	e734      	b.n	27066 <gnss_interface_getopt+0x5e>
   271fc:	2005      	movs	r0, #5
   271fe:	f7f8 ff2f 	bl	20060 <bsd_os_errno_set>
   27202:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   27206:	e72e      	b.n	27066 <gnss_interface_getopt+0x5e>
   27208:	2073      	movs	r0, #115	; 0x73
   2720a:	f7f8 ff29 	bl	20060 <bsd_os_errno_set>
   2720e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   27212:	e728      	b.n	27066 <gnss_interface_getopt+0x5e>
   27214:	200227a8 	.word	0x200227a8
   27218:	49765443 	.word	0x49765443
   2721c:	20020220 	.word	0x20020220
   27220:	2002761e 	.word	0x2002761e
   27224:	200227ac 	.word	0x200227ac

00027228 <gnss_interface_init>:
   27228:	2100      	movs	r1, #0
   2722a:	b538      	push	{r3, r4, r5, lr}
   2722c:	4c0a      	ldr	r4, [pc, #40]	; (27258 <gnss_interface_init+0x30>)
   2722e:	4d0b      	ldr	r5, [pc, #44]	; (2725c <gnss_interface_init+0x34>)
   27230:	6822      	ldr	r2, [r4, #0]
   27232:	480b      	ldr	r0, [pc, #44]	; (27260 <gnss_interface_init+0x38>)
   27234:	4b0b      	ldr	r3, [pc, #44]	; (27264 <gnss_interface_init+0x3c>)
   27236:	402a      	ands	r2, r5
   27238:	6022      	str	r2, [r4, #0]
   2723a:	8001      	strh	r1, [r0, #0]
   2723c:	6019      	str	r1, [r3, #0]
   2723e:	f002 f85f 	bl	29300 <rpc_gnss_client_init>
   27242:	b938      	cbnz	r0, 27254 <gnss_interface_init+0x2c>
   27244:	2101      	movs	r1, #1
   27246:	6823      	ldr	r3, [r4, #0]
   27248:	4a07      	ldr	r2, [pc, #28]	; (27268 <gnss_interface_init+0x40>)
   2724a:	402b      	ands	r3, r5
   2724c:	430b      	orrs	r3, r1
   2724e:	7011      	strb	r1, [r2, #0]
   27250:	6023      	str	r3, [r4, #0]
   27252:	bd38      	pop	{r3, r4, r5, pc}
   27254:	2003      	movs	r0, #3
   27256:	bd38      	pop	{r3, r4, r5, pc}
   27258:	200227a8 	.word	0x200227a8
   2725c:	ffff0000 	.word	0xffff0000
   27260:	2002761e 	.word	0x2002761e
   27264:	200227ac 	.word	0x200227ac
   27268:	20029088 	.word	0x20029088

0002726c <gnss_interface_open>:
   2726c:	b510      	push	{r4, lr}
   2726e:	4b1c      	ldr	r3, [pc, #112]	; (272e0 <gnss_interface_open+0x74>)
   27270:	781b      	ldrb	r3, [r3, #0]
   27272:	b34b      	cbz	r3, 272c8 <gnss_interface_open+0x5c>
   27274:	2902      	cmp	r1, #2
   27276:	d121      	bne.n	272bc <gnss_interface_open+0x50>
   27278:	4c1a      	ldr	r4, [pc, #104]	; (272e4 <gnss_interface_open+0x78>)
   2727a:	6823      	ldr	r3, [r4, #0]
   2727c:	b29b      	uxth	r3, r3
   2727e:	2b01      	cmp	r3, #1
   27280:	d116      	bne.n	272b0 <gnss_interface_open+0x44>
   27282:	6823      	ldr	r3, [r4, #0]
   27284:	4608      	mov	r0, r1
   27286:	0c1b      	lsrs	r3, r3, #16
   27288:	041b      	lsls	r3, r3, #16
   2728a:	f043 0302 	orr.w	r3, r3, #2
   2728e:	2200      	movs	r2, #0
   27290:	4915      	ldr	r1, [pc, #84]	; (272e8 <gnss_interface_open+0x7c>)
   27292:	6023      	str	r3, [r4, #0]
   27294:	f002 f956 	bl	29544 <packet_handler_create>
   27298:	4a14      	ldr	r2, [pc, #80]	; (272ec <gnss_interface_open+0x80>)
   2729a:	6010      	str	r0, [r2, #0]
   2729c:	b1d0      	cbz	r0, 272d4 <gnss_interface_open+0x68>
   2729e:	6823      	ldr	r3, [r4, #0]
   272a0:	6802      	ldr	r2, [r0, #0]
   272a2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   272a6:	6812      	ldr	r2, [r2, #0]
   272a8:	6023      	str	r3, [r4, #0]
   272aa:	4790      	blx	r2
   272ac:	4810      	ldr	r0, [pc, #64]	; (272f0 <gnss_interface_open+0x84>)
   272ae:	bd10      	pop	{r4, pc}
   272b0:	2005      	movs	r0, #5
   272b2:	f7f8 fed5 	bl	20060 <bsd_os_errno_set>
   272b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   272ba:	bd10      	pop	{r4, pc}
   272bc:	2029      	movs	r0, #41	; 0x29
   272be:	f7f8 fecf 	bl	20060 <bsd_os_errno_set>
   272c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   272c6:	bd10      	pop	{r4, pc}
   272c8:	2070      	movs	r0, #112	; 0x70
   272ca:	f7f8 fec9 	bl	20060 <bsd_os_errno_set>
   272ce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   272d2:	bd10      	pop	{r4, pc}
   272d4:	200e      	movs	r0, #14
   272d6:	f7f8 fec3 	bl	20060 <bsd_os_errno_set>
   272da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   272de:	bd10      	pop	{r4, pc}
   272e0:	20029088 	.word	0x20029088
   272e4:	200227a8 	.word	0x200227a8
   272e8:	00026565 	.word	0x00026565
   272ec:	200227b0 	.word	0x200227b0
   272f0:	49765443 	.word	0x49765443

000272f4 <gnss_interface_close>:
   272f4:	b530      	push	{r4, r5, lr}
   272f6:	4b15      	ldr	r3, [pc, #84]	; (2734c <gnss_interface_close+0x58>)
   272f8:	b085      	sub	sp, #20
   272fa:	4298      	cmp	r0, r3
   272fc:	d11f      	bne.n	2733e <gnss_interface_close+0x4a>
   272fe:	4c14      	ldr	r4, [pc, #80]	; (27350 <gnss_interface_close+0x5c>)
   27300:	6822      	ldr	r2, [r4, #0]
   27302:	b292      	uxth	r2, r2
   27304:	2a04      	cmp	r2, #4
   27306:	d00f      	beq.n	27328 <gnss_interface_close+0x34>
   27308:	4d12      	ldr	r5, [pc, #72]	; (27354 <gnss_interface_close+0x60>)
   2730a:	6828      	ldr	r0, [r5, #0]
   2730c:	b118      	cbz	r0, 27316 <gnss_interface_close+0x22>
   2730e:	f002 f939 	bl	29584 <packet_handler_delete>
   27312:	2300      	movs	r3, #0
   27314:	602b      	str	r3, [r5, #0]
   27316:	2000      	movs	r0, #0
   27318:	6823      	ldr	r3, [r4, #0]
   2731a:	0c1b      	lsrs	r3, r3, #16
   2731c:	041b      	lsls	r3, r3, #16
   2731e:	f043 0301 	orr.w	r3, r3, #1
   27322:	6023      	str	r3, [r4, #0]
   27324:	b005      	add	sp, #20
   27326:	bd30      	pop	{r4, r5, pc}
   27328:	2100      	movs	r1, #0
   2732a:	ab04      	add	r3, sp, #16
   2732c:	f843 1d04 	str.w	r1, [r3, #-4]!
   27330:	9200      	str	r2, [sp, #0]
   27332:	f44f 7101 	mov.w	r1, #516	; 0x204
   27336:	2208      	movs	r2, #8
   27338:	f001 fe62 	bl	29000 <nrf_setsockopt>
   2733c:	e7e4      	b.n	27308 <gnss_interface_close+0x14>
   2733e:	2009      	movs	r0, #9
   27340:	f7f8 fe8e 	bl	20060 <bsd_os_errno_set>
   27344:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27348:	e7ec      	b.n	27324 <gnss_interface_close+0x30>
   2734a:	bf00      	nop
   2734c:	49765443 	.word	0x49765443
   27350:	200227a8 	.word	0x200227a8
   27354:	200227b0 	.word	0x200227b0

00027358 <rpc_logobj_client_evt_handler>:
   27358:	b120      	cbz	r0, 27364 <rpc_logobj_client_evt_handler+0xc>
   2735a:	f850 1b08 	ldr.w	r1, [r0], #8
   2735e:	0c09      	lsrs	r1, r1, #16
   27360:	f7fb b8c8 	b.w	224f4 <logobj_event_handler>
   27364:	4770      	bx	lr
   27366:	bf00      	nop

00027368 <rpc_logobj_client_init>:
   27368:	4801      	ldr	r0, [pc, #4]	; (27370 <rpc_logobj_client_init+0x8>)
   2736a:	f7ff b83d 	b.w	263e8 <rpc_client_register>
   2736e:	bf00      	nop
   27370:	0003a98c 	.word	0x0003a98c

00027374 <rpc_logobj_client_request_alloc>:
   27374:	2300      	movs	r3, #0
   27376:	b510      	push	{r4, lr}
   27378:	b082      	sub	sp, #8
   2737a:	9301      	str	r3, [sp, #4]
   2737c:	b961      	cbnz	r1, 27398 <rpc_logobj_client_request_alloc+0x24>
   2737e:	b170      	cbz	r0, 2739e <rpc_logobj_client_request_alloc+0x2a>
   27380:	4604      	mov	r4, r0
   27382:	aa01      	add	r2, sp, #4
   27384:	2009      	movs	r0, #9
   27386:	f7ff f8a9 	bl	264dc <rpc_message_alloc>
   2738a:	b918      	cbnz	r0, 27394 <rpc_logobj_client_request_alloc+0x20>
   2738c:	9b01      	ldr	r3, [sp, #4]
   2738e:	b10b      	cbz	r3, 27394 <rpc_logobj_client_request_alloc+0x20>
   27390:	3308      	adds	r3, #8
   27392:	6023      	str	r3, [r4, #0]
   27394:	b002      	add	sp, #8
   27396:	bd10      	pop	{r4, pc}
   27398:	200f      	movs	r0, #15
   2739a:	b002      	add	sp, #8
   2739c:	bd10      	pop	{r4, pc}
   2739e:	200e      	movs	r0, #14
   273a0:	b002      	add	sp, #8
   273a2:	bd10      	pop	{r4, pc}

000273a4 <rpc_logobj_client_request_send>:
   273a4:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   273a8:	f5b3 4fe0 	cmp.w	r3, #28672	; 0x7000
   273ac:	d10b      	bne.n	273c6 <rpc_logobj_client_request_send+0x22>
   273ae:	b160      	cbz	r0, 273ca <rpc_logobj_client_request_send+0x26>
   273b0:	4603      	mov	r3, r0
   273b2:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   273b6:	2009      	movs	r0, #9
   273b8:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   273bc:	f843 1d08 	str.w	r1, [r3, #-8]!
   273c0:	4619      	mov	r1, r3
   273c2:	f7ff b87b 	b.w	264bc <rpc_message_send>
   273c6:	200f      	movs	r0, #15
   273c8:	4770      	bx	lr
   273ca:	200e      	movs	r0, #14
   273cc:	4770      	bx	lr
   273ce:	bf00      	nop

000273d0 <rpc_logobj_client_message_free>:
   273d0:	b120      	cbz	r0, 273dc <rpc_logobj_client_message_free+0xc>
   273d2:	f1a0 0108 	sub.w	r1, r0, #8
   273d6:	2009      	movs	r0, #9
   273d8:	f7ff b8ac 	b.w	26534 <rpc_message_free>
   273dc:	200e      	movs	r0, #14
   273de:	4770      	bx	lr

000273e0 <rpc_logobj_client_data_free>:
   273e0:	b118      	cbz	r0, 273ea <rpc_logobj_client_data_free+0xa>
   273e2:	4601      	mov	r1, r0
   273e4:	2009      	movs	r0, #9
   273e6:	f7ff b8b1 	b.w	2654c <rpc_message_data_free>
   273ea:	200e      	movs	r0, #14
   273ec:	4770      	bx	lr
   273ee:	bf00      	nop

000273f0 <dfu_client_event_handler>:
   273f0:	f850 1b08 	ldr.w	r1, [r0], #8
   273f4:	0c09      	lsrs	r1, r1, #16
   273f6:	f002 bdcb 	b.w	29f90 <rpc_dfu_event_handler>
   273fa:	bf00      	nop

000273fc <rpc_dfu_client_init>:
   273fc:	4801      	ldr	r0, [pc, #4]	; (27404 <rpc_dfu_client_init+0x8>)
   273fe:	f7fe bff3 	b.w	263e8 <rpc_client_register>
   27402:	bf00      	nop
   27404:	0003a99c 	.word	0x0003a99c

00027408 <rpc_dfu_client_request_alloc>:
   27408:	2300      	movs	r3, #0
   2740a:	b510      	push	{r4, lr}
   2740c:	b082      	sub	sp, #8
   2740e:	9301      	str	r3, [sp, #4]
   27410:	b158      	cbz	r0, 2742a <rpc_dfu_client_request_alloc+0x22>
   27412:	4604      	mov	r4, r0
   27414:	aa01      	add	r2, sp, #4
   27416:	2006      	movs	r0, #6
   27418:	f7ff f860 	bl	264dc <rpc_message_alloc>
   2741c:	b918      	cbnz	r0, 27426 <rpc_dfu_client_request_alloc+0x1e>
   2741e:	9b01      	ldr	r3, [sp, #4]
   27420:	b10b      	cbz	r3, 27426 <rpc_dfu_client_request_alloc+0x1e>
   27422:	3308      	adds	r3, #8
   27424:	6023      	str	r3, [r4, #0]
   27426:	b002      	add	sp, #8
   27428:	bd10      	pop	{r4, pc}
   2742a:	2007      	movs	r0, #7
   2742c:	b002      	add	sp, #8
   2742e:	bd10      	pop	{r4, pc}

00027430 <rpc_dfu_client_request_send>:
   27430:	f411 4f70 	tst.w	r1, #61440	; 0xf000
   27434:	d10b      	bne.n	2744e <rpc_dfu_client_request_send+0x1e>
   27436:	b160      	cbz	r0, 27452 <rpc_dfu_client_request_send+0x22>
   27438:	4603      	mov	r3, r0
   2743a:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2743e:	2006      	movs	r0, #6
   27440:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   27444:	f843 1d08 	str.w	r1, [r3, #-8]!
   27448:	4619      	mov	r1, r3
   2744a:	f7ff b837 	b.w	264bc <rpc_message_send>
   2744e:	200f      	movs	r0, #15
   27450:	4770      	bx	lr
   27452:	2007      	movs	r0, #7
   27454:	4770      	bx	lr
   27456:	bf00      	nop

00027458 <rpc_dfu_client_message_free>:
   27458:	b120      	cbz	r0, 27464 <rpc_dfu_client_message_free+0xc>
   2745a:	f1a0 0108 	sub.w	r1, r0, #8
   2745e:	2006      	movs	r0, #6
   27460:	f7ff b868 	b.w	26534 <rpc_message_free>
   27464:	2007      	movs	r0, #7
   27466:	4770      	bx	lr

00027468 <rpc_dfu_client_data_free>:
   27468:	b118      	cbz	r0, 27472 <rpc_dfu_client_data_free+0xa>
   2746a:	4601      	mov	r1, r0
   2746c:	2006      	movs	r0, #6
   2746e:	f7ff b86d 	b.w	2654c <rpc_message_data_free>
   27472:	2007      	movs	r0, #7
   27474:	4770      	bx	lr
   27476:	bf00      	nop

00027478 <packet_free_cb>:
   27478:	6800      	ldr	r0, [r0, #0]
   2747a:	f003 bae3 	b.w	2aa44 <rpc_at_client_data_free>
   2747e:	bf00      	nop

00027480 <at_interface_write>:
   27480:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27484:	b083      	sub	sp, #12
   27486:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   27488:	2c00      	cmp	r4, #0
   2748a:	d16c      	bne.n	27566 <at_interface_write+0xe6>
   2748c:	4688      	mov	r8, r1
   2748e:	4615      	mov	r5, r2
   27490:	461e      	mov	r6, r3
   27492:	4607      	mov	r7, r0
   27494:	f003 f9a8 	bl	2a7e8 <interface_socket_from_handle_get>
   27498:	4604      	mov	r4, r0
   2749a:	2e00      	cmp	r6, #0
   2749c:	d137      	bne.n	2750e <at_interface_write+0x8e>
   2749e:	2800      	cmp	r0, #0
   274a0:	d067      	beq.n	27572 <at_interface_write+0xf2>
   274a2:	6803      	ldr	r3, [r0, #0]
   274a4:	039b      	lsls	r3, r3, #14
   274a6:	d564      	bpl.n	27572 <at_interface_write+0xf2>
   274a8:	6803      	ldr	r3, [r0, #0]
   274aa:	4629      	mov	r1, r5
   274ac:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   274b0:	6003      	str	r3, [r0, #0]
   274b2:	6803      	ldr	r3, [r0, #0]
   274b4:	4668      	mov	r0, sp
   274b6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
   274ba:	6023      	str	r3, [r4, #0]
   274bc:	f003 fa98 	bl	2a9f0 <rpc_at_client_request_alloc>
   274c0:	4606      	mov	r6, r0
   274c2:	4638      	mov	r0, r7
   274c4:	f003 f990 	bl	2a7e8 <interface_socket_from_handle_get>
   274c8:	4681      	mov	r9, r0
   274ca:	bb56      	cbnz	r6, 27522 <at_interface_write+0xa2>
   274cc:	2304      	movs	r3, #4
   274ce:	9800      	ldr	r0, [sp, #0]
   274d0:	7203      	strb	r3, [r0, #8]
   274d2:	7246      	strb	r6, [r0, #9]
   274d4:	7286      	strb	r6, [r0, #10]
   274d6:	72c6      	strb	r6, [r0, #11]
   274d8:	60c7      	str	r7, [r0, #12]
   274da:	bb25      	cbnz	r5, 27526 <at_interface_write+0xa6>
   274dc:	2101      	movs	r1, #1
   274de:	f003 fa9b 	bl	2aa18 <rpc_at_client_request_send>
   274e2:	bb78      	cbnz	r0, 27544 <at_interface_write+0xc4>
   274e4:	f8d9 1024 	ldr.w	r1, [r9, #36]	; 0x24
   274e8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   274ec:	2900      	cmp	r1, #0
   274ee:	bf08      	it	eq
   274f0:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   274f4:	ab02      	add	r3, sp, #8
   274f6:	f843 1d04 	str.w	r1, [r3, #-4]!
   274fa:	4638      	mov	r0, r7
   274fc:	4611      	mov	r1, r2
   274fe:	f003 f8ff 	bl	2a700 <interface_socket_wait>
   27502:	b320      	cbz	r0, 2754e <at_interface_write+0xce>
   27504:	6823      	ldr	r3, [r4, #0]
   27506:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2750a:	6023      	str	r3, [r4, #0]
   2750c:	e002      	b.n	27514 <at_interface_write+0x94>
   2750e:	b390      	cbz	r0, 27576 <at_interface_write+0xf6>
   27510:	6803      	ldr	r3, [r0, #0]
   27512:	202d      	movs	r0, #45	; 0x2d
   27514:	f7f8 fda4 	bl	20060 <bsd_os_errno_set>
   27518:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2751c:	b003      	add	sp, #12
   2751e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   27522:	200c      	movs	r0, #12
   27524:	e7ee      	b.n	27504 <at_interface_write+0x84>
   27526:	4641      	mov	r1, r8
   27528:	6800      	ldr	r0, [r0, #0]
   2752a:	462a      	mov	r2, r5
   2752c:	f011 fd54 	bl	38fd8 <memcpy>
   27530:	2101      	movs	r1, #1
   27532:	9800      	ldr	r0, [sp, #0]
   27534:	f003 fa70 	bl	2aa18 <rpc_at_client_request_send>
   27538:	2800      	cmp	r0, #0
   2753a:	d0d3      	beq.n	274e4 <at_interface_write+0x64>
   2753c:	9b00      	ldr	r3, [sp, #0]
   2753e:	6818      	ldr	r0, [r3, #0]
   27540:	f003 fa80 	bl	2aa44 <rpc_at_client_data_free>
   27544:	9800      	ldr	r0, [sp, #0]
   27546:	f003 fa75 	bl	2aa34 <rpc_at_client_message_free>
   2754a:	2023      	movs	r0, #35	; 0x23
   2754c:	e7da      	b.n	27504 <at_interface_write+0x84>
   2754e:	4638      	mov	r0, r7
   27550:	f003 f94a 	bl	2a7e8 <interface_socket_from_handle_get>
   27554:	4603      	mov	r3, r0
   27556:	b120      	cbz	r0, 27562 <at_interface_write+0xe2>
   27558:	6840      	ldr	r0, [r0, #4]
   2755a:	b110      	cbz	r0, 27562 <at_interface_write+0xe2>
   2755c:	2200      	movs	r2, #0
   2755e:	605a      	str	r2, [r3, #4]
   27560:	e7d0      	b.n	27504 <at_interface_write+0x84>
   27562:	4628      	mov	r0, r5
   27564:	e7da      	b.n	2751c <at_interface_write+0x9c>
   27566:	2038      	movs	r0, #56	; 0x38
   27568:	f7f8 fd7a 	bl	20060 <bsd_os_errno_set>
   2756c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27570:	e7d4      	b.n	2751c <at_interface_write+0x9c>
   27572:	2016      	movs	r0, #22
   27574:	e7ce      	b.n	27514 <at_interface_write+0x94>
   27576:	202d      	movs	r0, #45	; 0x2d
   27578:	e7cc      	b.n	27514 <at_interface_write+0x94>
   2757a:	bf00      	nop

0002757c <at_interface_init>:
   2757c:	b508      	push	{r3, lr}
   2757e:	f003 fa31 	bl	2a9e4 <rpc_at_client_init>
   27582:	b910      	cbnz	r0, 2758a <at_interface_init+0xe>
   27584:	2201      	movs	r2, #1
   27586:	4b01      	ldr	r3, [pc, #4]	; (2758c <at_interface_init+0x10>)
   27588:	701a      	strb	r2, [r3, #0]
   2758a:	bd08      	pop	{r3, pc}
   2758c:	20029089 	.word	0x20029089

00027590 <at_interface_open>:
   27590:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27594:	2600      	movs	r6, #0
   27596:	4b34      	ldr	r3, [pc, #208]	; (27668 <at_interface_open+0xd8>)
   27598:	b084      	sub	sp, #16
   2759a:	781b      	ldrb	r3, [r3, #0]
   2759c:	9601      	str	r6, [sp, #4]
   2759e:	2b00      	cmp	r3, #0
   275a0:	d05c      	beq.n	2765c <at_interface_open+0xcc>
   275a2:	2902      	cmp	r1, #2
   275a4:	460d      	mov	r5, r1
   275a6:	d153      	bne.n	27650 <at_interface_open+0xc0>
   275a8:	4680      	mov	r8, r0
   275aa:	4617      	mov	r7, r2
   275ac:	a801      	add	r0, sp, #4
   275ae:	4a2f      	ldr	r2, [pc, #188]	; (2766c <at_interface_open+0xdc>)
   275b0:	f002 fff4 	bl	2a59c <interface_socket_allocate>
   275b4:	9b01      	ldr	r3, [sp, #4]
   275b6:	4604      	mov	r4, r0
   275b8:	b3c3      	cbz	r3, 2762c <at_interface_open+0x9c>
   275ba:	615f      	str	r7, [r3, #20]
   275bc:	4631      	mov	r1, r6
   275be:	e9c3 8503 	strd	r8, r5, [r3, #12]
   275c2:	a802      	add	r0, sp, #8
   275c4:	f003 fa14 	bl	2a9f0 <rpc_at_client_request_alloc>
   275c8:	4606      	mov	r6, r0
   275ca:	4620      	mov	r0, r4
   275cc:	f003 f90c 	bl	2a7e8 <interface_socket_from_handle_get>
   275d0:	4607      	mov	r7, r0
   275d2:	bb16      	cbnz	r6, 2761a <at_interface_open+0x8a>
   275d4:	2304      	movs	r3, #4
   275d6:	9802      	ldr	r0, [sp, #8]
   275d8:	2105      	movs	r1, #5
   275da:	7246      	strb	r6, [r0, #9]
   275dc:	7286      	strb	r6, [r0, #10]
   275de:	72c6      	strb	r6, [r0, #11]
   275e0:	7203      	strb	r3, [r0, #8]
   275e2:	60c4      	str	r4, [r0, #12]
   275e4:	f003 fa18 	bl	2aa18 <rpc_at_client_request_send>
   275e8:	4606      	mov	r6, r0
   275ea:	bb60      	cbnz	r0, 27646 <at_interface_open+0xb6>
   275ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   275ee:	ab04      	add	r3, sp, #16
   275f0:	2a00      	cmp	r2, #0
   275f2:	bf08      	it	eq
   275f4:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
   275f8:	4629      	mov	r1, r5
   275fa:	f843 2d04 	str.w	r2, [r3, #-4]!
   275fe:	4620      	mov	r0, r4
   27600:	462a      	mov	r2, r5
   27602:	f003 f87d 	bl	2a700 <interface_socket_wait>
   27606:	4605      	mov	r5, r0
   27608:	b940      	cbnz	r0, 2761c <at_interface_open+0x8c>
   2760a:	4620      	mov	r0, r4
   2760c:	f003 f8ec 	bl	2a7e8 <interface_socket_from_handle_get>
   27610:	b180      	cbz	r0, 27634 <at_interface_open+0xa4>
   27612:	6845      	ldr	r5, [r0, #4]
   27614:	b175      	cbz	r5, 27634 <at_interface_open+0xa4>
   27616:	6046      	str	r6, [r0, #4]
   27618:	e000      	b.n	2761c <at_interface_open+0x8c>
   2761a:	250c      	movs	r5, #12
   2761c:	4620      	mov	r0, r4
   2761e:	f003 f821 	bl	2a664 <interface_socket_free>
   27622:	4628      	mov	r0, r5
   27624:	f7f8 fd1c 	bl	20060 <bsd_os_errno_set>
   27628:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   2762c:	4620      	mov	r0, r4
   2762e:	b004      	add	sp, #16
   27630:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   27634:	4620      	mov	r0, r4
   27636:	9a01      	ldr	r2, [sp, #4]
   27638:	6813      	ldr	r3, [r2, #0]
   2763a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2763e:	6013      	str	r3, [r2, #0]
   27640:	b004      	add	sp, #16
   27642:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   27646:	9802      	ldr	r0, [sp, #8]
   27648:	f003 f9f4 	bl	2aa34 <rpc_at_client_message_free>
   2764c:	2523      	movs	r5, #35	; 0x23
   2764e:	e7e5      	b.n	2761c <at_interface_open+0x8c>
   27650:	2029      	movs	r0, #41	; 0x29
   27652:	f7f8 fd05 	bl	20060 <bsd_os_errno_set>
   27656:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   2765a:	e7e7      	b.n	2762c <at_interface_open+0x9c>
   2765c:	2070      	movs	r0, #112	; 0x70
   2765e:	f7f8 fcff 	bl	20060 <bsd_os_errno_set>
   27662:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27666:	e7e1      	b.n	2762c <at_interface_open+0x9c>
   27668:	20029089 	.word	0x20029089
   2766c:	00027479 	.word	0x00027479

00027670 <at_interface_close>:
   27670:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   27674:	b082      	sub	sp, #8
   27676:	4606      	mov	r6, r0
   27678:	f003 f8b6 	bl	2a7e8 <interface_socket_from_handle_get>
   2767c:	2800      	cmp	r0, #0
   2767e:	d051      	beq.n	27724 <at_interface_close+0xb4>
   27680:	230d      	movs	r3, #13
   27682:	6807      	ldr	r7, [r0, #0]
   27684:	6003      	str	r3, [r0, #0]
   27686:	6803      	ldr	r3, [r0, #0]
   27688:	4604      	mov	r4, r0
   2768a:	039b      	lsls	r3, r3, #14
   2768c:	d42e      	bmi.n	276ec <at_interface_close+0x7c>
   2768e:	2100      	movs	r1, #0
   27690:	4668      	mov	r0, sp
   27692:	f003 f9ad 	bl	2a9f0 <rpc_at_client_request_alloc>
   27696:	4605      	mov	r5, r0
   27698:	4630      	mov	r0, r6
   2769a:	f003 f8a5 	bl	2a7e8 <interface_socket_from_handle_get>
   2769e:	4680      	mov	r8, r0
   276a0:	bb75      	cbnz	r5, 27700 <at_interface_close+0x90>
   276a2:	2304      	movs	r3, #4
   276a4:	9800      	ldr	r0, [sp, #0]
   276a6:	2106      	movs	r1, #6
   276a8:	7203      	strb	r3, [r0, #8]
   276aa:	7245      	strb	r5, [r0, #9]
   276ac:	7285      	strb	r5, [r0, #10]
   276ae:	72c5      	strb	r5, [r0, #11]
   276b0:	60c6      	str	r6, [r0, #12]
   276b2:	f003 f9b1 	bl	2aa18 <rpc_at_client_request_send>
   276b6:	b9f0      	cbnz	r0, 276f6 <at_interface_close+0x86>
   276b8:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
   276bc:	220e      	movs	r2, #14
   276be:	2900      	cmp	r1, #0
   276c0:	bf08      	it	eq
   276c2:	f04f 31ff 	moveq.w	r1, #4294967295	; 0xffffffff
   276c6:	ab02      	add	r3, sp, #8
   276c8:	f843 1d04 	str.w	r1, [r3, #-4]!
   276cc:	4630      	mov	r0, r6
   276ce:	4611      	mov	r1, r2
   276d0:	f003 f816 	bl	2a700 <interface_socket_wait>
   276d4:	4605      	mov	r5, r0
   276d6:	b1a8      	cbz	r0, 27704 <at_interface_close+0x94>
   276d8:	6027      	str	r7, [r4, #0]
   276da:	4628      	mov	r0, r5
   276dc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   276e0:	f7f8 fcbe 	bl	20060 <bsd_os_errno_set>
   276e4:	4628      	mov	r0, r5
   276e6:	b002      	add	sp, #8
   276e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   276ec:	6803      	ldr	r3, [r0, #0]
   276ee:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   276f2:	6003      	str	r3, [r0, #0]
   276f4:	e7cb      	b.n	2768e <at_interface_close+0x1e>
   276f6:	9800      	ldr	r0, [sp, #0]
   276f8:	f003 f99c 	bl	2aa34 <rpc_at_client_message_free>
   276fc:	2523      	movs	r5, #35	; 0x23
   276fe:	e7eb      	b.n	276d8 <at_interface_close+0x68>
   27700:	250c      	movs	r5, #12
   27702:	e7e9      	b.n	276d8 <at_interface_close+0x68>
   27704:	4630      	mov	r0, r6
   27706:	f003 f86f 	bl	2a7e8 <interface_socket_from_handle_get>
   2770a:	b120      	cbz	r0, 27716 <at_interface_close+0xa6>
   2770c:	6843      	ldr	r3, [r0, #4]
   2770e:	b113      	cbz	r3, 27716 <at_interface_close+0xa6>
   27710:	6045      	str	r5, [r0, #4]
   27712:	461d      	mov	r5, r3
   27714:	e7e0      	b.n	276d8 <at_interface_close+0x68>
   27716:	4630      	mov	r0, r6
   27718:	f002 ffa4 	bl	2a664 <interface_socket_free>
   2771c:	4628      	mov	r0, r5
   2771e:	b002      	add	sp, #8
   27720:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   27724:	2516      	movs	r5, #22
   27726:	e7d8      	b.n	276da <at_interface_close+0x6a>

00027728 <at_interface_read>:
   27728:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2772c:	b087      	sub	sp, #28
   2772e:	4688      	mov	r8, r1
   27730:	4615      	mov	r5, r2
   27732:	461e      	mov	r6, r3
   27734:	4607      	mov	r7, r0
   27736:	f003 f857 	bl	2a7e8 <interface_socket_from_handle_get>
   2773a:	2800      	cmp	r0, #0
   2773c:	d056      	beq.n	277ec <at_interface_read+0xc4>
   2773e:	2300      	movs	r3, #0
   27740:	4604      	mov	r4, r0
   27742:	e9cd 8502 	strd	r8, r5, [sp, #8]
   27746:	e9cd 3304 	strd	r3, r3, [sp, #16]
   2774a:	bb66      	cbnz	r6, 277a6 <at_interface_read+0x7e>
   2774c:	f016 0502 	ands.w	r5, r6, #2
   27750:	d136      	bne.n	277c0 <at_interface_read+0x98>
   27752:	46a8      	mov	r8, r5
   27754:	6823      	ldr	r3, [r4, #0]
   27756:	69e0      	ldr	r0, [r4, #28]
   27758:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   2775c:	6023      	str	r3, [r4, #0]
   2775e:	6803      	ldr	r3, [r0, #0]
   27760:	4632      	mov	r2, r6
   27762:	689b      	ldr	r3, [r3, #8]
   27764:	a902      	add	r1, sp, #8
   27766:	4798      	blx	r3
   27768:	f1b0 0900 	subs.w	r9, r0, #0
   2776c:	da38      	bge.n	277e0 <at_interface_read+0xb8>
   2776e:	bb05      	cbnz	r5, 277b2 <at_interface_read+0x8a>
   27770:	6a25      	ldr	r5, [r4, #32]
   27772:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   27776:	2d00      	cmp	r5, #0
   27778:	bf08      	it	eq
   2777a:	f04f 35ff 	moveq.w	r5, #4294967295	; 0xffffffff
   2777e:	4611      	mov	r1, r2
   27780:	ab01      	add	r3, sp, #4
   27782:	4638      	mov	r0, r7
   27784:	9501      	str	r5, [sp, #4]
   27786:	f002 ffbb 	bl	2a700 <interface_socket_wait>
   2778a:	4605      	mov	r5, r0
   2778c:	2800      	cmp	r0, #0
   2778e:	d1e1      	bne.n	27754 <at_interface_read+0x2c>
   27790:	4638      	mov	r0, r7
   27792:	f003 f829 	bl	2a7e8 <interface_socket_from_handle_get>
   27796:	2800      	cmp	r0, #0
   27798:	d0dc      	beq.n	27754 <at_interface_read+0x2c>
   2779a:	6845      	ldr	r5, [r0, #4]
   2779c:	2d00      	cmp	r5, #0
   2779e:	d0d9      	beq.n	27754 <at_interface_read+0x2c>
   277a0:	f8c0 8004 	str.w	r8, [r0, #4]
   277a4:	e7d6      	b.n	27754 <at_interface_read+0x2c>
   277a6:	f016 0f2a 	tst.w	r6, #42	; 0x2a
   277aa:	d1cf      	bne.n	2774c <at_interface_read+0x24>
   277ac:	252d      	movs	r5, #45	; 0x2d
   277ae:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   277b2:	4628      	mov	r0, r5
   277b4:	f7f8 fc54 	bl	20060 <bsd_os_errno_set>
   277b8:	4648      	mov	r0, r9
   277ba:	b007      	add	sp, #28
   277bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   277c0:	6823      	ldr	r3, [r4, #0]
   277c2:	69e0      	ldr	r0, [r4, #28]
   277c4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   277c8:	6023      	str	r3, [r4, #0]
   277ca:	6803      	ldr	r3, [r0, #0]
   277cc:	4632      	mov	r2, r6
   277ce:	689b      	ldr	r3, [r3, #8]
   277d0:	a902      	add	r1, sp, #8
   277d2:	4798      	blx	r3
   277d4:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   277d8:	4681      	mov	r9, r0
   277da:	d1ed      	bne.n	277b8 <at_interface_read+0x90>
   277dc:	2523      	movs	r5, #35	; 0x23
   277de:	e7e8      	b.n	277b2 <at_interface_read+0x8a>
   277e0:	2d00      	cmp	r5, #0
   277e2:	d1e6      	bne.n	277b2 <at_interface_read+0x8a>
   277e4:	4648      	mov	r0, r9
   277e6:	b007      	add	sp, #28
   277e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   277ec:	2516      	movs	r5, #22
   277ee:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   277f2:	e7de      	b.n	277b2 <at_interface_read+0x8a>

000277f4 <at_interface_getopt>:
   277f4:	f003 b866 	b.w	2a8c4 <interface_socket_getopt>

000277f8 <at_interface_setopt>:
   277f8:	f003 b81e 	b.w	2a838 <interface_socket_setopt>

000277fc <rpc_at_event_handler>:
   277fc:	b570      	push	{r4, r5, r6, lr}
   277fe:	4606      	mov	r6, r0
   27800:	b084      	sub	sp, #16
   27802:	68c0      	ldr	r0, [r0, #12]
   27804:	460d      	mov	r5, r1
   27806:	f002 ffef 	bl	2a7e8 <interface_socket_from_handle_get>
   2780a:	4604      	mov	r4, r0
   2780c:	b348      	cbz	r0, 27862 <rpc_at_event_handler+0x66>
   2780e:	6803      	ldr	r3, [r0, #0]
   27810:	b29b      	uxth	r3, r3
   27812:	2b01      	cmp	r3, #1
   27814:	d01f      	beq.n	27856 <rpc_at_event_handler+0x5a>
   27816:	6803      	ldr	r3, [r0, #0]
   27818:	b29b      	uxth	r3, r3
   2781a:	2b0d      	cmp	r3, #13
   2781c:	d029      	beq.n	27872 <rpc_at_event_handler+0x76>
   2781e:	6803      	ldr	r3, [r0, #0]
   27820:	b29b      	uxth	r3, r3
   27822:	2b02      	cmp	r3, #2
   27824:	d02d      	beq.n	27882 <rpc_at_event_handler+0x86>
   27826:	3d03      	subs	r5, #3
   27828:	2d01      	cmp	r5, #1
   2782a:	d817      	bhi.n	2785c <rpc_at_event_handler+0x60>
   2782c:	2500      	movs	r5, #0
   2782e:	6873      	ldr	r3, [r6, #4]
   27830:	6832      	ldr	r2, [r6, #0]
   27832:	e9cd 5502 	strd	r5, r5, [sp, #8]
   27836:	e9cd 2300 	strd	r2, r3, [sp]
   2783a:	69e0      	ldr	r0, [r4, #28]
   2783c:	4669      	mov	r1, sp
   2783e:	6803      	ldr	r3, [r0, #0]
   27840:	685b      	ldr	r3, [r3, #4]
   27842:	4798      	blx	r3
   27844:	3001      	adds	r0, #1
   27846:	d019      	beq.n	2787c <rpc_at_event_handler+0x80>
   27848:	4628      	mov	r0, r5
   2784a:	6823      	ldr	r3, [r4, #0]
   2784c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   27850:	6023      	str	r3, [r4, #0]
   27852:	b004      	add	sp, #16
   27854:	bd70      	pop	{r4, r5, r6, pc}
   27856:	2d02      	cmp	r5, #2
   27858:	d1e5      	bne.n	27826 <rpc_at_event_handler+0x2a>
   2785a:	6005      	str	r5, [r0, #0]
   2785c:	2000      	movs	r0, #0
   2785e:	b004      	add	sp, #16
   27860:	bd70      	pop	{r4, r5, r6, pc}
   27862:	6830      	ldr	r0, [r6, #0]
   27864:	2800      	cmp	r0, #0
   27866:	d0f9      	beq.n	2785c <rpc_at_event_handler+0x60>
   27868:	f003 f8ec 	bl	2aa44 <rpc_at_client_data_free>
   2786c:	4620      	mov	r0, r4
   2786e:	b004      	add	sp, #16
   27870:	bd70      	pop	{r4, r5, r6, pc}
   27872:	2d02      	cmp	r5, #2
   27874:	d1d7      	bne.n	27826 <rpc_at_event_handler+0x2a>
   27876:	230e      	movs	r3, #14
   27878:	6003      	str	r3, [r0, #0]
   2787a:	e7ef      	b.n	2785c <rpc_at_event_handler+0x60>
   2787c:	2002      	movs	r0, #2
   2787e:	b004      	add	sp, #16
   27880:	bd70      	pop	{r4, r5, r6, pc}
   27882:	6803      	ldr	r3, [r0, #0]
   27884:	029b      	lsls	r3, r3, #10
   27886:	d5ce      	bpl.n	27826 <rpc_at_event_handler+0x2a>
   27888:	2d02      	cmp	r5, #2
   2788a:	d1cc      	bne.n	27826 <rpc_at_event_handler+0x2a>
   2788c:	6803      	ldr	r3, [r0, #0]
   2788e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
   27892:	6003      	str	r3, [r0, #0]
   27894:	6803      	ldr	r3, [r0, #0]
   27896:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   2789a:	6003      	str	r3, [r0, #0]
   2789c:	e7de      	b.n	2785c <rpc_at_event_handler+0x60>
   2789e:	bf00      	nop

000278a0 <ok_rsp_parser>:
   278a0:	2000      	movs	r0, #0
   278a2:	4770      	bx	lr

000278a4 <pdn_state_get_parser>:
   278a4:	2200      	movs	r2, #0
   278a6:	b570      	push	{r4, r5, r6, lr}
   278a8:	780b      	ldrb	r3, [r1, #0]
   278aa:	b084      	sub	sp, #16
   278ac:	460e      	mov	r6, r1
   278ae:	e9cd 2200 	strd	r2, r2, [sp]
   278b2:	e9cd 2202 	strd	r2, r2, [sp, #8]
   278b6:	b323      	cbz	r3, 27902 <pdn_state_get_parser+0x5e>
   278b8:	460c      	mov	r4, r1
   278ba:	2b20      	cmp	r3, #32
   278bc:	460d      	mov	r5, r1
   278be:	d01b      	beq.n	278f8 <pdn_state_get_parser+0x54>
   278c0:	700b      	strb	r3, [r1, #0]
   278c2:	3201      	adds	r2, #1
   278c4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   278c8:	18b1      	adds	r1, r6, r2
   278ca:	460d      	mov	r5, r1
   278cc:	2b00      	cmp	r3, #0
   278ce:	d1f4      	bne.n	278ba <pdn_state_get_parser+0x16>
   278d0:	2200      	movs	r2, #0
   278d2:	4b0d      	ldr	r3, [pc, #52]	; (27908 <pdn_state_get_parser+0x64>)
   278d4:	702a      	strb	r2, [r5, #0]
   278d6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   278da:	4a0c      	ldr	r2, [pc, #48]	; (2790c <pdn_state_get_parser+0x68>)
   278dc:	681b      	ldr	r3, [r3, #0]
   278de:	2110      	movs	r1, #16
   278e0:	4668      	mov	r0, sp
   278e2:	f00a f9cd 	bl	31c80 <sniprintf>
   278e6:	4669      	mov	r1, sp
   278e8:	4630      	mov	r0, r6
   278ea:	f011 fd1d 	bl	39328 <strstr>
   278ee:	3000      	adds	r0, #0
   278f0:	bf18      	it	ne
   278f2:	2001      	movne	r0, #1
   278f4:	b004      	add	sp, #16
   278f6:	bd70      	pop	{r4, r5, r6, pc}
   278f8:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   278fc:	2b00      	cmp	r3, #0
   278fe:	d1dc      	bne.n	278ba <pdn_state_get_parser+0x16>
   27900:	e7e6      	b.n	278d0 <pdn_state_get_parser+0x2c>
   27902:	460d      	mov	r5, r1
   27904:	e7e4      	b.n	278d0 <pdn_state_get_parser+0x2c>
   27906:	bf00      	nop
   27908:	200228b8 	.word	0x200228b8
   2790c:	0003aa54 	.word	0x0003aa54

00027910 <pdn_id_get_parser>:
   27910:	b570      	push	{r4, r5, r6, lr}
   27912:	780b      	ldrb	r3, [r1, #0]
   27914:	4606      	mov	r6, r0
   27916:	b313      	cbz	r3, 2795e <pdn_id_get_parser+0x4e>
   27918:	4608      	mov	r0, r1
   2791a:	2400      	movs	r4, #0
   2791c:	460a      	mov	r2, r1
   2791e:	2b20      	cmp	r3, #32
   27920:	4615      	mov	r5, r2
   27922:	d017      	beq.n	27954 <pdn_id_get_parser+0x44>
   27924:	7013      	strb	r3, [r2, #0]
   27926:	3401      	adds	r4, #1
   27928:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   2792c:	190a      	adds	r2, r1, r4
   2792e:	4615      	mov	r5, r2
   27930:	2b00      	cmp	r3, #0
   27932:	d1f4      	bne.n	2791e <pdn_id_get_parser+0xe>
   27934:	2300      	movs	r3, #0
   27936:	4608      	mov	r0, r1
   27938:	702b      	strb	r3, [r5, #0]
   2793a:	213a      	movs	r1, #58	; 0x3a
   2793c:	f011 fccd 	bl	392da <strchr>
   27940:	b130      	cbz	r0, 27950 <pdn_id_get_parser+0x40>
   27942:	3001      	adds	r0, #1
   27944:	f011 fb28 	bl	38f98 <atoi>
   27948:	4b06      	ldr	r3, [pc, #24]	; (27964 <pdn_id_get_parser+0x54>)
   2794a:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
   2794e:	6058      	str	r0, [r3, #4]
   27950:	2000      	movs	r0, #0
   27952:	bd70      	pop	{r4, r5, r6, pc}
   27954:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   27958:	2b00      	cmp	r3, #0
   2795a:	d1e0      	bne.n	2791e <pdn_id_get_parser+0xe>
   2795c:	e7ea      	b.n	27934 <pdn_id_get_parser+0x24>
   2795e:	460d      	mov	r5, r1
   27960:	e7e8      	b.n	27934 <pdn_id_get_parser+0x24>
   27962:	bf00      	nop
   27964:	200228b8 	.word	0x200228b8

00027968 <context_create_parser>:
   27968:	b570      	push	{r4, r5, r6, lr}
   2796a:	780b      	ldrb	r3, [r1, #0]
   2796c:	4606      	mov	r6, r0
   2796e:	b313      	cbz	r3, 279b6 <context_create_parser+0x4e>
   27970:	4608      	mov	r0, r1
   27972:	2400      	movs	r4, #0
   27974:	460a      	mov	r2, r1
   27976:	2b20      	cmp	r3, #32
   27978:	4615      	mov	r5, r2
   2797a:	d017      	beq.n	279ac <context_create_parser+0x44>
   2797c:	7013      	strb	r3, [r2, #0]
   2797e:	3401      	adds	r4, #1
   27980:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   27984:	190a      	adds	r2, r1, r4
   27986:	4615      	mov	r5, r2
   27988:	2b00      	cmp	r3, #0
   2798a:	d1f4      	bne.n	27976 <context_create_parser+0xe>
   2798c:	2300      	movs	r3, #0
   2798e:	4608      	mov	r0, r1
   27990:	702b      	strb	r3, [r5, #0]
   27992:	213a      	movs	r1, #58	; 0x3a
   27994:	f011 fca1 	bl	392da <strchr>
   27998:	b130      	cbz	r0, 279a8 <context_create_parser+0x40>
   2799a:	4b08      	ldr	r3, [pc, #32]	; (279bc <context_create_parser+0x54>)
   2799c:	3001      	adds	r0, #1
   2799e:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   279a2:	f011 faf9 	bl	38f98 <atoi>
   279a6:	6020      	str	r0, [r4, #0]
   279a8:	2000      	movs	r0, #0
   279aa:	bd70      	pop	{r4, r5, r6, pc}
   279ac:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   279b0:	2b00      	cmp	r3, #0
   279b2:	d1e0      	bne.n	27976 <context_create_parser+0xe>
   279b4:	e7ea      	b.n	2798c <context_create_parser+0x24>
   279b6:	460d      	mov	r5, r1
   279b8:	e7e8      	b.n	2798c <context_create_parser+0x24>
   279ba:	bf00      	nop
   279bc:	200228b8 	.word	0x200228b8

000279c0 <pdn_interface_init>:
   279c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   279c4:	b510      	push	{r4, lr}
   279c6:	4c0b      	ldr	r4, [pc, #44]	; (279f4 <pdn_interface_init+0x34>)
   279c8:	2228      	movs	r2, #40	; 0x28
   279ca:	2100      	movs	r1, #0
   279cc:	480a      	ldr	r0, [pc, #40]	; (279f8 <pdn_interface_init+0x38>)
   279ce:	6023      	str	r3, [r4, #0]
   279d0:	f011 fb3c 	bl	3904c <memset>
   279d4:	f240 2201 	movw	r2, #513	; 0x201
   279d8:	2102      	movs	r1, #2
   279da:	2066      	movs	r0, #102	; 0x66
   279dc:	f7ff fdd8 	bl	27590 <at_interface_open>
   279e0:	2800      	cmp	r0, #0
   279e2:	6020      	str	r0, [r4, #0]
   279e4:	db04      	blt.n	279f0 <pdn_interface_init+0x30>
   279e6:	2201      	movs	r2, #1
   279e8:	4b04      	ldr	r3, [pc, #16]	; (279fc <pdn_interface_init+0x3c>)
   279ea:	2000      	movs	r0, #0
   279ec:	701a      	strb	r2, [r3, #0]
   279ee:	bd10      	pop	{r4, pc}
   279f0:	2003      	movs	r0, #3
   279f2:	bd10      	pop	{r4, pc}
   279f4:	200227b4 	.word	0x200227b4
   279f8:	200228b8 	.word	0x200228b8
   279fc:	2002908a 	.word	0x2002908a

00027a00 <pdn_interface_open>:
   27a00:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27a04:	4b66      	ldr	r3, [pc, #408]	; (27ba0 <pdn_interface_open+0x1a0>)
   27a06:	b083      	sub	sp, #12
   27a08:	781b      	ldrb	r3, [r3, #0]
   27a0a:	2b00      	cmp	r3, #0
   27a0c:	f000 80c2 	beq.w	27b94 <pdn_interface_open+0x194>
   27a10:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   27a14:	f040 80ad 	bne.w	27b72 <pdn_interface_open+0x172>
   27a18:	4c62      	ldr	r4, [pc, #392]	; (27ba4 <pdn_interface_open+0x1a4>)
   27a1a:	6825      	ldr	r5, [r4, #0]
   27a1c:	b34d      	cbz	r5, 27a72 <pdn_interface_open+0x72>
   27a1e:	6863      	ldr	r3, [r4, #4]
   27a20:	2b00      	cmp	r3, #0
   27a22:	f000 8098 	beq.w	27b56 <pdn_interface_open+0x156>
   27a26:	68a3      	ldr	r3, [r4, #8]
   27a28:	2b00      	cmp	r3, #0
   27a2a:	f000 8096 	beq.w	27b5a <pdn_interface_open+0x15a>
   27a2e:	68e3      	ldr	r3, [r4, #12]
   27a30:	2b00      	cmp	r3, #0
   27a32:	f000 8094 	beq.w	27b5e <pdn_interface_open+0x15e>
   27a36:	6923      	ldr	r3, [r4, #16]
   27a38:	2b00      	cmp	r3, #0
   27a3a:	f000 8092 	beq.w	27b62 <pdn_interface_open+0x162>
   27a3e:	6963      	ldr	r3, [r4, #20]
   27a40:	2b00      	cmp	r3, #0
   27a42:	f000 8090 	beq.w	27b66 <pdn_interface_open+0x166>
   27a46:	69a3      	ldr	r3, [r4, #24]
   27a48:	2b00      	cmp	r3, #0
   27a4a:	f000 808e 	beq.w	27b6a <pdn_interface_open+0x16a>
   27a4e:	69e3      	ldr	r3, [r4, #28]
   27a50:	2b00      	cmp	r3, #0
   27a52:	f000 808c 	beq.w	27b6e <pdn_interface_open+0x16e>
   27a56:	6a23      	ldr	r3, [r4, #32]
   27a58:	b153      	cbz	r3, 27a70 <pdn_interface_open+0x70>
   27a5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   27a5c:	2509      	movs	r5, #9
   27a5e:	b143      	cbz	r3, 27a72 <pdn_interface_open+0x72>
   27a60:	200c      	movs	r0, #12
   27a62:	f7f8 fafd 	bl	20060 <bsd_os_errno_set>
   27a66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27a6a:	b003      	add	sp, #12
   27a6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   27a70:	2508      	movs	r5, #8
   27a72:	2074      	movs	r0, #116	; 0x74
   27a74:	f002 fa60 	bl	29f38 <nrf_malloc>
   27a78:	f844 0025 	str.w	r0, [r4, r5, lsl #2]
   27a7c:	2800      	cmp	r0, #0
   27a7e:	d0ef      	beq.n	27a60 <pdn_interface_open+0x60>
   27a80:	2274      	movs	r2, #116	; 0x74
   27a82:	2100      	movs	r1, #0
   27a84:	f011 fae2 	bl	3904c <memset>
   27a88:	2101      	movs	r1, #1
   27a8a:	2003      	movs	r0, #3
   27a8c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   27a90:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   27a94:	4a44      	ldr	r2, [pc, #272]	; (27ba8 <pdn_interface_open+0x1a8>)
   27a96:	6099      	str	r1, [r3, #8]
   27a98:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   27a9c:	f44f 7180 	mov.w	r1, #256	; 0x100
   27aa0:	6718      	str	r0, [r3, #112]	; 0x70
   27aa2:	605f      	str	r7, [r3, #4]
   27aa4:	4841      	ldr	r0, [pc, #260]	; (27bac <pdn_interface_open+0x1ac>)
   27aa6:	f8df 8110 	ldr.w	r8, [pc, #272]	; 27bb8 <pdn_interface_open+0x1b8>
   27aaa:	f00a f8e9 	bl	31c80 <sniprintf>
   27aae:	483f      	ldr	r0, [pc, #252]	; (27bac <pdn_interface_open+0x1ac>)
   27ab0:	f8d8 9000 	ldr.w	r9, [r8]
   27ab4:	2600      	movs	r6, #0
   27ab6:	f7ea fae3 	bl	12080 <strlen>
   27aba:	4633      	mov	r3, r6
   27abc:	4602      	mov	r2, r0
   27abe:	493b      	ldr	r1, [pc, #236]	; (27bac <pdn_interface_open+0x1ac>)
   27ac0:	4648      	mov	r0, r9
   27ac2:	9601      	str	r6, [sp, #4]
   27ac4:	9600      	str	r6, [sp, #0]
   27ac6:	f7ff fcdb 	bl	27480 <at_interface_write>
   27aca:	4681      	mov	r9, r0
   27acc:	4837      	ldr	r0, [pc, #220]	; (27bac <pdn_interface_open+0x1ac>)
   27ace:	f7ea fad7 	bl	12080 <strlen>
   27ad2:	4548      	cmp	r0, r9
   27ad4:	d153      	bne.n	27b7e <pdn_interface_open+0x17e>
   27ad6:	4633      	mov	r3, r6
   27ad8:	e9cd 6600 	strd	r6, r6, [sp]
   27adc:	f44f 7280 	mov.w	r2, #256	; 0x100
   27ae0:	4932      	ldr	r1, [pc, #200]	; (27bac <pdn_interface_open+0x1ac>)
   27ae2:	f8d8 0000 	ldr.w	r0, [r8]
   27ae6:	f7ff fe1f 	bl	27728 <at_interface_read>
   27aea:	4606      	mov	r6, r0
   27aec:	4830      	ldr	r0, [pc, #192]	; (27bb0 <pdn_interface_open+0x1b0>)
   27aee:	f7ea fac7 	bl	12080 <strlen>
   27af2:	4286      	cmp	r6, r0
   27af4:	db15      	blt.n	27b22 <pdn_interface_open+0x122>
   27af6:	4602      	mov	r2, r0
   27af8:	492c      	ldr	r1, [pc, #176]	; (27bac <pdn_interface_open+0x1ac>)
   27afa:	482d      	ldr	r0, [pc, #180]	; (27bb0 <pdn_interface_open+0x1b0>)
   27afc:	f011 fc02 	bl	39304 <strncmp>
   27b00:	b978      	cbnz	r0, 27b22 <pdn_interface_open+0x122>
   27b02:	492a      	ldr	r1, [pc, #168]	; (27bac <pdn_interface_open+0x1ac>)
   27b04:	4628      	mov	r0, r5
   27b06:	f7ff ff2f 	bl	27968 <context_create_parser>
   27b0a:	b9b0      	cbnz	r0, 27b3a <pdn_interface_open+0x13a>
   27b0c:	2202      	movs	r2, #2
   27b0e:	f854 3025 	ldr.w	r3, [r4, r5, lsl #2]
   27b12:	f045 40f1 	orr.w	r0, r5, #2021654528	; 0x78800000
   27b16:	f440 10d0 	orr.w	r0, r0, #1703936	; 0x1a0000
   27b1a:	609a      	str	r2, [r3, #8]
   27b1c:	b003      	add	sp, #12
   27b1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   27b22:	4824      	ldr	r0, [pc, #144]	; (27bb4 <pdn_interface_open+0x1b4>)
   27b24:	f7ea faac 	bl	12080 <strlen>
   27b28:	4920      	ldr	r1, [pc, #128]	; (27bac <pdn_interface_open+0x1ac>)
   27b2a:	4602      	mov	r2, r0
   27b2c:	4821      	ldr	r0, [pc, #132]	; (27bb4 <pdn_interface_open+0x1b4>)
   27b2e:	f011 fbe9 	bl	39304 <strncmp>
   27b32:	b960      	cbnz	r0, 27b4e <pdn_interface_open+0x14e>
   27b34:	2008      	movs	r0, #8
   27b36:	f7f8 fa93 	bl	20060 <bsd_os_errno_set>
   27b3a:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   27b3e:	f002 fa05 	bl	29f4c <nrf_free>
   27b42:	2300      	movs	r3, #0
   27b44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27b48:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
   27b4c:	e78d      	b.n	27a6a <pdn_interface_open+0x6a>
   27b4e:	2005      	movs	r0, #5
   27b50:	f7f8 fa86 	bl	20060 <bsd_os_errno_set>
   27b54:	e7f1      	b.n	27b3a <pdn_interface_open+0x13a>
   27b56:	2501      	movs	r5, #1
   27b58:	e78b      	b.n	27a72 <pdn_interface_open+0x72>
   27b5a:	2502      	movs	r5, #2
   27b5c:	e789      	b.n	27a72 <pdn_interface_open+0x72>
   27b5e:	2503      	movs	r5, #3
   27b60:	e787      	b.n	27a72 <pdn_interface_open+0x72>
   27b62:	2504      	movs	r5, #4
   27b64:	e785      	b.n	27a72 <pdn_interface_open+0x72>
   27b66:	2505      	movs	r5, #5
   27b68:	e783      	b.n	27a72 <pdn_interface_open+0x72>
   27b6a:	2506      	movs	r5, #6
   27b6c:	e781      	b.n	27a72 <pdn_interface_open+0x72>
   27b6e:	2507      	movs	r5, #7
   27b70:	e77f      	b.n	27a72 <pdn_interface_open+0x72>
   27b72:	2029      	movs	r0, #41	; 0x29
   27b74:	f7f8 fa74 	bl	20060 <bsd_os_errno_set>
   27b78:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27b7c:	e775      	b.n	27a6a <pdn_interface_open+0x6a>
   27b7e:	2005      	movs	r0, #5
   27b80:	f7f8 fa6e 	bl	20060 <bsd_os_errno_set>
   27b84:	f854 0025 	ldr.w	r0, [r4, r5, lsl #2]
   27b88:	f002 f9e0 	bl	29f4c <nrf_free>
   27b8c:	f844 6025 	str.w	r6, [r4, r5, lsl #2]
   27b90:	4638      	mov	r0, r7
   27b92:	e76a      	b.n	27a6a <pdn_interface_open+0x6a>
   27b94:	2070      	movs	r0, #112	; 0x70
   27b96:	f7f8 fa63 	bl	20060 <bsd_os_errno_set>
   27b9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   27b9e:	e764      	b.n	27a6a <pdn_interface_open+0x6a>
   27ba0:	2002908a 	.word	0x2002908a
   27ba4:	200228b8 	.word	0x200228b8
   27ba8:	0003aa30 	.word	0x0003aa30
   27bac:	200227b8 	.word	0x200227b8
   27bb0:	0003aa40 	.word	0x0003aa40
   27bb4:	0003aa4c 	.word	0x0003aa4c
   27bb8:	200227b4 	.word	0x200227b4

00027bbc <pdn_interface_connect>:
   27bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   27bc0:	b083      	sub	sp, #12
   27bc2:	2900      	cmp	r1, #0
   27bc4:	f000 813d 	beq.w	27e42 <pdn_interface_connect+0x286>
   27bc8:	2a64      	cmp	r2, #100	; 0x64
   27bca:	4691      	mov	r9, r2
   27bcc:	f200 8139 	bhi.w	27e42 <pdn_interface_connect+0x286>
   27bd0:	4605      	mov	r5, r0
   27bd2:	4608      	mov	r0, r1
   27bd4:	4688      	mov	r8, r1
   27bd6:	f7ea fa53 	bl	12080 <strlen>
   27bda:	2864      	cmp	r0, #100	; 0x64
   27bdc:	f200 8131 	bhi.w	27e42 <pdn_interface_connect+0x286>
   27be0:	0c2b      	lsrs	r3, r5, #16
   27be2:	4aa5      	ldr	r2, [pc, #660]	; (27e78 <pdn_interface_connect+0x2bc>)
   27be4:	041b      	lsls	r3, r3, #16
   27be6:	4293      	cmp	r3, r2
   27be8:	f040 8122 	bne.w	27e30 <pdn_interface_connect+0x274>
   27bec:	f025 45f1 	bic.w	r5, r5, #2021654528	; 0x78800000
   27bf0:	f425 15d0 	bic.w	r5, r5, #1703936	; 0x1a0000
   27bf4:	2d09      	cmp	r5, #9
   27bf6:	f300 811b 	bgt.w	27e30 <pdn_interface_connect+0x274>
   27bfa:	4fa0      	ldr	r7, [pc, #640]	; (27e7c <pdn_interface_connect+0x2c0>)
   27bfc:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27c00:	2b00      	cmp	r3, #0
   27c02:	f000 8115 	beq.w	27e30 <pdn_interface_connect+0x274>
   27c06:	689a      	ldr	r2, [r3, #8]
   27c08:	2a00      	cmp	r2, #0
   27c0a:	f000 8111 	beq.w	27e30 <pdn_interface_connect+0x274>
   27c0e:	689b      	ldr	r3, [r3, #8]
   27c10:	2b02      	cmp	r3, #2
   27c12:	f040 810d 	bne.w	27e30 <pdn_interface_connect+0x274>
   27c16:	4e9a      	ldr	r6, [pc, #616]	; (27e80 <pdn_interface_connect+0x2c4>)
   27c18:	4a9a      	ldr	r2, [pc, #616]	; (27e84 <pdn_interface_connect+0x2c8>)
   27c1a:	f44f 7180 	mov.w	r1, #256	; 0x100
   27c1e:	4630      	mov	r0, r6
   27c20:	f00a f82e 	bl	31c80 <sniprintf>
   27c24:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27c28:	4604      	mov	r4, r0
   27c2a:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   27c2e:	681b      	ldr	r3, [r3, #0]
   27c30:	4a95      	ldr	r2, [pc, #596]	; (27e88 <pdn_interface_connect+0x2cc>)
   27c32:	1830      	adds	r0, r6, r0
   27c34:	f00a f824 	bl	31c80 <sniprintf>
   27c38:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27c3c:	4404      	add	r4, r0
   27c3e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   27c40:	f003 0203 	and.w	r2, r3, #3
   27c44:	2a03      	cmp	r2, #3
   27c46:	f000 80ea 	beq.w	27e1e <pdn_interface_connect+0x262>
   27c4a:	079b      	lsls	r3, r3, #30
   27c4c:	eb06 0004 	add.w	r0, r6, r4
   27c50:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   27c54:	bf4c      	ite	mi
   27c56:	4b8d      	ldrmi	r3, [pc, #564]	; (27e8c <pdn_interface_connect+0x2d0>)
   27c58:	4b8d      	ldrpl	r3, [pc, #564]	; (27e90 <pdn_interface_connect+0x2d4>)
   27c5a:	4a8e      	ldr	r2, [pc, #568]	; (27e94 <pdn_interface_connect+0x2d8>)
   27c5c:	f00a f810 	bl	31c80 <sniprintf>
   27c60:	4404      	add	r4, r0
   27c62:	4643      	mov	r3, r8
   27c64:	4a8c      	ldr	r2, [pc, #560]	; (27e98 <pdn_interface_connect+0x2dc>)
   27c66:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   27c6a:	1930      	adds	r0, r6, r4
   27c6c:	f00a f808 	bl	31c80 <sniprintf>
   27c70:	4420      	add	r0, r4
   27c72:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
   27c76:	f300 80f7 	bgt.w	27e68 <pdn_interface_connect+0x2ac>
   27c7a:	f8df a23c 	ldr.w	sl, [pc, #572]	; 27eb8 <pdn_interface_connect+0x2fc>
   27c7e:	4880      	ldr	r0, [pc, #512]	; (27e80 <pdn_interface_connect+0x2c4>)
   27c80:	f8da b000 	ldr.w	fp, [sl]
   27c84:	2400      	movs	r4, #0
   27c86:	f7ea f9fb 	bl	12080 <strlen>
   27c8a:	4623      	mov	r3, r4
   27c8c:	4602      	mov	r2, r0
   27c8e:	497c      	ldr	r1, [pc, #496]	; (27e80 <pdn_interface_connect+0x2c4>)
   27c90:	4658      	mov	r0, fp
   27c92:	9401      	str	r4, [sp, #4]
   27c94:	9400      	str	r4, [sp, #0]
   27c96:	f7ff fbf3 	bl	27480 <at_interface_write>
   27c9a:	4683      	mov	fp, r0
   27c9c:	4878      	ldr	r0, [pc, #480]	; (27e80 <pdn_interface_connect+0x2c4>)
   27c9e:	f7ea f9ef 	bl	12080 <strlen>
   27ca2:	4558      	cmp	r0, fp
   27ca4:	d008      	beq.n	27cb8 <pdn_interface_connect+0xfc>
   27ca6:	2005      	movs	r0, #5
   27ca8:	f7f8 f9da 	bl	20060 <bsd_os_errno_set>
   27cac:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27cb0:	4620      	mov	r0, r4
   27cb2:	b003      	add	sp, #12
   27cb4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27cb8:	4623      	mov	r3, r4
   27cba:	e9cd 4400 	strd	r4, r4, [sp]
   27cbe:	f44f 7280 	mov.w	r2, #256	; 0x100
   27cc2:	496f      	ldr	r1, [pc, #444]	; (27e80 <pdn_interface_connect+0x2c4>)
   27cc4:	f8da 0000 	ldr.w	r0, [sl]
   27cc8:	f7ff fd2e 	bl	27728 <at_interface_read>
   27ccc:	4604      	mov	r4, r0
   27cce:	4873      	ldr	r0, [pc, #460]	; (27e9c <pdn_interface_connect+0x2e0>)
   27cd0:	f7ea f9d6 	bl	12080 <strlen>
   27cd4:	4284      	cmp	r4, r0
   27cd6:	f2c0 8091 	blt.w	27dfc <pdn_interface_connect+0x240>
   27cda:	4602      	mov	r2, r0
   27cdc:	4968      	ldr	r1, [pc, #416]	; (27e80 <pdn_interface_connect+0x2c4>)
   27cde:	486f      	ldr	r0, [pc, #444]	; (27e9c <pdn_interface_connect+0x2e0>)
   27ce0:	f011 fb10 	bl	39304 <strncmp>
   27ce4:	2800      	cmp	r0, #0
   27ce6:	f040 8089 	bne.w	27dfc <pdn_interface_connect+0x240>
   27cea:	4965      	ldr	r1, [pc, #404]	; (27e80 <pdn_interface_connect+0x2c4>)
   27cec:	4628      	mov	r0, r5
   27cee:	f7ff fdd7 	bl	278a0 <ok_rsp_parser>
   27cf2:	4604      	mov	r4, r0
   27cf4:	2800      	cmp	r0, #0
   27cf6:	d1db      	bne.n	27cb0 <pdn_interface_connect+0xf4>
   27cf8:	4a69      	ldr	r2, [pc, #420]	; (27ea0 <pdn_interface_connect+0x2e4>)
   27cfa:	f44f 7180 	mov.w	r1, #256	; 0x100
   27cfe:	4860      	ldr	r0, [pc, #384]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d00:	f009 ffbe 	bl	31c80 <sniprintf>
   27d04:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27d08:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   27d0c:	681b      	ldr	r3, [r3, #0]
   27d0e:	4a65      	ldr	r2, [pc, #404]	; (27ea4 <pdn_interface_connect+0x2e8>)
   27d10:	4430      	add	r0, r6
   27d12:	f009 ffb5 	bl	31c80 <sniprintf>
   27d16:	485a      	ldr	r0, [pc, #360]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d18:	f8da b000 	ldr.w	fp, [sl]
   27d1c:	f7ea f9b0 	bl	12080 <strlen>
   27d20:	4623      	mov	r3, r4
   27d22:	4602      	mov	r2, r0
   27d24:	4956      	ldr	r1, [pc, #344]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d26:	4658      	mov	r0, fp
   27d28:	9401      	str	r4, [sp, #4]
   27d2a:	9400      	str	r4, [sp, #0]
   27d2c:	f7ff fba8 	bl	27480 <at_interface_write>
   27d30:	4683      	mov	fp, r0
   27d32:	4853      	ldr	r0, [pc, #332]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d34:	f7ea f9a4 	bl	12080 <strlen>
   27d38:	4558      	cmp	r0, fp
   27d3a:	d1b4      	bne.n	27ca6 <pdn_interface_connect+0xea>
   27d3c:	4623      	mov	r3, r4
   27d3e:	f44f 7280 	mov.w	r2, #256	; 0x100
   27d42:	494f      	ldr	r1, [pc, #316]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d44:	f8da 0000 	ldr.w	r0, [sl]
   27d48:	e9cd 4400 	strd	r4, r4, [sp]
   27d4c:	f7ff fcec 	bl	27728 <at_interface_read>
   27d50:	4683      	mov	fp, r0
   27d52:	4852      	ldr	r0, [pc, #328]	; (27e9c <pdn_interface_connect+0x2e0>)
   27d54:	f7ea f994 	bl	12080 <strlen>
   27d58:	4583      	cmp	fp, r0
   27d5a:	db4f      	blt.n	27dfc <pdn_interface_connect+0x240>
   27d5c:	4602      	mov	r2, r0
   27d5e:	4948      	ldr	r1, [pc, #288]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d60:	484e      	ldr	r0, [pc, #312]	; (27e9c <pdn_interface_connect+0x2e0>)
   27d62:	f011 facf 	bl	39304 <strncmp>
   27d66:	2800      	cmp	r0, #0
   27d68:	d148      	bne.n	27dfc <pdn_interface_connect+0x240>
   27d6a:	2103      	movs	r1, #3
   27d6c:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27d70:	464a      	mov	r2, r9
   27d72:	6099      	str	r1, [r3, #8]
   27d74:	f857 0025 	ldr.w	r0, [r7, r5, lsl #2]
   27d78:	4641      	mov	r1, r8
   27d7a:	300c      	adds	r0, #12
   27d7c:	f011 f92c 	bl	38fd8 <memcpy>
   27d80:	4a49      	ldr	r2, [pc, #292]	; (27ea8 <pdn_interface_connect+0x2ec>)
   27d82:	f44f 7180 	mov.w	r1, #256	; 0x100
   27d86:	483e      	ldr	r0, [pc, #248]	; (27e80 <pdn_interface_connect+0x2c4>)
   27d88:	f009 ff7a 	bl	31c80 <sniprintf>
   27d8c:	4601      	mov	r1, r0
   27d8e:	f857 3025 	ldr.w	r3, [r7, r5, lsl #2]
   27d92:	f5c1 7180 	rsb	r1, r1, #256	; 0x100
   27d96:	681b      	ldr	r3, [r3, #0]
   27d98:	4a42      	ldr	r2, [pc, #264]	; (27ea4 <pdn_interface_connect+0x2e8>)
   27d9a:	1830      	adds	r0, r6, r0
   27d9c:	f009 ff70 	bl	31c80 <sniprintf>
   27da0:	4837      	ldr	r0, [pc, #220]	; (27e80 <pdn_interface_connect+0x2c4>)
   27da2:	f8da 6000 	ldr.w	r6, [sl]
   27da6:	f7ea f96b 	bl	12080 <strlen>
   27daa:	4623      	mov	r3, r4
   27dac:	4602      	mov	r2, r0
   27dae:	4934      	ldr	r1, [pc, #208]	; (27e80 <pdn_interface_connect+0x2c4>)
   27db0:	4630      	mov	r0, r6
   27db2:	9401      	str	r4, [sp, #4]
   27db4:	9400      	str	r4, [sp, #0]
   27db6:	f7ff fb63 	bl	27480 <at_interface_write>
   27dba:	4606      	mov	r6, r0
   27dbc:	4830      	ldr	r0, [pc, #192]	; (27e80 <pdn_interface_connect+0x2c4>)
   27dbe:	f7ea f95f 	bl	12080 <strlen>
   27dc2:	42b0      	cmp	r0, r6
   27dc4:	d153      	bne.n	27e6e <pdn_interface_connect+0x2b2>
   27dc6:	4623      	mov	r3, r4
   27dc8:	f44f 7280 	mov.w	r2, #256	; 0x100
   27dcc:	492c      	ldr	r1, [pc, #176]	; (27e80 <pdn_interface_connect+0x2c4>)
   27dce:	f8da 0000 	ldr.w	r0, [sl]
   27dd2:	e9cd 4400 	strd	r4, r4, [sp]
   27dd6:	f7ff fca7 	bl	27728 <at_interface_read>
   27dda:	4606      	mov	r6, r0
   27ddc:	4833      	ldr	r0, [pc, #204]	; (27eac <pdn_interface_connect+0x2f0>)
   27dde:	f7ea f94f 	bl	12080 <strlen>
   27de2:	4286      	cmp	r6, r0
   27de4:	db33      	blt.n	27e4e <pdn_interface_connect+0x292>
   27de6:	4602      	mov	r2, r0
   27de8:	4925      	ldr	r1, [pc, #148]	; (27e80 <pdn_interface_connect+0x2c4>)
   27dea:	4830      	ldr	r0, [pc, #192]	; (27eac <pdn_interface_connect+0x2f0>)
   27dec:	f011 fa8a 	bl	39304 <strncmp>
   27df0:	bb68      	cbnz	r0, 27e4e <pdn_interface_connect+0x292>
   27df2:	4628      	mov	r0, r5
   27df4:	4922      	ldr	r1, [pc, #136]	; (27e80 <pdn_interface_connect+0x2c4>)
   27df6:	f7ff fd8b 	bl	27910 <pdn_id_get_parser>
   27dfa:	e759      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27dfc:	482c      	ldr	r0, [pc, #176]	; (27eb0 <pdn_interface_connect+0x2f4>)
   27dfe:	f7ea f93f 	bl	12080 <strlen>
   27e02:	491f      	ldr	r1, [pc, #124]	; (27e80 <pdn_interface_connect+0x2c4>)
   27e04:	4602      	mov	r2, r0
   27e06:	482a      	ldr	r0, [pc, #168]	; (27eb0 <pdn_interface_connect+0x2f4>)
   27e08:	f011 fa7c 	bl	39304 <strncmp>
   27e0c:	2800      	cmp	r0, #0
   27e0e:	f47f af4a 	bne.w	27ca6 <pdn_interface_connect+0xea>
   27e12:	2008      	movs	r0, #8
   27e14:	f7f8 f924 	bl	20060 <bsd_os_errno_set>
   27e18:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27e1c:	e748      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27e1e:	f5c4 7180 	rsb	r1, r4, #256	; 0x100
   27e22:	1930      	adds	r0, r6, r4
   27e24:	4b23      	ldr	r3, [pc, #140]	; (27eb4 <pdn_interface_connect+0x2f8>)
   27e26:	4a1b      	ldr	r2, [pc, #108]	; (27e94 <pdn_interface_connect+0x2d8>)
   27e28:	f009 ff2a 	bl	31c80 <sniprintf>
   27e2c:	4404      	add	r4, r0
   27e2e:	e718      	b.n	27c62 <pdn_interface_connect+0xa6>
   27e30:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27e34:	2009      	movs	r0, #9
   27e36:	f7f8 f913 	bl	20060 <bsd_os_errno_set>
   27e3a:	4620      	mov	r0, r4
   27e3c:	b003      	add	sp, #12
   27e3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   27e42:	2016      	movs	r0, #22
   27e44:	f7f8 f90c 	bl	20060 <bsd_os_errno_set>
   27e48:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27e4c:	e730      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27e4e:	4818      	ldr	r0, [pc, #96]	; (27eb0 <pdn_interface_connect+0x2f4>)
   27e50:	f7ea f916 	bl	12080 <strlen>
   27e54:	490a      	ldr	r1, [pc, #40]	; (27e80 <pdn_interface_connect+0x2c4>)
   27e56:	4602      	mov	r2, r0
   27e58:	4815      	ldr	r0, [pc, #84]	; (27eb0 <pdn_interface_connect+0x2f4>)
   27e5a:	f011 fa53 	bl	39304 <strncmp>
   27e5e:	b930      	cbnz	r0, 27e6e <pdn_interface_connect+0x2b2>
   27e60:	2008      	movs	r0, #8
   27e62:	f7f8 f8fd 	bl	20060 <bsd_os_errno_set>
   27e66:	e723      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27e68:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
   27e6c:	e720      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27e6e:	2005      	movs	r0, #5
   27e70:	f7f8 f8f6 	bl	20060 <bsd_os_errno_set>
   27e74:	e71c      	b.n	27cb0 <pdn_interface_connect+0xf4>
   27e76:	bf00      	nop
   27e78:	789a0000 	.word	0x789a0000
   27e7c:	200228b8 	.word	0x200228b8
   27e80:	200227b8 	.word	0x200227b8
   27e84:	0003a9b8 	.word	0x0003a9b8
   27e88:	0003a9c4 	.word	0x0003a9c4
   27e8c:	0003a9d8 	.word	0x0003a9d8
   27e90:	0003a9e0 	.word	0x0003a9e0
   27e94:	0003a9d0 	.word	0x0003a9d0
   27e98:	0003aa14 	.word	0x0003aa14
   27e9c:	0003a9e4 	.word	0x0003a9e4
   27ea0:	0003a9e8 	.word	0x0003a9e8
   27ea4:	0003a9f4 	.word	0x0003a9f4
   27ea8:	0003a9f8 	.word	0x0003a9f8
   27eac:	0003aa08 	.word	0x0003aa08
   27eb0:	0003aa4c 	.word	0x0003aa4c
   27eb4:	0003a9c8 	.word	0x0003a9c8
   27eb8:	200227b4 	.word	0x200227b4

00027ebc <pdn_interface_close>:
   27ebc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   27ec0:	4a6b      	ldr	r2, [pc, #428]	; (28070 <pdn_interface_close+0x1b4>)
   27ec2:	0c03      	lsrs	r3, r0, #16
   27ec4:	041b      	lsls	r3, r3, #16
   27ec6:	4293      	cmp	r3, r2
   27ec8:	b083      	sub	sp, #12
   27eca:	f040 80ac 	bne.w	28026 <pdn_interface_close+0x16a>
   27ece:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   27ed2:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   27ed6:	2c09      	cmp	r4, #9
   27ed8:	f300 80a5 	bgt.w	28026 <pdn_interface_close+0x16a>
   27edc:	4d65      	ldr	r5, [pc, #404]	; (28074 <pdn_interface_close+0x1b8>)
   27ede:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   27ee2:	2800      	cmp	r0, #0
   27ee4:	f000 809f 	beq.w	28026 <pdn_interface_close+0x16a>
   27ee8:	6883      	ldr	r3, [r0, #8]
   27eea:	2b00      	cmp	r3, #0
   27eec:	f000 809b 	beq.w	28026 <pdn_interface_close+0x16a>
   27ef0:	6883      	ldr	r3, [r0, #8]
   27ef2:	2b03      	cmp	r3, #3
   27ef4:	d00b      	beq.n	27f0e <pdn_interface_close+0x52>
   27ef6:	6883      	ldr	r3, [r0, #8]
   27ef8:	2b02      	cmp	r3, #2
   27efa:	d055      	beq.n	27fa8 <pdn_interface_close+0xec>
   27efc:	f002 f826 	bl	29f4c <nrf_free>
   27f00:	2300      	movs	r3, #0
   27f02:	4618      	mov	r0, r3
   27f04:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
   27f08:	b003      	add	sp, #12
   27f0a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   27f0e:	4e5a      	ldr	r6, [pc, #360]	; (28078 <pdn_interface_close+0x1bc>)
   27f10:	4a5a      	ldr	r2, [pc, #360]	; (2807c <pdn_interface_close+0x1c0>)
   27f12:	f44f 7180 	mov.w	r1, #256	; 0x100
   27f16:	4630      	mov	r0, r6
   27f18:	f009 feb2 	bl	31c80 <sniprintf>
   27f1c:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   27f20:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   27f24:	681b      	ldr	r3, [r3, #0]
   27f26:	4a56      	ldr	r2, [pc, #344]	; (28080 <pdn_interface_close+0x1c4>)
   27f28:	4430      	add	r0, r6
   27f2a:	f8df 8164 	ldr.w	r8, [pc, #356]	; 28090 <pdn_interface_close+0x1d4>
   27f2e:	f009 fea7 	bl	31c80 <sniprintf>
   27f32:	4630      	mov	r0, r6
   27f34:	f8d8 9000 	ldr.w	r9, [r8]
   27f38:	2700      	movs	r7, #0
   27f3a:	f7ea f8a1 	bl	12080 <strlen>
   27f3e:	4631      	mov	r1, r6
   27f40:	4602      	mov	r2, r0
   27f42:	463b      	mov	r3, r7
   27f44:	4648      	mov	r0, r9
   27f46:	9701      	str	r7, [sp, #4]
   27f48:	9700      	str	r7, [sp, #0]
   27f4a:	f7ff fa99 	bl	27480 <at_interface_write>
   27f4e:	4681      	mov	r9, r0
   27f50:	4630      	mov	r0, r6
   27f52:	f7ea f895 	bl	12080 <strlen>
   27f56:	4548      	cmp	r0, r9
   27f58:	f040 8082 	bne.w	28060 <pdn_interface_close+0x1a4>
   27f5c:	463b      	mov	r3, r7
   27f5e:	e9cd 7700 	strd	r7, r7, [sp]
   27f62:	f44f 7280 	mov.w	r2, #256	; 0x100
   27f66:	4631      	mov	r1, r6
   27f68:	f8d8 0000 	ldr.w	r0, [r8]
   27f6c:	f7ff fbdc 	bl	27728 <at_interface_read>
   27f70:	4607      	mov	r7, r0
   27f72:	4844      	ldr	r0, [pc, #272]	; (28084 <pdn_interface_close+0x1c8>)
   27f74:	f7ea f884 	bl	12080 <strlen>
   27f78:	4287      	cmp	r7, r0
   27f7a:	da5a      	bge.n	28032 <pdn_interface_close+0x176>
   27f7c:	4842      	ldr	r0, [pc, #264]	; (28088 <pdn_interface_close+0x1cc>)
   27f7e:	f7ea f87f 	bl	12080 <strlen>
   27f82:	493d      	ldr	r1, [pc, #244]	; (28078 <pdn_interface_close+0x1bc>)
   27f84:	4602      	mov	r2, r0
   27f86:	4840      	ldr	r0, [pc, #256]	; (28088 <pdn_interface_close+0x1cc>)
   27f88:	f011 f9bc 	bl	39304 <strncmp>
   27f8c:	2800      	cmp	r0, #0
   27f8e:	d167      	bne.n	28060 <pdn_interface_close+0x1a4>
   27f90:	2008      	movs	r0, #8
   27f92:	f7f8 f865 	bl	20060 <bsd_os_errno_set>
   27f96:	2202      	movs	r2, #2
   27f98:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   27f9c:	609a      	str	r2, [r3, #8]
   27f9e:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   27fa2:	6883      	ldr	r3, [r0, #8]
   27fa4:	2b02      	cmp	r3, #2
   27fa6:	d1a9      	bne.n	27efc <pdn_interface_close+0x40>
   27fa8:	4e33      	ldr	r6, [pc, #204]	; (28078 <pdn_interface_close+0x1bc>)
   27faa:	4a38      	ldr	r2, [pc, #224]	; (2808c <pdn_interface_close+0x1d0>)
   27fac:	f44f 7180 	mov.w	r1, #256	; 0x100
   27fb0:	4630      	mov	r0, r6
   27fb2:	f009 fe65 	bl	31c80 <sniprintf>
   27fb6:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   27fba:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   27fbe:	681b      	ldr	r3, [r3, #0]
   27fc0:	4a2f      	ldr	r2, [pc, #188]	; (28080 <pdn_interface_close+0x1c4>)
   27fc2:	4430      	add	r0, r6
   27fc4:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 28090 <pdn_interface_close+0x1d4>
   27fc8:	f009 fe5a 	bl	31c80 <sniprintf>
   27fcc:	4630      	mov	r0, r6
   27fce:	f8d8 9000 	ldr.w	r9, [r8]
   27fd2:	2700      	movs	r7, #0
   27fd4:	f7ea f854 	bl	12080 <strlen>
   27fd8:	4631      	mov	r1, r6
   27fda:	4602      	mov	r2, r0
   27fdc:	463b      	mov	r3, r7
   27fde:	4648      	mov	r0, r9
   27fe0:	9701      	str	r7, [sp, #4]
   27fe2:	9700      	str	r7, [sp, #0]
   27fe4:	f7ff fa4c 	bl	27480 <at_interface_write>
   27fe8:	4681      	mov	r9, r0
   27fea:	4630      	mov	r0, r6
   27fec:	f7ea f848 	bl	12080 <strlen>
   27ff0:	4548      	cmp	r0, r9
   27ff2:	d139      	bne.n	28068 <pdn_interface_close+0x1ac>
   27ff4:	463b      	mov	r3, r7
   27ff6:	e9cd 7700 	strd	r7, r7, [sp]
   27ffa:	f44f 7280 	mov.w	r2, #256	; 0x100
   27ffe:	4631      	mov	r1, r6
   28000:	f8d8 0000 	ldr.w	r0, [r8]
   28004:	f7ff fb90 	bl	27728 <at_interface_read>
   28008:	4607      	mov	r7, r0
   2800a:	481e      	ldr	r0, [pc, #120]	; (28084 <pdn_interface_close+0x1c8>)
   2800c:	f7ea f838 	bl	12080 <strlen>
   28010:	4287      	cmp	r7, r0
   28012:	db16      	blt.n	28042 <pdn_interface_close+0x186>
   28014:	4602      	mov	r2, r0
   28016:	4631      	mov	r1, r6
   28018:	481a      	ldr	r0, [pc, #104]	; (28084 <pdn_interface_close+0x1c8>)
   2801a:	f011 f973 	bl	39304 <strncmp>
   2801e:	b980      	cbnz	r0, 28042 <pdn_interface_close+0x186>
   28020:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   28024:	e76a      	b.n	27efc <pdn_interface_close+0x40>
   28026:	2009      	movs	r0, #9
   28028:	f7f8 f81a 	bl	20060 <bsd_os_errno_set>
   2802c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28030:	e76a      	b.n	27f08 <pdn_interface_close+0x4c>
   28032:	4602      	mov	r2, r0
   28034:	4631      	mov	r1, r6
   28036:	4813      	ldr	r0, [pc, #76]	; (28084 <pdn_interface_close+0x1c8>)
   28038:	f011 f964 	bl	39304 <strncmp>
   2803c:	2800      	cmp	r0, #0
   2803e:	d0aa      	beq.n	27f96 <pdn_interface_close+0xda>
   28040:	e79c      	b.n	27f7c <pdn_interface_close+0xc0>
   28042:	4811      	ldr	r0, [pc, #68]	; (28088 <pdn_interface_close+0x1cc>)
   28044:	f7ea f81c 	bl	12080 <strlen>
   28048:	490b      	ldr	r1, [pc, #44]	; (28078 <pdn_interface_close+0x1bc>)
   2804a:	4602      	mov	r2, r0
   2804c:	480e      	ldr	r0, [pc, #56]	; (28088 <pdn_interface_close+0x1cc>)
   2804e:	f011 f959 	bl	39304 <strncmp>
   28052:	b948      	cbnz	r0, 28068 <pdn_interface_close+0x1ac>
   28054:	2008      	movs	r0, #8
   28056:	f7f8 f803 	bl	20060 <bsd_os_errno_set>
   2805a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
   2805e:	e74d      	b.n	27efc <pdn_interface_close+0x40>
   28060:	2005      	movs	r0, #5
   28062:	f7f7 fffd 	bl	20060 <bsd_os_errno_set>
   28066:	e796      	b.n	27f96 <pdn_interface_close+0xda>
   28068:	2005      	movs	r0, #5
   2806a:	f7f7 fff9 	bl	20060 <bsd_os_errno_set>
   2806e:	e7d7      	b.n	28020 <pdn_interface_close+0x164>
   28070:	789a0000 	.word	0x789a0000
   28074:	200228b8 	.word	0x200228b8
   28078:	200227b8 	.word	0x200227b8
   2807c:	0003a9ac 	.word	0x0003a9ac
   28080:	0003a9f4 	.word	0x0003a9f4
   28084:	0003a9e4 	.word	0x0003a9e4
   28088:	0003aa4c 	.word	0x0003aa4c
   2808c:	0003a9b8 	.word	0x0003a9b8
   28090:	200227b4 	.word	0x200227b4

00028094 <pdn_interface_setopt>:
   28094:	b538      	push	{r3, r4, r5, lr}
   28096:	f240 2502 	movw	r5, #514	; 0x202
   2809a:	42a9      	cmp	r1, r5
   2809c:	9c04      	ldr	r4, [sp, #16]
   2809e:	d140      	bne.n	28122 <pdn_interface_setopt+0x8e>
   280a0:	2b00      	cmp	r3, #0
   280a2:	d03e      	beq.n	28122 <pdn_interface_setopt+0x8e>
   280a4:	2c00      	cmp	r4, #0
   280a6:	d03c      	beq.n	28122 <pdn_interface_setopt+0x8e>
   280a8:	0c01      	lsrs	r1, r0, #16
   280aa:	4d22      	ldr	r5, [pc, #136]	; (28134 <pdn_interface_setopt+0xa0>)
   280ac:	0409      	lsls	r1, r1, #16
   280ae:	42a9      	cmp	r1, r5
   280b0:	d005      	beq.n	280be <pdn_interface_setopt+0x2a>
   280b2:	2009      	movs	r0, #9
   280b4:	f7f7 ffd4 	bl	20060 <bsd_os_errno_set>
   280b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   280bc:	bd38      	pop	{r3, r4, r5, pc}
   280be:	f020 40f1 	bic.w	r0, r0, #2021654528	; 0x78800000
   280c2:	f420 10d0 	bic.w	r0, r0, #1703936	; 0x1a0000
   280c6:	2809      	cmp	r0, #9
   280c8:	dcf3      	bgt.n	280b2 <pdn_interface_setopt+0x1e>
   280ca:	491b      	ldr	r1, [pc, #108]	; (28138 <pdn_interface_setopt+0xa4>)
   280cc:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   280d0:	2900      	cmp	r1, #0
   280d2:	d0ee      	beq.n	280b2 <pdn_interface_setopt+0x1e>
   280d4:	6888      	ldr	r0, [r1, #8]
   280d6:	2800      	cmp	r0, #0
   280d8:	d0eb      	beq.n	280b2 <pdn_interface_setopt+0x1e>
   280da:	2a01      	cmp	r2, #1
   280dc:	d128      	bne.n	28130 <pdn_interface_setopt+0x9c>
   280de:	688a      	ldr	r2, [r1, #8]
   280e0:	b1ea      	cbz	r2, 2811e <pdn_interface_setopt+0x8a>
   280e2:	688a      	ldr	r2, [r1, #8]
   280e4:	2a03      	cmp	r2, #3
   280e6:	d01a      	beq.n	2811e <pdn_interface_setopt+0x8a>
   280e8:	688a      	ldr	r2, [r1, #8]
   280ea:	2a04      	cmp	r2, #4
   280ec:	d017      	beq.n	2811e <pdn_interface_setopt+0x8a>
   280ee:	08a2      	lsrs	r2, r4, #2
   280f0:	1e50      	subs	r0, r2, #1
   280f2:	2801      	cmp	r0, #1
   280f4:	d815      	bhi.n	28122 <pdn_interface_setopt+0x8e>
   280f6:	07a0      	lsls	r0, r4, #30
   280f8:	d113      	bne.n	28122 <pdn_interface_setopt+0x8e>
   280fa:	6818      	ldr	r0, [r3, #0]
   280fc:	2802      	cmp	r0, #2
   280fe:	d012      	beq.n	28126 <pdn_interface_setopt+0x92>
   28100:	280a      	cmp	r0, #10
   28102:	d10e      	bne.n	28122 <pdn_interface_setopt+0x8e>
   28104:	2002      	movs	r0, #2
   28106:	2a02      	cmp	r2, #2
   28108:	d106      	bne.n	28118 <pdn_interface_setopt+0x84>
   2810a:	685b      	ldr	r3, [r3, #4]
   2810c:	2b02      	cmp	r3, #2
   2810e:	d00c      	beq.n	2812a <pdn_interface_setopt+0x96>
   28110:	2b0a      	cmp	r3, #10
   28112:	d106      	bne.n	28122 <pdn_interface_setopt+0x8e>
   28114:	f040 0002 	orr.w	r0, r0, #2
   28118:	6708      	str	r0, [r1, #112]	; 0x70
   2811a:	2000      	movs	r0, #0
   2811c:	bd38      	pop	{r3, r4, r5, pc}
   2811e:	200e      	movs	r0, #14
   28120:	e7c8      	b.n	280b4 <pdn_interface_setopt+0x20>
   28122:	2016      	movs	r0, #22
   28124:	e7c6      	b.n	280b4 <pdn_interface_setopt+0x20>
   28126:	2001      	movs	r0, #1
   28128:	e7ed      	b.n	28106 <pdn_interface_setopt+0x72>
   2812a:	f040 0001 	orr.w	r0, r0, #1
   2812e:	e7f3      	b.n	28118 <pdn_interface_setopt+0x84>
   28130:	202d      	movs	r0, #45	; 0x2d
   28132:	e7bf      	b.n	280b4 <pdn_interface_setopt+0x20>
   28134:	789a0000 	.word	0x789a0000
   28138:	200228b8 	.word	0x200228b8

0002813c <pdn_interface_getopt>:
   2813c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   28140:	f240 2402 	movw	r4, #514	; 0x202
   28144:	b083      	sub	sp, #12
   28146:	42a1      	cmp	r1, r4
   28148:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   2814a:	f040 809f 	bne.w	2828c <pdn_interface_getopt+0x150>
   2814e:	461e      	mov	r6, r3
   28150:	2b00      	cmp	r3, #0
   28152:	f000 809b 	beq.w	2828c <pdn_interface_getopt+0x150>
   28156:	2d00      	cmp	r5, #0
   28158:	f000 8098 	beq.w	2828c <pdn_interface_getopt+0x150>
   2815c:	0c03      	lsrs	r3, r0, #16
   2815e:	4955      	ldr	r1, [pc, #340]	; (282b4 <pdn_interface_getopt+0x178>)
   28160:	041b      	lsls	r3, r3, #16
   28162:	428b      	cmp	r3, r1
   28164:	f040 8094 	bne.w	28290 <pdn_interface_getopt+0x154>
   28168:	f020 44f1 	bic.w	r4, r0, #2021654528	; 0x78800000
   2816c:	f424 14d0 	bic.w	r4, r4, #1703936	; 0x1a0000
   28170:	2c09      	cmp	r4, #9
   28172:	f300 808d 	bgt.w	28290 <pdn_interface_getopt+0x154>
   28176:	4b50      	ldr	r3, [pc, #320]	; (282b8 <pdn_interface_getopt+0x17c>)
   28178:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   2817c:	2b00      	cmp	r3, #0
   2817e:	f000 8087 	beq.w	28290 <pdn_interface_getopt+0x154>
   28182:	6899      	ldr	r1, [r3, #8]
   28184:	2900      	cmp	r1, #0
   28186:	f000 8083 	beq.w	28290 <pdn_interface_getopt+0x154>
   2818a:	2a02      	cmp	r2, #2
   2818c:	d04c      	beq.n	28228 <pdn_interface_getopt+0xec>
   2818e:	2a03      	cmp	r2, #3
   28190:	d009      	beq.n	281a6 <pdn_interface_getopt+0x6a>
   28192:	2a01      	cmp	r2, #1
   28194:	d052      	beq.n	2823c <pdn_interface_getopt+0x100>
   28196:	202d      	movs	r0, #45	; 0x2d
   28198:	f7f7 ff62 	bl	20060 <bsd_os_errno_set>
   2819c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   281a0:	b003      	add	sp, #12
   281a2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   281a6:	682b      	ldr	r3, [r5, #0]
   281a8:	2b00      	cmp	r3, #0
   281aa:	d06f      	beq.n	2828c <pdn_interface_getopt+0x150>
   281ac:	4a43      	ldr	r2, [pc, #268]	; (282bc <pdn_interface_getopt+0x180>)
   281ae:	f44f 7180 	mov.w	r1, #256	; 0x100
   281b2:	4843      	ldr	r0, [pc, #268]	; (282c0 <pdn_interface_getopt+0x184>)
   281b4:	f8df 8114 	ldr.w	r8, [pc, #276]	; 282cc <pdn_interface_getopt+0x190>
   281b8:	f009 fd62 	bl	31c80 <sniprintf>
   281bc:	4840      	ldr	r0, [pc, #256]	; (282c0 <pdn_interface_getopt+0x184>)
   281be:	f8d8 9000 	ldr.w	r9, [r8]
   281c2:	2700      	movs	r7, #0
   281c4:	f7e9 ff5c 	bl	12080 <strlen>
   281c8:	463b      	mov	r3, r7
   281ca:	4602      	mov	r2, r0
   281cc:	493c      	ldr	r1, [pc, #240]	; (282c0 <pdn_interface_getopt+0x184>)
   281ce:	4648      	mov	r0, r9
   281d0:	9701      	str	r7, [sp, #4]
   281d2:	9700      	str	r7, [sp, #0]
   281d4:	f7ff f954 	bl	27480 <at_interface_write>
   281d8:	4681      	mov	r9, r0
   281da:	4839      	ldr	r0, [pc, #228]	; (282c0 <pdn_interface_getopt+0x184>)
   281dc:	f7e9 ff50 	bl	12080 <strlen>
   281e0:	4548      	cmp	r0, r9
   281e2:	d160      	bne.n	282a6 <pdn_interface_getopt+0x16a>
   281e4:	463b      	mov	r3, r7
   281e6:	e9cd 7700 	strd	r7, r7, [sp]
   281ea:	f44f 7280 	mov.w	r2, #256	; 0x100
   281ee:	4934      	ldr	r1, [pc, #208]	; (282c0 <pdn_interface_getopt+0x184>)
   281f0:	f8d8 0000 	ldr.w	r0, [r8]
   281f4:	f7ff fa98 	bl	27728 <at_interface_read>
   281f8:	4607      	mov	r7, r0
   281fa:	4832      	ldr	r0, [pc, #200]	; (282c4 <pdn_interface_getopt+0x188>)
   281fc:	f7e9 ff40 	bl	12080 <strlen>
   28200:	4287      	cmp	r7, r0
   28202:	db32      	blt.n	2826a <pdn_interface_getopt+0x12e>
   28204:	4602      	mov	r2, r0
   28206:	492e      	ldr	r1, [pc, #184]	; (282c0 <pdn_interface_getopt+0x184>)
   28208:	482e      	ldr	r0, [pc, #184]	; (282c4 <pdn_interface_getopt+0x188>)
   2820a:	f011 f87b 	bl	39304 <strncmp>
   2820e:	4607      	mov	r7, r0
   28210:	bb58      	cbnz	r0, 2826a <pdn_interface_getopt+0x12e>
   28212:	4620      	mov	r0, r4
   28214:	492a      	ldr	r1, [pc, #168]	; (282c0 <pdn_interface_getopt+0x184>)
   28216:	f7ff fb45 	bl	278a4 <pdn_state_get_parser>
   2821a:	2800      	cmp	r0, #0
   2821c:	dbbc      	blt.n	28198 <pdn_interface_getopt+0x5c>
   2821e:	2301      	movs	r3, #1
   28220:	7030      	strb	r0, [r6, #0]
   28222:	4638      	mov	r0, r7
   28224:	602b      	str	r3, [r5, #0]
   28226:	e7bb      	b.n	281a0 <pdn_interface_getopt+0x64>
   28228:	682a      	ldr	r2, [r5, #0]
   2822a:	b37a      	cbz	r2, 2828c <pdn_interface_getopt+0x150>
   2822c:	2201      	movs	r2, #1
   2822e:	2000      	movs	r0, #0
   28230:	681b      	ldr	r3, [r3, #0]
   28232:	7033      	strb	r3, [r6, #0]
   28234:	602a      	str	r2, [r5, #0]
   28236:	b003      	add	sp, #12
   28238:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2823c:	689a      	ldr	r2, [r3, #8]
   2823e:	b31a      	cbz	r2, 28288 <pdn_interface_getopt+0x14c>
   28240:	689a      	ldr	r2, [r3, #8]
   28242:	2a04      	cmp	r2, #4
   28244:	d020      	beq.n	28288 <pdn_interface_getopt+0x14c>
   28246:	682a      	ldr	r2, [r5, #0]
   28248:	2a07      	cmp	r2, #7
   2824a:	d91f      	bls.n	2828c <pdn_interface_getopt+0x150>
   2824c:	f012 0203 	ands.w	r2, r2, #3
   28250:	d11c      	bne.n	2828c <pdn_interface_getopt+0x150>
   28252:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   28254:	0799      	lsls	r1, r3, #30
   28256:	d421      	bmi.n	2829c <pdn_interface_getopt+0x160>
   28258:	2104      	movs	r1, #4
   2825a:	07db      	lsls	r3, r3, #31
   2825c:	d502      	bpl.n	28264 <pdn_interface_getopt+0x128>
   2825e:	2302      	movs	r3, #2
   28260:	50b3      	str	r3, [r6, r2]
   28262:	460a      	mov	r2, r1
   28264:	602a      	str	r2, [r5, #0]
   28266:	2000      	movs	r0, #0
   28268:	e79a      	b.n	281a0 <pdn_interface_getopt+0x64>
   2826a:	4817      	ldr	r0, [pc, #92]	; (282c8 <pdn_interface_getopt+0x18c>)
   2826c:	f7e9 ff08 	bl	12080 <strlen>
   28270:	4913      	ldr	r1, [pc, #76]	; (282c0 <pdn_interface_getopt+0x184>)
   28272:	4602      	mov	r2, r0
   28274:	4814      	ldr	r0, [pc, #80]	; (282c8 <pdn_interface_getopt+0x18c>)
   28276:	f011 f845 	bl	39304 <strncmp>
   2827a:	b9a0      	cbnz	r0, 282a6 <pdn_interface_getopt+0x16a>
   2827c:	2008      	movs	r0, #8
   2827e:	f7f7 feef 	bl	20060 <bsd_os_errno_set>
   28282:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28286:	e787      	b.n	28198 <pdn_interface_getopt+0x5c>
   28288:	200e      	movs	r0, #14
   2828a:	e785      	b.n	28198 <pdn_interface_getopt+0x5c>
   2828c:	2016      	movs	r0, #22
   2828e:	e783      	b.n	28198 <pdn_interface_getopt+0x5c>
   28290:	2009      	movs	r0, #9
   28292:	f7f7 fee5 	bl	20060 <bsd_os_errno_set>
   28296:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2829a:	e781      	b.n	281a0 <pdn_interface_getopt+0x64>
   2829c:	220a      	movs	r2, #10
   2829e:	2108      	movs	r1, #8
   282a0:	6032      	str	r2, [r6, #0]
   282a2:	2204      	movs	r2, #4
   282a4:	e7d9      	b.n	2825a <pdn_interface_getopt+0x11e>
   282a6:	2005      	movs	r0, #5
   282a8:	f7f7 feda 	bl	20060 <bsd_os_errno_set>
   282ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   282b0:	e772      	b.n	28198 <pdn_interface_getopt+0x5c>
   282b2:	bf00      	nop
   282b4:	789a0000 	.word	0x789a0000
   282b8:	200228b8 	.word	0x200228b8
   282bc:	0003aa1c 	.word	0x0003aa1c
   282c0:	200227b8 	.word	0x200227b8
   282c4:	0003aa28 	.word	0x0003aa28
   282c8:	0003aa4c 	.word	0x0003aa4c
   282cc:	200227b4 	.word	0x200227b4

000282d0 <pdn_interface_pdn_id_get>:
   282d0:	2900      	cmp	r1, #0
   282d2:	f000 83b9 	beq.w	28a48 <pdn_interface_pdn_id_get+0x778>
   282d6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   282da:	4ca3      	ldr	r4, [pc, #652]	; (28568 <pdn_interface_pdn_id_get+0x298>)
   282dc:	2802      	cmp	r0, #2
   282de:	b083      	sub	sp, #12
   282e0:	460d      	mov	r5, r1
   282e2:	6823      	ldr	r3, [r4, #0]
   282e4:	f000 8094 	beq.w	28410 <pdn_interface_pdn_id_get+0x140>
   282e8:	280a      	cmp	r0, #10
   282ea:	d03f      	beq.n	2836c <pdn_interface_pdn_id_get+0x9c>
   282ec:	b11b      	cbz	r3, 282f6 <pdn_interface_pdn_id_get+0x26>
   282ee:	689b      	ldr	r3, [r3, #8]
   282f0:	2b03      	cmp	r3, #3
   282f2:	f000 8127 	beq.w	28544 <pdn_interface_pdn_id_get+0x274>
   282f6:	6863      	ldr	r3, [r4, #4]
   282f8:	b11b      	cbz	r3, 28302 <pdn_interface_pdn_id_get+0x32>
   282fa:	689b      	ldr	r3, [r3, #8]
   282fc:	2b03      	cmp	r3, #3
   282fe:	f000 8110 	beq.w	28522 <pdn_interface_pdn_id_get+0x252>
   28302:	68a3      	ldr	r3, [r4, #8]
   28304:	b11b      	cbz	r3, 2830e <pdn_interface_pdn_id_get+0x3e>
   28306:	689b      	ldr	r3, [r3, #8]
   28308:	2b03      	cmp	r3, #3
   2830a:	f000 80f9 	beq.w	28500 <pdn_interface_pdn_id_get+0x230>
   2830e:	68e3      	ldr	r3, [r4, #12]
   28310:	b11b      	cbz	r3, 2831a <pdn_interface_pdn_id_get+0x4a>
   28312:	689b      	ldr	r3, [r3, #8]
   28314:	2b03      	cmp	r3, #3
   28316:	f000 80e2 	beq.w	284de <pdn_interface_pdn_id_get+0x20e>
   2831a:	6923      	ldr	r3, [r4, #16]
   2831c:	b11b      	cbz	r3, 28326 <pdn_interface_pdn_id_get+0x56>
   2831e:	689b      	ldr	r3, [r3, #8]
   28320:	2b03      	cmp	r3, #3
   28322:	f000 8123 	beq.w	2856c <pdn_interface_pdn_id_get+0x29c>
   28326:	6963      	ldr	r3, [r4, #20]
   28328:	b11b      	cbz	r3, 28332 <pdn_interface_pdn_id_get+0x62>
   2832a:	689b      	ldr	r3, [r3, #8]
   2832c:	2b03      	cmp	r3, #3
   2832e:	f000 8161 	beq.w	285f4 <pdn_interface_pdn_id_get+0x324>
   28332:	69a3      	ldr	r3, [r4, #24]
   28334:	b11b      	cbz	r3, 2833e <pdn_interface_pdn_id_get+0x6e>
   28336:	689b      	ldr	r3, [r3, #8]
   28338:	2b03      	cmp	r3, #3
   2833a:	f000 814a 	beq.w	285d2 <pdn_interface_pdn_id_get+0x302>
   2833e:	69e3      	ldr	r3, [r4, #28]
   28340:	b11b      	cbz	r3, 2834a <pdn_interface_pdn_id_get+0x7a>
   28342:	689b      	ldr	r3, [r3, #8]
   28344:	2b03      	cmp	r3, #3
   28346:	f000 8133 	beq.w	285b0 <pdn_interface_pdn_id_get+0x2e0>
   2834a:	6a23      	ldr	r3, [r4, #32]
   2834c:	b11b      	cbz	r3, 28356 <pdn_interface_pdn_id_get+0x86>
   2834e:	689b      	ldr	r3, [r3, #8]
   28350:	2b03      	cmp	r3, #3
   28352:	f000 811c 	beq.w	2858e <pdn_interface_pdn_id_get+0x2be>
   28356:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28358:	b11b      	cbz	r3, 28362 <pdn_interface_pdn_id_get+0x92>
   2835a:	689b      	ldr	r3, [r3, #8]
   2835c:	2b03      	cmp	r3, #3
   2835e:	f000 80ad 	beq.w	284bc <pdn_interface_pdn_id_get+0x1ec>
   28362:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28366:	b003      	add	sp, #12
   28368:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   2836c:	b11b      	cbz	r3, 28376 <pdn_interface_pdn_id_get+0xa6>
   2836e:	689b      	ldr	r3, [r3, #8]
   28370:	2b03      	cmp	r3, #3
   28372:	f000 8335 	beq.w	289e0 <pdn_interface_pdn_id_get+0x710>
   28376:	6863      	ldr	r3, [r4, #4]
   28378:	b11b      	cbz	r3, 28382 <pdn_interface_pdn_id_get+0xb2>
   2837a:	689b      	ldr	r3, [r3, #8]
   2837c:	2b03      	cmp	r3, #3
   2837e:	f000 82fd 	beq.w	2897c <pdn_interface_pdn_id_get+0x6ac>
   28382:	68a3      	ldr	r3, [r4, #8]
   28384:	b11b      	cbz	r3, 2838e <pdn_interface_pdn_id_get+0xbe>
   28386:	689b      	ldr	r3, [r3, #8]
   28388:	2b03      	cmp	r3, #3
   2838a:	f000 82d5 	beq.w	28938 <pdn_interface_pdn_id_get+0x668>
   2838e:	68e3      	ldr	r3, [r4, #12]
   28390:	b11b      	cbz	r3, 2839a <pdn_interface_pdn_id_get+0xca>
   28392:	689e      	ldr	r6, [r3, #8]
   28394:	2e03      	cmp	r6, #3
   28396:	f000 81f0 	beq.w	2877a <pdn_interface_pdn_id_get+0x4aa>
   2839a:	6923      	ldr	r3, [r4, #16]
   2839c:	b11b      	cbz	r3, 283a6 <pdn_interface_pdn_id_get+0xd6>
   2839e:	689b      	ldr	r3, [r3, #8]
   283a0:	2b03      	cmp	r3, #3
   283a2:	f000 8203 	beq.w	287ac <pdn_interface_pdn_id_get+0x4dc>
   283a6:	6963      	ldr	r3, [r4, #20]
   283a8:	b11b      	cbz	r3, 283b2 <pdn_interface_pdn_id_get+0xe2>
   283aa:	689b      	ldr	r3, [r3, #8]
   283ac:	2b03      	cmp	r3, #3
   283ae:	f000 8215 	beq.w	287dc <pdn_interface_pdn_id_get+0x50c>
   283b2:	69a3      	ldr	r3, [r4, #24]
   283b4:	b11b      	cbz	r3, 283be <pdn_interface_pdn_id_get+0xee>
   283b6:	689b      	ldr	r3, [r3, #8]
   283b8:	2b03      	cmp	r3, #3
   283ba:	f000 8227 	beq.w	2880c <pdn_interface_pdn_id_get+0x53c>
   283be:	69e3      	ldr	r3, [r4, #28]
   283c0:	b11b      	cbz	r3, 283ca <pdn_interface_pdn_id_get+0xfa>
   283c2:	689b      	ldr	r3, [r3, #8]
   283c4:	2b03      	cmp	r3, #3
   283c6:	f000 8239 	beq.w	2883c <pdn_interface_pdn_id_get+0x56c>
   283ca:	6a23      	ldr	r3, [r4, #32]
   283cc:	b11b      	cbz	r3, 283d6 <pdn_interface_pdn_id_get+0x106>
   283ce:	689b      	ldr	r3, [r3, #8]
   283d0:	2b03      	cmp	r3, #3
   283d2:	f000 824d 	beq.w	28870 <pdn_interface_pdn_id_get+0x5a0>
   283d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   283d8:	2b00      	cmp	r3, #0
   283da:	d0c2      	beq.n	28362 <pdn_interface_pdn_id_get+0x92>
   283dc:	689b      	ldr	r3, [r3, #8]
   283de:	2b03      	cmp	r3, #3
   283e0:	d1bf      	bne.n	28362 <pdn_interface_pdn_id_get+0x92>
   283e2:	4628      	mov	r0, r5
   283e4:	f7e9 fe4c 	bl	12080 <strlen>
   283e8:	4606      	mov	r6, r0
   283ea:	6a60      	ldr	r0, [r4, #36]	; 0x24
   283ec:	300c      	adds	r0, #12
   283ee:	f7e9 fe47 	bl	12080 <strlen>
   283f2:	42b0      	cmp	r0, r6
   283f4:	d1b5      	bne.n	28362 <pdn_interface_pdn_id_get+0x92>
   283f6:	6a61      	ldr	r1, [r4, #36]	; 0x24
   283f8:	4628      	mov	r0, r5
   283fa:	310c      	adds	r1, #12
   283fc:	f7e9 fe36 	bl	1206c <strcmp>
   28400:	2800      	cmp	r0, #0
   28402:	d1ae      	bne.n	28362 <pdn_interface_pdn_id_get+0x92>
   28404:	6a63      	ldr	r3, [r4, #36]	; 0x24
   28406:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28408:	0792      	lsls	r2, r2, #30
   2840a:	d5aa      	bpl.n	28362 <pdn_interface_pdn_id_get+0x92>
   2840c:	2609      	movs	r6, #9
   2840e:	e11a      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   28410:	b11b      	cbz	r3, 2841a <pdn_interface_pdn_id_get+0x14a>
   28412:	689b      	ldr	r3, [r3, #8]
   28414:	2b03      	cmp	r3, #3
   28416:	f000 82fd 	beq.w	28a14 <pdn_interface_pdn_id_get+0x744>
   2841a:	6863      	ldr	r3, [r4, #4]
   2841c:	b11b      	cbz	r3, 28426 <pdn_interface_pdn_id_get+0x156>
   2841e:	689b      	ldr	r3, [r3, #8]
   28420:	2b03      	cmp	r3, #3
   28422:	f000 82c5 	beq.w	289b0 <pdn_interface_pdn_id_get+0x6e0>
   28426:	68a3      	ldr	r3, [r4, #8]
   28428:	b11b      	cbz	r3, 28432 <pdn_interface_pdn_id_get+0x162>
   2842a:	689b      	ldr	r3, [r3, #8]
   2842c:	2b03      	cmp	r3, #3
   2842e:	f000 8269 	beq.w	28904 <pdn_interface_pdn_id_get+0x634>
   28432:	68e3      	ldr	r3, [r4, #12]
   28434:	b11b      	cbz	r3, 2843e <pdn_interface_pdn_id_get+0x16e>
   28436:	689e      	ldr	r6, [r3, #8]
   28438:	2e03      	cmp	r6, #3
   2843a:	f000 80ec 	beq.w	28616 <pdn_interface_pdn_id_get+0x346>
   2843e:	6923      	ldr	r3, [r4, #16]
   28440:	b11b      	cbz	r3, 2844a <pdn_interface_pdn_id_get+0x17a>
   28442:	689b      	ldr	r3, [r3, #8]
   28444:	2b03      	cmp	r3, #3
   28446:	f000 814a 	beq.w	286de <pdn_interface_pdn_id_get+0x40e>
   2844a:	6963      	ldr	r3, [r4, #20]
   2844c:	b11b      	cbz	r3, 28456 <pdn_interface_pdn_id_get+0x186>
   2844e:	689b      	ldr	r3, [r3, #8]
   28450:	2b03      	cmp	r3, #3
   28452:	f000 815e 	beq.w	28712 <pdn_interface_pdn_id_get+0x442>
   28456:	69a3      	ldr	r3, [r4, #24]
   28458:	b11b      	cbz	r3, 28462 <pdn_interface_pdn_id_get+0x192>
   2845a:	689b      	ldr	r3, [r3, #8]
   2845c:	2b03      	cmp	r3, #3
   2845e:	f000 8172 	beq.w	28746 <pdn_interface_pdn_id_get+0x476>
   28462:	69e3      	ldr	r3, [r4, #28]
   28464:	b11b      	cbz	r3, 2846e <pdn_interface_pdn_id_get+0x19e>
   28466:	689b      	ldr	r3, [r3, #8]
   28468:	2b03      	cmp	r3, #3
   2846a:	f000 821b 	beq.w	288a4 <pdn_interface_pdn_id_get+0x5d4>
   2846e:	6a23      	ldr	r3, [r4, #32]
   28470:	b11b      	cbz	r3, 2847a <pdn_interface_pdn_id_get+0x1aa>
   28472:	689b      	ldr	r3, [r3, #8]
   28474:	2b03      	cmp	r3, #3
   28476:	f000 822d 	beq.w	288d4 <pdn_interface_pdn_id_get+0x604>
   2847a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2847c:	2b00      	cmp	r3, #0
   2847e:	f43f af70 	beq.w	28362 <pdn_interface_pdn_id_get+0x92>
   28482:	689b      	ldr	r3, [r3, #8]
   28484:	2b03      	cmp	r3, #3
   28486:	f47f af6c 	bne.w	28362 <pdn_interface_pdn_id_get+0x92>
   2848a:	4628      	mov	r0, r5
   2848c:	f7e9 fdf8 	bl	12080 <strlen>
   28490:	4606      	mov	r6, r0
   28492:	6a60      	ldr	r0, [r4, #36]	; 0x24
   28494:	300c      	adds	r0, #12
   28496:	f7e9 fdf3 	bl	12080 <strlen>
   2849a:	4286      	cmp	r6, r0
   2849c:	f47f af61 	bne.w	28362 <pdn_interface_pdn_id_get+0x92>
   284a0:	6a61      	ldr	r1, [r4, #36]	; 0x24
   284a2:	4628      	mov	r0, r5
   284a4:	310c      	adds	r1, #12
   284a6:	f7e9 fde1 	bl	1206c <strcmp>
   284aa:	2800      	cmp	r0, #0
   284ac:	f47f af59 	bne.w	28362 <pdn_interface_pdn_id_get+0x92>
   284b0:	6a63      	ldr	r3, [r4, #36]	; 0x24
   284b2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   284b4:	07d2      	lsls	r2, r2, #31
   284b6:	f57f af54 	bpl.w	28362 <pdn_interface_pdn_id_get+0x92>
   284ba:	e7a7      	b.n	2840c <pdn_interface_pdn_id_get+0x13c>
   284bc:	4628      	mov	r0, r5
   284be:	f7e9 fddf 	bl	12080 <strlen>
   284c2:	4606      	mov	r6, r0
   284c4:	6a60      	ldr	r0, [r4, #36]	; 0x24
   284c6:	300c      	adds	r0, #12
   284c8:	f7e9 fdda 	bl	12080 <strlen>
   284cc:	42b0      	cmp	r0, r6
   284ce:	f47f af48 	bne.w	28362 <pdn_interface_pdn_id_get+0x92>
   284d2:	6a61      	ldr	r1, [r4, #36]	; 0x24
   284d4:	4628      	mov	r0, r5
   284d6:	310c      	adds	r1, #12
   284d8:	f7e9 fdc8 	bl	1206c <strcmp>
   284dc:	e741      	b.n	28362 <pdn_interface_pdn_id_get+0x92>
   284de:	4628      	mov	r0, r5
   284e0:	f7e9 fdce 	bl	12080 <strlen>
   284e4:	4606      	mov	r6, r0
   284e6:	68e0      	ldr	r0, [r4, #12]
   284e8:	300c      	adds	r0, #12
   284ea:	f7e9 fdc9 	bl	12080 <strlen>
   284ee:	4286      	cmp	r6, r0
   284f0:	f47f af13 	bne.w	2831a <pdn_interface_pdn_id_get+0x4a>
   284f4:	68e1      	ldr	r1, [r4, #12]
   284f6:	4628      	mov	r0, r5
   284f8:	310c      	adds	r1, #12
   284fa:	f7e9 fdb7 	bl	1206c <strcmp>
   284fe:	e70c      	b.n	2831a <pdn_interface_pdn_id_get+0x4a>
   28500:	4628      	mov	r0, r5
   28502:	f7e9 fdbd 	bl	12080 <strlen>
   28506:	4606      	mov	r6, r0
   28508:	68a0      	ldr	r0, [r4, #8]
   2850a:	300c      	adds	r0, #12
   2850c:	f7e9 fdb8 	bl	12080 <strlen>
   28510:	4286      	cmp	r6, r0
   28512:	f47f aefc 	bne.w	2830e <pdn_interface_pdn_id_get+0x3e>
   28516:	68a1      	ldr	r1, [r4, #8]
   28518:	4628      	mov	r0, r5
   2851a:	310c      	adds	r1, #12
   2851c:	f7e9 fda6 	bl	1206c <strcmp>
   28520:	e6f5      	b.n	2830e <pdn_interface_pdn_id_get+0x3e>
   28522:	4628      	mov	r0, r5
   28524:	f7e9 fdac 	bl	12080 <strlen>
   28528:	4606      	mov	r6, r0
   2852a:	6860      	ldr	r0, [r4, #4]
   2852c:	300c      	adds	r0, #12
   2852e:	f7e9 fda7 	bl	12080 <strlen>
   28532:	4286      	cmp	r6, r0
   28534:	f47f aee5 	bne.w	28302 <pdn_interface_pdn_id_get+0x32>
   28538:	6861      	ldr	r1, [r4, #4]
   2853a:	4628      	mov	r0, r5
   2853c:	310c      	adds	r1, #12
   2853e:	f7e9 fd95 	bl	1206c <strcmp>
   28542:	e6de      	b.n	28302 <pdn_interface_pdn_id_get+0x32>
   28544:	4608      	mov	r0, r1
   28546:	f7e9 fd9b 	bl	12080 <strlen>
   2854a:	4606      	mov	r6, r0
   2854c:	6820      	ldr	r0, [r4, #0]
   2854e:	300c      	adds	r0, #12
   28550:	f7e9 fd96 	bl	12080 <strlen>
   28554:	4286      	cmp	r6, r0
   28556:	f47f aece 	bne.w	282f6 <pdn_interface_pdn_id_get+0x26>
   2855a:	6821      	ldr	r1, [r4, #0]
   2855c:	4628      	mov	r0, r5
   2855e:	310c      	adds	r1, #12
   28560:	f7e9 fd84 	bl	1206c <strcmp>
   28564:	e6c7      	b.n	282f6 <pdn_interface_pdn_id_get+0x26>
   28566:	bf00      	nop
   28568:	200228b8 	.word	0x200228b8
   2856c:	4628      	mov	r0, r5
   2856e:	f7e9 fd87 	bl	12080 <strlen>
   28572:	4606      	mov	r6, r0
   28574:	6920      	ldr	r0, [r4, #16]
   28576:	300c      	adds	r0, #12
   28578:	f7e9 fd82 	bl	12080 <strlen>
   2857c:	4286      	cmp	r6, r0
   2857e:	f47f aed2 	bne.w	28326 <pdn_interface_pdn_id_get+0x56>
   28582:	6921      	ldr	r1, [r4, #16]
   28584:	4628      	mov	r0, r5
   28586:	310c      	adds	r1, #12
   28588:	f7e9 fd70 	bl	1206c <strcmp>
   2858c:	e6cb      	b.n	28326 <pdn_interface_pdn_id_get+0x56>
   2858e:	4628      	mov	r0, r5
   28590:	f7e9 fd76 	bl	12080 <strlen>
   28594:	4606      	mov	r6, r0
   28596:	6a20      	ldr	r0, [r4, #32]
   28598:	300c      	adds	r0, #12
   2859a:	f7e9 fd71 	bl	12080 <strlen>
   2859e:	4286      	cmp	r6, r0
   285a0:	f47f aed9 	bne.w	28356 <pdn_interface_pdn_id_get+0x86>
   285a4:	6a21      	ldr	r1, [r4, #32]
   285a6:	4628      	mov	r0, r5
   285a8:	310c      	adds	r1, #12
   285aa:	f7e9 fd5f 	bl	1206c <strcmp>
   285ae:	e6d2      	b.n	28356 <pdn_interface_pdn_id_get+0x86>
   285b0:	4628      	mov	r0, r5
   285b2:	f7e9 fd65 	bl	12080 <strlen>
   285b6:	4606      	mov	r6, r0
   285b8:	69e0      	ldr	r0, [r4, #28]
   285ba:	300c      	adds	r0, #12
   285bc:	f7e9 fd60 	bl	12080 <strlen>
   285c0:	4286      	cmp	r6, r0
   285c2:	f47f aec2 	bne.w	2834a <pdn_interface_pdn_id_get+0x7a>
   285c6:	69e1      	ldr	r1, [r4, #28]
   285c8:	4628      	mov	r0, r5
   285ca:	310c      	adds	r1, #12
   285cc:	f7e9 fd4e 	bl	1206c <strcmp>
   285d0:	e6bb      	b.n	2834a <pdn_interface_pdn_id_get+0x7a>
   285d2:	4628      	mov	r0, r5
   285d4:	f7e9 fd54 	bl	12080 <strlen>
   285d8:	4606      	mov	r6, r0
   285da:	69a0      	ldr	r0, [r4, #24]
   285dc:	300c      	adds	r0, #12
   285de:	f7e9 fd4f 	bl	12080 <strlen>
   285e2:	4286      	cmp	r6, r0
   285e4:	f47f aeab 	bne.w	2833e <pdn_interface_pdn_id_get+0x6e>
   285e8:	69a1      	ldr	r1, [r4, #24]
   285ea:	4628      	mov	r0, r5
   285ec:	310c      	adds	r1, #12
   285ee:	f7e9 fd3d 	bl	1206c <strcmp>
   285f2:	e6a4      	b.n	2833e <pdn_interface_pdn_id_get+0x6e>
   285f4:	4628      	mov	r0, r5
   285f6:	f7e9 fd43 	bl	12080 <strlen>
   285fa:	4606      	mov	r6, r0
   285fc:	6960      	ldr	r0, [r4, #20]
   285fe:	300c      	adds	r0, #12
   28600:	f7e9 fd3e 	bl	12080 <strlen>
   28604:	4286      	cmp	r6, r0
   28606:	f47f ae94 	bne.w	28332 <pdn_interface_pdn_id_get+0x62>
   2860a:	6961      	ldr	r1, [r4, #20]
   2860c:	4628      	mov	r0, r5
   2860e:	310c      	adds	r1, #12
   28610:	f7e9 fd2c 	bl	1206c <strcmp>
   28614:	e68d      	b.n	28332 <pdn_interface_pdn_id_get+0x62>
   28616:	4628      	mov	r0, r5
   28618:	f7e9 fd32 	bl	12080 <strlen>
   2861c:	4607      	mov	r7, r0
   2861e:	68e0      	ldr	r0, [r4, #12]
   28620:	300c      	adds	r0, #12
   28622:	f7e9 fd2d 	bl	12080 <strlen>
   28626:	4287      	cmp	r7, r0
   28628:	f47f af09 	bne.w	2843e <pdn_interface_pdn_id_get+0x16e>
   2862c:	68e1      	ldr	r1, [r4, #12]
   2862e:	4628      	mov	r0, r5
   28630:	310c      	adds	r1, #12
   28632:	f7e9 fd1b 	bl	1206c <strcmp>
   28636:	2800      	cmp	r0, #0
   28638:	f47f af01 	bne.w	2843e <pdn_interface_pdn_id_get+0x16e>
   2863c:	68e3      	ldr	r3, [r4, #12]
   2863e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28640:	07d1      	lsls	r1, r2, #31
   28642:	f57f aefc 	bpl.w	2843e <pdn_interface_pdn_id_get+0x16e>
   28646:	6858      	ldr	r0, [r3, #4]
   28648:	1c43      	adds	r3, r0, #1
   2864a:	f47f ae8c 	bne.w	28366 <pdn_interface_pdn_id_get+0x96>
   2864e:	4dc6      	ldr	r5, [pc, #792]	; (28968 <pdn_interface_pdn_id_get+0x698>)
   28650:	4ac6      	ldr	r2, [pc, #792]	; (2896c <pdn_interface_pdn_id_get+0x69c>)
   28652:	f44f 7180 	mov.w	r1, #256	; 0x100
   28656:	4628      	mov	r0, r5
   28658:	f009 fb12 	bl	31c80 <sniprintf>
   2865c:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   28660:	f5c0 7180 	rsb	r1, r0, #256	; 0x100
   28664:	681b      	ldr	r3, [r3, #0]
   28666:	4ac2      	ldr	r2, [pc, #776]	; (28970 <pdn_interface_pdn_id_get+0x6a0>)
   28668:	4428      	add	r0, r5
   2866a:	f8df 830c 	ldr.w	r8, [pc, #780]	; 28978 <pdn_interface_pdn_id_get+0x6a8>
   2866e:	f009 fb07 	bl	31c80 <sniprintf>
   28672:	4628      	mov	r0, r5
   28674:	f8d8 9000 	ldr.w	r9, [r8]
   28678:	2700      	movs	r7, #0
   2867a:	f7e9 fd01 	bl	12080 <strlen>
   2867e:	4629      	mov	r1, r5
   28680:	4602      	mov	r2, r0
   28682:	463b      	mov	r3, r7
   28684:	4648      	mov	r0, r9
   28686:	9701      	str	r7, [sp, #4]
   28688:	9700      	str	r7, [sp, #0]
   2868a:	f7fe fef9 	bl	27480 <at_interface_write>
   2868e:	4681      	mov	r9, r0
   28690:	4628      	mov	r0, r5
   28692:	f7e9 fcf5 	bl	12080 <strlen>
   28696:	4548      	cmp	r0, r9
   28698:	f040 81e9 	bne.w	28a6e <pdn_interface_pdn_id_get+0x79e>
   2869c:	463b      	mov	r3, r7
   2869e:	f44f 7280 	mov.w	r2, #256	; 0x100
   286a2:	e9cd 7700 	strd	r7, r7, [sp]
   286a6:	4629      	mov	r1, r5
   286a8:	f8d8 0000 	ldr.w	r0, [r8]
   286ac:	f7ff f83c 	bl	27728 <at_interface_read>
   286b0:	4607      	mov	r7, r0
   286b2:	48b0      	ldr	r0, [pc, #704]	; (28974 <pdn_interface_pdn_id_get+0x6a4>)
   286b4:	f7e9 fce4 	bl	12080 <strlen>
   286b8:	4287      	cmp	r7, r0
   286ba:	4602      	mov	r2, r0
   286bc:	f2c0 81c7 	blt.w	28a4e <pdn_interface_pdn_id_get+0x77e>
   286c0:	4629      	mov	r1, r5
   286c2:	48ac      	ldr	r0, [pc, #688]	; (28974 <pdn_interface_pdn_id_get+0x6a4>)
   286c4:	f010 fe1e 	bl	39304 <strncmp>
   286c8:	2800      	cmp	r0, #0
   286ca:	f040 81c0 	bne.w	28a4e <pdn_interface_pdn_id_get+0x77e>
   286ce:	4629      	mov	r1, r5
   286d0:	4630      	mov	r0, r6
   286d2:	f7ff f91d 	bl	27910 <pdn_id_get_parser>
   286d6:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   286da:	6858      	ldr	r0, [r3, #4]
   286dc:	e643      	b.n	28366 <pdn_interface_pdn_id_get+0x96>
   286de:	4628      	mov	r0, r5
   286e0:	f7e9 fcce 	bl	12080 <strlen>
   286e4:	4606      	mov	r6, r0
   286e6:	6920      	ldr	r0, [r4, #16]
   286e8:	300c      	adds	r0, #12
   286ea:	f7e9 fcc9 	bl	12080 <strlen>
   286ee:	4286      	cmp	r6, r0
   286f0:	f47f aeab 	bne.w	2844a <pdn_interface_pdn_id_get+0x17a>
   286f4:	6921      	ldr	r1, [r4, #16]
   286f6:	4628      	mov	r0, r5
   286f8:	310c      	adds	r1, #12
   286fa:	f7e9 fcb7 	bl	1206c <strcmp>
   286fe:	2800      	cmp	r0, #0
   28700:	f47f aea3 	bne.w	2844a <pdn_interface_pdn_id_get+0x17a>
   28704:	6923      	ldr	r3, [r4, #16]
   28706:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28708:	07d2      	lsls	r2, r2, #31
   2870a:	f57f ae9e 	bpl.w	2844a <pdn_interface_pdn_id_get+0x17a>
   2870e:	2604      	movs	r6, #4
   28710:	e799      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   28712:	4628      	mov	r0, r5
   28714:	f7e9 fcb4 	bl	12080 <strlen>
   28718:	4606      	mov	r6, r0
   2871a:	6960      	ldr	r0, [r4, #20]
   2871c:	300c      	adds	r0, #12
   2871e:	f7e9 fcaf 	bl	12080 <strlen>
   28722:	4286      	cmp	r6, r0
   28724:	f47f ae97 	bne.w	28456 <pdn_interface_pdn_id_get+0x186>
   28728:	6961      	ldr	r1, [r4, #20]
   2872a:	4628      	mov	r0, r5
   2872c:	310c      	adds	r1, #12
   2872e:	f7e9 fc9d 	bl	1206c <strcmp>
   28732:	2800      	cmp	r0, #0
   28734:	f47f ae8f 	bne.w	28456 <pdn_interface_pdn_id_get+0x186>
   28738:	6963      	ldr	r3, [r4, #20]
   2873a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2873c:	07d7      	lsls	r7, r2, #31
   2873e:	f57f ae8a 	bpl.w	28456 <pdn_interface_pdn_id_get+0x186>
   28742:	2605      	movs	r6, #5
   28744:	e77f      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   28746:	4628      	mov	r0, r5
   28748:	f7e9 fc9a 	bl	12080 <strlen>
   2874c:	4606      	mov	r6, r0
   2874e:	69a0      	ldr	r0, [r4, #24]
   28750:	300c      	adds	r0, #12
   28752:	f7e9 fc95 	bl	12080 <strlen>
   28756:	4286      	cmp	r6, r0
   28758:	f47f ae83 	bne.w	28462 <pdn_interface_pdn_id_get+0x192>
   2875c:	69a1      	ldr	r1, [r4, #24]
   2875e:	4628      	mov	r0, r5
   28760:	310c      	adds	r1, #12
   28762:	f7e9 fc83 	bl	1206c <strcmp>
   28766:	2800      	cmp	r0, #0
   28768:	f47f ae7b 	bne.w	28462 <pdn_interface_pdn_id_get+0x192>
   2876c:	69a3      	ldr	r3, [r4, #24]
   2876e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28770:	07d6      	lsls	r6, r2, #31
   28772:	f57f ae76 	bpl.w	28462 <pdn_interface_pdn_id_get+0x192>
   28776:	2606      	movs	r6, #6
   28778:	e765      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   2877a:	4628      	mov	r0, r5
   2877c:	f7e9 fc80 	bl	12080 <strlen>
   28780:	4607      	mov	r7, r0
   28782:	68e0      	ldr	r0, [r4, #12]
   28784:	300c      	adds	r0, #12
   28786:	f7e9 fc7b 	bl	12080 <strlen>
   2878a:	4287      	cmp	r7, r0
   2878c:	f47f ae05 	bne.w	2839a <pdn_interface_pdn_id_get+0xca>
   28790:	68e1      	ldr	r1, [r4, #12]
   28792:	4628      	mov	r0, r5
   28794:	310c      	adds	r1, #12
   28796:	f7e9 fc69 	bl	1206c <strcmp>
   2879a:	2800      	cmp	r0, #0
   2879c:	f47f adfd 	bne.w	2839a <pdn_interface_pdn_id_get+0xca>
   287a0:	68e3      	ldr	r3, [r4, #12]
   287a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   287a4:	0791      	lsls	r1, r2, #30
   287a6:	f53f af4e 	bmi.w	28646 <pdn_interface_pdn_id_get+0x376>
   287aa:	e5f6      	b.n	2839a <pdn_interface_pdn_id_get+0xca>
   287ac:	4628      	mov	r0, r5
   287ae:	f7e9 fc67 	bl	12080 <strlen>
   287b2:	4606      	mov	r6, r0
   287b4:	6920      	ldr	r0, [r4, #16]
   287b6:	300c      	adds	r0, #12
   287b8:	f7e9 fc62 	bl	12080 <strlen>
   287bc:	4286      	cmp	r6, r0
   287be:	f47f adf2 	bne.w	283a6 <pdn_interface_pdn_id_get+0xd6>
   287c2:	6921      	ldr	r1, [r4, #16]
   287c4:	4628      	mov	r0, r5
   287c6:	310c      	adds	r1, #12
   287c8:	f7e9 fc50 	bl	1206c <strcmp>
   287cc:	2800      	cmp	r0, #0
   287ce:	f47f adea 	bne.w	283a6 <pdn_interface_pdn_id_get+0xd6>
   287d2:	6923      	ldr	r3, [r4, #16]
   287d4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   287d6:	0792      	lsls	r2, r2, #30
   287d8:	d499      	bmi.n	2870e <pdn_interface_pdn_id_get+0x43e>
   287da:	e5e4      	b.n	283a6 <pdn_interface_pdn_id_get+0xd6>
   287dc:	4628      	mov	r0, r5
   287de:	f7e9 fc4f 	bl	12080 <strlen>
   287e2:	4606      	mov	r6, r0
   287e4:	6960      	ldr	r0, [r4, #20]
   287e6:	300c      	adds	r0, #12
   287e8:	f7e9 fc4a 	bl	12080 <strlen>
   287ec:	4286      	cmp	r6, r0
   287ee:	f47f ade0 	bne.w	283b2 <pdn_interface_pdn_id_get+0xe2>
   287f2:	6961      	ldr	r1, [r4, #20]
   287f4:	4628      	mov	r0, r5
   287f6:	310c      	adds	r1, #12
   287f8:	f7e9 fc38 	bl	1206c <strcmp>
   287fc:	2800      	cmp	r0, #0
   287fe:	f47f add8 	bne.w	283b2 <pdn_interface_pdn_id_get+0xe2>
   28802:	6963      	ldr	r3, [r4, #20]
   28804:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28806:	0797      	lsls	r7, r2, #30
   28808:	d49b      	bmi.n	28742 <pdn_interface_pdn_id_get+0x472>
   2880a:	e5d2      	b.n	283b2 <pdn_interface_pdn_id_get+0xe2>
   2880c:	4628      	mov	r0, r5
   2880e:	f7e9 fc37 	bl	12080 <strlen>
   28812:	4606      	mov	r6, r0
   28814:	69a0      	ldr	r0, [r4, #24]
   28816:	300c      	adds	r0, #12
   28818:	f7e9 fc32 	bl	12080 <strlen>
   2881c:	4286      	cmp	r6, r0
   2881e:	f47f adce 	bne.w	283be <pdn_interface_pdn_id_get+0xee>
   28822:	69a1      	ldr	r1, [r4, #24]
   28824:	4628      	mov	r0, r5
   28826:	310c      	adds	r1, #12
   28828:	f7e9 fc20 	bl	1206c <strcmp>
   2882c:	2800      	cmp	r0, #0
   2882e:	f47f adc6 	bne.w	283be <pdn_interface_pdn_id_get+0xee>
   28832:	69a3      	ldr	r3, [r4, #24]
   28834:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28836:	0796      	lsls	r6, r2, #30
   28838:	d49d      	bmi.n	28776 <pdn_interface_pdn_id_get+0x4a6>
   2883a:	e5c0      	b.n	283be <pdn_interface_pdn_id_get+0xee>
   2883c:	4628      	mov	r0, r5
   2883e:	f7e9 fc1f 	bl	12080 <strlen>
   28842:	4606      	mov	r6, r0
   28844:	69e0      	ldr	r0, [r4, #28]
   28846:	300c      	adds	r0, #12
   28848:	f7e9 fc1a 	bl	12080 <strlen>
   2884c:	4286      	cmp	r6, r0
   2884e:	f47f adbc 	bne.w	283ca <pdn_interface_pdn_id_get+0xfa>
   28852:	69e1      	ldr	r1, [r4, #28]
   28854:	4628      	mov	r0, r5
   28856:	310c      	adds	r1, #12
   28858:	f7e9 fc08 	bl	1206c <strcmp>
   2885c:	2800      	cmp	r0, #0
   2885e:	f47f adb4 	bne.w	283ca <pdn_interface_pdn_id_get+0xfa>
   28862:	69e3      	ldr	r3, [r4, #28]
   28864:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28866:	0790      	lsls	r0, r2, #30
   28868:	f57f adaf 	bpl.w	283ca <pdn_interface_pdn_id_get+0xfa>
   2886c:	2607      	movs	r6, #7
   2886e:	e6ea      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   28870:	4628      	mov	r0, r5
   28872:	f7e9 fc05 	bl	12080 <strlen>
   28876:	4606      	mov	r6, r0
   28878:	6a20      	ldr	r0, [r4, #32]
   2887a:	300c      	adds	r0, #12
   2887c:	f7e9 fc00 	bl	12080 <strlen>
   28880:	4286      	cmp	r6, r0
   28882:	f47f ada8 	bne.w	283d6 <pdn_interface_pdn_id_get+0x106>
   28886:	6a21      	ldr	r1, [r4, #32]
   28888:	4628      	mov	r0, r5
   2888a:	310c      	adds	r1, #12
   2888c:	f7e9 fbee 	bl	1206c <strcmp>
   28890:	2800      	cmp	r0, #0
   28892:	f47f ada0 	bne.w	283d6 <pdn_interface_pdn_id_get+0x106>
   28896:	6a23      	ldr	r3, [r4, #32]
   28898:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2889a:	0791      	lsls	r1, r2, #30
   2889c:	f57f ad9b 	bpl.w	283d6 <pdn_interface_pdn_id_get+0x106>
   288a0:	2608      	movs	r6, #8
   288a2:	e6d0      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   288a4:	4628      	mov	r0, r5
   288a6:	f7e9 fbeb 	bl	12080 <strlen>
   288aa:	4606      	mov	r6, r0
   288ac:	69e0      	ldr	r0, [r4, #28]
   288ae:	300c      	adds	r0, #12
   288b0:	f7e9 fbe6 	bl	12080 <strlen>
   288b4:	4286      	cmp	r6, r0
   288b6:	f47f adda 	bne.w	2846e <pdn_interface_pdn_id_get+0x19e>
   288ba:	69e1      	ldr	r1, [r4, #28]
   288bc:	4628      	mov	r0, r5
   288be:	310c      	adds	r1, #12
   288c0:	f7e9 fbd4 	bl	1206c <strcmp>
   288c4:	2800      	cmp	r0, #0
   288c6:	f47f add2 	bne.w	2846e <pdn_interface_pdn_id_get+0x19e>
   288ca:	69e3      	ldr	r3, [r4, #28]
   288cc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   288ce:	07d0      	lsls	r0, r2, #31
   288d0:	d4cc      	bmi.n	2886c <pdn_interface_pdn_id_get+0x59c>
   288d2:	e5cc      	b.n	2846e <pdn_interface_pdn_id_get+0x19e>
   288d4:	4628      	mov	r0, r5
   288d6:	f7e9 fbd3 	bl	12080 <strlen>
   288da:	4606      	mov	r6, r0
   288dc:	6a20      	ldr	r0, [r4, #32]
   288de:	300c      	adds	r0, #12
   288e0:	f7e9 fbce 	bl	12080 <strlen>
   288e4:	4286      	cmp	r6, r0
   288e6:	f47f adc8 	bne.w	2847a <pdn_interface_pdn_id_get+0x1aa>
   288ea:	6a21      	ldr	r1, [r4, #32]
   288ec:	4628      	mov	r0, r5
   288ee:	310c      	adds	r1, #12
   288f0:	f7e9 fbbc 	bl	1206c <strcmp>
   288f4:	2800      	cmp	r0, #0
   288f6:	f47f adc0 	bne.w	2847a <pdn_interface_pdn_id_get+0x1aa>
   288fa:	6a23      	ldr	r3, [r4, #32]
   288fc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   288fe:	07d1      	lsls	r1, r2, #31
   28900:	d4ce      	bmi.n	288a0 <pdn_interface_pdn_id_get+0x5d0>
   28902:	e5ba      	b.n	2847a <pdn_interface_pdn_id_get+0x1aa>
   28904:	4628      	mov	r0, r5
   28906:	f7e9 fbbb 	bl	12080 <strlen>
   2890a:	4606      	mov	r6, r0
   2890c:	68a0      	ldr	r0, [r4, #8]
   2890e:	300c      	adds	r0, #12
   28910:	f7e9 fbb6 	bl	12080 <strlen>
   28914:	4286      	cmp	r6, r0
   28916:	f47f ad8c 	bne.w	28432 <pdn_interface_pdn_id_get+0x162>
   2891a:	68a1      	ldr	r1, [r4, #8]
   2891c:	4628      	mov	r0, r5
   2891e:	310c      	adds	r1, #12
   28920:	f7e9 fba4 	bl	1206c <strcmp>
   28924:	2800      	cmp	r0, #0
   28926:	f47f ad84 	bne.w	28432 <pdn_interface_pdn_id_get+0x162>
   2892a:	68a3      	ldr	r3, [r4, #8]
   2892c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   2892e:	07d0      	lsls	r0, r2, #31
   28930:	f57f ad7f 	bpl.w	28432 <pdn_interface_pdn_id_get+0x162>
   28934:	2602      	movs	r6, #2
   28936:	e686      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   28938:	4628      	mov	r0, r5
   2893a:	f7e9 fba1 	bl	12080 <strlen>
   2893e:	4606      	mov	r6, r0
   28940:	68a0      	ldr	r0, [r4, #8]
   28942:	300c      	adds	r0, #12
   28944:	f7e9 fb9c 	bl	12080 <strlen>
   28948:	4286      	cmp	r6, r0
   2894a:	f47f ad20 	bne.w	2838e <pdn_interface_pdn_id_get+0xbe>
   2894e:	68a1      	ldr	r1, [r4, #8]
   28950:	4628      	mov	r0, r5
   28952:	310c      	adds	r1, #12
   28954:	f7e9 fb8a 	bl	1206c <strcmp>
   28958:	2800      	cmp	r0, #0
   2895a:	f47f ad18 	bne.w	2838e <pdn_interface_pdn_id_get+0xbe>
   2895e:	68a3      	ldr	r3, [r4, #8]
   28960:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28962:	0790      	lsls	r0, r2, #30
   28964:	d4e6      	bmi.n	28934 <pdn_interface_pdn_id_get+0x664>
   28966:	e512      	b.n	2838e <pdn_interface_pdn_id_get+0xbe>
   28968:	200227b8 	.word	0x200227b8
   2896c:	0003a9f8 	.word	0x0003a9f8
   28970:	0003a9f4 	.word	0x0003a9f4
   28974:	0003aa08 	.word	0x0003aa08
   28978:	200227b4 	.word	0x200227b4
   2897c:	4628      	mov	r0, r5
   2897e:	f7e9 fb7f 	bl	12080 <strlen>
   28982:	4606      	mov	r6, r0
   28984:	6860      	ldr	r0, [r4, #4]
   28986:	300c      	adds	r0, #12
   28988:	f7e9 fb7a 	bl	12080 <strlen>
   2898c:	4286      	cmp	r6, r0
   2898e:	f47f acf8 	bne.w	28382 <pdn_interface_pdn_id_get+0xb2>
   28992:	6861      	ldr	r1, [r4, #4]
   28994:	4628      	mov	r0, r5
   28996:	310c      	adds	r1, #12
   28998:	f7e9 fb68 	bl	1206c <strcmp>
   2899c:	2800      	cmp	r0, #0
   2899e:	f47f acf0 	bne.w	28382 <pdn_interface_pdn_id_get+0xb2>
   289a2:	6863      	ldr	r3, [r4, #4]
   289a4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   289a6:	0796      	lsls	r6, r2, #30
   289a8:	f57f aceb 	bpl.w	28382 <pdn_interface_pdn_id_get+0xb2>
   289ac:	2601      	movs	r6, #1
   289ae:	e64a      	b.n	28646 <pdn_interface_pdn_id_get+0x376>
   289b0:	4628      	mov	r0, r5
   289b2:	f7e9 fb65 	bl	12080 <strlen>
   289b6:	4606      	mov	r6, r0
   289b8:	6860      	ldr	r0, [r4, #4]
   289ba:	300c      	adds	r0, #12
   289bc:	f7e9 fb60 	bl	12080 <strlen>
   289c0:	4286      	cmp	r6, r0
   289c2:	f47f ad30 	bne.w	28426 <pdn_interface_pdn_id_get+0x156>
   289c6:	6861      	ldr	r1, [r4, #4]
   289c8:	4628      	mov	r0, r5
   289ca:	310c      	adds	r1, #12
   289cc:	f7e9 fb4e 	bl	1206c <strcmp>
   289d0:	2800      	cmp	r0, #0
   289d2:	f47f ad28 	bne.w	28426 <pdn_interface_pdn_id_get+0x156>
   289d6:	6863      	ldr	r3, [r4, #4]
   289d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   289da:	07d6      	lsls	r6, r2, #31
   289dc:	d4e6      	bmi.n	289ac <pdn_interface_pdn_id_get+0x6dc>
   289de:	e522      	b.n	28426 <pdn_interface_pdn_id_get+0x156>
   289e0:	4608      	mov	r0, r1
   289e2:	f7e9 fb4d 	bl	12080 <strlen>
   289e6:	4606      	mov	r6, r0
   289e8:	6820      	ldr	r0, [r4, #0]
   289ea:	300c      	adds	r0, #12
   289ec:	f7e9 fb48 	bl	12080 <strlen>
   289f0:	4286      	cmp	r6, r0
   289f2:	f47f acc0 	bne.w	28376 <pdn_interface_pdn_id_get+0xa6>
   289f6:	6821      	ldr	r1, [r4, #0]
   289f8:	4628      	mov	r0, r5
   289fa:	310c      	adds	r1, #12
   289fc:	f7e9 fb36 	bl	1206c <strcmp>
   28a00:	4606      	mov	r6, r0
   28a02:	2800      	cmp	r0, #0
   28a04:	f47f acb7 	bne.w	28376 <pdn_interface_pdn_id_get+0xa6>
   28a08:	6823      	ldr	r3, [r4, #0]
   28a0a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28a0c:	0797      	lsls	r7, r2, #30
   28a0e:	f53f ae1a 	bmi.w	28646 <pdn_interface_pdn_id_get+0x376>
   28a12:	e4b0      	b.n	28376 <pdn_interface_pdn_id_get+0xa6>
   28a14:	4608      	mov	r0, r1
   28a16:	f7e9 fb33 	bl	12080 <strlen>
   28a1a:	4606      	mov	r6, r0
   28a1c:	6820      	ldr	r0, [r4, #0]
   28a1e:	300c      	adds	r0, #12
   28a20:	f7e9 fb2e 	bl	12080 <strlen>
   28a24:	4286      	cmp	r6, r0
   28a26:	f47f acf8 	bne.w	2841a <pdn_interface_pdn_id_get+0x14a>
   28a2a:	6821      	ldr	r1, [r4, #0]
   28a2c:	4628      	mov	r0, r5
   28a2e:	310c      	adds	r1, #12
   28a30:	f7e9 fb1c 	bl	1206c <strcmp>
   28a34:	4606      	mov	r6, r0
   28a36:	2800      	cmp	r0, #0
   28a38:	f47f acef 	bne.w	2841a <pdn_interface_pdn_id_get+0x14a>
   28a3c:	6823      	ldr	r3, [r4, #0]
   28a3e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   28a40:	07d7      	lsls	r7, r2, #31
   28a42:	f53f ae00 	bmi.w	28646 <pdn_interface_pdn_id_get+0x376>
   28a46:	e4e8      	b.n	2841a <pdn_interface_pdn_id_get+0x14a>
   28a48:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28a4c:	4770      	bx	lr
   28a4e:	480b      	ldr	r0, [pc, #44]	; (28a7c <pdn_interface_pdn_id_get+0x7ac>)
   28a50:	f7e9 fb16 	bl	12080 <strlen>
   28a54:	490a      	ldr	r1, [pc, #40]	; (28a80 <pdn_interface_pdn_id_get+0x7b0>)
   28a56:	4602      	mov	r2, r0
   28a58:	4808      	ldr	r0, [pc, #32]	; (28a7c <pdn_interface_pdn_id_get+0x7ac>)
   28a5a:	f010 fc53 	bl	39304 <strncmp>
   28a5e:	b930      	cbnz	r0, 28a6e <pdn_interface_pdn_id_get+0x79e>
   28a60:	2008      	movs	r0, #8
   28a62:	f7f7 fafd 	bl	20060 <bsd_os_errno_set>
   28a66:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   28a6a:	6858      	ldr	r0, [r3, #4]
   28a6c:	e47b      	b.n	28366 <pdn_interface_pdn_id_get+0x96>
   28a6e:	2005      	movs	r0, #5
   28a70:	f7f7 faf6 	bl	20060 <bsd_os_errno_set>
   28a74:	f854 3026 	ldr.w	r3, [r4, r6, lsl #2]
   28a78:	6858      	ldr	r0, [r3, #4]
   28a7a:	e474      	b.n	28366 <pdn_interface_pdn_id_get+0x96>
   28a7c:	0003aa4c 	.word	0x0003aa4c
   28a80:	200227b8 	.word	0x200227b8

00028a84 <bsd_recoverable_error_handler>:
   28a84:	4770      	bx	lr
   28a86:	bf00      	nop

00028a88 <bsd_platform_error_handler>:
   28a88:	b508      	push	{r3, lr}
   28a8a:	f7ff fffb 	bl	28a84 <bsd_recoverable_error_handler>
   28a8e:	bd08      	pop	{r3, pc}

00028a90 <bsd_init>:
   28a90:	b160      	cbz	r0, 28aac <bsd_init+0x1c>
   28a92:	b510      	push	{r4, lr}
   28a94:	4c07      	ldr	r4, [pc, #28]	; (28ab4 <bsd_init+0x24>)
   28a96:	7823      	ldrb	r3, [r4, #0]
   28a98:	b92b      	cbnz	r3, 28aa6 <bsd_init+0x16>
   28a9a:	f000 f81b 	bl	28ad4 <bsd_platform_init>
   28a9e:	b908      	cbnz	r0, 28aa4 <bsd_init+0x14>
   28aa0:	2301      	movs	r3, #1
   28aa2:	7023      	strb	r3, [r4, #0]
   28aa4:	bd10      	pop	{r4, pc}
   28aa6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28aaa:	bd10      	pop	{r4, pc}
   28aac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28ab0:	4770      	bx	lr
   28ab2:	bf00      	nop
   28ab4:	2002908b 	.word	0x2002908b

00028ab8 <unimplemented_method>:
   28ab8:	b40f      	push	{r0, r1, r2, r3}
   28aba:	b508      	push	{r3, lr}
   28abc:	202d      	movs	r0, #45	; 0x2d
   28abe:	f7f7 facf 	bl	20060 <bsd_os_errno_set>
   28ac2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   28ac6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28aca:	b004      	add	sp, #16
   28acc:	4770      	bx	lr
   28ace:	bf00      	nop

00028ad0 <rpc_transport_ipc_fault_handler>:
   28ad0:	f7ff bfda 	b.w	28a88 <bsd_platform_error_handler>

00028ad4 <bsd_platform_init>:
   28ad4:	b5f0      	push	{r4, r5, r6, r7, lr}
   28ad6:	f04f 0c00 	mov.w	ip, #0
   28ada:	f247 0660 	movw	r6, #28768	; 0x7060
   28ade:	f24b 0260 	movw	r2, #45152	; 0xb060
   28ae2:	6843      	ldr	r3, [r0, #4]
   28ae4:	4d3a      	ldr	r5, [pc, #232]	; (28bd0 <bsd_platform_init+0xfc>)
   28ae6:	4607      	mov	r7, r0
   28ae8:	602b      	str	r3, [r5, #0]
   28aea:	7801      	ldrb	r1, [r0, #0]
   28aec:	2006      	movs	r0, #6
   28aee:	4561      	cmp	r1, ip
   28af0:	bf08      	it	eq
   28af2:	4632      	moveq	r2, r6
   28af4:	4413      	add	r3, r2
   28af6:	4c37      	ldr	r4, [pc, #220]	; (28bd4 <bsd_platform_init+0x100>)
   28af8:	60ab      	str	r3, [r5, #8]
   28afa:	68b9      	ldr	r1, [r7, #8]
   28afc:	6063      	str	r3, [r4, #4]
   28afe:	4b36      	ldr	r3, [pc, #216]	; (28bd8 <bsd_platform_init+0x104>)
   28b00:	b093      	sub	sp, #76	; 0x4c
   28b02:	606a      	str	r2, [r5, #4]
   28b04:	f8a4 c000 	strh.w	ip, [r4]
   28b08:	1a8a      	subs	r2, r1, r2
   28b0a:	60ea      	str	r2, [r5, #12]
   28b0c:	60a2      	str	r2, [r4, #8]
   28b0e:	81a0      	strh	r0, [r4, #12]
   28b10:	6123      	str	r3, [r4, #16]
   28b12:	f001 f883 	bl	29c1c <nrf_mem_init>
   28b16:	2800      	cmp	r0, #0
   28b18:	d156      	bne.n	28bc8 <bsd_platform_init+0xf4>
   28b1a:	4621      	mov	r1, r4
   28b1c:	a801      	add	r0, sp, #4
   28b1e:	f001 f8f1 	bl	29d04 <nrf_mem_register>
   28b22:	2800      	cmp	r0, #0
   28b24:	d150      	bne.n	28bc8 <bsd_platform_init+0xf4>
   28b26:	f7f7 fbb3 	bl	20290 <bsd_os_init>
   28b2a:	f7fd fc53 	bl	263d4 <rpc_framework_init>
   28b2e:	2800      	cmp	r0, #0
   28b30:	d14a      	bne.n	28bc8 <bsd_platform_init+0xf4>
   28b32:	783a      	ldrb	r2, [r7, #0]
   28b34:	682b      	ldr	r3, [r5, #0]
   28b36:	bb32      	cbnz	r2, 28b86 <bsd_platform_init+0xb2>
   28b38:	4606      	mov	r6, r0
   28b3a:	2220      	movs	r2, #32
   28b3c:	2408      	movs	r4, #8
   28b3e:	2500      	movs	r5, #0
   28b40:	f44f 5c40 	mov.w	ip, #12288	; 0x3000
   28b44:	f44f 4780 	mov.w	r7, #16384	; 0x4000
   28b48:	f503 5141 	add.w	r1, r3, #12352	; 0x3040
   28b4c:	4411      	add	r1, r2
   28b4e:	9302      	str	r3, [sp, #8]
   28b50:	e9cd 6008 	strd	r6, r0, [sp, #32]
   28b54:	910c      	str	r1, [sp, #48]	; 0x30
   28b56:	9203      	str	r2, [sp, #12]
   28b58:	f103 0140 	add.w	r1, r3, #64	; 0x40
   28b5c:	9205      	str	r2, [sp, #20]
   28b5e:	9207      	str	r2, [sp, #28]
   28b60:	eb0d 0004 	add.w	r0, sp, r4
   28b64:	189a      	adds	r2, r3, r2
   28b66:	3360      	adds	r3, #96	; 0x60
   28b68:	e9cd 5510 	strd	r5, r5, [sp, #64]	; 0x40
   28b6c:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
   28b70:	e9cd 740d 	strd	r7, r4, [sp, #52]	; 0x34
   28b74:	940f      	str	r4, [sp, #60]	; 0x3c
   28b76:	9104      	str	r1, [sp, #16]
   28b78:	9206      	str	r2, [sp, #24]
   28b7a:	930a      	str	r3, [sp, #40]	; 0x28
   28b7c:	f7fa fafa 	bl	23174 <rpc_transport_ipc_init>
   28b80:	b128      	cbz	r0, 28b8e <bsd_platform_init+0xba>
   28b82:	b013      	add	sp, #76	; 0x4c
   28b84:	bdf0      	pop	{r4, r5, r6, r7, pc}
   28b86:	441e      	add	r6, r3
   28b88:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   28b8c:	e7d5      	b.n	28b3a <bsd_platform_init+0x66>
   28b8e:	f001 fcf9 	bl	2a584 <interface_init>
   28b92:	b9c8      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28b94:	f7fe fcf2 	bl	2757c <at_interface_init>
   28b98:	b9b0      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28b9a:	f7fb fe1d 	bl	247d8 <ip_interface_init>
   28b9e:	b998      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28ba0:	f7fb f8ba 	bl	23d18 <tls_interface_init>
   28ba4:	b980      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28ba6:	f001 fa09 	bl	29fbc <mfu_interface_init>
   28baa:	b968      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28bac:	f7fe ff08 	bl	279c0 <pdn_interface_init>
   28bb0:	b950      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28bb2:	f7fe fb39 	bl	27228 <gnss_interface_init>
   28bb6:	b938      	cbnz	r0, 28bc8 <bsd_platform_init+0xf4>
   28bb8:	f7f9 fd1a 	bl	225f0 <logobj_interface_init>
   28bbc:	1b40      	subs	r0, r0, r5
   28bbe:	bf18      	it	ne
   28bc0:	2001      	movne	r0, #1
   28bc2:	4240      	negs	r0, r0
   28bc4:	b013      	add	sp, #76	; 0x4c
   28bc6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   28bc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28bcc:	b013      	add	sp, #76	; 0x4c
   28bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
   28bd0:	200228f4 	.word	0x200228f4
   28bd4:	200228e0 	.word	0x200228e0
   28bd8:	0003aba0 	.word	0x0003aba0

00028bdc <bsd_platform_af_method_table_get>:
   28bdc:	2805      	cmp	r0, #5
   28bde:	d02a      	beq.n	28c36 <bsd_platform_af_method_table_get+0x5a>
   28be0:	b508      	push	{r3, lr}
   28be2:	d914      	bls.n	28c0e <bsd_platform_af_method_table_get+0x32>
   28be4:	280a      	cmp	r0, #10
   28be6:	d016      	beq.n	28c16 <bsd_platform_af_method_table_get+0x3a>
   28be8:	2866      	cmp	r0, #102	; 0x66
   28bea:	d11f      	bne.n	28c2c <bsd_platform_af_method_table_get+0x50>
   28bec:	f240 2302 	movw	r3, #514	; 0x202
   28bf0:	429a      	cmp	r2, r3
   28bf2:	d035      	beq.n	28c60 <bsd_platform_af_method_table_get+0x84>
   28bf4:	f240 2305 	movw	r3, #517	; 0x205
   28bf8:	429a      	cmp	r2, r3
   28bfa:	d035      	beq.n	28c68 <bsd_platform_af_method_table_get+0x8c>
   28bfc:	f240 2301 	movw	r3, #513	; 0x201
   28c00:	429a      	cmp	r2, r3
   28c02:	d02f      	beq.n	28c64 <bsd_platform_af_method_table_get+0x88>
   28c04:	202b      	movs	r0, #43	; 0x2b
   28c06:	f7f7 fa2b 	bl	20060 <bsd_os_errno_set>
   28c0a:	2000      	movs	r0, #0
   28c0c:	bd08      	pop	{r3, pc}
   28c0e:	2801      	cmp	r0, #1
   28c10:	d016      	beq.n	28c40 <bsd_platform_af_method_table_get+0x64>
   28c12:	2802      	cmp	r0, #2
   28c14:	d10a      	bne.n	28c2c <bsd_platform_af_method_table_get+0x50>
   28c16:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   28c1a:	d21a      	bcs.n	28c52 <bsd_platform_af_method_table_get+0x76>
   28c1c:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   28c20:	d21a      	bcs.n	28c58 <bsd_platform_af_method_table_get+0x7c>
   28c22:	3a01      	subs	r2, #1
   28c24:	2a01      	cmp	r2, #1
   28c26:	d8ed      	bhi.n	28c04 <bsd_platform_af_method_table_get+0x28>
   28c28:	4810      	ldr	r0, [pc, #64]	; (28c6c <bsd_platform_af_method_table_get+0x90>)
   28c2a:	bd08      	pop	{r3, pc}
   28c2c:	2016      	movs	r0, #22
   28c2e:	f7f7 fa17 	bl	20060 <bsd_os_errno_set>
   28c32:	2000      	movs	r0, #0
   28c34:	bd08      	pop	{r3, pc}
   28c36:	2903      	cmp	r1, #3
   28c38:	480d      	ldr	r0, [pc, #52]	; (28c70 <bsd_platform_af_method_table_get+0x94>)
   28c3a:	bf18      	it	ne
   28c3c:	2000      	movne	r0, #0
   28c3e:	4770      	bx	lr
   28c40:	f240 2303 	movw	r3, #515	; 0x203
   28c44:	429a      	cmp	r2, r3
   28c46:	d009      	beq.n	28c5c <bsd_platform_af_method_table_get+0x80>
   28c48:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   28c4c:	d1da      	bne.n	28c04 <bsd_platform_af_method_table_get+0x28>
   28c4e:	4809      	ldr	r0, [pc, #36]	; (28c74 <bsd_platform_af_method_table_get+0x98>)
   28c50:	bd08      	pop	{r3, pc}
   28c52:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   28c56:	d1d5      	bne.n	28c04 <bsd_platform_af_method_table_get+0x28>
   28c58:	4807      	ldr	r0, [pc, #28]	; (28c78 <bsd_platform_af_method_table_get+0x9c>)
   28c5a:	bd08      	pop	{r3, pc}
   28c5c:	4807      	ldr	r0, [pc, #28]	; (28c7c <bsd_platform_af_method_table_get+0xa0>)
   28c5e:	bd08      	pop	{r3, pc}
   28c60:	4807      	ldr	r0, [pc, #28]	; (28c80 <bsd_platform_af_method_table_get+0xa4>)
   28c62:	bd08      	pop	{r3, pc}
   28c64:	4807      	ldr	r0, [pc, #28]	; (28c84 <bsd_platform_af_method_table_get+0xa8>)
   28c66:	bd08      	pop	{r3, pc}
   28c68:	4807      	ldr	r0, [pc, #28]	; (28c88 <bsd_platform_af_method_table_get+0xac>)
   28c6a:	bd08      	pop	{r3, pc}
   28c6c:	0003aa88 	.word	0x0003aa88
   28c70:	0003ab78 	.word	0x0003ab78
   28c74:	0003ab28 	.word	0x0003ab28
   28c78:	0003aab0 	.word	0x0003aab0
   28c7c:	0003aad8 	.word	0x0003aad8
   28c80:	0003ab00 	.word	0x0003ab00
   28c84:	0003aa60 	.word	0x0003aa60
   28c88:	0003ab50 	.word	0x0003ab50

00028c8c <bsd_platform_fd_method_table_get>:
   28c8c:	b538      	push	{r3, r4, r5, lr}
   28c8e:	4605      	mov	r5, r0
   28c90:	f001 fdaa 	bl	2a7e8 <interface_socket_from_handle_get>
   28c94:	4604      	mov	r4, r0
   28c96:	b960      	cbnz	r0, 28cb2 <bsd_platform_fd_method_table_get+0x26>
   28c98:	4b2c      	ldr	r3, [pc, #176]	; (28d4c <bsd_platform_fd_method_table_get+0xc0>)
   28c9a:	429d      	cmp	r5, r3
   28c9c:	d02f      	beq.n	28cfe <bsd_platform_fd_method_table_get+0x72>
   28c9e:	0c2b      	lsrs	r3, r5, #16
   28ca0:	4a2b      	ldr	r2, [pc, #172]	; (28d50 <bsd_platform_fd_method_table_get+0xc4>)
   28ca2:	041b      	lsls	r3, r3, #16
   28ca4:	4293      	cmp	r3, r2
   28ca6:	d03d      	beq.n	28d24 <bsd_platform_fd_method_table_get+0x98>
   28ca8:	4b2a      	ldr	r3, [pc, #168]	; (28d54 <bsd_platform_fd_method_table_get+0xc8>)
   28caa:	429d      	cmp	r5, r3
   28cac:	d149      	bne.n	28d42 <bsd_platform_fd_method_table_get+0xb6>
   28cae:	482a      	ldr	r0, [pc, #168]	; (28d58 <bsd_platform_fd_method_table_get+0xcc>)
   28cb0:	bd38      	pop	{r3, r4, r5, pc}
   28cb2:	68c3      	ldr	r3, [r0, #12]
   28cb4:	6942      	ldr	r2, [r0, #20]
   28cb6:	2b05      	cmp	r3, #5
   28cb8:	d036      	beq.n	28d28 <bsd_platform_fd_method_table_get+0x9c>
   28cba:	d911      	bls.n	28ce0 <bsd_platform_fd_method_table_get+0x54>
   28cbc:	2b0a      	cmp	r3, #10
   28cbe:	d013      	beq.n	28ce8 <bsd_platform_fd_method_table_get+0x5c>
   28cc0:	2b66      	cmp	r3, #102	; 0x66
   28cc2:	d11e      	bne.n	28d02 <bsd_platform_fd_method_table_get+0x76>
   28cc4:	f240 2302 	movw	r3, #514	; 0x202
   28cc8:	429a      	cmp	r2, r3
   28cca:	d02b      	beq.n	28d24 <bsd_platform_fd_method_table_get+0x98>
   28ccc:	f240 2305 	movw	r3, #517	; 0x205
   28cd0:	429a      	cmp	r2, r3
   28cd2:	d02f      	beq.n	28d34 <bsd_platform_fd_method_table_get+0xa8>
   28cd4:	f240 2301 	movw	r3, #513	; 0x201
   28cd8:	429a      	cmp	r2, r3
   28cda:	d11e      	bne.n	28d1a <bsd_platform_fd_method_table_get+0x8e>
   28cdc:	481f      	ldr	r0, [pc, #124]	; (28d5c <bsd_platform_fd_method_table_get+0xd0>)
   28cde:	bd38      	pop	{r3, r4, r5, pc}
   28ce0:	2b01      	cmp	r3, #1
   28ce2:	d013      	beq.n	28d0c <bsd_platform_fd_method_table_get+0x80>
   28ce4:	2b02      	cmp	r3, #2
   28ce6:	d10c      	bne.n	28d02 <bsd_platform_fd_method_table_get+0x76>
   28ce8:	f5b2 7f83 	cmp.w	r2, #262	; 0x106
   28cec:	d224      	bcs.n	28d38 <bsd_platform_fd_method_table_get+0xac>
   28cee:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
   28cf2:	d224      	bcs.n	28d3e <bsd_platform_fd_method_table_get+0xb2>
   28cf4:	3a01      	subs	r2, #1
   28cf6:	2a01      	cmp	r2, #1
   28cf8:	d80f      	bhi.n	28d1a <bsd_platform_fd_method_table_get+0x8e>
   28cfa:	4819      	ldr	r0, [pc, #100]	; (28d60 <bsd_platform_fd_method_table_get+0xd4>)
   28cfc:	bd38      	pop	{r3, r4, r5, pc}
   28cfe:	4819      	ldr	r0, [pc, #100]	; (28d64 <bsd_platform_fd_method_table_get+0xd8>)
   28d00:	bd38      	pop	{r3, r4, r5, pc}
   28d02:	2016      	movs	r0, #22
   28d04:	f7f7 f9ac 	bl	20060 <bsd_os_errno_set>
   28d08:	2000      	movs	r0, #0
   28d0a:	bd38      	pop	{r3, r4, r5, pc}
   28d0c:	f240 2303 	movw	r3, #515	; 0x203
   28d10:	429a      	cmp	r2, r3
   28d12:	d0f4      	beq.n	28cfe <bsd_platform_fd_method_table_get+0x72>
   28d14:	f5b2 7f01 	cmp.w	r2, #516	; 0x204
   28d18:	d0c9      	beq.n	28cae <bsd_platform_fd_method_table_get+0x22>
   28d1a:	202b      	movs	r0, #43	; 0x2b
   28d1c:	f7f7 f9a0 	bl	20060 <bsd_os_errno_set>
   28d20:	2000      	movs	r0, #0
   28d22:	bd38      	pop	{r3, r4, r5, pc}
   28d24:	4810      	ldr	r0, [pc, #64]	; (28d68 <bsd_platform_fd_method_table_get+0xdc>)
   28d26:	bd38      	pop	{r3, r4, r5, pc}
   28d28:	6903      	ldr	r3, [r0, #16]
   28d2a:	4810      	ldr	r0, [pc, #64]	; (28d6c <bsd_platform_fd_method_table_get+0xe0>)
   28d2c:	2b03      	cmp	r3, #3
   28d2e:	bf18      	it	ne
   28d30:	2000      	movne	r0, #0
   28d32:	bd38      	pop	{r3, r4, r5, pc}
   28d34:	480e      	ldr	r0, [pc, #56]	; (28d70 <bsd_platform_fd_method_table_get+0xe4>)
   28d36:	bd38      	pop	{r3, r4, r5, pc}
   28d38:	f5b2 7f87 	cmp.w	r2, #270	; 0x10e
   28d3c:	d1ed      	bne.n	28d1a <bsd_platform_fd_method_table_get+0x8e>
   28d3e:	480d      	ldr	r0, [pc, #52]	; (28d74 <bsd_platform_fd_method_table_get+0xe8>)
   28d40:	bd38      	pop	{r3, r4, r5, pc}
   28d42:	2009      	movs	r0, #9
   28d44:	f7f7 f98c 	bl	20060 <bsd_os_errno_set>
   28d48:	4620      	mov	r0, r4
   28d4a:	bd38      	pop	{r3, r4, r5, pc}
   28d4c:	49765432 	.word	0x49765432
   28d50:	789a0000 	.word	0x789a0000
   28d54:	49765443 	.word	0x49765443
   28d58:	0003ab28 	.word	0x0003ab28
   28d5c:	0003aa60 	.word	0x0003aa60
   28d60:	0003aa88 	.word	0x0003aa88
   28d64:	0003aad8 	.word	0x0003aad8
   28d68:	0003ab00 	.word	0x0003ab00
   28d6c:	0003ab78 	.word	0x0003ab78
   28d70:	0003ab50 	.word	0x0003ab50
   28d74:	0003aab0 	.word	0x0003aab0

00028d78 <bsd_platform_getaddrinfo>:
   28d78:	f7fc bf1a 	b.w	25bb0 <ip_interface_getaddrinfo>

00028d7c <bsd_platform_freeaddrinfo>:
   28d7c:	f7fd b816 	b.w	25dac <ip_interface_freeaddrinfo>

00028d80 <bsd_platform_poll>:
   28d80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   28d84:	ea42 72e2 	orr.w	r2, r2, r2, asr #31
   28d88:	b083      	sub	sp, #12
   28d8a:	9200      	str	r2, [sp, #0]
   28d8c:	2800      	cmp	r0, #0
   28d8e:	d048      	beq.n	28e22 <bsd_platform_poll+0xa2>
   28d90:	1e4b      	subs	r3, r1, #1
   28d92:	2b08      	cmp	r3, #8
   28d94:	d845      	bhi.n	28e22 <bsd_platform_poll+0xa2>
   28d96:	4680      	mov	r8, r0
   28d98:	4605      	mov	r5, r0
   28d9a:	2400      	movs	r4, #0
   28d9c:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
   28da0:	88ab      	ldrh	r3, [r5, #4]
   28da2:	6828      	ldr	r0, [r5, #0]
   28da4:	f003 0303 	and.w	r3, r3, #3
   28da8:	a901      	add	r1, sp, #4
   28daa:	f043 061c 	orr.w	r6, r3, #28
   28dae:	f001 fd29 	bl	2a804 <interface_socket_event_get>
   28db2:	9b01      	ldr	r3, [sp, #4]
   28db4:	3508      	adds	r5, #8
   28db6:	4033      	ands	r3, r6
   28db8:	f825 3c02 	strh.w	r3, [r5, #-2]
   28dbc:	b103      	cbz	r3, 28dc0 <bsd_platform_poll+0x40>
   28dbe:	3401      	adds	r4, #1
   28dc0:	42af      	cmp	r7, r5
   28dc2:	d1ed      	bne.n	28da0 <bsd_platform_poll+0x20>
   28dc4:	bb9c      	cbnz	r4, 28e2e <bsd_platform_poll+0xae>
   28dc6:	4669      	mov	r1, sp
   28dc8:	4640      	mov	r0, r8
   28dca:	f7f7 f89f 	bl	1ff0c <bsd_os_timedwait>
   28dce:	4607      	mov	r7, r0
   28dd0:	b108      	cbz	r0, 28dd6 <bsd_platform_poll+0x56>
   28dd2:	283c      	cmp	r0, #60	; 0x3c
   28dd4:	d11d      	bne.n	28e12 <bsd_platform_poll+0x92>
   28dd6:	46c1      	mov	r9, r8
   28dd8:	2600      	movs	r6, #0
   28dda:	f8b9 3004 	ldrh.w	r3, [r9, #4]
   28dde:	f8d9 0000 	ldr.w	r0, [r9]
   28de2:	f003 0303 	and.w	r3, r3, #3
   28de6:	a901      	add	r1, sp, #4
   28de8:	f043 041c 	orr.w	r4, r3, #28
   28dec:	f001 fd0a 	bl	2a804 <interface_socket_event_get>
   28df0:	9b01      	ldr	r3, [sp, #4]
   28df2:	f109 0908 	add.w	r9, r9, #8
   28df6:	4023      	ands	r3, r4
   28df8:	f829 3c02 	strh.w	r3, [r9, #-2]
   28dfc:	b103      	cbz	r3, 28e00 <bsd_platform_poll+0x80>
   28dfe:	3601      	adds	r6, #1
   28e00:	454d      	cmp	r5, r9
   28e02:	d1ea      	bne.n	28dda <bsd_platform_poll+0x5a>
   28e04:	b90e      	cbnz	r6, 28e0a <bsd_platform_poll+0x8a>
   28e06:	2f00      	cmp	r7, #0
   28e08:	d0dd      	beq.n	28dc6 <bsd_platform_poll+0x46>
   28e0a:	4630      	mov	r0, r6
   28e0c:	b003      	add	sp, #12
   28e0e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   28e12:	2023      	movs	r0, #35	; 0x23
   28e14:	f7f7 f924 	bl	20060 <bsd_os_errno_set>
   28e18:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28e1c:	b003      	add	sp, #12
   28e1e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   28e22:	2016      	movs	r0, #22
   28e24:	f7f7 f91c 	bl	20060 <bsd_os_errno_set>
   28e28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28e2c:	e7ee      	b.n	28e0c <bsd_platform_poll+0x8c>
   28e2e:	4620      	mov	r0, r4
   28e30:	e7ec      	b.n	28e0c <bsd_platform_poll+0x8c>
   28e32:	bf00      	nop

00028e34 <bsd_platform_fcntl>:
   28e34:	b508      	push	{r3, lr}
   28e36:	4b06      	ldr	r3, [pc, #24]	; (28e50 <bsd_platform_fcntl+0x1c>)
   28e38:	4298      	cmp	r0, r3
   28e3a:	d003      	beq.n	28e44 <bsd_platform_fcntl+0x10>
   28e3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   28e40:	f001 bd8a 	b.w	2a958 <interface_socket_fcntl>
   28e44:	202d      	movs	r0, #45	; 0x2d
   28e46:	f7f7 f90b 	bl	20060 <bsd_os_errno_set>
   28e4a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28e4e:	bd08      	pop	{r3, pc}
   28e50:	49765432 	.word	0x49765432

00028e54 <linked_list_init>:
   28e54:	b128      	cbz	r0, 28e62 <linked_list_init+0xe>
   28e56:	2300      	movs	r3, #0
   28e58:	6003      	str	r3, [r0, #0]
   28e5a:	e9c0 3301 	strd	r3, r3, [r0, #4]
   28e5e:	4618      	mov	r0, r3
   28e60:	4770      	bx	lr
   28e62:	2007      	movs	r0, #7
   28e64:	4770      	bx	lr
   28e66:	bf00      	nop

00028e68 <linked_list_push>:
   28e68:	6802      	ldr	r2, [r0, #0]
   28e6a:	4603      	mov	r3, r0
   28e6c:	3201      	adds	r2, #1
   28e6e:	d00e      	beq.n	28e8e <linked_list_push+0x26>
   28e70:	2200      	movs	r2, #0
   28e72:	600a      	str	r2, [r1, #0]
   28e74:	6802      	ldr	r2, [r0, #0]
   28e76:	b13a      	cbz	r2, 28e88 <linked_list_push+0x20>
   28e78:	6882      	ldr	r2, [r0, #8]
   28e7a:	6011      	str	r1, [r2, #0]
   28e7c:	6081      	str	r1, [r0, #8]
   28e7e:	681a      	ldr	r2, [r3, #0]
   28e80:	2000      	movs	r0, #0
   28e82:	3201      	adds	r2, #1
   28e84:	601a      	str	r2, [r3, #0]
   28e86:	4770      	bx	lr
   28e88:	e9c0 1101 	strd	r1, r1, [r0, #4]
   28e8c:	e7f7      	b.n	28e7e <linked_list_push+0x16>
   28e8e:	2004      	movs	r0, #4
   28e90:	4770      	bx	lr
   28e92:	bf00      	nop

00028e94 <linked_list_pop>:
   28e94:	4603      	mov	r3, r0
   28e96:	6800      	ldr	r0, [r0, #0]
   28e98:	b128      	cbz	r0, 28ea6 <linked_list_pop+0x12>
   28e9a:	6858      	ldr	r0, [r3, #4]
   28e9c:	681a      	ldr	r2, [r3, #0]
   28e9e:	6801      	ldr	r1, [r0, #0]
   28ea0:	3a01      	subs	r2, #1
   28ea2:	6059      	str	r1, [r3, #4]
   28ea4:	601a      	str	r2, [r3, #0]
   28ea6:	4770      	bx	lr

00028ea8 <linked_list_peek>:
   28ea8:	6803      	ldr	r3, [r0, #0]
   28eaa:	b10b      	cbz	r3, 28eb0 <linked_list_peek+0x8>
   28eac:	6840      	ldr	r0, [r0, #4]
   28eae:	4770      	bx	lr
   28eb0:	4618      	mov	r0, r3
   28eb2:	4770      	bx	lr

00028eb4 <linked_list_size_get>:
   28eb4:	6800      	ldr	r0, [r0, #0]
   28eb6:	4770      	bx	lr

00028eb8 <linked_list_get_next>:
   28eb8:	6800      	ldr	r0, [r0, #0]
   28eba:	4770      	bx	lr

00028ebc <nrf_socket>:
   28ebc:	b570      	push	{r4, r5, r6, lr}
   28ebe:	4604      	mov	r4, r0
   28ec0:	460d      	mov	r5, r1
   28ec2:	4616      	mov	r6, r2
   28ec4:	f7ff fe8a 	bl	28bdc <bsd_platform_af_method_table_get>
   28ec8:	b130      	cbz	r0, 28ed8 <nrf_socket+0x1c>
   28eca:	6803      	ldr	r3, [r0, #0]
   28ecc:	4632      	mov	r2, r6
   28ece:	4629      	mov	r1, r5
   28ed0:	4620      	mov	r0, r4
   28ed2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   28ed6:	4718      	bx	r3
   28ed8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28edc:	bd70      	pop	{r4, r5, r6, pc}
   28ede:	bf00      	nop

00028ee0 <nrf_close>:
   28ee0:	b510      	push	{r4, lr}
   28ee2:	4604      	mov	r4, r0
   28ee4:	f7ff fed2 	bl	28c8c <bsd_platform_fd_method_table_get>
   28ee8:	b120      	cbz	r0, 28ef4 <nrf_close+0x14>
   28eea:	6843      	ldr	r3, [r0, #4]
   28eec:	4620      	mov	r0, r4
   28eee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   28ef2:	4718      	bx	r3
   28ef4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28ef8:	bd10      	pop	{r4, pc}
   28efa:	bf00      	nop

00028efc <nrf_sendto>:
   28efc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28f00:	460d      	mov	r5, r1
   28f02:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   28f06:	4616      	mov	r6, r2
   28f08:	461f      	mov	r7, r3
   28f0a:	4604      	mov	r4, r0
   28f0c:	f7ff febe 	bl	28c8c <bsd_platform_fd_method_table_get>
   28f10:	b158      	cbz	r0, 28f2a <nrf_sendto+0x2e>
   28f12:	e9cd 8908 	strd	r8, r9, [sp, #32]
   28f16:	f8d0 e008 	ldr.w	lr, [r0, #8]
   28f1a:	463b      	mov	r3, r7
   28f1c:	4632      	mov	r2, r6
   28f1e:	4629      	mov	r1, r5
   28f20:	4620      	mov	r0, r4
   28f22:	46f4      	mov	ip, lr
   28f24:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28f28:	4760      	bx	ip
   28f2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28f2e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   28f32:	bf00      	nop

00028f34 <nrf_recvfrom>:
   28f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28f38:	460d      	mov	r5, r1
   28f3a:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
   28f3e:	4616      	mov	r6, r2
   28f40:	461f      	mov	r7, r3
   28f42:	4604      	mov	r4, r0
   28f44:	f7ff fea2 	bl	28c8c <bsd_platform_fd_method_table_get>
   28f48:	b158      	cbz	r0, 28f62 <nrf_recvfrom+0x2e>
   28f4a:	e9cd 8908 	strd	r8, r9, [sp, #32]
   28f4e:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   28f52:	463b      	mov	r3, r7
   28f54:	4632      	mov	r2, r6
   28f56:	4629      	mov	r1, r5
   28f58:	4620      	mov	r0, r4
   28f5a:	46f4      	mov	ip, lr
   28f5c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   28f60:	4760      	bx	ip
   28f62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28f66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   28f6a:	bf00      	nop

00028f6c <nrf_connect>:
   28f6c:	b570      	push	{r4, r5, r6, lr}
   28f6e:	460d      	mov	r5, r1
   28f70:	4616      	mov	r6, r2
   28f72:	4604      	mov	r4, r0
   28f74:	f7ff fe8a 	bl	28c8c <bsd_platform_fd_method_table_get>
   28f78:	b130      	cbz	r0, 28f88 <nrf_connect+0x1c>
   28f7a:	6943      	ldr	r3, [r0, #20]
   28f7c:	4632      	mov	r2, r6
   28f7e:	4629      	mov	r1, r5
   28f80:	4620      	mov	r0, r4
   28f82:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   28f86:	4718      	bx	r3
   28f88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28f8c:	bd70      	pop	{r4, r5, r6, pc}
   28f8e:	bf00      	nop

00028f90 <nrf_listen>:
   28f90:	b570      	push	{r4, r5, r6, lr}
   28f92:	460d      	mov	r5, r1
   28f94:	4604      	mov	r4, r0
   28f96:	f7ff fe79 	bl	28c8c <bsd_platform_fd_method_table_get>
   28f9a:	b128      	cbz	r0, 28fa8 <nrf_listen+0x18>
   28f9c:	6983      	ldr	r3, [r0, #24]
   28f9e:	4629      	mov	r1, r5
   28fa0:	4620      	mov	r0, r4
   28fa2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   28fa6:	4718      	bx	r3
   28fa8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28fac:	bd70      	pop	{r4, r5, r6, pc}
   28fae:	bf00      	nop

00028fb0 <nrf_accept>:
   28fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   28fb4:	460d      	mov	r5, r1
   28fb6:	4616      	mov	r6, r2
   28fb8:	4604      	mov	r4, r0
   28fba:	f7ff fe67 	bl	28c8c <bsd_platform_fd_method_table_get>
   28fbe:	b140      	cbz	r0, 28fd2 <nrf_accept+0x22>
   28fc0:	69c7      	ldr	r7, [r0, #28]
   28fc2:	4632      	mov	r2, r6
   28fc4:	4629      	mov	r1, r5
   28fc6:	4620      	mov	r0, r4
   28fc8:	46bc      	mov	ip, r7
   28fca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   28fce:	2300      	movs	r3, #0
   28fd0:	4760      	bx	ip
   28fd2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28fd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   28fda:	bf00      	nop

00028fdc <nrf_bind>:
   28fdc:	b570      	push	{r4, r5, r6, lr}
   28fde:	460d      	mov	r5, r1
   28fe0:	4616      	mov	r6, r2
   28fe2:	4604      	mov	r4, r0
   28fe4:	f7ff fe52 	bl	28c8c <bsd_platform_fd_method_table_get>
   28fe8:	b130      	cbz	r0, 28ff8 <nrf_bind+0x1c>
   28fea:	6903      	ldr	r3, [r0, #16]
   28fec:	4632      	mov	r2, r6
   28fee:	4629      	mov	r1, r5
   28ff0:	4620      	mov	r0, r4
   28ff2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   28ff6:	4718      	bx	r3
   28ff8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   28ffc:	bd70      	pop	{r4, r5, r6, pc}
   28ffe:	bf00      	nop

00029000 <nrf_setsockopt>:
   29000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   29004:	f8dd 8018 	ldr.w	r8, [sp, #24]
   29008:	460d      	mov	r5, r1
   2900a:	4616      	mov	r6, r2
   2900c:	461f      	mov	r7, r3
   2900e:	4604      	mov	r4, r0
   29010:	f7ff fe3c 	bl	28c8c <bsd_platform_fd_method_table_get>
   29014:	b158      	cbz	r0, 2902e <nrf_setsockopt+0x2e>
   29016:	f8cd 8018 	str.w	r8, [sp, #24]
   2901a:	f8d0 e020 	ldr.w	lr, [r0, #32]
   2901e:	463b      	mov	r3, r7
   29020:	4632      	mov	r2, r6
   29022:	4629      	mov	r1, r5
   29024:	4620      	mov	r0, r4
   29026:	46f4      	mov	ip, lr
   29028:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2902c:	4760      	bx	ip
   2902e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29032:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   29036:	bf00      	nop

00029038 <nrf_getsockopt>:
   29038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2903c:	f8dd 8018 	ldr.w	r8, [sp, #24]
   29040:	460d      	mov	r5, r1
   29042:	4616      	mov	r6, r2
   29044:	461f      	mov	r7, r3
   29046:	4604      	mov	r4, r0
   29048:	f7ff fe20 	bl	28c8c <bsd_platform_fd_method_table_get>
   2904c:	b158      	cbz	r0, 29066 <nrf_getsockopt+0x2e>
   2904e:	f8cd 8018 	str.w	r8, [sp, #24]
   29052:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
   29056:	463b      	mov	r3, r7
   29058:	4632      	mov	r2, r6
   2905a:	4629      	mov	r1, r5
   2905c:	4620      	mov	r0, r4
   2905e:	46f4      	mov	ip, lr
   29060:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   29064:	4760      	bx	ip
   29066:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2906a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2906e:	bf00      	nop

00029070 <nrf_getaddrinfo>:
   29070:	f7ff be82 	b.w	28d78 <bsd_platform_getaddrinfo>

00029074 <nrf_freeaddrinfo>:
   29074:	f7ff be82 	b.w	28d7c <bsd_platform_freeaddrinfo>

00029078 <nrf_poll>:
   29078:	f7ff be82 	b.w	28d80 <bsd_platform_poll>

0002907c <nrf_fcntl>:
   2907c:	f7ff beda 	b.w	28e34 <bsd_platform_fcntl>

00029080 <rpc_gnss_serialize_utc>:
   29080:	4603      	mov	r3, r0
   29082:	b1d8      	cbz	r0, 290bc <rpc_gnss_serialize_utc+0x3c>
   29084:	b1d1      	cbz	r1, 290bc <rpc_gnss_serialize_utc+0x3c>
   29086:	2000      	movs	r0, #0
   29088:	2201      	movs	r2, #1
   2908a:	7048      	strb	r0, [r1, #1]
   2908c:	700a      	strb	r2, [r1, #0]
   2908e:	685a      	ldr	r2, [r3, #4]
   29090:	2010      	movs	r0, #16
   29092:	f8c1 2006 	str.w	r2, [r1, #6]
   29096:	681a      	ldr	r2, [r3, #0]
   29098:	f8c1 2002 	str.w	r2, [r1, #2]
   2909c:	f993 200a 	ldrsb.w	r2, [r3, #10]
   290a0:	730a      	strb	r2, [r1, #12]
   290a2:	f993 200d 	ldrsb.w	r2, [r3, #13]
   290a6:	73ca      	strb	r2, [r1, #15]
   290a8:	f993 200c 	ldrsb.w	r2, [r3, #12]
   290ac:	738a      	strb	r2, [r1, #14]
   290ae:	7a1a      	ldrb	r2, [r3, #8]
   290b0:	728a      	strb	r2, [r1, #10]
   290b2:	7ada      	ldrb	r2, [r3, #11]
   290b4:	734a      	strb	r2, [r1, #13]
   290b6:	7a5b      	ldrb	r3, [r3, #9]
   290b8:	72cb      	strb	r3, [r1, #11]
   290ba:	4770      	bx	lr
   290bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   290c0:	4770      	bx	lr
   290c2:	bf00      	nop

000290c4 <rpc_gnss_serialize_ephe>:
   290c4:	4603      	mov	r3, r0
   290c6:	2800      	cmp	r0, #0
   290c8:	d04b      	beq.n	29162 <rpc_gnss_serialize_ephe+0x9e>
   290ca:	2900      	cmp	r1, #0
   290cc:	d049      	beq.n	29162 <rpc_gnss_serialize_ephe+0x9e>
   290ce:	2000      	movs	r0, #0
   290d0:	2202      	movs	r2, #2
   290d2:	7048      	strb	r0, [r1, #1]
   290d4:	700a      	strb	r2, [r1, #0]
   290d6:	68da      	ldr	r2, [r3, #12]
   290d8:	2040      	movs	r0, #64	; 0x40
   290da:	f8c1 200b 	str.w	r2, [r1, #11]
   290de:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   290e2:	f8a1 2009 	strh.w	r2, [r1, #9]
   290e6:	f993 2006 	ldrsb.w	r2, [r3, #6]
   290ea:	720a      	strb	r2, [r1, #8]
   290ec:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
   290f0:	878a      	strh	r2, [r1, #60]	; 0x3c
   290f2:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
   290f6:	86ca      	strh	r2, [r1, #54]	; 0x36
   290f8:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
   290fc:	874a      	strh	r2, [r1, #58]	; 0x3a
   290fe:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
   29102:	868a      	strh	r2, [r1, #52]	; 0x34
   29104:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
   29108:	87ca      	strh	r2, [r1, #62]	; 0x3e
   2910a:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
   2910e:	870a      	strh	r2, [r1, #56]	; 0x38
   29110:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   29114:	830a      	strh	r2, [r1, #24]
   29116:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   29118:	f8c1 2022 	str.w	r2, [r1, #34]	; 0x22
   2911c:	7c9a      	ldrb	r2, [r3, #18]
   2911e:	744a      	strb	r2, [r1, #17]
   29120:	785a      	ldrb	r2, [r3, #1]
   29122:	70ca      	strb	r2, [r1, #3]
   29124:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   29126:	62ca      	str	r2, [r1, #44]	; 0x2c
   29128:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
   2912c:	84ca      	strh	r2, [r1, #38]	; 0x26
   2912e:	885a      	ldrh	r2, [r3, #2]
   29130:	808a      	strh	r2, [r1, #4]
   29132:	6a1a      	ldr	r2, [r3, #32]
   29134:	f8c1 201a 	str.w	r2, [r1, #26]
   29138:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   2913a:	630a      	str	r2, [r1, #48]	; 0x30
   2913c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   2913e:	f8c1 201e 	str.w	r2, [r1, #30]
   29142:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   29144:	628a      	str	r2, [r1, #40]	; 0x28
   29146:	781a      	ldrb	r2, [r3, #0]
   29148:	708a      	strb	r2, [r1, #2]
   2914a:	f993 2010 	ldrsb.w	r2, [r3, #16]
   2914e:	73ca      	strb	r2, [r1, #15]
   29150:	889a      	ldrh	r2, [r3, #4]
   29152:	80ca      	strh	r2, [r1, #6]
   29154:	8a9a      	ldrh	r2, [r3, #20]
   29156:	824a      	strh	r2, [r1, #18]
   29158:	7c5a      	ldrb	r2, [r3, #17]
   2915a:	740a      	strb	r2, [r1, #16]
   2915c:	699b      	ldr	r3, [r3, #24]
   2915e:	614b      	str	r3, [r1, #20]
   29160:	4770      	bx	lr
   29162:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29166:	4770      	bx	lr

00029168 <rpc_gnss_serialize_alm>:
   29168:	4603      	mov	r3, r0
   2916a:	b360      	cbz	r0, 291c6 <rpc_gnss_serialize_alm+0x5e>
   2916c:	b359      	cbz	r1, 291c6 <rpc_gnss_serialize_alm+0x5e>
   2916e:	2000      	movs	r0, #0
   29170:	2203      	movs	r2, #3
   29172:	7048      	strb	r0, [r1, #1]
   29174:	700a      	strb	r2, [r1, #0]
   29176:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
   2917a:	2021      	movs	r0, #33	; 0x21
   2917c:	f8a1 201d 	strh.w	r2, [r1, #29]
   29180:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
   29184:	f8a1 201f 	strh.w	r2, [r1, #31]
   29188:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
   2918c:	810a      	strh	r2, [r1, #8]
   2918e:	889a      	ldrh	r2, [r3, #4]
   29190:	80ca      	strh	r2, [r1, #6]
   29192:	78da      	ldrb	r2, [r3, #3]
   29194:	714a      	strb	r2, [r1, #5]
   29196:	699a      	ldr	r2, [r3, #24]
   29198:	f8c1 2019 	str.w	r2, [r1, #25]
   2919c:	691a      	ldr	r2, [r3, #16]
   2919e:	f8c1 2011 	str.w	r2, [r1, #17]
   291a2:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   291a6:	814a      	strh	r2, [r1, #10]
   291a8:	68da      	ldr	r2, [r3, #12]
   291aa:	f8c1 200d 	str.w	r2, [r1, #13]
   291ae:	7a9a      	ldrb	r2, [r3, #10]
   291b0:	730a      	strb	r2, [r1, #12]
   291b2:	781a      	ldrb	r2, [r3, #0]
   291b4:	708a      	strb	r2, [r1, #2]
   291b6:	789a      	ldrb	r2, [r3, #2]
   291b8:	710a      	strb	r2, [r1, #4]
   291ba:	695a      	ldr	r2, [r3, #20]
   291bc:	f8c1 2015 	str.w	r2, [r1, #21]
   291c0:	785b      	ldrb	r3, [r3, #1]
   291c2:	70cb      	strb	r3, [r1, #3]
   291c4:	4770      	bx	lr
   291c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   291ca:	4770      	bx	lr

000291cc <rpc_gnss_serialize_klob>:
   291cc:	4603      	mov	r3, r0
   291ce:	b1f0      	cbz	r0, 2920e <rpc_gnss_serialize_klob+0x42>
   291d0:	b1e9      	cbz	r1, 2920e <rpc_gnss_serialize_klob+0x42>
   291d2:	2000      	movs	r0, #0
   291d4:	2204      	movs	r2, #4
   291d6:	7048      	strb	r0, [r1, #1]
   291d8:	700a      	strb	r2, [r1, #0]
   291da:	f993 2000 	ldrsb.w	r2, [r3]
   291de:	200a      	movs	r0, #10
   291e0:	708a      	strb	r2, [r1, #2]
   291e2:	f993 2001 	ldrsb.w	r2, [r3, #1]
   291e6:	70ca      	strb	r2, [r1, #3]
   291e8:	f993 2002 	ldrsb.w	r2, [r3, #2]
   291ec:	710a      	strb	r2, [r1, #4]
   291ee:	f993 2003 	ldrsb.w	r2, [r3, #3]
   291f2:	714a      	strb	r2, [r1, #5]
   291f4:	f993 2004 	ldrsb.w	r2, [r3, #4]
   291f8:	718a      	strb	r2, [r1, #6]
   291fa:	f993 2005 	ldrsb.w	r2, [r3, #5]
   291fe:	71ca      	strb	r2, [r1, #7]
   29200:	f993 2006 	ldrsb.w	r2, [r3, #6]
   29204:	720a      	strb	r2, [r1, #8]
   29206:	f993 3007 	ldrsb.w	r3, [r3, #7]
   2920a:	724b      	strb	r3, [r1, #9]
   2920c:	4770      	bx	lr
   2920e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29212:	4770      	bx	lr

00029214 <rpc_gnss_serialize_nequick>:
   29214:	4603      	mov	r3, r0
   29216:	b198      	cbz	r0, 29240 <rpc_gnss_serialize_nequick+0x2c>
   29218:	b191      	cbz	r1, 29240 <rpc_gnss_serialize_nequick+0x2c>
   2921a:	2000      	movs	r0, #0
   2921c:	2205      	movs	r2, #5
   2921e:	7048      	strb	r0, [r1, #1]
   29220:	700a      	strb	r2, [r1, #0]
   29222:	f9b3 2000 	ldrsh.w	r2, [r3]
   29226:	200a      	movs	r0, #10
   29228:	804a      	strh	r2, [r1, #2]
   2922a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
   2922e:	808a      	strh	r2, [r1, #4]
   29230:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
   29234:	80ca      	strh	r2, [r1, #6]
   29236:	799a      	ldrb	r2, [r3, #6]
   29238:	720a      	strb	r2, [r1, #8]
   2923a:	79db      	ldrb	r3, [r3, #7]
   2923c:	724b      	strb	r3, [r1, #9]
   2923e:	4770      	bx	lr
   29240:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29244:	4770      	bx	lr
   29246:	bf00      	nop

00029248 <rpc_gnss_serialize_time_and_sv_tow>:
   29248:	b310      	cbz	r0, 29290 <rpc_gnss_serialize_time_and_sv_tow+0x48>
   2924a:	b309      	cbz	r1, 29290 <rpc_gnss_serialize_time_and_sv_tow+0x48>
   2924c:	b470      	push	{r4, r5, r6}
   2924e:	2500      	movs	r5, #0
   29250:	2606      	movs	r6, #6
   29252:	460c      	mov	r4, r1
   29254:	704d      	strb	r5, [r1, #1]
   29256:	700e      	strb	r6, [r1, #0]
   29258:	462b      	mov	r3, r5
   2925a:	8805      	ldrh	r5, [r0, #0]
   2925c:	4602      	mov	r2, r0
   2925e:	804d      	strh	r5, [r1, #2]
   29260:	68c5      	ldr	r5, [r0, #12]
   29262:	f8c1 500a 	str.w	r5, [r1, #10]
   29266:	8905      	ldrh	r5, [r0, #8]
   29268:	810d      	strh	r5, [r1, #8]
   2926a:	6840      	ldr	r0, [r0, #4]
   2926c:	6048      	str	r0, [r1, #4]
   2926e:	8a15      	ldrh	r5, [r2, #16]
   29270:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   29274:	4408      	add	r0, r1
   29276:	81c5      	strh	r5, [r0, #14]
   29278:	7c90      	ldrb	r0, [r2, #18]
   2927a:	3301      	adds	r3, #1
   2927c:	2b20      	cmp	r3, #32
   2927e:	7420      	strb	r0, [r4, #16]
   29280:	f102 0204 	add.w	r2, r2, #4
   29284:	f104 0403 	add.w	r4, r4, #3
   29288:	d1f1      	bne.n	2926e <rpc_gnss_serialize_time_and_sv_tow+0x26>
   2928a:	206e      	movs	r0, #110	; 0x6e
   2928c:	bc70      	pop	{r4, r5, r6}
   2928e:	4770      	bx	lr
   29290:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29294:	4770      	bx	lr
   29296:	bf00      	nop

00029298 <rpc_gnss_serialize_location>:
   29298:	4603      	mov	r3, r0
   2929a:	b1c8      	cbz	r0, 292d0 <rpc_gnss_serialize_location+0x38>
   2929c:	b1c1      	cbz	r1, 292d0 <rpc_gnss_serialize_location+0x38>
   2929e:	2000      	movs	r0, #0
   292a0:	2207      	movs	r2, #7
   292a2:	7048      	strb	r0, [r1, #1]
   292a4:	700a      	strb	r2, [r1, #0]
   292a6:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
   292aa:	2011      	movs	r0, #17
   292ac:	814a      	strh	r2, [r1, #10]
   292ae:	7b9a      	ldrb	r2, [r3, #14]
   292b0:	740a      	strb	r2, [r1, #16]
   292b2:	681a      	ldr	r2, [r3, #0]
   292b4:	f8c1 2002 	str.w	r2, [r1, #2]
   292b8:	685a      	ldr	r2, [r3, #4]
   292ba:	f8c1 2006 	str.w	r2, [r1, #6]
   292be:	7b1a      	ldrb	r2, [r3, #12]
   292c0:	738a      	strb	r2, [r1, #14]
   292c2:	7b5a      	ldrb	r2, [r3, #13]
   292c4:	73ca      	strb	r2, [r1, #15]
   292c6:	7a9a      	ldrb	r2, [r3, #10]
   292c8:	730a      	strb	r2, [r1, #12]
   292ca:	7adb      	ldrb	r3, [r3, #11]
   292cc:	734b      	strb	r3, [r1, #13]
   292ce:	4770      	bx	lr
   292d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   292d4:	4770      	bx	lr
   292d6:	bf00      	nop

000292d8 <rpc_gnss_serialize_integrity>:
   292d8:	b148      	cbz	r0, 292ee <rpc_gnss_serialize_integrity+0x16>
   292da:	b141      	cbz	r1, 292ee <rpc_gnss_serialize_integrity+0x16>
   292dc:	2200      	movs	r2, #0
   292de:	2308      	movs	r3, #8
   292e0:	704a      	strb	r2, [r1, #1]
   292e2:	700b      	strb	r3, [r1, #0]
   292e4:	6803      	ldr	r3, [r0, #0]
   292e6:	2006      	movs	r0, #6
   292e8:	f8c1 3002 	str.w	r3, [r1, #2]
   292ec:	4770      	bx	lr
   292ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   292f2:	4770      	bx	lr

000292f4 <gnss_client_event_handler>:
   292f4:	f850 1b08 	ldr.w	r1, [r0], #8
   292f8:	0c09      	lsrs	r1, r1, #16
   292fa:	f7fd b941 	b.w	26580 <rpc_gnss_event_handler>
   292fe:	bf00      	nop

00029300 <rpc_gnss_client_init>:
   29300:	4801      	ldr	r0, [pc, #4]	; (29308 <rpc_gnss_client_init+0x8>)
   29302:	f7fd b871 	b.w	263e8 <rpc_client_register>
   29306:	bf00      	nop
   29308:	0003abb8 	.word	0x0003abb8

0002930c <rpc_gnss_client_request_alloc>:
   2930c:	2300      	movs	r3, #0
   2930e:	b510      	push	{r4, lr}
   29310:	b082      	sub	sp, #8
   29312:	9301      	str	r3, [sp, #4]
   29314:	b158      	cbz	r0, 2932e <rpc_gnss_client_request_alloc+0x22>
   29316:	4604      	mov	r4, r0
   29318:	aa01      	add	r2, sp, #4
   2931a:	2007      	movs	r0, #7
   2931c:	f7fd f8de 	bl	264dc <rpc_message_alloc>
   29320:	b918      	cbnz	r0, 2932a <rpc_gnss_client_request_alloc+0x1e>
   29322:	9b01      	ldr	r3, [sp, #4]
   29324:	b10b      	cbz	r3, 2932a <rpc_gnss_client_request_alloc+0x1e>
   29326:	3308      	adds	r3, #8
   29328:	6023      	str	r3, [r4, #0]
   2932a:	b002      	add	sp, #8
   2932c:	bd10      	pop	{r4, pc}
   2932e:	2007      	movs	r0, #7
   29330:	b002      	add	sp, #8
   29332:	bd10      	pop	{r4, pc}

00029334 <rpc_gnss_client_request_send>:
   29334:	f401 4370 	and.w	r3, r1, #61440	; 0xf000
   29338:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2933c:	d10b      	bne.n	29356 <rpc_gnss_client_request_send+0x22>
   2933e:	b160      	cbz	r0, 2935a <rpc_gnss_client_request_send+0x26>
   29340:	4603      	mov	r3, r0
   29342:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   29346:	2007      	movs	r0, #7
   29348:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2934c:	f843 1d08 	str.w	r1, [r3, #-8]!
   29350:	4619      	mov	r1, r3
   29352:	f7fd b8b3 	b.w	264bc <rpc_message_send>
   29356:	200f      	movs	r0, #15
   29358:	4770      	bx	lr
   2935a:	2007      	movs	r0, #7
   2935c:	4770      	bx	lr
   2935e:	bf00      	nop

00029360 <rpc_gnss_client_message_free>:
   29360:	b120      	cbz	r0, 2936c <rpc_gnss_client_message_free+0xc>
   29362:	f1a0 0108 	sub.w	r1, r0, #8
   29366:	2007      	movs	r0, #7
   29368:	f7fd b8e4 	b.w	26534 <rpc_message_free>
   2936c:	2007      	movs	r0, #7
   2936e:	4770      	bx	lr

00029370 <rpc_gnss_client_data_free>:
   29370:	b118      	cbz	r0, 2937a <rpc_gnss_client_data_free+0xa>
   29372:	4601      	mov	r1, r0
   29374:	2007      	movs	r0, #7
   29376:	f7fd b8e9 	b.w	2654c <rpc_message_data_free>
   2937a:	2007      	movs	r0, #7
   2937c:	4770      	bx	lr
   2937e:	bf00      	nop

00029380 <datagram_handler_init>:
   29380:	b510      	push	{r4, lr}
   29382:	4604      	mov	r4, r0
   29384:	200c      	movs	r0, #12
   29386:	f000 fdd7 	bl	29f38 <nrf_malloc>
   2938a:	60e0      	str	r0, [r4, #12]
   2938c:	b118      	cbz	r0, 29396 <datagram_handler_init+0x16>
   2938e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   29392:	f7ff bd5f 	b.w	28e54 <linked_list_init>
   29396:	2004      	movs	r0, #4
   29398:	bd10      	pop	{r4, pc}
   2939a:	bf00      	nop

0002939c <datagram_handler_put>:
   2939c:	b570      	push	{r4, r5, r6, lr}
   2939e:	4606      	mov	r6, r0
   293a0:	2014      	movs	r0, #20
   293a2:	460d      	mov	r5, r1
   293a4:	f000 fdc8 	bl	29f38 <nrf_malloc>
   293a8:	b178      	cbz	r0, 293ca <datagram_handler_put+0x2e>
   293aa:	682b      	ldr	r3, [r5, #0]
   293ac:	4604      	mov	r4, r0
   293ae:	6043      	str	r3, [r0, #4]
   293b0:	686b      	ldr	r3, [r5, #4]
   293b2:	4601      	mov	r1, r0
   293b4:	6083      	str	r3, [r0, #8]
   293b6:	68eb      	ldr	r3, [r5, #12]
   293b8:	60c3      	str	r3, [r0, #12]
   293ba:	68ab      	ldr	r3, [r5, #8]
   293bc:	6103      	str	r3, [r0, #16]
   293be:	68f0      	ldr	r0, [r6, #12]
   293c0:	f7ff fd52 	bl	28e68 <linked_list_push>
   293c4:	b920      	cbnz	r0, 293d0 <datagram_handler_put+0x34>
   293c6:	6868      	ldr	r0, [r5, #4]
   293c8:	bd70      	pop	{r4, r5, r6, pc}
   293ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   293ce:	bd70      	pop	{r4, r5, r6, pc}
   293d0:	4620      	mov	r0, r4
   293d2:	f000 fdbb 	bl	29f4c <nrf_free>
   293d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   293da:	bd70      	pop	{r4, r5, r6, pc}

000293dc <datagram_handler_get>:
   293dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   293e0:	4607      	mov	r7, r0
   293e2:	b084      	sub	sp, #16
   293e4:	68c0      	ldr	r0, [r0, #12]
   293e6:	460c      	mov	r4, r1
   293e8:	4616      	mov	r6, r2
   293ea:	f7ff fd5d 	bl	28ea8 <linked_list_peek>
   293ee:	2800      	cmp	r0, #0
   293f0:	d03b      	beq.n	2946a <datagram_handler_get+0x8e>
   293f2:	6882      	ldr	r2, [r0, #8]
   293f4:	4605      	mov	r5, r0
   293f6:	e9d4 0300 	ldrd	r0, r3, [r4]
   293fa:	429a      	cmp	r2, r3
   293fc:	bf28      	it	cs
   293fe:	461a      	movcs	r2, r3
   29400:	6062      	str	r2, [r4, #4]
   29402:	b110      	cbz	r0, 2940a <datagram_handler_get+0x2e>
   29404:	6869      	ldr	r1, [r5, #4]
   29406:	f00f fde7 	bl	38fd8 <memcpy>
   2940a:	68a0      	ldr	r0, [r4, #8]
   2940c:	b118      	cbz	r0, 29416 <datagram_handler_get+0x3a>
   2940e:	692b      	ldr	r3, [r5, #16]
   29410:	b10b      	cbz	r3, 29416 <datagram_handler_get+0x3a>
   29412:	68ea      	ldr	r2, [r5, #12]
   29414:	bb02      	cbnz	r2, 29458 <datagram_handler_get+0x7c>
   29416:	2300      	movs	r3, #0
   29418:	60e3      	str	r3, [r4, #12]
   2941a:	0732      	lsls	r2, r6, #28
   2941c:	d506      	bpl.n	2942c <datagram_handler_get+0x50>
   2941e:	06b3      	lsls	r3, r6, #26
   29420:	bf4c      	ite	mi
   29422:	68a8      	ldrmi	r0, [r5, #8]
   29424:	6860      	ldrpl	r0, [r4, #4]
   29426:	b004      	add	sp, #16
   29428:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2942c:	68f8      	ldr	r0, [r7, #12]
   2942e:	f7ff fd31 	bl	28e94 <linked_list_pop>
   29432:	4680      	mov	r8, r0
   29434:	2800      	cmp	r0, #0
   29436:	d0f2      	beq.n	2941e <datagram_handler_get+0x42>
   29438:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   2943c:	6902      	ldr	r2, [r0, #16]
   2943e:	9300      	str	r3, [sp, #0]
   29440:	68c3      	ldr	r3, [r0, #12]
   29442:	e9cd 1201 	strd	r1, r2, [sp, #4]
   29446:	9303      	str	r3, [sp, #12]
   29448:	4668      	mov	r0, sp
   2944a:	e9d7 3101 	ldrd	r3, r1, [r7, #4]
   2944e:	4798      	blx	r3
   29450:	4640      	mov	r0, r8
   29452:	f000 fd7b 	bl	29f4c <nrf_free>
   29456:	e7e2      	b.n	2941e <datagram_handler_get+0x42>
   29458:	68e3      	ldr	r3, [r4, #12]
   2945a:	429a      	cmp	r2, r3
   2945c:	bf28      	it	cs
   2945e:	461a      	movcs	r2, r3
   29460:	60e2      	str	r2, [r4, #12]
   29462:	6929      	ldr	r1, [r5, #16]
   29464:	f00f fdb8 	bl	38fd8 <memcpy>
   29468:	e7d7      	b.n	2941a <datagram_handler_get+0x3e>
   2946a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2946e:	e7da      	b.n	29426 <datagram_handler_get+0x4a>

00029470 <datagram_handler_available>:
   29470:	b508      	push	{r3, lr}
   29472:	68c0      	ldr	r0, [r0, #12]
   29474:	f7ff fd18 	bl	28ea8 <linked_list_peek>
   29478:	b108      	cbz	r0, 2947e <datagram_handler_available+0xe>
   2947a:	6880      	ldr	r0, [r0, #8]
   2947c:	bd08      	pop	{r3, pc}
   2947e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29482:	bd08      	pop	{r3, pc}

00029484 <datagram_handler_flush>:
   29484:	b530      	push	{r4, r5, lr}
   29486:	4605      	mov	r5, r0
   29488:	68c0      	ldr	r0, [r0, #12]
   2948a:	b085      	sub	sp, #20
   2948c:	b9a8      	cbnz	r0, 294ba <datagram_handler_flush+0x36>
   2948e:	e01a      	b.n	294c6 <datagram_handler_flush+0x42>
   29490:	68e8      	ldr	r0, [r5, #12]
   29492:	f7ff fcff 	bl	28e94 <linked_list_pop>
   29496:	4604      	mov	r4, r0
   29498:	b170      	cbz	r0, 294b8 <datagram_handler_flush+0x34>
   2949a:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   2949e:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   294a2:	e9cd 0100 	strd	r0, r1, [sp]
   294a6:	e9cd 2302 	strd	r2, r3, [sp, #8]
   294aa:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   294ae:	4668      	mov	r0, sp
   294b0:	4798      	blx	r3
   294b2:	4620      	mov	r0, r4
   294b4:	f000 fd4a 	bl	29f4c <nrf_free>
   294b8:	68e8      	ldr	r0, [r5, #12]
   294ba:	f7ff fcfb 	bl	28eb4 <linked_list_size_get>
   294be:	2800      	cmp	r0, #0
   294c0:	d1e6      	bne.n	29490 <datagram_handler_flush+0xc>
   294c2:	b005      	add	sp, #20
   294c4:	bd30      	pop	{r4, r5, pc}
   294c6:	2008      	movs	r0, #8
   294c8:	b005      	add	sp, #20
   294ca:	bd30      	pop	{r4, r5, pc}

000294cc <datagram_handler_free>:
   294cc:	b530      	push	{r4, r5, lr}
   294ce:	4605      	mov	r5, r0
   294d0:	68c0      	ldr	r0, [r0, #12]
   294d2:	b085      	sub	sp, #20
   294d4:	b9a0      	cbnz	r0, 29500 <datagram_handler_free+0x34>
   294d6:	e01c      	b.n	29512 <datagram_handler_free+0x46>
   294d8:	f7ff fcdc 	bl	28e94 <linked_list_pop>
   294dc:	4604      	mov	r4, r0
   294de:	b170      	cbz	r0, 294fe <datagram_handler_free+0x32>
   294e0:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   294e4:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   294e8:	e9cd 0100 	strd	r0, r1, [sp]
   294ec:	e9cd 2302 	strd	r2, r3, [sp, #8]
   294f0:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   294f4:	4668      	mov	r0, sp
   294f6:	4798      	blx	r3
   294f8:	4620      	mov	r0, r4
   294fa:	f000 fd27 	bl	29f4c <nrf_free>
   294fe:	68e8      	ldr	r0, [r5, #12]
   29500:	f7ff fcd8 	bl	28eb4 <linked_list_size_get>
   29504:	4604      	mov	r4, r0
   29506:	68e8      	ldr	r0, [r5, #12]
   29508:	2c00      	cmp	r4, #0
   2950a:	d1e5      	bne.n	294d8 <datagram_handler_free+0xc>
   2950c:	f000 fd1e 	bl	29f4c <nrf_free>
   29510:	60ec      	str	r4, [r5, #12]
   29512:	b005      	add	sp, #20
   29514:	bd30      	pop	{r4, r5, pc}
   29516:	bf00      	nop

00029518 <null_handler_init>:
   29518:	2000      	movs	r0, #0
   2951a:	4770      	bx	lr

0002951c <null_handler_put>:
   2951c:	b510      	push	{r4, lr}
   2951e:	460c      	mov	r4, r1
   29520:	e9d0 3101 	ldrd	r3, r1, [r0, #4]
   29524:	4620      	mov	r0, r4
   29526:	4798      	blx	r3
   29528:	6860      	ldr	r0, [r4, #4]
   2952a:	bd10      	pop	{r4, pc}

0002952c <null_handler_get>:
   2952c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29530:	4770      	bx	lr
   29532:	bf00      	nop

00029534 <null_handler_available>:
   29534:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29538:	4770      	bx	lr
   2953a:	bf00      	nop

0002953c <null_handler_flush>:
   2953c:	2000      	movs	r0, #0
   2953e:	4770      	bx	lr

00029540 <null_handler_free>:
   29540:	4770      	bx	lr
   29542:	bf00      	nop

00029544 <packet_handler_create>:
   29544:	2801      	cmp	r0, #1
   29546:	b538      	push	{r3, r4, r5, lr}
   29548:	460d      	mov	r5, r1
   2954a:	4614      	mov	r4, r2
   2954c:	d00d      	beq.n	2956a <packet_handler_create+0x26>
   2954e:	db11      	blt.n	29574 <packet_handler_create+0x30>
   29550:	2803      	cmp	r0, #3
   29552:	dc0f      	bgt.n	29574 <packet_handler_create+0x30>
   29554:	2010      	movs	r0, #16
   29556:	f000 fcef 	bl	29f38 <nrf_malloc>
   2955a:	2218      	movs	r2, #24
   2955c:	b120      	cbz	r0, 29568 <packet_handler_create+0x24>
   2955e:	4b08      	ldr	r3, [pc, #32]	; (29580 <packet_handler_create+0x3c>)
   29560:	6045      	str	r5, [r0, #4]
   29562:	4413      	add	r3, r2
   29564:	6084      	str	r4, [r0, #8]
   29566:	6003      	str	r3, [r0, #0]
   29568:	bd38      	pop	{r3, r4, r5, pc}
   2956a:	2014      	movs	r0, #20
   2956c:	f000 fce4 	bl	29f38 <nrf_malloc>
   29570:	2230      	movs	r2, #48	; 0x30
   29572:	e7f3      	b.n	2955c <packet_handler_create+0x18>
   29574:	200c      	movs	r0, #12
   29576:	f000 fcdf 	bl	29f38 <nrf_malloc>
   2957a:	2200      	movs	r2, #0
   2957c:	e7ee      	b.n	2955c <packet_handler_create+0x18>
   2957e:	bf00      	nop
   29580:	0003abc8 	.word	0x0003abc8

00029584 <packet_handler_delete>:
   29584:	b510      	push	{r4, lr}
   29586:	4604      	mov	r4, r0
   29588:	6803      	ldr	r3, [r0, #0]
   2958a:	691b      	ldr	r3, [r3, #16]
   2958c:	4798      	blx	r3
   2958e:	6823      	ldr	r3, [r4, #0]
   29590:	4620      	mov	r0, r4
   29592:	695b      	ldr	r3, [r3, #20]
   29594:	4798      	blx	r3
   29596:	4620      	mov	r0, r4
   29598:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2959c:	f000 bcd6 	b.w	29f4c <nrf_free>

000295a0 <stream_handler_init>:
   295a0:	b510      	push	{r4, lr}
   295a2:	4604      	mov	r4, r0
   295a4:	200c      	movs	r0, #12
   295a6:	f000 fcc7 	bl	29f38 <nrf_malloc>
   295aa:	60e0      	str	r0, [r4, #12]
   295ac:	b128      	cbz	r0, 295ba <stream_handler_init+0x1a>
   295ae:	2300      	movs	r3, #0
   295b0:	6123      	str	r3, [r4, #16]
   295b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   295b6:	f7ff bc4d 	b.w	28e54 <linked_list_init>
   295ba:	2004      	movs	r0, #4
   295bc:	bd10      	pop	{r4, pc}
   295be:	bf00      	nop

000295c0 <stream_handler_put>:
   295c0:	b570      	push	{r4, r5, r6, lr}
   295c2:	4606      	mov	r6, r0
   295c4:	2014      	movs	r0, #20
   295c6:	460d      	mov	r5, r1
   295c8:	f000 fcb6 	bl	29f38 <nrf_malloc>
   295cc:	b178      	cbz	r0, 295ee <stream_handler_put+0x2e>
   295ce:	682b      	ldr	r3, [r5, #0]
   295d0:	4604      	mov	r4, r0
   295d2:	6043      	str	r3, [r0, #4]
   295d4:	686b      	ldr	r3, [r5, #4]
   295d6:	4601      	mov	r1, r0
   295d8:	6083      	str	r3, [r0, #8]
   295da:	68eb      	ldr	r3, [r5, #12]
   295dc:	60c3      	str	r3, [r0, #12]
   295de:	68ab      	ldr	r3, [r5, #8]
   295e0:	6103      	str	r3, [r0, #16]
   295e2:	68f0      	ldr	r0, [r6, #12]
   295e4:	f7ff fc40 	bl	28e68 <linked_list_push>
   295e8:	b920      	cbnz	r0, 295f4 <stream_handler_put+0x34>
   295ea:	6868      	ldr	r0, [r5, #4]
   295ec:	bd70      	pop	{r4, r5, r6, pc}
   295ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   295f2:	bd70      	pop	{r4, r5, r6, pc}
   295f4:	4620      	mov	r0, r4
   295f6:	f000 fca9 	bl	29f4c <nrf_free>
   295fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   295fe:	bd70      	pop	{r4, r5, r6, pc}

00029600 <stream_handler_get>:
   29600:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29604:	4682      	mov	sl, r0
   29606:	b089      	sub	sp, #36	; 0x24
   29608:	68c0      	ldr	r0, [r0, #12]
   2960a:	4689      	mov	r9, r1
   2960c:	4693      	mov	fp, r2
   2960e:	f7ff fc4b 	bl	28ea8 <linked_list_peek>
   29612:	2800      	cmp	r0, #0
   29614:	d071      	beq.n	296fa <stream_handler_get+0xfa>
   29616:	4605      	mov	r5, r0
   29618:	f8d9 0008 	ldr.w	r0, [r9, #8]
   2961c:	b120      	cbz	r0, 29628 <stream_handler_get+0x28>
   2961e:	692b      	ldr	r3, [r5, #16]
   29620:	b113      	cbz	r3, 29628 <stream_handler_get+0x28>
   29622:	68ea      	ldr	r2, [r5, #12]
   29624:	2a00      	cmp	r2, #0
   29626:	d15d      	bne.n	296e4 <stream_handler_get+0xe4>
   29628:	2300      	movs	r3, #0
   2962a:	f8c9 300c 	str.w	r3, [r9, #12]
   2962e:	f8d9 2000 	ldr.w	r2, [r9]
   29632:	f8d9 8004 	ldr.w	r8, [r9, #4]
   29636:	f8da 1010 	ldr.w	r1, [sl, #16]
   2963a:	9203      	str	r2, [sp, #12]
   2963c:	f1b8 0f00 	cmp.w	r8, #0
   29640:	d030      	beq.n	296a4 <stream_handler_get+0xa4>
   29642:	2400      	movs	r4, #0
   29644:	f00b 0320 	and.w	r3, fp, #32
   29648:	9301      	str	r3, [sp, #4]
   2964a:	f00b 0b08 	and.w	fp, fp, #8
   2964e:	68ae      	ldr	r6, [r5, #8]
   29650:	eba8 0304 	sub.w	r3, r8, r4
   29654:	1a76      	subs	r6, r6, r1
   29656:	429e      	cmp	r6, r3
   29658:	4637      	mov	r7, r6
   2965a:	bf28      	it	cs
   2965c:	461f      	movcs	r7, r3
   2965e:	b10a      	cbz	r2, 29664 <stream_handler_get+0x64>
   29660:	9a01      	ldr	r2, [sp, #4]
   29662:	b1aa      	cbz	r2, 29690 <stream_handler_get+0x90>
   29664:	f1bb 0f00 	cmp.w	fp, #0
   29668:	d106      	bne.n	29678 <stream_handler_get+0x78>
   2966a:	429e      	cmp	r6, r3
   2966c:	d921      	bls.n	296b2 <stream_handler_get+0xb2>
   2966e:	f8da 3010 	ldr.w	r3, [sl, #16]
   29672:	443b      	add	r3, r7
   29674:	f8ca 3010 	str.w	r3, [sl, #16]
   29678:	4628      	mov	r0, r5
   2967a:	f7ff fc1d 	bl	28eb8 <linked_list_get_next>
   2967e:	443c      	add	r4, r7
   29680:	4605      	mov	r5, r0
   29682:	b180      	cbz	r0, 296a6 <stream_handler_get+0xa6>
   29684:	45a0      	cmp	r8, r4
   29686:	d90e      	bls.n	296a6 <stream_handler_get+0xa6>
   29688:	f8d9 2000 	ldr.w	r2, [r9]
   2968c:	2100      	movs	r1, #0
   2968e:	e7de      	b.n	2964e <stream_handler_get+0x4e>
   29690:	6868      	ldr	r0, [r5, #4]
   29692:	9302      	str	r3, [sp, #8]
   29694:	9b03      	ldr	r3, [sp, #12]
   29696:	4401      	add	r1, r0
   29698:	463a      	mov	r2, r7
   2969a:	1918      	adds	r0, r3, r4
   2969c:	f00f fc9c 	bl	38fd8 <memcpy>
   296a0:	9b02      	ldr	r3, [sp, #8]
   296a2:	e7df      	b.n	29664 <stream_handler_get+0x64>
   296a4:	4644      	mov	r4, r8
   296a6:	4620      	mov	r0, r4
   296a8:	f8c9 4004 	str.w	r4, [r9, #4]
   296ac:	b009      	add	sp, #36	; 0x24
   296ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   296b2:	f8da 000c 	ldr.w	r0, [sl, #12]
   296b6:	f7ff fbed 	bl	28e94 <linked_list_pop>
   296ba:	4606      	mov	r6, r0
   296bc:	b170      	cbz	r0, 296dc <stream_handler_get+0xdc>
   296be:	e9d0 2301 	ldrd	r2, r3, [r0, #4]
   296c2:	e9d0 0103 	ldrd	r0, r1, [r0, #12]
   296c6:	e9cd 2304 	strd	r2, r3, [sp, #16]
   296ca:	e9cd 1006 	strd	r1, r0, [sp, #24]
   296ce:	e9da 3101 	ldrd	r3, r1, [sl, #4]
   296d2:	a804      	add	r0, sp, #16
   296d4:	4798      	blx	r3
   296d6:	4630      	mov	r0, r6
   296d8:	f000 fc38 	bl	29f4c <nrf_free>
   296dc:	2300      	movs	r3, #0
   296de:	f8ca 3010 	str.w	r3, [sl, #16]
   296e2:	e7c9      	b.n	29678 <stream_handler_get+0x78>
   296e4:	f8d9 300c 	ldr.w	r3, [r9, #12]
   296e8:	429a      	cmp	r2, r3
   296ea:	bf28      	it	cs
   296ec:	461a      	movcs	r2, r3
   296ee:	f8c9 200c 	str.w	r2, [r9, #12]
   296f2:	6929      	ldr	r1, [r5, #16]
   296f4:	f00f fc70 	bl	38fd8 <memcpy>
   296f8:	e799      	b.n	2962e <stream_handler_get+0x2e>
   296fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   296fe:	e7d5      	b.n	296ac <stream_handler_get+0xac>

00029700 <stream_handler_available>:
   29700:	b510      	push	{r4, lr}
   29702:	4604      	mov	r4, r0
   29704:	68c0      	ldr	r0, [r0, #12]
   29706:	f7ff fbcf 	bl	28ea8 <linked_list_peek>
   2970a:	b150      	cbz	r0, 29722 <stream_handler_available+0x22>
   2970c:	6924      	ldr	r4, [r4, #16]
   2970e:	4264      	negs	r4, r4
   29710:	6883      	ldr	r3, [r0, #8]
   29712:	441c      	add	r4, r3
   29714:	f7ff fbd0 	bl	28eb8 <linked_list_get_next>
   29718:	2800      	cmp	r0, #0
   2971a:	d1f9      	bne.n	29710 <stream_handler_available+0x10>
   2971c:	ea24 70e4 	bic.w	r0, r4, r4, asr #31
   29720:	bd10      	pop	{r4, pc}
   29722:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29726:	bd10      	pop	{r4, pc}

00029728 <stream_handler_flush>:
   29728:	b530      	push	{r4, r5, lr}
   2972a:	4605      	mov	r5, r0
   2972c:	68c0      	ldr	r0, [r0, #12]
   2972e:	b085      	sub	sp, #20
   29730:	b9a8      	cbnz	r0, 2975e <stream_handler_flush+0x36>
   29732:	e01a      	b.n	2976a <stream_handler_flush+0x42>
   29734:	68e8      	ldr	r0, [r5, #12]
   29736:	f7ff fbad 	bl	28e94 <linked_list_pop>
   2973a:	4604      	mov	r4, r0
   2973c:	b170      	cbz	r0, 2975c <stream_handler_flush+0x34>
   2973e:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   29742:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   29746:	e9cd 0100 	strd	r0, r1, [sp]
   2974a:	e9cd 2302 	strd	r2, r3, [sp, #8]
   2974e:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   29752:	4668      	mov	r0, sp
   29754:	4798      	blx	r3
   29756:	4620      	mov	r0, r4
   29758:	f000 fbf8 	bl	29f4c <nrf_free>
   2975c:	68e8      	ldr	r0, [r5, #12]
   2975e:	f7ff fba9 	bl	28eb4 <linked_list_size_get>
   29762:	2800      	cmp	r0, #0
   29764:	d1e6      	bne.n	29734 <stream_handler_flush+0xc>
   29766:	b005      	add	sp, #20
   29768:	bd30      	pop	{r4, r5, pc}
   2976a:	2008      	movs	r0, #8
   2976c:	b005      	add	sp, #20
   2976e:	bd30      	pop	{r4, r5, pc}

00029770 <stream_handler_free>:
   29770:	b530      	push	{r4, r5, lr}
   29772:	4605      	mov	r5, r0
   29774:	68c0      	ldr	r0, [r0, #12]
   29776:	b085      	sub	sp, #20
   29778:	b9a0      	cbnz	r0, 297a4 <stream_handler_free+0x34>
   2977a:	e01c      	b.n	297b6 <stream_handler_free+0x46>
   2977c:	f7ff fb8a 	bl	28e94 <linked_list_pop>
   29780:	4604      	mov	r4, r0
   29782:	b170      	cbz	r0, 297a2 <stream_handler_free+0x32>
   29784:	e9d0 0101 	ldrd	r0, r1, [r0, #4]
   29788:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
   2978c:	e9cd 0100 	strd	r0, r1, [sp]
   29790:	e9cd 2302 	strd	r2, r3, [sp, #8]
   29794:	e9d5 3101 	ldrd	r3, r1, [r5, #4]
   29798:	4668      	mov	r0, sp
   2979a:	4798      	blx	r3
   2979c:	4620      	mov	r0, r4
   2979e:	f000 fbd5 	bl	29f4c <nrf_free>
   297a2:	68e8      	ldr	r0, [r5, #12]
   297a4:	f7ff fb86 	bl	28eb4 <linked_list_size_get>
   297a8:	4604      	mov	r4, r0
   297aa:	68e8      	ldr	r0, [r5, #12]
   297ac:	2c00      	cmp	r4, #0
   297ae:	d1e5      	bne.n	2977c <stream_handler_free+0xc>
   297b0:	f000 fbcc 	bl	29f4c <nrf_free>
   297b4:	60ec      	str	r4, [r5, #12]
   297b6:	b005      	add	sp, #20
   297b8:	bd30      	pop	{r4, r5, pc}
   297ba:	bf00      	nop

000297bc <mem_free>:
   297bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   297c0:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 29890 <mem_free+0xd4>
   297c4:	b083      	sub	sp, #12
   297c6:	9000      	str	r0, [sp, #0]
   297c8:	f10c 0b3c 	add.w	fp, ip, #60	; 0x3c
   297cc:	f8dc 3008 	ldr.w	r3, [ip, #8]
   297d0:	b12b      	cbz	r3, 297de <mem_free+0x22>
   297d2:	f8dc 2000 	ldr.w	r2, [ip]
   297d6:	9c00      	ldr	r4, [sp, #0]
   297d8:	7810      	ldrb	r0, [r2, #0]
   297da:	42a0      	cmp	r0, r4
   297dc:	d006      	beq.n	297ec <mem_free+0x30>
   297de:	f10c 0c0c 	add.w	ip, ip, #12
   297e2:	45e3      	cmp	fp, ip
   297e4:	d1f2      	bne.n	297cc <mem_free+0x10>
   297e6:	b003      	add	sp, #12
   297e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   297ec:	f8dc a004 	ldr.w	sl, [ip, #4]
   297f0:	eb03 080a 	add.w	r8, r3, sl
   297f4:	45c2      	cmp	sl, r8
   297f6:	d2f2      	bcs.n	297de <mem_free+0x22>
   297f8:	6853      	ldr	r3, [r2, #4]
   297fa:	f8cd c004 	str.w	ip, [sp, #4]
   297fe:	46d6      	mov	lr, sl
   29800:	469c      	mov	ip, r3
   29802:	f8d2 9010 	ldr.w	r9, [r2, #16]
   29806:	8997      	ldrh	r7, [r2, #12]
   29808:	ebae 000a 	sub.w	r0, lr, sl
   2980c:	b3df      	cbz	r7, 29886 <mem_free+0xca>
   2980e:	f8b9 2002 	ldrh.w	r2, [r9, #2]
   29812:	4290      	cmp	r0, r2
   29814:	d31c      	bcc.n	29850 <mem_free+0x94>
   29816:	4665      	mov	r5, ip
   29818:	2400      	movs	r4, #0
   2981a:	f109 0304 	add.w	r3, r9, #4
   2981e:	e003      	b.n	29828 <mem_free+0x6c>
   29820:	885a      	ldrh	r2, [r3, #2]
   29822:	3304      	adds	r3, #4
   29824:	4282      	cmp	r2, r0
   29826:	d815      	bhi.n	29854 <mem_free+0x98>
   29828:	f833 6c04 	ldrh.w	r6, [r3, #-4]
   2982c:	3401      	adds	r4, #1
   2982e:	42a7      	cmp	r7, r4
   29830:	fb02 5506 	mla	r5, r2, r6, r5
   29834:	eba0 0002 	sub.w	r0, r0, r2
   29838:	461e      	mov	r6, r3
   2983a:	d1f1      	bne.n	29820 <mem_free+0x64>
   2983c:	2000      	movs	r0, #0
   2983e:	4281      	cmp	r1, r0
   29840:	d00d      	beq.n	2985e <mem_free+0xa2>
   29842:	f10e 0e01 	add.w	lr, lr, #1
   29846:	45f0      	cmp	r8, lr
   29848:	d1de      	bne.n	29808 <mem_free+0x4c>
   2984a:	f8dd c004 	ldr.w	ip, [sp, #4]
   2984e:	e7c6      	b.n	297de <mem_free+0x22>
   29850:	4665      	mov	r5, ip
   29852:	464e      	mov	r6, r9
   29854:	8833      	ldrh	r3, [r6, #0]
   29856:	fb00 5003 	mla	r0, r0, r3, r5
   2985a:	4281      	cmp	r1, r0
   2985c:	d1f1      	bne.n	29842 <mem_free+0x86>
   2985e:	f5be 7f00 	cmp.w	lr, #512	; 0x200
   29862:	f8dd c004 	ldr.w	ip, [sp, #4]
   29866:	d0ba      	beq.n	297de <mem_free+0x22>
   29868:	2301      	movs	r3, #1
   2986a:	4a08      	ldr	r2, [pc, #32]	; (2988c <mem_free+0xd0>)
   2986c:	ea4f 115e 	mov.w	r1, lr, lsr #5
   29870:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
   29874:	f00e 0e1f 	and.w	lr, lr, #31
   29878:	fa03 fe0e 	lsl.w	lr, r3, lr
   2987c:	ea4e 0000 	orr.w	r0, lr, r0
   29880:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
   29884:	e7af      	b.n	297e6 <mem_free+0x2a>
   29886:	4638      	mov	r0, r7
   29888:	e7d9      	b.n	2983e <mem_free+0x82>
   2988a:	bf00      	nop
   2988c:	20022904 	.word	0x20022904
   29890:	20022948 	.word	0x20022948

00029894 <mem_alloc.constprop.5>:
   29894:	2800      	cmp	r0, #0
   29896:	d050      	beq.n	2993a <mem_alloc.constprop.5+0xa6>
   29898:	4b6d      	ldr	r3, [pc, #436]	; (29a50 <mem_alloc.constprop.5+0x1bc>)
   2989a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   2989e:	4290      	cmp	r0, r2
   298a0:	d84b      	bhi.n	2993a <mem_alloc.constprop.5+0xa6>
   298a2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   298a6:	f8d3 b08c 	ldr.w	fp, [r3, #140]	; 0x8c
   298aa:	b083      	sub	sp, #12
   298ac:	f1bb 0f00 	cmp.w	fp, #0
   298b0:	d054      	beq.n	2995c <mem_alloc.constprop.5+0xc8>
   298b2:	f10b 32ff 	add.w	r2, fp, #4294967295	; 0xffffffff
   298b6:	4691      	mov	r9, r2
   298b8:	2600      	movs	r6, #0
   298ba:	f04f 0812 	mov.w	r8, #18
   298be:	4f65      	ldr	r7, [pc, #404]	; (29a54 <mem_alloc.constprop.5+0x1c0>)
   298c0:	9201      	str	r2, [sp, #4]
   298c2:	f10b 0e11 	add.w	lr, fp, #17
   298c6:	eb06 0209 	add.w	r2, r6, r9
   298ca:	f853 4038 	ldr.w	r4, [r3, r8, lsl #3]
   298ce:	3201      	adds	r2, #1
   298d0:	0852      	lsrs	r2, r2, #1
   298d2:	eb04 0c44 	add.w	ip, r4, r4, lsl #1
   298d6:	f102 0112 	add.w	r1, r2, #18
   298da:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]
   298de:	f857 a02c 	ldr.w	sl, [r7, ip, lsl #2]
   298e2:	f853 403e 	ldr.w	r4, [r3, lr, lsl #3]
   298e6:	eb03 0cc8 	add.w	ip, r3, r8, lsl #3
   298ea:	f8dc c004 	ldr.w	ip, [ip, #4]
   298ee:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   298f2:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   298f6:	f8da a010 	ldr.w	sl, [sl, #16]
   298fa:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
   298fe:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
   29902:	f83a a02c 	ldrh.w	sl, [sl, ip, lsl #2]
   29906:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   2990a:	eb03 0cce 	add.w	ip, r3, lr, lsl #3
   2990e:	6849      	ldr	r1, [r1, #4]
   29910:	692d      	ldr	r5, [r5, #16]
   29912:	6924      	ldr	r4, [r4, #16]
   29914:	f8dc c004 	ldr.w	ip, [ip, #4]
   29918:	4550      	cmp	r0, sl
   2991a:	f835 5021 	ldrh.w	r5, [r5, r1, lsl #2]
   2991e:	f834 102c 	ldrh.w	r1, [r4, ip, lsl #2]
   29922:	d915      	bls.n	29950 <mem_alloc.constprop.5+0xbc>
   29924:	4288      	cmp	r0, r1
   29926:	d211      	bcs.n	2994c <mem_alloc.constprop.5+0xb8>
   29928:	42a8      	cmp	r0, r5
   2992a:	d908      	bls.n	2993e <mem_alloc.constprop.5+0xaa>
   2992c:	1c56      	adds	r6, r2, #1
   2992e:	45b1      	cmp	r9, r6
   29930:	f0c0 8087 	bcc.w	29a42 <mem_alloc.constprop.5+0x1ae>
   29934:	f102 0813 	add.w	r8, r2, #19
   29938:	e7c5      	b.n	298c6 <mem_alloc.constprop.5+0x32>
   2993a:	2000      	movs	r0, #0
   2993c:	4770      	bx	lr
   2993e:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   29942:	454e      	cmp	r6, r9
   29944:	d87d      	bhi.n	29a42 <mem_alloc.constprop.5+0x1ae>
   29946:	f102 0e11 	add.w	lr, r2, #17
   2994a:	e7bc      	b.n	298c6 <mem_alloc.constprop.5+0x32>
   2994c:	f109 0601 	add.w	r6, r9, #1
   29950:	45b3      	cmp	fp, r6
   29952:	d007      	beq.n	29964 <mem_alloc.constprop.5+0xd0>
   29954:	2e10      	cmp	r6, #16
   29956:	d001      	beq.n	2995c <mem_alloc.constprop.5+0xc8>
   29958:	45b3      	cmp	fp, r6
   2995a:	d808      	bhi.n	2996e <mem_alloc.constprop.5+0xda>
   2995c:	2000      	movs	r0, #0
   2995e:	b003      	add	sp, #12
   29960:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29964:	9a01      	ldr	r2, [sp, #4]
   29966:	2a10      	cmp	r2, #16
   29968:	bf18      	it	ne
   2996a:	4616      	movne	r6, r2
   2996c:	d0f6      	beq.n	2995c <mem_alloc.constprop.5+0xc8>
   2996e:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 29a58 <mem_alloc.constprop.5+0x1c4>
   29972:	eb03 08c6 	add.w	r8, r3, r6, lsl #3
   29976:	e9d8 2424 	ldrd	r2, r4, [r8, #144]	; 0x90
   2997a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   2997e:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
   29982:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   29986:	f8d2 e004 	ldr.w	lr, [r2, #4]
   2998a:	691d      	ldr	r5, [r3, #16]
   2998c:	2c00      	cmp	r4, #0
   2998e:	d056      	beq.n	29a3e <mem_alloc.constprop.5+0x1aa>
   29990:	462a      	mov	r2, r5
   29992:	4670      	mov	r0, lr
   29994:	00a4      	lsls	r4, r4, #2
   29996:	eb05 0904 	add.w	r9, r5, r4
   2999a:	8851      	ldrh	r1, [r2, #2]
   2999c:	3204      	adds	r2, #4
   2999e:	4591      	cmp	r9, r2
   299a0:	4408      	add	r0, r1
   299a2:	d1fa      	bne.n	2999a <mem_alloc.constprop.5+0x106>
   299a4:	1929      	adds	r1, r5, r4
   299a6:	f8b1 a002 	ldrh.w	sl, [r1, #2]
   299aa:	4482      	add	sl, r0
   299ac:	4582      	cmp	sl, r0
   299ae:	d918      	bls.n	299e2 <mem_alloc.constprop.5+0x14e>
   299b0:	0941      	lsrs	r1, r0, #5
   299b2:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   299b6:	f000 041f 	and.w	r4, r0, #31
   299ba:	fa22 f904 	lsr.w	r9, r2, r4
   299be:	f019 0f01 	tst.w	r9, #1
   299c2:	d007      	beq.n	299d4 <mem_alloc.constprop.5+0x140>
   299c4:	e013      	b.n	299ee <mem_alloc.constprop.5+0x15a>
   299c6:	f85c 2021 	ldr.w	r2, [ip, r1, lsl #2]
   299ca:	fa22 f904 	lsr.w	r9, r2, r4
   299ce:	f019 0f01 	tst.w	r9, #1
   299d2:	d10c      	bne.n	299ee <mem_alloc.constprop.5+0x15a>
   299d4:	3001      	adds	r0, #1
   299d6:	4582      	cmp	sl, r0
   299d8:	ea4f 1150 	mov.w	r1, r0, lsr #5
   299dc:	f000 041f 	and.w	r4, r0, #31
   299e0:	d1f1      	bne.n	299c6 <mem_alloc.constprop.5+0x132>
   299e2:	3601      	adds	r6, #1
   299e4:	455e      	cmp	r6, fp
   299e6:	f108 0808 	add.w	r8, r8, #8
   299ea:	d3c4      	bcc.n	29976 <mem_alloc.constprop.5+0xe2>
   299ec:	e7b6      	b.n	2995c <mem_alloc.constprop.5+0xc8>
   299ee:	2601      	movs	r6, #1
   299f0:	fa06 f404 	lsl.w	r4, r6, r4
   299f4:	899e      	ldrh	r6, [r3, #12]
   299f6:	ea22 0204 	bic.w	r2, r2, r4
   299fa:	eba0 000e 	sub.w	r0, r0, lr
   299fe:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
   29a02:	685c      	ldr	r4, [r3, #4]
   29a04:	2e00      	cmp	r6, #0
   29a06:	d0a9      	beq.n	2995c <mem_alloc.constprop.5+0xc8>
   29a08:	886a      	ldrh	r2, [r5, #2]
   29a0a:	4282      	cmp	r2, r0
   29a0c:	d811      	bhi.n	29a32 <mem_alloc.constprop.5+0x19e>
   29a0e:	2100      	movs	r1, #0
   29a10:	1d2b      	adds	r3, r5, #4
   29a12:	e003      	b.n	29a1c <mem_alloc.constprop.5+0x188>
   29a14:	885a      	ldrh	r2, [r3, #2]
   29a16:	3304      	adds	r3, #4
   29a18:	4282      	cmp	r2, r0
   29a1a:	d80a      	bhi.n	29a32 <mem_alloc.constprop.5+0x19e>
   29a1c:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   29a20:	3101      	adds	r1, #1
   29a22:	428e      	cmp	r6, r1
   29a24:	fb02 4405 	mla	r4, r2, r5, r4
   29a28:	eba0 0002 	sub.w	r0, r0, r2
   29a2c:	461d      	mov	r5, r3
   29a2e:	d1f1      	bne.n	29a14 <mem_alloc.constprop.5+0x180>
   29a30:	e794      	b.n	2995c <mem_alloc.constprop.5+0xc8>
   29a32:	882b      	ldrh	r3, [r5, #0]
   29a34:	fb00 4003 	mla	r0, r0, r3, r4
   29a38:	b003      	add	sp, #12
   29a3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29a3e:	4670      	mov	r0, lr
   29a40:	e7b0      	b.n	299a4 <mem_alloc.constprop.5+0x110>
   29a42:	f1bb 0f10 	cmp.w	fp, #16
   29a46:	bf08      	it	eq
   29a48:	260f      	moveq	r6, #15
   29a4a:	d090      	beq.n	2996e <mem_alloc.constprop.5+0xda>
   29a4c:	e786      	b.n	2995c <mem_alloc.constprop.5+0xc8>
   29a4e:	bf00      	nop
   29a50:	20022984 	.word	0x20022984
   29a54:	20022948 	.word	0x20022948
   29a58:	20022904 	.word	0x20022904

00029a5c <mem_alloc.constprop.4>:
   29a5c:	2800      	cmp	r0, #0
   29a5e:	d04c      	beq.n	29afa <mem_alloc.constprop.4+0x9e>
   29a60:	4b6b      	ldr	r3, [pc, #428]	; (29c10 <mem_alloc.constprop.4+0x1b4>)
   29a62:	681a      	ldr	r2, [r3, #0]
   29a64:	4290      	cmp	r0, r2
   29a66:	d848      	bhi.n	29afa <mem_alloc.constprop.4+0x9e>
   29a68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29a6c:	685f      	ldr	r7, [r3, #4]
   29a6e:	b083      	sub	sp, #12
   29a70:	9700      	str	r7, [sp, #0]
   29a72:	2f00      	cmp	r7, #0
   29a74:	d051      	beq.n	29b1a <mem_alloc.constprop.4+0xbe>
   29a76:	1e7a      	subs	r2, r7, #1
   29a78:	4696      	mov	lr, r2
   29a7a:	2100      	movs	r1, #0
   29a7c:	f04f 0c01 	mov.w	ip, #1
   29a80:	4c64      	ldr	r4, [pc, #400]	; (29c14 <mem_alloc.constprop.4+0x1b8>)
   29a82:	9201      	str	r2, [sp, #4]
   29a84:	eb01 020e 	add.w	r2, r1, lr
   29a88:	3201      	adds	r2, #1
   29a8a:	f853 503c 	ldr.w	r5, [r3, ip, lsl #3]
   29a8e:	0852      	lsrs	r2, r2, #1
   29a90:	f102 0801 	add.w	r8, r2, #1
   29a94:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   29a98:	f853 9037 	ldr.w	r9, [r3, r7, lsl #3]
   29a9c:	f854 a025 	ldr.w	sl, [r4, r5, lsl #2]
   29aa0:	f853 6038 	ldr.w	r6, [r3, r8, lsl #3]
   29aa4:	eb09 0549 	add.w	r5, r9, r9, lsl #1
   29aa8:	eb03 09cc 	add.w	r9, r3, ip, lsl #3
   29aac:	f8d9 9004 	ldr.w	r9, [r9, #4]
   29ab0:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   29ab4:	f8da a010 	ldr.w	sl, [sl, #16]
   29ab8:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
   29abc:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
   29ac0:	f83a a029 	ldrh.w	sl, [sl, r9, lsl #2]
   29ac4:	eb03 0bc8 	add.w	fp, r3, r8, lsl #3
   29ac8:	eb03 09c7 	add.w	r9, r3, r7, lsl #3
   29acc:	6936      	ldr	r6, [r6, #16]
   29ace:	f8db b004 	ldr.w	fp, [fp, #4]
   29ad2:	692d      	ldr	r5, [r5, #16]
   29ad4:	f8d9 9004 	ldr.w	r9, [r9, #4]
   29ad8:	4550      	cmp	r0, sl
   29ada:	f836 602b 	ldrh.w	r6, [r6, fp, lsl #2]
   29ade:	f835 5029 	ldrh.w	r5, [r5, r9, lsl #2]
   29ae2:	d913      	bls.n	29b0c <mem_alloc.constprop.4+0xb0>
   29ae4:	42a8      	cmp	r0, r5
   29ae6:	d210      	bcs.n	29b0a <mem_alloc.constprop.4+0xae>
   29ae8:	42b0      	cmp	r0, r6
   29aea:	d908      	bls.n	29afe <mem_alloc.constprop.4+0xa2>
   29aec:	45c6      	cmp	lr, r8
   29aee:	4641      	mov	r1, r8
   29af0:	f0c0 8087 	bcc.w	29c02 <mem_alloc.constprop.4+0x1a6>
   29af4:	f108 0c01 	add.w	ip, r8, #1
   29af8:	e7c4      	b.n	29a84 <mem_alloc.constprop.4+0x28>
   29afa:	2000      	movs	r0, #0
   29afc:	4770      	bx	lr
   29afe:	f102 3eff 	add.w	lr, r2, #4294967295	; 0xffffffff
   29b02:	4571      	cmp	r1, lr
   29b04:	d87d      	bhi.n	29c02 <mem_alloc.constprop.4+0x1a6>
   29b06:	4617      	mov	r7, r2
   29b08:	e7bc      	b.n	29a84 <mem_alloc.constprop.4+0x28>
   29b0a:	4639      	mov	r1, r7
   29b0c:	9a00      	ldr	r2, [sp, #0]
   29b0e:	428a      	cmp	r2, r1
   29b10:	d007      	beq.n	29b22 <mem_alloc.constprop.4+0xc6>
   29b12:	2910      	cmp	r1, #16
   29b14:	d001      	beq.n	29b1a <mem_alloc.constprop.4+0xbe>
   29b16:	428a      	cmp	r2, r1
   29b18:	d808      	bhi.n	29b2c <mem_alloc.constprop.4+0xd0>
   29b1a:	2000      	movs	r0, #0
   29b1c:	b003      	add	sp, #12
   29b1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29b22:	9a01      	ldr	r2, [sp, #4]
   29b24:	2a10      	cmp	r2, #16
   29b26:	bf18      	it	ne
   29b28:	4611      	movne	r1, r2
   29b2a:	d0f6      	beq.n	29b1a <mem_alloc.constprop.4+0xbe>
   29b2c:	f8df c0e8 	ldr.w	ip, [pc, #232]	; 29c18 <mem_alloc.constprop.4+0x1bc>
   29b30:	f8dd 9000 	ldr.w	r9, [sp]
   29b34:	eb03 08c1 	add.w	r8, r3, r1, lsl #3
   29b38:	e9d8 2602 	ldrd	r2, r6, [r8, #8]
   29b3c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   29b40:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
   29b44:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   29b48:	f8d2 e004 	ldr.w	lr, [r2, #4]
   29b4c:	691f      	ldr	r7, [r3, #16]
   29b4e:	2e00      	cmp	r6, #0
   29b50:	d055      	beq.n	29bfe <mem_alloc.constprop.4+0x1a2>
   29b52:	463a      	mov	r2, r7
   29b54:	4670      	mov	r0, lr
   29b56:	00b6      	lsls	r6, r6, #2
   29b58:	eb07 0a06 	add.w	sl, r7, r6
   29b5c:	8855      	ldrh	r5, [r2, #2]
   29b5e:	3204      	adds	r2, #4
   29b60:	4592      	cmp	sl, r2
   29b62:	4428      	add	r0, r5
   29b64:	d1fa      	bne.n	29b5c <mem_alloc.constprop.4+0x100>
   29b66:	19bd      	adds	r5, r7, r6
   29b68:	f8b5 b002 	ldrh.w	fp, [r5, #2]
   29b6c:	4483      	add	fp, r0
   29b6e:	4583      	cmp	fp, r0
   29b70:	d918      	bls.n	29ba4 <mem_alloc.constprop.4+0x148>
   29b72:	0945      	lsrs	r5, r0, #5
   29b74:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   29b78:	f000 061f 	and.w	r6, r0, #31
   29b7c:	fa22 fa06 	lsr.w	sl, r2, r6
   29b80:	f01a 0f01 	tst.w	sl, #1
   29b84:	d007      	beq.n	29b96 <mem_alloc.constprop.4+0x13a>
   29b86:	e013      	b.n	29bb0 <mem_alloc.constprop.4+0x154>
   29b88:	f85c 2025 	ldr.w	r2, [ip, r5, lsl #2]
   29b8c:	fa22 fa06 	lsr.w	sl, r2, r6
   29b90:	f01a 0f01 	tst.w	sl, #1
   29b94:	d10c      	bne.n	29bb0 <mem_alloc.constprop.4+0x154>
   29b96:	3001      	adds	r0, #1
   29b98:	4583      	cmp	fp, r0
   29b9a:	ea4f 1550 	mov.w	r5, r0, lsr #5
   29b9e:	f000 061f 	and.w	r6, r0, #31
   29ba2:	d1f1      	bne.n	29b88 <mem_alloc.constprop.4+0x12c>
   29ba4:	3101      	adds	r1, #1
   29ba6:	4549      	cmp	r1, r9
   29ba8:	f108 0808 	add.w	r8, r8, #8
   29bac:	d3c4      	bcc.n	29b38 <mem_alloc.constprop.4+0xdc>
   29bae:	e7b4      	b.n	29b1a <mem_alloc.constprop.4+0xbe>
   29bb0:	2101      	movs	r1, #1
   29bb2:	40b1      	lsls	r1, r6
   29bb4:	899e      	ldrh	r6, [r3, #12]
   29bb6:	ea22 0201 	bic.w	r2, r2, r1
   29bba:	eba0 000e 	sub.w	r0, r0, lr
   29bbe:	f84c 2025 	str.w	r2, [ip, r5, lsl #2]
   29bc2:	685c      	ldr	r4, [r3, #4]
   29bc4:	2e00      	cmp	r6, #0
   29bc6:	d0a8      	beq.n	29b1a <mem_alloc.constprop.4+0xbe>
   29bc8:	887a      	ldrh	r2, [r7, #2]
   29bca:	4282      	cmp	r2, r0
   29bcc:	d811      	bhi.n	29bf2 <mem_alloc.constprop.4+0x196>
   29bce:	2100      	movs	r1, #0
   29bd0:	1d3b      	adds	r3, r7, #4
   29bd2:	e003      	b.n	29bdc <mem_alloc.constprop.4+0x180>
   29bd4:	885a      	ldrh	r2, [r3, #2]
   29bd6:	3304      	adds	r3, #4
   29bd8:	4282      	cmp	r2, r0
   29bda:	d80a      	bhi.n	29bf2 <mem_alloc.constprop.4+0x196>
   29bdc:	f833 5c04 	ldrh.w	r5, [r3, #-4]
   29be0:	3101      	adds	r1, #1
   29be2:	428e      	cmp	r6, r1
   29be4:	eba0 0002 	sub.w	r0, r0, r2
   29be8:	fb02 4405 	mla	r4, r2, r5, r4
   29bec:	461f      	mov	r7, r3
   29bee:	d1f1      	bne.n	29bd4 <mem_alloc.constprop.4+0x178>
   29bf0:	e793      	b.n	29b1a <mem_alloc.constprop.4+0xbe>
   29bf2:	883b      	ldrh	r3, [r7, #0]
   29bf4:	fb00 4003 	mla	r0, r0, r3, r4
   29bf8:	b003      	add	sp, #12
   29bfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29bfe:	4670      	mov	r0, lr
   29c00:	e7b1      	b.n	29b66 <mem_alloc.constprop.4+0x10a>
   29c02:	9a00      	ldr	r2, [sp, #0]
   29c04:	2a10      	cmp	r2, #16
   29c06:	bf08      	it	eq
   29c08:	210f      	moveq	r1, #15
   29c0a:	d08f      	beq.n	29b2c <mem_alloc.constprop.4+0xd0>
   29c0c:	e785      	b.n	29b1a <mem_alloc.constprop.4+0xbe>
   29c0e:	bf00      	nop
   29c10:	20022984 	.word	0x20022984
   29c14:	20022948 	.word	0x20022948
   29c18:	20022904 	.word	0x20022904

00029c1c <nrf_mem_init>:
   29c1c:	b570      	push	{r4, r5, r6, lr}
   29c1e:	2200      	movs	r2, #0
   29c20:	2501      	movs	r5, #1
   29c22:	4833      	ldr	r0, [pc, #204]	; (29cf0 <nrf_mem_init+0xd4>)
   29c24:	0951      	lsrs	r1, r2, #5
   29c26:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
   29c2a:	f002 031f 	and.w	r3, r2, #31
   29c2e:	fa05 f303 	lsl.w	r3, r5, r3
   29c32:	3201      	adds	r2, #1
   29c34:	4323      	orrs	r3, r4
   29c36:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   29c3a:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   29c3e:	d1f1      	bne.n	29c24 <nrf_mem_init+0x8>
   29c40:	2400      	movs	r4, #0
   29c42:	4b2c      	ldr	r3, [pc, #176]	; (29cf4 <nrf_mem_init+0xd8>)
   29c44:	4621      	mov	r1, r4
   29c46:	223c      	movs	r2, #60	; 0x3c
   29c48:	482b      	ldr	r0, [pc, #172]	; (29cf8 <nrf_mem_init+0xdc>)
   29c4a:	601c      	str	r4, [r3, #0]
   29c4c:	f00f f9fe 	bl	3904c <memset>
   29c50:	2110      	movs	r1, #16
   29c52:	2205      	movs	r2, #5
   29c54:	4b29      	ldr	r3, [pc, #164]	; (29cfc <nrf_mem_init+0xe0>)
   29c56:	4e2a      	ldr	r6, [pc, #168]	; (29d00 <nrf_mem_init+0xe4>)
   29c58:	e9c3 4400 	strd	r4, r4, [r3]
   29c5c:	60d9      	str	r1, [r3, #12]
   29c5e:	6159      	str	r1, [r3, #20]
   29c60:	61d9      	str	r1, [r3, #28]
   29c62:	6259      	str	r1, [r3, #36]	; 0x24
   29c64:	62d9      	str	r1, [r3, #44]	; 0x2c
   29c66:	6359      	str	r1, [r3, #52]	; 0x34
   29c68:	63d9      	str	r1, [r3, #60]	; 0x3c
   29c6a:	6459      	str	r1, [r3, #68]	; 0x44
   29c6c:	64d9      	str	r1, [r3, #76]	; 0x4c
   29c6e:	6559      	str	r1, [r3, #84]	; 0x54
   29c70:	65d9      	str	r1, [r3, #92]	; 0x5c
   29c72:	6659      	str	r1, [r3, #100]	; 0x64
   29c74:	66d9      	str	r1, [r3, #108]	; 0x6c
   29c76:	6759      	str	r1, [r3, #116]	; 0x74
   29c78:	67d9      	str	r1, [r3, #124]	; 0x7c
   29c7a:	609a      	str	r2, [r3, #8]
   29c7c:	611a      	str	r2, [r3, #16]
   29c7e:	619a      	str	r2, [r3, #24]
   29c80:	621a      	str	r2, [r3, #32]
   29c82:	629a      	str	r2, [r3, #40]	; 0x28
   29c84:	631a      	str	r2, [r3, #48]	; 0x30
   29c86:	639a      	str	r2, [r3, #56]	; 0x38
   29c88:	641a      	str	r2, [r3, #64]	; 0x40
   29c8a:	649a      	str	r2, [r3, #72]	; 0x48
   29c8c:	651a      	str	r2, [r3, #80]	; 0x50
   29c8e:	659a      	str	r2, [r3, #88]	; 0x58
   29c90:	661a      	str	r2, [r3, #96]	; 0x60
   29c92:	669a      	str	r2, [r3, #104]	; 0x68
   29c94:	671a      	str	r2, [r3, #112]	; 0x70
   29c96:	679a      	str	r2, [r3, #120]	; 0x78
   29c98:	e9c3 2120 	strd	r2, r1, [r3, #128]	; 0x80
   29c9c:	e9c3 4422 	strd	r4, r4, [r3, #136]	; 0x88
   29ca0:	e9c3 2124 	strd	r2, r1, [r3, #144]	; 0x90
   29ca4:	e9c3 2126 	strd	r2, r1, [r3, #152]	; 0x98
   29ca8:	e9c3 2128 	strd	r2, r1, [r3, #160]	; 0xa0
   29cac:	e9c3 212a 	strd	r2, r1, [r3, #168]	; 0xa8
   29cb0:	e9c3 212c 	strd	r2, r1, [r3, #176]	; 0xb0
   29cb4:	e9c3 212e 	strd	r2, r1, [r3, #184]	; 0xb8
   29cb8:	e9c3 2130 	strd	r2, r1, [r3, #192]	; 0xc0
   29cbc:	e9c3 2132 	strd	r2, r1, [r3, #200]	; 0xc8
   29cc0:	e9c3 2134 	strd	r2, r1, [r3, #208]	; 0xd0
   29cc4:	e9c3 2136 	strd	r2, r1, [r3, #216]	; 0xd8
   29cc8:	e9c3 2138 	strd	r2, r1, [r3, #224]	; 0xe0
   29ccc:	e9c3 213a 	strd	r2, r1, [r3, #232]	; 0xe8
   29cd0:	e9c3 213c 	strd	r2, r1, [r3, #240]	; 0xf0
   29cd4:	e9c3 213e 	strd	r2, r1, [r3, #248]	; 0xf8
   29cd8:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
   29cdc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
   29ce0:	f8c3 110c 	str.w	r1, [r3, #268]	; 0x10c
   29ce4:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   29ce8:	4620      	mov	r0, r4
   29cea:	7035      	strb	r5, [r6, #0]
   29cec:	bd70      	pop	{r4, r5, r6, pc}
   29cee:	bf00      	nop
   29cf0:	20022904 	.word	0x20022904
   29cf4:	20022944 	.word	0x20022944
   29cf8:	20022948 	.word	0x20022948
   29cfc:	20022984 	.word	0x20022984
   29d00:	2002908c 	.word	0x2002908c

00029d04 <nrf_mem_register>:
   29d04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   29d08:	4b87      	ldr	r3, [pc, #540]	; (29f28 <nrf_mem_register+0x224>)
   29d0a:	b087      	sub	sp, #28
   29d0c:	781b      	ldrb	r3, [r3, #0]
   29d0e:	2b00      	cmp	r3, #0
   29d10:	f000 808c 	beq.w	29e2c <nrf_mem_register+0x128>
   29d14:	b328      	cbz	r0, 29d62 <nrf_mem_register+0x5e>
   29d16:	b321      	cbz	r1, 29d62 <nrf_mem_register+0x5e>
   29d18:	780b      	ldrb	r3, [r1, #0]
   29d1a:	f8df 8218 	ldr.w	r8, [pc, #536]	; 29f34 <nrf_mem_register+0x230>
   29d1e:	eb03 1303 	add.w	r3, r3, r3, lsl #4
   29d22:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   29d26:	685b      	ldr	r3, [r3, #4]
   29d28:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   29d2c:	4463      	add	r3, ip
   29d2e:	2b10      	cmp	r3, #16
   29d30:	d811      	bhi.n	29d56 <nrf_mem_register+0x52>
   29d32:	f04f 0a00 	mov.w	sl, #0
   29d36:	4689      	mov	r9, r1
   29d38:	4b7c      	ldr	r3, [pc, #496]	; (29f2c <nrf_mem_register+0x228>)
   29d3a:	4f7d      	ldr	r7, [pc, #500]	; (29f30 <nrf_mem_register+0x22c>)
   29d3c:	681b      	ldr	r3, [r3, #0]
   29d3e:	ea4f 0e8c 	mov.w	lr, ip, lsl #2
   29d42:	9300      	str	r3, [sp, #0]
   29d44:	68b9      	ldr	r1, [r7, #8]
   29d46:	b191      	cbz	r1, 29d6e <nrf_mem_register+0x6a>
   29d48:	f10a 0a01 	add.w	sl, sl, #1
   29d4c:	f1ba 0f05 	cmp.w	sl, #5
   29d50:	f107 070c 	add.w	r7, r7, #12
   29d54:	d1f6      	bne.n	29d44 <nrf_mem_register+0x40>
   29d56:	f248 1b07 	movw	fp, #33031	; 0x8107
   29d5a:	4658      	mov	r0, fp
   29d5c:	b007      	add	sp, #28
   29d5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29d62:	f248 1b0e 	movw	fp, #33038	; 0x810e
   29d66:	4658      	mov	r0, fp
   29d68:	b007      	add	sp, #28
   29d6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29d6e:	f1bc 0f00 	cmp.w	ip, #0
   29d72:	d061      	beq.n	29e38 <nrf_mem_register+0x134>
   29d74:	460d      	mov	r5, r1
   29d76:	460c      	mov	r4, r1
   29d78:	f8d9 3010 	ldr.w	r3, [r9, #16]
   29d7c:	eb0e 0b03 	add.w	fp, lr, r3
   29d80:	885a      	ldrh	r2, [r3, #2]
   29d82:	f833 6b04 	ldrh.w	r6, [r3], #4
   29d86:	4415      	add	r5, r2
   29d88:	459b      	cmp	fp, r3
   29d8a:	fb02 4406 	mla	r4, r2, r6, r4
   29d8e:	d1f7      	bne.n	29d80 <nrf_mem_register+0x7c>
   29d90:	f8d9 3008 	ldr.w	r3, [r9, #8]
   29d94:	42a3      	cmp	r3, r4
   29d96:	d3d7      	bcc.n	29d48 <nrf_mem_register+0x44>
   29d98:	9b00      	ldr	r3, [sp, #0]
   29d9a:	442b      	add	r3, r5
   29d9c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   29da0:	d2d2      	bcs.n	29d48 <nrf_mem_register+0x44>
   29da2:	4c63      	ldr	r4, [pc, #396]	; (29f30 <nrf_mem_register+0x22c>)
   29da4:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
   29da8:	0092      	lsls	r2, r2, #2
   29daa:	f8c0 a000 	str.w	sl, [r0]
   29dae:	18a0      	adds	r0, r4, r2
   29db0:	f844 9002 	str.w	r9, [r4, r2]
   29db4:	9a00      	ldr	r2, [sp, #0]
   29db6:	468b      	mov	fp, r1
   29db8:	e9c0 2501 	strd	r2, r5, [r0, #4]
   29dbc:	f899 2001 	ldrb.w	r2, [r9, #1]
   29dc0:	485a      	ldr	r0, [pc, #360]	; (29f2c <nrf_mem_register+0x228>)
   29dc2:	2a01      	cmp	r2, #1
   29dc4:	6003      	str	r3, [r0, #0]
   29dc6:	d0c8      	beq.n	29d5a <nrf_mem_register+0x56>
   29dc8:	f8b9 300c 	ldrh.w	r3, [r9, #12]
   29dcc:	2b00      	cmp	r3, #0
   29dce:	d0c4      	beq.n	29d5a <nrf_mem_register+0x56>
   29dd0:	2500      	movs	r5, #0
   29dd2:	f8cd 9004 	str.w	r9, [sp, #4]
   29dd6:	f8cd a00c 	str.w	sl, [sp, #12]
   29dda:	f8cd b014 	str.w	fp, [sp, #20]
   29dde:	9b01      	ldr	r3, [sp, #4]
   29de0:	781f      	ldrb	r7, [r3, #0]
   29de2:	691a      	ldr	r2, [r3, #16]
   29de4:	013b      	lsls	r3, r7, #4
   29de6:	eb03 0907 	add.w	r9, r3, r7
   29dea:	9300      	str	r3, [sp, #0]
   29dec:	eb08 03c9 	add.w	r3, r8, r9, lsl #3
   29df0:	6859      	ldr	r1, [r3, #4]
   29df2:	f832 4025 	ldrh.w	r4, [r2, r5, lsl #2]
   29df6:	9102      	str	r1, [sp, #8]
   29df8:	bb39      	cbnz	r1, 29e4a <nrf_mem_register+0x146>
   29dfa:	9a03      	ldr	r2, [sp, #12]
   29dfc:	60dd      	str	r5, [r3, #12]
   29dfe:	609a      	str	r2, [r3, #8]
   29e00:	9b00      	ldr	r3, [sp, #0]
   29e02:	443b      	add	r3, r7
   29e04:	461f      	mov	r7, r3
   29e06:	eb08 01c3 	add.w	r1, r8, r3, lsl #3
   29e0a:	684b      	ldr	r3, [r1, #4]
   29e0c:	f858 2037 	ldr.w	r2, [r8, r7, lsl #3]
   29e10:	3301      	adds	r3, #1
   29e12:	4294      	cmp	r4, r2
   29e14:	604b      	str	r3, [r1, #4]
   29e16:	d912      	bls.n	29e3e <nrf_mem_register+0x13a>
   29e18:	9b01      	ldr	r3, [sp, #4]
   29e1a:	f848 4037 	str.w	r4, [r8, r7, lsl #3]
   29e1e:	899b      	ldrh	r3, [r3, #12]
   29e20:	3501      	adds	r5, #1
   29e22:	429d      	cmp	r5, r3
   29e24:	d3db      	bcc.n	29dde <nrf_mem_register+0xda>
   29e26:	f8dd b014 	ldr.w	fp, [sp, #20]
   29e2a:	e796      	b.n	29d5a <nrf_mem_register+0x56>
   29e2c:	f248 1b08 	movw	fp, #33032	; 0x8108
   29e30:	4658      	mov	r0, fp
   29e32:	b007      	add	sp, #28
   29e34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   29e38:	9b00      	ldr	r3, [sp, #0]
   29e3a:	4665      	mov	r5, ip
   29e3c:	e7ae      	b.n	29d9c <nrf_mem_register+0x98>
   29e3e:	9b01      	ldr	r3, [sp, #4]
   29e40:	3501      	adds	r5, #1
   29e42:	899b      	ldrh	r3, [r3, #12]
   29e44:	42ab      	cmp	r3, r5
   29e46:	d8ca      	bhi.n	29dde <nrf_mem_register+0xda>
   29e48:	e7ed      	b.n	29e26 <nrf_mem_register+0x122>
   29e4a:	2600      	movs	r6, #0
   29e4c:	f101 3aff 	add.w	sl, r1, #4294967295	; 0xffffffff
   29e50:	9504      	str	r5, [sp, #16]
   29e52:	eb06 000a 	add.w	r0, r6, sl
   29e56:	eb09 0206 	add.w	r2, r9, r6
   29e5a:	3201      	adds	r2, #1
   29e5c:	3001      	adds	r0, #1
   29e5e:	f858 c032 	ldr.w	ip, [r8, r2, lsl #3]
   29e62:	0840      	lsrs	r0, r0, #1
   29e64:	4d32      	ldr	r5, [pc, #200]	; (29f30 <nrf_mem_register+0x22c>)
   29e66:	eb09 0100 	add.w	r1, r9, r0
   29e6a:	eb09 030a 	add.w	r3, r9, sl
   29e6e:	3101      	adds	r1, #1
   29e70:	3301      	adds	r3, #1
   29e72:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   29e76:	f858 e031 	ldr.w	lr, [r8, r1, lsl #3]
   29e7a:	f855 b02c 	ldr.w	fp, [r5, ip, lsl #2]
   29e7e:	f858 c033 	ldr.w	ip, [r8, r3, lsl #3]
   29e82:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
   29e86:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   29e8a:	eb0c 0c4c 	add.w	ip, ip, ip, lsl #1
   29e8e:	f8db b010 	ldr.w	fp, [fp, #16]
   29e92:	6852      	ldr	r2, [r2, #4]
   29e94:	f855 e02e 	ldr.w	lr, [r5, lr, lsl #2]
   29e98:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
   29e9c:	eb08 01c1 	add.w	r1, r8, r1, lsl #3
   29ea0:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
   29ea4:	f83b 2022 	ldrh.w	r2, [fp, r2, lsl #2]
   29ea8:	f8de e010 	ldr.w	lr, [lr, #16]
   29eac:	6849      	ldr	r1, [r1, #4]
   29eae:	f8dc c010 	ldr.w	ip, [ip, #16]
   29eb2:	685b      	ldr	r3, [r3, #4]
   29eb4:	4294      	cmp	r4, r2
   29eb6:	f83e 1021 	ldrh.w	r1, [lr, r1, lsl #2]
   29eba:	f83c 3023 	ldrh.w	r3, [ip, r3, lsl #2]
   29ebe:	d92d      	bls.n	29f1c <nrf_mem_register+0x218>
   29ec0:	429c      	cmp	r4, r3
   29ec2:	d22d      	bcs.n	29f20 <nrf_mem_register+0x21c>
   29ec4:	428c      	cmp	r4, r1
   29ec6:	d924      	bls.n	29f12 <nrf_mem_register+0x20e>
   29ec8:	1c46      	adds	r6, r0, #1
   29eca:	45b2      	cmp	sl, r6
   29ecc:	d2c1      	bcs.n	29e52 <nrf_mem_register+0x14e>
   29ece:	2610      	movs	r6, #16
   29ed0:	9d04      	ldr	r5, [sp, #16]
   29ed2:	9a02      	ldr	r2, [sp, #8]
   29ed4:	42b2      	cmp	r2, r6
   29ed6:	d911      	bls.n	29efc <nrf_mem_register+0x1f8>
   29ed8:	9b00      	ldr	r3, [sp, #0]
   29eda:	443b      	add	r3, r7
   29edc:	441a      	add	r2, r3
   29ede:	4433      	add	r3, r6
   29ee0:	eb08 0ac2 	add.w	sl, r8, r2, lsl #3
   29ee4:	eb08 09c3 	add.w	r9, r8, r3, lsl #3
   29ee8:	2208      	movs	r2, #8
   29eea:	4651      	mov	r1, sl
   29eec:	eb0a 0002 	add.w	r0, sl, r2
   29ef0:	f1aa 0a08 	sub.w	sl, sl, #8
   29ef4:	f00f f870 	bl	38fd8 <memcpy>
   29ef8:	45d1      	cmp	r9, sl
   29efa:	d1f5      	bne.n	29ee8 <nrf_mem_register+0x1e4>
   29efc:	9b00      	ldr	r3, [sp, #0]
   29efe:	9903      	ldr	r1, [sp, #12]
   29f00:	443b      	add	r3, r7
   29f02:	4433      	add	r3, r6
   29f04:	3301      	adds	r3, #1
   29f06:	eb08 02c3 	add.w	r2, r8, r3, lsl #3
   29f0a:	f848 1033 	str.w	r1, [r8, r3, lsl #3]
   29f0e:	6055      	str	r5, [r2, #4]
   29f10:	e776      	b.n	29e00 <nrf_mem_register+0xfc>
   29f12:	f100 3aff 	add.w	sl, r0, #4294967295	; 0xffffffff
   29f16:	4556      	cmp	r6, sl
   29f18:	d99b      	bls.n	29e52 <nrf_mem_register+0x14e>
   29f1a:	e7d8      	b.n	29ece <nrf_mem_register+0x1ca>
   29f1c:	9d04      	ldr	r5, [sp, #16]
   29f1e:	e7d8      	b.n	29ed2 <nrf_mem_register+0x1ce>
   29f20:	9d04      	ldr	r5, [sp, #16]
   29f22:	f10a 0601 	add.w	r6, sl, #1
   29f26:	e7d4      	b.n	29ed2 <nrf_mem_register+0x1ce>
   29f28:	2002908c 	.word	0x2002908c
   29f2c:	20022944 	.word	0x20022944
   29f30:	20022948 	.word	0x20022948
   29f34:	20022984 	.word	0x20022984

00029f38 <nrf_malloc>:
   29f38:	4b03      	ldr	r3, [pc, #12]	; (29f48 <nrf_malloc+0x10>)
   29f3a:	781b      	ldrb	r3, [r3, #0]
   29f3c:	b10b      	cbz	r3, 29f42 <nrf_malloc+0xa>
   29f3e:	f7ff bd8d 	b.w	29a5c <mem_alloc.constprop.4>
   29f42:	4618      	mov	r0, r3
   29f44:	4770      	bx	lr
   29f46:	bf00      	nop
   29f48:	2002908c 	.word	0x2002908c

00029f4c <nrf_free>:
   29f4c:	4b04      	ldr	r3, [pc, #16]	; (29f60 <nrf_free+0x14>)
   29f4e:	781b      	ldrb	r3, [r3, #0]
   29f50:	b123      	cbz	r3, 29f5c <nrf_free+0x10>
   29f52:	b118      	cbz	r0, 29f5c <nrf_free+0x10>
   29f54:	4601      	mov	r1, r0
   29f56:	2000      	movs	r0, #0
   29f58:	f7ff bc30 	b.w	297bc <mem_free>
   29f5c:	4770      	bx	lr
   29f5e:	bf00      	nop
   29f60:	2002908c 	.word	0x2002908c

00029f64 <nrf_shared_malloc>:
   29f64:	4b03      	ldr	r3, [pc, #12]	; (29f74 <nrf_shared_malloc+0x10>)
   29f66:	781b      	ldrb	r3, [r3, #0]
   29f68:	b10b      	cbz	r3, 29f6e <nrf_shared_malloc+0xa>
   29f6a:	f7ff bc93 	b.w	29894 <mem_alloc.constprop.5>
   29f6e:	4618      	mov	r0, r3
   29f70:	4770      	bx	lr
   29f72:	bf00      	nop
   29f74:	2002908c 	.word	0x2002908c

00029f78 <nrf_shared_free>:
   29f78:	4b04      	ldr	r3, [pc, #16]	; (29f8c <nrf_shared_free+0x14>)
   29f7a:	781b      	ldrb	r3, [r3, #0]
   29f7c:	b123      	cbz	r3, 29f88 <nrf_shared_free+0x10>
   29f7e:	b118      	cbz	r0, 29f88 <nrf_shared_free+0x10>
   29f80:	4601      	mov	r1, r0
   29f82:	2001      	movs	r0, #1
   29f84:	f7ff bc1a 	b.w	297bc <mem_free>
   29f88:	4770      	bx	lr
   29f8a:	bf00      	nop
   29f8c:	2002908c 	.word	0x2002908c

00029f90 <rpc_dfu_event_handler>:
   29f90:	b508      	push	{r3, lr}
   29f92:	4a08      	ldr	r2, [pc, #32]	; (29fb4 <rpc_dfu_event_handler+0x24>)
   29f94:	68c1      	ldr	r1, [r0, #12]
   29f96:	8812      	ldrh	r2, [r2, #0]
   29f98:	4603      	mov	r3, r0
   29f9a:	ebb2 4f11 	cmp.w	r2, r1, lsr #16
   29f9e:	d005      	beq.n	29fac <rpc_dfu_event_handler+0x1c>
   29fa0:	6800      	ldr	r0, [r0, #0]
   29fa2:	b110      	cbz	r0, 29faa <rpc_dfu_event_handler+0x1a>
   29fa4:	f7fd fa60 	bl	27468 <rpc_dfu_client_data_free>
   29fa8:	2000      	movs	r0, #0
   29faa:	bd08      	pop	{r3, pc}
   29fac:	4a02      	ldr	r2, [pc, #8]	; (29fb8 <rpc_dfu_event_handler+0x28>)
   29fae:	2001      	movs	r0, #1
   29fb0:	6013      	str	r3, [r2, #0]
   29fb2:	bd08      	pop	{r3, pc}
   29fb4:	20027620 	.word	0x20027620
   29fb8:	20022aa0 	.word	0x20022aa0

00029fbc <mfu_interface_init>:
   29fbc:	2300      	movs	r3, #0
   29fbe:	b510      	push	{r4, lr}
   29fc0:	4808      	ldr	r0, [pc, #32]	; (29fe4 <mfu_interface_init+0x28>)
   29fc2:	4909      	ldr	r1, [pc, #36]	; (29fe8 <mfu_interface_init+0x2c>)
   29fc4:	4a09      	ldr	r2, [pc, #36]	; (29fec <mfu_interface_init+0x30>)
   29fc6:	4c0a      	ldr	r4, [pc, #40]	; (29ff0 <mfu_interface_init+0x34>)
   29fc8:	8003      	strh	r3, [r0, #0]
   29fca:	600b      	str	r3, [r1, #0]
   29fcc:	6013      	str	r3, [r2, #0]
   29fce:	6023      	str	r3, [r4, #0]
   29fd0:	f7fd fa14 	bl	273fc <rpc_dfu_client_init>
   29fd4:	b910      	cbnz	r0, 29fdc <mfu_interface_init+0x20>
   29fd6:	2301      	movs	r3, #1
   29fd8:	6023      	str	r3, [r4, #0]
   29fda:	bd10      	pop	{r4, pc}
   29fdc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   29fe0:	bd10      	pop	{r4, pc}
   29fe2:	bf00      	nop
   29fe4:	20027620 	.word	0x20027620
   29fe8:	20022aa0 	.word	0x20022aa0
   29fec:	20022a9c 	.word	0x20022a9c
   29ff0:	20022a94 	.word	0x20022a94

00029ff4 <mfu_interface_open>:
   29ff4:	b508      	push	{r3, lr}
   29ff6:	4b07      	ldr	r3, [pc, #28]	; (2a014 <mfu_interface_open+0x20>)
   29ff8:	681a      	ldr	r2, [r3, #0]
   29ffa:	2a01      	cmp	r2, #1
   29ffc:	d103      	bne.n	2a006 <mfu_interface_open+0x12>
   29ffe:	2202      	movs	r2, #2
   2a000:	601a      	str	r2, [r3, #0]
   2a002:	4805      	ldr	r0, [pc, #20]	; (2a018 <mfu_interface_open+0x24>)
   2a004:	bd08      	pop	{r3, pc}
   2a006:	2001      	movs	r0, #1
   2a008:	f7f6 f82a 	bl	20060 <bsd_os_errno_set>
   2a00c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a010:	bd08      	pop	{r3, pc}
   2a012:	bf00      	nop
   2a014:	20022a94 	.word	0x20022a94
   2a018:	49765432 	.word	0x49765432

0002a01c <mfu_interface_close>:
   2a01c:	b5f0      	push	{r4, r5, r6, r7, lr}
   2a01e:	4c32      	ldr	r4, [pc, #200]	; (2a0e8 <mfu_interface_close+0xcc>)
   2a020:	b083      	sub	sp, #12
   2a022:	6823      	ldr	r3, [r4, #0]
   2a024:	1e9a      	subs	r2, r3, #2
   2a026:	2a01      	cmp	r2, #1
   2a028:	d857      	bhi.n	2a0da <mfu_interface_close+0xbe>
   2a02a:	2b03      	cmp	r3, #3
   2a02c:	d004      	beq.n	2a038 <mfu_interface_close+0x1c>
   2a02e:	2301      	movs	r3, #1
   2a030:	2000      	movs	r0, #0
   2a032:	6023      	str	r3, [r4, #0]
   2a034:	b003      	add	sp, #12
   2a036:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a038:	2100      	movs	r1, #0
   2a03a:	4668      	mov	r0, sp
   2a03c:	f7fd f9e4 	bl	27408 <rpc_dfu_client_request_alloc>
   2a040:	4603      	mov	r3, r0
   2a042:	2800      	cmp	r0, #0
   2a044:	d13d      	bne.n	2a0c2 <mfu_interface_close+0xa6>
   2a046:	2104      	movs	r1, #4
   2a048:	4e28      	ldr	r6, [pc, #160]	; (2a0ec <mfu_interface_close+0xd0>)
   2a04a:	9800      	ldr	r0, [sp, #0]
   2a04c:	8832      	ldrh	r2, [r6, #0]
   2a04e:	7201      	strb	r1, [r0, #8]
   2a050:	3201      	adds	r2, #1
   2a052:	b292      	uxth	r2, r2
   2a054:	0411      	lsls	r1, r2, #16
   2a056:	f041 0106 	orr.w	r1, r1, #6
   2a05a:	4d25      	ldr	r5, [pc, #148]	; (2a0f0 <mfu_interface_close+0xd4>)
   2a05c:	60c1      	str	r1, [r0, #12]
   2a05e:	7103      	strb	r3, [r0, #4]
   2a060:	7143      	strb	r3, [r0, #5]
   2a062:	7183      	strb	r3, [r0, #6]
   2a064:	71c3      	strb	r3, [r0, #7]
   2a066:	7243      	strb	r3, [r0, #9]
   2a068:	7283      	strb	r3, [r0, #10]
   2a06a:	72c3      	strb	r3, [r0, #11]
   2a06c:	2106      	movs	r1, #6
   2a06e:	8032      	strh	r2, [r6, #0]
   2a070:	602b      	str	r3, [r5, #0]
   2a072:	f7fd f9dd 	bl	27430 <rpc_dfu_client_request_send>
   2a076:	b9d8      	cbnz	r0, 2a0b0 <mfu_interface_close+0x94>
   2a078:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a07c:	ae02      	add	r6, sp, #8
   2a07e:	4627      	mov	r7, r4
   2a080:	f846 3d04 	str.w	r3, [r6, #-4]!
   2a084:	e004      	b.n	2a090 <mfu_interface_close+0x74>
   2a086:	4631      	mov	r1, r6
   2a088:	4638      	mov	r0, r7
   2a08a:	f7f5 ff3f 	bl	1ff0c <bsd_os_timedwait>
   2a08e:	b9f0      	cbnz	r0, 2a0ce <mfu_interface_close+0xb2>
   2a090:	6828      	ldr	r0, [r5, #0]
   2a092:	2800      	cmp	r0, #0
   2a094:	d0f7      	beq.n	2a086 <mfu_interface_close+0x6a>
   2a096:	6905      	ldr	r5, [r0, #16]
   2a098:	f7fd f9de 	bl	27458 <rpc_dfu_client_message_free>
   2a09c:	2d00      	cmp	r5, #0
   2a09e:	d0c6      	beq.n	2a02e <mfu_interface_close+0x12>
   2a0a0:	4b14      	ldr	r3, [pc, #80]	; (2a0f4 <mfu_interface_close+0xd8>)
   2a0a2:	2008      	movs	r0, #8
   2a0a4:	601d      	str	r5, [r3, #0]
   2a0a6:	f7f5 ffdb 	bl	20060 <bsd_os_errno_set>
   2a0aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a0ae:	e7c1      	b.n	2a034 <mfu_interface_close+0x18>
   2a0b0:	9800      	ldr	r0, [sp, #0]
   2a0b2:	6803      	ldr	r3, [r0, #0]
   2a0b4:	b11b      	cbz	r3, 2a0be <mfu_interface_close+0xa2>
   2a0b6:	4618      	mov	r0, r3
   2a0b8:	f7fd f9d6 	bl	27468 <rpc_dfu_client_data_free>
   2a0bc:	9800      	ldr	r0, [sp, #0]
   2a0be:	f7fd f9cb 	bl	27458 <rpc_dfu_client_message_free>
   2a0c2:	200c      	movs	r0, #12
   2a0c4:	f7f5 ffcc 	bl	20060 <bsd_os_errno_set>
   2a0c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a0cc:	e7b2      	b.n	2a034 <mfu_interface_close+0x18>
   2a0ce:	203c      	movs	r0, #60	; 0x3c
   2a0d0:	f7f5 ffc6 	bl	20060 <bsd_os_errno_set>
   2a0d4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a0d8:	e7ac      	b.n	2a034 <mfu_interface_close+0x18>
   2a0da:	2001      	movs	r0, #1
   2a0dc:	f7f5 ffc0 	bl	20060 <bsd_os_errno_set>
   2a0e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a0e4:	e7a6      	b.n	2a034 <mfu_interface_close+0x18>
   2a0e6:	bf00      	nop
   2a0e8:	20022a94 	.word	0x20022a94
   2a0ec:	20027620 	.word	0x20027620
   2a0f0:	20022aa0 	.word	0x20022aa0
   2a0f4:	20022a98 	.word	0x20022a98

0002a0f8 <mfu_interface_sendto>:
   2a0f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2a0fc:	4e64      	ldr	r6, [pc, #400]	; (2a290 <mfu_interface_sendto+0x198>)
   2a0fe:	460f      	mov	r7, r1
   2a100:	6831      	ldr	r1, [r6, #0]
   2a102:	4615      	mov	r5, r2
   2a104:	1e8a      	subs	r2, r1, #2
   2a106:	2a01      	cmp	r2, #1
   2a108:	b082      	sub	sp, #8
   2a10a:	f200 80b4 	bhi.w	2a276 <mfu_interface_sendto+0x17e>
   2a10e:	2f00      	cmp	r7, #0
   2a110:	f000 80a5 	beq.w	2a25e <mfu_interface_sendto+0x166>
   2a114:	2d00      	cmp	r5, #0
   2a116:	f000 80a2 	beq.w	2a25e <mfu_interface_sendto+0x166>
   2a11a:	2b00      	cmp	r3, #0
   2a11c:	f040 80b1 	bne.w	2a282 <mfu_interface_sendto+0x18a>
   2a120:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   2a122:	2b00      	cmp	r3, #0
   2a124:	f040 80a1 	bne.w	2a26a <mfu_interface_sendto+0x172>
   2a128:	2902      	cmp	r1, #2
   2a12a:	d04f      	beq.n	2a1cc <mfu_interface_sendto+0xd4>
   2a12c:	46e8      	mov	r8, sp
   2a12e:	4640      	mov	r0, r8
   2a130:	4629      	mov	r1, r5
   2a132:	f7fd f969 	bl	27408 <rpc_dfu_client_request_alloc>
   2a136:	4606      	mov	r6, r0
   2a138:	b140      	cbz	r0, 2a14c <mfu_interface_sendto+0x54>
   2a13a:	200c      	movs	r0, #12
   2a13c:	f7f5 ff90 	bl	20060 <bsd_os_errno_set>
   2a140:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a144:	4628      	mov	r0, r5
   2a146:	b002      	add	sp, #8
   2a148:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a14c:	9b00      	ldr	r3, [sp, #0]
   2a14e:	4639      	mov	r1, r7
   2a150:	6818      	ldr	r0, [r3, #0]
   2a152:	462a      	mov	r2, r5
   2a154:	f00e ff40 	bl	38fd8 <memcpy>
   2a158:	2104      	movs	r1, #4
   2a15a:	4c4e      	ldr	r4, [pc, #312]	; (2a294 <mfu_interface_sendto+0x19c>)
   2a15c:	9800      	ldr	r0, [sp, #0]
   2a15e:	8823      	ldrh	r3, [r4, #0]
   2a160:	6045      	str	r5, [r0, #4]
   2a162:	3301      	adds	r3, #1
   2a164:	b29b      	uxth	r3, r3
   2a166:	041a      	lsls	r2, r3, #16
   2a168:	8023      	strh	r3, [r4, #0]
   2a16a:	430a      	orrs	r2, r1
   2a16c:	4c4a      	ldr	r4, [pc, #296]	; (2a298 <mfu_interface_sendto+0x1a0>)
   2a16e:	60c2      	str	r2, [r0, #12]
   2a170:	7246      	strb	r6, [r0, #9]
   2a172:	7286      	strb	r6, [r0, #10]
   2a174:	72c6      	strb	r6, [r0, #11]
   2a176:	7201      	strb	r1, [r0, #8]
   2a178:	6026      	str	r6, [r4, #0]
   2a17a:	f7fd f959 	bl	27430 <rpc_dfu_client_request_send>
   2a17e:	2800      	cmp	r0, #0
   2a180:	d163      	bne.n	2a24a <mfu_interface_sendto+0x152>
   2a182:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a186:	ae02      	add	r6, sp, #8
   2a188:	4f41      	ldr	r7, [pc, #260]	; (2a290 <mfu_interface_sendto+0x198>)
   2a18a:	f846 3d04 	str.w	r3, [r6, #-4]!
   2a18e:	e004      	b.n	2a19a <mfu_interface_sendto+0xa2>
   2a190:	4631      	mov	r1, r6
   2a192:	4638      	mov	r0, r7
   2a194:	f7f5 feba 	bl	1ff0c <bsd_os_timedwait>
   2a198:	b978      	cbnz	r0, 2a1ba <mfu_interface_sendto+0xc2>
   2a19a:	6820      	ldr	r0, [r4, #0]
   2a19c:	2800      	cmp	r0, #0
   2a19e:	d0f7      	beq.n	2a190 <mfu_interface_sendto+0x98>
   2a1a0:	6904      	ldr	r4, [r0, #16]
   2a1a2:	f7fd f959 	bl	27458 <rpc_dfu_client_message_free>
   2a1a6:	2c00      	cmp	r4, #0
   2a1a8:	d0cc      	beq.n	2a144 <mfu_interface_sendto+0x4c>
   2a1aa:	4b3c      	ldr	r3, [pc, #240]	; (2a29c <mfu_interface_sendto+0x1a4>)
   2a1ac:	2008      	movs	r0, #8
   2a1ae:	601c      	str	r4, [r3, #0]
   2a1b0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a1b4:	f7f5 ff54 	bl	20060 <bsd_os_errno_set>
   2a1b8:	e7c4      	b.n	2a144 <mfu_interface_sendto+0x4c>
   2a1ba:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a1be:	203c      	movs	r0, #60	; 0x3c
   2a1c0:	f7f5 ff4e 	bl	20060 <bsd_os_errno_set>
   2a1c4:	4628      	mov	r0, r5
   2a1c6:	b002      	add	sp, #8
   2a1c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   2a1cc:	46e8      	mov	r8, sp
   2a1ce:	4619      	mov	r1, r3
   2a1d0:	4640      	mov	r0, r8
   2a1d2:	f7fd f919 	bl	27408 <rpc_dfu_client_request_alloc>
   2a1d6:	4602      	mov	r2, r0
   2a1d8:	2800      	cmp	r0, #0
   2a1da:	d1ae      	bne.n	2a13a <mfu_interface_sendto+0x42>
   2a1dc:	f04f 0c08 	mov.w	ip, #8
   2a1e0:	492c      	ldr	r1, [pc, #176]	; (2a294 <mfu_interface_sendto+0x19c>)
   2a1e2:	482f      	ldr	r0, [pc, #188]	; (2a2a0 <mfu_interface_sendto+0x1a8>)
   2a1e4:	880b      	ldrh	r3, [r1, #0]
   2a1e6:	6804      	ldr	r4, [r0, #0]
   2a1e8:	3301      	adds	r3, #1
   2a1ea:	9800      	ldr	r0, [sp, #0]
   2a1ec:	b29b      	uxth	r3, r3
   2a1ee:	800b      	strh	r3, [r1, #0]
   2a1f0:	041b      	lsls	r3, r3, #16
   2a1f2:	f043 0303 	orr.w	r3, r3, #3
   2a1f6:	6104      	str	r4, [r0, #16]
   2a1f8:	4c27      	ldr	r4, [pc, #156]	; (2a298 <mfu_interface_sendto+0x1a0>)
   2a1fa:	60c3      	str	r3, [r0, #12]
   2a1fc:	7102      	strb	r2, [r0, #4]
   2a1fe:	7142      	strb	r2, [r0, #5]
   2a200:	7182      	strb	r2, [r0, #6]
   2a202:	71c2      	strb	r2, [r0, #7]
   2a204:	7242      	strb	r2, [r0, #9]
   2a206:	7282      	strb	r2, [r0, #10]
   2a208:	72c2      	strb	r2, [r0, #11]
   2a20a:	f880 c008 	strb.w	ip, [r0, #8]
   2a20e:	2103      	movs	r1, #3
   2a210:	6022      	str	r2, [r4, #0]
   2a212:	f7fd f90d 	bl	27430 <rpc_dfu_client_request_send>
   2a216:	b9c0      	cbnz	r0, 2a24a <mfu_interface_sendto+0x152>
   2a218:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a21c:	f10d 0908 	add.w	r9, sp, #8
   2a220:	f849 3d04 	str.w	r3, [r9, #-4]!
   2a224:	46b2      	mov	sl, r6
   2a226:	e005      	b.n	2a234 <mfu_interface_sendto+0x13c>
   2a228:	4649      	mov	r1, r9
   2a22a:	4650      	mov	r0, sl
   2a22c:	f7f5 fe6e 	bl	1ff0c <bsd_os_timedwait>
   2a230:	2800      	cmp	r0, #0
   2a232:	d1c2      	bne.n	2a1ba <mfu_interface_sendto+0xc2>
   2a234:	6820      	ldr	r0, [r4, #0]
   2a236:	2800      	cmp	r0, #0
   2a238:	d0f6      	beq.n	2a228 <mfu_interface_sendto+0x130>
   2a23a:	6904      	ldr	r4, [r0, #16]
   2a23c:	f7fd f90c 	bl	27458 <rpc_dfu_client_message_free>
   2a240:	2c00      	cmp	r4, #0
   2a242:	d1b2      	bne.n	2a1aa <mfu_interface_sendto+0xb2>
   2a244:	2303      	movs	r3, #3
   2a246:	6033      	str	r3, [r6, #0]
   2a248:	e771      	b.n	2a12e <mfu_interface_sendto+0x36>
   2a24a:	9800      	ldr	r0, [sp, #0]
   2a24c:	6803      	ldr	r3, [r0, #0]
   2a24e:	b11b      	cbz	r3, 2a258 <mfu_interface_sendto+0x160>
   2a250:	4618      	mov	r0, r3
   2a252:	f7fd f909 	bl	27468 <rpc_dfu_client_data_free>
   2a256:	9800      	ldr	r0, [sp, #0]
   2a258:	f7fd f8fe 	bl	27458 <rpc_dfu_client_message_free>
   2a25c:	e76d      	b.n	2a13a <mfu_interface_sendto+0x42>
   2a25e:	2016      	movs	r0, #22
   2a260:	f7f5 fefe 	bl	20060 <bsd_os_errno_set>
   2a264:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a268:	e76c      	b.n	2a144 <mfu_interface_sendto+0x4c>
   2a26a:	2038      	movs	r0, #56	; 0x38
   2a26c:	f7f5 fef8 	bl	20060 <bsd_os_errno_set>
   2a270:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a274:	e766      	b.n	2a144 <mfu_interface_sendto+0x4c>
   2a276:	2001      	movs	r0, #1
   2a278:	f7f5 fef2 	bl	20060 <bsd_os_errno_set>
   2a27c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a280:	e760      	b.n	2a144 <mfu_interface_sendto+0x4c>
   2a282:	202d      	movs	r0, #45	; 0x2d
   2a284:	f7f5 feec 	bl	20060 <bsd_os_errno_set>
   2a288:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a28c:	e75a      	b.n	2a144 <mfu_interface_sendto+0x4c>
   2a28e:	bf00      	nop
   2a290:	20022a94 	.word	0x20022a94
   2a294:	20027620 	.word	0x20027620
   2a298:	20022aa0 	.word	0x20022aa0
   2a29c:	20022a98 	.word	0x20022a98
   2a2a0:	20022a9c 	.word	0x20022a9c

0002a2a4 <mfu_interface_setopt>:
   2a2a4:	b5f0      	push	{r4, r5, r6, r7, lr}
   2a2a6:	4846      	ldr	r0, [pc, #280]	; (2a3c0 <mfu_interface_setopt+0x11c>)
   2a2a8:	b083      	sub	sp, #12
   2a2aa:	6800      	ldr	r0, [r0, #0]
   2a2ac:	3802      	subs	r0, #2
   2a2ae:	2801      	cmp	r0, #1
   2a2b0:	d877      	bhi.n	2a3a2 <mfu_interface_setopt+0xfe>
   2a2b2:	f240 2003 	movw	r0, #515	; 0x203
   2a2b6:	4281      	cmp	r1, r0
   2a2b8:	d16d      	bne.n	2a396 <mfu_interface_setopt+0xf2>
   2a2ba:	3a04      	subs	r2, #4
   2a2bc:	2a03      	cmp	r2, #3
   2a2be:	d85c      	bhi.n	2a37a <mfu_interface_setopt+0xd6>
   2a2c0:	e8df f002 	tbb	[pc, r2]
   2a2c4:	514e024b 	.word	0x514e024b
   2a2c8:	2407      	movs	r4, #7
   2a2ca:	4625      	mov	r5, r4
   2a2cc:	2100      	movs	r1, #0
   2a2ce:	4668      	mov	r0, sp
   2a2d0:	f7fd f89a 	bl	27408 <rpc_dfu_client_request_alloc>
   2a2d4:	4603      	mov	r3, r0
   2a2d6:	2800      	cmp	r0, #0
   2a2d8:	d138      	bne.n	2a34c <mfu_interface_setopt+0xa8>
   2a2da:	2704      	movs	r7, #4
   2a2dc:	4e39      	ldr	r6, [pc, #228]	; (2a3c4 <mfu_interface_setopt+0x120>)
   2a2de:	9800      	ldr	r0, [sp, #0]
   2a2e0:	8832      	ldrh	r2, [r6, #0]
   2a2e2:	4629      	mov	r1, r5
   2a2e4:	3201      	adds	r2, #1
   2a2e6:	b292      	uxth	r2, r2
   2a2e8:	ea44 4502 	orr.w	r5, r4, r2, lsl #16
   2a2ec:	4c36      	ldr	r4, [pc, #216]	; (2a3c8 <mfu_interface_setopt+0x124>)
   2a2ee:	60c5      	str	r5, [r0, #12]
   2a2f0:	7103      	strb	r3, [r0, #4]
   2a2f2:	7143      	strb	r3, [r0, #5]
   2a2f4:	7183      	strb	r3, [r0, #6]
   2a2f6:	71c3      	strb	r3, [r0, #7]
   2a2f8:	7243      	strb	r3, [r0, #9]
   2a2fa:	7283      	strb	r3, [r0, #10]
   2a2fc:	72c3      	strb	r3, [r0, #11]
   2a2fe:	7207      	strb	r7, [r0, #8]
   2a300:	8032      	strh	r2, [r6, #0]
   2a302:	6023      	str	r3, [r4, #0]
   2a304:	f7fd f894 	bl	27430 <rpc_dfu_client_request_send>
   2a308:	b9b8      	cbnz	r0, 2a33a <mfu_interface_setopt+0x96>
   2a30a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a30e:	ad02      	add	r5, sp, #8
   2a310:	4e2b      	ldr	r6, [pc, #172]	; (2a3c0 <mfu_interface_setopt+0x11c>)
   2a312:	f845 3d04 	str.w	r3, [r5, #-4]!
   2a316:	e005      	b.n	2a324 <mfu_interface_setopt+0x80>
   2a318:	4629      	mov	r1, r5
   2a31a:	4630      	mov	r0, r6
   2a31c:	f7f5 fdf6 	bl	1ff0c <bsd_os_timedwait>
   2a320:	2800      	cmp	r0, #0
   2a322:	d131      	bne.n	2a388 <mfu_interface_setopt+0xe4>
   2a324:	6820      	ldr	r0, [r4, #0]
   2a326:	2800      	cmp	r0, #0
   2a328:	d0f6      	beq.n	2a318 <mfu_interface_setopt+0x74>
   2a32a:	6904      	ldr	r4, [r0, #16]
   2a32c:	f7fd f894 	bl	27458 <rpc_dfu_client_message_free>
   2a330:	2c00      	cmp	r4, #0
   2a332:	d13c      	bne.n	2a3ae <mfu_interface_setopt+0x10a>
   2a334:	4620      	mov	r0, r4
   2a336:	b003      	add	sp, #12
   2a338:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a33a:	9800      	ldr	r0, [sp, #0]
   2a33c:	6803      	ldr	r3, [r0, #0]
   2a33e:	b11b      	cbz	r3, 2a348 <mfu_interface_setopt+0xa4>
   2a340:	4618      	mov	r0, r3
   2a342:	f7fd f891 	bl	27468 <rpc_dfu_client_data_free>
   2a346:	9800      	ldr	r0, [sp, #0]
   2a348:	f7fd f886 	bl	27458 <rpc_dfu_client_message_free>
   2a34c:	200c      	movs	r0, #12
   2a34e:	f7f5 fe87 	bl	20060 <bsd_os_errno_set>
   2a352:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a356:	b003      	add	sp, #12
   2a358:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a35a:	2405      	movs	r4, #5
   2a35c:	4625      	mov	r5, r4
   2a35e:	e7b5      	b.n	2a2cc <mfu_interface_setopt+0x28>
   2a360:	2408      	movs	r4, #8
   2a362:	4625      	mov	r5, r4
   2a364:	e7b2      	b.n	2a2cc <mfu_interface_setopt+0x28>
   2a366:	b1b3      	cbz	r3, 2a396 <mfu_interface_setopt+0xf2>
   2a368:	9a08      	ldr	r2, [sp, #32]
   2a36a:	2a04      	cmp	r2, #4
   2a36c:	d113      	bne.n	2a396 <mfu_interface_setopt+0xf2>
   2a36e:	2000      	movs	r0, #0
   2a370:	681a      	ldr	r2, [r3, #0]
   2a372:	4b16      	ldr	r3, [pc, #88]	; (2a3cc <mfu_interface_setopt+0x128>)
   2a374:	601a      	str	r2, [r3, #0]
   2a376:	b003      	add	sp, #12
   2a378:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a37a:	202a      	movs	r0, #42	; 0x2a
   2a37c:	f7f5 fe70 	bl	20060 <bsd_os_errno_set>
   2a380:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a384:	b003      	add	sp, #12
   2a386:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a388:	203c      	movs	r0, #60	; 0x3c
   2a38a:	f7f5 fe69 	bl	20060 <bsd_os_errno_set>
   2a38e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a392:	b003      	add	sp, #12
   2a394:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2a396:	2016      	movs	r0, #22
   2a398:	f7f5 fe62 	bl	20060 <bsd_os_errno_set>
   2a39c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a3a0:	e7c9      	b.n	2a336 <mfu_interface_setopt+0x92>
   2a3a2:	2001      	movs	r0, #1
   2a3a4:	f7f5 fe5c 	bl	20060 <bsd_os_errno_set>
   2a3a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a3ac:	e7c3      	b.n	2a336 <mfu_interface_setopt+0x92>
   2a3ae:	4b08      	ldr	r3, [pc, #32]	; (2a3d0 <mfu_interface_setopt+0x12c>)
   2a3b0:	2008      	movs	r0, #8
   2a3b2:	601c      	str	r4, [r3, #0]
   2a3b4:	f7f5 fe54 	bl	20060 <bsd_os_errno_set>
   2a3b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a3bc:	e7bb      	b.n	2a336 <mfu_interface_setopt+0x92>
   2a3be:	bf00      	nop
   2a3c0:	20022a94 	.word	0x20022a94
   2a3c4:	20027620 	.word	0x20027620
   2a3c8:	20022aa0 	.word	0x20022aa0
   2a3cc:	20022a9c 	.word	0x20022a9c
   2a3d0:	20022a98 	.word	0x20022a98

0002a3d4 <mfu_interface_getopt>:
   2a3d4:	f240 2003 	movw	r0, #515	; 0x203
   2a3d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a3dc:	4281      	cmp	r1, r0
   2a3de:	b082      	sub	sp, #8
   2a3e0:	9e08      	ldr	r6, [sp, #32]
   2a3e2:	f040 80ae 	bne.w	2a542 <mfu_interface_getopt+0x16e>
   2a3e6:	461d      	mov	r5, r3
   2a3e8:	2b00      	cmp	r3, #0
   2a3ea:	f000 80aa 	beq.w	2a542 <mfu_interface_getopt+0x16e>
   2a3ee:	2e00      	cmp	r6, #0
   2a3f0:	f000 80a7 	beq.w	2a542 <mfu_interface_getopt+0x16e>
   2a3f4:	4b5e      	ldr	r3, [pc, #376]	; (2a570 <mfu_interface_getopt+0x19c>)
   2a3f6:	681b      	ldr	r3, [r3, #0]
   2a3f8:	3b02      	subs	r3, #2
   2a3fa:	2b01      	cmp	r3, #1
   2a3fc:	f200 80a7 	bhi.w	2a54e <mfu_interface_getopt+0x17a>
   2a400:	3a01      	subs	r2, #1
   2a402:	2a13      	cmp	r2, #19
   2a404:	d879      	bhi.n	2a4fa <mfu_interface_getopt+0x126>
   2a406:	e8df f002 	tbb	[pc, r2]
   2a40a:	5f17      	.short	0x5f17
   2a40c:	78787878 	.word	0x78787878
   2a410:	78787872 	.word	0x78787872
   2a414:	78787878 	.word	0x78787878
   2a418:	78787878 	.word	0x78787878
   2a41c:	0a78      	.short	0x0a78
   2a41e:	6833      	ldr	r3, [r6, #0]
   2a420:	2b04      	cmp	r3, #4
   2a422:	f040 808e 	bne.w	2a542 <mfu_interface_getopt+0x16e>
   2a426:	2200      	movs	r2, #0
   2a428:	4610      	mov	r0, r2
   2a42a:	4b52      	ldr	r3, [pc, #328]	; (2a574 <mfu_interface_getopt+0x1a0>)
   2a42c:	6819      	ldr	r1, [r3, #0]
   2a42e:	601a      	str	r2, [r3, #0]
   2a430:	6029      	str	r1, [r5, #0]
   2a432:	b002      	add	sp, #8
   2a434:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a438:	6833      	ldr	r3, [r6, #0]
   2a43a:	2b24      	cmp	r3, #36	; 0x24
   2a43c:	f040 8081 	bne.w	2a542 <mfu_interface_getopt+0x16e>
   2a440:	2401      	movs	r4, #1
   2a442:	46a0      	mov	r8, r4
   2a444:	2100      	movs	r1, #0
   2a446:	4668      	mov	r0, sp
   2a448:	f7fc ffde 	bl	27408 <rpc_dfu_client_request_alloc>
   2a44c:	2800      	cmp	r0, #0
   2a44e:	d146      	bne.n	2a4de <mfu_interface_getopt+0x10a>
   2a450:	4949      	ldr	r1, [pc, #292]	; (2a578 <mfu_interface_getopt+0x1a4>)
   2a452:	9b00      	ldr	r3, [sp, #0]
   2a454:	880a      	ldrh	r2, [r1, #0]
   2a456:	f1b8 0f03 	cmp.w	r8, #3
   2a45a:	f102 0201 	add.w	r2, r2, #1
   2a45e:	b292      	uxth	r2, r2
   2a460:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
   2a464:	7118      	strb	r0, [r3, #4]
   2a466:	800a      	strh	r2, [r1, #0]
   2a468:	60dc      	str	r4, [r3, #12]
   2a46a:	7158      	strb	r0, [r3, #5]
   2a46c:	7198      	strb	r0, [r3, #6]
   2a46e:	71d8      	strb	r0, [r3, #7]
   2a470:	d04b      	beq.n	2a50a <mfu_interface_getopt+0x136>
   2a472:	2104      	movs	r1, #4
   2a474:	2200      	movs	r2, #0
   2a476:	4f41      	ldr	r7, [pc, #260]	; (2a57c <mfu_interface_getopt+0x1a8>)
   2a478:	6099      	str	r1, [r3, #8]
   2a47a:	4618      	mov	r0, r3
   2a47c:	4641      	mov	r1, r8
   2a47e:	603a      	str	r2, [r7, #0]
   2a480:	f7fc ffd6 	bl	27430 <rpc_dfu_client_request_send>
   2a484:	2800      	cmp	r0, #0
   2a486:	d14d      	bne.n	2a524 <mfu_interface_getopt+0x150>
   2a488:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2a48c:	ac02      	add	r4, sp, #8
   2a48e:	f844 3d04 	str.w	r3, [r4, #-4]!
   2a492:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 2a570 <mfu_interface_getopt+0x19c>
   2a496:	e005      	b.n	2a4a4 <mfu_interface_getopt+0xd0>
   2a498:	4621      	mov	r1, r4
   2a49a:	4640      	mov	r0, r8
   2a49c:	f7f5 fd36 	bl	1ff0c <bsd_os_timedwait>
   2a4a0:	2800      	cmp	r0, #0
   2a4a2:	d137      	bne.n	2a514 <mfu_interface_getopt+0x140>
   2a4a4:	6839      	ldr	r1, [r7, #0]
   2a4a6:	2900      	cmp	r1, #0
   2a4a8:	d0f6      	beq.n	2a498 <mfu_interface_getopt+0xc4>
   2a4aa:	690c      	ldr	r4, [r1, #16]
   2a4ac:	2c00      	cmp	r4, #0
   2a4ae:	d154      	bne.n	2a55a <mfu_interface_getopt+0x186>
   2a4b0:	6832      	ldr	r2, [r6, #0]
   2a4b2:	3114      	adds	r1, #20
   2a4b4:	4628      	mov	r0, r5
   2a4b6:	f00e fd8f 	bl	38fd8 <memcpy>
   2a4ba:	6838      	ldr	r0, [r7, #0]
   2a4bc:	f7fc ffcc 	bl	27458 <rpc_dfu_client_message_free>
   2a4c0:	4620      	mov	r0, r4
   2a4c2:	b002      	add	sp, #8
   2a4c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a4c8:	6833      	ldr	r3, [r6, #0]
   2a4ca:	2b04      	cmp	r3, #4
   2a4cc:	d139      	bne.n	2a542 <mfu_interface_getopt+0x16e>
   2a4ce:	2402      	movs	r4, #2
   2a4d0:	2100      	movs	r1, #0
   2a4d2:	4668      	mov	r0, sp
   2a4d4:	46a0      	mov	r8, r4
   2a4d6:	f7fc ff97 	bl	27408 <rpc_dfu_client_request_alloc>
   2a4da:	2800      	cmp	r0, #0
   2a4dc:	d0b8      	beq.n	2a450 <mfu_interface_getopt+0x7c>
   2a4de:	200c      	movs	r0, #12
   2a4e0:	f7f5 fdbe 	bl	20060 <bsd_os_errno_set>
   2a4e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a4e8:	b002      	add	sp, #8
   2a4ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a4ee:	6833      	ldr	r3, [r6, #0]
   2a4f0:	2b04      	cmp	r3, #4
   2a4f2:	d126      	bne.n	2a542 <mfu_interface_getopt+0x16e>
   2a4f4:	2409      	movs	r4, #9
   2a4f6:	46a0      	mov	r8, r4
   2a4f8:	e7a4      	b.n	2a444 <mfu_interface_getopt+0x70>
   2a4fa:	202a      	movs	r0, #42	; 0x2a
   2a4fc:	f7f5 fdb0 	bl	20060 <bsd_os_errno_set>
   2a500:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a504:	b002      	add	sp, #8
   2a506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a50a:	4a1d      	ldr	r2, [pc, #116]	; (2a580 <mfu_interface_getopt+0x1ac>)
   2a50c:	2108      	movs	r1, #8
   2a50e:	6812      	ldr	r2, [r2, #0]
   2a510:	611a      	str	r2, [r3, #16]
   2a512:	e7af      	b.n	2a474 <mfu_interface_getopt+0xa0>
   2a514:	203c      	movs	r0, #60	; 0x3c
   2a516:	f7f5 fda3 	bl	20060 <bsd_os_errno_set>
   2a51a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a51e:	b002      	add	sp, #8
   2a520:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a524:	9800      	ldr	r0, [sp, #0]
   2a526:	6803      	ldr	r3, [r0, #0]
   2a528:	b11b      	cbz	r3, 2a532 <mfu_interface_getopt+0x15e>
   2a52a:	4618      	mov	r0, r3
   2a52c:	f7fc ff9c 	bl	27468 <rpc_dfu_client_data_free>
   2a530:	9800      	ldr	r0, [sp, #0]
   2a532:	f7fc ff91 	bl	27458 <rpc_dfu_client_message_free>
   2a536:	200c      	movs	r0, #12
   2a538:	f7f5 fd92 	bl	20060 <bsd_os_errno_set>
   2a53c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a540:	e7d2      	b.n	2a4e8 <mfu_interface_getopt+0x114>
   2a542:	2016      	movs	r0, #22
   2a544:	f7f5 fd8c 	bl	20060 <bsd_os_errno_set>
   2a548:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a54c:	e771      	b.n	2a432 <mfu_interface_getopt+0x5e>
   2a54e:	2001      	movs	r0, #1
   2a550:	f7f5 fd86 	bl	20060 <bsd_os_errno_set>
   2a554:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a558:	e76b      	b.n	2a432 <mfu_interface_getopt+0x5e>
   2a55a:	4b06      	ldr	r3, [pc, #24]	; (2a574 <mfu_interface_getopt+0x1a0>)
   2a55c:	2008      	movs	r0, #8
   2a55e:	601c      	str	r4, [r3, #0]
   2a560:	f7f5 fd7e 	bl	20060 <bsd_os_errno_set>
   2a564:	6838      	ldr	r0, [r7, #0]
   2a566:	f7fc ff77 	bl	27458 <rpc_dfu_client_message_free>
   2a56a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a56e:	e760      	b.n	2a432 <mfu_interface_getopt+0x5e>
   2a570:	20022a94 	.word	0x20022a94
   2a574:	20022a98 	.word	0x20022a98
   2a578:	20027620 	.word	0x20027620
   2a57c:	20022aa0 	.word	0x20022aa0
   2a580:	20022a9c 	.word	0x20022a9c

0002a584 <interface_init>:
   2a584:	b508      	push	{r3, lr}
   2a586:	f44f 72b4 	mov.w	r2, #360	; 0x168
   2a58a:	2100      	movs	r1, #0
   2a58c:	4802      	ldr	r0, [pc, #8]	; (2a598 <interface_init+0x14>)
   2a58e:	f00e fd5d 	bl	3904c <memset>
   2a592:	2000      	movs	r0, #0
   2a594:	bd08      	pop	{r3, pc}
   2a596:	bf00      	nop
   2a598:	20029090 	.word	0x20029090

0002a59c <interface_socket_allocate>:
   2a59c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a59e:	4b30      	ldr	r3, [pc, #192]	; (2a660 <interface_socket_allocate+0xc4>)
   2a5a0:	4606      	mov	r6, r0
   2a5a2:	681d      	ldr	r5, [r3, #0]
   2a5a4:	4608      	mov	r0, r1
   2a5a6:	b31d      	cbz	r5, 2a5f0 <interface_socket_allocate+0x54>
   2a5a8:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   2a5aa:	2c00      	cmp	r4, #0
   2a5ac:	d04a      	beq.n	2a644 <interface_socket_allocate+0xa8>
   2a5ae:	6d1c      	ldr	r4, [r3, #80]	; 0x50
   2a5b0:	2c00      	cmp	r4, #0
   2a5b2:	d049      	beq.n	2a648 <interface_socket_allocate+0xac>
   2a5b4:	6f9c      	ldr	r4, [r3, #120]	; 0x78
   2a5b6:	2c00      	cmp	r4, #0
   2a5b8:	d048      	beq.n	2a64c <interface_socket_allocate+0xb0>
   2a5ba:	f8d3 10a0 	ldr.w	r1, [r3, #160]	; 0xa0
   2a5be:	2900      	cmp	r1, #0
   2a5c0:	d046      	beq.n	2a650 <interface_socket_allocate+0xb4>
   2a5c2:	f8d3 10c8 	ldr.w	r1, [r3, #200]	; 0xc8
   2a5c6:	b191      	cbz	r1, 2a5ee <interface_socket_allocate+0x52>
   2a5c8:	f8d3 10f0 	ldr.w	r1, [r3, #240]	; 0xf0
   2a5cc:	2900      	cmp	r1, #0
   2a5ce:	d043      	beq.n	2a658 <interface_socket_allocate+0xbc>
   2a5d0:	f8d3 1118 	ldr.w	r1, [r3, #280]	; 0x118
   2a5d4:	2900      	cmp	r1, #0
   2a5d6:	d041      	beq.n	2a65c <interface_socket_allocate+0xc0>
   2a5d8:	f8d3 1140 	ldr.w	r1, [r3, #320]	; 0x140
   2a5dc:	2900      	cmp	r1, #0
   2a5de:	d039      	beq.n	2a654 <interface_socket_allocate+0xb8>
   2a5e0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a5e4:	2069      	movs	r0, #105	; 0x69
   2a5e6:	f7f5 fd3b 	bl	20060 <bsd_os_errno_set>
   2a5ea:	4628      	mov	r0, r5
   2a5ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a5ee:	2505      	movs	r5, #5
   2a5f0:	f04f 0c01 	mov.w	ip, #1
   2a5f4:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2a5f8:	eb05 0485 	add.w	r4, r5, r5, lsl #2
   2a5fc:	00e4      	lsls	r4, r4, #3
   2a5fe:	f843 c004 	str.w	ip, [r3, r4]
   2a602:	441c      	add	r4, r3
   2a604:	4611      	mov	r1, r2
   2a606:	61a7      	str	r7, [r4, #24]
   2a608:	4622      	mov	r2, r4
   2a60a:	f7fe ff9b 	bl	29544 <packet_handler_create>
   2a60e:	4603      	mov	r3, r0
   2a610:	61e0      	str	r0, [r4, #28]
   2a612:	b158      	cbz	r0, 2a62c <interface_socket_allocate+0x90>
   2a614:	681b      	ldr	r3, [r3, #0]
   2a616:	681b      	ldr	r3, [r3, #0]
   2a618:	4798      	blx	r3
   2a61a:	b910      	cbnz	r0, 2a622 <interface_socket_allocate+0x86>
   2a61c:	6034      	str	r4, [r6, #0]
   2a61e:	4628      	mov	r0, r5
   2a620:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a622:	69e0      	ldr	r0, [r4, #28]
   2a624:	f7fe ffae 	bl	29584 <packet_handler_delete>
   2a628:	2300      	movs	r3, #0
   2a62a:	61e3      	str	r3, [r4, #28]
   2a62c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   2a630:	2228      	movs	r2, #40	; 0x28
   2a632:	2100      	movs	r1, #0
   2a634:	4620      	mov	r0, r4
   2a636:	f00e fd09 	bl	3904c <memset>
   2a63a:	200c      	movs	r0, #12
   2a63c:	f7f5 fd10 	bl	20060 <bsd_os_errno_set>
   2a640:	4628      	mov	r0, r5
   2a642:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a644:	2501      	movs	r5, #1
   2a646:	e7d3      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a648:	2502      	movs	r5, #2
   2a64a:	e7d1      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a64c:	2503      	movs	r5, #3
   2a64e:	e7cf      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a650:	2504      	movs	r5, #4
   2a652:	e7cd      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a654:	2508      	movs	r5, #8
   2a656:	e7cb      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a658:	2506      	movs	r5, #6
   2a65a:	e7c9      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a65c:	2507      	movs	r5, #7
   2a65e:	e7c7      	b.n	2a5f0 <interface_socket_allocate+0x54>
   2a660:	20029090 	.word	0x20029090

0002a664 <interface_socket_free>:
   2a664:	2808      	cmp	r0, #8
   2a666:	d900      	bls.n	2a66a <interface_socket_free+0x6>
   2a668:	4770      	bx	lr
   2a66a:	b510      	push	{r4, lr}
   2a66c:	4c07      	ldr	r4, [pc, #28]	; (2a68c <interface_socket_free+0x28>)
   2a66e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a672:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
   2a676:	69e0      	ldr	r0, [r4, #28]
   2a678:	b108      	cbz	r0, 2a67e <interface_socket_free+0x1a>
   2a67a:	f7fe ff83 	bl	29584 <packet_handler_delete>
   2a67e:	4620      	mov	r0, r4
   2a680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2a684:	2228      	movs	r2, #40	; 0x28
   2a686:	2100      	movs	r1, #0
   2a688:	f00e bce0 	b.w	3904c <memset>
   2a68c:	20029090 	.word	0x20029090

0002a690 <interface_socket_packet_handler_update>:
   2a690:	2808      	cmp	r0, #8
   2a692:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2a696:	d81e      	bhi.n	2a6d6 <interface_socket_packet_handler_update+0x46>
   2a698:	ea4f 0880 	mov.w	r8, r0, lsl #2
   2a69c:	4e17      	ldr	r6, [pc, #92]	; (2a6fc <interface_socket_packet_handler_update+0x6c>)
   2a69e:	eb08 0300 	add.w	r3, r8, r0
   2a6a2:	00db      	lsls	r3, r3, #3
   2a6a4:	58f4      	ldr	r4, [r6, r3]
   2a6a6:	18f5      	adds	r5, r6, r3
   2a6a8:	b1ac      	cbz	r4, 2a6d6 <interface_socket_packet_handler_update+0x46>
   2a6aa:	460b      	mov	r3, r1
   2a6ac:	4604      	mov	r4, r0
   2a6ae:	4611      	mov	r1, r2
   2a6b0:	4618      	mov	r0, r3
   2a6b2:	462a      	mov	r2, r5
   2a6b4:	f8d5 901c 	ldr.w	r9, [r5, #28]
   2a6b8:	f7fe ff44 	bl	29544 <packet_handler_create>
   2a6bc:	61e8      	str	r0, [r5, #28]
   2a6be:	b1d0      	cbz	r0, 2a6f6 <interface_socket_packet_handler_update+0x66>
   2a6c0:	6803      	ldr	r3, [r0, #0]
   2a6c2:	681b      	ldr	r3, [r3, #0]
   2a6c4:	4798      	blx	r3
   2a6c6:	4607      	mov	r7, r0
   2a6c8:	b948      	cbnz	r0, 2a6de <interface_socket_packet_handler_update+0x4e>
   2a6ca:	4648      	mov	r0, r9
   2a6cc:	f7fe ff5a 	bl	29584 <packet_handler_delete>
   2a6d0:	4638      	mov	r0, r7
   2a6d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2a6d6:	2705      	movs	r7, #5
   2a6d8:	4638      	mov	r0, r7
   2a6da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2a6de:	69e8      	ldr	r0, [r5, #28]
   2a6e0:	f7fe ff50 	bl	29584 <packet_handler_delete>
   2a6e4:	eb08 0004 	add.w	r0, r8, r4
   2a6e8:	eb06 06c0 	add.w	r6, r6, r0, lsl #3
   2a6ec:	f8c6 901c 	str.w	r9, [r6, #28]
   2a6f0:	4638      	mov	r0, r7
   2a6f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   2a6f6:	2704      	movs	r7, #4
   2a6f8:	e7f4      	b.n	2a6e4 <interface_socket_packet_handler_update+0x54>
   2a6fa:	bf00      	nop
   2a6fc:	20029090 	.word	0x20029090

0002a700 <interface_socket_wait>:
   2a700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2a704:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a708:	4c0d      	ldr	r4, [pc, #52]	; (2a740 <interface_socket_wait+0x40>)
   2a70a:	00c0      	lsls	r0, r0, #3
   2a70c:	5825      	ldr	r5, [r4, r0]
   2a70e:	4404      	add	r4, r0
   2a710:	4015      	ands	r5, r2
   2a712:	428d      	cmp	r5, r1
   2a714:	d011      	beq.n	2a73a <interface_socket_wait+0x3a>
   2a716:	6860      	ldr	r0, [r4, #4]
   2a718:	b978      	cbnz	r0, 2a73a <interface_socket_wait+0x3a>
   2a71a:	4698      	mov	r8, r3
   2a71c:	460f      	mov	r7, r1
   2a71e:	4616      	mov	r6, r2
   2a720:	4625      	mov	r5, r4
   2a722:	e006      	b.n	2a732 <interface_socket_wait+0x32>
   2a724:	686b      	ldr	r3, [r5, #4]
   2a726:	b943      	cbnz	r3, 2a73a <interface_socket_wait+0x3a>
   2a728:	4641      	mov	r1, r8
   2a72a:	4620      	mov	r0, r4
   2a72c:	f7f5 fbee 	bl	1ff0c <bsd_os_timedwait>
   2a730:	b920      	cbnz	r0, 2a73c <interface_socket_wait+0x3c>
   2a732:	6828      	ldr	r0, [r5, #0]
   2a734:	4030      	ands	r0, r6
   2a736:	42b8      	cmp	r0, r7
   2a738:	d1f4      	bne.n	2a724 <interface_socket_wait+0x24>
   2a73a:	2000      	movs	r0, #0
   2a73c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2a740:	20029090 	.word	0x20029090

0002a744 <interface_from_internal_id_search>:
   2a744:	4b27      	ldr	r3, [pc, #156]	; (2a7e4 <interface_from_internal_id_search+0xa0>)
   2a746:	681a      	ldr	r2, [r3, #0]
   2a748:	b112      	cbz	r2, 2a750 <interface_from_internal_id_search+0xc>
   2a74a:	699a      	ldr	r2, [r3, #24]
   2a74c:	4282      	cmp	r2, r0
   2a74e:	d039      	beq.n	2a7c4 <interface_from_internal_id_search+0x80>
   2a750:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   2a752:	b112      	cbz	r2, 2a75a <interface_from_internal_id_search+0x16>
   2a754:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   2a756:	4282      	cmp	r2, r0
   2a758:	d036      	beq.n	2a7c8 <interface_from_internal_id_search+0x84>
   2a75a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   2a75c:	b112      	cbz	r2, 2a764 <interface_from_internal_id_search+0x20>
   2a75e:	6e9a      	ldr	r2, [r3, #104]	; 0x68
   2a760:	4282      	cmp	r2, r0
   2a762:	d033      	beq.n	2a7cc <interface_from_internal_id_search+0x88>
   2a764:	6f9a      	ldr	r2, [r3, #120]	; 0x78
   2a766:	b11a      	cbz	r2, 2a770 <interface_from_internal_id_search+0x2c>
   2a768:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   2a76c:	4282      	cmp	r2, r0
   2a76e:	d02f      	beq.n	2a7d0 <interface_from_internal_id_search+0x8c>
   2a770:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
   2a774:	b11a      	cbz	r2, 2a77e <interface_from_internal_id_search+0x3a>
   2a776:	f8d3 20b8 	ldr.w	r2, [r3, #184]	; 0xb8
   2a77a:	4282      	cmp	r2, r0
   2a77c:	d02a      	beq.n	2a7d4 <interface_from_internal_id_search+0x90>
   2a77e:	f8d3 20c8 	ldr.w	r2, [r3, #200]	; 0xc8
   2a782:	b11a      	cbz	r2, 2a78c <interface_from_internal_id_search+0x48>
   2a784:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
   2a788:	4282      	cmp	r2, r0
   2a78a:	d025      	beq.n	2a7d8 <interface_from_internal_id_search+0x94>
   2a78c:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
   2a790:	b11a      	cbz	r2, 2a79a <interface_from_internal_id_search+0x56>
   2a792:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   2a796:	4282      	cmp	r2, r0
   2a798:	d020      	beq.n	2a7dc <interface_from_internal_id_search+0x98>
   2a79a:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   2a79e:	b11a      	cbz	r2, 2a7a8 <interface_from_internal_id_search+0x64>
   2a7a0:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
   2a7a4:	4282      	cmp	r2, r0
   2a7a6:	d01b      	beq.n	2a7e0 <interface_from_internal_id_search+0x9c>
   2a7a8:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
   2a7ac:	b13a      	cbz	r2, 2a7be <interface_from_internal_id_search+0x7a>
   2a7ae:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
   2a7b2:	4283      	cmp	r3, r0
   2a7b4:	bf14      	ite	ne
   2a7b6:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   2a7ba:	2008      	moveq	r0, #8
   2a7bc:	4770      	bx	lr
   2a7be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a7c2:	4770      	bx	lr
   2a7c4:	2000      	movs	r0, #0
   2a7c6:	4770      	bx	lr
   2a7c8:	2001      	movs	r0, #1
   2a7ca:	4770      	bx	lr
   2a7cc:	2002      	movs	r0, #2
   2a7ce:	4770      	bx	lr
   2a7d0:	2003      	movs	r0, #3
   2a7d2:	4770      	bx	lr
   2a7d4:	2004      	movs	r0, #4
   2a7d6:	4770      	bx	lr
   2a7d8:	2005      	movs	r0, #5
   2a7da:	4770      	bx	lr
   2a7dc:	2006      	movs	r0, #6
   2a7de:	4770      	bx	lr
   2a7e0:	2007      	movs	r0, #7
   2a7e2:	4770      	bx	lr
   2a7e4:	20029090 	.word	0x20029090

0002a7e8 <interface_socket_from_handle_get>:
   2a7e8:	2808      	cmp	r0, #8
   2a7ea:	d807      	bhi.n	2a7fc <interface_socket_from_handle_get+0x14>
   2a7ec:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a7f0:	4b03      	ldr	r3, [pc, #12]	; (2a800 <interface_socket_from_handle_get+0x18>)
   2a7f2:	00c0      	lsls	r0, r0, #3
   2a7f4:	581a      	ldr	r2, [r3, r0]
   2a7f6:	b10a      	cbz	r2, 2a7fc <interface_socket_from_handle_get+0x14>
   2a7f8:	4418      	add	r0, r3
   2a7fa:	4770      	bx	lr
   2a7fc:	2000      	movs	r0, #0
   2a7fe:	4770      	bx	lr
   2a800:	20029090 	.word	0x20029090

0002a804 <interface_socket_event_get>:
   2a804:	b119      	cbz	r1, 2a80e <interface_socket_event_get+0xa>
   2a806:	2808      	cmp	r0, #8
   2a808:	d902      	bls.n	2a810 <interface_socket_event_get+0xc>
   2a80a:	2310      	movs	r3, #16
   2a80c:	600b      	str	r3, [r1, #0]
   2a80e:	4770      	bx	lr
   2a810:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a814:	4b07      	ldr	r3, [pc, #28]	; (2a834 <interface_socket_event_get+0x30>)
   2a816:	00c0      	lsls	r0, r0, #3
   2a818:	581a      	ldr	r2, [r3, r0]
   2a81a:	2a00      	cmp	r2, #0
   2a81c:	d0f5      	beq.n	2a80a <interface_socket_event_get+0x6>
   2a81e:	581b      	ldr	r3, [r3, r0]
   2a820:	0c1b      	lsrs	r3, r3, #16
   2a822:	f003 020a 	and.w	r2, r3, #10
   2a826:	2a0a      	cmp	r2, #10
   2a828:	bf14      	ite	ne
   2a82a:	f003 030f 	andne.w	r3, r3, #15
   2a82e:	f003 030d 	andeq.w	r3, r3, #13
   2a832:	e7eb      	b.n	2a80c <interface_socket_event_get+0x8>
   2a834:	20029090 	.word	0x20029090

0002a838 <interface_socket_setopt>:
   2a838:	2808      	cmp	r0, #8
   2a83a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2a83c:	d82c      	bhi.n	2a898 <interface_socket_setopt+0x60>
   2a83e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a842:	4e1e      	ldr	r6, [pc, #120]	; (2a8bc <interface_socket_setopt+0x84>)
   2a844:	00c0      	lsls	r0, r0, #3
   2a846:	5834      	ldr	r4, [r6, r0]
   2a848:	b334      	cbz	r4, 2a898 <interface_socket_setopt+0x60>
   2a84a:	2901      	cmp	r1, #1
   2a84c:	d11e      	bne.n	2a88c <interface_socket_setopt+0x54>
   2a84e:	f1a2 0114 	sub.w	r1, r2, #20
   2a852:	2901      	cmp	r1, #1
   2a854:	d81a      	bhi.n	2a88c <interface_socket_setopt+0x54>
   2a856:	9906      	ldr	r1, [sp, #24]
   2a858:	2908      	cmp	r1, #8
   2a85a:	d123      	bne.n	2a8a4 <interface_socket_setopt+0x6c>
   2a85c:	b313      	cbz	r3, 2a8a4 <interface_socket_setopt+0x6c>
   2a85e:	6859      	ldr	r1, [r3, #4]
   2a860:	4c17      	ldr	r4, [pc, #92]	; (2a8c0 <interface_socket_setopt+0x88>)
   2a862:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
   2a866:	fba4 4101 	umull	r4, r1, r4, r1
   2a86a:	0989      	lsrs	r1, r1, #6
   2a86c:	460c      	mov	r4, r1
   2a86e:	2500      	movs	r5, #0
   2a870:	681b      	ldr	r3, [r3, #0]
   2a872:	fbe7 4503 	umlal	r4, r5, r7, r3
   2a876:	2d01      	cmp	r5, #1
   2a878:	bf08      	it	eq
   2a87a:	2c00      	cmpeq	r4, #0
   2a87c:	d218      	bcs.n	2a8b0 <interface_socket_setopt+0x78>
   2a87e:	4430      	add	r0, r6
   2a880:	2a14      	cmp	r2, #20
   2a882:	bf0c      	ite	eq
   2a884:	6204      	streq	r4, [r0, #32]
   2a886:	6244      	strne	r4, [r0, #36]	; 0x24
   2a888:	2000      	movs	r0, #0
   2a88a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a88c:	202a      	movs	r0, #42	; 0x2a
   2a88e:	f7f5 fbe7 	bl	20060 <bsd_os_errno_set>
   2a892:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a896:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a898:	2009      	movs	r0, #9
   2a89a:	f7f5 fbe1 	bl	20060 <bsd_os_errno_set>
   2a89e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a8a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a8a4:	2016      	movs	r0, #22
   2a8a6:	f7f5 fbdb 	bl	20060 <bsd_os_errno_set>
   2a8aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a8ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a8b0:	2025      	movs	r0, #37	; 0x25
   2a8b2:	f7f5 fbd5 	bl	20060 <bsd_os_errno_set>
   2a8b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a8ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2a8bc:	20029090 	.word	0x20029090
   2a8c0:	10624dd3 	.word	0x10624dd3

0002a8c4 <interface_socket_getopt>:
   2a8c4:	b570      	push	{r4, r5, r6, lr}
   2a8c6:	2808      	cmp	r0, #8
   2a8c8:	9d04      	ldr	r5, [sp, #16]
   2a8ca:	d835      	bhi.n	2a938 <interface_socket_getopt+0x74>
   2a8cc:	4c20      	ldr	r4, [pc, #128]	; (2a950 <interface_socket_getopt+0x8c>)
   2a8ce:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a8d2:	00c0      	lsls	r0, r0, #3
   2a8d4:	5826      	ldr	r6, [r4, r0]
   2a8d6:	4404      	add	r4, r0
   2a8d8:	b376      	cbz	r6, 2a938 <interface_socket_getopt+0x74>
   2a8da:	2901      	cmp	r1, #1
   2a8dc:	d132      	bne.n	2a944 <interface_socket_getopt+0x80>
   2a8de:	b32b      	cbz	r3, 2a92c <interface_socket_getopt+0x68>
   2a8e0:	b325      	cbz	r5, 2a92c <interface_socket_getopt+0x68>
   2a8e2:	2a04      	cmp	r2, #4
   2a8e4:	d019      	beq.n	2a91a <interface_socket_getopt+0x56>
   2a8e6:	f1a2 0114 	sub.w	r1, r2, #20
   2a8ea:	2901      	cmp	r1, #1
   2a8ec:	d82a      	bhi.n	2a944 <interface_socket_getopt+0x80>
   2a8ee:	6829      	ldr	r1, [r5, #0]
   2a8f0:	2908      	cmp	r1, #8
   2a8f2:	d11b      	bne.n	2a92c <interface_socket_getopt+0x68>
   2a8f4:	e9d4 1008 	ldrd	r1, r0, [r4, #32]
   2a8f8:	2a14      	cmp	r2, #20
   2a8fa:	bf18      	it	ne
   2a8fc:	4601      	movne	r1, r0
   2a8fe:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   2a902:	4a14      	ldr	r2, [pc, #80]	; (2a954 <interface_socket_getopt+0x90>)
   2a904:	2000      	movs	r0, #0
   2a906:	fba2 5201 	umull	r5, r2, r2, r1
   2a90a:	0992      	lsrs	r2, r2, #6
   2a90c:	fb04 1112 	mls	r1, r4, r2, r1
   2a910:	fb04 f101 	mul.w	r1, r4, r1
   2a914:	e9c3 2100 	strd	r2, r1, [r3]
   2a918:	bd70      	pop	{r4, r5, r6, pc}
   2a91a:	682a      	ldr	r2, [r5, #0]
   2a91c:	2a04      	cmp	r2, #4
   2a91e:	d105      	bne.n	2a92c <interface_socket_getopt+0x68>
   2a920:	2200      	movs	r2, #0
   2a922:	6861      	ldr	r1, [r4, #4]
   2a924:	4610      	mov	r0, r2
   2a926:	6019      	str	r1, [r3, #0]
   2a928:	6062      	str	r2, [r4, #4]
   2a92a:	bd70      	pop	{r4, r5, r6, pc}
   2a92c:	2016      	movs	r0, #22
   2a92e:	f7f5 fb97 	bl	20060 <bsd_os_errno_set>
   2a932:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a936:	bd70      	pop	{r4, r5, r6, pc}
   2a938:	2009      	movs	r0, #9
   2a93a:	f7f5 fb91 	bl	20060 <bsd_os_errno_set>
   2a93e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a942:	bd70      	pop	{r4, r5, r6, pc}
   2a944:	202a      	movs	r0, #42	; 0x2a
   2a946:	f7f5 fb8b 	bl	20060 <bsd_os_errno_set>
   2a94a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a94e:	bd70      	pop	{r4, r5, r6, pc}
   2a950:	20029090 	.word	0x20029090
   2a954:	10624dd3 	.word	0x10624dd3

0002a958 <interface_socket_fcntl>:
   2a958:	2808      	cmp	r0, #8
   2a95a:	b510      	push	{r4, lr}
   2a95c:	d826      	bhi.n	2a9ac <interface_socket_fcntl+0x54>
   2a95e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   2a962:	4c1b      	ldr	r4, [pc, #108]	; (2a9d0 <interface_socket_fcntl+0x78>)
   2a964:	00c3      	lsls	r3, r0, #3
   2a966:	58e0      	ldr	r0, [r4, r3]
   2a968:	b300      	cbz	r0, 2a9ac <interface_socket_fcntl+0x54>
   2a96a:	2901      	cmp	r1, #1
   2a96c:	d005      	beq.n	2a97a <interface_socket_fcntl+0x22>
   2a96e:	2902      	cmp	r1, #2
   2a970:	d122      	bne.n	2a9b8 <interface_socket_fcntl+0x60>
   2a972:	58e0      	ldr	r0, [r4, r3]
   2a974:	f3c0 7000 	ubfx	r0, r0, #28, #1
   2a978:	bd10      	pop	{r4, pc}
   2a97a:	07d2      	lsls	r2, r2, #31
   2a97c:	d410      	bmi.n	2a9a0 <interface_socket_fcntl+0x48>
   2a97e:	58e0      	ldr	r0, [r4, r3]
   2a980:	f010 5000 	ands.w	r0, r0, #536870912	; 0x20000000
   2a984:	d11e      	bne.n	2a9c4 <interface_socket_fcntl+0x6c>
   2a986:	58e2      	ldr	r2, [r4, r3]
   2a988:	b292      	uxth	r2, r2
   2a98a:	2a0a      	cmp	r2, #10
   2a98c:	d01a      	beq.n	2a9c4 <interface_socket_fcntl+0x6c>
   2a98e:	58e2      	ldr	r2, [r4, r3]
   2a990:	b292      	uxth	r2, r2
   2a992:	2a0b      	cmp	r2, #11
   2a994:	d016      	beq.n	2a9c4 <interface_socket_fcntl+0x6c>
   2a996:	58e2      	ldr	r2, [r4, r3]
   2a998:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
   2a99c:	50e2      	str	r2, [r4, r3]
   2a99e:	bd10      	pop	{r4, pc}
   2a9a0:	58e2      	ldr	r2, [r4, r3]
   2a9a2:	2000      	movs	r0, #0
   2a9a4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
   2a9a8:	50e2      	str	r2, [r4, r3]
   2a9aa:	bd10      	pop	{r4, pc}
   2a9ac:	2009      	movs	r0, #9
   2a9ae:	f7f5 fb57 	bl	20060 <bsd_os_errno_set>
   2a9b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a9b6:	bd10      	pop	{r4, pc}
   2a9b8:	2016      	movs	r0, #22
   2a9ba:	f7f5 fb51 	bl	20060 <bsd_os_errno_set>
   2a9be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a9c2:	bd10      	pop	{r4, pc}
   2a9c4:	2023      	movs	r0, #35	; 0x23
   2a9c6:	f7f5 fb4b 	bl	20060 <bsd_os_errno_set>
   2a9ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2a9ce:	bd10      	pop	{r4, pc}
   2a9d0:	20029090 	.word	0x20029090

0002a9d4 <at_client_evt_handler>:
   2a9d4:	b120      	cbz	r0, 2a9e0 <at_client_evt_handler+0xc>
   2a9d6:	f850 1b08 	ldr.w	r1, [r0], #8
   2a9da:	0c09      	lsrs	r1, r1, #16
   2a9dc:	f7fc bf0e 	b.w	277fc <rpc_at_event_handler>
   2a9e0:	4770      	bx	lr
   2a9e2:	bf00      	nop

0002a9e4 <rpc_at_client_init>:
   2a9e4:	4801      	ldr	r0, [pc, #4]	; (2a9ec <rpc_at_client_init+0x8>)
   2a9e6:	f7fb bcff 	b.w	263e8 <rpc_client_register>
   2a9ea:	bf00      	nop
   2a9ec:	0003ac10 	.word	0x0003ac10

0002a9f0 <rpc_at_client_request_alloc>:
   2a9f0:	b180      	cbz	r0, 2aa14 <rpc_at_client_request_alloc+0x24>
   2a9f2:	2300      	movs	r3, #0
   2a9f4:	b510      	push	{r4, lr}
   2a9f6:	b082      	sub	sp, #8
   2a9f8:	aa02      	add	r2, sp, #8
   2a9fa:	4604      	mov	r4, r0
   2a9fc:	f842 3d04 	str.w	r3, [r2, #-4]!
   2aa00:	2003      	movs	r0, #3
   2aa02:	f7fb fd6b 	bl	264dc <rpc_message_alloc>
   2aa06:	b918      	cbnz	r0, 2aa10 <rpc_at_client_request_alloc+0x20>
   2aa08:	9b01      	ldr	r3, [sp, #4]
   2aa0a:	b10b      	cbz	r3, 2aa10 <rpc_at_client_request_alloc+0x20>
   2aa0c:	3308      	adds	r3, #8
   2aa0e:	6023      	str	r3, [r4, #0]
   2aa10:	b002      	add	sp, #8
   2aa12:	bd10      	pop	{r4, pc}
   2aa14:	200e      	movs	r0, #14
   2aa16:	4770      	bx	lr

0002aa18 <rpc_at_client_request_send>:
   2aa18:	b150      	cbz	r0, 2aa30 <rpc_at_client_request_send+0x18>
   2aa1a:	4603      	mov	r3, r0
   2aa1c:	f830 2c08 	ldrh.w	r2, [r0, #-8]
   2aa20:	2003      	movs	r0, #3
   2aa22:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
   2aa26:	f843 1d08 	str.w	r1, [r3, #-8]!
   2aa2a:	4619      	mov	r1, r3
   2aa2c:	f7fb bd46 	b.w	264bc <rpc_message_send>
   2aa30:	200e      	movs	r0, #14
   2aa32:	4770      	bx	lr

0002aa34 <rpc_at_client_message_free>:
   2aa34:	b120      	cbz	r0, 2aa40 <rpc_at_client_message_free+0xc>
   2aa36:	f1a0 0108 	sub.w	r1, r0, #8
   2aa3a:	2003      	movs	r0, #3
   2aa3c:	f7fb bd7a 	b.w	26534 <rpc_message_free>
   2aa40:	200e      	movs	r0, #14
   2aa42:	4770      	bx	lr

0002aa44 <rpc_at_client_data_free>:
   2aa44:	b118      	cbz	r0, 2aa4e <rpc_at_client_data_free+0xa>
   2aa46:	4601      	mov	r1, r0
   2aa48:	2003      	movs	r0, #3
   2aa4a:	f7fb bd7f 	b.w	2654c <rpc_message_data_free>
   2aa4e:	200e      	movs	r0, #14
   2aa50:	4770      	bx	lr
   2aa52:	bf00      	nop

0002aa54 <SystemInit>:
    
    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
    * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
    * operations are not used in your code. */
    #if (__FPU_USED == 1)
      SCB->CPACR |= (3UL << 20) | (3UL << 22);
   2aa54:	4a07      	ldr	r2, [pc, #28]	; (2aa74 <SystemInit+0x20>)
   2aa56:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
   2aa5a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
   2aa5e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   2aa62:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   2aa66:	f3bf 8f6f 	isb	sy
    SystemCoreClock = __SYSTEM_CLOCK;
   2aa6a:	4b03      	ldr	r3, [pc, #12]	; (2aa78 <SystemInit+0x24>)
   2aa6c:	4a03      	ldr	r2, [pc, #12]	; (2aa7c <SystemInit+0x28>)
   2aa6e:	601a      	str	r2, [r3, #0]
      __DSB();
      __ISB();
    #endif
    
    SystemCoreClockUpdate();
}
   2aa70:	4770      	bx	lr
   2aa72:	bf00      	nop
   2aa74:	e000ed00 	.word	0xe000ed00
   2aa78:	20020224 	.word	0x20020224
   2aa7c:	03d09000 	.word	0x03d09000

0002aa80 <nrf_gpio_pin_port_decode.isra.0>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   2aa80:	b508      	push	{r3, lr}
NRF_STATIC_INLINE bool nrf_gpio_pin_present_check(uint32_t pin_number)
{
    uint32_t port = pin_number >> 5;
    uint32_t mask = 0;

    switch (port)
   2aa82:	0943      	lsrs	r3, r0, #5
   2aa84:	bf0c      	ite	eq
   2aa86:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   2aa8a:	2300      	movne	r3, #0
            mask = P1_FEATURE_PINS_PRESENT;
            break;
#endif
    }

    pin_number &= 0x1F;
   2aa8c:	f000 001f 	and.w	r0, r0, #31

    return (mask & (1UL << pin_number)) ? true : false;
   2aa90:	fa23 f000 	lsr.w	r0, r3, r0
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2aa94:	07c3      	lsls	r3, r0, #31
   2aa96:	d40b      	bmi.n	2aab0 <nrf_gpio_pin_port_decode.isra.0+0x30>
   2aa98:	4906      	ldr	r1, [pc, #24]	; (2aab4 <nrf_gpio_pin_port_decode.isra.0+0x34>)
   2aa9a:	4807      	ldr	r0, [pc, #28]	; (2aab8 <nrf_gpio_pin_port_decode.isra.0+0x38>)
   2aa9c:	f240 230d 	movw	r3, #525	; 0x20d
   2aaa0:	4a06      	ldr	r2, [pc, #24]	; (2aabc <nrf_gpio_pin_port_decode.isra.0+0x3c>)
   2aaa2:	f008 fd91 	bl	335c8 <printk>
   2aaa6:	f240 210d 	movw	r1, #525	; 0x20d
   2aaaa:	4804      	ldr	r0, [pc, #16]	; (2aabc <nrf_gpio_pin_port_decode.isra.0+0x3c>)
   2aaac:	f009 f88d 	bl	33bca <assert_post_action>
}
   2aab0:	4803      	ldr	r0, [pc, #12]	; (2aac0 <nrf_gpio_pin_port_decode.isra.0+0x40>)
   2aab2:	bd08      	pop	{r3, pc}
   2aab4:	0003df67 	.word	0x0003df67
   2aab8:	0003b77f 	.word	0x0003b77f
   2aabc:	0003df34 	.word	0x0003df34
   2aac0:	40842500 	.word	0x40842500

0002aac4 <nrfx_spim_init>:

nrfx_err_t nrfx_spim_init(nrfx_spim_t const *        p_instance,
                          nrfx_spim_config_t const * p_config,
                          nrfx_spim_evt_handler_t    handler,
                          void *                     p_context)
{
   2aac4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2aac8:	4681      	mov	r9, r0
   2aaca:	4692      	mov	sl, r2
   2aacc:	461f      	mov	r7, r3
    NRFX_ASSERT(p_config);
   2aace:	460c      	mov	r4, r1
   2aad0:	b949      	cbnz	r1, 2aae6 <nrfx_spim_init+0x22>
   2aad2:	4953      	ldr	r1, [pc, #332]	; (2ac20 <nrfx_spim_init+0x15c>)
   2aad4:	4853      	ldr	r0, [pc, #332]	; (2ac24 <nrfx_spim_init+0x160>)
   2aad6:	23ff      	movs	r3, #255	; 0xff
   2aad8:	4a53      	ldr	r2, [pc, #332]	; (2ac28 <nrfx_spim_init+0x164>)
   2aada:	f008 fd75 	bl	335c8 <printk>
   2aade:	21ff      	movs	r1, #255	; 0xff
   2aae0:	4851      	ldr	r0, [pc, #324]	; (2ac28 <nrfx_spim_init+0x164>)
   2aae2:	f009 f872 	bl	33bca <assert_post_action>
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2aae6:	2324      	movs	r3, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2aae8:	f899 5004 	ldrb.w	r5, [r9, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2aaec:	4e4f      	ldr	r6, [pc, #316]	; (2ac2c <nrfx_spim_init+0x168>)
   2aaee:	436b      	muls	r3, r5
   2aaf0:	18f2      	adds	r2, r6, r3
   2aaf2:	7f11      	ldrb	r1, [r2, #28]
   2aaf4:	2900      	cmp	r1, #0
   2aaf6:	f040 8091 	bne.w	2ac1c <nrfx_spim_init+0x158>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif

    NRF_SPIM_Type * p_spim = (NRF_SPIM_Type *)p_instance->p_reg;
   2aafa:	f8d9 8000 	ldr.w	r8, [r9]
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler = handler;
   2aafe:	f846 a003 	str.w	sl, [r6, r3]
    // Configure pins used by the peripheral:
    // - SCK - output with initial value corresponding with the SPI mode used:
    //   0 - for modes 0 and 1 (CPOL = 0), 1 - for modes 2 and 3 (CPOL = 1);
    //   according to the reference manual guidelines this pin and its input
    //   buffer must always be connected for the SPI to work.
    if (p_config->mode <= NRF_SPIM_MODE_1)
   2ab02:	7b23      	ldrb	r3, [r4, #12]
    p_cb->p_context = p_context;
   2ab04:	6057      	str	r7, [r2, #4]
    if (p_config->mode <= NRF_SPIM_MODE_1)
   2ab06:	2b01      	cmp	r3, #1
   2ab08:	7820      	ldrb	r0, [r4, #0]
   2ab0a:	d875      	bhi.n	2abf8 <nrfx_spim_init+0x134>
    {
        nrf_gpio_pin_clear(p_config->sck_pin);
   2ab0c:	f00d ffb8 	bl	38a80 <nrf_gpio_pin_clear>
    }
    else
    {
        nrf_gpio_pin_set(p_config->sck_pin);
    }
    nrf_gpio_cfg(p_config->sck_pin,
   2ab10:	7827      	ldrb	r7, [r4, #0]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2ab12:	4638      	mov	r0, r7
   2ab14:	f7ff ffb4 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2ab18:	2301      	movs	r3, #1
   2ab1a:	3780      	adds	r7, #128	; 0x80
   2ab1c:	f840 3027 	str.w	r3, [r0, r7, lsl #2]
                 NRF_GPIO_PIN_INPUT_CONNECT,
                 NRF_GPIO_PIN_NOPULL,
                 NRF_GPIO_PIN_S0S1,
                 NRF_GPIO_PIN_NOSENSE);
    // - MOSI (optional) - output with initial value 0,
    if (p_config->mosi_pin != NRFX_SPIM_PIN_NOT_USED)
   2ab20:	7867      	ldrb	r7, [r4, #1]
   2ab22:	2fff      	cmp	r7, #255	; 0xff
   2ab24:	d06b      	beq.n	2abfe <nrfx_spim_init+0x13a>
    {
        mosi_pin = p_config->mosi_pin;
        nrf_gpio_pin_clear(mosi_pin);
   2ab26:	4638      	mov	r0, r7
   2ab28:	f00d ffaa 	bl	38a80 <nrf_gpio_pin_clear>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2ab2c:	4638      	mov	r0, r7
   2ab2e:	f7ff ffa7 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2ab32:	2203      	movs	r2, #3
   2ab34:	f107 0380 	add.w	r3, r7, #128	; 0x80
   2ab38:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    else
    {
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
    }
    // - MISO (optional) - input,
    if (p_config->miso_pin != NRFX_SPIM_PIN_NOT_USED)
   2ab3c:	f894 a002 	ldrb.w	sl, [r4, #2]
   2ab40:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   2ab44:	d05e      	beq.n	2ac04 <nrfx_spim_init+0x140>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2ab46:	4650      	mov	r0, sl
    {
        miso_pin = p_config->miso_pin;
        nrf_gpio_cfg_input(miso_pin, p_config->miso_pull);
   2ab48:	f894 b00e 	ldrb.w	fp, [r4, #14]
   2ab4c:	f7ff ff98 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
   2ab50:	ea4f 038b 	mov.w	r3, fp, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2ab54:	f10a 0280 	add.w	r2, sl, #128	; 0x80
   2ab58:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
    }
    // - Slave Select (optional) - output with initial value 1 (inactive).

    // 'p_cb->ss_pin' variable is used during transfers to check if SS pin should be toggled,
    // so this field needs to be initialized even if the pin is not used.
    p_cb->ss_pin = p_config->ss_pin;
   2ab5c:	2324      	movs	r3, #36	; 0x24
   2ab5e:	fb03 6305 	mla	r3, r3, r5, r6
   2ab62:	78e0      	ldrb	r0, [r4, #3]

    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2ab64:	28ff      	cmp	r0, #255	; 0xff
    p_cb->ss_pin = p_config->ss_pin;
   2ab66:	77d8      	strb	r0, [r3, #31]
    if (p_config->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2ab68:	d013      	beq.n	2ab92 <nrfx_spim_init+0xce>
    {
        if (p_config->ss_active_high)
   2ab6a:	7923      	ldrb	r3, [r4, #4]
   2ab6c:	2b00      	cmp	r3, #0
   2ab6e:	d04c      	beq.n	2ac0a <nrfx_spim_init+0x146>
        {
            nrf_gpio_pin_clear(p_config->ss_pin);
   2ab70:	f00d ff86 	bl	38a80 <nrf_gpio_pin_clear>
        }
        else
        {
            nrf_gpio_pin_set(p_config->ss_pin);
        }
        nrf_gpio_cfg_output(p_config->ss_pin);
   2ab74:	f894 b003 	ldrb.w	fp, [r4, #3]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2ab78:	4658      	mov	r0, fp
   2ab7a:	f7ff ff81 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2ab7e:	2303      	movs	r3, #3
   2ab80:	f10b 0b80 	add.w	fp, fp, #128	; 0x80
   2ab84:	f840 302b 	str.w	r3, [r0, fp, lsl #2]
                                   (p_config->ss_active_high == true ?
                                        NRF_SPIM_CSN_POL_HIGH : NRF_SPIM_CSN_POL_LOW),
                                   p_config->ss_duration);
        }
#endif
        p_cb->ss_active_high = p_config->ss_active_high;
   2ab88:	2324      	movs	r3, #36	; 0x24
   2ab8a:	fb03 6305 	mla	r3, r3, r5, r6
   2ab8e:	7922      	ldrb	r2, [r4, #4]
   2ab90:	779a      	strb	r2, [r3, #30]
    // Change rx delay
    nrf_spim_iftiming_set(p_spim, p_config->rx_delay);
#endif


    nrf_spim_pins_set(p_spim, p_config->sck_pin, mosi_pin, miso_pin);
   2ab92:	7823      	ldrb	r3, [r4, #0]
    nrf_spim_frequency_set(p_spim, p_config->frequency);
    nrf_spim_configure(p_spim, p_config->mode, p_config->bit_order);
   2ab94:	7b22      	ldrb	r2, [r4, #12]
    p_reg->PSEL.SCK  = sck_pin;
   2ab96:	f8c8 3508 	str.w	r3, [r8, #1288]	; 0x508
    p_reg->FREQUENCY = (uint32_t)frequency;
   2ab9a:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.MOSI = mosi_pin;
   2ab9c:	f8c8 750c 	str.w	r7, [r8, #1292]	; 0x50c
    p_reg->PSEL.MISO = miso_pin;
   2aba0:	f8c8 a510 	str.w	sl, [r8, #1296]	; 0x510
    p_reg->FREQUENCY = (uint32_t)frequency;
   2aba4:	f8c8 3524 	str.w	r3, [r8, #1316]	; 0x524
        SPIM_CONFIG_ORDER_MsbFirst : SPIM_CONFIG_ORDER_LsbFirst);
   2aba8:	7b63      	ldrb	r3, [r4, #13]
   2abaa:	3300      	adds	r3, #0
   2abac:	bf18      	it	ne
   2abae:	2301      	movne	r3, #1
    switch (spi_mode)
   2abb0:	2a02      	cmp	r2, #2
   2abb2:	d02d      	beq.n	2ac10 <nrfx_spim_init+0x14c>
   2abb4:	2a03      	cmp	r2, #3
   2abb6:	d02e      	beq.n	2ac16 <nrfx_spim_init+0x152>
   2abb8:	2a01      	cmp	r2, #1
   2abba:	d101      	bne.n	2abc0 <nrfx_spim_init+0xfc>
        config |= (SPIM_CONFIG_CPOL_ActiveHigh << SPIM_CONFIG_CPOL_Pos) |
   2abbc:	f043 0302 	orr.w	r3, r3, #2
    p_reg->CONFIG = config;
   2abc0:	f8c8 3554 	str.w	r3, [r8, #1364]	; 0x554
}

NRF_STATIC_INLINE void nrf_spim_orc_set(NRF_SPIM_Type * p_reg,
                                        uint8_t         orc)
{
    p_reg->ORC = orc;
   2abc4:	79a3      	ldrb	r3, [r4, #6]
   2abc6:	f8c8 35c0 	str.w	r3, [r8, #1472]	; 0x5c0
    p_reg->ENABLE = (SPIM_ENABLE_ENABLE_Enabled << SPIM_ENABLE_ENABLE_Pos);
   2abca:	2307      	movs	r3, #7
   2abcc:	f8c8 3500 	str.w	r3, [r8, #1280]	; 0x500

    nrf_spim_orc_set(p_spim, p_config->orc);

    nrf_spim_enable(p_spim);

    if (p_cb->handler)
   2abd0:	2324      	movs	r3, #36	; 0x24
   2abd2:	436b      	muls	r3, r5
   2abd4:	58f3      	ldr	r3, [r6, r3]
   2abd6:	b12b      	cbz	r3, 2abe4 <nrfx_spim_init+0x120>
    return ((((uint32_t)p_object) & 0x3u) == 0u);
}

NRF_STATIC_INLINE IRQn_Type nrfx_get_irq_number(void const * p_reg)
{
    return (IRQn_Type)NRFX_IRQ_NUMBER_GET(p_reg);
   2abd8:	f8d9 0000 	ldr.w	r0, [r9]
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg),
            p_config->irq_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   2abdc:	f340 3007 	sbfx	r0, r0, #12, #8
   2abe0:	f7f0 f806 	bl	1abf0 <arch_irq_enable>
    }

    p_cb->transfer_in_progress = false;
   2abe4:	2324      	movs	r3, #36	; 0x24
   2abe6:	fb03 6505 	mla	r5, r3, r5, r6
   2abea:	2300      	movs	r3, #0
   2abec:	776b      	strb	r3, [r5, #29]
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2abee:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   2abf0:	480f      	ldr	r0, [pc, #60]	; (2ac30 <nrfx_spim_init+0x16c>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2abf2:	772b      	strb	r3, [r5, #28]
}
   2abf4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        nrf_gpio_pin_set(p_config->sck_pin);
   2abf8:	f00d ff4a 	bl	38a90 <nrf_gpio_pin_set>
   2abfc:	e788      	b.n	2ab10 <nrfx_spim_init+0x4c>
        mosi_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   2abfe:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   2ac02:	e79b      	b.n	2ab3c <nrfx_spim_init+0x78>
        miso_pin = NRF_SPIM_PIN_NOT_CONNECTED;
   2ac04:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
   2ac08:	e7a8      	b.n	2ab5c <nrfx_spim_init+0x98>
            nrf_gpio_pin_set(p_config->ss_pin);
   2ac0a:	f00d ff41 	bl	38a90 <nrf_gpio_pin_set>
   2ac0e:	e7b1      	b.n	2ab74 <nrfx_spim_init+0xb0>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2ac10:	f043 0304 	orr.w	r3, r3, #4
        break;
   2ac14:	e7d4      	b.n	2abc0 <nrfx_spim_init+0xfc>
        config |= (SPIM_CONFIG_CPOL_ActiveLow  << SPIM_CONFIG_CPOL_Pos) |
   2ac16:	f043 0306 	orr.w	r3, r3, #6
        break;
   2ac1a:	e7d1      	b.n	2abc0 <nrfx_spim_init+0xfc>
        return err_code;
   2ac1c:	4805      	ldr	r0, [pc, #20]	; (2ac34 <nrfx_spim_init+0x170>)
   2ac1e:	e7e9      	b.n	2abf4 <nrfx_spim_init+0x130>
   2ac20:	0003f5bf 	.word	0x0003f5bf
   2ac24:	0003b77f 	.word	0x0003b77f
   2ac28:	0003f583 	.word	0x0003f583
   2ac2c:	20022aa4 	.word	0x20022aa4
   2ac30:	0bad0000 	.word	0x0bad0000
   2ac34:	0bad0005 	.word	0x0bad0005

0002ac38 <nrfx_spim_xfer>:
}

nrfx_err_t nrfx_spim_xfer(nrfx_spim_t const *           p_instance,
                          nrfx_spim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   2ac38:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2ac3c:	2324      	movs	r3, #36	; 0x24
    spim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2ac3e:	7905      	ldrb	r5, [r0, #4]
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2ac40:	4e6e      	ldr	r6, [pc, #440]	; (2adfc <nrfx_spim_xfer+0x1c4>)
{
   2ac42:	4681      	mov	r9, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2ac44:	fb03 6305 	mla	r3, r3, r5, r6
   2ac48:	7f1b      	ldrb	r3, [r3, #28]
{
   2ac4a:	460c      	mov	r4, r1
   2ac4c:	4617      	mov	r7, r2
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2ac4e:	b95b      	cbnz	r3, 2ac68 <nrfx_spim_xfer+0x30>
   2ac50:	496b      	ldr	r1, [pc, #428]	; (2ae00 <nrfx_spim_xfer+0x1c8>)
   2ac52:	486c      	ldr	r0, [pc, #432]	; (2ae04 <nrfx_spim_xfer+0x1cc>)
   2ac54:	f240 2396 	movw	r3, #662	; 0x296
   2ac58:	4a6b      	ldr	r2, [pc, #428]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2ac5a:	f008 fcb5 	bl	335c8 <printk>
   2ac5e:	f240 2196 	movw	r1, #662	; 0x296
   2ac62:	4869      	ldr	r0, [pc, #420]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2ac64:	f008 ffb1 	bl	33bca <assert_post_action>
    NRFX_ASSERT(p_xfer_desc->p_tx_buffer != NULL || p_xfer_desc->tx_length == 0);
   2ac68:	6823      	ldr	r3, [r4, #0]
   2ac6a:	b96b      	cbnz	r3, 2ac88 <nrfx_spim_xfer+0x50>
   2ac6c:	6863      	ldr	r3, [r4, #4]
   2ac6e:	b15b      	cbz	r3, 2ac88 <nrfx_spim_xfer+0x50>
   2ac70:	4966      	ldr	r1, [pc, #408]	; (2ae0c <nrfx_spim_xfer+0x1d4>)
   2ac72:	4864      	ldr	r0, [pc, #400]	; (2ae04 <nrfx_spim_xfer+0x1cc>)
   2ac74:	f240 2397 	movw	r3, #663	; 0x297
   2ac78:	4a63      	ldr	r2, [pc, #396]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2ac7a:	f008 fca5 	bl	335c8 <printk>
   2ac7e:	f240 2197 	movw	r1, #663	; 0x297
   2ac82:	4861      	ldr	r0, [pc, #388]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2ac84:	f008 ffa1 	bl	33bca <assert_post_action>
    NRFX_ASSERT(p_xfer_desc->p_rx_buffer != NULL || p_xfer_desc->rx_length == 0);
   2ac88:	68a3      	ldr	r3, [r4, #8]
   2ac8a:	b96b      	cbnz	r3, 2aca8 <nrfx_spim_xfer+0x70>
   2ac8c:	68e3      	ldr	r3, [r4, #12]
   2ac8e:	b15b      	cbz	r3, 2aca8 <nrfx_spim_xfer+0x70>
   2ac90:	495f      	ldr	r1, [pc, #380]	; (2ae10 <nrfx_spim_xfer+0x1d8>)
   2ac92:	485c      	ldr	r0, [pc, #368]	; (2ae04 <nrfx_spim_xfer+0x1cc>)
   2ac94:	f44f 7326 	mov.w	r3, #664	; 0x298
   2ac98:	4a5b      	ldr	r2, [pc, #364]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2ac9a:	f008 fc95 	bl	335c8 <printk>
   2ac9e:	f44f 7126 	mov.w	r1, #664	; 0x298
   2aca2:	4859      	ldr	r0, [pc, #356]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2aca4:	f008 ff91 	bl	33bca <assert_post_action>
    NRFX_ASSERT(SPIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   2aca8:	f899 3004 	ldrb.w	r3, [r9, #4]
   2acac:	b93b      	cbnz	r3, 2acbe <nrfx_spim_xfer+0x86>
   2acae:	68e3      	ldr	r3, [r4, #12]
   2acb0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2acb4:	d203      	bcs.n	2acbe <nrfx_spim_xfer+0x86>
   2acb6:	6863      	ldr	r3, [r4, #4]
   2acb8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2acbc:	d30b      	bcc.n	2acd6 <nrfx_spim_xfer+0x9e>
   2acbe:	4955      	ldr	r1, [pc, #340]	; (2ae14 <nrfx_spim_xfer+0x1dc>)
   2acc0:	4850      	ldr	r0, [pc, #320]	; (2ae04 <nrfx_spim_xfer+0x1cc>)
   2acc2:	f240 239b 	movw	r3, #667	; 0x29b
   2acc6:	4a50      	ldr	r2, [pc, #320]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2acc8:	f008 fc7e 	bl	335c8 <printk>
   2accc:	f240 219b 	movw	r1, #667	; 0x29b
   2acd0:	484d      	ldr	r0, [pc, #308]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2acd2:	f008 ff7a 	bl	33bca <assert_post_action>
                                     p_xfer_desc->rx_length,
                                     p_xfer_desc->tx_length));
    NRFX_ASSERT(!(flags & NRFX_SPIM_FLAG_HOLD_XFER) ||
   2acd6:	f017 0808 	ands.w	r8, r7, #8
   2acda:	d011      	beq.n	2ad00 <nrfx_spim_xfer+0xc8>
   2acdc:	2324      	movs	r3, #36	; 0x24
   2acde:	fb03 6305 	mla	r3, r3, r5, r6
   2ace2:	7fdb      	ldrb	r3, [r3, #31]
   2ace4:	2bff      	cmp	r3, #255	; 0xff
   2ace6:	d00b      	beq.n	2ad00 <nrfx_spim_xfer+0xc8>
   2ace8:	494b      	ldr	r1, [pc, #300]	; (2ae18 <nrfx_spim_xfer+0x1e0>)
   2acea:	4846      	ldr	r0, [pc, #280]	; (2ae04 <nrfx_spim_xfer+0x1cc>)
   2acec:	f240 239d 	movw	r3, #669	; 0x29d
   2acf0:	4a45      	ldr	r2, [pc, #276]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2acf2:	f008 fc69 	bl	335c8 <printk>
   2acf6:	f240 219d 	movw	r1, #669	; 0x29d
   2acfa:	4843      	ldr	r0, [pc, #268]	; (2ae08 <nrfx_spim_xfer+0x1d0>)
   2acfc:	f008 ff65 	bl	33bca <assert_post_action>
                (p_cb->ss_pin == NRFX_SPIM_PIN_NOT_USED));

    nrfx_err_t err_code = NRFX_SUCCESS;

    if (p_cb->transfer_in_progress)
   2ad00:	2324      	movs	r3, #36	; 0x24
   2ad02:	436b      	muls	r3, r5
   2ad04:	18f2      	adds	r2, r6, r3
   2ad06:	7f51      	ldrb	r1, [r2, #29]
   2ad08:	2900      	cmp	r1, #0
   2ad0a:	d175      	bne.n	2adf8 <nrfx_spim_xfer+0x1c0>
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }
    else
    {
        if (p_cb->handler && !(flags & (NRFX_SPIM_FLAG_REPEATED_XFER |
   2ad0c:	58f3      	ldr	r3, [r6, r3]
   2ad0e:	b123      	cbz	r3, 2ad1a <nrfx_spim_xfer+0xe2>
   2ad10:	f017 0f14 	tst.w	r7, #20
                                        NRFX_SPIM_FLAG_NO_XFER_EVT_HANDLER)))
        {
            p_cb->transfer_in_progress = true;
   2ad14:	bf04      	itt	eq
   2ad16:	2301      	moveq	r3, #1
   2ad18:	7753      	strbeq	r3, [r2, #29]
        }
    }

    p_cb->evt.xfer_desc = *p_xfer_desc;
   2ad1a:	f04f 0c24 	mov.w	ip, #36	; 0x24
   2ad1e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   2ad22:	fb0c 6c05 	mla	ip, ip, r5, r6
   2ad26:	f10c 0e0c 	add.w	lr, ip, #12
   2ad2a:	e88e 000f 	stmia.w	lr, {r0, r1, r2, r3}

    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2ad2e:	f89c 001f 	ldrb.w	r0, [ip, #31]
   2ad32:	28ff      	cmp	r0, #255	; 0xff
   2ad34:	d004      	beq.n	2ad40 <nrfx_spim_xfer+0x108>
    {
#if NRFX_CHECK(NRFX_SPIM_EXTENDED_ENABLED)
        if (!p_cb->use_hw_ss)
#endif
        {
            if (p_cb->ss_active_high)
   2ad36:	f89c 301e 	ldrb.w	r3, [ip, #30]
   2ad3a:	b1bb      	cbz	r3, 2ad6c <nrfx_spim_xfer+0x134>
            {
                nrf_gpio_pin_set(p_cb->ss_pin);
   2ad3c:	f00d fea8 	bl	38a90 <nrf_gpio_pin_set>
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   2ad40:	6821      	ldr	r1, [r4, #0]
   2ad42:	b121      	cbz	r1, 2ad4e <nrfx_spim_xfer+0x116>
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
   2ad44:	f001 4360 	and.w	r3, r1, #3758096384	; 0xe0000000
   2ad48:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2ad4c:	d106      	bne.n	2ad5c <nrfx_spim_xfer+0x124>
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   2ad4e:	68a2      	ldr	r2, [r4, #8]
    if ((p_xfer_desc->p_tx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_tx_buffer)) ||
   2ad50:	b17a      	cbz	r2, 2ad72 <nrfx_spim_xfer+0x13a>
   2ad52:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        (p_xfer_desc->p_rx_buffer != NULL && !nrfx_is_in_ram(p_xfer_desc->p_rx_buffer)))
   2ad56:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2ad5a:	d00a      	beq.n	2ad72 <nrfx_spim_xfer+0x13a>
        p_cb->transfer_in_progress = false;
   2ad5c:	2324      	movs	r3, #36	; 0x24
   2ad5e:	fb03 6505 	mla	r5, r3, r5, r6
   2ad62:	2300      	movs	r3, #0
        return err_code;
   2ad64:	482d      	ldr	r0, [pc, #180]	; (2ae1c <nrfx_spim_xfer+0x1e4>)
        p_cb->transfer_in_progress = false;
   2ad66:	776b      	strb	r3, [r5, #29]
            }
        }
    }

    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
}
   2ad68:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                nrf_gpio_pin_clear(p_cb->ss_pin);
   2ad6c:	f00d fe88 	bl	38a80 <nrf_gpio_pin_clear>
   2ad70:	e7e6      	b.n	2ad40 <nrfx_spim_xfer+0x108>
    return spim_xfer(p_instance->p_reg, p_cb,  p_xfer_desc, flags);
   2ad72:	f8d9 3000 	ldr.w	r3, [r9]
    nrf_spim_tx_buffer_set(p_spim, p_xfer_desc->p_tx_buffer, p_xfer_desc->tx_length);
   2ad76:	6860      	ldr	r0, [r4, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2ad78:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2ad7c:	f8c3 0548 	str.w	r0, [r3, #1352]	; 0x548
    nrf_spim_rx_buffer_set(p_spim, p_xfer_desc->p_rx_buffer, p_xfer_desc->rx_length);
   2ad80:	68e1      	ldr	r1, [r4, #12]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2ad82:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2ad86:	2200      	movs	r2, #0
    p_reg->RXD.MAXCNT = length;
   2ad88:	f8c3 1538 	str.w	r1, [r3, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2ad8c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    if (NRFX_SPIM_FLAG_TX_POSTINC & flags)
   2ad90:	f017 0201 	ands.w	r2, r7, #1
}


NRF_STATIC_INLINE void nrf_spim_tx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_ArrayList << SPIM_TXD_LIST_LIST_Pos;
   2ad94:	bf18      	it	ne
   2ad96:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_tx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->TXD.LIST = SPIM_TXD_LIST_LIST_Disabled << SPIM_TXD_LIST_LIST_Pos;
   2ad98:	f8c3 2550 	str.w	r2, [r3, #1360]	; 0x550
    if (NRFX_SPIM_FLAG_RX_POSTINC & flags)
   2ad9c:	f017 0202 	ands.w	r2, r7, #2
}

NRF_STATIC_INLINE void nrf_spim_rx_list_enable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_ArrayList << SPIM_RXD_LIST_LIST_Pos;
   2ada0:	bf18      	it	ne
   2ada2:	2201      	movne	r2, #1
}

NRF_STATIC_INLINE void nrf_spim_rx_list_disable(NRF_SPIM_Type * p_reg)
{
    p_reg->RXD.LIST = SPIM_RXD_LIST_LIST_Disabled << SPIM_RXD_LIST_LIST_Pos;
   2ada4:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   2ada8:	f1b8 0f00 	cmp.w	r8, #0
   2adac:	d101      	bne.n	2adb2 <nrfx_spim_xfer+0x17a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2adae:	2201      	movs	r2, #1
   2adb0:	611a      	str	r2, [r3, #16]
    if (!p_cb->handler)
   2adb2:	2224      	movs	r2, #36	; 0x24
   2adb4:	436a      	muls	r2, r5
   2adb6:	58b2      	ldr	r2, [r6, r2]
   2adb8:	b9aa      	cbnz	r2, 2ade6 <nrfx_spim_xfer+0x1ae>
        if (!(flags & NRFX_SPIM_FLAG_HOLD_XFER))
   2adba:	f1b8 0f00 	cmp.w	r8, #0
   2adbe:	d103      	bne.n	2adc8 <nrfx_spim_xfer+0x190>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2adc0:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
            while (!nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   2adc4:	2a00      	cmp	r2, #0
   2adc6:	d0fb      	beq.n	2adc0 <nrfx_spim_xfer+0x188>
        if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2adc8:	2324      	movs	r3, #36	; 0x24
   2adca:	fb03 6505 	mla	r5, r3, r5, r6
   2adce:	7fe8      	ldrb	r0, [r5, #31]
   2add0:	28ff      	cmp	r0, #255	; 0xff
   2add2:	d003      	beq.n	2addc <nrfx_spim_xfer+0x1a4>
                if (p_cb->ss_active_high)
   2add4:	7fab      	ldrb	r3, [r5, #30]
   2add6:	b11b      	cbz	r3, 2ade0 <nrfx_spim_xfer+0x1a8>
                    nrf_gpio_pin_clear(p_cb->ss_pin);
   2add8:	f00d fe52 	bl	38a80 <nrf_gpio_pin_clear>
    return err_code;
   2addc:	4810      	ldr	r0, [pc, #64]	; (2ae20 <nrfx_spim_xfer+0x1e8>)
   2adde:	e7c3      	b.n	2ad68 <nrfx_spim_xfer+0x130>
                    nrf_gpio_pin_set(p_cb->ss_pin);
   2ade0:	f00d fe56 	bl	38a90 <nrf_gpio_pin_set>
   2ade4:	e7fa      	b.n	2addc <nrfx_spim_xfer+0x1a4>
    if (!enable)
   2ade6:	2240      	movs	r2, #64	; 0x40
   2ade8:	f017 0f04 	tst.w	r7, #4
    p_reg->INTENCLR = mask;
   2adec:	bf14      	ite	ne
   2adee:	f8c3 2308 	strne.w	r2, [r3, #776]	; 0x308
    p_reg->INTENSET = mask;
   2adf2:	f8c3 2304 	streq.w	r2, [r3, #772]	; 0x304
   2adf6:	e7f1      	b.n	2addc <nrfx_spim_xfer+0x1a4>
        return err_code;
   2adf8:	480a      	ldr	r0, [pc, #40]	; (2ae24 <nrfx_spim_xfer+0x1ec>)
   2adfa:	e7b5      	b.n	2ad68 <nrfx_spim_xfer+0x130>
   2adfc:	20022aa4 	.word	0x20022aa4
   2ae00:	0003f5c8 	.word	0x0003f5c8
   2ae04:	0003b77f 	.word	0x0003b77f
   2ae08:	0003f583 	.word	0x0003f583
   2ae0c:	0003f5f4 	.word	0x0003f5f4
   2ae10:	0003f63b 	.word	0x0003f63b
   2ae14:	0003f682 	.word	0x0003f682
   2ae18:	0003f726 	.word	0x0003f726
   2ae1c:	0bad000a 	.word	0x0bad000a
   2ae20:	0bad0000 	.word	0x0bad0000
   2ae24:	0bad000b 	.word	0x0bad000b

0002ae28 <nrfx_spim_3_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2ae28:	4b15      	ldr	r3, [pc, #84]	; (2ae80 <nrfx_spim_3_irq_handler+0x58>)
}
#endif

#if NRFX_CHECK(NRFX_SPIM3_ENABLED)
void nrfx_spim_3_irq_handler(void)
{
   2ae2a:	b510      	push	{r4, lr}
   2ae2c:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
    if (nrf_spim_event_check(p_spim, NRF_SPIM_EVENT_END))
   2ae30:	b322      	cbz	r2, 2ae7c <nrfx_spim_3_irq_handler+0x54>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2ae32:	2200      	movs	r2, #0
        NRFX_ASSERT(p_cb->handler);
   2ae34:	4c13      	ldr	r4, [pc, #76]	; (2ae84 <nrfx_spim_3_irq_handler+0x5c>)
   2ae36:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
   2ae3a:	6823      	ldr	r3, [r4, #0]
   2ae3c:	b95b      	cbnz	r3, 2ae56 <nrfx_spim_3_irq_handler+0x2e>
   2ae3e:	4912      	ldr	r1, [pc, #72]	; (2ae88 <nrfx_spim_3_irq_handler+0x60>)
   2ae40:	4812      	ldr	r0, [pc, #72]	; (2ae8c <nrfx_spim_3_irq_handler+0x64>)
   2ae42:	f240 23ff 	movw	r3, #767	; 0x2ff
   2ae46:	4a12      	ldr	r2, [pc, #72]	; (2ae90 <nrfx_spim_3_irq_handler+0x68>)
   2ae48:	f008 fbbe 	bl	335c8 <printk>
   2ae4c:	f240 21ff 	movw	r1, #767	; 0x2ff
   2ae50:	480f      	ldr	r0, [pc, #60]	; (2ae90 <nrfx_spim_3_irq_handler+0x68>)
   2ae52:	f008 feba 	bl	33bca <assert_post_action>
    if (p_cb->ss_pin != NRFX_SPIM_PIN_NOT_USED)
   2ae56:	7fe0      	ldrb	r0, [r4, #31]
   2ae58:	28ff      	cmp	r0, #255	; 0xff
   2ae5a:	d003      	beq.n	2ae64 <nrfx_spim_3_irq_handler+0x3c>
            if (p_cb->ss_active_high)
   2ae5c:	7fa3      	ldrb	r3, [r4, #30]
   2ae5e:	b153      	cbz	r3, 2ae76 <nrfx_spim_3_irq_handler+0x4e>
                nrf_gpio_pin_clear(p_cb->ss_pin);
   2ae60:	f00d fe0e 	bl	38a80 <nrf_gpio_pin_clear>
    p_cb->transfer_in_progress = false;
   2ae64:	2300      	movs	r3, #0
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ae66:	480b      	ldr	r0, [pc, #44]	; (2ae94 <nrfx_spim_3_irq_handler+0x6c>)
    p_cb->transfer_in_progress = false;
   2ae68:	7763      	strb	r3, [r4, #29]
    p_cb->evt.type = NRFX_SPIM_EVENT_DONE;
   2ae6a:	7223      	strb	r3, [r4, #8]
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ae6c:	e9d4 3100 	ldrd	r3, r1, [r4]
    irq_handler(NRF_SPIM3, &m_cb[NRFX_SPIM3_INST_IDX]);
}
   2ae70:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    p_cb->handler(&p_cb->evt, p_cb->p_context);
   2ae74:	4718      	bx	r3
                nrf_gpio_pin_set(p_cb->ss_pin);
   2ae76:	f00d fe0b 	bl	38a90 <nrf_gpio_pin_set>
   2ae7a:	e7f3      	b.n	2ae64 <nrfx_spim_3_irq_handler+0x3c>
}
   2ae7c:	bd10      	pop	{r4, pc}
   2ae7e:	bf00      	nop
   2ae80:	4000b000 	.word	0x4000b000
   2ae84:	20022aa4 	.word	0x20022aa4
   2ae88:	0003f575 	.word	0x0003f575
   2ae8c:	0003b77f 	.word	0x0003b77f
   2ae90:	0003f583 	.word	0x0003f583
   2ae94:	20022aac 	.word	0x20022aac

0002ae98 <nrf_gpio_pin_port_decode.isra.1>:
NRF_STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
   2ae98:	b508      	push	{r3, lr}
    switch (port)
   2ae9a:	0943      	lsrs	r3, r0, #5
   2ae9c:	bf0c      	ite	eq
   2ae9e:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   2aea2:	2300      	movne	r3, #0
    pin_number &= 0x1F;
   2aea4:	f000 001f 	and.w	r0, r0, #31
    return (mask & (1UL << pin_number)) ? true : false;
   2aea8:	fa23 f000 	lsr.w	r0, r3, r0
    NRFX_ASSERT(nrf_gpio_pin_present_check(*p_pin));
   2aeac:	07c3      	lsls	r3, r0, #31
   2aeae:	d40b      	bmi.n	2aec8 <nrf_gpio_pin_port_decode.isra.1+0x30>
   2aeb0:	4906      	ldr	r1, [pc, #24]	; (2aecc <nrf_gpio_pin_port_decode.isra.1+0x34>)
   2aeb2:	4807      	ldr	r0, [pc, #28]	; (2aed0 <nrf_gpio_pin_port_decode.isra.1+0x38>)
   2aeb4:	f240 230d 	movw	r3, #525	; 0x20d
   2aeb8:	4a06      	ldr	r2, [pc, #24]	; (2aed4 <nrf_gpio_pin_port_decode.isra.1+0x3c>)
   2aeba:	f008 fb85 	bl	335c8 <printk>
   2aebe:	f240 210d 	movw	r1, #525	; 0x20d
   2aec2:	4804      	ldr	r0, [pc, #16]	; (2aed4 <nrf_gpio_pin_port_decode.isra.1+0x3c>)
   2aec4:	f008 fe81 	bl	33bca <assert_post_action>
}
   2aec8:	4803      	ldr	r0, [pc, #12]	; (2aed8 <nrf_gpio_pin_port_decode.isra.1+0x40>)
   2aeca:	bd08      	pop	{r3, pc}
   2aecc:	0003df67 	.word	0x0003df67
   2aed0:	0003b77f 	.word	0x0003b77f
   2aed4:	0003df34 	.word	0x0003df34
   2aed8:	40842500 	.word	0x40842500

0002aedc <nrfx_twim_init>:

nrfx_err_t nrfx_twim_init(nrfx_twim_t const *        p_instance,
                          nrfx_twim_config_t const * p_config,
                          nrfx_twim_evt_handler_t    event_handler,
                          void *                     p_context)
{
   2aedc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2aee0:	4681      	mov	r9, r0
   2aee2:	4692      	mov	sl, r2
   2aee4:	4698      	mov	r8, r3
    NRFX_ASSERT(p_config);
   2aee6:	460c      	mov	r4, r1
   2aee8:	b949      	cbnz	r1, 2aefe <nrfx_twim_init+0x22>
   2aeea:	492e      	ldr	r1, [pc, #184]	; (2afa4 <nrfx_twim_init+0xc8>)
   2aeec:	482e      	ldr	r0, [pc, #184]	; (2afa8 <nrfx_twim_init+0xcc>)
   2aeee:	23de      	movs	r3, #222	; 0xde
   2aef0:	4a2e      	ldr	r2, [pc, #184]	; (2afac <nrfx_twim_init+0xd0>)
   2aef2:	f008 fb69 	bl	335c8 <printk>
   2aef6:	21de      	movs	r1, #222	; 0xde
   2aef8:	482c      	ldr	r0, [pc, #176]	; (2afac <nrfx_twim_init+0xd0>)
   2aefa:	f008 fe66 	bl	33bca <assert_post_action>
    NRFX_ASSERT(p_config->scl != p_config->sda);
   2aefe:	e9d4 2300 	ldrd	r2, r3, [r4]
   2af02:	429a      	cmp	r2, r3
   2af04:	d109      	bne.n	2af1a <nrfx_twim_init+0x3e>
   2af06:	492a      	ldr	r1, [pc, #168]	; (2afb0 <nrfx_twim_init+0xd4>)
   2af08:	4827      	ldr	r0, [pc, #156]	; (2afa8 <nrfx_twim_init+0xcc>)
   2af0a:	23df      	movs	r3, #223	; 0xdf
   2af0c:	4a27      	ldr	r2, [pc, #156]	; (2afac <nrfx_twim_init+0xd0>)
   2af0e:	f008 fb5b 	bl	335c8 <printk>
   2af12:	21df      	movs	r1, #223	; 0xdf
   2af14:	4825      	ldr	r0, [pc, #148]	; (2afac <nrfx_twim_init+0xd0>)
   2af16:	f008 fe58 	bl	33bca <assert_post_action>
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
    nrfx_err_t err_code;

    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2af1a:	2634      	movs	r6, #52	; 0x34
    twim_control_block_t * p_cb  = &m_cb[p_instance->drv_inst_idx];
   2af1c:	f899 7004 	ldrb.w	r7, [r9, #4]
    if (p_cb->state != NRFX_DRV_STATE_UNINITIALIZED)
   2af20:	4d24      	ldr	r5, [pc, #144]	; (2afb4 <nrfx_twim_init+0xd8>)
   2af22:	437e      	muls	r6, r7
   2af24:	19ab      	adds	r3, r5, r6
   2af26:	f893 202d 	ldrb.w	r2, [r3, #45]	; 0x2d
   2af2a:	bbca      	cbnz	r2, 2afa0 <nrfx_twim_init+0xc4>
    }
#endif // NRFX_CHECK(NRFX_PRS_ENABLED)

    p_cb->handler         = event_handler;
    p_cb->p_context       = p_context;
    p_cb->int_mask        = 0;
   2af2c:	609a      	str	r2, [r3, #8]
    p_cb->p_context       = p_context;
   2af2e:	f8c3 8004 	str.w	r8, [r3, #4]
    p_cb->repeated        = false;
   2af32:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    p_cb->busy            = false;
   2af36:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

    /* To secure correct signal levels on the pins used by the TWI
       master when the system is in OFF mode, and when the TWI master is
       disabled, these pins must be configured in the GPIO peripheral.
    */
    TWIM_PIN_INIT(p_config->scl);
   2af3a:	f8d4 8000 	ldr.w	r8, [r4]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   2af3e:	7b62      	ldrb	r2, [r4, #13]
    p_cb->handler         = event_handler;
   2af40:	f845 a006 	str.w	sl, [r5, r6]
    p_cb->hold_bus_uninit = p_config->hold_bus_uninit;
   2af44:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2af48:	4640      	mov	r0, r8
   2af4a:	f7ff ffa5 	bl	2ae98 <nrf_gpio_pin_port_decode.isra.1>
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2af4e:	f240 6a0c 	movw	sl, #1548	; 0x60c
   2af52:	f108 0880 	add.w	r8, r8, #128	; 0x80
   2af56:	f840 a028 	str.w	sl, [r0, r8, lsl #2]
    TWIM_PIN_INIT(p_config->sda);
   2af5a:	f8d4 8004 	ldr.w	r8, [r4, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   2af5e:	4640      	mov	r0, r8
   2af60:	f7ff ff9a 	bl	2ae98 <nrf_gpio_pin_port_decode.isra.1>

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    nrf_twim_pins_set(p_twim, p_config->scl, p_config->sda);
   2af64:	e9d4 2300 	ldrd	r2, r3, [r4]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
   2af68:	f108 0880 	add.w	r8, r8, #128	; 0x80
   2af6c:	f840 a028 	str.w	sl, [r0, r8, lsl #2]
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   2af70:	f8d9 0000 	ldr.w	r0, [r9]
    p_reg->PSEL.SCL = scl_pin;
   2af74:	f8c0 2508 	str.w	r2, [r0, #1288]	; 0x508
    p_reg->PSEL.SDA = sda_pin;
   2af78:	f8c0 350c 	str.w	r3, [r0, #1292]	; 0x50c
    nrf_twim_frequency_set(p_twim,
        (nrf_twim_frequency_t)p_config->frequency);
   2af7c:	68a3      	ldr	r3, [r4, #8]
    p_reg->FREQUENCY = frequency;
   2af7e:	f8c0 3524 	str.w	r3, [r0, #1316]	; 0x524

    if (p_cb->handler)
   2af82:	59ab      	ldr	r3, [r5, r6]
   2af84:	b11b      	cbz	r3, 2af8e <nrfx_twim_init+0xb2>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_twim),
            p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_twim));
   2af86:	f340 3007 	sbfx	r0, r0, #12, #8
   2af8a:	f7ef fe31 	bl	1abf0 <arch_irq_enable>
    }

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2af8e:	2334      	movs	r3, #52	; 0x34
   2af90:	fb03 5507 	mla	r5, r3, r7, r5
   2af94:	2301      	movs	r3, #1

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   2af96:	4808      	ldr	r0, [pc, #32]	; (2afb8 <nrfx_twim_init+0xdc>)
    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2af98:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
}
   2af9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return err_code;
   2afa0:	4806      	ldr	r0, [pc, #24]	; (2afbc <nrfx_twim_init+0xe0>)
   2afa2:	e7fb      	b.n	2af9c <nrfx_twim_init+0xc0>
   2afa4:	0003f5bf 	.word	0x0003f5bf
   2afa8:	0003b77f 	.word	0x0003b77f
   2afac:	0003f780 	.word	0x0003f780
   2afb0:	0003f7bc 	.word	0x0003f7bc
   2afb4:	20022ac8 	.word	0x20022ac8
   2afb8:	0bad0000 	.word	0x0bad0000
   2afbc:	0bad0005 	.word	0x0bad0005

0002afc0 <nrfx_twim_enable>:
}

void nrfx_twim_enable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   2afc0:	2234      	movs	r2, #52	; 0x34
{
   2afc2:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   2afc4:	4d0f      	ldr	r5, [pc, #60]	; (2b004 <nrfx_twim_enable+0x44>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2afc6:	7904      	ldrb	r4, [r0, #4]
{
   2afc8:	4606      	mov	r6, r0
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   2afca:	fb02 5204 	mla	r2, r2, r4, r5
   2afce:	f892 202d 	ldrb.w	r2, [r2, #45]	; 0x2d
   2afd2:	2a01      	cmp	r2, #1
   2afd4:	d00b      	beq.n	2afee <nrfx_twim_enable+0x2e>
   2afd6:	490c      	ldr	r1, [pc, #48]	; (2b008 <nrfx_twim_enable+0x48>)
   2afd8:	480c      	ldr	r0, [pc, #48]	; (2b00c <nrfx_twim_enable+0x4c>)
   2afda:	f44f 73a3 	mov.w	r3, #326	; 0x146
   2afde:	4a0c      	ldr	r2, [pc, #48]	; (2b010 <nrfx_twim_enable+0x50>)
   2afe0:	f008 faf2 	bl	335c8 <printk>
   2afe4:	f44f 71a3 	mov.w	r1, #326	; 0x146
   2afe8:	4809      	ldr	r0, [pc, #36]	; (2b010 <nrfx_twim_enable+0x50>)
   2afea:	f008 fdee 	bl	33bca <assert_post_action>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   2afee:	2206      	movs	r2, #6

    nrf_twim_enable(p_instance->p_twim);
   2aff0:	6833      	ldr	r3, [r6, #0]
   2aff2:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500

    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   2aff6:	2334      	movs	r3, #52	; 0x34
   2aff8:	fb03 5404 	mla	r4, r3, r4, r5
   2affc:	2302      	movs	r3, #2
   2affe:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    NRFX_LOG_INFO("Instance enabled: %d.", p_instance->drv_inst_idx);
}
   2b002:	bd70      	pop	{r4, r5, r6, pc}
   2b004:	20022ac8 	.word	0x20022ac8
   2b008:	0003f756 	.word	0x0003f756
   2b00c:	0003b77f 	.word	0x0003b77f
   2b010:	0003f780 	.word	0x0003f780

0002b014 <nrfx_twim_disable>:

void nrfx_twim_disable(nrfx_twim_t const * p_instance)
{
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2b014:	2234      	movs	r2, #52	; 0x34
{
   2b016:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2b018:	4d14      	ldr	r5, [pc, #80]	; (2b06c <nrfx_twim_disable+0x58>)
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2b01a:	7904      	ldrb	r4, [r0, #4]
{
   2b01c:	4606      	mov	r6, r0
    NRFX_ASSERT(p_cb->state != NRFX_DRV_STATE_UNINITIALIZED);
   2b01e:	fb02 5204 	mla	r2, r2, r4, r5
   2b022:	f892 202d 	ldrb.w	r2, [r2, #45]	; 0x2d
   2b026:	b95a      	cbnz	r2, 2b040 <nrfx_twim_disable+0x2c>
   2b028:	4911      	ldr	r1, [pc, #68]	; (2b070 <nrfx_twim_disable+0x5c>)
   2b02a:	4812      	ldr	r0, [pc, #72]	; (2b074 <nrfx_twim_disable+0x60>)
   2b02c:	f240 1351 	movw	r3, #337	; 0x151
   2b030:	4a11      	ldr	r2, [pc, #68]	; (2b078 <nrfx_twim_disable+0x64>)
   2b032:	f008 fac9 	bl	335c8 <printk>
   2b036:	f240 1151 	movw	r1, #337	; 0x151
   2b03a:	480f      	ldr	r0, [pc, #60]	; (2b078 <nrfx_twim_disable+0x64>)
   2b03c:	f008 fdc5 	bl	33bca <assert_post_action>

    NRF_TWIM_Type * p_twim = p_instance->p_twim;
    p_cb->int_mask = 0;
   2b040:	2234      	movs	r2, #52	; 0x34
   2b042:	2100      	movs	r1, #0
   2b044:	fb02 5404 	mla	r4, r2, r4, r5
    NRF_TWIM_Type * p_twim = p_instance->p_twim;
   2b048:	6833      	ldr	r3, [r6, #0]
    p_reg->INTENCLR = mask;
   2b04a:	4a0c      	ldr	r2, [pc, #48]	; (2b07c <nrfx_twim_disable+0x68>)
    p_cb->int_mask = 0;
   2b04c:	60a1      	str	r1, [r4, #8]
   2b04e:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    p_reg->SHORTS &= ~(mask);
   2b052:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   2b056:	f422 52bc 	bic.w	r2, r2, #6016	; 0x1780
   2b05a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   2b05e:	f8c3 1500 	str.w	r1, [r3, #1280]	; 0x500
    nrf_twim_int_disable(p_twim, NRF_TWIM_ALL_INTS_MASK);
    nrf_twim_shorts_disable(p_twim, NRF_TWIM_ALL_SHORTS_MASK);
    nrf_twim_disable(p_twim);

    p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2b062:	2301      	movs	r3, #1
   2b064:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    NRFX_LOG_INFO("Instance disabled: %d.", p_instance->drv_inst_idx);
}
   2b068:	bd70      	pop	{r4, r5, r6, pc}
   2b06a:	bf00      	nop
   2b06c:	20022ac8 	.word	0x20022ac8
   2b070:	0003f5c8 	.word	0x0003f5c8
   2b074:	0003b77f 	.word	0x0003b77f
   2b078:	0003f780 	.word	0x0003f780
   2b07c:	019c0202 	.word	0x019c0202

0002b080 <nrfx_twim_xfer>:


nrfx_err_t nrfx_twim_xfer(nrfx_twim_t           const * p_instance,
                          nrfx_twim_xfer_desc_t const * p_xfer_desc,
                          uint32_t                      flags)
{
   2b080:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   2b084:	7903      	ldrb	r3, [r0, #4]
{
   2b086:	4606      	mov	r6, r0
   2b088:	460d      	mov	r5, r1
   2b08a:	4690      	mov	r8, r2
    NRFX_ASSERT(TWIM_LENGTH_VALIDATE(p_instance->drv_inst_idx,
   2b08c:	b93b      	cbnz	r3, 2b09e <nrfx_twim_xfer+0x1e>
   2b08e:	684b      	ldr	r3, [r1, #4]
   2b090:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2b094:	d203      	bcs.n	2b09e <nrfx_twim_xfer+0x1e>
   2b096:	688b      	ldr	r3, [r1, #8]
   2b098:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2b09c:	d30b      	bcc.n	2b0b6 <nrfx_twim_xfer+0x36>
   2b09e:	49b1      	ldr	r1, [pc, #708]	; (2b364 <nrfx_twim_xfer+0x2e4>)
   2b0a0:	48b1      	ldr	r0, [pc, #708]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b0a2:	f240 2363 	movw	r3, #611	; 0x263
   2b0a6:	4ab1      	ldr	r2, [pc, #708]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b0a8:	f008 fa8e 	bl	335c8 <printk>
   2b0ac:	f240 2163 	movw	r1, #611	; 0x263
   2b0b0:	48ae      	ldr	r0, [pc, #696]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b0b2:	f008 fd8a 	bl	33bca <assert_post_action>

    nrfx_err_t err_code = NRFX_SUCCESS;
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];

    // TXRX and TXTX transfers are supported only in non-blocking mode.
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   2b0b6:	2434      	movs	r4, #52	; 0x34
    twim_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2b0b8:	f896 9004 	ldrb.w	r9, [r6, #4]
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   2b0bc:	4fac      	ldr	r7, [pc, #688]	; (2b370 <nrfx_twim_xfer+0x2f0>)
   2b0be:	fb04 f409 	mul.w	r4, r4, r9
   2b0c2:	593b      	ldr	r3, [r7, r4]
   2b0c4:	bb0b      	cbnz	r3, 2b10a <nrfx_twim_xfer+0x8a>
   2b0c6:	782b      	ldrb	r3, [r5, #0]
   2b0c8:	2b02      	cmp	r3, #2
   2b0ca:	d00f      	beq.n	2b0ec <nrfx_twim_xfer+0x6c>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   2b0cc:	782b      	ldrb	r3, [r5, #0]
   2b0ce:	2b03      	cmp	r3, #3
   2b0d0:	d11b      	bne.n	2b10a <nrfx_twim_xfer+0x8a>
   2b0d2:	f240 236a 	movw	r3, #618	; 0x26a
   2b0d6:	4aa5      	ldr	r2, [pc, #660]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b0d8:	49a6      	ldr	r1, [pc, #664]	; (2b374 <nrfx_twim_xfer+0x2f4>)
   2b0da:	48a3      	ldr	r0, [pc, #652]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b0dc:	f008 fa74 	bl	335c8 <printk>
   2b0e0:	f240 216a 	movw	r1, #618	; 0x26a
   2b0e4:	48a1      	ldr	r0, [pc, #644]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b0e6:	f008 fd70 	bl	33bca <assert_post_action>
   2b0ea:	e00e      	b.n	2b10a <nrfx_twim_xfer+0x8a>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXRX)));
   2b0ec:	f240 2369 	movw	r3, #617	; 0x269
   2b0f0:	4a9e      	ldr	r2, [pc, #632]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b0f2:	49a1      	ldr	r1, [pc, #644]	; (2b378 <nrfx_twim_xfer+0x2f8>)
   2b0f4:	489c      	ldr	r0, [pc, #624]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b0f6:	f008 fa67 	bl	335c8 <printk>
   2b0fa:	f240 2169 	movw	r1, #617	; 0x269
   2b0fe:	489b      	ldr	r0, [pc, #620]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b100:	f008 fd63 	bl	33bca <assert_post_action>
    NRFX_ASSERT( !((p_cb->handler == NULL) && (p_xfer_desc->type == NRFX_TWIM_XFER_TXTX)));
   2b104:	593b      	ldr	r3, [r7, r4]
   2b106:	2b00      	cmp	r3, #0
   2b108:	d0e0      	beq.n	2b0cc <nrfx_twim_xfer+0x4c>
                           p_xfer_desc->primary_length * sizeof(p_xfer_desc->p_primary_buf[0]));
    NRFX_LOG_DEBUG("Secondary buffer data:");
    NRFX_LOG_HEXDUMP_DEBUG(p_xfer_desc->p_secondary_buf,
                           p_xfer_desc->secondary_length * sizeof(p_xfer_desc->p_secondary_buf[0]));

    err_code = twim_xfer(p_cb, (NRF_TWIM_Type *)p_instance->p_twim, p_xfer_desc, flags);
   2b10a:	6834      	ldr	r4, [r6, #0]
    p_cb->error = false;
   2b10c:	2634      	movs	r6, #52	; 0x34
   2b10e:	2300      	movs	r3, #0
   2b110:	fb06 7609 	mla	r6, r6, r9, r7
   2b114:	f886 302e 	strb.w	r3, [r6, #46]	; 0x2e
   2b118:	68eb      	ldr	r3, [r5, #12]
   2b11a:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
    if (!nrfx_is_in_ram(p_xfer_desc->p_primary_buf))
   2b11e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2b122:	d003      	beq.n	2b12c <nrfx_twim_xfer+0xac>
        return err_code;
   2b124:	4e95      	ldr	r6, [pc, #596]	; (2b37c <nrfx_twim_xfer+0x2fc>)
    NRFX_LOG_WARNING("Function: %s, error code: %s.",
                     __func__,
                     NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
   2b126:	4630      	mov	r0, r6
   2b128:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    p_reg->INTENCLR = mask;
   2b12c:	4b94      	ldr	r3, [pc, #592]	; (2b380 <nrfx_twim_xfer+0x300>)
   2b12e:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    if (p_cb->busy)
   2b132:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
   2b136:	f003 0aff 	and.w	sl, r3, #255	; 0xff
   2b13a:	b123      	cbz	r3, 2b146 <nrfx_twim_xfer+0xc6>
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   2b13c:	68b3      	ldr	r3, [r6, #8]
        return err_code;
   2b13e:	4e91      	ldr	r6, [pc, #580]	; (2b384 <nrfx_twim_xfer+0x304>)
    p_reg->INTENSET = mask;
   2b140:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   2b144:	e7ef      	b.n	2b126 <nrfx_twim_xfer+0xa6>
                      (NRFX_TWIM_FLAG_REPEATED_XFER & flags)) ? false: true;
   2b146:	f018 0f14 	tst.w	r8, #20
   2b14a:	bf0c      	ite	eq
   2b14c:	2301      	moveq	r3, #1
   2b14e:	2300      	movne	r3, #0
    p_cb->xfer_desc = *p_xfer_desc;
   2b150:	46ae      	mov	lr, r5
        p_cb->busy = ((NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER & flags) ||
   2b152:	f886 302f 	strb.w	r3, [r6, #47]	; 0x2f
    p_cb->xfer_desc = *p_xfer_desc;
   2b156:	f106 0c0c 	add.w	ip, r6, #12
   2b15a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
   2b15e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
   2b162:	f8de 3000 	ldr.w	r3, [lr]
    p_cb->flags = flags;
   2b166:	f8c6 8020 	str.w	r8, [r6, #32]
    p_cb->xfer_desc = *p_xfer_desc;
   2b16a:	f8cc 3000 	str.w	r3, [ip]
    p_cb->repeated = (flags & NRFX_TWIM_FLAG_REPEATED_XFER) ? true : false;
   2b16e:	f3c8 1300 	ubfx	r3, r8, #4, #1
   2b172:	f886 3030 	strb.w	r3, [r6, #48]	; 0x30
}

NRF_STATIC_INLINE void nrf_twim_address_set(NRF_TWIM_Type * p_reg,
                                            uint8_t address)
{
    p_reg->ADDRESS = address;
   2b176:	786b      	ldrb	r3, [r5, #1]
   2b178:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    if (NRFX_TWIM_FLAG_TX_POSTINC & flags)
   2b17c:	f018 0301 	ands.w	r3, r8, #1
    return p_reg->RXD.AMOUNT;
}

NRF_STATIC_INLINE void nrf_twim_tx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_ArrayList << TWIM_TXD_LIST_LIST_Pos;
   2b180:	bf18      	it	ne
   2b182:	2301      	movne	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b184:	f8c4 a104 	str.w	sl, [r4, #260]	; 0x104
   2b188:	f8c4 a124 	str.w	sl, [r4, #292]	; 0x124
   2b18c:	f8c4 a160 	str.w	sl, [r4, #352]	; 0x160
   2b190:	f8c4 a148 	str.w	sl, [r4, #328]	; 0x148
}

NRF_STATIC_INLINE void nrf_twim_tx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->TXD.LIST = TWIM_TXD_LIST_LIST_Disabled << TWIM_TXD_LIST_LIST_Pos;
   2b194:	f8c4 3550 	str.w	r3, [r4, #1360]	; 0x550
    if (NRFX_TWIM_FLAG_RX_POSTINC & flags)
   2b198:	f018 0302 	ands.w	r3, r8, #2
}

NRF_STATIC_INLINE void nrf_twim_rx_list_enable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_ArrayList << TWIM_RXD_LIST_LIST_Pos;
   2b19c:	bf18      	it	ne
   2b19e:	2301      	movne	r3, #1
}

NRF_STATIC_INLINE void nrf_twim_rx_list_disable(NRF_TWIM_Type * p_reg)
{
    p_reg->RXD.LIST = TWIM_RXD_LIST_LIST_Disabled << TWIM_RXD_LIST_LIST_Pos;
   2b1a0:	f8c4 3540 	str.w	r3, [r4, #1344]	; 0x540
    switch (p_xfer_desc->type)
   2b1a4:	782b      	ldrb	r3, [r5, #0]
   2b1a6:	2b03      	cmp	r3, #3
   2b1a8:	f200 80d9 	bhi.w	2b35e <nrfx_twim_xfer+0x2de>
   2b1ac:	e8df f003 	tbb	[pc, r3]
   2b1b0:	028dc4a8 	.word	0x028dc4a8
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_REPEATED_XFER));
   2b1b4:	f018 0f10 	tst.w	r8, #16
   2b1b8:	d00b      	beq.n	2b1d2 <nrfx_twim_xfer+0x152>
   2b1ba:	4973      	ldr	r1, [pc, #460]	; (2b388 <nrfx_twim_xfer+0x308>)
   2b1bc:	486a      	ldr	r0, [pc, #424]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b1be:	f240 13a9 	movw	r3, #425	; 0x1a9
   2b1c2:	4a6a      	ldr	r2, [pc, #424]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b1c4:	f008 fa00 	bl	335c8 <printk>
   2b1c8:	f240 11a9 	movw	r1, #425	; 0x1a9
   2b1cc:	4867      	ldr	r0, [pc, #412]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b1ce:	f008 fcfc 	bl	33bca <assert_post_action>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_HOLD_XFER));
   2b1d2:	f018 0f08 	tst.w	r8, #8
   2b1d6:	d00b      	beq.n	2b1f0 <nrfx_twim_xfer+0x170>
   2b1d8:	496c      	ldr	r1, [pc, #432]	; (2b38c <nrfx_twim_xfer+0x30c>)
   2b1da:	4863      	ldr	r0, [pc, #396]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b1dc:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
   2b1e0:	4a62      	ldr	r2, [pc, #392]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b1e2:	f008 f9f1 	bl	335c8 <printk>
   2b1e6:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
   2b1ea:	4860      	ldr	r0, [pc, #384]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b1ec:	f008 fced 	bl	33bca <assert_post_action>
        NRFX_ASSERT(!(flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER));
   2b1f0:	f018 0f04 	tst.w	r8, #4
   2b1f4:	d00b      	beq.n	2b20e <nrfx_twim_xfer+0x18e>
   2b1f6:	4966      	ldr	r1, [pc, #408]	; (2b390 <nrfx_twim_xfer+0x310>)
   2b1f8:	485b      	ldr	r0, [pc, #364]	; (2b368 <nrfx_twim_xfer+0x2e8>)
   2b1fa:	f240 13ab 	movw	r3, #427	; 0x1ab
   2b1fe:	4a5b      	ldr	r2, [pc, #364]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b200:	f008 f9e2 	bl	335c8 <printk>
   2b204:	f240 11ab 	movw	r1, #427	; 0x1ab
   2b208:	4858      	ldr	r0, [pc, #352]	; (2b36c <nrfx_twim_xfer+0x2ec>)
   2b20a:	f008 fcde 	bl	33bca <assert_post_action>
   2b20e:	692a      	ldr	r2, [r5, #16]
   2b210:	f002 4360 	and.w	r3, r2, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   2b214:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   2b218:	d184      	bne.n	2b124 <nrfx_twim_xfer+0xa4>
    p_reg->SHORTS = mask;
   2b21a:	f44f 7380 	mov.w	r3, #256	; 0x100
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2b21e:	68e9      	ldr	r1, [r5, #12]
    p_reg->SHORTS = mask;
   2b220:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2b224:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2b226:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2b22a:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b22e:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b230:	2300      	movs	r3, #0
   2b232:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b236:	6221      	str	r1, [r4, #32]
   2b238:	60a1      	str	r1, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b23a:	f8d4 1150 	ldr.w	r1, [r4, #336]	; 0x150
        while (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_TXSTARTED))
   2b23e:	2900      	cmp	r1, #0
   2b240:	d0fb      	beq.n	2b23a <nrfx_twim_xfer+0x1ba>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b242:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   2b246:	68ab      	ldr	r3, [r5, #8]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2b248:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2b24c:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
        p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   2b250:	2334      	movs	r3, #52	; 0x34
   2b252:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   2b256:	fb03 7309 	mla	r3, r3, r9, r7
   2b25a:	609a      	str	r2, [r3, #8]
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   2b25c:	2308      	movs	r3, #8
    nrfx_err_t err_code = NRFX_SUCCESS;
   2b25e:	4e4d      	ldr	r6, [pc, #308]	; (2b394 <nrfx_twim_xfer+0x314>)
    if (!(flags & NRFX_TWIM_FLAG_HOLD_XFER) && (p_xfer_desc->type != NRFX_TWIM_XFER_TXTX))
   2b260:	f018 0f08 	tst.w	r8, #8
   2b264:	d104      	bne.n	2b270 <nrfx_twim_xfer+0x1f0>
   2b266:	782a      	ldrb	r2, [r5, #0]
   2b268:	2a03      	cmp	r2, #3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b26a:	bf1c      	itt	ne
   2b26c:	2201      	movne	r2, #1
   2b26e:	50e2      	strne	r2, [r4, r3]
    if (p_cb->handler)
   2b270:	2334      	movs	r3, #52	; 0x34
   2b272:	fb03 f309 	mul.w	r3, r3, r9
   2b276:	18fa      	adds	r2, r7, r3
   2b278:	58fb      	ldr	r3, [r7, r3]
   2b27a:	2b00      	cmp	r3, #0
   2b27c:	f040 808e 	bne.w	2b39c <nrfx_twim_xfer+0x31c>
                transmission_finished = true;
   2b280:	2101      	movs	r1, #1
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b282:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
   2b286:	f8d4 0104 	ldr.w	r0, [r4, #260]	; 0x104
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   2b28a:	2800      	cmp	r0, #0
   2b28c:	f040 80a0 	bne.w	2b3d0 <nrfx_twim_xfer+0x350>
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_SUSPENDED))
   2b290:	3200      	adds	r2, #0
   2b292:	bf18      	it	ne
   2b294:	2201      	movne	r2, #1
   2b296:	f8d4 0124 	ldr.w	r0, [r4, #292]	; 0x124
            if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   2b29a:	2800      	cmp	r0, #0
   2b29c:	f000 809c 	beq.w	2b3d8 <nrfx_twim_xfer+0x358>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b2a0:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b2a4:	f8d4 5160 	ldr.w	r5, [r4, #352]	; 0x160
    return p_reg->SHORTS;
   2b2a8:	f8d4 0200 	ldr.w	r0, [r4, #512]	; 0x200
                if (!(lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_STOP_MASK)))
   2b2ac:	b115      	cbz	r5, 2b2b4 <nrfx_twim_xfer+0x234>
   2b2ae:	f410 7f00 	tst.w	r0, #512	; 0x200
   2b2b2:	d104      	bne.n	2b2be <nrfx_twim_xfer+0x23e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b2b4:	6221      	str	r1, [r4, #32]
   2b2b6:	6161      	str	r1, [r4, #20]
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   2b2b8:	2d00      	cmp	r5, #0
   2b2ba:	d0e2      	beq.n	2b282 <nrfx_twim_xfer+0x202>
                    transmission_finished = false;
   2b2bc:	2200      	movs	r2, #0
                if (lasttx_triggered && (shorts_mask & NRF_TWIM_SHORT_LASTTX_SUSPEND_MASK))
   2b2be:	05c0      	lsls	r0, r0, #23
   2b2c0:	f140 808a 	bpl.w	2b3d8 <nrfx_twim_xfer+0x358>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b2c4:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
                    transmission_finished = false;
   2b2c8:	e7db      	b.n	2b282 <nrfx_twim_xfer+0x202>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2b2ca:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2b2cc:	68ea      	ldr	r2, [r5, #12]
   2b2ce:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2b2d2:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   2b2d6:	692b      	ldr	r3, [r5, #16]
   2b2d8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
        if (!nrfx_is_in_ram(p_xfer_desc->p_secondary_buf))
   2b2dc:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
   2b2e0:	f47f af20 	bne.w	2b124 <nrfx_twim_xfer+0xa4>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_secondary_buf, p_xfer_desc->secondary_length);
   2b2e4:	68aa      	ldr	r2, [r5, #8]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2b2e6:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->SHORTS = mask;
   2b2ea:	f44f 5384 	mov.w	r3, #4224	; 0x1080
    p_reg->RXD.MAXCNT = length;
   2b2ee:	f8c4 2538 	str.w	r2, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   2b2f2:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2b2f6:	2334      	movs	r3, #52	; 0x34
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2b2f8:	fb03 7309 	mla	r3, r3, r9, r7
   2b2fc:	2202      	movs	r2, #2
   2b2fe:	e012      	b.n	2b326 <nrfx_twim_xfer+0x2a6>
        nrf_twim_tx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2b300:	686b      	ldr	r3, [r5, #4]
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   2b302:	68ea      	ldr	r2, [r5, #12]
        if (NRFX_TWIM_FLAG_TX_NO_STOP & flags)
   2b304:	f018 0f20 	tst.w	r8, #32
   2b308:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   2b30c:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
   2b310:	f04f 0334 	mov.w	r3, #52	; 0x34
   2b314:	d00b      	beq.n	2b32e <nrfx_twim_xfer+0x2ae>
    p_reg->SHORTS = mask;
   2b316:	f44f 7280 	mov.w	r2, #256	; 0x100
   2b31a:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_SUSPENDED_MASK;
   2b31e:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   2b322:	fb03 7309 	mla	r3, r3, r9, r7
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2b326:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b328:	2301      	movs	r3, #1
   2b32a:	6223      	str	r3, [r4, #32]
   2b32c:	e796      	b.n	2b25c <nrfx_twim_xfer+0x1dc>
    p_reg->SHORTS = mask;
   2b32e:	f44f 7200 	mov.w	r2, #512	; 0x200
   2b332:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   2b336:	e7df      	b.n	2b2f8 <nrfx_twim_xfer+0x278>
        nrf_twim_rx_buffer_set(p_twim, p_xfer_desc->p_primary_buf, p_xfer_desc->primary_length);
   2b338:	686b      	ldr	r3, [r5, #4]
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
   2b33a:	68ea      	ldr	r2, [r5, #12]
   2b33c:	f8c4 2534 	str.w	r2, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
   2b340:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    p_reg->SHORTS = mask;
   2b344:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   2b348:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
        p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2b34c:	2334      	movs	r3, #52	; 0x34
   2b34e:	2202      	movs	r2, #2
   2b350:	fb03 7309 	mla	r3, r3, r9, r7
   2b354:	609a      	str	r2, [r3, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b356:	2301      	movs	r3, #1
   2b358:	6223      	str	r3, [r4, #32]
        start_task = NRF_TWIM_TASK_STARTRX;
   2b35a:	2300      	movs	r3, #0
   2b35c:	e77f      	b.n	2b25e <nrfx_twim_xfer+0x1de>
    nrf_twim_task_t  start_task = NRF_TWIM_TASK_STARTTX;
   2b35e:	2308      	movs	r3, #8
        err_code = NRFX_ERROR_INVALID_PARAM;
   2b360:	4e0d      	ldr	r6, [pc, #52]	; (2b398 <nrfx_twim_xfer+0x318>)
   2b362:	e77d      	b.n	2b260 <nrfx_twim_xfer+0x1e0>
   2b364:	0003f7db 	.word	0x0003f7db
   2b368:	0003b77f 	.word	0x0003b77f
   2b36c:	0003f780 	.word	0x0003f780
   2b370:	20022ac8 	.word	0x20022ac8
   2b374:	0003f8d6 	.word	0x0003f8d6
   2b378:	0003f886 	.word	0x0003f886
   2b37c:	0bad000a 	.word	0x0bad000a
   2b380:	019c0202 	.word	0x019c0202
   2b384:	0bad000b 	.word	0x0bad000b
   2b388:	0003f926 	.word	0x0003f926
   2b38c:	0003f93c 	.word	0x0003f93c
   2b390:	0003f952 	.word	0x0003f952
   2b394:	0bad0000 	.word	0x0bad0000
   2b398:	0bad0004 	.word	0x0bad0004
        if (flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER)
   2b39c:	f018 0f04 	tst.w	r8, #4
            p_cb->int_mask = 0;
   2b3a0:	bf1c      	itt	ne
   2b3a2:	2300      	movne	r3, #0
   2b3a4:	6093      	strne	r3, [r2, #8]
        if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK))
   2b3a6:	f018 0f40 	tst.w	r8, #64	; 0x40
   2b3aa:	d106      	bne.n	2b3ba <nrfx_twim_xfer+0x33a>
            p_cb->int_mask |= NRF_TWIM_INT_STOPPED_MASK;
   2b3ac:	2334      	movs	r3, #52	; 0x34
   2b3ae:	fb03 7309 	mla	r3, r3, r9, r7
   2b3b2:	689a      	ldr	r2, [r3, #8]
   2b3b4:	f042 0202 	orr.w	r2, r2, #2
   2b3b8:	609a      	str	r2, [r3, #8]
        p_cb->int_mask |= NRF_TWIM_INT_ERROR_MASK;
   2b3ba:	2334      	movs	r3, #52	; 0x34
   2b3bc:	fb03 7709 	mla	r7, r3, r9, r7
   2b3c0:	68bb      	ldr	r3, [r7, #8]
   2b3c2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   2b3c6:	60bb      	str	r3, [r7, #8]
        nrf_twim_int_enable(p_twim, p_cb->int_mask);
   2b3c8:	68bb      	ldr	r3, [r7, #8]
    p_reg->INTENSET = mask;
   2b3ca:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
   2b3ce:	e6aa      	b.n	2b126 <nrfx_twim_xfer+0xa6>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b3d0:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
                transmission_finished = true;
   2b3d4:	2201      	movs	r2, #1
   2b3d6:	e75e      	b.n	2b296 <nrfx_twim_xfer+0x216>
        } while (!transmission_finished);
   2b3d8:	2a00      	cmp	r2, #0
   2b3da:	f43f af52 	beq.w	2b282 <nrfx_twim_xfer+0x202>
        p_cb->busy = false;
   2b3de:	2134      	movs	r1, #52	; 0x34
   2b3e0:	2000      	movs	r0, #0
   2b3e2:	fb01 7209 	mla	r2, r1, r9, r7
    uint32_t error_source = p_reg->ERRORSRC;
   2b3e6:	f8d4 34c4 	ldr.w	r3, [r4, #1220]	; 0x4c4
    p_reg->ERRORSRC = error_source;
   2b3ea:	f8c4 34c4 	str.w	r3, [r4, #1220]	; 0x4c4
   2b3ee:	f882 002f 	strb.w	r0, [r2, #47]	; 0x2f
        if (errorsrc)
   2b3f2:	b18b      	cbz	r3, 2b418 <nrfx_twim_xfer+0x398>
        ret = NRFX_ERROR_DRV_TWI_ERR_OVERRUN;
   2b3f4:	4a0f      	ldr	r2, [pc, #60]	; (2b434 <nrfx_twim_xfer+0x3b4>)
   2b3f6:	f013 0f01 	tst.w	r3, #1
   2b3fa:	4e0f      	ldr	r6, [pc, #60]	; (2b438 <nrfx_twim_xfer+0x3b8>)
   2b3fc:	bf18      	it	ne
   2b3fe:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_ANACK;
   2b400:	f013 0f02 	tst.w	r3, #2
   2b404:	f102 0201 	add.w	r2, r2, #1
   2b408:	bf18      	it	ne
   2b40a:	4616      	movne	r6, r2
        ret = NRFX_ERROR_DRV_TWI_ERR_DNACK;
   2b40c:	f013 0f04 	tst.w	r3, #4
   2b410:	4b0a      	ldr	r3, [pc, #40]	; (2b43c <nrfx_twim_xfer+0x3bc>)
   2b412:	bf18      	it	ne
   2b414:	461e      	movne	r6, r3
   2b416:	e686      	b.n	2b126 <nrfx_twim_xfer+0xa6>
            if (!(flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) &&
   2b418:	f018 0f40 	tst.w	r8, #64	; 0x40
   2b41c:	f47f ae83 	bne.w	2b126 <nrfx_twim_xfer+0xa6>
                !xfer_completeness_check(p_twim, p_cb))
   2b420:	fb09 7101 	mla	r1, r9, r1, r7
   2b424:	4620      	mov	r0, r4
   2b426:	f00d fb3b 	bl	38aa0 <xfer_completeness_check>
                err_code = NRFX_ERROR_INTERNAL;
   2b42a:	4b03      	ldr	r3, [pc, #12]	; (2b438 <nrfx_twim_xfer+0x3b8>)
   2b42c:	2800      	cmp	r0, #0
   2b42e:	bf08      	it	eq
   2b430:	461e      	moveq	r6, r3
   2b432:	e678      	b.n	2b126 <nrfx_twim_xfer+0xa6>
   2b434:	0bae0000 	.word	0x0bae0000
   2b438:	0bad0001 	.word	0x0bad0001
   2b43c:	0bae0002 	.word	0x0bae0002

0002b440 <nrfx_twim_2_irq_handler>:
}
#endif

#if NRFX_CHECK(NRFX_TWIM2_ENABLED)
void nrfx_twim_2_irq_handler(void)
{
   2b440:	b5f0      	push	{r4, r5, r6, r7, lr}
    NRFX_ASSERT(p_cb->handler);
   2b442:	4c5d      	ldr	r4, [pc, #372]	; (2b5b8 <nrfx_twim_2_irq_handler+0x178>)
{
   2b444:	b087      	sub	sp, #28
    NRFX_ASSERT(p_cb->handler);
   2b446:	6823      	ldr	r3, [r4, #0]
   2b448:	b95b      	cbnz	r3, 2b462 <nrfx_twim_2_irq_handler+0x22>
   2b44a:	495c      	ldr	r1, [pc, #368]	; (2b5bc <nrfx_twim_2_irq_handler+0x17c>)
   2b44c:	485c      	ldr	r0, [pc, #368]	; (2b5c0 <nrfx_twim_2_irq_handler+0x180>)
   2b44e:	f44f 7329 	mov.w	r3, #676	; 0x2a4
   2b452:	4a5c      	ldr	r2, [pc, #368]	; (2b5c4 <nrfx_twim_2_irq_handler+0x184>)
   2b454:	f008 f8b8 	bl	335c8 <printk>
   2b458:	f44f 7129 	mov.w	r1, #676	; 0x2a4
   2b45c:	4859      	ldr	r0, [pc, #356]	; (2b5c4 <nrfx_twim_2_irq_handler+0x184>)
   2b45e:	f008 fbb4 	bl	33bca <assert_post_action>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b462:	4b59      	ldr	r3, [pc, #356]	; (2b5c8 <nrfx_twim_2_irq_handler+0x188>)
   2b464:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   2b468:	461d      	mov	r5, r3
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_ERROR))
   2b46a:	b1ea      	cbz	r2, 2b4a8 <nrfx_twim_2_irq_handler+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b46c:	2200      	movs	r2, #0
   2b46e:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b472:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        if (!nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   2b476:	b9ba      	cbnz	r2, 2b4a8 <nrfx_twim_2_irq_handler+0x68>
            nrf_twim_int_disable(p_twim, p_cb->int_mask);
   2b478:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   2b47a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK;
   2b47e:	2202      	movs	r2, #2
   2b480:	60a2      	str	r2, [r4, #8]
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   2b482:	68a2      	ldr	r2, [r4, #8]
    p_reg->INTENSET = mask;
   2b484:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b488:	f8d3 2160 	ldr.w	r2, [r3, #352]	; 0x160
            if (!(nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_LASTTX) &&
   2b48c:	b11a      	cbz	r2, 2b496 <nrfx_twim_2_irq_handler+0x56>
    return p_reg->SHORTS;
   2b48e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
   2b492:	059e      	lsls	r6, r3, #22
   2b494:	d403      	bmi.n	2b49e <nrfx_twim_2_irq_handler+0x5e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b496:	2201      	movs	r2, #1
   2b498:	4b4b      	ldr	r3, [pc, #300]	; (2b5c8 <nrfx_twim_2_irq_handler+0x188>)
   2b49a:	621a      	str	r2, [r3, #32]
   2b49c:	615a      	str	r2, [r3, #20]
            p_cb->error = true;
   2b49e:	2301      	movs	r3, #1
   2b4a0:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
    twim_irq_handler(NRF_TWIM2, &m_cb[NRFX_TWIM2_INST_IDX]);
}
   2b4a4:	b007      	add	sp, #28
   2b4a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   2b4a8:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    if (nrf_twim_event_check(p_twim, NRF_TWIM_EVENT_STOPPED))
   2b4ac:	2b00      	cmp	r3, #0
   2b4ae:	d04e      	beq.n	2b54e <nrfx_twim_2_irq_handler+0x10e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b4b0:	2300      	movs	r3, #0
   2b4b2:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_SPURIOUS_STOP_CHECK) && !p_cb->error)
   2b4b6:	6a23      	ldr	r3, [r4, #32]
   2b4b8:	065d      	lsls	r5, r3, #25
   2b4ba:	d40a      	bmi.n	2b4d2 <nrfx_twim_2_irq_handler+0x92>
   2b4bc:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   2b4c0:	b93b      	cbnz	r3, 2b4d2 <nrfx_twim_2_irq_handler+0x92>
            p_cb->error = !xfer_completeness_check(p_twim, p_cb);
   2b4c2:	493d      	ldr	r1, [pc, #244]	; (2b5b8 <nrfx_twim_2_irq_handler+0x178>)
   2b4c4:	4840      	ldr	r0, [pc, #256]	; (2b5c8 <nrfx_twim_2_irq_handler+0x188>)
   2b4c6:	f00d faeb 	bl	38aa0 <xfer_completeness_check>
   2b4ca:	f080 0001 	eor.w	r0, r0, #1
   2b4ce:	f884 002e 	strb.w	r0, [r4, #46]	; 0x2e
        if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER))
   2b4d2:	6a23      	ldr	r3, [r4, #32]
   2b4d4:	f013 0704 	ands.w	r7, r3, #4
   2b4d8:	d11e      	bne.n	2b518 <nrfx_twim_2_irq_handler+0xd8>
            event.xfer_desc = p_cb->xfer_desc;
   2b4da:	4e3c      	ldr	r6, [pc, #240]	; (2b5cc <nrfx_twim_2_irq_handler+0x18c>)
   2b4dc:	ad01      	add	r5, sp, #4
   2b4de:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
   2b4e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2b4e2:	6833      	ldr	r3, [r6, #0]
   2b4e4:	f894 c030 	ldrb.w	ip, [r4, #48]	; 0x30
   2b4e8:	602b      	str	r3, [r5, #0]
   2b4ea:	4b37      	ldr	r3, [pc, #220]	; (2b5c8 <nrfx_twim_2_irq_handler+0x188>)
   2b4ec:	f8c3 7160 	str.w	r7, [r3, #352]	; 0x160
   2b4f0:	f8c3 715c 	str.w	r7, [r3, #348]	; 0x15c
            if (!p_cb->repeated || p_cb->error)
   2b4f4:	f1bc 0f00 	cmp.w	ip, #0
   2b4f8:	d002      	beq.n	2b500 <nrfx_twim_2_irq_handler+0xc0>
   2b4fa:	f894 202e 	ldrb.w	r2, [r4, #46]	; 0x2e
   2b4fe:	b15a      	cbz	r2, 2b518 <nrfx_twim_2_irq_handler+0xd8>
    p_reg->SHORTS = mask;
   2b500:	2200      	movs	r2, #0
   2b502:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
                p_cb->int_mask = 0;
   2b506:	60a2      	str	r2, [r4, #8]
    p_reg->INTENCLR = mask;
   2b508:	4a31      	ldr	r2, [pc, #196]	; (2b5d0 <nrfx_twim_2_irq_handler+0x190>)
   2b50a:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
   2b50e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   2b512:	4b30      	ldr	r3, [pc, #192]	; (2b5d4 <nrfx_twim_2_irq_handler+0x194>)
   2b514:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    uint32_t error_source = p_reg->ERRORSRC;
   2b518:	4a2b      	ldr	r2, [pc, #172]	; (2b5c8 <nrfx_twim_2_irq_handler+0x188>)
   2b51a:	f8d2 34c4 	ldr.w	r3, [r2, #1220]	; 0x4c4
    if (errorsrc & NRF_TWIM_ERROR_ADDRESS_NACK)
   2b51e:	0798      	lsls	r0, r3, #30
    p_reg->ERRORSRC = error_source;
   2b520:	f8c2 34c4 	str.w	r3, [r2, #1220]	; 0x4c4
   2b524:	d53a      	bpl.n	2b59c <nrfx_twim_2_irq_handler+0x15c>
        event.type = NRFX_TWIM_EVT_ADDRESS_NACK;
   2b526:	2301      	movs	r3, #1
        event.type = NRFX_TWIM_EVT_DONE;
   2b528:	f88d 3000 	strb.w	r3, [sp]
    if (!p_cb->repeated)
   2b52c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   2b530:	b90b      	cbnz	r3, 2b536 <nrfx_twim_2_irq_handler+0xf6>
        p_cb->busy = false;
   2b532:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
    if (!(p_cb->flags & NRFX_TWIM_FLAG_NO_XFER_EVT_HANDLER) || p_cb->error)
   2b536:	6a23      	ldr	r3, [r4, #32]
   2b538:	075b      	lsls	r3, r3, #29
   2b53a:	d503      	bpl.n	2b544 <nrfx_twim_2_irq_handler+0x104>
   2b53c:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   2b540:	2b00      	cmp	r3, #0
   2b542:	d0af      	beq.n	2b4a4 <nrfx_twim_2_irq_handler+0x64>
        p_cb->handler(&event, p_cb->p_context);
   2b544:	e9d4 3100 	ldrd	r3, r1, [r4]
   2b548:	4668      	mov	r0, sp
   2b54a:	4798      	blx	r3
}
   2b54c:	e7aa      	b.n	2b4a4 <nrfx_twim_2_irq_handler+0x64>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b54e:	f8c5 3148 	str.w	r3, [r5, #328]	; 0x148
        if (p_cb->xfer_desc.type == NRFX_TWIM_XFER_TX)
   2b552:	7b23      	ldrb	r3, [r4, #12]
   2b554:	b983      	cbnz	r3, 2b578 <nrfx_twim_2_irq_handler+0x138>
            event.xfer_desc = p_cb->xfer_desc;
   2b556:	4f1d      	ldr	r7, [pc, #116]	; (2b5cc <nrfx_twim_2_irq_handler+0x18c>)
   2b558:	ae01      	add	r6, sp, #4
   2b55a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
   2b55c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
   2b55e:	683b      	ldr	r3, [r7, #0]
   2b560:	6033      	str	r3, [r6, #0]
            if (!p_cb->repeated)
   2b562:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
   2b566:	2b00      	cmp	r3, #0
   2b568:	d1d6      	bne.n	2b518 <nrfx_twim_2_irq_handler+0xd8>
    p_reg->SHORTS = mask;
   2b56a:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
                p_cb->int_mask = 0;
   2b56e:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   2b570:	4b17      	ldr	r3, [pc, #92]	; (2b5d0 <nrfx_twim_2_irq_handler+0x190>)
   2b572:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
   2b576:	e7ca      	b.n	2b50e <nrfx_twim_2_irq_handler+0xce>
    p_reg->SHORTS = mask;
   2b578:	f44f 7300 	mov.w	r3, #512	; 0x200
   2b57c:	f8c5 3200 	str.w	r3, [r5, #512]	; 0x200
            p_cb->int_mask = NRF_TWIM_INT_STOPPED_MASK | NRF_TWIM_INT_ERROR_MASK;
   2b580:	f240 2302 	movw	r3, #514	; 0x202
   2b584:	60a3      	str	r3, [r4, #8]
    p_reg->INTENCLR = mask;
   2b586:	f103 73ce 	add.w	r3, r3, #27000832	; 0x19c0000
   2b58a:	f8c5 3308 	str.w	r3, [r5, #776]	; 0x308
            nrf_twim_int_enable(p_twim, p_cb->int_mask);
   2b58e:	68a3      	ldr	r3, [r4, #8]
    p_reg->INTENSET = mask;
   2b590:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   2b594:	2301      	movs	r3, #1
   2b596:	60ab      	str	r3, [r5, #8]
   2b598:	622b      	str	r3, [r5, #32]
            return;
   2b59a:	e783      	b.n	2b4a4 <nrfx_twim_2_irq_handler+0x64>
    else if (errorsrc & NRF_TWIM_ERROR_DATA_NACK)
   2b59c:	0759      	lsls	r1, r3, #29
   2b59e:	d501      	bpl.n	2b5a4 <nrfx_twim_2_irq_handler+0x164>
        event.type = NRFX_TWIM_EVT_DATA_NACK;
   2b5a0:	2302      	movs	r3, #2
   2b5a2:	e7c1      	b.n	2b528 <nrfx_twim_2_irq_handler+0xe8>
    else if (errorsrc & NRF_TWIM_ERROR_OVERRUN)
   2b5a4:	07da      	lsls	r2, r3, #31
   2b5a6:	d501      	bpl.n	2b5ac <nrfx_twim_2_irq_handler+0x16c>
        event.type = NRFX_TWIM_EVT_OVERRUN;
   2b5a8:	2303      	movs	r3, #3
   2b5aa:	e7bd      	b.n	2b528 <nrfx_twim_2_irq_handler+0xe8>
    else if (p_cb->error)
   2b5ac:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
   2b5b0:	2b00      	cmp	r3, #0
   2b5b2:	d0b9      	beq.n	2b528 <nrfx_twim_2_irq_handler+0xe8>
        event.type = NRFX_TWIM_EVT_BUS_ERROR;
   2b5b4:	2304      	movs	r3, #4
   2b5b6:	e7b7      	b.n	2b528 <nrfx_twim_2_irq_handler+0xe8>
   2b5b8:	20022ac8 	.word	0x20022ac8
   2b5bc:	0003f575 	.word	0x0003f575
   2b5c0:	0003b77f 	.word	0x0003b77f
   2b5c4:	0003f780 	.word	0x0003f780
   2b5c8:	4000a000 	.word	0x4000a000
   2b5cc:	20022ad4 	.word	0x20022ad4
   2b5d0:	019c0202 	.word	0x019c0202
   2b5d4:	e000e100 	.word	0xe000e100

0002b5d8 <nrfx_wdt_init>:
static wdt_control_block_t m_cb[NRFX_WDT_ENABLED_COUNT];

nrfx_err_t nrfx_wdt_init(nrfx_wdt_t const *        p_instance,
                         nrfx_wdt_config_t const * p_config,
                         nrfx_wdt_event_handler_t  wdt_event_handler)
{
   2b5d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2b5dc:	4606      	mov	r6, r0
   2b5de:	4617      	mov	r7, r2
    NRFX_ASSERT(p_config);
   2b5e0:	460c      	mov	r4, r1
   2b5e2:	b949      	cbnz	r1, 2b5f8 <nrfx_wdt_init+0x20>
   2b5e4:	4921      	ldr	r1, [pc, #132]	; (2b66c <nrfx_wdt_init+0x94>)
   2b5e6:	4822      	ldr	r0, [pc, #136]	; (2b670 <nrfx_wdt_init+0x98>)
   2b5e8:	233d      	movs	r3, #61	; 0x3d
   2b5ea:	4a22      	ldr	r2, [pc, #136]	; (2b674 <nrfx_wdt_init+0x9c>)
   2b5ec:	f007 ffec 	bl	335c8 <printk>
   2b5f0:	213d      	movs	r1, #61	; 0x3d
   2b5f2:	4820      	ldr	r0, [pc, #128]	; (2b674 <nrfx_wdt_init+0x9c>)
   2b5f4:	f008 fae9 	bl	33bca <assert_post_action>
    nrfx_err_t err_code;

    wdt_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2b5f8:	7932      	ldrb	r2, [r6, #4]

#if NRFX_CHECK(NRFX_WDT_CONFIG_NO_IRQ)
    (void)wdt_event_handler;
#else
    p_cb->wdt_event_handler = wdt_event_handler;
   2b5fa:	4b1f      	ldr	r3, [pc, #124]	; (2b678 <nrfx_wdt_init+0xa0>)
   2b5fc:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
   2b600:	604f      	str	r7, [r1, #4]
#endif

    if (p_cb->state == NRFX_DRV_STATE_UNINITIALIZED)
   2b602:	f813 1032 	ldrb.w	r1, [r3, r2, lsl #3]
   2b606:	bb69      	cbnz	r1, 2b664 <nrfx_wdt_init+0x8c>
    {
        p_cb->state = NRFX_DRV_STATE_INITIALIZED;
   2b608:	2001      	movs	r0, #1
   2b60a:	f803 0032 	strb.w	r0, [r3, r2, lsl #3]
    p_reg->CONFIG = behaviour;
   2b60e:	7822      	ldrb	r2, [r4, #0]
                         __func__,
                         NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }

    nrf_wdt_behaviour_set(p_instance->p_reg, p_config->behaviour);
   2b610:	6833      	ldr	r3, [r6, #0]
   2b612:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c

    uint64_t ticks = (p_config->reload_value * 32768ULL) / 1000;
   2b616:	6863      	ldr	r3, [r4, #4]
   2b618:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2b61c:	0c5d      	lsrs	r5, r3, #17
   2b61e:	03dc      	lsls	r4, r3, #15
   2b620:	4620      	mov	r0, r4
   2b622:	2300      	movs	r3, #0
   2b624:	4629      	mov	r1, r5
   2b626:	f7e2 f8a3 	bl	d770 <__aeabi_uldivmod>
    NRFX_ASSERT(ticks <= UINT32_MAX);
   2b62a:	f5b5 7f7a 	cmp.w	r5, #1000	; 0x3e8
   2b62e:	bf08      	it	eq
   2b630:	2c00      	cmpeq	r4, #0
    uint64_t ticks = (p_config->reload_value * 32768ULL) / 1000;
   2b632:	4680      	mov	r8, r0
    NRFX_ASSERT(ticks <= UINT32_MAX);
   2b634:	d309      	bcc.n	2b64a <nrfx_wdt_init+0x72>
   2b636:	4911      	ldr	r1, [pc, #68]	; (2b67c <nrfx_wdt_init+0xa4>)
   2b638:	480d      	ldr	r0, [pc, #52]	; (2b670 <nrfx_wdt_init+0x98>)
   2b63a:	2358      	movs	r3, #88	; 0x58
   2b63c:	4a0d      	ldr	r2, [pc, #52]	; (2b674 <nrfx_wdt_init+0x9c>)
   2b63e:	f007 ffc3 	bl	335c8 <printk>
   2b642:	2158      	movs	r1, #88	; 0x58
   2b644:	480b      	ldr	r0, [pc, #44]	; (2b674 <nrfx_wdt_init+0x9c>)
   2b646:	f008 fac0 	bl	33bca <assert_post_action>

    nrf_wdt_reload_value_set(p_instance->p_reg, (uint32_t) ticks);
   2b64a:	6830      	ldr	r0, [r6, #0]
}

NRF_STATIC_INLINE void nrf_wdt_reload_value_set(NRF_WDT_Type * p_reg, uint32_t reload_value)
{
    p_reg->CRV = reload_value;
   2b64c:	f8c0 8504 	str.w	r8, [r0, #1284]	; 0x504

#if !NRFX_CHECK(NRFX_WDT_CONFIG_NO_IRQ)
    if (wdt_event_handler)
   2b650:	b137      	cbz	r7, 2b660 <nrfx_wdt_init+0x88>
    p_reg->INTENSET = mask;
   2b652:	2301      	movs	r3, #1
   2b654:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
    {
        nrf_wdt_int_enable(p_instance->p_reg, NRF_WDT_INT_TIMEOUT_MASK);
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(p_instance->p_reg), p_config->interrupt_priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(p_instance->p_reg));
   2b658:	f340 3007 	sbfx	r0, r0, #12, #8
   2b65c:	f7ef fac8 	bl	1abf0 <arch_irq_enable>
    }
#endif

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
   2b660:	4807      	ldr	r0, [pc, #28]	; (2b680 <nrfx_wdt_init+0xa8>)
   2b662:	e000      	b.n	2b666 <nrfx_wdt_init+0x8e>
        return err_code;
   2b664:	4807      	ldr	r0, [pc, #28]	; (2b684 <nrfx_wdt_init+0xac>)
}
   2b666:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2b66a:	bf00      	nop
   2b66c:	0003f5bf 	.word	0x0003f5bf
   2b670:	0003b77f 	.word	0x0003b77f
   2b674:	0003f9ce 	.word	0x0003f9ce
   2b678:	20022afc 	.word	0x20022afc
   2b67c:	0003fa09 	.word	0x0003fa09
   2b680:	0bad0000 	.word	0x0bad0000
   2b684:	0bad0005 	.word	0x0bad0005

0002b688 <nrfx_wdt_enable>:


void nrfx_wdt_enable(nrfx_wdt_t const * p_instance)
{
   2b688:	b570      	push	{r4, r5, r6, lr}
    wdt_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
    NRFX_ASSERT(p_cb->alloc_index != 0);
   2b68a:	4c13      	ldr	r4, [pc, #76]	; (2b6d8 <nrfx_wdt_enable+0x50>)
    wdt_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2b68c:	7905      	ldrb	r5, [r0, #4]
{
   2b68e:	4606      	mov	r6, r0
    NRFX_ASSERT(p_cb->alloc_index != 0);
   2b690:	eb04 03c5 	add.w	r3, r4, r5, lsl #3
   2b694:	785b      	ldrb	r3, [r3, #1]
   2b696:	b94b      	cbnz	r3, 2b6ac <nrfx_wdt_enable+0x24>
   2b698:	4910      	ldr	r1, [pc, #64]	; (2b6dc <nrfx_wdt_enable+0x54>)
   2b69a:	4811      	ldr	r0, [pc, #68]	; (2b6e0 <nrfx_wdt_enable+0x58>)
   2b69c:	236e      	movs	r3, #110	; 0x6e
   2b69e:	4a11      	ldr	r2, [pc, #68]	; (2b6e4 <nrfx_wdt_enable+0x5c>)
   2b6a0:	f007 ff92 	bl	335c8 <printk>
   2b6a4:	216e      	movs	r1, #110	; 0x6e
   2b6a6:	480f      	ldr	r0, [pc, #60]	; (2b6e4 <nrfx_wdt_enable+0x5c>)
   2b6a8:	f008 fa8f 	bl	33bca <assert_post_action>
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   2b6ac:	f814 3035 	ldrb.w	r3, [r4, r5, lsl #3]
   2b6b0:	2b01      	cmp	r3, #1
   2b6b2:	d009      	beq.n	2b6c8 <nrfx_wdt_enable+0x40>
   2b6b4:	490c      	ldr	r1, [pc, #48]	; (2b6e8 <nrfx_wdt_enable+0x60>)
   2b6b6:	480a      	ldr	r0, [pc, #40]	; (2b6e0 <nrfx_wdt_enable+0x58>)
   2b6b8:	236f      	movs	r3, #111	; 0x6f
   2b6ba:	4a0a      	ldr	r2, [pc, #40]	; (2b6e4 <nrfx_wdt_enable+0x5c>)
   2b6bc:	f007 ff84 	bl	335c8 <printk>
   2b6c0:	216f      	movs	r1, #111	; 0x6f
   2b6c2:	4808      	ldr	r0, [pc, #32]	; (2b6e4 <nrfx_wdt_enable+0x5c>)
   2b6c4:	f008 fa81 	bl	33bca <assert_post_action>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x01UL;
   2b6c8:	2201      	movs	r2, #1
    nrf_wdt_task_trigger(p_instance->p_reg, NRF_WDT_TASK_START);
   2b6ca:	6833      	ldr	r3, [r6, #0]
   2b6cc:	601a      	str	r2, [r3, #0]
    p_cb->state = NRFX_DRV_STATE_POWERED_ON;
   2b6ce:	2302      	movs	r3, #2
   2b6d0:	f804 3035 	strb.w	r3, [r4, r5, lsl #3]
    NRFX_LOG_INFO("Enabled.");
}
   2b6d4:	bd70      	pop	{r4, r5, r6, pc}
   2b6d6:	bf00      	nop
   2b6d8:	20022afc 	.word	0x20022afc
   2b6dc:	0003f9b7 	.word	0x0003f9b7
   2b6e0:	0003b77f 	.word	0x0003b77f
   2b6e4:	0003f9ce 	.word	0x0003f9ce
   2b6e8:	0003f756 	.word	0x0003f756

0002b6ec <nrfx_wdt_channel_alloc>:
        nrf_wdt_reload_request_set(p_instance->p_reg, (nrf_wdt_rr_register_t)(NRF_WDT_RR0 + i));
    }
}

nrfx_err_t nrfx_wdt_channel_alloc(nrfx_wdt_t const * p_instance, nrfx_wdt_channel_id * p_channel_id)
{
   2b6ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2b6ee:	4605      	mov	r5, r0
    nrfx_err_t result;
    wdt_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
   2b6f0:	7907      	ldrb	r7, [r0, #4]

    NRFX_ASSERT(p_channel_id);
   2b6f2:	460e      	mov	r6, r1
   2b6f4:	b949      	cbnz	r1, 2b70a <nrfx_wdt_channel_alloc+0x1e>
   2b6f6:	491c      	ldr	r1, [pc, #112]	; (2b768 <nrfx_wdt_channel_alloc+0x7c>)
   2b6f8:	481c      	ldr	r0, [pc, #112]	; (2b76c <nrfx_wdt_channel_alloc+0x80>)
   2b6fa:	2385      	movs	r3, #133	; 0x85
   2b6fc:	4a1c      	ldr	r2, [pc, #112]	; (2b770 <nrfx_wdt_channel_alloc+0x84>)
   2b6fe:	f007 ff63 	bl	335c8 <printk>
   2b702:	2185      	movs	r1, #133	; 0x85
   2b704:	481a      	ldr	r0, [pc, #104]	; (2b770 <nrfx_wdt_channel_alloc+0x84>)
   2b706:	f008 fa60 	bl	33bca <assert_post_action>
    NRFX_ASSERT(p_cb->state == NRFX_DRV_STATE_INITIALIZED);
   2b70a:	4c1a      	ldr	r4, [pc, #104]	; (2b774 <nrfx_wdt_channel_alloc+0x88>)
   2b70c:	f814 2037 	ldrb.w	r2, [r4, r7, lsl #3]
   2b710:	2a01      	cmp	r2, #1
   2b712:	d009      	beq.n	2b728 <nrfx_wdt_channel_alloc+0x3c>
   2b714:	4918      	ldr	r1, [pc, #96]	; (2b778 <nrfx_wdt_channel_alloc+0x8c>)
   2b716:	4815      	ldr	r0, [pc, #84]	; (2b76c <nrfx_wdt_channel_alloc+0x80>)
   2b718:	2386      	movs	r3, #134	; 0x86
   2b71a:	4a15      	ldr	r2, [pc, #84]	; (2b770 <nrfx_wdt_channel_alloc+0x84>)
   2b71c:	f007 ff54 	bl	335c8 <printk>
   2b720:	2186      	movs	r1, #134	; 0x86
   2b722:	4813      	ldr	r0, [pc, #76]	; (2b770 <nrfx_wdt_channel_alloc+0x84>)
   2b724:	f008 fa51 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2b728:	f04f 0320 	mov.w	r3, #32
   2b72c:	f3ef 8c11 	mrs	ip, BASEPRI
   2b730:	f383 8811 	msr	BASEPRI, r3
   2b734:	f3bf 8f6f 	isb	sy

    NRFX_CRITICAL_SECTION_ENTER();
    if (p_cb->alloc_index < NRF_WDT_CHANNEL_NUMBER)
   2b738:	eb04 03c7 	add.w	r3, r4, r7, lsl #3
   2b73c:	785a      	ldrb	r2, [r3, #1]
   2b73e:	2a07      	cmp	r2, #7
   2b740:	d810      	bhi.n	2b764 <nrfx_wdt_channel_alloc+0x78>
    {
        *p_channel_id = (nrfx_wdt_channel_id)(NRF_WDT_RR0 + p_cb->alloc_index);
        p_cb->alloc_index++;
   2b742:	1c51      	adds	r1, r2, #1
   2b744:	7059      	strb	r1, [r3, #1]
}

NRF_STATIC_INLINE void nrf_wdt_reload_request_enable(NRF_WDT_Type *        p_reg,
                                                     nrf_wdt_rr_register_t rr_register)
{
    p_reg->RREN |= 0x1UL << rr_register;
   2b746:	2301      	movs	r3, #1
        nrf_wdt_reload_request_enable(p_instance->p_reg, *p_channel_id);
   2b748:	6829      	ldr	r1, [r5, #0]
   2b74a:	4093      	lsls	r3, r2
   2b74c:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
        *p_channel_id = (nrfx_wdt_channel_id)(NRF_WDT_RR0 + p_cb->alloc_index);
   2b750:	7032      	strb	r2, [r6, #0]
   2b752:	4303      	orrs	r3, r0
        result = NRFX_SUCCESS;
   2b754:	4809      	ldr	r0, [pc, #36]	; (2b77c <nrfx_wdt_channel_alloc+0x90>)
   2b756:	f8c1 3508 	str.w	r3, [r1, #1288]	; 0x508
	__asm__ volatile(
   2b75a:	f38c 8811 	msr	BASEPRI, ip
   2b75e:	f3bf 8f6f 	isb	sy
        result = NRFX_ERROR_NO_MEM;
    }
    NRFX_CRITICAL_SECTION_EXIT();
    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(result));
    return result;
}
   2b762:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        result = NRFX_ERROR_NO_MEM;
   2b764:	4806      	ldr	r0, [pc, #24]	; (2b780 <nrfx_wdt_channel_alloc+0x94>)
   2b766:	e7f8      	b.n	2b75a <nrfx_wdt_channel_alloc+0x6e>
   2b768:	0003f968 	.word	0x0003f968
   2b76c:	0003b77f 	.word	0x0003b77f
   2b770:	0003f9ce 	.word	0x0003f9ce
   2b774:	20022afc 	.word	0x20022afc
   2b778:	0003f756 	.word	0x0003f756
   2b77c:	0bad0000 	.word	0x0bad0000
   2b780:	0bad0002 	.word	0x0bad0002

0002b784 <nrfx_wdt_channel_feed>:

void nrfx_wdt_channel_feed(nrfx_wdt_t const * p_instance, nrfx_wdt_channel_id channel_id)
{
   2b784:	b538      	push	{r3, r4, r5, lr}
    NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state == NRFX_DRV_STATE_POWERED_ON);
   2b786:	4b0c      	ldr	r3, [pc, #48]	; (2b7b8 <nrfx_wdt_channel_feed+0x34>)
   2b788:	7902      	ldrb	r2, [r0, #4]
{
   2b78a:	4605      	mov	r5, r0
    NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state == NRFX_DRV_STATE_POWERED_ON);
   2b78c:	f813 3032 	ldrb.w	r3, [r3, r2, lsl #3]
{
   2b790:	460c      	mov	r4, r1
    NRFX_ASSERT(m_cb[p_instance->drv_inst_idx].state == NRFX_DRV_STATE_POWERED_ON);
   2b792:	2b02      	cmp	r3, #2
   2b794:	d009      	beq.n	2b7aa <nrfx_wdt_channel_feed+0x26>
   2b796:	4909      	ldr	r1, [pc, #36]	; (2b7bc <nrfx_wdt_channel_feed+0x38>)
   2b798:	4809      	ldr	r0, [pc, #36]	; (2b7c0 <nrfx_wdt_channel_feed+0x3c>)
   2b79a:	239b      	movs	r3, #155	; 0x9b
   2b79c:	4a09      	ldr	r2, [pc, #36]	; (2b7c4 <nrfx_wdt_channel_feed+0x40>)
   2b79e:	f007 ff13 	bl	335c8 <printk>
   2b7a2:	219b      	movs	r1, #155	; 0x9b
   2b7a4:	4807      	ldr	r0, [pc, #28]	; (2b7c4 <nrfx_wdt_channel_feed+0x40>)
   2b7a6:	f008 fa10 	bl	33bca <assert_post_action>
    nrf_wdt_reload_request_set(p_instance->p_reg, channel_id);
   2b7aa:	682b      	ldr	r3, [r5, #0]
}

NRF_STATIC_INLINE void nrf_wdt_reload_request_set(NRF_WDT_Type *        p_reg,
                                                  nrf_wdt_rr_register_t rr_register)
{
    p_reg->RR[rr_register] = NRF_WDT_RR_VALUE;
   2b7ac:	4a06      	ldr	r2, [pc, #24]	; (2b7c8 <nrfx_wdt_channel_feed+0x44>)
   2b7ae:	f504 74c0 	add.w	r4, r4, #384	; 0x180
   2b7b2:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
}
   2b7b6:	bd38      	pop	{r3, r4, r5, pc}
   2b7b8:	20022afc 	.word	0x20022afc
   2b7bc:	0003f975 	.word	0x0003f975
   2b7c0:	0003b77f 	.word	0x0003b77f
   2b7c4:	0003f9ce 	.word	0x0003f9ce
   2b7c8:	6e524635 	.word	0x6e524635

0002b7cc <nrfx_wdt_0_irq_handler>:

#if NRFX_CHECK(NRFX_WDT0_ENABLED) && !NRFX_CHECK(NRFX_WDT_CONFIG_NO_IRQ)
void nrfx_wdt_0_irq_handler(void)
{
   2b7cc:	b510      	push	{r4, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
   2b7ce:	4c04      	ldr	r4, [pc, #16]	; (2b7e0 <nrfx_wdt_0_irq_handler+0x14>)
   2b7d0:	6823      	ldr	r3, [r4, #0]
    if (nrf_wdt_event_check(NRF_WDT0, NRF_WDT_EVENT_TIMEOUT))
   2b7d2:	b123      	cbz	r3, 2b7de <nrfx_wdt_0_irq_handler+0x12>
    {
        m_cb[NRFX_WDT0_INST_IDX].wdt_event_handler();
   2b7d4:	4b03      	ldr	r3, [pc, #12]	; (2b7e4 <nrfx_wdt_0_irq_handler+0x18>)
   2b7d6:	685b      	ldr	r3, [r3, #4]
   2b7d8:	4798      	blx	r3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   2b7da:	2300      	movs	r3, #0
   2b7dc:	6023      	str	r3, [r4, #0]
        nrf_wdt_event_clear(NRF_WDT0, NRF_WDT_EVENT_TIMEOUT);
    }
}
   2b7de:	bd10      	pop	{r4, pc}
   2b7e0:	40018100 	.word	0x40018100
   2b7e4:	20022afc 	.word	0x20022afc

0002b7e8 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(s32_t level)
{
   2b7e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if (dev) {
				/* Initialization failed. Clear the API struct
				 * so that device_get_binding() will not succeed
				 * for it.
				 */
				dev->driver_api = NULL;
   2b7ea:	2700      	movs	r7, #0
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2b7ec:	4b08      	ldr	r3, [pc, #32]	; (2b810 <z_sys_init_run_level+0x28>)
   2b7ee:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
   2b7f2:	3001      	adds	r0, #1
   2b7f4:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
   2b7f8:	42a6      	cmp	r6, r4
   2b7fa:	d800      	bhi.n	2b7fe <z_sys_init_run_level+0x16>
			}
		}
	}
}
   2b7fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		retval = entry->init(dev);
   2b7fe:	e9d4 3500 	ldrd	r3, r5, [r4]
   2b802:	4628      	mov	r0, r5
   2b804:	4798      	blx	r3
		if (retval != 0) {
   2b806:	b108      	cbz	r0, 2b80c <z_sys_init_run_level+0x24>
			if (dev) {
   2b808:	b105      	cbz	r5, 2b80c <z_sys_init_run_level+0x24>
				dev->driver_api = NULL;
   2b80a:	60af      	str	r7, [r5, #8]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
   2b80c:	3408      	adds	r4, #8
   2b80e:	e7f3      	b.n	2b7f8 <z_sys_init_run_level+0x10>
   2b810:	0003ac20 	.word	0x0003ac20

0002b814 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
   2b814:	4b0f      	ldr	r3, [pc, #60]	; (2b854 <z_impl_device_get_binding+0x40>)
{
   2b816:	b570      	push	{r4, r5, r6, lr}
   2b818:	4605      	mov	r5, r0
   2b81a:	461e      	mov	r6, r3
	for (dev = __device_start; dev != __device_end; dev++) {
   2b81c:	4c0e      	ldr	r4, [pc, #56]	; (2b858 <z_impl_device_get_binding+0x44>)
   2b81e:	429c      	cmp	r4, r3
   2b820:	d104      	bne.n	2b82c <z_impl_device_get_binding+0x18>
		    (dev->name == name)) {
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
   2b822:	4c0d      	ldr	r4, [pc, #52]	; (2b858 <z_impl_device_get_binding+0x44>)
   2b824:	42b4      	cmp	r4, r6
   2b826:	d108      	bne.n	2b83a <z_impl_device_get_binding+0x26>
		    (strcmp(name, dev->name) == 0)) {
			return dev;
		}
	}

	return NULL;
   2b828:	2400      	movs	r4, #0
   2b82a:	e010      	b.n	2b84e <z_impl_device_get_binding+0x3a>
		if ((dev->driver_api != NULL) &&
   2b82c:	68a2      	ldr	r2, [r4, #8]
   2b82e:	b112      	cbz	r2, 2b836 <z_impl_device_get_binding+0x22>
   2b830:	6822      	ldr	r2, [r4, #0]
   2b832:	42aa      	cmp	r2, r5
   2b834:	d00b      	beq.n	2b84e <z_impl_device_get_binding+0x3a>
	for (dev = __device_start; dev != __device_end; dev++) {
   2b836:	3410      	adds	r4, #16
   2b838:	e7f1      	b.n	2b81e <z_impl_device_get_binding+0xa>
		if ((dev->driver_api != NULL) &&
   2b83a:	68a3      	ldr	r3, [r4, #8]
   2b83c:	b90b      	cbnz	r3, 2b842 <z_impl_device_get_binding+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
   2b83e:	3410      	adds	r4, #16
   2b840:	e7f0      	b.n	2b824 <z_impl_device_get_binding+0x10>
		    (strcmp(name, dev->name) == 0)) {
   2b842:	6821      	ldr	r1, [r4, #0]
   2b844:	4628      	mov	r0, r5
   2b846:	f7e6 fc11 	bl	1206c <strcmp>
		if ((dev->driver_api != NULL) &&
   2b84a:	2800      	cmp	r0, #0
   2b84c:	d1f7      	bne.n	2b83e <z_impl_device_get_binding+0x2a>
}
   2b84e:	4620      	mov	r0, r4
   2b850:	bd70      	pop	{r4, r5, r6, pc}
   2b852:	bf00      	nop
   2b854:	200205b4 	.word	0x200205b4
   2b858:	20020504 	.word	0x20020504

0002b85c <z_impl_z_errno>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   2b85c:	4b01      	ldr	r3, [pc, #4]	; (2b864 <z_impl_z_errno+0x8>)
   2b85e:	6898      	ldr	r0, [r3, #8]
}
   2b860:	305c      	adds	r0, #92	; 0x5c
   2b862:	4770      	bx	lr
   2b864:	200274dc 	.word	0x200274dc

0002b868 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   2b868:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   2b86c:	4605      	mov	r5, r0
   2b86e:	460f      	mov	r7, r1
	__asm__ volatile(
   2b870:	f04f 0320 	mov.w	r3, #32
   2b874:	f3ef 8911 	mrs	r9, BASEPRI
   2b878:	f383 8811 	msr	BASEPRI, r3
   2b87c:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   2b880:	f002 fbae 	bl	2dfe0 <z_impl_k_current_get>
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
   2b884:	2301      	movs	r3, #1
   2b886:	4606      	mov	r6, r0
   2b888:	f04f 0000 	mov.w	r0, #0
   2b88c:	2200      	movs	r2, #0
   2b88e:	f363 0007 	bfi	r0, r3, #0, #8
   2b892:	4c2d      	ldr	r4, [pc, #180]	; (2b948 <z_fatal_error+0xe0>)
   2b894:	4b2d      	ldr	r3, [pc, #180]	; (2b94c <z_fatal_error+0xe4>)
   2b896:	2d04      	cmp	r5, #4
   2b898:	eba4 0403 	sub.w	r4, r4, r3
   2b89c:	bf98      	it	ls
   2b89e:	4b2c      	ldrls	r3, [pc, #176]	; (2b950 <z_fatal_error+0xe8>)
   2b8a0:	f3c4 04c9 	ubfx	r4, r4, #3, #10
   2b8a4:	bf94      	ite	ls
   2b8a6:	f853 3025 	ldrls.w	r3, [r3, r5, lsl #2]
   2b8aa:	4b2a      	ldrhi	r3, [pc, #168]	; (2b954 <z_fatal_error+0xec>)
   2b8ac:	9200      	str	r2, [sp, #0]
   2b8ae:	f364 108f 	bfi	r0, r4, #6, #10
   2b8b2:	462a      	mov	r2, r5
   2b8b4:	4928      	ldr	r1, [pc, #160]	; (2b958 <z_fatal_error+0xf0>)
   2b8b6:	f008 f99f 	bl	33bf8 <log_string_sync>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
   2b8ba:	b16f      	cbz	r7, 2b8d8 <z_fatal_error+0x70>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
   2b8bc:	69fb      	ldr	r3, [r7, #28]
   2b8be:	f3c3 0308 	ubfx	r3, r3, #0, #9
   2b8c2:	b14b      	cbz	r3, 2b8d8 <z_fatal_error+0x70>
		LOG_ERR("Fault during interrupt handling\n");
   2b8c4:	f04f 0000 	mov.w	r0, #0
   2b8c8:	2301      	movs	r3, #1
   2b8ca:	f363 0007 	bfi	r0, r3, #0, #8
   2b8ce:	f364 108f 	bfi	r0, r4, #6, #10
   2b8d2:	4922      	ldr	r1, [pc, #136]	; (2b95c <z_fatal_error+0xf4>)
   2b8d4:	f008 f990 	bl	33bf8 <log_string_sync>
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
   2b8d8:	f04f 0800 	mov.w	r8, #0
   2b8dc:	2301      	movs	r3, #1
	const char *thread_name = k_thread_name_get(thread);
   2b8de:	4630      	mov	r0, r6
	LOG_ERR("Current thread: %p (%s)", thread,
   2b8e0:	f363 0807 	bfi	r8, r3, #0, #8
   2b8e4:	f364 188f 	bfi	r8, r4, #6, #10
	const char *thread_name = k_thread_name_get(thread);
   2b8e8:	f00d fa36 	bl	38d58 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
   2b8ec:	b348      	cbz	r0, 2b942 <z_fatal_error+0xda>
   2b8ee:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
   2b8f0:	4b1b      	ldr	r3, [pc, #108]	; (2b960 <z_fatal_error+0xf8>)
   2b8f2:	2a00      	cmp	r2, #0
   2b8f4:	bf08      	it	eq
   2b8f6:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
   2b8f8:	f008 f990 	bl	33c1c <log_strdup>
   2b8fc:	4632      	mov	r2, r6
   2b8fe:	4603      	mov	r3, r0
   2b900:	4918      	ldr	r1, [pc, #96]	; (2b964 <z_fatal_error+0xfc>)
   2b902:	4640      	mov	r0, r8
   2b904:	f008 f978 	bl	33bf8 <log_string_sync>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
   2b908:	4639      	mov	r1, r7
   2b90a:	4628      	mov	r0, r5
   2b90c:	f7f6 f982 	bl	21c14 <k_sys_fatal_error_handler>
	 *
	 * Note that k_thread_abort() returns on some architectures but
	 * not others; e.g. on ARC, x86_64, Xtensa with ASM2, ARM
	 */
	if (!IS_ENABLED(CONFIG_TEST)) {
		__ASSERT(reason != K_ERR_KERNEL_PANIC,
   2b910:	2d04      	cmp	r5, #4
   2b912:	d10c      	bne.n	2b92e <z_fatal_error+0xc6>
   2b914:	4914      	ldr	r1, [pc, #80]	; (2b968 <z_fatal_error+0x100>)
   2b916:	238c      	movs	r3, #140	; 0x8c
   2b918:	4a14      	ldr	r2, [pc, #80]	; (2b96c <z_fatal_error+0x104>)
   2b91a:	4815      	ldr	r0, [pc, #84]	; (2b970 <z_fatal_error+0x108>)
   2b91c:	f007 fe54 	bl	335c8 <printk>
   2b920:	4814      	ldr	r0, [pc, #80]	; (2b974 <z_fatal_error+0x10c>)
   2b922:	f007 fe51 	bl	335c8 <printk>
   2b926:	218c      	movs	r1, #140	; 0x8c
   2b928:	4810      	ldr	r0, [pc, #64]	; (2b96c <z_fatal_error+0x104>)
   2b92a:	f008 f94e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2b92e:	f389 8811 	msr	BASEPRI, r9
   2b932:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   2b936:	4630      	mov	r0, r6
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   2b938:	b003      	add	sp, #12
   2b93a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   2b93e:	f7ef be13 	b.w	1b568 <z_impl_k_thread_abort>
		thread_name = "unknown";
   2b942:	4807      	ldr	r0, [pc, #28]	; (2b960 <z_fatal_error+0xf8>)
   2b944:	e7d8      	b.n	2b8f8 <z_fatal_error+0x90>
   2b946:	bf00      	nop
   2b948:	00039ff0 	.word	0x00039ff0
   2b94c:	00039f60 	.word	0x00039f60
   2b950:	0003ac38 	.word	0x0003ac38
   2b954:	0003fa69 	.word	0x0003fa69
   2b958:	0003fa7f 	.word	0x0003fa7f
   2b95c:	0003faa7 	.word	0x0003faa7
   2b960:	0003fa77 	.word	0x0003fa77
   2b964:	0003fac8 	.word	0x0003fac8
   2b968:	0003fb02 	.word	0x0003fb02
   2b96c:	0003fae0 	.word	0x0003fae0
   2b970:	0003b77f 	.word	0x0003b77f
   2b974:	0003fb1f 	.word	0x0003fb1f

0002b978 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
   2b978:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
   2b97a:	4d0b      	ldr	r5, [pc, #44]	; (2b9a8 <idle+0x30>)
	__asm__ volatile(
   2b97c:	f04f 0220 	mov.w	r2, #32
   2b980:	f3ef 8311 	mrs	r3, BASEPRI
   2b984:	f382 8811 	msr	BASEPRI, r2
   2b988:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
   2b98c:	f003 f86c 	bl	2ea68 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   2b990:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
   2b992:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
   2b994:	2802      	cmp	r0, #2
   2b996:	bfd8      	it	le
   2b998:	4608      	movle	r0, r1
   2b99a:	f003 f8ad 	bl	2eaf8 <z_set_timeout_expiry>
	_kernel.idle = ticks;
   2b99e:	622c      	str	r4, [r5, #32]
	arch_cpu_idle();
   2b9a0:	f7ef f9c0 	bl	1ad24 <arch_cpu_idle>
   2b9a4:	e7ea      	b.n	2b97c <idle+0x4>
   2b9a6:	bf00      	nop
   2b9a8:	200274dc 	.word	0x200274dc

0002b9ac <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
   2b9ac:	4802      	ldr	r0, [pc, #8]	; (2b9b8 <z_bss_zero+0xc>)
__ssp_bos_icheck3(memset, void *, int)
   2b9ae:	4a03      	ldr	r2, [pc, #12]	; (2b9bc <z_bss_zero+0x10>)
   2b9b0:	2100      	movs	r1, #0
   2b9b2:	1a12      	subs	r2, r2, r0
   2b9b4:	f00d bb4a 	b.w	3904c <memset>
   2b9b8:	20020900 	.word	0x20020900
   2b9bc:	20029208 	.word	0x20029208

0002b9c0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
   2b9c0:	b508      	push	{r3, lr}
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   2b9c2:	4806      	ldr	r0, [pc, #24]	; (2b9dc <z_data_copy+0x1c>)
   2b9c4:	4a06      	ldr	r2, [pc, #24]	; (2b9e0 <z_data_copy+0x20>)
   2b9c6:	4907      	ldr	r1, [pc, #28]	; (2b9e4 <z_data_copy+0x24>)
   2b9c8:	1a12      	subs	r2, r2, r0
   2b9ca:	f00d fb05 	bl	38fd8 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
   2b9ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2b9d2:	4a05      	ldr	r2, [pc, #20]	; (2b9e8 <z_data_copy+0x28>)
   2b9d4:	4905      	ldr	r1, [pc, #20]	; (2b9ec <z_data_copy+0x2c>)
   2b9d6:	4806      	ldr	r0, [pc, #24]	; (2b9f0 <z_data_copy+0x30>)
   2b9d8:	f00d bafe 	b.w	38fd8 <memcpy>
   2b9dc:	20020000 	.word	0x20020000
   2b9e0:	200208fc 	.word	0x200208fc
   2b9e4:	000409a4 	.word	0x000409a4
   2b9e8:	00000000 	.word	0x00000000
   2b9ec:	000409a4 	.word	0x000409a4
   2b9f0:	20020000 	.word	0x20020000

0002b9f4 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
   2b9f4:	2201      	movs	r2, #1
{
   2b9f6:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
   2b9f8:	4b0b      	ldr	r3, [pc, #44]	; (2ba28 <bg_thread_main+0x34>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2b9fa:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
   2b9fc:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
   2b9fe:	f7ff fef3 	bl	2b7e8 <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
   2ba02:	4a0a      	ldr	r2, [pc, #40]	; (2ba2c <bg_thread_main+0x38>)
   2ba04:	490a      	ldr	r1, [pc, #40]	; (2ba30 <bg_thread_main+0x3c>)
   2ba06:	480b      	ldr	r0, [pc, #44]	; (2ba34 <bg_thread_main+0x40>)
   2ba08:	f007 fdde 	bl	335c8 <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
   2ba0c:	2003      	movs	r0, #3
   2ba0e:	f7ff feeb 	bl	2b7e8 <z_sys_init_run_level>

	z_init_static_threads();
   2ba12:	f002 fcdb 	bl	2e3cc <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
   2ba16:	f7e9 fc0d 	bl	15234 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
   2ba1a:	4a07      	ldr	r2, [pc, #28]	; (2ba38 <bg_thread_main+0x44>)
   2ba1c:	7b13      	ldrb	r3, [r2, #12]
   2ba1e:	f023 0301 	bic.w	r3, r3, #1
   2ba22:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
   2ba24:	bd08      	pop	{r3, pc}
   2ba26:	bf00      	nop
   2ba28:	2002908d 	.word	0x2002908d
   2ba2c:	0003c520 	.word	0x0003c520
   2ba30:	0003fb54 	.word	0x0003fb54
   2ba34:	0003fb74 	.word	0x0003fb74
   2ba38:	20022bbc 	.word	0x20022bbc

0002ba3c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
   2ba3c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
   2ba40:	b0b5      	sub	sp, #212	; 0xd4
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
   2ba42:	f7ed f9bd 	bl	18dc0 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
   2ba46:	4b36      	ldr	r3, [pc, #216]	; (2bb20 <z_cstart+0xe4>)
   2ba48:	f503 6900 	add.w	r9, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
   2ba4c:	f389 8808 	msr	MSP, r9
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
   2ba50:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2ba54:	2400      	movs	r4, #0
   2ba56:	23e0      	movs	r3, #224	; 0xe0
   2ba58:	4d32      	ldr	r5, [pc, #200]	; (2bb24 <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
   2ba5a:	4e33      	ldr	r6, [pc, #204]	; (2bb28 <z_cstart+0xec>)
   2ba5c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
   2ba60:	77ec      	strb	r4, [r5, #31]
   2ba62:	762c      	strb	r4, [r5, #24]
   2ba64:	766c      	strb	r4, [r5, #25]
   2ba66:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
   2ba68:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2ba6a:	f04f 0b01 	mov.w	fp, #1
   2ba6e:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
   2ba72:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
   2ba74:	f7ef fd40 	bl	1b4f8 <z_arm_fault_init>
	z_arm_cpu_idle_init();
   2ba78:	f7ef f94e 	bl	1ad18 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
   2ba7c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2ba80:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
   2ba82:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
   2ba84:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif

	_current_cpu->current = dummy_thread;
   2ba88:	4d28      	ldr	r5, [pc, #160]	; (2bb2c <z_cstart+0xf0>)
	dummy_thread->base.user_options = K_ESSENTIAL;
   2ba8a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
   2ba8e:	ab06      	add	r3, sp, #24
   2ba90:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
   2ba92:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
   2ba94:	e9cd 441e 	strd	r4, r4, [sp, #120]	; 0x78
   2ba98:	f7ff fea6 	bl	2b7e8 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
   2ba9c:	2001      	movs	r0, #1
   2ba9e:	f7ff fea3 	bl	2b7e8 <z_sys_init_run_level>
	z_sched_init();
   2baa2:	f002 f913 	bl	2dccc <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2baa6:	4b22      	ldr	r3, [pc, #136]	; (2bb30 <z_cstart+0xf4>)
	_kernel.ready_q.cache = &z_main_thread;
   2baa8:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
   2baaa:	9305      	str	r3, [sp, #20]
   2baac:	2307      	movs	r3, #7
   2baae:	f8df a090 	ldr.w	sl, [pc, #144]	; 2bb40 <z_cstart+0x104>
   2bab2:	f8df 8090 	ldr.w	r8, [pc, #144]	; 2bb44 <z_cstart+0x108>
   2bab6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   2baba:	4641      	mov	r1, r8
   2babc:	e9cd 3b03 	strd	r3, fp, [sp, #12]
   2bac0:	4630      	mov	r0, r6
   2bac2:	4653      	mov	r3, sl
   2bac4:	e9cd 4401 	strd	r4, r4, [sp, #4]
   2bac8:	9400      	str	r4, [sp, #0]
   2baca:	f002 fbd3 	bl	2e274 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2bace:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
   2bad0:	4630      	mov	r0, r6
   2bad2:	f023 0304 	bic.w	r3, r3, #4
   2bad6:	7373      	strb	r3, [r6, #13]
   2bad8:	f001 fbb8 	bl	2d24c <z_ready_thread>
	z_setup_new_thread(thread, stack,
   2badc:	230f      	movs	r3, #15
   2bade:	4f15      	ldr	r7, [pc, #84]	; (2bb34 <z_cstart+0xf8>)
   2bae0:	e9cd 4302 	strd	r4, r3, [sp, #8]
   2bae4:	f44f 72a0 	mov.w	r2, #320	; 0x140
   2bae8:	4b13      	ldr	r3, [pc, #76]	; (2bb38 <z_cstart+0xfc>)
   2baea:	4914      	ldr	r1, [pc, #80]	; (2bb3c <z_cstart+0x100>)
   2baec:	4638      	mov	r0, r7
   2baee:	e9cd b404 	strd	fp, r4, [sp, #16]
   2baf2:	e9cd 4400 	strd	r4, r4, [sp]
   2baf6:	f002 fbbd 	bl	2e274 <z_setup_new_thread>
   2bafa:	7b7b      	ldrb	r3, [r7, #13]
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
   2bafc:	60ef      	str	r7, [r5, #12]
   2bafe:	f023 0304 	bic.w	r3, r3, #4
   2bb02:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
   2bb04:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
   2bb08:	e9c5 3306 	strd	r3, r3, [r5, #24]
		_kernel.cpus[i].id = i;
   2bb0c:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
   2bb0e:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
   2bb12:	4653      	mov	r3, sl
   2bb14:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   2bb18:	4641      	mov	r1, r8
   2bb1a:	4630      	mov	r0, r6
   2bb1c:	f7ef f8d4 	bl	1acc8 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
   2bb20:	200349d8 	.word	0x200349d8
   2bb24:	e000ed00 	.word	0xe000ed00
   2bb28:	20022bbc 	.word	0x20022bbc
   2bb2c:	200274dc 	.word	0x200274dc
   2bb30:	0003fb9e 	.word	0x0003fb9e
   2bb34:	20022b04 	.word	0x20022b04
   2bb38:	0002b979 	.word	0x0002b979
   2bb3c:	20034898 	.word	0x20034898
   2bb40:	0002b9f5 	.word	0x0002b9f5
   2bb44:	20032898 	.word	0x20032898

0002bb48 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
   2bb48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   2bb4a:	4d0f      	ldr	r5, [pc, #60]	; (2bb88 <statics_init+0x40>)
   2bb4c:	4c0f      	ldr	r4, [pc, #60]	; (2bb8c <statics_init+0x44>)
   2bb4e:	462f      	mov	r7, r5
   2bb50:	4e0f      	ldr	r6, [pc, #60]	; (2bb90 <statics_init+0x48>)
   2bb52:	42ac      	cmp	r4, r5
   2bb54:	d90c      	bls.n	2bb70 <statics_init+0x28>
   2bb56:	490f      	ldr	r1, [pc, #60]	; (2bb94 <statics_init+0x4c>)
   2bb58:	2315      	movs	r3, #21
   2bb5a:	4632      	mov	r2, r6
   2bb5c:	480e      	ldr	r0, [pc, #56]	; (2bb98 <statics_init+0x50>)
   2bb5e:	f007 fd33 	bl	335c8 <printk>
   2bb62:	480e      	ldr	r0, [pc, #56]	; (2bb9c <statics_init+0x54>)
   2bb64:	f007 fd30 	bl	335c8 <printk>
   2bb68:	2115      	movs	r1, #21
   2bb6a:	4630      	mov	r0, r6
   2bb6c:	f008 f82d 	bl	33bca <assert_post_action>
   2bb70:	42bc      	cmp	r4, r7
   2bb72:	d301      	bcc.n	2bb78 <statics_init+0x30>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
   2bb74:	2000      	movs	r0, #0
   2bb76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
   2bb78:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
   2bb7c:	4620      	mov	r0, r4
   2bb7e:	f00c ffc1 	bl	38b04 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
   2bb82:	3418      	adds	r4, #24
   2bb84:	e7e5      	b.n	2bb52 <statics_init+0xa>
   2bb86:	bf00      	nop
   2bb88:	200206d4 	.word	0x200206d4
   2bb8c:	200206bc 	.word	0x200206bc
   2bb90:	0003fbcb 	.word	0x0003fbcb
   2bb94:	0003fbed 	.word	0x0003fbed
   2bb98:	0003b77f 	.word	0x0003b77f
   2bb9c:	0003cc09 	.word	0x0003cc09

0002bba0 <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
   2bba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2bba4:	4606      	mov	r6, r0
   2bba6:	b085      	sub	sp, #20
	s64_t now, end = z_timeout_end_calc(timeout);
   2bba8:	4610      	mov	r0, r2
{
   2bbaa:	468b      	mov	fp, r1
   2bbac:	4617      	mov	r7, r2
	s64_t now, end = z_timeout_end_calc(timeout);
   2bbae:	f00d f947 	bl	38e40 <z_timeout_end_calc>
   2bbb2:	4680      	mov	r8, r0
   2bbb4:	9003      	str	r0, [sp, #12]
   2bbb6:	468a      	mov	sl, r1
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   2bbb8:	f106 0414 	add.w	r4, r6, #20
   2bbbc:	f04f 0320 	mov.w	r3, #32
   2bbc0:	f3ef 8511 	mrs	r5, BASEPRI
   2bbc4:	f383 8811 	msr	BASEPRI, r3
   2bbc8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bbcc:	4620      	mov	r0, r4
   2bbce:	f002 fc87 	bl	2e4e0 <z_spin_lock_valid>
   2bbd2:	b968      	cbnz	r0, 2bbf0 <k_heap_alloc+0x50>
   2bbd4:	235c      	movs	r3, #92	; 0x5c
   2bbd6:	4a41      	ldr	r2, [pc, #260]	; (2bcdc <k_heap_alloc+0x13c>)
   2bbd8:	4941      	ldr	r1, [pc, #260]	; (2bce0 <k_heap_alloc+0x140>)
   2bbda:	4842      	ldr	r0, [pc, #264]	; (2bce4 <k_heap_alloc+0x144>)
   2bbdc:	f007 fcf4 	bl	335c8 <printk>
   2bbe0:	4621      	mov	r1, r4
   2bbe2:	4841      	ldr	r0, [pc, #260]	; (2bce8 <k_heap_alloc+0x148>)
   2bbe4:	f007 fcf0 	bl	335c8 <printk>
   2bbe8:	215c      	movs	r1, #92	; 0x5c
   2bbea:	483c      	ldr	r0, [pc, #240]	; (2bcdc <k_heap_alloc+0x13c>)
   2bbec:	f007 ffed 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2bbf0:	4620      	mov	r0, r4
   2bbf2:	f002 fc93 	bl	2e51c <z_spin_lock_set_owner>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   2bbf6:	f3ef 8305 	mrs	r3, IPSR

	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2bbfa:	b16b      	cbz	r3, 2bc18 <k_heap_alloc+0x78>
   2bbfc:	b167      	cbz	r7, 2bc18 <k_heap_alloc+0x78>
   2bbfe:	493b      	ldr	r1, [pc, #236]	; (2bcec <k_heap_alloc+0x14c>)
   2bc00:	2323      	movs	r3, #35	; 0x23
   2bc02:	4a3b      	ldr	r2, [pc, #236]	; (2bcf0 <k_heap_alloc+0x150>)
   2bc04:	4837      	ldr	r0, [pc, #220]	; (2bce4 <k_heap_alloc+0x144>)
   2bc06:	f007 fcdf 	bl	335c8 <printk>
   2bc0a:	483a      	ldr	r0, [pc, #232]	; (2bcf4 <k_heap_alloc+0x154>)
   2bc0c:	f007 fcdc 	bl	335c8 <printk>
   2bc10:	2123      	movs	r1, #35	; 0x23
   2bc12:	4837      	ldr	r0, [pc, #220]	; (2bcf0 <k_heap_alloc+0x150>)
   2bc14:	f007 ffd9 	bl	33bca <assert_post_action>
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bc18:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 2bcdc <k_heap_alloc+0x13c>

	while (ret == NULL) {
		ret = sys_heap_alloc(&h->heap, bytes);
   2bc1c:	4659      	mov	r1, fp
   2bc1e:	4630      	mov	r0, r6
   2bc20:	f007 fedd 	bl	339de <sys_heap_alloc>
   2bc24:	4607      	mov	r7, r0

		now = z_tick_get();
   2bc26:	f003 f869 	bl	2ecfc <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
   2bc2a:	b1cf      	cbz	r7, 2bc60 <k_heap_alloc+0xc0>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2bc2c:	4620      	mov	r0, r4
   2bc2e:	f002 fc65 	bl	2e4fc <z_spin_unlock_valid>
   2bc32:	b968      	cbnz	r0, 2bc50 <k_heap_alloc+0xb0>
   2bc34:	2384      	movs	r3, #132	; 0x84
   2bc36:	4a29      	ldr	r2, [pc, #164]	; (2bcdc <k_heap_alloc+0x13c>)
   2bc38:	492f      	ldr	r1, [pc, #188]	; (2bcf8 <k_heap_alloc+0x158>)
   2bc3a:	482a      	ldr	r0, [pc, #168]	; (2bce4 <k_heap_alloc+0x144>)
   2bc3c:	f007 fcc4 	bl	335c8 <printk>
   2bc40:	4621      	mov	r1, r4
   2bc42:	482e      	ldr	r0, [pc, #184]	; (2bcfc <k_heap_alloc+0x15c>)
   2bc44:	f007 fcc0 	bl	335c8 <printk>
   2bc48:	2184      	movs	r1, #132	; 0x84
   2bc4a:	4824      	ldr	r0, [pc, #144]	; (2bcdc <k_heap_alloc+0x13c>)
   2bc4c:	f007 ffbd 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2bc50:	f385 8811 	msr	BASEPRI, r5
   2bc54:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
   2bc58:	4638      	mov	r0, r7
   2bc5a:	b005      	add	sp, #20
   2bc5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
   2bc60:	9b03      	ldr	r3, [sp, #12]
   2bc62:	1a1b      	subs	r3, r3, r0
   2bc64:	9300      	str	r3, [sp, #0]
   2bc66:	eb6a 0301 	sbc.w	r3, sl, r1
   2bc6a:	9301      	str	r3, [sp, #4]
   2bc6c:	e9dd 2300 	ldrd	r2, r3, [sp]
   2bc70:	2a01      	cmp	r2, #1
   2bc72:	f173 0300 	sbcs.w	r3, r3, #0
   2bc76:	dbd9      	blt.n	2bc2c <k_heap_alloc+0x8c>
			return (u32_t)((t * to_hz + off) / from_hz);
   2bc78:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   2bc7c:	f647 71ff 	movw	r1, #32767	; 0x7fff
   2bc80:	2200      	movs	r2, #0
				   K_TICKS(end - now));
   2bc82:	eba8 0000 	sub.w	r0, r8, r0
   2bc86:	fbe3 1200 	umlal	r1, r2, r3, r0
   2bc8a:	4608      	mov	r0, r1
   2bc8c:	4611      	mov	r1, r2
   2bc8e:	0bc2      	lsrs	r2, r0, #15
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
   2bc90:	ea42 4341 	orr.w	r3, r2, r1, lsl #17
   2bc94:	4620      	mov	r0, r4
   2bc96:	f106 020c 	add.w	r2, r6, #12
   2bc9a:	4629      	mov	r1, r5
   2bc9c:	f001 fec8 	bl	2da30 <z_pend_curr>
	__asm__ volatile(
   2bca0:	f04f 0320 	mov.w	r3, #32
   2bca4:	f3ef 8511 	mrs	r5, BASEPRI
   2bca8:	f383 8811 	msr	BASEPRI, r3
   2bcac:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bcb0:	4620      	mov	r0, r4
   2bcb2:	f002 fc15 	bl	2e4e0 <z_spin_lock_valid>
   2bcb6:	b968      	cbnz	r0, 2bcd4 <k_heap_alloc+0x134>
   2bcb8:	235c      	movs	r3, #92	; 0x5c
   2bcba:	464a      	mov	r2, r9
   2bcbc:	4908      	ldr	r1, [pc, #32]	; (2bce0 <k_heap_alloc+0x140>)
   2bcbe:	4809      	ldr	r0, [pc, #36]	; (2bce4 <k_heap_alloc+0x144>)
   2bcc0:	f007 fc82 	bl	335c8 <printk>
   2bcc4:	4621      	mov	r1, r4
   2bcc6:	4808      	ldr	r0, [pc, #32]	; (2bce8 <k_heap_alloc+0x148>)
   2bcc8:	f007 fc7e 	bl	335c8 <printk>
   2bccc:	215c      	movs	r1, #92	; 0x5c
   2bcce:	4648      	mov	r0, r9
   2bcd0:	f007 ff7b 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2bcd4:	4620      	mov	r0, r4
   2bcd6:	f002 fc21 	bl	2e51c <z_spin_lock_set_owner>
	return k;
   2bcda:	e79f      	b.n	2bc1c <k_heap_alloc+0x7c>
   2bcdc:	0003c751 	.word	0x0003c751
   2bce0:	0003c777 	.word	0x0003c777
   2bce4:	0003b77f 	.word	0x0003b77f
   2bce8:	0003c78c 	.word	0x0003c78c
   2bcec:	0003fba3 	.word	0x0003fba3
   2bcf0:	0003fbcb 	.word	0x0003fbcb
   2bcf4:	0003cb8b 	.word	0x0003cb8b
   2bcf8:	0003c7a4 	.word	0x0003c7a4
   2bcfc:	0003c7bb 	.word	0x0003c7bb

0002bd00 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
   2bd00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2bd02:	4605      	mov	r5, r0
   2bd04:	460f      	mov	r7, r1
	k_spinlock_key_t key = k_spin_lock(&h->lock);
   2bd06:	f100 0414 	add.w	r4, r0, #20
   2bd0a:	f04f 0320 	mov.w	r3, #32
   2bd0e:	f3ef 8611 	mrs	r6, BASEPRI
   2bd12:	f383 8811 	msr	BASEPRI, r3
   2bd16:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bd1a:	4620      	mov	r0, r4
   2bd1c:	f002 fbe0 	bl	2e4e0 <z_spin_lock_valid>
   2bd20:	b968      	cbnz	r0, 2bd3e <k_heap_free+0x3e>
   2bd22:	235c      	movs	r3, #92	; 0x5c
   2bd24:	4a1a      	ldr	r2, [pc, #104]	; (2bd90 <k_heap_free+0x90>)
   2bd26:	491b      	ldr	r1, [pc, #108]	; (2bd94 <k_heap_free+0x94>)
   2bd28:	481b      	ldr	r0, [pc, #108]	; (2bd98 <k_heap_free+0x98>)
   2bd2a:	f007 fc4d 	bl	335c8 <printk>
   2bd2e:	4621      	mov	r1, r4
   2bd30:	481a      	ldr	r0, [pc, #104]	; (2bd9c <k_heap_free+0x9c>)
   2bd32:	f007 fc49 	bl	335c8 <printk>
   2bd36:	215c      	movs	r1, #92	; 0x5c
   2bd38:	4815      	ldr	r0, [pc, #84]	; (2bd90 <k_heap_free+0x90>)
   2bd3a:	f007 ff46 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2bd3e:	4620      	mov	r0, r4
   2bd40:	f002 fbec 	bl	2e51c <z_spin_lock_set_owner>

	sys_heap_free(&h->heap, mem);
   2bd44:	4628      	mov	r0, r5
   2bd46:	4639      	mov	r1, r7
   2bd48:	f007 fd97 	bl	3387a <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
   2bd4c:	f105 000c 	add.w	r0, r5, #12
   2bd50:	f00c ffd7 	bl	38d02 <z_unpend_all>
   2bd54:	b128      	cbz	r0, 2bd62 <k_heap_free+0x62>
		z_reschedule(&h->lock, key);
   2bd56:	4631      	mov	r1, r6
   2bd58:	4620      	mov	r0, r4
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
   2bd5a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		z_reschedule(&h->lock, key);
   2bd5e:	f001 b853 	b.w	2ce08 <z_reschedule>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2bd62:	4620      	mov	r0, r4
   2bd64:	f002 fbca 	bl	2e4fc <z_spin_unlock_valid>
   2bd68:	b968      	cbnz	r0, 2bd86 <k_heap_free+0x86>
   2bd6a:	2384      	movs	r3, #132	; 0x84
   2bd6c:	4a08      	ldr	r2, [pc, #32]	; (2bd90 <k_heap_free+0x90>)
   2bd6e:	490c      	ldr	r1, [pc, #48]	; (2bda0 <k_heap_free+0xa0>)
   2bd70:	4809      	ldr	r0, [pc, #36]	; (2bd98 <k_heap_free+0x98>)
   2bd72:	f007 fc29 	bl	335c8 <printk>
   2bd76:	4621      	mov	r1, r4
   2bd78:	480a      	ldr	r0, [pc, #40]	; (2bda4 <k_heap_free+0xa4>)
   2bd7a:	f007 fc25 	bl	335c8 <printk>
   2bd7e:	2184      	movs	r1, #132	; 0x84
   2bd80:	4803      	ldr	r0, [pc, #12]	; (2bd90 <k_heap_free+0x90>)
   2bd82:	f007 ff22 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2bd86:	f386 8811 	msr	BASEPRI, r6
   2bd8a:	f3bf 8f6f 	isb	sy
}
   2bd8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2bd90:	0003c751 	.word	0x0003c751
   2bd94:	0003c777 	.word	0x0003c777
   2bd98:	0003b77f 	.word	0x0003b77f
   2bd9c:	0003c78c 	.word	0x0003c78c
   2bda0:	0003c7a4 	.word	0x0003c7a4
   2bda4:	0003c7bb 	.word	0x0003c7bb

0002bda8 <mbox_message_put>:
	struct k_thread *receiving_thread;
	struct k_mbox_msg *rx_msg;
	k_spinlock_key_t key;

	/* save sender id so it can be used during message matching */
	tx_msg->rx_source_thread = _current;
   2bda8:	4b4d      	ldr	r3, [pc, #308]	; (2bee0 <mbox_message_put+0x138>)
{
   2bdaa:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	tx_msg->rx_source_thread = _current;
   2bdae:	689b      	ldr	r3, [r3, #8]

	/* finish readying sending thread (actual or dummy) for send */
	sending_thread = tx_msg->_syncing_thread;
   2bdb0:	f8d1 9024 	ldr.w	r9, [r1, #36]	; 0x24
	tx_msg->rx_source_thread = _current;
   2bdb4:	61cb      	str	r3, [r1, #28]
{
   2bdb6:	4680      	mov	r8, r0
   2bdb8:	468a      	mov	sl, r1
   2bdba:	4693      	mov	fp, r2
	sending_thread->base.swap_data = tx_msg;
   2bdbc:	f8c9 1014 	str.w	r1, [r9, #20]

	/* search mailbox's rx queue for a compatible receiver */
	key = k_spin_lock(&mbox->lock);
   2bdc0:	f100 0410 	add.w	r4, r0, #16
	__asm__ volatile(
   2bdc4:	f04f 0320 	mov.w	r3, #32
   2bdc8:	f3ef 8711 	mrs	r7, BASEPRI
   2bdcc:	f383 8811 	msr	BASEPRI, r3
   2bdd0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bdd4:	4620      	mov	r0, r4
   2bdd6:	f002 fb83 	bl	2e4e0 <z_spin_lock_valid>
   2bdda:	b968      	cbnz	r0, 2bdf8 <mbox_message_put+0x50>
   2bddc:	235c      	movs	r3, #92	; 0x5c
   2bdde:	4a41      	ldr	r2, [pc, #260]	; (2bee4 <mbox_message_put+0x13c>)
   2bde0:	4941      	ldr	r1, [pc, #260]	; (2bee8 <mbox_message_put+0x140>)
   2bde2:	4842      	ldr	r0, [pc, #264]	; (2beec <mbox_message_put+0x144>)
   2bde4:	f007 fbf0 	bl	335c8 <printk>
   2bde8:	4621      	mov	r1, r4
   2bdea:	4841      	ldr	r0, [pc, #260]	; (2bef0 <mbox_message_put+0x148>)
   2bdec:	f007 fbec 	bl	335c8 <printk>
   2bdf0:	215c      	movs	r1, #92	; 0x5c
   2bdf2:	483c      	ldr	r0, [pc, #240]	; (2bee4 <mbox_message_put+0x13c>)
   2bdf4:	f007 fee9 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2bdf8:	4620      	mov	r0, r4
   2bdfa:	f002 fb8f 	bl	2e51c <z_spin_lock_set_owner>
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
   2bdfe:	4643      	mov	r3, r8
   2be00:	f853 5f08 	ldr.w	r5, [r3, #8]!
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2be04:	429d      	cmp	r5, r3
   2be06:	d129      	bne.n	2be5c <mbox_message_put+0xb4>

		}
	}

	/* didn't find a matching receiver: don't wait for one */
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2be08:	f1bb 0f00 	cmp.w	fp, #0
   2be0c:	d143      	bne.n	2be96 <mbox_message_put+0xee>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2be0e:	4620      	mov	r0, r4
   2be10:	f002 fb74 	bl	2e4fc <z_spin_unlock_valid>
   2be14:	b968      	cbnz	r0, 2be32 <mbox_message_put+0x8a>
   2be16:	2384      	movs	r3, #132	; 0x84
   2be18:	4a32      	ldr	r2, [pc, #200]	; (2bee4 <mbox_message_put+0x13c>)
   2be1a:	4936      	ldr	r1, [pc, #216]	; (2bef4 <mbox_message_put+0x14c>)
   2be1c:	4833      	ldr	r0, [pc, #204]	; (2beec <mbox_message_put+0x144>)
   2be1e:	f007 fbd3 	bl	335c8 <printk>
   2be22:	4621      	mov	r1, r4
   2be24:	4834      	ldr	r0, [pc, #208]	; (2bef8 <mbox_message_put+0x150>)
   2be26:	f007 fbcf 	bl	335c8 <printk>
   2be2a:	2184      	movs	r1, #132	; 0x84
   2be2c:	482d      	ldr	r0, [pc, #180]	; (2bee4 <mbox_message_put+0x13c>)
   2be2e:	f007 fecc 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2be32:	f387 8811 	msr	BASEPRI, r7
   2be36:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&mbox->lock, key);
		return -ENOMSG;
   2be3a:	f06f 0622 	mvn.w	r6, #34	; 0x22
   2be3e:	e026      	b.n	2be8e <mbox_message_put+0xe6>
			return z_pend_curr(&mbox->lock, key, NULL, K_FOREVER);
   2be40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
		return 0;
	}
#endif

	/* synchronous send: sender waits on tx queue for receiver or timeout */
	return z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);
   2be44:	4639      	mov	r1, r7
   2be46:	4620      	mov	r0, r4
}
   2be48:	b001      	add	sp, #4
   2be4a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	return z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);
   2be4e:	f001 bdef 	b.w	2da30 <z_pend_curr>
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
   2be52:	f8d8 300c 	ldr.w	r3, [r8, #12]
   2be56:	429d      	cmp	r5, r3
   2be58:	d0d6      	beq.n	2be08 <mbox_message_put+0x60>
   2be5a:	682d      	ldr	r5, [r5, #0]
	_WAIT_Q_FOR_EACH(&mbox->rx_msg_queue, receiving_thread) {
   2be5c:	2d00      	cmp	r5, #0
   2be5e:	d0d3      	beq.n	2be08 <mbox_message_put+0x60>
		if (mbox_message_match(tx_msg, rx_msg) == 0) {
   2be60:	6969      	ldr	r1, [r5, #20]
   2be62:	4650      	mov	r0, sl
   2be64:	f00c fe71 	bl	38b4a <mbox_message_match>
   2be68:	4606      	mov	r6, r0
   2be6a:	2800      	cmp	r0, #0
   2be6c:	d1f1      	bne.n	2be52 <mbox_message_put+0xaa>
			z_unpend_thread(receiving_thread);
   2be6e:	4628      	mov	r0, r5
   2be70:	f001 f8ac 	bl	2cfcc <z_unpend_thread>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
   2be74:	672e      	str	r6, [r5, #112]	; 0x70
			z_ready_thread(receiving_thread);
   2be76:	4628      	mov	r0, r5
   2be78:	f001 f9e8 	bl	2d24c <z_ready_thread>
			if ((sending_thread->base.thread_state & _THREAD_DUMMY)
   2be7c:	f899 200d 	ldrb.w	r2, [r9, #13]
   2be80:	f012 0201 	ands.w	r2, r2, #1
   2be84:	d0dc      	beq.n	2be40 <mbox_message_put+0x98>
				z_reschedule(&mbox->lock, key);
   2be86:	4639      	mov	r1, r7
   2be88:	4620      	mov	r0, r4
   2be8a:	f000 ffbd 	bl	2ce08 <z_reschedule>
}
   2be8e:	4630      	mov	r0, r6
   2be90:	b001      	add	sp, #4
   2be92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {
   2be96:	f899 300d 	ldrb.w	r3, [r9, #13]
   2be9a:	07db      	lsls	r3, r3, #31
   2be9c:	d51d      	bpl.n	2beda <mbox_message_put+0x132>
		z_pend_thread(sending_thread, &mbox->tx_msg_queue, K_FOREVER);
   2be9e:	4648      	mov	r0, r9
   2bea0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2bea4:	4641      	mov	r1, r8
   2bea6:	f001 fd9d 	bl	2d9e4 <z_pend_thread>
   2beaa:	4620      	mov	r0, r4
   2beac:	f002 fb26 	bl	2e4fc <z_spin_unlock_valid>
   2beb0:	b968      	cbnz	r0, 2bece <mbox_message_put+0x126>
   2beb2:	2384      	movs	r3, #132	; 0x84
   2beb4:	4a0b      	ldr	r2, [pc, #44]	; (2bee4 <mbox_message_put+0x13c>)
   2beb6:	490f      	ldr	r1, [pc, #60]	; (2bef4 <mbox_message_put+0x14c>)
   2beb8:	480c      	ldr	r0, [pc, #48]	; (2beec <mbox_message_put+0x144>)
   2beba:	f007 fb85 	bl	335c8 <printk>
   2bebe:	4621      	mov	r1, r4
   2bec0:	480d      	ldr	r0, [pc, #52]	; (2bef8 <mbox_message_put+0x150>)
   2bec2:	f007 fb81 	bl	335c8 <printk>
   2bec6:	2184      	movs	r1, #132	; 0x84
   2bec8:	4806      	ldr	r0, [pc, #24]	; (2bee4 <mbox_message_put+0x13c>)
   2beca:	f007 fe7e 	bl	33bca <assert_post_action>
   2bece:	f387 8811 	msr	BASEPRI, r7
   2bed2:	f3bf 8f6f 	isb	sy
		return 0;
   2bed6:	2600      	movs	r6, #0
   2bed8:	e7d9      	b.n	2be8e <mbox_message_put+0xe6>
	return z_pend_curr(&mbox->lock, key, &mbox->tx_msg_queue, timeout);
   2beda:	465b      	mov	r3, fp
   2bedc:	4642      	mov	r2, r8
   2bede:	e7b1      	b.n	2be44 <mbox_message_put+0x9c>
   2bee0:	200274dc 	.word	0x200274dc
   2bee4:	0003c751 	.word	0x0003c751
   2bee8:	0003c777 	.word	0x0003c777
   2beec:	0003b77f 	.word	0x0003b77f
   2bef0:	0003c78c 	.word	0x0003c78c
   2bef4:	0003c7a4 	.word	0x0003c7a4
   2bef8:	0003c7bb 	.word	0x0003c7bb

0002befc <mbox_message_dispose>:
	if (rx_msg->_syncing_thread == NULL) {
   2befc:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
   2befe:	b510      	push	{r4, lr}
   2bf00:	4604      	mov	r4, r0
	if (rx_msg->_syncing_thread == NULL) {
   2bf02:	b36b      	cbz	r3, 2bf60 <mbox_message_dispose+0x64>
	if (rx_msg->tx_block.data != NULL) {
   2bf04:	6943      	ldr	r3, [r0, #20]
   2bf06:	b123      	cbz	r3, 2bf12 <mbox_message_dispose+0x16>
		k_mem_pool_free(&rx_msg->tx_block);
   2bf08:	3014      	adds	r0, #20
   2bf0a:	f00c fe6a 	bl	38be2 <k_mem_pool_free>
		rx_msg->tx_block.data = NULL;
   2bf0e:	2300      	movs	r3, #0
   2bf10:	6163      	str	r3, [r4, #20]
	rx_msg->_syncing_thread = NULL;
   2bf12:	2300      	movs	r3, #0
	sending_thread = rx_msg->_syncing_thread;
   2bf14:	6a61      	ldr	r1, [r4, #36]	; 0x24
	rx_msg->_syncing_thread = NULL;
   2bf16:	6263      	str	r3, [r4, #36]	; 0x24
	tx_msg = (struct k_mbox_msg *)sending_thread->base.swap_data;
   2bf18:	694a      	ldr	r2, [r1, #20]
	tx_msg->size = rx_msg->size;
   2bf1a:	6863      	ldr	r3, [r4, #4]
   2bf1c:	6053      	str	r3, [r2, #4]
	if ((sending_thread->base.thread_state & _THREAD_DUMMY) != 0U) {
   2bf1e:	7b4b      	ldrb	r3, [r1, #13]
   2bf20:	f013 0001 	ands.w	r0, r3, #1
   2bf24:	d009      	beq.n	2bf3a <mbox_message_dispose+0x3e>
		struct k_sem *async_sem = tx_msg->_async_sem;
   2bf26:	6a94      	ldr	r4, [r2, #40]	; 0x28
	return z_impl_k_stack_push(stack, data);
   2bf28:	480e      	ldr	r0, [pc, #56]	; (2bf64 <mbox_message_dispose+0x68>)
   2bf2a:	f002 f927 	bl	2e17c <z_impl_k_stack_push>
		if (async_sem != NULL) {
   2bf2e:	b1bc      	cbz	r4, 2bf60 <mbox_message_dispose+0x64>
	z_impl_k_sem_give(sem);
   2bf30:	4620      	mov	r0, r4
}
   2bf32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   2bf36:	f002 b859 	b.w	2dfec <z_impl_k_sem_give>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
   2bf3a:	f023 0302 	bic.w	r3, r3, #2
   2bf3e:	6708      	str	r0, [r1, #112]	; 0x70
   2bf40:	734b      	strb	r3, [r1, #13]
	z_ready_thread(sending_thread);
   2bf42:	4608      	mov	r0, r1
   2bf44:	f001 f982 	bl	2d24c <z_ready_thread>
	__asm__ volatile(
   2bf48:	f04f 0320 	mov.w	r3, #32
   2bf4c:	f3ef 8011 	mrs	r0, BASEPRI
   2bf50:	f383 8811 	msr	BASEPRI, r3
   2bf54:	f3bf 8f6f 	isb	sy
}
   2bf58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   2bf5c:	f00c beb5 	b.w	38cca <z_reschedule_irqlock>
   2bf60:	bd10      	pop	{r4, pc}
   2bf62:	bf00      	nop
   2bf64:	20020784 	.word	0x20020784

0002bf68 <init_mbox_module>:
{
   2bf68:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < CONFIG_NUM_MBOX_ASYNC_MSGS; i++) {
   2bf6a:	2500      	movs	r5, #0
   2bf6c:	4c09      	ldr	r4, [pc, #36]	; (2bf94 <init_mbox_module+0x2c>)
	return z_impl_k_stack_push(stack, data);
   2bf6e:	4e0a      	ldr	r6, [pc, #40]	; (2bf98 <init_mbox_module+0x30>)
		z_init_thread_base(&async_msg[i].thread, 0, _THREAD_DUMMY, 0);
   2bf70:	2300      	movs	r3, #0
   2bf72:	2201      	movs	r2, #1
   2bf74:	4619      	mov	r1, r3
   2bf76:	4620      	mov	r0, r4
   2bf78:	f00c fef0 	bl	38d5c <z_init_thread_base>
   2bf7c:	4621      	mov	r1, r4
   2bf7e:	4630      	mov	r0, r6
	for (i = 0; i < CONFIG_NUM_MBOX_ASYNC_MSGS; i++) {
   2bf80:	3501      	adds	r5, #1
   2bf82:	f002 f8fb 	bl	2e17c <z_impl_k_stack_push>
   2bf86:	2d0a      	cmp	r5, #10
   2bf88:	f104 045c 	add.w	r4, r4, #92	; 0x5c
   2bf8c:	d1f0      	bne.n	2bf70 <init_mbox_module+0x8>
}
   2bf8e:	2000      	movs	r0, #0
   2bf90:	bd70      	pop	{r4, r5, r6, pc}
   2bf92:	bf00      	nop
   2bf94:	200374d8 	.word	0x200374d8
   2bf98:	20020784 	.word	0x20020784

0002bf9c <k_mbox_put>:

int k_mbox_put(struct k_mbox *mbox, struct k_mbox_msg *tx_msg,
	       k_timeout_t timeout)
{
	/* configure things for a synchronous send, then send the message */
	tx_msg->_syncing_thread = _current;
   2bf9c:	4b02      	ldr	r3, [pc, #8]	; (2bfa8 <k_mbox_put+0xc>)
   2bf9e:	689b      	ldr	r3, [r3, #8]
   2bfa0:	624b      	str	r3, [r1, #36]	; 0x24

	return mbox_message_put(mbox, tx_msg, timeout);
   2bfa2:	f7ff bf01 	b.w	2bda8 <mbox_message_put>
   2bfa6:	bf00      	nop
   2bfa8:	200274dc 	.word	0x200274dc

0002bfac <k_mbox_get>:
	return 0;
}

int k_mbox_get(struct k_mbox *mbox, struct k_mbox_msg *rx_msg, void *buffer,
	       k_timeout_t timeout)
{
   2bfac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct k_mbox_msg *tx_msg;
	k_spinlock_key_t key;
	int result;

	/* save receiver id so it can be used during message matching */
	rx_msg->tx_target_thread = _current;
   2bfb0:	4d43      	ldr	r5, [pc, #268]	; (2c0c0 <k_mbox_get+0x114>)
{
   2bfb2:	469a      	mov	sl, r3
	rx_msg->tx_target_thread = _current;
   2bfb4:	68ab      	ldr	r3, [r5, #8]
{
   2bfb6:	4607      	mov	r7, r0
   2bfb8:	460e      	mov	r6, r1
   2bfba:	4690      	mov	r8, r2
	rx_msg->tx_target_thread = _current;
   2bfbc:	620b      	str	r3, [r1, #32]

	/* search mailbox's tx queue for a compatible sender */
	key = k_spin_lock(&mbox->lock);
   2bfbe:	f100 0410 	add.w	r4, r0, #16
   2bfc2:	f04f 0320 	mov.w	r3, #32
   2bfc6:	f3ef 8911 	mrs	r9, BASEPRI
   2bfca:	f383 8811 	msr	BASEPRI, r3
   2bfce:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2bfd2:	4620      	mov	r0, r4
   2bfd4:	f002 fa84 	bl	2e4e0 <z_spin_lock_valid>
   2bfd8:	46ab      	mov	fp, r5
   2bfda:	b968      	cbnz	r0, 2bff8 <k_mbox_get+0x4c>
   2bfdc:	235c      	movs	r3, #92	; 0x5c
   2bfde:	4a39      	ldr	r2, [pc, #228]	; (2c0c4 <k_mbox_get+0x118>)
   2bfe0:	4939      	ldr	r1, [pc, #228]	; (2c0c8 <k_mbox_get+0x11c>)
   2bfe2:	483a      	ldr	r0, [pc, #232]	; (2c0cc <k_mbox_get+0x120>)
   2bfe4:	f007 faf0 	bl	335c8 <printk>
   2bfe8:	4621      	mov	r1, r4
   2bfea:	4839      	ldr	r0, [pc, #228]	; (2c0d0 <k_mbox_get+0x124>)
   2bfec:	f007 faec 	bl	335c8 <printk>
   2bff0:	215c      	movs	r1, #92	; 0x5c
   2bff2:	4834      	ldr	r0, [pc, #208]	; (2c0c4 <k_mbox_get+0x118>)
   2bff4:	f007 fde9 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2bff8:	4620      	mov	r0, r4
   2bffa:	f002 fa8f 	bl	2e51c <z_spin_lock_set_owner>
	return list->head == list;
   2bffe:	683d      	ldr	r5, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2c000:	42af      	cmp	r7, r5
   2c002:	d125      	bne.n	2c050 <k_mbox_get+0xa4>
		}
	}

	/* didn't find a matching sender */

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2c004:	f1ba 0f00 	cmp.w	sl, #0
   2c008:	d14d      	bne.n	2c0a6 <k_mbox_get+0xfa>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c00a:	4620      	mov	r0, r4
   2c00c:	f002 fa76 	bl	2e4fc <z_spin_unlock_valid>
   2c010:	b968      	cbnz	r0, 2c02e <k_mbox_get+0x82>
   2c012:	2384      	movs	r3, #132	; 0x84
   2c014:	4a2b      	ldr	r2, [pc, #172]	; (2c0c4 <k_mbox_get+0x118>)
   2c016:	492f      	ldr	r1, [pc, #188]	; (2c0d4 <k_mbox_get+0x128>)
   2c018:	482c      	ldr	r0, [pc, #176]	; (2c0cc <k_mbox_get+0x120>)
   2c01a:	f007 fad5 	bl	335c8 <printk>
   2c01e:	4621      	mov	r1, r4
   2c020:	482d      	ldr	r0, [pc, #180]	; (2c0d8 <k_mbox_get+0x12c>)
   2c022:	f007 fad1 	bl	335c8 <printk>
   2c026:	2184      	movs	r1, #132	; 0x84
   2c028:	4826      	ldr	r0, [pc, #152]	; (2c0c4 <k_mbox_get+0x118>)
   2c02a:	f007 fdce 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c02e:	f389 8811 	msr	BASEPRI, r9
   2c032:	f3bf 8f6f 	isb	sy
		/* don't wait for a matching sender to appear */
		k_spin_unlock(&mbox->lock, key);
		return -ENOMSG;
   2c036:	f06f 0022 	mvn.w	r0, #34	; 0x22
   2c03a:	e032      	b.n	2c0a2 <k_mbox_get+0xf6>
	} else if (rx_msg->size == 0) {
   2c03c:	6873      	ldr	r3, [r6, #4]
   2c03e:	bb7b      	cbnz	r3, 2c0a0 <k_mbox_get+0xf4>
		mbox_message_dispose(rx_msg);
   2c040:	4630      	mov	r0, r6
   2c042:	f7ff ff5b 	bl	2befc <mbox_message_dispose>
   2c046:	e02b      	b.n	2c0a0 <k_mbox_get+0xf4>
	return (node == list->tail) ? NULL : node->next;
   2c048:	687b      	ldr	r3, [r7, #4]
   2c04a:	429d      	cmp	r5, r3
   2c04c:	d0da      	beq.n	2c004 <k_mbox_get+0x58>
   2c04e:	682d      	ldr	r5, [r5, #0]
	_WAIT_Q_FOR_EACH(&mbox->tx_msg_queue, sending_thread) {
   2c050:	2d00      	cmp	r5, #0
   2c052:	d0d7      	beq.n	2c004 <k_mbox_get+0x58>
		if (mbox_message_match(tx_msg, rx_msg) == 0) {
   2c054:	4631      	mov	r1, r6
   2c056:	6968      	ldr	r0, [r5, #20]
   2c058:	f00c fd77 	bl	38b4a <mbox_message_match>
   2c05c:	2800      	cmp	r0, #0
   2c05e:	d1f3      	bne.n	2c048 <k_mbox_get+0x9c>
			z_unpend_thread(sending_thread);
   2c060:	4628      	mov	r0, r5
   2c062:	f000 ffb3 	bl	2cfcc <z_unpend_thread>
   2c066:	4620      	mov	r0, r4
   2c068:	f002 fa48 	bl	2e4fc <z_spin_unlock_valid>
   2c06c:	b968      	cbnz	r0, 2c08a <k_mbox_get+0xde>
   2c06e:	2384      	movs	r3, #132	; 0x84
   2c070:	4a14      	ldr	r2, [pc, #80]	; (2c0c4 <k_mbox_get+0x118>)
   2c072:	4918      	ldr	r1, [pc, #96]	; (2c0d4 <k_mbox_get+0x128>)
   2c074:	4815      	ldr	r0, [pc, #84]	; (2c0cc <k_mbox_get+0x120>)
   2c076:	f007 faa7 	bl	335c8 <printk>
   2c07a:	4621      	mov	r1, r4
   2c07c:	4816      	ldr	r0, [pc, #88]	; (2c0d8 <k_mbox_get+0x12c>)
   2c07e:	f007 faa3 	bl	335c8 <printk>
   2c082:	2184      	movs	r1, #132	; 0x84
   2c084:	480f      	ldr	r0, [pc, #60]	; (2c0c4 <k_mbox_get+0x118>)
   2c086:	f007 fda0 	bl	33bca <assert_post_action>
   2c08a:	f389 8811 	msr	BASEPRI, r9
   2c08e:	f3bf 8f6f 	isb	sy
	if (buffer != NULL) {
   2c092:	f1b8 0f00 	cmp.w	r8, #0
   2c096:	d0d1      	beq.n	2c03c <k_mbox_get+0x90>
		k_mbox_data_get(rx_msg, buffer);
   2c098:	4641      	mov	r1, r8
   2c09a:	4630      	mov	r0, r6
   2c09c:	f00c fd8f 	bl	38bbe <k_mbox_data_get>
			return mbox_message_data_check(rx_msg, buffer);
   2c0a0:	2000      	movs	r0, #0
	if (result == 0) {
		result = mbox_message_data_check(rx_msg, buffer);
	}

	return result;
}
   2c0a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	_current->base.swap_data = rx_msg;
   2c0a6:	f8db 3008 	ldr.w	r3, [fp, #8]
	result = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);
   2c0aa:	f107 0208 	add.w	r2, r7, #8
	_current->base.swap_data = rx_msg;
   2c0ae:	615e      	str	r6, [r3, #20]
	result = z_pend_curr(&mbox->lock, key, &mbox->rx_msg_queue, timeout);
   2c0b0:	4649      	mov	r1, r9
   2c0b2:	4653      	mov	r3, sl
   2c0b4:	4620      	mov	r0, r4
   2c0b6:	f001 fcbb 	bl	2da30 <z_pend_curr>
	if (result == 0) {
   2c0ba:	2800      	cmp	r0, #0
   2c0bc:	d1f1      	bne.n	2c0a2 <k_mbox_get+0xf6>
   2c0be:	e7e8      	b.n	2c092 <k_mbox_get+0xe6>
   2c0c0:	200274dc 	.word	0x200274dc
   2c0c4:	0003c751 	.word	0x0003c751
   2c0c8:	0003c777 	.word	0x0003c777
   2c0cc:	0003b77f 	.word	0x0003b77f
   2c0d0:	0003c78c 	.word	0x0003c78c
   2c0d4:	0003c7a4 	.word	0x0003c7a4
   2c0d8:	0003c7bb 	.word	0x0003c7bb

0002c0dc <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
   2c0dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2c0e0:	4d16      	ldr	r5, [pc, #88]	; (2c13c <init_mem_slab_module+0x60>)
   2c0e2:	4c17      	ldr	r4, [pc, #92]	; (2c140 <init_mem_slab_module+0x64>)
   2c0e4:	46a8      	mov	r8, r5
   2c0e6:	4e17      	ldr	r6, [pc, #92]	; (2c144 <init_mem_slab_module+0x68>)
   2c0e8:	42ac      	cmp	r4, r5
   2c0ea:	d90c      	bls.n	2c106 <init_mem_slab_module+0x2a>
   2c0ec:	4916      	ldr	r1, [pc, #88]	; (2c148 <init_mem_slab_module+0x6c>)
   2c0ee:	2342      	movs	r3, #66	; 0x42
   2c0f0:	4632      	mov	r2, r6
   2c0f2:	4816      	ldr	r0, [pc, #88]	; (2c14c <init_mem_slab_module+0x70>)
   2c0f4:	f007 fa68 	bl	335c8 <printk>
   2c0f8:	4815      	ldr	r0, [pc, #84]	; (2c150 <init_mem_slab_module+0x74>)
   2c0fa:	f007 fa65 	bl	335c8 <printk>
   2c0fe:	2142      	movs	r1, #66	; 0x42
   2c100:	4630      	mov	r0, r6
   2c102:	f007 fd62 	bl	33bca <assert_post_action>
   2c106:	4544      	cmp	r4, r8
   2c108:	d302      	bcc.n	2c110 <init_mem_slab_module+0x34>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
   2c10a:	2000      	movs	r0, #0
	return rc;
}
   2c10c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   2c110:	e9d4 1203 	ldrd	r1, r2, [r4, #12]
   2c114:	ea42 0301 	orr.w	r3, r2, r1
   2c118:	f013 0303 	ands.w	r3, r3, #3
   2c11c:	d10b      	bne.n	2c136 <init_mem_slab_module+0x5a>
	for (j = 0U; j < slab->num_blocks; j++) {
   2c11e:	68a0      	ldr	r0, [r4, #8]
	slab->free_list = NULL;
   2c120:	6163      	str	r3, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2c122:	4283      	cmp	r3, r0
   2c124:	d101      	bne.n	2c12a <init_mem_slab_module+0x4e>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
   2c126:	341c      	adds	r4, #28
   2c128:	e7de      	b.n	2c0e8 <init_mem_slab_module+0xc>
		*(char **)p = slab->free_list;
   2c12a:	6967      	ldr	r7, [r4, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   2c12c:	3301      	adds	r3, #1
		*(char **)p = slab->free_list;
   2c12e:	6017      	str	r7, [r2, #0]
		slab->free_list = p;
   2c130:	6162      	str	r2, [r4, #20]
		p += slab->block_size;
   2c132:	440a      	add	r2, r1
   2c134:	e7f5      	b.n	2c122 <init_mem_slab_module+0x46>
		return -EINVAL;
   2c136:	f06f 0015 	mvn.w	r0, #21
	return rc;
   2c13a:	e7e7      	b.n	2c10c <init_mem_slab_module+0x30>
   2c13c:	200206bc 	.word	0x200206bc
   2c140:	20020668 	.word	0x20020668
   2c144:	0003fc03 	.word	0x0003fc03
   2c148:	0003fc28 	.word	0x0003fc28
   2c14c:	0003b77f 	.word	0x0003b77f
   2c150:	0003cc09 	.word	0x0003cc09

0002c154 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
   2c154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c156:	4604      	mov	r4, r0
   2c158:	460d      	mov	r5, r1
   2c15a:	4616      	mov	r6, r2
	__asm__ volatile(
   2c15c:	f04f 0320 	mov.w	r3, #32
   2c160:	f3ef 8711 	mrs	r7, BASEPRI
   2c164:	f383 8811 	msr	BASEPRI, r3
   2c168:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c16c:	4823      	ldr	r0, [pc, #140]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c16e:	f002 f9b7 	bl	2e4e0 <z_spin_lock_valid>
   2c172:	b968      	cbnz	r0, 2c190 <k_mem_slab_alloc+0x3c>
   2c174:	235c      	movs	r3, #92	; 0x5c
   2c176:	4a22      	ldr	r2, [pc, #136]	; (2c200 <k_mem_slab_alloc+0xac>)
   2c178:	4922      	ldr	r1, [pc, #136]	; (2c204 <k_mem_slab_alloc+0xb0>)
   2c17a:	4823      	ldr	r0, [pc, #140]	; (2c208 <k_mem_slab_alloc+0xb4>)
   2c17c:	f007 fa24 	bl	335c8 <printk>
   2c180:	491e      	ldr	r1, [pc, #120]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c182:	4822      	ldr	r0, [pc, #136]	; (2c20c <k_mem_slab_alloc+0xb8>)
   2c184:	f007 fa20 	bl	335c8 <printk>
   2c188:	215c      	movs	r1, #92	; 0x5c
   2c18a:	481d      	ldr	r0, [pc, #116]	; (2c200 <k_mem_slab_alloc+0xac>)
   2c18c:	f007 fd1d 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c190:	481a      	ldr	r0, [pc, #104]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c192:	f002 f9c3 	bl	2e51c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
   2c196:	6963      	ldr	r3, [r4, #20]
   2c198:	b1eb      	cbz	r3, 2c1d6 <k_mem_slab_alloc+0x82>
		/* take a free block */
		*mem = slab->free_list;
   2c19a:	602b      	str	r3, [r5, #0]
		slab->free_list = *(char **)(slab->free_list);
   2c19c:	681b      	ldr	r3, [r3, #0]
   2c19e:	6163      	str	r3, [r4, #20]
		slab->num_used++;
   2c1a0:	69a3      	ldr	r3, [r4, #24]
   2c1a2:	3301      	adds	r3, #1
   2c1a4:	61a3      	str	r3, [r4, #24]
		result = 0;
   2c1a6:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c1a8:	4814      	ldr	r0, [pc, #80]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c1aa:	f002 f9a7 	bl	2e4fc <z_spin_unlock_valid>
   2c1ae:	b968      	cbnz	r0, 2c1cc <k_mem_slab_alloc+0x78>
   2c1b0:	2384      	movs	r3, #132	; 0x84
   2c1b2:	4a13      	ldr	r2, [pc, #76]	; (2c200 <k_mem_slab_alloc+0xac>)
   2c1b4:	4916      	ldr	r1, [pc, #88]	; (2c210 <k_mem_slab_alloc+0xbc>)
   2c1b6:	4814      	ldr	r0, [pc, #80]	; (2c208 <k_mem_slab_alloc+0xb4>)
   2c1b8:	f007 fa06 	bl	335c8 <printk>
   2c1bc:	490f      	ldr	r1, [pc, #60]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c1be:	4815      	ldr	r0, [pc, #84]	; (2c214 <k_mem_slab_alloc+0xc0>)
   2c1c0:	f007 fa02 	bl	335c8 <printk>
   2c1c4:	2184      	movs	r1, #132	; 0x84
   2c1c6:	480e      	ldr	r0, [pc, #56]	; (2c200 <k_mem_slab_alloc+0xac>)
   2c1c8:	f007 fcff 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c1cc:	f387 8811 	msr	BASEPRI, r7
   2c1d0:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
   2c1d4:	e010      	b.n	2c1f8 <k_mem_slab_alloc+0xa4>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2c1d6:	b91e      	cbnz	r6, 2c1e0 <k_mem_slab_alloc+0x8c>
		*mem = NULL;
   2c1d8:	602e      	str	r6, [r5, #0]
		result = -ENOMEM;
   2c1da:	f06f 040b 	mvn.w	r4, #11
   2c1de:	e7e3      	b.n	2c1a8 <k_mem_slab_alloc+0x54>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
   2c1e0:	4622      	mov	r2, r4
   2c1e2:	4633      	mov	r3, r6
   2c1e4:	4639      	mov	r1, r7
   2c1e6:	4805      	ldr	r0, [pc, #20]	; (2c1fc <k_mem_slab_alloc+0xa8>)
   2c1e8:	f001 fc22 	bl	2da30 <z_pend_curr>
		if (result == 0) {
   2c1ec:	4604      	mov	r4, r0
   2c1ee:	b918      	cbnz	r0, 2c1f8 <k_mem_slab_alloc+0xa4>
			*mem = _current->base.swap_data;
   2c1f0:	4b09      	ldr	r3, [pc, #36]	; (2c218 <k_mem_slab_alloc+0xc4>)
   2c1f2:	689b      	ldr	r3, [r3, #8]
   2c1f4:	695b      	ldr	r3, [r3, #20]
   2c1f6:	602b      	str	r3, [r5, #0]
}
   2c1f8:	4620      	mov	r0, r4
   2c1fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2c1fc:	20022c74 	.word	0x20022c74
   2c200:	0003c751 	.word	0x0003c751
   2c204:	0003c777 	.word	0x0003c777
   2c208:	0003b77f 	.word	0x0003b77f
   2c20c:	0003c78c 	.word	0x0003c78c
   2c210:	0003c7a4 	.word	0x0003c7a4
   2c214:	0003c7bb 	.word	0x0003c7bb
   2c218:	200274dc 	.word	0x200274dc

0002c21c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
   2c21c:	b570      	push	{r4, r5, r6, lr}
   2c21e:	4604      	mov	r4, r0
   2c220:	460d      	mov	r5, r1
	__asm__ volatile(
   2c222:	f04f 0320 	mov.w	r3, #32
   2c226:	f3ef 8611 	mrs	r6, BASEPRI
   2c22a:	f383 8811 	msr	BASEPRI, r3
   2c22e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c232:	4822      	ldr	r0, [pc, #136]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c234:	f002 f954 	bl	2e4e0 <z_spin_lock_valid>
   2c238:	b968      	cbnz	r0, 2c256 <k_mem_slab_free+0x3a>
   2c23a:	235c      	movs	r3, #92	; 0x5c
   2c23c:	4a20      	ldr	r2, [pc, #128]	; (2c2c0 <k_mem_slab_free+0xa4>)
   2c23e:	4921      	ldr	r1, [pc, #132]	; (2c2c4 <k_mem_slab_free+0xa8>)
   2c240:	4821      	ldr	r0, [pc, #132]	; (2c2c8 <k_mem_slab_free+0xac>)
   2c242:	f007 f9c1 	bl	335c8 <printk>
   2c246:	491d      	ldr	r1, [pc, #116]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c248:	4820      	ldr	r0, [pc, #128]	; (2c2cc <k_mem_slab_free+0xb0>)
   2c24a:	f007 f9bd 	bl	335c8 <printk>
   2c24e:	215c      	movs	r1, #92	; 0x5c
   2c250:	481b      	ldr	r0, [pc, #108]	; (2c2c0 <k_mem_slab_free+0xa4>)
   2c252:	f007 fcba 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c256:	4819      	ldr	r0, [pc, #100]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c258:	f002 f960 	bl	2e51c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
   2c25c:	4620      	mov	r0, r4
   2c25e:	f001 fca5 	bl	2dbac <z_unpend_first_thread>

	if (pending_thread != NULL) {
   2c262:	b158      	cbz	r0, 2c27c <k_mem_slab_free+0x60>
   2c264:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
   2c266:	682a      	ldr	r2, [r5, #0]
   2c268:	6701      	str	r1, [r0, #112]	; 0x70
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
   2c26a:	6142      	str	r2, [r0, #20]
		z_ready_thread(pending_thread);
   2c26c:	f000 ffee 	bl	2d24c <z_ready_thread>
		z_reschedule(&lock, key);
   2c270:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
   2c272:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
   2c276:	4811      	ldr	r0, [pc, #68]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c278:	f000 bdc6 	b.w	2ce08 <z_reschedule>
		**(char ***)mem = slab->free_list;
   2c27c:	682b      	ldr	r3, [r5, #0]
   2c27e:	6962      	ldr	r2, [r4, #20]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c280:	480e      	ldr	r0, [pc, #56]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c282:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
   2c284:	682b      	ldr	r3, [r5, #0]
   2c286:	6163      	str	r3, [r4, #20]
		slab->num_used--;
   2c288:	69a3      	ldr	r3, [r4, #24]
   2c28a:	3b01      	subs	r3, #1
   2c28c:	61a3      	str	r3, [r4, #24]
   2c28e:	f002 f935 	bl	2e4fc <z_spin_unlock_valid>
   2c292:	b968      	cbnz	r0, 2c2b0 <k_mem_slab_free+0x94>
   2c294:	2384      	movs	r3, #132	; 0x84
   2c296:	4a0a      	ldr	r2, [pc, #40]	; (2c2c0 <k_mem_slab_free+0xa4>)
   2c298:	490d      	ldr	r1, [pc, #52]	; (2c2d0 <k_mem_slab_free+0xb4>)
   2c29a:	480b      	ldr	r0, [pc, #44]	; (2c2c8 <k_mem_slab_free+0xac>)
   2c29c:	f007 f994 	bl	335c8 <printk>
   2c2a0:	4906      	ldr	r1, [pc, #24]	; (2c2bc <k_mem_slab_free+0xa0>)
   2c2a2:	480c      	ldr	r0, [pc, #48]	; (2c2d4 <k_mem_slab_free+0xb8>)
   2c2a4:	f007 f990 	bl	335c8 <printk>
   2c2a8:	2184      	movs	r1, #132	; 0x84
   2c2aa:	4805      	ldr	r0, [pc, #20]	; (2c2c0 <k_mem_slab_free+0xa4>)
   2c2ac:	f007 fc8d 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c2b0:	f386 8811 	msr	BASEPRI, r6
   2c2b4:	f3bf 8f6f 	isb	sy
}
   2c2b8:	bd70      	pop	{r4, r5, r6, pc}
   2c2ba:	bf00      	nop
   2c2bc:	20022c74 	.word	0x20022c74
   2c2c0:	0003c751 	.word	0x0003c751
   2c2c4:	0003c777 	.word	0x0003c777
   2c2c8:	0003b77f 	.word	0x0003b77f
   2c2cc:	0003c78c 	.word	0x0003c78c
   2c2d0:	0003c7a4 	.word	0x0003c7a4
   2c2d4:	0003c7bb 	.word	0x0003c7bb

0002c2d8 <k_malloc>:
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
   2c2d8:	4601      	mov	r1, r0
   2c2da:	4801      	ldr	r0, [pc, #4]	; (2c2e0 <k_malloc+0x8>)
   2c2dc:	f00c bc83 	b.w	38be6 <k_mem_pool_malloc>
   2c2e0:	20020228 	.word	0x20020228

0002c2e4 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
   2c2e4:	b510      	push	{r4, lr}
   2c2e6:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
   2c2e8:	f00c fd2b 	bl	38d42 <k_is_in_isr>
   2c2ec:	b948      	cbnz	r0, 2c302 <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
   2c2ee:	4b06      	ldr	r3, [pc, #24]	; (2c308 <z_thread_malloc+0x24>)
   2c2f0:	689b      	ldr	r3, [r3, #8]
   2c2f2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	}

	if (pool) {
   2c2f4:	b13b      	cbz	r3, 2c306 <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
   2c2f6:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
   2c2f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
   2c2fc:	4618      	mov	r0, r3
   2c2fe:	f00c bc72 	b.w	38be6 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
   2c302:	4b02      	ldr	r3, [pc, #8]	; (2c30c <z_thread_malloc+0x28>)
   2c304:	e7f7      	b.n	2c2f6 <z_thread_malloc+0x12>
}
   2c306:	bd10      	pop	{r4, pc}
   2c308:	200274dc 	.word	0x200274dc
   2c30c:	20020228 	.word	0x20020228

0002c310 <z_impl_k_msgq_put>:
	return 0;
}


int z_impl_k_msgq_put(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   2c310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c314:	4604      	mov	r4, r0
   2c316:	4688      	mov	r8, r1
   2c318:	4616      	mov	r6, r2
   2c31a:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2c31e:	b16b      	cbz	r3, 2c33c <z_impl_k_msgq_put+0x2c>
   2c320:	b162      	cbz	r2, 2c33c <z_impl_k_msgq_put+0x2c>
   2c322:	493e      	ldr	r1, [pc, #248]	; (2c41c <z_impl_k_msgq_put+0x10c>)
   2c324:	2376      	movs	r3, #118	; 0x76
   2c326:	4a3e      	ldr	r2, [pc, #248]	; (2c420 <z_impl_k_msgq_put+0x110>)
   2c328:	483e      	ldr	r0, [pc, #248]	; (2c424 <z_impl_k_msgq_put+0x114>)
   2c32a:	f007 f94d 	bl	335c8 <printk>
   2c32e:	483e      	ldr	r0, [pc, #248]	; (2c428 <z_impl_k_msgq_put+0x118>)
   2c330:	f007 f94a 	bl	335c8 <printk>
   2c334:	2176      	movs	r1, #118	; 0x76
   2c336:	483a      	ldr	r0, [pc, #232]	; (2c420 <z_impl_k_msgq_put+0x110>)
   2c338:	f007 fc47 	bl	33bca <assert_post_action>

	struct k_thread *pending_thread;
	k_spinlock_key_t key;
	int result;

	key = k_spin_lock(&msgq->lock);
   2c33c:	f104 0508 	add.w	r5, r4, #8
	__asm__ volatile(
   2c340:	f04f 0320 	mov.w	r3, #32
   2c344:	f3ef 8711 	mrs	r7, BASEPRI
   2c348:	f383 8811 	msr	BASEPRI, r3
   2c34c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c350:	4628      	mov	r0, r5
   2c352:	f002 f8c5 	bl	2e4e0 <z_spin_lock_valid>
   2c356:	b968      	cbnz	r0, 2c374 <z_impl_k_msgq_put+0x64>
   2c358:	235c      	movs	r3, #92	; 0x5c
   2c35a:	4a34      	ldr	r2, [pc, #208]	; (2c42c <z_impl_k_msgq_put+0x11c>)
   2c35c:	4934      	ldr	r1, [pc, #208]	; (2c430 <z_impl_k_msgq_put+0x120>)
   2c35e:	4831      	ldr	r0, [pc, #196]	; (2c424 <z_impl_k_msgq_put+0x114>)
   2c360:	f007 f932 	bl	335c8 <printk>
   2c364:	4629      	mov	r1, r5
   2c366:	4833      	ldr	r0, [pc, #204]	; (2c434 <z_impl_k_msgq_put+0x124>)
   2c368:	f007 f92e 	bl	335c8 <printk>
   2c36c:	215c      	movs	r1, #92	; 0x5c
   2c36e:	482f      	ldr	r0, [pc, #188]	; (2c42c <z_impl_k_msgq_put+0x11c>)
   2c370:	f007 fc2b 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c374:	4628      	mov	r0, r5
   2c376:	f002 f8d1 	bl	2e51c <z_spin_lock_set_owner>

	if (msgq->used_msgs < msgq->max_msgs) {
   2c37a:	6a62      	ldr	r2, [r4, #36]	; 0x24
   2c37c:	6923      	ldr	r3, [r4, #16]
   2c37e:	429a      	cmp	r2, r3
   2c380:	d23c      	bcs.n	2c3fc <z_impl_k_msgq_put+0xec>
		/* message queue isn't full */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2c382:	4620      	mov	r0, r4
   2c384:	f001 fc12 	bl	2dbac <z_unpend_first_thread>
		if (pending_thread != NULL) {
   2c388:	68e2      	ldr	r2, [r4, #12]
   2c38a:	4606      	mov	r6, r0
   2c38c:	4641      	mov	r1, r8
   2c38e:	b170      	cbz	r0, 2c3ae <z_impl_k_msgq_put+0x9e>
   2c390:	2400      	movs	r4, #0
   2c392:	6940      	ldr	r0, [r0, #20]
   2c394:	f00c fe20 	bl	38fd8 <memcpy>
			/* give message to waiting thread */
			(void)memcpy(pending_thread->base.swap_data, data,
			       msgq->msg_size);
			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   2c398:	4630      	mov	r0, r6
   2c39a:	6734      	str	r4, [r6, #112]	; 0x70
   2c39c:	f000 ff56 	bl	2d24c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   2c3a0:	4639      	mov	r1, r7
   2c3a2:	4628      	mov	r0, r5
   2c3a4:	f000 fd30 	bl	2ce08 <z_reschedule>
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2c3a8:	4620      	mov	r0, r4
   2c3aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2c3ae:	6a20      	ldr	r0, [r4, #32]
   2c3b0:	f00c fe12 	bl	38fd8 <memcpy>
			msgq->write_ptr += msgq->msg_size;
   2c3b4:	6a23      	ldr	r3, [r4, #32]
   2c3b6:	68e2      	ldr	r2, [r4, #12]
   2c3b8:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   2c3ba:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   2c3bc:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   2c3be:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   2c3c0:	bf04      	itt	eq
   2c3c2:	6963      	ldreq	r3, [r4, #20]
   2c3c4:	6223      	streq	r3, [r4, #32]
			msgq->used_msgs++;
   2c3c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c3c8:	3301      	adds	r3, #1
   2c3ca:	6263      	str	r3, [r4, #36]	; 0x24
		result = 0;
   2c3cc:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c3ce:	4628      	mov	r0, r5
   2c3d0:	f002 f894 	bl	2e4fc <z_spin_unlock_valid>
   2c3d4:	b968      	cbnz	r0, 2c3f2 <z_impl_k_msgq_put+0xe2>
   2c3d6:	2384      	movs	r3, #132	; 0x84
   2c3d8:	4a14      	ldr	r2, [pc, #80]	; (2c42c <z_impl_k_msgq_put+0x11c>)
   2c3da:	4917      	ldr	r1, [pc, #92]	; (2c438 <z_impl_k_msgq_put+0x128>)
   2c3dc:	4811      	ldr	r0, [pc, #68]	; (2c424 <z_impl_k_msgq_put+0x114>)
   2c3de:	f007 f8f3 	bl	335c8 <printk>
   2c3e2:	4629      	mov	r1, r5
   2c3e4:	4815      	ldr	r0, [pc, #84]	; (2c43c <z_impl_k_msgq_put+0x12c>)
   2c3e6:	f007 f8ef 	bl	335c8 <printk>
   2c3ea:	2184      	movs	r1, #132	; 0x84
   2c3ec:	480f      	ldr	r0, [pc, #60]	; (2c42c <z_impl_k_msgq_put+0x11c>)
   2c3ee:	f007 fbec 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c3f2:	f387 8811 	msr	BASEPRI, r7
   2c3f6:	f3bf 8f6f 	isb	sy
	return result;
   2c3fa:	e7d5      	b.n	2c3a8 <z_impl_k_msgq_put+0x98>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2c3fc:	b15e      	cbz	r6, 2c416 <z_impl_k_msgq_put+0x106>
		_current->base.swap_data = data;
   2c3fe:	4b10      	ldr	r3, [pc, #64]	; (2c440 <z_impl_k_msgq_put+0x130>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c400:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   2c402:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c404:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   2c406:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c40a:	4628      	mov	r0, r5
   2c40c:	4633      	mov	r3, r6
}
   2c40e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c412:	f001 bb0d 	b.w	2da30 <z_pend_curr>
		result = -ENOMSG;
   2c416:	f06f 0422 	mvn.w	r4, #34	; 0x22
   2c41a:	e7d8      	b.n	2c3ce <z_impl_k_msgq_put+0xbe>
   2c41c:	0003fba3 	.word	0x0003fba3
   2c420:	0003fc45 	.word	0x0003fc45
   2c424:	0003b77f 	.word	0x0003b77f
   2c428:	0003cb8b 	.word	0x0003cb8b
   2c42c:	0003c751 	.word	0x0003c751
   2c430:	0003c777 	.word	0x0003c777
   2c434:	0003c78c 	.word	0x0003c78c
   2c438:	0003c7a4 	.word	0x0003c7a4
   2c43c:	0003c7bb 	.word	0x0003c7bb
   2c440:	200274dc 	.word	0x200274dc

0002c444 <z_impl_k_msgq_get>:
}
#include <syscalls/k_msgq_get_attrs_mrsh.c>
#endif

int z_impl_k_msgq_get(struct k_msgq *msgq, void *data, k_timeout_t timeout)
{
   2c444:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2c448:	4604      	mov	r4, r0
   2c44a:	4688      	mov	r8, r1
   2c44c:	4615      	mov	r5, r2
   2c44e:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr() || K_TIMEOUT_EQ(timeout, K_NO_WAIT), "");
   2c452:	b16b      	cbz	r3, 2c470 <z_impl_k_msgq_get+0x2c>
   2c454:	b162      	cbz	r2, 2c470 <z_impl_k_msgq_get+0x2c>
   2c456:	4944      	ldr	r1, [pc, #272]	; (2c568 <z_impl_k_msgq_get+0x124>)
   2c458:	23c2      	movs	r3, #194	; 0xc2
   2c45a:	4a44      	ldr	r2, [pc, #272]	; (2c56c <z_impl_k_msgq_get+0x128>)
   2c45c:	4844      	ldr	r0, [pc, #272]	; (2c570 <z_impl_k_msgq_get+0x12c>)
   2c45e:	f007 f8b3 	bl	335c8 <printk>
   2c462:	4844      	ldr	r0, [pc, #272]	; (2c574 <z_impl_k_msgq_get+0x130>)
   2c464:	f007 f8b0 	bl	335c8 <printk>
   2c468:	21c2      	movs	r1, #194	; 0xc2
   2c46a:	4840      	ldr	r0, [pc, #256]	; (2c56c <z_impl_k_msgq_get+0x128>)
   2c46c:	f007 fbad 	bl	33bca <assert_post_action>

	k_spinlock_key_t key;
	struct k_thread *pending_thread;
	int result;

	key = k_spin_lock(&msgq->lock);
   2c470:	f104 0608 	add.w	r6, r4, #8
	__asm__ volatile(
   2c474:	f04f 0320 	mov.w	r3, #32
   2c478:	f3ef 8711 	mrs	r7, BASEPRI
   2c47c:	f383 8811 	msr	BASEPRI, r3
   2c480:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c484:	4630      	mov	r0, r6
   2c486:	f002 f82b 	bl	2e4e0 <z_spin_lock_valid>
   2c48a:	b968      	cbnz	r0, 2c4a8 <z_impl_k_msgq_get+0x64>
   2c48c:	235c      	movs	r3, #92	; 0x5c
   2c48e:	4a3a      	ldr	r2, [pc, #232]	; (2c578 <z_impl_k_msgq_get+0x134>)
   2c490:	493a      	ldr	r1, [pc, #232]	; (2c57c <z_impl_k_msgq_get+0x138>)
   2c492:	4837      	ldr	r0, [pc, #220]	; (2c570 <z_impl_k_msgq_get+0x12c>)
   2c494:	f007 f898 	bl	335c8 <printk>
   2c498:	4631      	mov	r1, r6
   2c49a:	4839      	ldr	r0, [pc, #228]	; (2c580 <z_impl_k_msgq_get+0x13c>)
   2c49c:	f007 f894 	bl	335c8 <printk>
   2c4a0:	215c      	movs	r1, #92	; 0x5c
   2c4a2:	4835      	ldr	r0, [pc, #212]	; (2c578 <z_impl_k_msgq_get+0x134>)
   2c4a4:	f007 fb91 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c4a8:	4630      	mov	r0, r6
   2c4aa:	f002 f837 	bl	2e51c <z_spin_lock_set_owner>

	if (msgq->used_msgs > 0) {
   2c4ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c4b0:	2b00      	cmp	r3, #0
   2c4b2:	d033      	beq.n	2c51c <z_impl_k_msgq_get+0xd8>
   2c4b4:	68e2      	ldr	r2, [r4, #12]
   2c4b6:	69e1      	ldr	r1, [r4, #28]
   2c4b8:	4640      	mov	r0, r8
   2c4ba:	f00c fd8d 	bl	38fd8 <memcpy>
		/* take first available message from queue */
		(void)memcpy(data, msgq->read_ptr, msgq->msg_size);
		msgq->read_ptr += msgq->msg_size;
   2c4be:	69e3      	ldr	r3, [r4, #28]
   2c4c0:	68e2      	ldr	r2, [r4, #12]
			msgq->read_ptr = msgq->buffer_start;
		}
		msgq->used_msgs--;

		/* handle first thread waiting to write (if any) */
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2c4c2:	4620      	mov	r0, r4
		msgq->read_ptr += msgq->msg_size;
   2c4c4:	4413      	add	r3, r2
		if (msgq->read_ptr == msgq->buffer_end) {
   2c4c6:	69a2      	ldr	r2, [r4, #24]
		msgq->read_ptr += msgq->msg_size;
   2c4c8:	61e3      	str	r3, [r4, #28]
		if (msgq->read_ptr == msgq->buffer_end) {
   2c4ca:	4293      	cmp	r3, r2
			msgq->read_ptr = msgq->buffer_start;
   2c4cc:	bf04      	itt	eq
   2c4ce:	6963      	ldreq	r3, [r4, #20]
   2c4d0:	61e3      	streq	r3, [r4, #28]
		msgq->used_msgs--;
   2c4d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c4d4:	3b01      	subs	r3, #1
   2c4d6:	6263      	str	r3, [r4, #36]	; 0x24
		pending_thread = z_unpend_first_thread(&msgq->wait_q);
   2c4d8:	f001 fb68 	bl	2dbac <z_unpend_first_thread>
		if (pending_thread != NULL) {
   2c4dc:	4605      	mov	r5, r0
   2c4de:	b360      	cbz	r0, 2c53a <z_impl_k_msgq_get+0xf6>
   2c4e0:	6941      	ldr	r1, [r0, #20]
   2c4e2:	68e2      	ldr	r2, [r4, #12]
   2c4e4:	6a20      	ldr	r0, [r4, #32]
   2c4e6:	f00c fd77 	bl	38fd8 <memcpy>
			/* add thread's message to queue */
			(void)memcpy(msgq->write_ptr, pending_thread->base.swap_data,
			       msgq->msg_size);
			msgq->write_ptr += msgq->msg_size;
   2c4ea:	6a23      	ldr	r3, [r4, #32]
   2c4ec:	68e2      	ldr	r2, [r4, #12]
			}
			msgq->used_msgs++;

			/* wake up waiting thread */
			arch_thread_return_value_set(pending_thread, 0);
			z_ready_thread(pending_thread);
   2c4ee:	4628      	mov	r0, r5
			msgq->write_ptr += msgq->msg_size;
   2c4f0:	4413      	add	r3, r2
			if (msgq->write_ptr == msgq->buffer_end) {
   2c4f2:	69a2      	ldr	r2, [r4, #24]
			msgq->write_ptr += msgq->msg_size;
   2c4f4:	6223      	str	r3, [r4, #32]
			if (msgq->write_ptr == msgq->buffer_end) {
   2c4f6:	4293      	cmp	r3, r2
				msgq->write_ptr = msgq->buffer_start;
   2c4f8:	bf04      	itt	eq
   2c4fa:	6963      	ldreq	r3, [r4, #20]
   2c4fc:	6223      	streq	r3, [r4, #32]
			msgq->used_msgs++;
   2c4fe:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2c500:	3301      	adds	r3, #1
   2c502:	6263      	str	r3, [r4, #36]	; 0x24
   2c504:	2400      	movs	r4, #0
   2c506:	672c      	str	r4, [r5, #112]	; 0x70
			z_ready_thread(pending_thread);
   2c508:	f000 fea0 	bl	2d24c <z_ready_thread>
			z_reschedule(&msgq->lock, key);
   2c50c:	4639      	mov	r1, r7
   2c50e:	4630      	mov	r0, r6
   2c510:	f000 fc7a 	bl	2ce08 <z_reschedule>
			return 0;
   2c514:	4625      	mov	r5, r4
	}

	k_spin_unlock(&msgq->lock, key);

	return result;
}
   2c516:	4628      	mov	r0, r5
   2c518:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2c51c:	b15d      	cbz	r5, 2c536 <z_impl_k_msgq_get+0xf2>
		_current->base.swap_data = data;
   2c51e:	4b19      	ldr	r3, [pc, #100]	; (2c584 <z_impl_k_msgq_get+0x140>)
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c520:	4622      	mov	r2, r4
		_current->base.swap_data = data;
   2c522:	689b      	ldr	r3, [r3, #8]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c524:	4639      	mov	r1, r7
		_current->base.swap_data = data;
   2c526:	f8c3 8014 	str.w	r8, [r3, #20]
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c52a:	4630      	mov	r0, r6
   2c52c:	462b      	mov	r3, r5
}
   2c52e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		return z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
   2c532:	f001 ba7d 	b.w	2da30 <z_pend_curr>
		result = -ENOMSG;
   2c536:	f06f 0522 	mvn.w	r5, #34	; 0x22
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c53a:	4630      	mov	r0, r6
   2c53c:	f001 ffde 	bl	2e4fc <z_spin_unlock_valid>
   2c540:	b968      	cbnz	r0, 2c55e <z_impl_k_msgq_get+0x11a>
   2c542:	2384      	movs	r3, #132	; 0x84
   2c544:	4a0c      	ldr	r2, [pc, #48]	; (2c578 <z_impl_k_msgq_get+0x134>)
   2c546:	4910      	ldr	r1, [pc, #64]	; (2c588 <z_impl_k_msgq_get+0x144>)
   2c548:	4809      	ldr	r0, [pc, #36]	; (2c570 <z_impl_k_msgq_get+0x12c>)
   2c54a:	f007 f83d 	bl	335c8 <printk>
   2c54e:	4631      	mov	r1, r6
   2c550:	480e      	ldr	r0, [pc, #56]	; (2c58c <z_impl_k_msgq_get+0x148>)
   2c552:	f007 f839 	bl	335c8 <printk>
   2c556:	2184      	movs	r1, #132	; 0x84
   2c558:	4807      	ldr	r0, [pc, #28]	; (2c578 <z_impl_k_msgq_get+0x134>)
   2c55a:	f007 fb36 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c55e:	f387 8811 	msr	BASEPRI, r7
   2c562:	f3bf 8f6f 	isb	sy
	return result;
   2c566:	e7d6      	b.n	2c516 <z_impl_k_msgq_get+0xd2>
   2c568:	0003fba3 	.word	0x0003fba3
   2c56c:	0003fc45 	.word	0x0003fc45
   2c570:	0003b77f 	.word	0x0003b77f
   2c574:	0003cb8b 	.word	0x0003cb8b
   2c578:	0003c751 	.word	0x0003c751
   2c57c:	0003c777 	.word	0x0003c777
   2c580:	0003c78c 	.word	0x0003c78c
   2c584:	200274dc 	.word	0x200274dc
   2c588:	0003c7a4 	.word	0x0003c7a4
   2c58c:	0003c7bb 	.word	0x0003c7bb

0002c590 <z_impl_k_msgq_purge>:
}
#include <syscalls/k_msgq_peek_mrsh.c>
#endif

void z_impl_k_msgq_purge(struct k_msgq *msgq)
{
   2c590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c592:	4604      	mov	r4, r0
	k_spinlock_key_t key;
	struct k_thread *pending_thread;

	key = k_spin_lock(&msgq->lock);
   2c594:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2c598:	f04f 0320 	mov.w	r3, #32
   2c59c:	f3ef 8611 	mrs	r6, BASEPRI
   2c5a0:	f383 8811 	msr	BASEPRI, r3
   2c5a4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c5a8:	4628      	mov	r0, r5
   2c5aa:	f001 ff99 	bl	2e4e0 <z_spin_lock_valid>
   2c5ae:	b968      	cbnz	r0, 2c5cc <z_impl_k_msgq_purge+0x3c>
   2c5b0:	235c      	movs	r3, #92	; 0x5c
   2c5b2:	4a12      	ldr	r2, [pc, #72]	; (2c5fc <z_impl_k_msgq_purge+0x6c>)
   2c5b4:	4912      	ldr	r1, [pc, #72]	; (2c600 <z_impl_k_msgq_purge+0x70>)
   2c5b6:	4813      	ldr	r0, [pc, #76]	; (2c604 <z_impl_k_msgq_purge+0x74>)
   2c5b8:	f007 f806 	bl	335c8 <printk>
   2c5bc:	4629      	mov	r1, r5
   2c5be:	4812      	ldr	r0, [pc, #72]	; (2c608 <z_impl_k_msgq_purge+0x78>)
   2c5c0:	f007 f802 	bl	335c8 <printk>
   2c5c4:	215c      	movs	r1, #92	; 0x5c
   2c5c6:	480d      	ldr	r0, [pc, #52]	; (2c5fc <z_impl_k_msgq_purge+0x6c>)
   2c5c8:	f007 faff 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c5cc:	4628      	mov	r0, r5
   2c5ce:	f001 ffa5 	bl	2e51c <z_spin_lock_set_owner>
   2c5d2:	f06f 0722 	mvn.w	r7, #34	; 0x22

	/* wake up any threads that are waiting to write */
	while ((pending_thread = z_unpend_first_thread(&msgq->wait_q)) != NULL) {
   2c5d6:	4620      	mov	r0, r4
   2c5d8:	f001 fae8 	bl	2dbac <z_unpend_first_thread>
   2c5dc:	4603      	mov	r3, r0
   2c5de:	b940      	cbnz	r0, 2c5f2 <z_impl_k_msgq_purge+0x62>
		arch_thread_return_value_set(pending_thread, -ENOMSG);
		z_ready_thread(pending_thread);
	}

	msgq->used_msgs = 0;
	msgq->read_ptr = msgq->write_ptr;
   2c5e0:	6a23      	ldr	r3, [r4, #32]
	msgq->used_msgs = 0;
   2c5e2:	6260      	str	r0, [r4, #36]	; 0x24
	msgq->read_ptr = msgq->write_ptr;
   2c5e4:	61e3      	str	r3, [r4, #28]

	z_reschedule(&msgq->lock, key);
   2c5e6:	4631      	mov	r1, r6
   2c5e8:	4628      	mov	r0, r5
}
   2c5ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	z_reschedule(&msgq->lock, key);
   2c5ee:	f000 bc0b 	b.w	2ce08 <z_reschedule>
   2c5f2:	671f      	str	r7, [r3, #112]	; 0x70
		z_ready_thread(pending_thread);
   2c5f4:	f000 fe2a 	bl	2d24c <z_ready_thread>
   2c5f8:	e7ed      	b.n	2c5d6 <z_impl_k_msgq_purge+0x46>
   2c5fa:	bf00      	nop
   2c5fc:	0003c751 	.word	0x0003c751
   2c600:	0003c777 	.word	0x0003c777
   2c604:	0003b77f 	.word	0x0003b77f
   2c608:	0003c78c 	.word	0x0003c78c

0002c60c <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
   2c60c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2c60e:	4604      	mov	r4, r0
   2c610:	460e      	mov	r6, r1
   2c612:	f04f 0320 	mov.w	r3, #32
   2c616:	f3ef 8511 	mrs	r5, BASEPRI
   2c61a:	f383 8811 	msr	BASEPRI, r3
   2c61e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c622:	4861      	ldr	r0, [pc, #388]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c624:	f001 ff5c 	bl	2e4e0 <z_spin_lock_valid>
   2c628:	b968      	cbnz	r0, 2c646 <z_impl_k_mutex_lock+0x3a>
   2c62a:	235c      	movs	r3, #92	; 0x5c
   2c62c:	4a5f      	ldr	r2, [pc, #380]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c62e:	4960      	ldr	r1, [pc, #384]	; (2c7b0 <z_impl_k_mutex_lock+0x1a4>)
   2c630:	4860      	ldr	r0, [pc, #384]	; (2c7b4 <z_impl_k_mutex_lock+0x1a8>)
   2c632:	f006 ffc9 	bl	335c8 <printk>
   2c636:	495c      	ldr	r1, [pc, #368]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c638:	485f      	ldr	r0, [pc, #380]	; (2c7b8 <z_impl_k_mutex_lock+0x1ac>)
   2c63a:	f006 ffc5 	bl	335c8 <printk>
   2c63e:	215c      	movs	r1, #92	; 0x5c
   2c640:	485a      	ldr	r0, [pc, #360]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c642:	f007 fac2 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c646:	4858      	ldr	r0, [pc, #352]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c648:	f001 ff68 	bl	2e51c <z_spin_lock_set_owner>
	bool resched = false;

	sys_trace_void(SYS_TRACE_ID_MUTEX_LOCK);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
   2c64c:	68e3      	ldr	r3, [r4, #12]
   2c64e:	4a5b      	ldr	r2, [pc, #364]	; (2c7bc <z_impl_k_mutex_lock+0x1b0>)
   2c650:	b1f3      	cbz	r3, 2c690 <z_impl_k_mutex_lock+0x84>
   2c652:	68a0      	ldr	r0, [r4, #8]
   2c654:	6891      	ldr	r1, [r2, #8]
   2c656:	4288      	cmp	r0, r1
   2c658:	d03a      	beq.n	2c6d0 <z_impl_k_mutex_lock+0xc4>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
   2c65a:	2e00      	cmp	r6, #0
   2c65c:	d13a      	bne.n	2c6d4 <z_impl_k_mutex_lock+0xc8>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c65e:	4852      	ldr	r0, [pc, #328]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c660:	f001 ff4c 	bl	2e4fc <z_spin_unlock_valid>
   2c664:	b968      	cbnz	r0, 2c682 <z_impl_k_mutex_lock+0x76>
   2c666:	2384      	movs	r3, #132	; 0x84
   2c668:	4a50      	ldr	r2, [pc, #320]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c66a:	4955      	ldr	r1, [pc, #340]	; (2c7c0 <z_impl_k_mutex_lock+0x1b4>)
   2c66c:	4851      	ldr	r0, [pc, #324]	; (2c7b4 <z_impl_k_mutex_lock+0x1a8>)
   2c66e:	f006 ffab 	bl	335c8 <printk>
   2c672:	494d      	ldr	r1, [pc, #308]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c674:	4853      	ldr	r0, [pc, #332]	; (2c7c4 <z_impl_k_mutex_lock+0x1b8>)
   2c676:	f006 ffa7 	bl	335c8 <printk>
   2c67a:	2184      	movs	r1, #132	; 0x84
   2c67c:	484b      	ldr	r0, [pc, #300]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c67e:	f007 faa4 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c682:	f385 8811 	msr	BASEPRI, r5
   2c686:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
   2c68a:	f06f 000f 	mvn.w	r0, #15
   2c68e:	e01e      	b.n	2c6ce <z_impl_k_mutex_lock+0xc2>
					_current->base.prio :
   2c690:	6891      	ldr	r1, [r2, #8]
   2c692:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
   2c696:	3301      	adds	r3, #1
   2c698:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
   2c69a:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
   2c69c:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
   2c69e:	60a3      	str	r3, [r4, #8]
   2c6a0:	4841      	ldr	r0, [pc, #260]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c6a2:	f001 ff2b 	bl	2e4fc <z_spin_unlock_valid>
   2c6a6:	b968      	cbnz	r0, 2c6c4 <z_impl_k_mutex_lock+0xb8>
   2c6a8:	2384      	movs	r3, #132	; 0x84
   2c6aa:	4a40      	ldr	r2, [pc, #256]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c6ac:	4944      	ldr	r1, [pc, #272]	; (2c7c0 <z_impl_k_mutex_lock+0x1b4>)
   2c6ae:	4841      	ldr	r0, [pc, #260]	; (2c7b4 <z_impl_k_mutex_lock+0x1a8>)
   2c6b0:	f006 ff8a 	bl	335c8 <printk>
   2c6b4:	493c      	ldr	r1, [pc, #240]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c6b6:	4843      	ldr	r0, [pc, #268]	; (2c7c4 <z_impl_k_mutex_lock+0x1b8>)
   2c6b8:	f006 ff86 	bl	335c8 <printk>
   2c6bc:	2184      	movs	r1, #132	; 0x84
   2c6be:	483b      	ldr	r0, [pc, #236]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c6c0:	f007 fa83 	bl	33bca <assert_post_action>
   2c6c4:	f385 8811 	msr	BASEPRI, r5
   2c6c8:	f3bf 8f6f 	isb	sy
		return 0;
   2c6cc:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
   2c6ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					_current->base.prio :
   2c6d0:	6921      	ldr	r1, [r4, #16]
   2c6d2:	e7e0      	b.n	2c696 <z_impl_k_mutex_lock+0x8a>
	new_prio = new_prio_for_inheritance(_current->base.prio,
   2c6d4:	f990 300e 	ldrsb.w	r3, [r0, #14]
   2c6d8:	f991 100e 	ldrsb.w	r1, [r1, #14]
   2c6dc:	4299      	cmp	r1, r3
   2c6de:	bfa8      	it	ge
   2c6e0:	4619      	movge	r1, r3
   2c6e2:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
   2c6e6:	4299      	cmp	r1, r3
   2c6e8:	da40      	bge.n	2c76c <z_impl_k_mutex_lock+0x160>
		return z_set_prio(mutex->owner, new_prio);
   2c6ea:	f001 f9cf 	bl	2da8c <z_set_prio>
   2c6ee:	4607      	mov	r7, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
   2c6f0:	4633      	mov	r3, r6
   2c6f2:	4622      	mov	r2, r4
   2c6f4:	4629      	mov	r1, r5
   2c6f6:	482c      	ldr	r0, [pc, #176]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c6f8:	f001 f99a 	bl	2da30 <z_pend_curr>
	if (got_mutex == 0) {
   2c6fc:	2800      	cmp	r0, #0
   2c6fe:	d0e6      	beq.n	2c6ce <z_impl_k_mutex_lock+0xc2>
	__asm__ volatile(
   2c700:	f04f 0320 	mov.w	r3, #32
   2c704:	f3ef 8511 	mrs	r5, BASEPRI
   2c708:	f383 8811 	msr	BASEPRI, r3
   2c70c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c710:	4825      	ldr	r0, [pc, #148]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c712:	f001 fee5 	bl	2e4e0 <z_spin_lock_valid>
   2c716:	b968      	cbnz	r0, 2c734 <z_impl_k_mutex_lock+0x128>
   2c718:	235c      	movs	r3, #92	; 0x5c
   2c71a:	4a24      	ldr	r2, [pc, #144]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c71c:	4924      	ldr	r1, [pc, #144]	; (2c7b0 <z_impl_k_mutex_lock+0x1a4>)
   2c71e:	4825      	ldr	r0, [pc, #148]	; (2c7b4 <z_impl_k_mutex_lock+0x1a8>)
   2c720:	f006 ff52 	bl	335c8 <printk>
   2c724:	4920      	ldr	r1, [pc, #128]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c726:	4824      	ldr	r0, [pc, #144]	; (2c7b8 <z_impl_k_mutex_lock+0x1ac>)
   2c728:	f006 ff4e 	bl	335c8 <printk>
   2c72c:	215c      	movs	r1, #92	; 0x5c
   2c72e:	481f      	ldr	r0, [pc, #124]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c730:	f007 fa4b 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c734:	481c      	ldr	r0, [pc, #112]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c736:	f001 fef1 	bl	2e51c <z_spin_lock_set_owner>
	return list->head == list;
   2c73a:	6823      	ldr	r3, [r4, #0]
   2c73c:	6921      	ldr	r1, [r4, #16]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2c73e:	429c      	cmp	r4, r3
   2c740:	d007      	beq.n	2c752 <z_impl_k_mutex_lock+0x146>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
   2c742:	b133      	cbz	r3, 2c752 <z_impl_k_mutex_lock+0x146>
   2c744:	f993 300e 	ldrsb.w	r3, [r3, #14]
   2c748:	4299      	cmp	r1, r3
   2c74a:	bfa8      	it	ge
   2c74c:	4619      	movge	r1, r3
   2c74e:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   2c752:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
   2c754:	f990 300e 	ldrsb.w	r3, [r0, #14]
   2c758:	4299      	cmp	r1, r3
   2c75a:	d109      	bne.n	2c770 <z_impl_k_mutex_lock+0x164>
	if (resched) {
   2c75c:	b16f      	cbz	r7, 2c77a <z_impl_k_mutex_lock+0x16e>
		z_reschedule(&lock, key);
   2c75e:	4629      	mov	r1, r5
   2c760:	4811      	ldr	r0, [pc, #68]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c762:	f000 fb51 	bl	2ce08 <z_reschedule>
	return -EAGAIN;
   2c766:	f06f 000a 	mvn.w	r0, #10
   2c76a:	e7b0      	b.n	2c6ce <z_impl_k_mutex_lock+0xc2>
	bool resched = false;
   2c76c:	2700      	movs	r7, #0
   2c76e:	e7bf      	b.n	2c6f0 <z_impl_k_mutex_lock+0xe4>
		return z_set_prio(mutex->owner, new_prio);
   2c770:	f001 f98c 	bl	2da8c <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
   2c774:	2800      	cmp	r0, #0
   2c776:	d1f2      	bne.n	2c75e <z_impl_k_mutex_lock+0x152>
   2c778:	e7f0      	b.n	2c75c <z_impl_k_mutex_lock+0x150>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c77a:	480b      	ldr	r0, [pc, #44]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c77c:	f001 febe 	bl	2e4fc <z_spin_unlock_valid>
   2c780:	b968      	cbnz	r0, 2c79e <z_impl_k_mutex_lock+0x192>
   2c782:	2384      	movs	r3, #132	; 0x84
   2c784:	4a09      	ldr	r2, [pc, #36]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c786:	490e      	ldr	r1, [pc, #56]	; (2c7c0 <z_impl_k_mutex_lock+0x1b4>)
   2c788:	480a      	ldr	r0, [pc, #40]	; (2c7b4 <z_impl_k_mutex_lock+0x1a8>)
   2c78a:	f006 ff1d 	bl	335c8 <printk>
   2c78e:	4906      	ldr	r1, [pc, #24]	; (2c7a8 <z_impl_k_mutex_lock+0x19c>)
   2c790:	480c      	ldr	r0, [pc, #48]	; (2c7c4 <z_impl_k_mutex_lock+0x1b8>)
   2c792:	f006 ff19 	bl	335c8 <printk>
   2c796:	2184      	movs	r1, #132	; 0x84
   2c798:	4804      	ldr	r0, [pc, #16]	; (2c7ac <z_impl_k_mutex_lock+0x1a0>)
   2c79a:	f007 fa16 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c79e:	f385 8811 	msr	BASEPRI, r5
   2c7a2:	f3bf 8f6f 	isb	sy
   2c7a6:	e7de      	b.n	2c766 <z_impl_k_mutex_lock+0x15a>
   2c7a8:	200274d8 	.word	0x200274d8
   2c7ac:	0003c751 	.word	0x0003c751
   2c7b0:	0003c777 	.word	0x0003c777
   2c7b4:	0003b77f 	.word	0x0003b77f
   2c7b8:	0003c78c 	.word	0x0003c78c
   2c7bc:	200274dc 	.word	0x200274dc
   2c7c0:	0003c7a4 	.word	0x0003c7a4
   2c7c4:	0003c7bb 	.word	0x0003c7bb

0002c7c8 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
   2c7c8:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	CHECKIF(mutex->owner == NULL) {
   2c7ca:	6883      	ldr	r3, [r0, #8]
{
   2c7cc:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
   2c7ce:	2b00      	cmp	r3, #0
   2c7d0:	f000 8091 	beq.w	2c8f6 <z_impl_k_mutex_unlock+0x12e>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
   2c7d4:	4d4b      	ldr	r5, [pc, #300]	; (2c904 <z_impl_k_mutex_unlock+0x13c>)
   2c7d6:	68aa      	ldr	r2, [r5, #8]
   2c7d8:	4293      	cmp	r3, r2
   2c7da:	f040 808f 	bne.w	2c8fc <z_impl_k_mutex_unlock+0x134>
	 * Attempt to unlock a mutex which is unlocked. mutex->lock_count
	 * cannot be zero if the current thread is equal to mutex->owner,
	 * therefore no underflow check is required. Use assert to catch
	 * undefined behavior.
	 */
	__ASSERT_NO_MSG(mutex->lock_count > 0U);
   2c7de:	68c3      	ldr	r3, [r0, #12]
   2c7e0:	b94b      	cbnz	r3, 2c7f6 <z_impl_k_mutex_unlock+0x2e>
   2c7e2:	4949      	ldr	r1, [pc, #292]	; (2c908 <z_impl_k_mutex_unlock+0x140>)
   2c7e4:	4849      	ldr	r0, [pc, #292]	; (2c90c <z_impl_k_mutex_unlock+0x144>)
   2c7e6:	23e6      	movs	r3, #230	; 0xe6
   2c7e8:	4a49      	ldr	r2, [pc, #292]	; (2c910 <z_impl_k_mutex_unlock+0x148>)
   2c7ea:	f006 feed 	bl	335c8 <printk>
   2c7ee:	21e6      	movs	r1, #230	; 0xe6
   2c7f0:	4847      	ldr	r0, [pc, #284]	; (2c910 <z_impl_k_mutex_unlock+0x148>)
   2c7f2:	f007 f9ea 	bl	33bca <assert_post_action>
   2c7f6:	f3ef 8305 	mrs	r3, IPSR
}

static inline void z_sched_lock(void)
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
   2c7fa:	b173      	cbz	r3, 2c81a <z_impl_k_mutex_unlock+0x52>
   2c7fc:	4945      	ldr	r1, [pc, #276]	; (2c914 <z_impl_k_mutex_unlock+0x14c>)
   2c7fe:	f240 130b 	movw	r3, #267	; 0x10b
   2c802:	4a45      	ldr	r2, [pc, #276]	; (2c918 <z_impl_k_mutex_unlock+0x150>)
   2c804:	4841      	ldr	r0, [pc, #260]	; (2c90c <z_impl_k_mutex_unlock+0x144>)
   2c806:	f006 fedf 	bl	335c8 <printk>
   2c80a:	4844      	ldr	r0, [pc, #272]	; (2c91c <z_impl_k_mutex_unlock+0x154>)
   2c80c:	f006 fedc 	bl	335c8 <printk>
   2c810:	f240 110b 	movw	r1, #267	; 0x10b
   2c814:	4840      	ldr	r0, [pc, #256]	; (2c918 <z_impl_k_mutex_unlock+0x150>)
   2c816:	f007 f9d8 	bl	33bca <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   2c81a:	68ab      	ldr	r3, [r5, #8]
   2c81c:	7bdb      	ldrb	r3, [r3, #15]
   2c81e:	2b01      	cmp	r3, #1
   2c820:	d10e      	bne.n	2c840 <z_impl_k_mutex_unlock+0x78>
   2c822:	493f      	ldr	r1, [pc, #252]	; (2c920 <z_impl_k_mutex_unlock+0x158>)
   2c824:	f44f 7386 	mov.w	r3, #268	; 0x10c
   2c828:	4a3b      	ldr	r2, [pc, #236]	; (2c918 <z_impl_k_mutex_unlock+0x150>)
   2c82a:	4838      	ldr	r0, [pc, #224]	; (2c90c <z_impl_k_mutex_unlock+0x144>)
   2c82c:	f006 fecc 	bl	335c8 <printk>
   2c830:	483a      	ldr	r0, [pc, #232]	; (2c91c <z_impl_k_mutex_unlock+0x154>)
   2c832:	f006 fec9 	bl	335c8 <printk>
   2c836:	f44f 7186 	mov.w	r1, #268	; 0x10c
   2c83a:	4837      	ldr	r0, [pc, #220]	; (2c918 <z_impl_k_mutex_unlock+0x150>)
   2c83c:	f007 f9c5 	bl	33bca <assert_post_action>

	--_current->base.sched_locked;
   2c840:	68aa      	ldr	r2, [r5, #8]
   2c842:	7bd3      	ldrb	r3, [r2, #15]
   2c844:	3b01      	subs	r3, #1
   2c846:	73d3      	strb	r3, [r2, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
   2c848:	68e3      	ldr	r3, [r4, #12]
   2c84a:	2b01      	cmp	r3, #1
   2c84c:	d005      	beq.n	2c85a <z_impl_k_mutex_unlock+0x92>
		mutex->lock_count--;
   2c84e:	3b01      	subs	r3, #1
   2c850:	60e3      	str	r3, [r4, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
   2c852:	f000 fc35 	bl	2d0c0 <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
   2c856:	2000      	movs	r0, #0
}
   2c858:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
   2c85a:	f04f 0320 	mov.w	r3, #32
   2c85e:	f3ef 8511 	mrs	r5, BASEPRI
   2c862:	f383 8811 	msr	BASEPRI, r3
   2c866:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c86a:	482e      	ldr	r0, [pc, #184]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c86c:	f001 fe38 	bl	2e4e0 <z_spin_lock_valid>
   2c870:	b968      	cbnz	r0, 2c88e <z_impl_k_mutex_unlock+0xc6>
   2c872:	235c      	movs	r3, #92	; 0x5c
   2c874:	4a2c      	ldr	r2, [pc, #176]	; (2c928 <z_impl_k_mutex_unlock+0x160>)
   2c876:	492d      	ldr	r1, [pc, #180]	; (2c92c <z_impl_k_mutex_unlock+0x164>)
   2c878:	4824      	ldr	r0, [pc, #144]	; (2c90c <z_impl_k_mutex_unlock+0x144>)
   2c87a:	f006 fea5 	bl	335c8 <printk>
   2c87e:	4929      	ldr	r1, [pc, #164]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c880:	482b      	ldr	r0, [pc, #172]	; (2c930 <z_impl_k_mutex_unlock+0x168>)
   2c882:	f006 fea1 	bl	335c8 <printk>
   2c886:	215c      	movs	r1, #92	; 0x5c
   2c888:	4827      	ldr	r0, [pc, #156]	; (2c928 <z_impl_k_mutex_unlock+0x160>)
   2c88a:	f007 f99e 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c88e:	4825      	ldr	r0, [pc, #148]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c890:	f001 fe44 	bl	2e51c <z_spin_lock_set_owner>
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
   2c894:	68a0      	ldr	r0, [r4, #8]
   2c896:	6921      	ldr	r1, [r4, #16]
	if (mutex->owner->base.prio != new_prio) {
   2c898:	f990 300e 	ldrsb.w	r3, [r0, #14]
   2c89c:	4299      	cmp	r1, r3
   2c89e:	d001      	beq.n	2c8a4 <z_impl_k_mutex_unlock+0xdc>
		return z_set_prio(mutex->owner, new_prio);
   2c8a0:	f001 f8f4 	bl	2da8c <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
   2c8a4:	4620      	mov	r0, r4
   2c8a6:	f001 f981 	bl	2dbac <z_unpend_first_thread>
	mutex->owner = new_owner;
   2c8aa:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
   2c8ac:	b158      	cbz	r0, 2c8c6 <z_impl_k_mutex_unlock+0xfe>
		mutex->owner_orig_prio = new_owner->base.prio;
   2c8ae:	f990 200e 	ldrsb.w	r2, [r0, #14]
   2c8b2:	6122      	str	r2, [r4, #16]
   2c8b4:	2200      	movs	r2, #0
   2c8b6:	6702      	str	r2, [r0, #112]	; 0x70
		z_ready_thread(new_owner);
   2c8b8:	f000 fcc8 	bl	2d24c <z_ready_thread>
		z_reschedule(&lock, key);
   2c8bc:	4629      	mov	r1, r5
   2c8be:	4819      	ldr	r0, [pc, #100]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c8c0:	f000 faa2 	bl	2ce08 <z_reschedule>
   2c8c4:	e7c5      	b.n	2c852 <z_impl_k_mutex_unlock+0x8a>
		mutex->lock_count = 0U;
   2c8c6:	60e0      	str	r0, [r4, #12]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c8c8:	4816      	ldr	r0, [pc, #88]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c8ca:	f001 fe17 	bl	2e4fc <z_spin_unlock_valid>
   2c8ce:	b968      	cbnz	r0, 2c8ec <z_impl_k_mutex_unlock+0x124>
   2c8d0:	2384      	movs	r3, #132	; 0x84
   2c8d2:	4a15      	ldr	r2, [pc, #84]	; (2c928 <z_impl_k_mutex_unlock+0x160>)
   2c8d4:	4917      	ldr	r1, [pc, #92]	; (2c934 <z_impl_k_mutex_unlock+0x16c>)
   2c8d6:	480d      	ldr	r0, [pc, #52]	; (2c90c <z_impl_k_mutex_unlock+0x144>)
   2c8d8:	f006 fe76 	bl	335c8 <printk>
   2c8dc:	4911      	ldr	r1, [pc, #68]	; (2c924 <z_impl_k_mutex_unlock+0x15c>)
   2c8de:	4816      	ldr	r0, [pc, #88]	; (2c938 <z_impl_k_mutex_unlock+0x170>)
   2c8e0:	f006 fe72 	bl	335c8 <printk>
   2c8e4:	2184      	movs	r1, #132	; 0x84
   2c8e6:	4810      	ldr	r0, [pc, #64]	; (2c928 <z_impl_k_mutex_unlock+0x160>)
   2c8e8:	f007 f96f 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c8ec:	f385 8811 	msr	BASEPRI, r5
   2c8f0:	f3bf 8f6f 	isb	sy
   2c8f4:	e7ad      	b.n	2c852 <z_impl_k_mutex_unlock+0x8a>
		return -EINVAL;
   2c8f6:	f06f 0015 	mvn.w	r0, #21
   2c8fa:	e7ad      	b.n	2c858 <z_impl_k_mutex_unlock+0x90>
		return -EPERM;
   2c8fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   2c900:	e7aa      	b.n	2c858 <z_impl_k_mutex_unlock+0x90>
   2c902:	bf00      	nop
   2c904:	200274dc 	.word	0x200274dc
   2c908:	0003fc89 	.word	0x0003fc89
   2c90c:	0003b77f 	.word	0x0003b77f
   2c910:	0003fc67 	.word	0x0003fc67
   2c914:	0003fccb 	.word	0x0003fccb
   2c918:	0003fca0 	.word	0x0003fca0
   2c91c:	0003cb8b 	.word	0x0003cb8b
   2c920:	0003fcdd 	.word	0x0003fcdd
   2c924:	200274d8 	.word	0x200274d8
   2c928:	0003c751 	.word	0x0003c751
   2c92c:	0003c777 	.word	0x0003c777
   2c930:	0003c78c 	.word	0x0003c78c
   2c934:	0003c7a4 	.word	0x0003c7a4
   2c938:	0003c7bb 	.word	0x0003c7bb

0002c93c <queue_insert>:
#include <syscalls/k_queue_cancel_wait_mrsh.c>
#endif

static s32_t queue_insert(struct k_queue *queue, void *prev, void *data,
			  bool alloc)
{
   2c93c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2c940:	4604      	mov	r4, r0
   2c942:	460e      	mov	r6, r1
   2c944:	4690      	mov	r8, r2
   2c946:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2c948:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2c94c:	f04f 0320 	mov.w	r3, #32
   2c950:	f3ef 8711 	mrs	r7, BASEPRI
   2c954:	f383 8811 	msr	BASEPRI, r3
   2c958:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2c95c:	4628      	mov	r0, r5
   2c95e:	f001 fdbf 	bl	2e4e0 <z_spin_lock_valid>
   2c962:	b968      	cbnz	r0, 2c980 <queue_insert+0x44>
   2c964:	235c      	movs	r3, #92	; 0x5c
   2c966:	4a39      	ldr	r2, [pc, #228]	; (2ca4c <queue_insert+0x110>)
   2c968:	4939      	ldr	r1, [pc, #228]	; (2ca50 <queue_insert+0x114>)
   2c96a:	483a      	ldr	r0, [pc, #232]	; (2ca54 <queue_insert+0x118>)
   2c96c:	f006 fe2c 	bl	335c8 <printk>
   2c970:	4629      	mov	r1, r5
   2c972:	4839      	ldr	r0, [pc, #228]	; (2ca58 <queue_insert+0x11c>)
   2c974:	f006 fe28 	bl	335c8 <printk>
   2c978:	215c      	movs	r1, #92	; 0x5c
   2c97a:	4834      	ldr	r0, [pc, #208]	; (2ca4c <queue_insert+0x110>)
   2c97c:	f007 f925 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2c980:	4628      	mov	r0, r5
   2c982:	f001 fdcb 	bl	2e51c <z_spin_lock_set_owner>
	struct k_thread *first_pending_thread;

	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   2c986:	f104 000c 	add.w	r0, r4, #12
   2c98a:	f001 f90f 	bl	2dbac <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
   2c98e:	b158      	cbz	r0, 2c9a8 <queue_insert+0x6c>
   2c990:	2400      	movs	r4, #0
   2c992:	f8c0 8014 	str.w	r8, [r0, #20]
   2c996:	6704      	str	r4, [r0, #112]	; 0x70
	z_ready_thread(thread);
   2c998:	f000 fc58 	bl	2d24c <z_ready_thread>
		sys_sfnode_init(data, 0x0);
	}

	sys_sflist_insert(&queue->data_q, prev, data);
	handle_poll_events(queue, K_POLL_STATE_DATA_AVAILABLE);
	z_reschedule(&queue->lock, key);
   2c99c:	4628      	mov	r0, r5
   2c99e:	4639      	mov	r1, r7
   2c9a0:	f000 fa32 	bl	2ce08 <z_reschedule>
	return 0;
   2c9a4:	2000      	movs	r0, #0
   2c9a6:	e01e      	b.n	2c9e6 <queue_insert+0xaa>
	if (alloc) {
   2c9a8:	f1b9 0f00 	cmp.w	r9, #0
   2c9ac:	d02d      	beq.n	2ca0a <queue_insert+0xce>
		anode = z_thread_malloc(sizeof(*anode));
   2c9ae:	2008      	movs	r0, #8
   2c9b0:	f7ff fc98 	bl	2c2e4 <z_thread_malloc>
		if (anode == NULL) {
   2c9b4:	b9c8      	cbnz	r0, 2c9ea <queue_insert+0xae>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2c9b6:	4628      	mov	r0, r5
   2c9b8:	f001 fda0 	bl	2e4fc <z_spin_unlock_valid>
   2c9bc:	b968      	cbnz	r0, 2c9da <queue_insert+0x9e>
   2c9be:	2384      	movs	r3, #132	; 0x84
   2c9c0:	4a22      	ldr	r2, [pc, #136]	; (2ca4c <queue_insert+0x110>)
   2c9c2:	4926      	ldr	r1, [pc, #152]	; (2ca5c <queue_insert+0x120>)
   2c9c4:	4823      	ldr	r0, [pc, #140]	; (2ca54 <queue_insert+0x118>)
   2c9c6:	f006 fdff 	bl	335c8 <printk>
   2c9ca:	4629      	mov	r1, r5
   2c9cc:	4824      	ldr	r0, [pc, #144]	; (2ca60 <queue_insert+0x124>)
   2c9ce:	f006 fdfb 	bl	335c8 <printk>
   2c9d2:	2184      	movs	r1, #132	; 0x84
   2c9d4:	481d      	ldr	r0, [pc, #116]	; (2ca4c <queue_insert+0x110>)
   2c9d6:	f007 f8f8 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2c9da:	f387 8811 	msr	BASEPRI, r7
   2c9de:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
   2c9e2:	f06f 000b 	mvn.w	r0, #11
}
   2c9e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 * @param flags A value between 0 and 3 to set the flags value
 */
static inline void sys_sfnode_init(sys_sfnode_t *node, u8_t flags)
{
	__ASSERT((flags & ~SYS_SFLIST_FLAGS_MASK) == 0UL, "flags too large");
	node->next_and_flags = flags;
   2c9ea:	2301      	movs	r3, #1
		anode->data = data;
   2c9ec:	f8c0 8004 	str.w	r8, [r0, #4]
   2c9f0:	6003      	str	r3, [r0, #0]
 */
static inline void sys_sflist_insert(sys_sflist_t *list,
				     sys_sfnode_t *prev,
				     sys_sfnode_t *node);

Z_GENLIST_INSERT(sflist, sfnode)
   2c9f2:	6803      	ldr	r3, [r0, #0]
   2c9f4:	f003 0303 	and.w	r3, r3, #3
   2c9f8:	b95e      	cbnz	r6, 2ca12 <queue_insert+0xd6>
	parent->next_and_flags = cur_flags | (unative_t)child;
   2c9fa:	6822      	ldr	r2, [r4, #0]
   2c9fc:	4313      	orrs	r3, r2
   2c9fe:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2ca00:	6863      	ldr	r3, [r4, #4]
	list->head = node;
   2ca02:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
   2ca04:	b973      	cbnz	r3, 2ca24 <queue_insert+0xe8>
	list->tail = node;
   2ca06:	6060      	str	r0, [r4, #4]
   2ca08:	e00c      	b.n	2ca24 <queue_insert+0xe8>
	node->next_and_flags = flags;
   2ca0a:	f8c8 9000 	str.w	r9, [r8]
   2ca0e:	4640      	mov	r0, r8
   2ca10:	e7ef      	b.n	2c9f2 <queue_insert+0xb6>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2ca12:	6832      	ldr	r2, [r6, #0]
Z_GENLIST_INSERT(sflist, sfnode)
   2ca14:	f032 0203 	bics.w	r2, r2, #3
   2ca18:	d110      	bne.n	2ca3c <queue_insert+0x100>
Z_GENLIST_APPEND(sflist, sfnode)
   2ca1a:	6862      	ldr	r2, [r4, #4]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2ca1c:	6003      	str	r3, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
   2ca1e:	b93a      	cbnz	r2, 2ca30 <queue_insert+0xf4>
	list->head = node;
   2ca20:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
   2ca24:	2104      	movs	r1, #4
   2ca26:	f104 0014 	add.w	r0, r4, #20
   2ca2a:	f00c faa6 	bl	38f7a <z_handle_obj_poll_events>
   2ca2e:	e7b5      	b.n	2c99c <queue_insert+0x60>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2ca30:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2ca32:	f003 0303 	and.w	r3, r3, #3
   2ca36:	4303      	orrs	r3, r0
   2ca38:	6013      	str	r3, [r2, #0]
   2ca3a:	e7e4      	b.n	2ca06 <queue_insert+0xca>
   2ca3c:	4313      	orrs	r3, r2
   2ca3e:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   2ca40:	6833      	ldr	r3, [r6, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   2ca42:	f003 0303 	and.w	r3, r3, #3
   2ca46:	4318      	orrs	r0, r3
   2ca48:	6030      	str	r0, [r6, #0]
   2ca4a:	e7eb      	b.n	2ca24 <queue_insert+0xe8>
   2ca4c:	0003c751 	.word	0x0003c751
   2ca50:	0003c777 	.word	0x0003c777
   2ca54:	0003b77f 	.word	0x0003b77f
   2ca58:	0003c78c 	.word	0x0003c78c
   2ca5c:	0003c7a4 	.word	0x0003c7a4
   2ca60:	0003c7bb 	.word	0x0003c7bb

0002ca64 <z_impl_k_queue_cancel_wait>:
{
   2ca64:	b570      	push	{r4, r5, r6, lr}
   2ca66:	4605      	mov	r5, r0
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2ca68:	f100 0408 	add.w	r4, r0, #8
	__asm__ volatile(
   2ca6c:	f04f 0320 	mov.w	r3, #32
   2ca70:	f3ef 8611 	mrs	r6, BASEPRI
   2ca74:	f383 8811 	msr	BASEPRI, r3
   2ca78:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2ca7c:	4620      	mov	r0, r4
   2ca7e:	f001 fd2f 	bl	2e4e0 <z_spin_lock_valid>
   2ca82:	b968      	cbnz	r0, 2caa0 <z_impl_k_queue_cancel_wait+0x3c>
   2ca84:	235c      	movs	r3, #92	; 0x5c
   2ca86:	4a12      	ldr	r2, [pc, #72]	; (2cad0 <z_impl_k_queue_cancel_wait+0x6c>)
   2ca88:	4912      	ldr	r1, [pc, #72]	; (2cad4 <z_impl_k_queue_cancel_wait+0x70>)
   2ca8a:	4813      	ldr	r0, [pc, #76]	; (2cad8 <z_impl_k_queue_cancel_wait+0x74>)
   2ca8c:	f006 fd9c 	bl	335c8 <printk>
   2ca90:	4621      	mov	r1, r4
   2ca92:	4812      	ldr	r0, [pc, #72]	; (2cadc <z_impl_k_queue_cancel_wait+0x78>)
   2ca94:	f006 fd98 	bl	335c8 <printk>
   2ca98:	215c      	movs	r1, #92	; 0x5c
   2ca9a:	480d      	ldr	r0, [pc, #52]	; (2cad0 <z_impl_k_queue_cancel_wait+0x6c>)
   2ca9c:	f007 f895 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2caa0:	4620      	mov	r0, r4
   2caa2:	f001 fd3b 	bl	2e51c <z_spin_lock_set_owner>
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
   2caa6:	f105 000c 	add.w	r0, r5, #12
   2caaa:	f001 f87f 	bl	2dbac <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
   2caae:	b120      	cbz	r0, 2caba <z_impl_k_queue_cancel_wait+0x56>
   2cab0:	2200      	movs	r2, #0
   2cab2:	6702      	str	r2, [r0, #112]	; 0x70
   2cab4:	6142      	str	r2, [r0, #20]
	z_ready_thread(thread);
   2cab6:	f000 fbc9 	bl	2d24c <z_ready_thread>
	z_handle_obj_poll_events(&queue->poll_events, state);
   2caba:	f105 0014 	add.w	r0, r5, #20
   2cabe:	2108      	movs	r1, #8
   2cac0:	f00c fa5b 	bl	38f7a <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
   2cac4:	4631      	mov	r1, r6
   2cac6:	4620      	mov	r0, r4
}
   2cac8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_reschedule(&queue->lock, key);
   2cacc:	f000 b99c 	b.w	2ce08 <z_reschedule>
   2cad0:	0003c751 	.word	0x0003c751
   2cad4:	0003c777 	.word	0x0003c777
   2cad8:	0003b77f 	.word	0x0003b77f
   2cadc:	0003c78c 	.word	0x0003c78c

0002cae0 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
   2cae0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2cae4:	4606      	mov	r6, r0
   2cae6:	4688      	mov	r8, r1
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
   2cae8:	f100 0408 	add.w	r4, r0, #8
   2caec:	f04f 0320 	mov.w	r3, #32
   2caf0:	f3ef 8711 	mrs	r7, BASEPRI
   2caf4:	f383 8811 	msr	BASEPRI, r3
   2caf8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2cafc:	4620      	mov	r0, r4
   2cafe:	f001 fcef 	bl	2e4e0 <z_spin_lock_valid>
   2cb02:	b968      	cbnz	r0, 2cb20 <z_impl_k_queue_get+0x40>
   2cb04:	235c      	movs	r3, #92	; 0x5c
   2cb06:	4a24      	ldr	r2, [pc, #144]	; (2cb98 <z_impl_k_queue_get+0xb8>)
   2cb08:	4924      	ldr	r1, [pc, #144]	; (2cb9c <z_impl_k_queue_get+0xbc>)
   2cb0a:	4825      	ldr	r0, [pc, #148]	; (2cba0 <z_impl_k_queue_get+0xc0>)
   2cb0c:	f006 fd5c 	bl	335c8 <printk>
   2cb10:	4621      	mov	r1, r4
   2cb12:	4824      	ldr	r0, [pc, #144]	; (2cba4 <z_impl_k_queue_get+0xc4>)
   2cb14:	f006 fd58 	bl	335c8 <printk>
   2cb18:	215c      	movs	r1, #92	; 0x5c
   2cb1a:	481f      	ldr	r0, [pc, #124]	; (2cb98 <z_impl_k_queue_get+0xb8>)
   2cb1c:	f007 f855 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2cb20:	4620      	mov	r0, r4
   2cb22:	f001 fcfb 	bl	2e51c <z_spin_lock_set_owner>
Z_GENLIST_IS_EMPTY(sflist)
   2cb26:	6835      	ldr	r5, [r6, #0]
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
   2cb28:	b32d      	cbz	r5, 2cb76 <z_impl_k_queue_get+0x96>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2cb2a:	682b      	ldr	r3, [r5, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2cb2c:	6872      	ldr	r2, [r6, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   2cb2e:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
   2cb32:	4295      	cmp	r5, r2
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
   2cb34:	4628      	mov	r0, r5
	list->head = node;
   2cb36:	6033      	str	r3, [r6, #0]
	list->tail = node;
   2cb38:	bf08      	it	eq
   2cb3a:	6073      	streq	r3, [r6, #4]
   2cb3c:	2101      	movs	r1, #1
   2cb3e:	f00c f898 	bl	38c72 <z_queue_node_peek>
   2cb42:	4605      	mov	r5, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2cb44:	4620      	mov	r0, r4
   2cb46:	f001 fcd9 	bl	2e4fc <z_spin_unlock_valid>
   2cb4a:	b968      	cbnz	r0, 2cb68 <z_impl_k_queue_get+0x88>
   2cb4c:	2384      	movs	r3, #132	; 0x84
   2cb4e:	4a12      	ldr	r2, [pc, #72]	; (2cb98 <z_impl_k_queue_get+0xb8>)
   2cb50:	4915      	ldr	r1, [pc, #84]	; (2cba8 <z_impl_k_queue_get+0xc8>)
   2cb52:	4813      	ldr	r0, [pc, #76]	; (2cba0 <z_impl_k_queue_get+0xc0>)
   2cb54:	f006 fd38 	bl	335c8 <printk>
   2cb58:	4621      	mov	r1, r4
   2cb5a:	4814      	ldr	r0, [pc, #80]	; (2cbac <z_impl_k_queue_get+0xcc>)
   2cb5c:	f006 fd34 	bl	335c8 <printk>
   2cb60:	2184      	movs	r1, #132	; 0x84
   2cb62:	480d      	ldr	r0, [pc, #52]	; (2cb98 <z_impl_k_queue_get+0xb8>)
   2cb64:	f007 f831 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2cb68:	f387 8811 	msr	BASEPRI, r7
   2cb6c:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
   2cb70:	4628      	mov	r0, r5
   2cb72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2cb76:	f1b8 0f00 	cmp.w	r8, #0
   2cb7a:	d0e3      	beq.n	2cb44 <z_impl_k_queue_get+0x64>
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
   2cb7c:	4643      	mov	r3, r8
   2cb7e:	f106 020c 	add.w	r2, r6, #12
   2cb82:	4639      	mov	r1, r7
   2cb84:	4620      	mov	r0, r4
   2cb86:	f000 ff53 	bl	2da30 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
   2cb8a:	2800      	cmp	r0, #0
   2cb8c:	d1f0      	bne.n	2cb70 <z_impl_k_queue_get+0x90>
   2cb8e:	4b08      	ldr	r3, [pc, #32]	; (2cbb0 <z_impl_k_queue_get+0xd0>)
   2cb90:	689b      	ldr	r3, [r3, #8]
   2cb92:	695d      	ldr	r5, [r3, #20]
   2cb94:	e7ec      	b.n	2cb70 <z_impl_k_queue_get+0x90>
   2cb96:	bf00      	nop
   2cb98:	0003c751 	.word	0x0003c751
   2cb9c:	0003c777 	.word	0x0003c777
   2cba0:	0003b77f 	.word	0x0003b77f
   2cba4:	0003c78c 	.word	0x0003c78c
   2cba8:	0003c7a4 	.word	0x0003c7a4
   2cbac:	0003c7bb 	.word	0x0003c7bb
   2cbb0:	200274dc 	.word	0x200274dc

0002cbb4 <pended_on.isra.18>:
#include <syscalls/k_thread_resume_mrsh.c>
#endif

static _wait_q_t *pended_on(struct k_thread *thread)
{
	__ASSERT_NO_MSG(thread->base.pended_on);
   2cbb4:	6803      	ldr	r3, [r0, #0]
static _wait_q_t *pended_on(struct k_thread *thread)
   2cbb6:	b510      	push	{r4, lr}
   2cbb8:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread->base.pended_on);
   2cbba:	b95b      	cbnz	r3, 2cbd4 <pended_on.isra.18+0x20>
   2cbbc:	4906      	ldr	r1, [pc, #24]	; (2cbd8 <pended_on.isra.18+0x24>)
   2cbbe:	4807      	ldr	r0, [pc, #28]	; (2cbdc <pended_on.isra.18+0x28>)
   2cbc0:	f240 13d9 	movw	r3, #473	; 0x1d9
   2cbc4:	4a06      	ldr	r2, [pc, #24]	; (2cbe0 <pended_on.isra.18+0x2c>)
   2cbc6:	f006 fcff 	bl	335c8 <printk>
   2cbca:	f240 11d9 	movw	r1, #473	; 0x1d9
   2cbce:	4804      	ldr	r0, [pc, #16]	; (2cbe0 <pended_on.isra.18+0x2c>)
   2cbd0:	f006 fffb 	bl	33bca <assert_post_action>

	return thread->base.pended_on;
}
   2cbd4:	6820      	ldr	r0, [r4, #0]
   2cbd6:	bd10      	pop	{r4, pc}
   2cbd8:	0003fd5f 	.word	0x0003fd5f
   2cbdc:	0003b77f 	.word	0x0003b77f
   2cbe0:	0003fd3d 	.word	0x0003fd3d

0002cbe4 <z_reset_time_slice>:
{
   2cbe4:	b510      	push	{r4, lr}
	if (slice_time != 0) {
   2cbe6:	4c08      	ldr	r4, [pc, #32]	; (2cc08 <z_reset_time_slice+0x24>)
   2cbe8:	6823      	ldr	r3, [r4, #0]
   2cbea:	b15b      	cbz	r3, 2cc04 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
   2cbec:	f7ed fc38 	bl	1a460 <z_clock_elapsed>
   2cbf0:	6823      	ldr	r3, [r4, #0]
   2cbf2:	4a06      	ldr	r2, [pc, #24]	; (2cc0c <z_reset_time_slice+0x28>)
   2cbf4:	4418      	add	r0, r3
   2cbf6:	6110      	str	r0, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
   2cbf8:	2100      	movs	r1, #0
}
   2cbfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		z_set_timeout_expiry(slice_time, false);
   2cbfe:	4618      	mov	r0, r3
   2cc00:	f001 bf7a 	b.w	2eaf8 <z_set_timeout_expiry>
}
   2cc04:	bd10      	pop	{r4, pc}
   2cc06:	bf00      	nop
   2cc08:	2002751c 	.word	0x2002751c
   2cc0c:	200274dc 	.word	0x200274dc

0002cc10 <k_sched_time_slice_set>:
{
   2cc10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2cc12:	4607      	mov	r7, r0
   2cc14:	460d      	mov	r5, r1
	__asm__ volatile(
   2cc16:	f04f 0320 	mov.w	r3, #32
   2cc1a:	f3ef 8411 	mrs	r4, BASEPRI
   2cc1e:	f383 8811 	msr	BASEPRI, r3
   2cc22:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2cc26:	4820      	ldr	r0, [pc, #128]	; (2cca8 <k_sched_time_slice_set+0x98>)
   2cc28:	f001 fc5a 	bl	2e4e0 <z_spin_lock_valid>
   2cc2c:	b968      	cbnz	r0, 2cc4a <k_sched_time_slice_set+0x3a>
   2cc2e:	235c      	movs	r3, #92	; 0x5c
   2cc30:	4a1e      	ldr	r2, [pc, #120]	; (2ccac <k_sched_time_slice_set+0x9c>)
   2cc32:	491f      	ldr	r1, [pc, #124]	; (2ccb0 <k_sched_time_slice_set+0xa0>)
   2cc34:	481f      	ldr	r0, [pc, #124]	; (2ccb4 <k_sched_time_slice_set+0xa4>)
   2cc36:	f006 fcc7 	bl	335c8 <printk>
   2cc3a:	491b      	ldr	r1, [pc, #108]	; (2cca8 <k_sched_time_slice_set+0x98>)
   2cc3c:	481e      	ldr	r0, [pc, #120]	; (2ccb8 <k_sched_time_slice_set+0xa8>)
   2cc3e:	f006 fcc3 	bl	335c8 <printk>
   2cc42:	215c      	movs	r1, #92	; 0x5c
   2cc44:	4819      	ldr	r0, [pc, #100]	; (2ccac <k_sched_time_slice_set+0x9c>)
   2cc46:	f006 ffc0 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2cc4a:	4817      	ldr	r0, [pc, #92]	; (2cca8 <k_sched_time_slice_set+0x98>)
   2cc4c:	f001 fc66 	bl	2e51c <z_spin_lock_set_owner>
   2cc50:	f44f 4600 	mov.w	r6, #32768	; 0x8000
		_current_cpu->slice_ticks = 0;
   2cc54:	2200      	movs	r2, #0
   2cc56:	f240 30e7 	movw	r0, #999	; 0x3e7
   2cc5a:	2100      	movs	r1, #0
   2cc5c:	4b17      	ldr	r3, [pc, #92]	; (2ccbc <k_sched_time_slice_set+0xac>)
   2cc5e:	fbe6 0107 	umlal	r0, r1, r6, r7
   2cc62:	611a      	str	r2, [r3, #16]
   2cc64:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2cc68:	2300      	movs	r3, #0
   2cc6a:	f7e0 fd81 	bl	d770 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
   2cc6e:	4b14      	ldr	r3, [pc, #80]	; (2ccc0 <k_sched_time_slice_set+0xb0>)
   2cc70:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
   2cc72:	4b14      	ldr	r3, [pc, #80]	; (2ccc4 <k_sched_time_slice_set+0xb4>)
   2cc74:	601d      	str	r5, [r3, #0]
		z_reset_time_slice();
   2cc76:	f7ff ffb5 	bl	2cbe4 <z_reset_time_slice>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2cc7a:	480b      	ldr	r0, [pc, #44]	; (2cca8 <k_sched_time_slice_set+0x98>)
   2cc7c:	f001 fc3e 	bl	2e4fc <z_spin_unlock_valid>
   2cc80:	b968      	cbnz	r0, 2cc9e <k_sched_time_slice_set+0x8e>
   2cc82:	2384      	movs	r3, #132	; 0x84
   2cc84:	4a09      	ldr	r2, [pc, #36]	; (2ccac <k_sched_time_slice_set+0x9c>)
   2cc86:	4910      	ldr	r1, [pc, #64]	; (2ccc8 <k_sched_time_slice_set+0xb8>)
   2cc88:	480a      	ldr	r0, [pc, #40]	; (2ccb4 <k_sched_time_slice_set+0xa4>)
   2cc8a:	f006 fc9d 	bl	335c8 <printk>
   2cc8e:	4906      	ldr	r1, [pc, #24]	; (2cca8 <k_sched_time_slice_set+0x98>)
   2cc90:	480e      	ldr	r0, [pc, #56]	; (2cccc <k_sched_time_slice_set+0xbc>)
   2cc92:	f006 fc99 	bl	335c8 <printk>
   2cc96:	2184      	movs	r1, #132	; 0x84
   2cc98:	4804      	ldr	r0, [pc, #16]	; (2ccac <k_sched_time_slice_set+0x9c>)
   2cc9a:	f006 ff96 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2cc9e:	f384 8811 	msr	BASEPRI, r4
   2cca2:	f3bf 8f6f 	isb	sy
}
   2cca6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2cca8:	20027514 	.word	0x20027514
   2ccac:	0003c751 	.word	0x0003c751
   2ccb0:	0003c777 	.word	0x0003c777
   2ccb4:	0003b77f 	.word	0x0003b77f
   2ccb8:	0003c78c 	.word	0x0003c78c
   2ccbc:	200274dc 	.word	0x200274dc
   2ccc0:	2002751c 	.word	0x2002751c
   2ccc4:	20027518 	.word	0x20027518
   2ccc8:	0003c7a4 	.word	0x0003c7a4
   2cccc:	0003c7bb 	.word	0x0003c7bb

0002ccd0 <z_find_first_thread_to_unpend>:
	pend(thread, wait_q, timeout);
}

ALWAYS_INLINE struct k_thread *z_find_first_thread_to_unpend(_wait_q_t *wait_q,
						     struct k_thread *from)
{
   2ccd0:	b538      	push	{r3, r4, r5, lr}
   2ccd2:	4604      	mov	r4, r0
	__asm__ volatile(
   2ccd4:	f04f 0320 	mov.w	r3, #32
   2ccd8:	f3ef 8511 	mrs	r5, BASEPRI
   2ccdc:	f383 8811 	msr	BASEPRI, r3
   2cce0:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2cce4:	4818      	ldr	r0, [pc, #96]	; (2cd48 <z_find_first_thread_to_unpend+0x78>)
   2cce6:	f001 fbfb 	bl	2e4e0 <z_spin_lock_valid>
   2ccea:	b968      	cbnz	r0, 2cd08 <z_find_first_thread_to_unpend+0x38>
   2ccec:	235c      	movs	r3, #92	; 0x5c
   2ccee:	4a17      	ldr	r2, [pc, #92]	; (2cd4c <z_find_first_thread_to_unpend+0x7c>)
   2ccf0:	4917      	ldr	r1, [pc, #92]	; (2cd50 <z_find_first_thread_to_unpend+0x80>)
   2ccf2:	4818      	ldr	r0, [pc, #96]	; (2cd54 <z_find_first_thread_to_unpend+0x84>)
   2ccf4:	f006 fc68 	bl	335c8 <printk>
   2ccf8:	4913      	ldr	r1, [pc, #76]	; (2cd48 <z_find_first_thread_to_unpend+0x78>)
   2ccfa:	4817      	ldr	r0, [pc, #92]	; (2cd58 <z_find_first_thread_to_unpend+0x88>)
   2ccfc:	f006 fc64 	bl	335c8 <printk>
   2cd00:	215c      	movs	r1, #92	; 0x5c
   2cd02:	4812      	ldr	r0, [pc, #72]	; (2cd4c <z_find_first_thread_to_unpend+0x7c>)
   2cd04:	f006 ff61 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2cd08:	480f      	ldr	r0, [pc, #60]	; (2cd48 <z_find_first_thread_to_unpend+0x78>)
   2cd0a:	f001 fc07 	bl	2e51c <z_spin_lock_set_owner>
	ARG_UNUSED(from);

	struct k_thread *ret = NULL;

	LOCKED(&sched_spinlock) {
		ret = _priq_wait_best(&wait_q->waitq);
   2cd0e:	4620      	mov	r0, r4
   2cd10:	f00b fff1 	bl	38cf6 <z_priq_dumb_best>
   2cd14:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2cd16:	480c      	ldr	r0, [pc, #48]	; (2cd48 <z_find_first_thread_to_unpend+0x78>)
   2cd18:	f001 fbf0 	bl	2e4fc <z_spin_unlock_valid>
   2cd1c:	b968      	cbnz	r0, 2cd3a <z_find_first_thread_to_unpend+0x6a>
   2cd1e:	2384      	movs	r3, #132	; 0x84
   2cd20:	4a0a      	ldr	r2, [pc, #40]	; (2cd4c <z_find_first_thread_to_unpend+0x7c>)
   2cd22:	490e      	ldr	r1, [pc, #56]	; (2cd5c <z_find_first_thread_to_unpend+0x8c>)
   2cd24:	480b      	ldr	r0, [pc, #44]	; (2cd54 <z_find_first_thread_to_unpend+0x84>)
   2cd26:	f006 fc4f 	bl	335c8 <printk>
   2cd2a:	4907      	ldr	r1, [pc, #28]	; (2cd48 <z_find_first_thread_to_unpend+0x78>)
   2cd2c:	480c      	ldr	r0, [pc, #48]	; (2cd60 <z_find_first_thread_to_unpend+0x90>)
   2cd2e:	f006 fc4b 	bl	335c8 <printk>
   2cd32:	2184      	movs	r1, #132	; 0x84
   2cd34:	4805      	ldr	r0, [pc, #20]	; (2cd4c <z_find_first_thread_to_unpend+0x7c>)
   2cd36:	f006 ff48 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2cd3a:	f385 8811 	msr	BASEPRI, r5
   2cd3e:	f3bf 8f6f 	isb	sy
	}

	return ret;
}
   2cd42:	4620      	mov	r0, r4
   2cd44:	bd38      	pop	{r3, r4, r5, pc}
   2cd46:	bf00      	nop
   2cd48:	20027514 	.word	0x20027514
   2cd4c:	0003c751 	.word	0x0003c751
   2cd50:	0003c777 	.word	0x0003c777
   2cd54:	0003b77f 	.word	0x0003b77f
   2cd58:	0003c78c 	.word	0x0003c78c
   2cd5c:	0003c7a4 	.word	0x0003c7a4
   2cd60:	0003c7bb 	.word	0x0003c7bb

0002cd64 <z_unpend_thread_no_timeout>:

ALWAYS_INLINE void z_unpend_thread_no_timeout(struct k_thread *thread)
{
   2cd64:	b538      	push	{r3, r4, r5, lr}
   2cd66:	4604      	mov	r4, r0
	__asm__ volatile(
   2cd68:	f04f 0320 	mov.w	r3, #32
   2cd6c:	f3ef 8511 	mrs	r5, BASEPRI
   2cd70:	f383 8811 	msr	BASEPRI, r3
   2cd74:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2cd78:	481c      	ldr	r0, [pc, #112]	; (2cdec <z_unpend_thread_no_timeout+0x88>)
   2cd7a:	f001 fbb1 	bl	2e4e0 <z_spin_lock_valid>
   2cd7e:	b968      	cbnz	r0, 2cd9c <z_unpend_thread_no_timeout+0x38>
   2cd80:	235c      	movs	r3, #92	; 0x5c
   2cd82:	4a1b      	ldr	r2, [pc, #108]	; (2cdf0 <z_unpend_thread_no_timeout+0x8c>)
   2cd84:	491b      	ldr	r1, [pc, #108]	; (2cdf4 <z_unpend_thread_no_timeout+0x90>)
   2cd86:	481c      	ldr	r0, [pc, #112]	; (2cdf8 <z_unpend_thread_no_timeout+0x94>)
   2cd88:	f006 fc1e 	bl	335c8 <printk>
   2cd8c:	4917      	ldr	r1, [pc, #92]	; (2cdec <z_unpend_thread_no_timeout+0x88>)
   2cd8e:	481b      	ldr	r0, [pc, #108]	; (2cdfc <z_unpend_thread_no_timeout+0x98>)
   2cd90:	f006 fc1a 	bl	335c8 <printk>
   2cd94:	215c      	movs	r1, #92	; 0x5c
   2cd96:	4816      	ldr	r0, [pc, #88]	; (2cdf0 <z_unpend_thread_no_timeout+0x8c>)
   2cd98:	f006 ff17 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2cd9c:	4813      	ldr	r0, [pc, #76]	; (2cdec <z_unpend_thread_no_timeout+0x88>)
   2cd9e:	f001 fbbd 	bl	2e51c <z_spin_lock_set_owner>
	LOCKED(&sched_spinlock) {
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2cda2:	f104 0008 	add.w	r0, r4, #8
   2cda6:	f7ff ff05 	bl	2cbb4 <pended_on.isra.18>
   2cdaa:	4621      	mov	r1, r4
   2cdac:	f000 f8e0 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2cdb0:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2cdb2:	480e      	ldr	r0, [pc, #56]	; (2cdec <z_unpend_thread_no_timeout+0x88>)
   2cdb4:	f023 0302 	bic.w	r3, r3, #2
   2cdb8:	7363      	strb	r3, [r4, #13]
		z_mark_thread_as_not_pending(thread);
		thread->base.pended_on = NULL;
   2cdba:	2300      	movs	r3, #0
   2cdbc:	60a3      	str	r3, [r4, #8]
   2cdbe:	f001 fb9d 	bl	2e4fc <z_spin_unlock_valid>
   2cdc2:	b968      	cbnz	r0, 2cde0 <z_unpend_thread_no_timeout+0x7c>
   2cdc4:	2384      	movs	r3, #132	; 0x84
   2cdc6:	4a0a      	ldr	r2, [pc, #40]	; (2cdf0 <z_unpend_thread_no_timeout+0x8c>)
   2cdc8:	490d      	ldr	r1, [pc, #52]	; (2ce00 <z_unpend_thread_no_timeout+0x9c>)
   2cdca:	480b      	ldr	r0, [pc, #44]	; (2cdf8 <z_unpend_thread_no_timeout+0x94>)
   2cdcc:	f006 fbfc 	bl	335c8 <printk>
   2cdd0:	4906      	ldr	r1, [pc, #24]	; (2cdec <z_unpend_thread_no_timeout+0x88>)
   2cdd2:	480c      	ldr	r0, [pc, #48]	; (2ce04 <z_unpend_thread_no_timeout+0xa0>)
   2cdd4:	f006 fbf8 	bl	335c8 <printk>
   2cdd8:	2184      	movs	r1, #132	; 0x84
   2cdda:	4805      	ldr	r0, [pc, #20]	; (2cdf0 <z_unpend_thread_no_timeout+0x8c>)
   2cddc:	f006 fef5 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2cde0:	f385 8811 	msr	BASEPRI, r5
   2cde4:	f3bf 8f6f 	isb	sy
	}
}
   2cde8:	bd38      	pop	{r3, r4, r5, pc}
   2cdea:	bf00      	nop
   2cdec:	20027514 	.word	0x20027514
   2cdf0:	0003c751 	.word	0x0003c751
   2cdf4:	0003c777 	.word	0x0003c777
   2cdf8:	0003b77f 	.word	0x0003b77f
   2cdfc:	0003c78c 	.word	0x0003c78c
   2ce00:	0003c7a4 	.word	0x0003c7a4
   2ce04:	0003c7bb 	.word	0x0003c7bb

0002ce08 <z_reschedule>:

	return arch_irq_unlocked(key) && !arch_is_in_isr();
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
   2ce08:	b538      	push	{r3, r4, r5, lr}
   2ce0a:	4604      	mov	r4, r0
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   2ce0c:	460d      	mov	r5, r1
   2ce0e:	b9c1      	cbnz	r1, 2ce42 <z_reschedule+0x3a>
   2ce10:	f3ef 8305 	mrs	r3, IPSR
   2ce14:	b9ab      	cbnz	r3, 2ce42 <z_reschedule+0x3a>
 */
static ALWAYS_INLINE void k_spin_release(struct k_spinlock *l)
{
	ARG_UNUSED(l);
#ifdef CONFIG_SPIN_VALIDATE
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ce16:	f001 fb71 	bl	2e4fc <z_spin_unlock_valid>
   2ce1a:	b968      	cbnz	r0, 2ce38 <z_reschedule+0x30>
   2ce1c:	239b      	movs	r3, #155	; 0x9b
   2ce1e:	4a14      	ldr	r2, [pc, #80]	; (2ce70 <z_reschedule+0x68>)
   2ce20:	4914      	ldr	r1, [pc, #80]	; (2ce74 <z_reschedule+0x6c>)
   2ce22:	4815      	ldr	r0, [pc, #84]	; (2ce78 <z_reschedule+0x70>)
   2ce24:	f006 fbd0 	bl	335c8 <printk>
   2ce28:	4621      	mov	r1, r4
   2ce2a:	4814      	ldr	r0, [pc, #80]	; (2ce7c <z_reschedule+0x74>)
   2ce2c:	f006 fbcc 	bl	335c8 <printk>
   2ce30:	219b      	movs	r1, #155	; 0x9b
   2ce32:	480f      	ldr	r0, [pc, #60]	; (2ce70 <z_reschedule+0x68>)
   2ce34:	f006 fec9 	bl	33bca <assert_post_action>
	if (resched(key.key)) {
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
   2ce38:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	ret = arch_swap(key);
   2ce3c:	2000      	movs	r0, #0
   2ce3e:	f7ed be55 	b.w	1aaec <arch_swap>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ce42:	4620      	mov	r0, r4
   2ce44:	f001 fb5a 	bl	2e4fc <z_spin_unlock_valid>
   2ce48:	b968      	cbnz	r0, 2ce66 <z_reschedule+0x5e>
   2ce4a:	2384      	movs	r3, #132	; 0x84
   2ce4c:	4a08      	ldr	r2, [pc, #32]	; (2ce70 <z_reschedule+0x68>)
   2ce4e:	4909      	ldr	r1, [pc, #36]	; (2ce74 <z_reschedule+0x6c>)
   2ce50:	4809      	ldr	r0, [pc, #36]	; (2ce78 <z_reschedule+0x70>)
   2ce52:	f006 fbb9 	bl	335c8 <printk>
   2ce56:	4621      	mov	r1, r4
   2ce58:	4808      	ldr	r0, [pc, #32]	; (2ce7c <z_reschedule+0x74>)
   2ce5a:	f006 fbb5 	bl	335c8 <printk>
   2ce5e:	2184      	movs	r1, #132	; 0x84
   2ce60:	4803      	ldr	r0, [pc, #12]	; (2ce70 <z_reschedule+0x68>)
   2ce62:	f006 feb2 	bl	33bca <assert_post_action>
   2ce66:	f385 8811 	msr	BASEPRI, r5
   2ce6a:	f3bf 8f6f 	isb	sy
   2ce6e:	bd38      	pop	{r3, r4, r5, pc}
   2ce70:	0003c751 	.word	0x0003c751
   2ce74:	0003c7a4 	.word	0x0003c7a4
   2ce78:	0003b77f 	.word	0x0003b77f
   2ce7c:	0003c7bb 	.word	0x0003c7bb

0002ce80 <k_sched_lock>:
		irq_unlock(key);
	}
}

void k_sched_lock(void)
{
   2ce80:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2ce82:	f04f 0320 	mov.w	r3, #32
   2ce86:	f3ef 8511 	mrs	r5, BASEPRI
   2ce8a:	f383 8811 	msr	BASEPRI, r3
   2ce8e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2ce92:	482b      	ldr	r0, [pc, #172]	; (2cf40 <k_sched_lock+0xc0>)
   2ce94:	f001 fb24 	bl	2e4e0 <z_spin_lock_valid>
   2ce98:	b968      	cbnz	r0, 2ceb6 <k_sched_lock+0x36>
   2ce9a:	235c      	movs	r3, #92	; 0x5c
   2ce9c:	4a29      	ldr	r2, [pc, #164]	; (2cf44 <k_sched_lock+0xc4>)
   2ce9e:	492a      	ldr	r1, [pc, #168]	; (2cf48 <k_sched_lock+0xc8>)
   2cea0:	482a      	ldr	r0, [pc, #168]	; (2cf4c <k_sched_lock+0xcc>)
   2cea2:	f006 fb91 	bl	335c8 <printk>
   2cea6:	4926      	ldr	r1, [pc, #152]	; (2cf40 <k_sched_lock+0xc0>)
   2cea8:	4829      	ldr	r0, [pc, #164]	; (2cf50 <k_sched_lock+0xd0>)
   2ceaa:	f006 fb8d 	bl	335c8 <printk>
   2ceae:	215c      	movs	r1, #92	; 0x5c
   2ceb0:	4824      	ldr	r0, [pc, #144]	; (2cf44 <k_sched_lock+0xc4>)
   2ceb2:	f006 fe8a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2ceb6:	4822      	ldr	r0, [pc, #136]	; (2cf40 <k_sched_lock+0xc0>)
   2ceb8:	f001 fb30 	bl	2e51c <z_spin_lock_set_owner>
   2cebc:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   2cec0:	b173      	cbz	r3, 2cee0 <k_sched_lock+0x60>
   2cec2:	4924      	ldr	r1, [pc, #144]	; (2cf54 <k_sched_lock+0xd4>)
   2cec4:	f240 130b 	movw	r3, #267	; 0x10b
   2cec8:	4a23      	ldr	r2, [pc, #140]	; (2cf58 <k_sched_lock+0xd8>)
   2ceca:	4820      	ldr	r0, [pc, #128]	; (2cf4c <k_sched_lock+0xcc>)
   2cecc:	f006 fb7c 	bl	335c8 <printk>
   2ced0:	4822      	ldr	r0, [pc, #136]	; (2cf5c <k_sched_lock+0xdc>)
   2ced2:	f006 fb79 	bl	335c8 <printk>
   2ced6:	f240 110b 	movw	r1, #267	; 0x10b
   2ceda:	481f      	ldr	r0, [pc, #124]	; (2cf58 <k_sched_lock+0xd8>)
   2cedc:	f006 fe75 	bl	33bca <assert_post_action>
	__ASSERT(_current->base.sched_locked != 1, "");
   2cee0:	4c1f      	ldr	r4, [pc, #124]	; (2cf60 <k_sched_lock+0xe0>)
   2cee2:	68a2      	ldr	r2, [r4, #8]
   2cee4:	7bd2      	ldrb	r2, [r2, #15]
   2cee6:	2a01      	cmp	r2, #1
   2cee8:	d10e      	bne.n	2cf08 <k_sched_lock+0x88>
   2ceea:	491e      	ldr	r1, [pc, #120]	; (2cf64 <k_sched_lock+0xe4>)
   2ceec:	f44f 7386 	mov.w	r3, #268	; 0x10c
   2cef0:	4a19      	ldr	r2, [pc, #100]	; (2cf58 <k_sched_lock+0xd8>)
   2cef2:	4816      	ldr	r0, [pc, #88]	; (2cf4c <k_sched_lock+0xcc>)
   2cef4:	f006 fb68 	bl	335c8 <printk>
   2cef8:	4818      	ldr	r0, [pc, #96]	; (2cf5c <k_sched_lock+0xdc>)
   2cefa:	f006 fb65 	bl	335c8 <printk>
   2cefe:	f44f 7186 	mov.w	r1, #268	; 0x10c
   2cf02:	4815      	ldr	r0, [pc, #84]	; (2cf58 <k_sched_lock+0xd8>)
   2cf04:	f006 fe61 	bl	33bca <assert_post_action>
	--_current->base.sched_locked;
   2cf08:	68a2      	ldr	r2, [r4, #8]
   2cf0a:	7bd3      	ldrb	r3, [r2, #15]
   2cf0c:	3b01      	subs	r3, #1
   2cf0e:	73d3      	strb	r3, [r2, #15]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2cf10:	480b      	ldr	r0, [pc, #44]	; (2cf40 <k_sched_lock+0xc0>)
   2cf12:	f001 faf3 	bl	2e4fc <z_spin_unlock_valid>
   2cf16:	b968      	cbnz	r0, 2cf34 <k_sched_lock+0xb4>
   2cf18:	2384      	movs	r3, #132	; 0x84
   2cf1a:	4a0a      	ldr	r2, [pc, #40]	; (2cf44 <k_sched_lock+0xc4>)
   2cf1c:	4912      	ldr	r1, [pc, #72]	; (2cf68 <k_sched_lock+0xe8>)
   2cf1e:	480b      	ldr	r0, [pc, #44]	; (2cf4c <k_sched_lock+0xcc>)
   2cf20:	f006 fb52 	bl	335c8 <printk>
   2cf24:	4906      	ldr	r1, [pc, #24]	; (2cf40 <k_sched_lock+0xc0>)
   2cf26:	4811      	ldr	r0, [pc, #68]	; (2cf6c <k_sched_lock+0xec>)
   2cf28:	f006 fb4e 	bl	335c8 <printk>
   2cf2c:	2184      	movs	r1, #132	; 0x84
   2cf2e:	4805      	ldr	r0, [pc, #20]	; (2cf44 <k_sched_lock+0xc4>)
   2cf30:	f006 fe4b 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2cf34:	f385 8811 	msr	BASEPRI, r5
   2cf38:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
   2cf3c:	bd38      	pop	{r3, r4, r5, pc}
   2cf3e:	bf00      	nop
   2cf40:	20027514 	.word	0x20027514
   2cf44:	0003c751 	.word	0x0003c751
   2cf48:	0003c777 	.word	0x0003c777
   2cf4c:	0003b77f 	.word	0x0003b77f
   2cf50:	0003c78c 	.word	0x0003c78c
   2cf54:	0003fccb 	.word	0x0003fccb
   2cf58:	0003fca0 	.word	0x0003fca0
   2cf5c:	0003cb8b 	.word	0x0003cb8b
   2cf60:	200274dc 	.word	0x200274dc
   2cf64:	0003fcdd 	.word	0x0003fcdd
   2cf68:	0003c7a4 	.word	0x0003c7a4
   2cf6c:	0003c7bb 	.word	0x0003c7bb

0002cf70 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   2cf70:	4b11      	ldr	r3, [pc, #68]	; (2cfb8 <z_priq_dumb_remove+0x48>)
{
   2cf72:	b510      	push	{r4, lr}
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   2cf74:	f103 0228 	add.w	r2, r3, #40	; 0x28
   2cf78:	4282      	cmp	r2, r0
{
   2cf7a:	460c      	mov	r4, r1
	if (pq == &_kernel.ready_q.runq && thread == _current &&
   2cf7c:	d105      	bne.n	2cf8a <z_priq_dumb_remove+0x1a>
   2cf7e:	689b      	ldr	r3, [r3, #8]
   2cf80:	428b      	cmp	r3, r1
   2cf82:	d102      	bne.n	2cf8a <z_priq_dumb_remove+0x1a>
   2cf84:	7b4b      	ldrb	r3, [r1, #13]
   2cf86:	06db      	lsls	r3, r3, #27
   2cf88:	d115      	bne.n	2cfb6 <z_priq_dumb_remove+0x46>
	    z_is_thread_prevented_from_running(thread)) {
		return;
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2cf8a:	4b0c      	ldr	r3, [pc, #48]	; (2cfbc <z_priq_dumb_remove+0x4c>)
   2cf8c:	429c      	cmp	r4, r3
   2cf8e:	d10b      	bne.n	2cfa8 <z_priq_dumb_remove+0x38>
   2cf90:	490b      	ldr	r1, [pc, #44]	; (2cfc0 <z_priq_dumb_remove+0x50>)
   2cf92:	480c      	ldr	r0, [pc, #48]	; (2cfc4 <z_priq_dumb_remove+0x54>)
   2cf94:	f240 336b 	movw	r3, #875	; 0x36b
   2cf98:	4a0b      	ldr	r2, [pc, #44]	; (2cfc8 <z_priq_dumb_remove+0x58>)
   2cf9a:	f006 fb15 	bl	335c8 <printk>
   2cf9e:	f240 316b 	movw	r1, #875	; 0x36b
   2cfa2:	4809      	ldr	r0, [pc, #36]	; (2cfc8 <z_priq_dumb_remove+0x58>)
   2cfa4:	f006 fe11 	bl	33bca <assert_post_action>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
   2cfa8:	e9d4 3200 	ldrd	r3, r2, [r4]
   2cfac:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   2cfae:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2cfb0:	2300      	movs	r3, #0
	node->prev = NULL;
   2cfb2:	e9c4 3300 	strd	r3, r3, [r4]

	sys_dlist_remove(&thread->base.qnode_dlist);
}
   2cfb6:	bd10      	pop	{r4, pc}
   2cfb8:	200274dc 	.word	0x200274dc
   2cfbc:	20022b04 	.word	0x20022b04
   2cfc0:	0003fdb3 	.word	0x0003fdb3
   2cfc4:	0003b77f 	.word	0x0003b77f
   2cfc8:	0003fd3d 	.word	0x0003fd3d

0002cfcc <z_unpend_thread>:
{
   2cfcc:	b538      	push	{r3, r4, r5, lr}
   2cfce:	4604      	mov	r4, r0
	__asm__ volatile(
   2cfd0:	f04f 0320 	mov.w	r3, #32
   2cfd4:	f3ef 8511 	mrs	r5, BASEPRI
   2cfd8:	f383 8811 	msr	BASEPRI, r3
   2cfdc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2cfe0:	481e      	ldr	r0, [pc, #120]	; (2d05c <z_unpend_thread+0x90>)
   2cfe2:	f001 fa7d 	bl	2e4e0 <z_spin_lock_valid>
   2cfe6:	b968      	cbnz	r0, 2d004 <z_unpend_thread+0x38>
   2cfe8:	235c      	movs	r3, #92	; 0x5c
   2cfea:	4a1d      	ldr	r2, [pc, #116]	; (2d060 <z_unpend_thread+0x94>)
   2cfec:	491d      	ldr	r1, [pc, #116]	; (2d064 <z_unpend_thread+0x98>)
   2cfee:	481e      	ldr	r0, [pc, #120]	; (2d068 <z_unpend_thread+0x9c>)
   2cff0:	f006 faea 	bl	335c8 <printk>
   2cff4:	4919      	ldr	r1, [pc, #100]	; (2d05c <z_unpend_thread+0x90>)
   2cff6:	481d      	ldr	r0, [pc, #116]	; (2d06c <z_unpend_thread+0xa0>)
   2cff8:	f006 fae6 	bl	335c8 <printk>
   2cffc:	215c      	movs	r1, #92	; 0x5c
   2cffe:	4818      	ldr	r0, [pc, #96]	; (2d060 <z_unpend_thread+0x94>)
   2d000:	f006 fde3 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d004:	4815      	ldr	r0, [pc, #84]	; (2d05c <z_unpend_thread+0x90>)
   2d006:	f001 fa89 	bl	2e51c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d00a:	f104 0008 	add.w	r0, r4, #8
   2d00e:	f7ff fdd1 	bl	2cbb4 <pended_on.isra.18>
   2d012:	4621      	mov	r1, r4
   2d014:	f7ff ffac 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d018:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d01a:	4810      	ldr	r0, [pc, #64]	; (2d05c <z_unpend_thread+0x90>)
   2d01c:	f023 0302 	bic.w	r3, r3, #2
   2d020:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   2d022:	2300      	movs	r3, #0
   2d024:	60a3      	str	r3, [r4, #8]
   2d026:	f001 fa69 	bl	2e4fc <z_spin_unlock_valid>
   2d02a:	b968      	cbnz	r0, 2d048 <z_unpend_thread+0x7c>
   2d02c:	2384      	movs	r3, #132	; 0x84
   2d02e:	4a0c      	ldr	r2, [pc, #48]	; (2d060 <z_unpend_thread+0x94>)
   2d030:	490f      	ldr	r1, [pc, #60]	; (2d070 <z_unpend_thread+0xa4>)
   2d032:	480d      	ldr	r0, [pc, #52]	; (2d068 <z_unpend_thread+0x9c>)
   2d034:	f006 fac8 	bl	335c8 <printk>
   2d038:	4908      	ldr	r1, [pc, #32]	; (2d05c <z_unpend_thread+0x90>)
   2d03a:	480e      	ldr	r0, [pc, #56]	; (2d074 <z_unpend_thread+0xa8>)
   2d03c:	f006 fac4 	bl	335c8 <printk>
   2d040:	2184      	movs	r1, #132	; 0x84
   2d042:	4807      	ldr	r0, [pc, #28]	; (2d060 <z_unpend_thread+0x94>)
   2d044:	f006 fdc1 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d048:	f385 8811 	msr	BASEPRI, r5
   2d04c:	f3bf 8f6f 	isb	sy
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
   2d050:	f104 0018 	add.w	r0, r4, #24
}
   2d054:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2d058:	f001 bc6e 	b.w	2e938 <z_abort_timeout>
   2d05c:	20027514 	.word	0x20027514
   2d060:	0003c751 	.word	0x0003c751
   2d064:	0003c777 	.word	0x0003c777
   2d068:	0003b77f 	.word	0x0003b77f
   2d06c:	0003c78c 	.word	0x0003c78c
   2d070:	0003c7a4 	.word	0x0003c7a4
   2d074:	0003c7bb 	.word	0x0003c7bb

0002d078 <update_cache>:
{
   2d078:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   2d07a:	4c10      	ldr	r4, [pc, #64]	; (2d0bc <update_cache+0x44>)
{
   2d07c:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
   2d07e:	f104 0028 	add.w	r0, r4, #40	; 0x28
   2d082:	f00b fe38 	bl	38cf6 <z_priq_dumb_best>
   2d086:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
   2d088:	68a3      	ldr	r3, [r4, #8]
   2d08a:	7b59      	ldrb	r1, [r3, #13]
   2d08c:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
   2d08e:	bf44      	itt	mi
   2d090:	f041 0108 	orrmi.w	r1, r1, #8
   2d094:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
   2d096:	b905      	cbnz	r5, 2d09a <update_cache+0x22>
   2d098:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
   2d09a:	b94e      	cbnz	r6, 2d0b0 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
   2d09c:	7b5a      	ldrb	r2, [r3, #13]
   2d09e:	06d2      	lsls	r2, r2, #27
   2d0a0:	d106      	bne.n	2d0b0 <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
   2d0a2:	69aa      	ldr	r2, [r5, #24]
   2d0a4:	b922      	cbnz	r2, 2d0b0 <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
   2d0a6:	89da      	ldrh	r2, [r3, #14]
   2d0a8:	2a7f      	cmp	r2, #127	; 0x7f
   2d0aa:	d901      	bls.n	2d0b0 <update_cache+0x38>
		_kernel.ready_q.cache = _current;
   2d0ac:	6263      	str	r3, [r4, #36]	; 0x24
}
   2d0ae:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
   2d0b0:	42ab      	cmp	r3, r5
   2d0b2:	d001      	beq.n	2d0b8 <update_cache+0x40>
			z_reset_time_slice();
   2d0b4:	f7ff fd96 	bl	2cbe4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
   2d0b8:	6265      	str	r5, [r4, #36]	; 0x24
}
   2d0ba:	e7f8      	b.n	2d0ae <update_cache+0x36>
   2d0bc:	200274dc 	.word	0x200274dc

0002d0c0 <k_sched_unlock>:
{
   2d0c0:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2d0c2:	f04f 0320 	mov.w	r3, #32
   2d0c6:	f3ef 8511 	mrs	r5, BASEPRI
   2d0ca:	f383 8811 	msr	BASEPRI, r3
   2d0ce:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d0d2:	482d      	ldr	r0, [pc, #180]	; (2d188 <k_sched_unlock+0xc8>)
   2d0d4:	f001 fa04 	bl	2e4e0 <z_spin_lock_valid>
   2d0d8:	b968      	cbnz	r0, 2d0f6 <k_sched_unlock+0x36>
   2d0da:	235c      	movs	r3, #92	; 0x5c
   2d0dc:	4a2b      	ldr	r2, [pc, #172]	; (2d18c <k_sched_unlock+0xcc>)
   2d0de:	492c      	ldr	r1, [pc, #176]	; (2d190 <k_sched_unlock+0xd0>)
   2d0e0:	482c      	ldr	r0, [pc, #176]	; (2d194 <k_sched_unlock+0xd4>)
   2d0e2:	f006 fa71 	bl	335c8 <printk>
   2d0e6:	4928      	ldr	r1, [pc, #160]	; (2d188 <k_sched_unlock+0xc8>)
   2d0e8:	482b      	ldr	r0, [pc, #172]	; (2d198 <k_sched_unlock+0xd8>)
   2d0ea:	f006 fa6d 	bl	335c8 <printk>
   2d0ee:	215c      	movs	r1, #92	; 0x5c
   2d0f0:	4826      	ldr	r0, [pc, #152]	; (2d18c <k_sched_unlock+0xcc>)
   2d0f2:	f006 fd6a 	bl	33bca <assert_post_action>
		__ASSERT(_current->base.sched_locked != 0, "");
   2d0f6:	4c29      	ldr	r4, [pc, #164]	; (2d19c <k_sched_unlock+0xdc>)
	z_spin_lock_set_owner(l);
   2d0f8:	4823      	ldr	r0, [pc, #140]	; (2d188 <k_sched_unlock+0xc8>)
   2d0fa:	f001 fa0f 	bl	2e51c <z_spin_lock_set_owner>
   2d0fe:	68a2      	ldr	r2, [r4, #8]
   2d100:	7bd2      	ldrb	r2, [r2, #15]
   2d102:	b972      	cbnz	r2, 2d122 <k_sched_unlock+0x62>
   2d104:	4926      	ldr	r1, [pc, #152]	; (2d1a0 <k_sched_unlock+0xe0>)
   2d106:	f240 330a 	movw	r3, #778	; 0x30a
   2d10a:	4a26      	ldr	r2, [pc, #152]	; (2d1a4 <k_sched_unlock+0xe4>)
   2d10c:	4821      	ldr	r0, [pc, #132]	; (2d194 <k_sched_unlock+0xd4>)
   2d10e:	f006 fa5b 	bl	335c8 <printk>
   2d112:	4825      	ldr	r0, [pc, #148]	; (2d1a8 <k_sched_unlock+0xe8>)
   2d114:	f006 fa58 	bl	335c8 <printk>
   2d118:	f240 310a 	movw	r1, #778	; 0x30a
   2d11c:	4821      	ldr	r0, [pc, #132]	; (2d1a4 <k_sched_unlock+0xe4>)
   2d11e:	f006 fd54 	bl	33bca <assert_post_action>
   2d122:	f3ef 8305 	mrs	r3, IPSR
		__ASSERT(!arch_is_in_isr(), "");
   2d126:	b173      	cbz	r3, 2d146 <k_sched_unlock+0x86>
   2d128:	4920      	ldr	r1, [pc, #128]	; (2d1ac <k_sched_unlock+0xec>)
   2d12a:	f240 330b 	movw	r3, #779	; 0x30b
   2d12e:	4a1d      	ldr	r2, [pc, #116]	; (2d1a4 <k_sched_unlock+0xe4>)
   2d130:	4818      	ldr	r0, [pc, #96]	; (2d194 <k_sched_unlock+0xd4>)
   2d132:	f006 fa49 	bl	335c8 <printk>
   2d136:	481c      	ldr	r0, [pc, #112]	; (2d1a8 <k_sched_unlock+0xe8>)
   2d138:	f006 fa46 	bl	335c8 <printk>
   2d13c:	f240 310b 	movw	r1, #779	; 0x30b
   2d140:	4818      	ldr	r0, [pc, #96]	; (2d1a4 <k_sched_unlock+0xe4>)
   2d142:	f006 fd42 	bl	33bca <assert_post_action>
		++_current->base.sched_locked;
   2d146:	68a2      	ldr	r2, [r4, #8]
		update_cache(0);
   2d148:	2000      	movs	r0, #0
		++_current->base.sched_locked;
   2d14a:	7bd3      	ldrb	r3, [r2, #15]
   2d14c:	3301      	adds	r3, #1
   2d14e:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
   2d150:	f7ff ff92 	bl	2d078 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d154:	480c      	ldr	r0, [pc, #48]	; (2d188 <k_sched_unlock+0xc8>)
   2d156:	f001 f9d1 	bl	2e4fc <z_spin_unlock_valid>
   2d15a:	b968      	cbnz	r0, 2d178 <k_sched_unlock+0xb8>
   2d15c:	2384      	movs	r3, #132	; 0x84
   2d15e:	4a0b      	ldr	r2, [pc, #44]	; (2d18c <k_sched_unlock+0xcc>)
   2d160:	4913      	ldr	r1, [pc, #76]	; (2d1b0 <k_sched_unlock+0xf0>)
   2d162:	480c      	ldr	r0, [pc, #48]	; (2d194 <k_sched_unlock+0xd4>)
   2d164:	f006 fa30 	bl	335c8 <printk>
   2d168:	4907      	ldr	r1, [pc, #28]	; (2d188 <k_sched_unlock+0xc8>)
   2d16a:	4812      	ldr	r0, [pc, #72]	; (2d1b4 <k_sched_unlock+0xf4>)
   2d16c:	f006 fa2c 	bl	335c8 <printk>
   2d170:	2184      	movs	r1, #132	; 0x84
   2d172:	4806      	ldr	r0, [pc, #24]	; (2d18c <k_sched_unlock+0xcc>)
   2d174:	f006 fd29 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d178:	f385 8811 	msr	BASEPRI, r5
   2d17c:	f3bf 8f6f 	isb	sy
}
   2d180:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_unlocked();
   2d184:	f00b bdad 	b.w	38ce2 <z_reschedule_unlocked>
   2d188:	20027514 	.word	0x20027514
   2d18c:	0003c751 	.word	0x0003c751
   2d190:	0003c777 	.word	0x0003c777
   2d194:	0003b77f 	.word	0x0003b77f
   2d198:	0003c78c 	.word	0x0003c78c
   2d19c:	200274dc 	.word	0x200274dc
   2d1a0:	0003fd0d 	.word	0x0003fd0d
   2d1a4:	0003fd3d 	.word	0x0003fd3d
   2d1a8:	0003cb8b 	.word	0x0003cb8b
   2d1ac:	0003fccb 	.word	0x0003fccb
   2d1b0:	0003c7a4 	.word	0x0003c7a4
   2d1b4:	0003c7bb 	.word	0x0003c7bb

0002d1b8 <ready_thread>:
{
   2d1b8:	b570      	push	{r4, r5, r6, lr}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d1ba:	7b43      	ldrb	r3, [r0, #13]
   2d1bc:	4604      	mov	r4, r0
   2d1be:	06db      	lsls	r3, r3, #27
   2d1c0:	d138      	bne.n	2d234 <ready_thread+0x7c>
	if (z_is_thread_ready(thread)) {
   2d1c2:	6983      	ldr	r3, [r0, #24]
   2d1c4:	2b00      	cmp	r3, #0
   2d1c6:	d135      	bne.n	2d234 <ready_thread+0x7c>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2d1c8:	4b1b      	ldr	r3, [pc, #108]	; (2d238 <ready_thread+0x80>)
   2d1ca:	4298      	cmp	r0, r3
   2d1cc:	d10b      	bne.n	2d1e6 <ready_thread+0x2e>
   2d1ce:	491b      	ldr	r1, [pc, #108]	; (2d23c <ready_thread+0x84>)
   2d1d0:	481b      	ldr	r0, [pc, #108]	; (2d240 <ready_thread+0x88>)
   2d1d2:	f240 3355 	movw	r3, #853	; 0x355
   2d1d6:	4a1b      	ldr	r2, [pc, #108]	; (2d244 <ready_thread+0x8c>)
   2d1d8:	f006 f9f6 	bl	335c8 <printk>
   2d1dc:	f240 3155 	movw	r1, #853	; 0x355
   2d1e0:	4818      	ldr	r0, [pc, #96]	; (2d244 <ready_thread+0x8c>)
   2d1e2:	f006 fcf2 	bl	33bca <assert_post_action>
	return list->head == list;
   2d1e6:	4a18      	ldr	r2, [pc, #96]	; (2d248 <ready_thread+0x90>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d1e8:	f102 0128 	add.w	r1, r2, #40	; 0x28
   2d1ec:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   2d1f0:	428b      	cmp	r3, r1
   2d1f2:	d019      	beq.n	2d228 <ready_thread+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d1f4:	b1c3      	cbz	r3, 2d228 <ready_thread+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
   2d1f6:	f994 500e 	ldrsb.w	r5, [r4, #14]
   2d1fa:	f993 600e 	ldrsb.w	r6, [r3, #14]
   2d1fe:	42ae      	cmp	r6, r5
   2d200:	dd0d      	ble.n	2d21e <ready_thread+0x66>
	node->prev = successor->prev;
   2d202:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2d204:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   2d208:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2d20a:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   2d20c:	7b63      	ldrb	r3, [r4, #13]
		update_cache(0);
   2d20e:	2000      	movs	r0, #0
   2d210:	f063 037f 	orn	r3, r3, #127	; 0x7f
   2d214:	7363      	strb	r3, [r4, #13]
}
   2d216:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		update_cache(0);
   2d21a:	f7ff bf2d 	b.w	2d078 <update_cache>
	return (node == list->tail) ? NULL : node->next;
   2d21e:	4298      	cmp	r0, r3
   2d220:	d002      	beq.n	2d228 <ready_thread+0x70>
   2d222:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d224:	2b00      	cmp	r3, #0
   2d226:	d1e8      	bne.n	2d1fa <ready_thread+0x42>
	node->prev = list->tail;
   2d228:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   2d22c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2d22e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2d230:	62d4      	str	r4, [r2, #44]	; 0x2c
   2d232:	e7eb      	b.n	2d20c <ready_thread+0x54>
}
   2d234:	bd70      	pop	{r4, r5, r6, pc}
   2d236:	bf00      	nop
   2d238:	20022b04 	.word	0x20022b04
   2d23c:	0003fdb3 	.word	0x0003fdb3
   2d240:	0003b77f 	.word	0x0003b77f
   2d244:	0003fd3d 	.word	0x0003fd3d
   2d248:	200274dc 	.word	0x200274dc

0002d24c <z_ready_thread>:
{
   2d24c:	b538      	push	{r3, r4, r5, lr}
   2d24e:	4605      	mov	r5, r0
	__asm__ volatile(
   2d250:	f04f 0320 	mov.w	r3, #32
   2d254:	f3ef 8411 	mrs	r4, BASEPRI
   2d258:	f383 8811 	msr	BASEPRI, r3
   2d25c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d260:	4817      	ldr	r0, [pc, #92]	; (2d2c0 <z_ready_thread+0x74>)
   2d262:	f001 f93d 	bl	2e4e0 <z_spin_lock_valid>
   2d266:	b968      	cbnz	r0, 2d284 <z_ready_thread+0x38>
   2d268:	235c      	movs	r3, #92	; 0x5c
   2d26a:	4a16      	ldr	r2, [pc, #88]	; (2d2c4 <z_ready_thread+0x78>)
   2d26c:	4916      	ldr	r1, [pc, #88]	; (2d2c8 <z_ready_thread+0x7c>)
   2d26e:	4817      	ldr	r0, [pc, #92]	; (2d2cc <z_ready_thread+0x80>)
   2d270:	f006 f9aa 	bl	335c8 <printk>
   2d274:	4912      	ldr	r1, [pc, #72]	; (2d2c0 <z_ready_thread+0x74>)
   2d276:	4816      	ldr	r0, [pc, #88]	; (2d2d0 <z_ready_thread+0x84>)
   2d278:	f006 f9a6 	bl	335c8 <printk>
   2d27c:	215c      	movs	r1, #92	; 0x5c
   2d27e:	4811      	ldr	r0, [pc, #68]	; (2d2c4 <z_ready_thread+0x78>)
   2d280:	f006 fca3 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d284:	480e      	ldr	r0, [pc, #56]	; (2d2c0 <z_ready_thread+0x74>)
   2d286:	f001 f949 	bl	2e51c <z_spin_lock_set_owner>
		ready_thread(thread);
   2d28a:	4628      	mov	r0, r5
   2d28c:	f7ff ff94 	bl	2d1b8 <ready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d290:	480b      	ldr	r0, [pc, #44]	; (2d2c0 <z_ready_thread+0x74>)
   2d292:	f001 f933 	bl	2e4fc <z_spin_unlock_valid>
   2d296:	b968      	cbnz	r0, 2d2b4 <z_ready_thread+0x68>
   2d298:	2384      	movs	r3, #132	; 0x84
   2d29a:	4a0a      	ldr	r2, [pc, #40]	; (2d2c4 <z_ready_thread+0x78>)
   2d29c:	490d      	ldr	r1, [pc, #52]	; (2d2d4 <z_ready_thread+0x88>)
   2d29e:	480b      	ldr	r0, [pc, #44]	; (2d2cc <z_ready_thread+0x80>)
   2d2a0:	f006 f992 	bl	335c8 <printk>
   2d2a4:	4906      	ldr	r1, [pc, #24]	; (2d2c0 <z_ready_thread+0x74>)
   2d2a6:	480c      	ldr	r0, [pc, #48]	; (2d2d8 <z_ready_thread+0x8c>)
   2d2a8:	f006 f98e 	bl	335c8 <printk>
   2d2ac:	2184      	movs	r1, #132	; 0x84
   2d2ae:	4805      	ldr	r0, [pc, #20]	; (2d2c4 <z_ready_thread+0x78>)
   2d2b0:	f006 fc8b 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d2b4:	f384 8811 	msr	BASEPRI, r4
   2d2b8:	f3bf 8f6f 	isb	sy
}
   2d2bc:	bd38      	pop	{r3, r4, r5, pc}
   2d2be:	bf00      	nop
   2d2c0:	20027514 	.word	0x20027514
   2d2c4:	0003c751 	.word	0x0003c751
   2d2c8:	0003c777 	.word	0x0003c777
   2d2cc:	0003b77f 	.word	0x0003b77f
   2d2d0:	0003c78c 	.word	0x0003c78c
   2d2d4:	0003c7a4 	.word	0x0003c7a4
   2d2d8:	0003c7bb 	.word	0x0003c7bb

0002d2dc <z_thread_timeout>:
	if (thread->base.pended_on != NULL) {
   2d2dc:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
   2d2e0:	b570      	push	{r4, r5, r6, lr}
   2d2e2:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
   2d2e4:	f1a0 0518 	sub.w	r5, r0, #24
	if (thread->base.pended_on != NULL) {
   2d2e8:	2b00      	cmp	r3, #0
   2d2ea:	d042      	beq.n	2d372 <z_thread_timeout+0x96>
	__asm__ volatile(
   2d2ec:	f04f 0320 	mov.w	r3, #32
   2d2f0:	f3ef 8611 	mrs	r6, BASEPRI
   2d2f4:	f383 8811 	msr	BASEPRI, r3
   2d2f8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d2fc:	4822      	ldr	r0, [pc, #136]	; (2d388 <z_thread_timeout+0xac>)
   2d2fe:	f001 f8ef 	bl	2e4e0 <z_spin_lock_valid>
   2d302:	b968      	cbnz	r0, 2d320 <z_thread_timeout+0x44>
   2d304:	235c      	movs	r3, #92	; 0x5c
   2d306:	4a21      	ldr	r2, [pc, #132]	; (2d38c <z_thread_timeout+0xb0>)
   2d308:	4921      	ldr	r1, [pc, #132]	; (2d390 <z_thread_timeout+0xb4>)
   2d30a:	4822      	ldr	r0, [pc, #136]	; (2d394 <z_thread_timeout+0xb8>)
   2d30c:	f006 f95c 	bl	335c8 <printk>
   2d310:	491d      	ldr	r1, [pc, #116]	; (2d388 <z_thread_timeout+0xac>)
   2d312:	4821      	ldr	r0, [pc, #132]	; (2d398 <z_thread_timeout+0xbc>)
   2d314:	f006 f958 	bl	335c8 <printk>
   2d318:	215c      	movs	r1, #92	; 0x5c
   2d31a:	481c      	ldr	r0, [pc, #112]	; (2d38c <z_thread_timeout+0xb0>)
   2d31c:	f006 fc55 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d320:	4819      	ldr	r0, [pc, #100]	; (2d388 <z_thread_timeout+0xac>)
   2d322:	f001 f8fb 	bl	2e51c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2d326:	f1a4 0010 	sub.w	r0, r4, #16
   2d32a:	f7ff fc43 	bl	2cbb4 <pended_on.isra.18>
   2d32e:	4629      	mov	r1, r5
   2d330:	f7ff fe1e 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d334:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d338:	4813      	ldr	r0, [pc, #76]	; (2d388 <z_thread_timeout+0xac>)
   2d33a:	f023 0302 	bic.w	r3, r3, #2
   2d33e:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
   2d342:	2300      	movs	r3, #0
   2d344:	f844 3c10 	str.w	r3, [r4, #-16]
   2d348:	f001 f8d8 	bl	2e4fc <z_spin_unlock_valid>
   2d34c:	b968      	cbnz	r0, 2d36a <z_thread_timeout+0x8e>
   2d34e:	2384      	movs	r3, #132	; 0x84
   2d350:	4a0e      	ldr	r2, [pc, #56]	; (2d38c <z_thread_timeout+0xb0>)
   2d352:	4912      	ldr	r1, [pc, #72]	; (2d39c <z_thread_timeout+0xc0>)
   2d354:	480f      	ldr	r0, [pc, #60]	; (2d394 <z_thread_timeout+0xb8>)
   2d356:	f006 f937 	bl	335c8 <printk>
   2d35a:	490b      	ldr	r1, [pc, #44]	; (2d388 <z_thread_timeout+0xac>)
   2d35c:	4810      	ldr	r0, [pc, #64]	; (2d3a0 <z_thread_timeout+0xc4>)
   2d35e:	f006 f933 	bl	335c8 <printk>
   2d362:	2184      	movs	r1, #132	; 0x84
   2d364:	4809      	ldr	r0, [pc, #36]	; (2d38c <z_thread_timeout+0xb0>)
   2d366:	f006 fc30 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d36a:	f386 8811 	msr	BASEPRI, r6
   2d36e:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   2d372:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	z_ready_thread(thread);
   2d376:	4628      	mov	r0, r5
   2d378:	f023 0314 	bic.w	r3, r3, #20
   2d37c:	f804 3c0b 	strb.w	r3, [r4, #-11]
}
   2d380:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_ready_thread(thread);
   2d384:	f7ff bf62 	b.w	2d24c <z_ready_thread>
   2d388:	20027514 	.word	0x20027514
   2d38c:	0003c751 	.word	0x0003c751
   2d390:	0003c777 	.word	0x0003c777
   2d394:	0003b77f 	.word	0x0003b77f
   2d398:	0003c78c 	.word	0x0003c78c
   2d39c:	0003c7a4 	.word	0x0003c7a4
   2d3a0:	0003c7bb 	.word	0x0003c7bb

0002d3a4 <z_sched_start>:
{
   2d3a4:	b538      	push	{r3, r4, r5, lr}
   2d3a6:	4604      	mov	r4, r0
	__asm__ volatile(
   2d3a8:	f04f 0320 	mov.w	r3, #32
   2d3ac:	f3ef 8511 	mrs	r5, BASEPRI
   2d3b0:	f383 8811 	msr	BASEPRI, r3
   2d3b4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d3b8:	481d      	ldr	r0, [pc, #116]	; (2d430 <z_sched_start+0x8c>)
   2d3ba:	f001 f891 	bl	2e4e0 <z_spin_lock_valid>
   2d3be:	b968      	cbnz	r0, 2d3dc <z_sched_start+0x38>
   2d3c0:	235c      	movs	r3, #92	; 0x5c
   2d3c2:	4a1c      	ldr	r2, [pc, #112]	; (2d434 <z_sched_start+0x90>)
   2d3c4:	491c      	ldr	r1, [pc, #112]	; (2d438 <z_sched_start+0x94>)
   2d3c6:	481d      	ldr	r0, [pc, #116]	; (2d43c <z_sched_start+0x98>)
   2d3c8:	f006 f8fe 	bl	335c8 <printk>
   2d3cc:	4918      	ldr	r1, [pc, #96]	; (2d430 <z_sched_start+0x8c>)
   2d3ce:	481c      	ldr	r0, [pc, #112]	; (2d440 <z_sched_start+0x9c>)
   2d3d0:	f006 f8fa 	bl	335c8 <printk>
   2d3d4:	215c      	movs	r1, #92	; 0x5c
   2d3d6:	4817      	ldr	r0, [pc, #92]	; (2d434 <z_sched_start+0x90>)
   2d3d8:	f006 fbf7 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d3dc:	4814      	ldr	r0, [pc, #80]	; (2d430 <z_sched_start+0x8c>)
   2d3de:	f001 f89d 	bl	2e51c <z_spin_lock_set_owner>
	if (z_has_thread_started(thread)) {
   2d3e2:	7b63      	ldrb	r3, [r4, #13]
   2d3e4:	075a      	lsls	r2, r3, #29
   2d3e6:	d416      	bmi.n	2d416 <z_sched_start+0x72>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d3e8:	4811      	ldr	r0, [pc, #68]	; (2d430 <z_sched_start+0x8c>)
   2d3ea:	f001 f887 	bl	2e4fc <z_spin_unlock_valid>
   2d3ee:	b968      	cbnz	r0, 2d40c <z_sched_start+0x68>
   2d3f0:	2384      	movs	r3, #132	; 0x84
   2d3f2:	4a10      	ldr	r2, [pc, #64]	; (2d434 <z_sched_start+0x90>)
   2d3f4:	4913      	ldr	r1, [pc, #76]	; (2d444 <z_sched_start+0xa0>)
   2d3f6:	4811      	ldr	r0, [pc, #68]	; (2d43c <z_sched_start+0x98>)
   2d3f8:	f006 f8e6 	bl	335c8 <printk>
   2d3fc:	490c      	ldr	r1, [pc, #48]	; (2d430 <z_sched_start+0x8c>)
   2d3fe:	4812      	ldr	r0, [pc, #72]	; (2d448 <z_sched_start+0xa4>)
   2d400:	f006 f8e2 	bl	335c8 <printk>
   2d404:	2184      	movs	r1, #132	; 0x84
   2d406:	480b      	ldr	r0, [pc, #44]	; (2d434 <z_sched_start+0x90>)
   2d408:	f006 fbdf 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d40c:	f385 8811 	msr	BASEPRI, r5
   2d410:	f3bf 8f6f 	isb	sy
}
   2d414:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
   2d416:	f023 0304 	bic.w	r3, r3, #4
	ready_thread(thread);
   2d41a:	4620      	mov	r0, r4
   2d41c:	7363      	strb	r3, [r4, #13]
   2d41e:	f7ff fecb 	bl	2d1b8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
   2d422:	4629      	mov	r1, r5
}
   2d424:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&sched_spinlock, key);
   2d428:	4801      	ldr	r0, [pc, #4]	; (2d430 <z_sched_start+0x8c>)
   2d42a:	f7ff bced 	b.w	2ce08 <z_reschedule>
   2d42e:	bf00      	nop
   2d430:	20027514 	.word	0x20027514
   2d434:	0003c751 	.word	0x0003c751
   2d438:	0003c777 	.word	0x0003c777
   2d43c:	0003b77f 	.word	0x0003b77f
   2d440:	0003c78c 	.word	0x0003c78c
   2d444:	0003c7a4 	.word	0x0003c7a4
   2d448:	0003c7bb 	.word	0x0003c7bb

0002d44c <z_move_thread_to_end_of_prio_q>:
{
   2d44c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d44e:	4604      	mov	r4, r0
	__asm__ volatile(
   2d450:	f04f 0320 	mov.w	r3, #32
   2d454:	f3ef 8511 	mrs	r5, BASEPRI
   2d458:	f383 8811 	msr	BASEPRI, r3
   2d45c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d460:	4835      	ldr	r0, [pc, #212]	; (2d538 <z_move_thread_to_end_of_prio_q+0xec>)
   2d462:	f001 f83d 	bl	2e4e0 <z_spin_lock_valid>
   2d466:	b968      	cbnz	r0, 2d484 <z_move_thread_to_end_of_prio_q+0x38>
   2d468:	235c      	movs	r3, #92	; 0x5c
   2d46a:	4a34      	ldr	r2, [pc, #208]	; (2d53c <z_move_thread_to_end_of_prio_q+0xf0>)
   2d46c:	4934      	ldr	r1, [pc, #208]	; (2d540 <z_move_thread_to_end_of_prio_q+0xf4>)
   2d46e:	4835      	ldr	r0, [pc, #212]	; (2d544 <z_move_thread_to_end_of_prio_q+0xf8>)
   2d470:	f006 f8aa 	bl	335c8 <printk>
   2d474:	4930      	ldr	r1, [pc, #192]	; (2d538 <z_move_thread_to_end_of_prio_q+0xec>)
   2d476:	4834      	ldr	r0, [pc, #208]	; (2d548 <z_move_thread_to_end_of_prio_q+0xfc>)
   2d478:	f006 f8a6 	bl	335c8 <printk>
   2d47c:	215c      	movs	r1, #92	; 0x5c
   2d47e:	482f      	ldr	r0, [pc, #188]	; (2d53c <z_move_thread_to_end_of_prio_q+0xf0>)
   2d480:	f006 fba3 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d484:	482c      	ldr	r0, [pc, #176]	; (2d538 <z_move_thread_to_end_of_prio_q+0xec>)
   2d486:	f001 f849 	bl	2e51c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   2d48a:	f994 300d 	ldrsb.w	r3, [r4, #13]
   2d48e:	2b00      	cmp	r3, #0
   2d490:	da03      	bge.n	2d49a <z_move_thread_to_end_of_prio_q+0x4e>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   2d492:	4621      	mov	r1, r4
   2d494:	482d      	ldr	r0, [pc, #180]	; (2d54c <z_move_thread_to_end_of_prio_q+0x100>)
   2d496:	f7ff fd6b 	bl	2cf70 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2d49a:	4b2d      	ldr	r3, [pc, #180]	; (2d550 <z_move_thread_to_end_of_prio_q+0x104>)
   2d49c:	429c      	cmp	r4, r3
   2d49e:	d10b      	bne.n	2d4b8 <z_move_thread_to_end_of_prio_q+0x6c>
   2d4a0:	492c      	ldr	r1, [pc, #176]	; (2d554 <z_move_thread_to_end_of_prio_q+0x108>)
   2d4a2:	4828      	ldr	r0, [pc, #160]	; (2d544 <z_move_thread_to_end_of_prio_q+0xf8>)
   2d4a4:	f240 3355 	movw	r3, #853	; 0x355
   2d4a8:	4a2b      	ldr	r2, [pc, #172]	; (2d558 <z_move_thread_to_end_of_prio_q+0x10c>)
   2d4aa:	f006 f88d 	bl	335c8 <printk>
   2d4ae:	f240 3155 	movw	r1, #853	; 0x355
   2d4b2:	4829      	ldr	r0, [pc, #164]	; (2d558 <z_move_thread_to_end_of_prio_q+0x10c>)
   2d4b4:	f006 fb89 	bl	33bca <assert_post_action>
	return list->head == list;
   2d4b8:	4a28      	ldr	r2, [pc, #160]	; (2d55c <z_move_thread_to_end_of_prio_q+0x110>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d4ba:	f102 0128 	add.w	r1, r2, #40	; 0x28
   2d4be:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   2d4c2:	428b      	cmp	r3, r1
   2d4c4:	d032      	beq.n	2d52c <z_move_thread_to_end_of_prio_q+0xe0>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d4c6:	2b00      	cmp	r3, #0
   2d4c8:	d030      	beq.n	2d52c <z_move_thread_to_end_of_prio_q+0xe0>
	if (thread_1->base.prio < thread_2->base.prio) {
   2d4ca:	f994 600e 	ldrsb.w	r6, [r4, #14]
   2d4ce:	f993 700e 	ldrsb.w	r7, [r3, #14]
   2d4d2:	42b7      	cmp	r7, r6
   2d4d4:	dd25      	ble.n	2d522 <z_move_thread_to_end_of_prio_q+0xd6>
	node->prev = successor->prev;
   2d4d6:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
   2d4d8:	e9c4 3100 	strd	r3, r1, [r4]
	successor->prev->next = node;
   2d4dc:	600c      	str	r4, [r1, #0]
	successor->prev = node;
   2d4de:	605c      	str	r4, [r3, #4]
	thread->base.thread_state |= states;
   2d4e0:	7b63      	ldrb	r3, [r4, #13]
		update_cache(thread == _current);
   2d4e2:	6890      	ldr	r0, [r2, #8]
   2d4e4:	f063 037f 	orn	r3, r3, #127	; 0x7f
   2d4e8:	7363      	strb	r3, [r4, #13]
   2d4ea:	1b03      	subs	r3, r0, r4
   2d4ec:	4258      	negs	r0, r3
   2d4ee:	4158      	adcs	r0, r3
   2d4f0:	f7ff fdc2 	bl	2d078 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d4f4:	4810      	ldr	r0, [pc, #64]	; (2d538 <z_move_thread_to_end_of_prio_q+0xec>)
   2d4f6:	f001 f801 	bl	2e4fc <z_spin_unlock_valid>
   2d4fa:	b968      	cbnz	r0, 2d518 <z_move_thread_to_end_of_prio_q+0xcc>
   2d4fc:	2384      	movs	r3, #132	; 0x84
   2d4fe:	4a0f      	ldr	r2, [pc, #60]	; (2d53c <z_move_thread_to_end_of_prio_q+0xf0>)
   2d500:	4917      	ldr	r1, [pc, #92]	; (2d560 <z_move_thread_to_end_of_prio_q+0x114>)
   2d502:	4810      	ldr	r0, [pc, #64]	; (2d544 <z_move_thread_to_end_of_prio_q+0xf8>)
   2d504:	f006 f860 	bl	335c8 <printk>
   2d508:	490b      	ldr	r1, [pc, #44]	; (2d538 <z_move_thread_to_end_of_prio_q+0xec>)
   2d50a:	4816      	ldr	r0, [pc, #88]	; (2d564 <z_move_thread_to_end_of_prio_q+0x118>)
   2d50c:	f006 f85c 	bl	335c8 <printk>
   2d510:	2184      	movs	r1, #132	; 0x84
   2d512:	480a      	ldr	r0, [pc, #40]	; (2d53c <z_move_thread_to_end_of_prio_q+0xf0>)
   2d514:	f006 fb59 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d518:	f385 8811 	msr	BASEPRI, r5
   2d51c:	f3bf 8f6f 	isb	sy
}
   2d520:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   2d522:	4298      	cmp	r0, r3
   2d524:	d002      	beq.n	2d52c <z_move_thread_to_end_of_prio_q+0xe0>
   2d526:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d528:	2b00      	cmp	r3, #0
   2d52a:	d1d0      	bne.n	2d4ce <z_move_thread_to_end_of_prio_q+0x82>
	node->prev = list->tail;
   2d52c:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   2d530:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2d532:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2d534:	62d4      	str	r4, [r2, #44]	; 0x2c
   2d536:	e7d3      	b.n	2d4e0 <z_move_thread_to_end_of_prio_q+0x94>
   2d538:	20027514 	.word	0x20027514
   2d53c:	0003c751 	.word	0x0003c751
   2d540:	0003c777 	.word	0x0003c777
   2d544:	0003b77f 	.word	0x0003b77f
   2d548:	0003c78c 	.word	0x0003c78c
   2d54c:	20027504 	.word	0x20027504
   2d550:	20022b04 	.word	0x20022b04
   2d554:	0003fdb3 	.word	0x0003fdb3
   2d558:	0003fd3d 	.word	0x0003fd3d
   2d55c:	200274dc 	.word	0x200274dc
   2d560:	0003c7a4 	.word	0x0003c7a4
   2d564:	0003c7bb 	.word	0x0003c7bb

0002d568 <z_time_slice>:
	if (pending_current == _current) {
   2d568:	4a15      	ldr	r2, [pc, #84]	; (2d5c0 <z_time_slice+0x58>)
   2d56a:	4916      	ldr	r1, [pc, #88]	; (2d5c4 <z_time_slice+0x5c>)
{
   2d56c:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
   2d56e:	680c      	ldr	r4, [r1, #0]
   2d570:	6893      	ldr	r3, [r2, #8]
   2d572:	42a3      	cmp	r3, r4
   2d574:	4614      	mov	r4, r2
   2d576:	d103      	bne.n	2d580 <z_time_slice+0x18>
}
   2d578:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
   2d57c:	f7ff bb32 	b.w	2cbe4 <z_reset_time_slice>
	pending_current = NULL;
   2d580:	2500      	movs	r5, #0
   2d582:	600d      	str	r5, [r1, #0]
	if (slice_time && sliceable(_current)) {
   2d584:	4910      	ldr	r1, [pc, #64]	; (2d5c8 <z_time_slice+0x60>)
   2d586:	6809      	ldr	r1, [r1, #0]
   2d588:	b1b9      	cbz	r1, 2d5ba <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   2d58a:	89d9      	ldrh	r1, [r3, #14]
   2d58c:	297f      	cmp	r1, #127	; 0x7f
   2d58e:	d814      	bhi.n	2d5ba <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
   2d590:	490e      	ldr	r1, [pc, #56]	; (2d5cc <z_time_slice+0x64>)
   2d592:	f993 500e 	ldrsb.w	r5, [r3, #14]
   2d596:	6809      	ldr	r1, [r1, #0]
   2d598:	428d      	cmp	r5, r1
   2d59a:	db0e      	blt.n	2d5ba <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
   2d59c:	490c      	ldr	r1, [pc, #48]	; (2d5d0 <z_time_slice+0x68>)
   2d59e:	428b      	cmp	r3, r1
   2d5a0:	d00b      	beq.n	2d5ba <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
   2d5a2:	6999      	ldr	r1, [r3, #24]
   2d5a4:	b949      	cbnz	r1, 2d5ba <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
   2d5a6:	6911      	ldr	r1, [r2, #16]
   2d5a8:	4281      	cmp	r1, r0
   2d5aa:	dc03      	bgt.n	2d5b4 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
   2d5ac:	4618      	mov	r0, r3
   2d5ae:	f7ff ff4d 	bl	2d44c <z_move_thread_to_end_of_prio_q>
   2d5b2:	e7e1      	b.n	2d578 <z_time_slice+0x10>
			_current_cpu->slice_ticks -= ticks;
   2d5b4:	1a09      	subs	r1, r1, r0
   2d5b6:	6111      	str	r1, [r2, #16]
}
   2d5b8:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
   2d5ba:	2300      	movs	r3, #0
   2d5bc:	6123      	str	r3, [r4, #16]
   2d5be:	e7fb      	b.n	2d5b8 <z_time_slice+0x50>
   2d5c0:	200274dc 	.word	0x200274dc
   2d5c4:	20027510 	.word	0x20027510
   2d5c8:	2002751c 	.word	0x2002751c
   2d5cc:	20027518 	.word	0x20027518
   2d5d0:	20022b04 	.word	0x20022b04

0002d5d4 <z_impl_k_thread_suspend>:
{
   2d5d4:	b570      	push	{r4, r5, r6, lr}
   2d5d6:	4604      	mov	r4, r0
   2d5d8:	3018      	adds	r0, #24
   2d5da:	f001 f9ad 	bl	2e938 <z_abort_timeout>
	__asm__ volatile(
   2d5de:	f04f 0320 	mov.w	r3, #32
   2d5e2:	f3ef 8611 	mrs	r6, BASEPRI
   2d5e6:	f383 8811 	msr	BASEPRI, r3
   2d5ea:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d5ee:	4825      	ldr	r0, [pc, #148]	; (2d684 <z_impl_k_thread_suspend+0xb0>)
   2d5f0:	f000 ff76 	bl	2e4e0 <z_spin_lock_valid>
   2d5f4:	b968      	cbnz	r0, 2d612 <z_impl_k_thread_suspend+0x3e>
   2d5f6:	235c      	movs	r3, #92	; 0x5c
   2d5f8:	4a23      	ldr	r2, [pc, #140]	; (2d688 <z_impl_k_thread_suspend+0xb4>)
   2d5fa:	4924      	ldr	r1, [pc, #144]	; (2d68c <z_impl_k_thread_suspend+0xb8>)
   2d5fc:	4824      	ldr	r0, [pc, #144]	; (2d690 <z_impl_k_thread_suspend+0xbc>)
   2d5fe:	f005 ffe3 	bl	335c8 <printk>
   2d602:	4920      	ldr	r1, [pc, #128]	; (2d684 <z_impl_k_thread_suspend+0xb0>)
   2d604:	4823      	ldr	r0, [pc, #140]	; (2d694 <z_impl_k_thread_suspend+0xc0>)
   2d606:	f005 ffdf 	bl	335c8 <printk>
   2d60a:	215c      	movs	r1, #92	; 0x5c
   2d60c:	481e      	ldr	r0, [pc, #120]	; (2d688 <z_impl_k_thread_suspend+0xb4>)
   2d60e:	f006 fadc 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d612:	481c      	ldr	r0, [pc, #112]	; (2d684 <z_impl_k_thread_suspend+0xb0>)
   2d614:	f000 ff82 	bl	2e51c <z_spin_lock_set_owner>
		if (z_is_thread_queued(thread)) {
   2d618:	f994 300d 	ldrsb.w	r3, [r4, #13]
   2d61c:	2b00      	cmp	r3, #0
   2d61e:	da07      	bge.n	2d630 <z_impl_k_thread_suspend+0x5c>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
   2d620:	4621      	mov	r1, r4
   2d622:	481d      	ldr	r0, [pc, #116]	; (2d698 <z_impl_k_thread_suspend+0xc4>)
   2d624:	f7ff fca4 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2d628:	7b63      	ldrb	r3, [r4, #13]
   2d62a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2d62e:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
   2d630:	4d1a      	ldr	r5, [pc, #104]	; (2d69c <z_impl_k_thread_suspend+0xc8>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
   2d632:	7b63      	ldrb	r3, [r4, #13]
   2d634:	68a8      	ldr	r0, [r5, #8]
   2d636:	f043 0310 	orr.w	r3, r3, #16
   2d63a:	7363      	strb	r3, [r4, #13]
   2d63c:	1b03      	subs	r3, r0, r4
   2d63e:	4258      	negs	r0, r3
   2d640:	4158      	adcs	r0, r3
   2d642:	f7ff fd19 	bl	2d078 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d646:	480f      	ldr	r0, [pc, #60]	; (2d684 <z_impl_k_thread_suspend+0xb0>)
   2d648:	f000 ff58 	bl	2e4fc <z_spin_unlock_valid>
   2d64c:	b968      	cbnz	r0, 2d66a <z_impl_k_thread_suspend+0x96>
   2d64e:	2384      	movs	r3, #132	; 0x84
   2d650:	4a0d      	ldr	r2, [pc, #52]	; (2d688 <z_impl_k_thread_suspend+0xb4>)
   2d652:	4913      	ldr	r1, [pc, #76]	; (2d6a0 <z_impl_k_thread_suspend+0xcc>)
   2d654:	480e      	ldr	r0, [pc, #56]	; (2d690 <z_impl_k_thread_suspend+0xbc>)
   2d656:	f005 ffb7 	bl	335c8 <printk>
   2d65a:	490a      	ldr	r1, [pc, #40]	; (2d684 <z_impl_k_thread_suspend+0xb0>)
   2d65c:	4811      	ldr	r0, [pc, #68]	; (2d6a4 <z_impl_k_thread_suspend+0xd0>)
   2d65e:	f005 ffb3 	bl	335c8 <printk>
   2d662:	2184      	movs	r1, #132	; 0x84
   2d664:	4808      	ldr	r0, [pc, #32]	; (2d688 <z_impl_k_thread_suspend+0xb4>)
   2d666:	f006 fab0 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d66a:	f386 8811 	msr	BASEPRI, r6
   2d66e:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
   2d672:	68ab      	ldr	r3, [r5, #8]
   2d674:	42a3      	cmp	r3, r4
   2d676:	d103      	bne.n	2d680 <z_impl_k_thread_suspend+0xac>
}
   2d678:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
   2d67c:	f00b bb31 	b.w	38ce2 <z_reschedule_unlocked>
}
   2d680:	bd70      	pop	{r4, r5, r6, pc}
   2d682:	bf00      	nop
   2d684:	20027514 	.word	0x20027514
   2d688:	0003c751 	.word	0x0003c751
   2d68c:	0003c777 	.word	0x0003c777
   2d690:	0003b77f 	.word	0x0003b77f
   2d694:	0003c78c 	.word	0x0003c78c
   2d698:	20027504 	.word	0x20027504
   2d69c:	200274dc 	.word	0x200274dc
   2d6a0:	0003c7a4 	.word	0x0003c7a4
   2d6a4:	0003c7bb 	.word	0x0003c7bb

0002d6a8 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
   2d6a8:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
   2d6aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2d6ae:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
   2d6b0:	b103      	cbz	r3, 2d6b4 <z_thread_single_abort+0xc>
		thread->fn_abort();
   2d6b2:	4798      	blx	r3
   2d6b4:	f104 0018 	add.w	r0, r4, #24
   2d6b8:	f001 f93e 	bl	2e938 <z_abort_timeout>
	__asm__ volatile(
   2d6bc:	f04f 0320 	mov.w	r3, #32
   2d6c0:	f3ef 8611 	mrs	r6, BASEPRI
   2d6c4:	f383 8811 	msr	BASEPRI, r3
   2d6c8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d6cc:	4839      	ldr	r0, [pc, #228]	; (2d7b4 <z_thread_single_abort+0x10c>)
   2d6ce:	f000 ff07 	bl	2e4e0 <z_spin_lock_valid>
   2d6d2:	b968      	cbnz	r0, 2d6f0 <z_thread_single_abort+0x48>
   2d6d4:	235c      	movs	r3, #92	; 0x5c
   2d6d6:	4a38      	ldr	r2, [pc, #224]	; (2d7b8 <z_thread_single_abort+0x110>)
   2d6d8:	4938      	ldr	r1, [pc, #224]	; (2d7bc <z_thread_single_abort+0x114>)
   2d6da:	4839      	ldr	r0, [pc, #228]	; (2d7c0 <z_thread_single_abort+0x118>)
   2d6dc:	f005 ff74 	bl	335c8 <printk>
   2d6e0:	4934      	ldr	r1, [pc, #208]	; (2d7b4 <z_thread_single_abort+0x10c>)
   2d6e2:	4838      	ldr	r0, [pc, #224]	; (2d7c4 <z_thread_single_abort+0x11c>)
   2d6e4:	f005 ff70 	bl	335c8 <printk>
   2d6e8:	215c      	movs	r1, #92	; 0x5c
   2d6ea:	4833      	ldr	r0, [pc, #204]	; (2d7b8 <z_thread_single_abort+0x110>)
   2d6ec:	f006 fa6d 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d6f0:	4830      	ldr	r0, [pc, #192]	; (2d7b4 <z_thread_single_abort+0x10c>)
   2d6f2:	f000 ff13 	bl	2e51c <z_spin_lock_set_owner>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2d6f6:	7b63      	ldrb	r3, [r4, #13]
   2d6f8:	06d8      	lsls	r0, r3, #27
   2d6fa:	d136      	bne.n	2d76a <z_thread_single_abort+0xc2>
		if (z_is_thread_ready(thread)) {
   2d6fc:	69a2      	ldr	r2, [r4, #24]
   2d6fe:	2a00      	cmp	r2, #0
   2d700:	d133      	bne.n	2d76a <z_thread_single_abort+0xc2>
			if (z_is_thread_queued(thread)) {
   2d702:	0619      	lsls	r1, r3, #24
   2d704:	d507      	bpl.n	2d716 <z_thread_single_abort+0x6e>
				_priq_run_remove(&_kernel.ready_q.runq,
   2d706:	4621      	mov	r1, r4
   2d708:	482f      	ldr	r0, [pc, #188]	; (2d7c8 <z_thread_single_abort+0x120>)
   2d70a:	f7ff fc31 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2d70e:	7b63      	ldrb	r3, [r4, #13]
   2d710:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2d714:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
   2d716:	4b2d      	ldr	r3, [pc, #180]	; (2d7cc <z_thread_single_abort+0x124>)
   2d718:	6898      	ldr	r0, [r3, #8]
   2d71a:	1b02      	subs	r2, r0, r4
   2d71c:	4250      	negs	r0, r2
   2d71e:	4150      	adcs	r0, r2
   2d720:	f7ff fcaa 	bl	2d078 <update_cache>
			waiter->base.pended_on = NULL;
   2d724:	2700      	movs	r7, #0
		thread->base.thread_state |= mask;
   2d726:	7b63      	ldrb	r3, [r4, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
   2d728:	f104 0828 	add.w	r8, r4, #40	; 0x28
   2d72c:	f043 0308 	orr.w	r3, r3, #8
   2d730:	7363      	strb	r3, [r4, #13]
	return list->head == list;
   2d732:	6aa5      	ldr	r5, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d734:	4545      	cmp	r5, r8
   2d736:	d000      	beq.n	2d73a <z_thread_single_abort+0x92>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
   2d738:	bb3d      	cbnz	r5, 2d78a <z_thread_single_abort+0xe2>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d73a:	481e      	ldr	r0, [pc, #120]	; (2d7b4 <z_thread_single_abort+0x10c>)
   2d73c:	f000 fede 	bl	2e4fc <z_spin_unlock_valid>
   2d740:	b968      	cbnz	r0, 2d75e <z_thread_single_abort+0xb6>
   2d742:	2384      	movs	r3, #132	; 0x84
   2d744:	4a1c      	ldr	r2, [pc, #112]	; (2d7b8 <z_thread_single_abort+0x110>)
   2d746:	4922      	ldr	r1, [pc, #136]	; (2d7d0 <z_thread_single_abort+0x128>)
   2d748:	481d      	ldr	r0, [pc, #116]	; (2d7c0 <z_thread_single_abort+0x118>)
   2d74a:	f005 ff3d 	bl	335c8 <printk>
   2d74e:	4919      	ldr	r1, [pc, #100]	; (2d7b4 <z_thread_single_abort+0x10c>)
   2d750:	4820      	ldr	r0, [pc, #128]	; (2d7d4 <z_thread_single_abort+0x12c>)
   2d752:	f005 ff39 	bl	335c8 <printk>
   2d756:	2184      	movs	r1, #132	; 0x84
   2d758:	4817      	ldr	r0, [pc, #92]	; (2d7b8 <z_thread_single_abort+0x110>)
   2d75a:	f006 fa36 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d75e:	f386 8811 	msr	BASEPRI, r6
   2d762:	f3bf 8f6f 	isb	sy
}
   2d766:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (z_is_thread_pending(thread)) {
   2d76a:	079b      	lsls	r3, r3, #30
   2d76c:	d5da      	bpl.n	2d724 <z_thread_single_abort+0x7c>
				_priq_wait_remove(&pended_on(thread)->waitq,
   2d76e:	f104 0008 	add.w	r0, r4, #8
   2d772:	f7ff fa1f 	bl	2cbb4 <pended_on.isra.18>
   2d776:	4621      	mov	r1, r4
   2d778:	f7ff fbfa 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2d77c:	7b63      	ldrb	r3, [r4, #13]
   2d77e:	f023 0302 	bic.w	r3, r3, #2
   2d782:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
   2d784:	2300      	movs	r3, #0
   2d786:	60a3      	str	r3, [r4, #8]
   2d788:	e7cc      	b.n	2d724 <z_thread_single_abort+0x7c>
   2d78a:	f105 0018 	add.w	r0, r5, #24
   2d78e:	f001 f8d3 	bl	2e938 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
   2d792:	f105 0008 	add.w	r0, r5, #8
   2d796:	f7ff fa0d 	bl	2cbb4 <pended_on.isra.18>
   2d79a:	4629      	mov	r1, r5
   2d79c:	f7ff fbe8 	bl	2cf70 <z_priq_dumb_remove>
   2d7a0:	7b6b      	ldrb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
   2d7a2:	60af      	str	r7, [r5, #8]
   2d7a4:	f023 0302 	bic.w	r3, r3, #2
   2d7a8:	736b      	strb	r3, [r5, #13]
   2d7aa:	672f      	str	r7, [r5, #112]	; 0x70
			ready_thread(waiter);
   2d7ac:	4628      	mov	r0, r5
   2d7ae:	f7ff fd03 	bl	2d1b8 <ready_thread>
   2d7b2:	e7be      	b.n	2d732 <z_thread_single_abort+0x8a>
   2d7b4:	20027514 	.word	0x20027514
   2d7b8:	0003c751 	.word	0x0003c751
   2d7bc:	0003c777 	.word	0x0003c777
   2d7c0:	0003b77f 	.word	0x0003b77f
   2d7c4:	0003c78c 	.word	0x0003c78c
   2d7c8:	20027504 	.word	0x20027504
   2d7cc:	200274dc 	.word	0x200274dc
   2d7d0:	0003c7a4 	.word	0x0003c7a4
   2d7d4:	0003c7bb 	.word	0x0003c7bb

0002d7d8 <unready_thread>:
{
   2d7d8:	b510      	push	{r4, lr}
	if (z_is_thread_queued(thread)) {
   2d7da:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
   2d7de:	4604      	mov	r4, r0
	if (z_is_thread_queued(thread)) {
   2d7e0:	2b00      	cmp	r3, #0
   2d7e2:	da07      	bge.n	2d7f4 <unready_thread+0x1c>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
   2d7e4:	4601      	mov	r1, r0
   2d7e6:	4808      	ldr	r0, [pc, #32]	; (2d808 <unready_thread+0x30>)
   2d7e8:	f7ff fbc2 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
   2d7ec:	7b63      	ldrb	r3, [r4, #13]
   2d7ee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   2d7f2:	7363      	strb	r3, [r4, #13]
	update_cache(thread == _current);
   2d7f4:	4b05      	ldr	r3, [pc, #20]	; (2d80c <unready_thread+0x34>)
   2d7f6:	6898      	ldr	r0, [r3, #8]
   2d7f8:	1b03      	subs	r3, r0, r4
   2d7fa:	4258      	negs	r0, r3
   2d7fc:	4158      	adcs	r0, r3
}
   2d7fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	update_cache(thread == _current);
   2d802:	f7ff bc39 	b.w	2d078 <update_cache>
   2d806:	bf00      	nop
   2d808:	20027504 	.word	0x20027504
   2d80c:	200274dc 	.word	0x200274dc

0002d810 <z_remove_thread_from_ready_q>:
{
   2d810:	b538      	push	{r3, r4, r5, lr}
   2d812:	4605      	mov	r5, r0
	__asm__ volatile(
   2d814:	f04f 0320 	mov.w	r3, #32
   2d818:	f3ef 8411 	mrs	r4, BASEPRI
   2d81c:	f383 8811 	msr	BASEPRI, r3
   2d820:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d824:	4817      	ldr	r0, [pc, #92]	; (2d884 <z_remove_thread_from_ready_q+0x74>)
   2d826:	f000 fe5b 	bl	2e4e0 <z_spin_lock_valid>
   2d82a:	b968      	cbnz	r0, 2d848 <z_remove_thread_from_ready_q+0x38>
   2d82c:	235c      	movs	r3, #92	; 0x5c
   2d82e:	4a16      	ldr	r2, [pc, #88]	; (2d888 <z_remove_thread_from_ready_q+0x78>)
   2d830:	4916      	ldr	r1, [pc, #88]	; (2d88c <z_remove_thread_from_ready_q+0x7c>)
   2d832:	4817      	ldr	r0, [pc, #92]	; (2d890 <z_remove_thread_from_ready_q+0x80>)
   2d834:	f005 fec8 	bl	335c8 <printk>
   2d838:	4912      	ldr	r1, [pc, #72]	; (2d884 <z_remove_thread_from_ready_q+0x74>)
   2d83a:	4816      	ldr	r0, [pc, #88]	; (2d894 <z_remove_thread_from_ready_q+0x84>)
   2d83c:	f005 fec4 	bl	335c8 <printk>
   2d840:	215c      	movs	r1, #92	; 0x5c
   2d842:	4811      	ldr	r0, [pc, #68]	; (2d888 <z_remove_thread_from_ready_q+0x78>)
   2d844:	f006 f9c1 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d848:	480e      	ldr	r0, [pc, #56]	; (2d884 <z_remove_thread_from_ready_q+0x74>)
   2d84a:	f000 fe67 	bl	2e51c <z_spin_lock_set_owner>
		unready_thread(thread);
   2d84e:	4628      	mov	r0, r5
   2d850:	f7ff ffc2 	bl	2d7d8 <unready_thread>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d854:	480b      	ldr	r0, [pc, #44]	; (2d884 <z_remove_thread_from_ready_q+0x74>)
   2d856:	f000 fe51 	bl	2e4fc <z_spin_unlock_valid>
   2d85a:	b968      	cbnz	r0, 2d878 <z_remove_thread_from_ready_q+0x68>
   2d85c:	2384      	movs	r3, #132	; 0x84
   2d85e:	4a0a      	ldr	r2, [pc, #40]	; (2d888 <z_remove_thread_from_ready_q+0x78>)
   2d860:	490d      	ldr	r1, [pc, #52]	; (2d898 <z_remove_thread_from_ready_q+0x88>)
   2d862:	480b      	ldr	r0, [pc, #44]	; (2d890 <z_remove_thread_from_ready_q+0x80>)
   2d864:	f005 feb0 	bl	335c8 <printk>
   2d868:	4906      	ldr	r1, [pc, #24]	; (2d884 <z_remove_thread_from_ready_q+0x74>)
   2d86a:	480c      	ldr	r0, [pc, #48]	; (2d89c <z_remove_thread_from_ready_q+0x8c>)
   2d86c:	f005 feac 	bl	335c8 <printk>
   2d870:	2184      	movs	r1, #132	; 0x84
   2d872:	4805      	ldr	r0, [pc, #20]	; (2d888 <z_remove_thread_from_ready_q+0x78>)
   2d874:	f006 f9a9 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d878:	f384 8811 	msr	BASEPRI, r4
   2d87c:	f3bf 8f6f 	isb	sy
}
   2d880:	bd38      	pop	{r3, r4, r5, pc}
   2d882:	bf00      	nop
   2d884:	20027514 	.word	0x20027514
   2d888:	0003c751 	.word	0x0003c751
   2d88c:	0003c777 	.word	0x0003c777
   2d890:	0003b77f 	.word	0x0003b77f
   2d894:	0003c78c 	.word	0x0003c78c
   2d898:	0003c7a4 	.word	0x0003c7a4
   2d89c:	0003c7bb 	.word	0x0003c7bb

0002d8a0 <add_to_waitq_locked>:
{
   2d8a0:	b538      	push	{r3, r4, r5, lr}
   2d8a2:	4604      	mov	r4, r0
   2d8a4:	460d      	mov	r5, r1
	unready_thread(thread);
   2d8a6:	f7ff ff97 	bl	2d7d8 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   2d8aa:	7b63      	ldrb	r3, [r4, #13]
   2d8ac:	f043 0302 	orr.w	r3, r3, #2
   2d8b0:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   2d8b2:	b1f5      	cbz	r5, 2d8f2 <add_to_waitq_locked+0x52>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2d8b4:	4b16      	ldr	r3, [pc, #88]	; (2d910 <add_to_waitq_locked+0x70>)
		thread->base.pended_on = wait_q;
   2d8b6:	60a5      	str	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2d8b8:	429c      	cmp	r4, r3
   2d8ba:	d10b      	bne.n	2d8d4 <add_to_waitq_locked+0x34>
   2d8bc:	4915      	ldr	r1, [pc, #84]	; (2d914 <add_to_waitq_locked+0x74>)
   2d8be:	4816      	ldr	r0, [pc, #88]	; (2d918 <add_to_waitq_locked+0x78>)
   2d8c0:	f240 3355 	movw	r3, #853	; 0x355
   2d8c4:	4a15      	ldr	r2, [pc, #84]	; (2d91c <add_to_waitq_locked+0x7c>)
   2d8c6:	f005 fe7f 	bl	335c8 <printk>
   2d8ca:	f240 3155 	movw	r1, #853	; 0x355
   2d8ce:	4813      	ldr	r0, [pc, #76]	; (2d91c <add_to_waitq_locked+0x7c>)
   2d8d0:	f006 f97b 	bl	33bca <assert_post_action>
	return list->head == list;
   2d8d4:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2d8d6:	429d      	cmp	r5, r3
   2d8d8:	d012      	beq.n	2d900 <add_to_waitq_locked+0x60>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d8da:	b18b      	cbz	r3, 2d900 <add_to_waitq_locked+0x60>
	if (thread_1->base.prio < thread_2->base.prio) {
   2d8dc:	f994 200e 	ldrsb.w	r2, [r4, #14]
   2d8e0:	f993 100e 	ldrsb.w	r1, [r3, #14]
   2d8e4:	4291      	cmp	r1, r2
   2d8e6:	dd05      	ble.n	2d8f4 <add_to_waitq_locked+0x54>
	node->prev = successor->prev;
   2d8e8:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2d8ea:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   2d8ee:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2d8f0:	605c      	str	r4, [r3, #4]
}
   2d8f2:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
   2d8f4:	6869      	ldr	r1, [r5, #4]
   2d8f6:	428b      	cmp	r3, r1
   2d8f8:	d002      	beq.n	2d900 <add_to_waitq_locked+0x60>
   2d8fa:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2d8fc:	2b00      	cmp	r3, #0
   2d8fe:	d1ef      	bne.n	2d8e0 <add_to_waitq_locked+0x40>
	node->prev = list->tail;
   2d900:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   2d902:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   2d904:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   2d906:	686b      	ldr	r3, [r5, #4]
   2d908:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2d90a:	606c      	str	r4, [r5, #4]
}
   2d90c:	e7f1      	b.n	2d8f2 <add_to_waitq_locked+0x52>
   2d90e:	bf00      	nop
   2d910:	20022b04 	.word	0x20022b04
   2d914:	0003fdb3 	.word	0x0003fdb3
   2d918:	0003b77f 	.word	0x0003b77f
   2d91c:	0003fd3d 	.word	0x0003fd3d

0002d920 <pend>:
{
   2d920:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2d922:	4604      	mov	r4, r0
   2d924:	460f      	mov	r7, r1
   2d926:	4615      	mov	r5, r2
	__asm__ volatile(
   2d928:	f04f 0320 	mov.w	r3, #32
   2d92c:	f3ef 8611 	mrs	r6, BASEPRI
   2d930:	f383 8811 	msr	BASEPRI, r3
   2d934:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2d938:	4822      	ldr	r0, [pc, #136]	; (2d9c4 <pend+0xa4>)
   2d93a:	f000 fdd1 	bl	2e4e0 <z_spin_lock_valid>
   2d93e:	b968      	cbnz	r0, 2d95c <pend+0x3c>
   2d940:	235c      	movs	r3, #92	; 0x5c
   2d942:	4a21      	ldr	r2, [pc, #132]	; (2d9c8 <pend+0xa8>)
   2d944:	4921      	ldr	r1, [pc, #132]	; (2d9cc <pend+0xac>)
   2d946:	4822      	ldr	r0, [pc, #136]	; (2d9d0 <pend+0xb0>)
   2d948:	f005 fe3e 	bl	335c8 <printk>
   2d94c:	491d      	ldr	r1, [pc, #116]	; (2d9c4 <pend+0xa4>)
   2d94e:	4821      	ldr	r0, [pc, #132]	; (2d9d4 <pend+0xb4>)
   2d950:	f005 fe3a 	bl	335c8 <printk>
   2d954:	215c      	movs	r1, #92	; 0x5c
   2d956:	481c      	ldr	r0, [pc, #112]	; (2d9c8 <pend+0xa8>)
   2d958:	f006 f937 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2d95c:	4819      	ldr	r0, [pc, #100]	; (2d9c4 <pend+0xa4>)
   2d95e:	f000 fddd 	bl	2e51c <z_spin_lock_set_owner>
		add_to_waitq_locked(thread, wait_q);
   2d962:	4620      	mov	r0, r4
   2d964:	4639      	mov	r1, r7
   2d966:	f7ff ff9b 	bl	2d8a0 <add_to_waitq_locked>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2d96a:	4816      	ldr	r0, [pc, #88]	; (2d9c4 <pend+0xa4>)
   2d96c:	f000 fdc6 	bl	2e4fc <z_spin_unlock_valid>
   2d970:	b968      	cbnz	r0, 2d98e <pend+0x6e>
   2d972:	2384      	movs	r3, #132	; 0x84
   2d974:	4a14      	ldr	r2, [pc, #80]	; (2d9c8 <pend+0xa8>)
   2d976:	4918      	ldr	r1, [pc, #96]	; (2d9d8 <pend+0xb8>)
   2d978:	4815      	ldr	r0, [pc, #84]	; (2d9d0 <pend+0xb0>)
   2d97a:	f005 fe25 	bl	335c8 <printk>
   2d97e:	4911      	ldr	r1, [pc, #68]	; (2d9c4 <pend+0xa4>)
   2d980:	4816      	ldr	r0, [pc, #88]	; (2d9dc <pend+0xbc>)
   2d982:	f005 fe21 	bl	335c8 <printk>
   2d986:	2184      	movs	r1, #132	; 0x84
   2d988:	480f      	ldr	r0, [pc, #60]	; (2d9c8 <pend+0xa8>)
   2d98a:	f006 f91e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2d98e:	f386 8811 	msr	BASEPRI, r6
   2d992:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2d996:	1c6b      	adds	r3, r5, #1
   2d998:	d013      	beq.n	2d9c2 <pend+0xa2>
   2d99a:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2d99e:	f240 30e7 	movw	r0, #999	; 0x3e7
   2d9a2:	2100      	movs	r1, #0
   2d9a4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2d9a8:	2300      	movs	r3, #0
   2d9aa:	fbe6 0105 	umlal	r0, r1, r6, r5
   2d9ae:	f7df fedf 	bl	d770 <__aeabi_uldivmod>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   2d9b2:	490b      	ldr	r1, [pc, #44]	; (2d9e0 <pend+0xc0>)
   2d9b4:	1c42      	adds	r2, r0, #1
   2d9b6:	f104 0018 	add.w	r0, r4, #24
}
   2d9ba:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2d9be:	f000 bf13 	b.w	2e7e8 <z_add_timeout>
   2d9c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2d9c4:	20027514 	.word	0x20027514
   2d9c8:	0003c751 	.word	0x0003c751
   2d9cc:	0003c777 	.word	0x0003c777
   2d9d0:	0003b77f 	.word	0x0003b77f
   2d9d4:	0003c78c 	.word	0x0003c78c
   2d9d8:	0003c7a4 	.word	0x0003c7a4
   2d9dc:	0003c7bb 	.word	0x0003c7bb
   2d9e0:	0002d2dd 	.word	0x0002d2dd

0002d9e4 <z_pend_thread>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
   2d9e4:	4b0e      	ldr	r3, [pc, #56]	; (2da20 <z_pend_thread+0x3c>)
{
   2d9e6:	b570      	push	{r4, r5, r6, lr}
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
   2d9e8:	689b      	ldr	r3, [r3, #8]
{
   2d9ea:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
   2d9ec:	4283      	cmp	r3, r0
{
   2d9ee:	460d      	mov	r5, r1
   2d9f0:	4616      	mov	r6, r2
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
   2d9f2:	d00e      	beq.n	2da12 <z_pend_thread+0x2e>
   2d9f4:	7b43      	ldrb	r3, [r0, #13]
   2d9f6:	07db      	lsls	r3, r3, #31
   2d9f8:	d40b      	bmi.n	2da12 <z_pend_thread+0x2e>
   2d9fa:	490a      	ldr	r1, [pc, #40]	; (2da24 <z_pend_thread+0x40>)
   2d9fc:	480a      	ldr	r0, [pc, #40]	; (2da28 <z_pend_thread+0x44>)
   2d9fe:	f240 2361 	movw	r3, #609	; 0x261
   2da02:	4a0a      	ldr	r2, [pc, #40]	; (2da2c <z_pend_thread+0x48>)
   2da04:	f005 fde0 	bl	335c8 <printk>
   2da08:	f240 2161 	movw	r1, #609	; 0x261
   2da0c:	4807      	ldr	r0, [pc, #28]	; (2da2c <z_pend_thread+0x48>)
   2da0e:	f006 f8dc 	bl	33bca <assert_post_action>
	pend(thread, wait_q, timeout);
   2da12:	4632      	mov	r2, r6
   2da14:	4629      	mov	r1, r5
   2da16:	4620      	mov	r0, r4
}
   2da18:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	pend(thread, wait_q, timeout);
   2da1c:	f7ff bf80 	b.w	2d920 <pend>
   2da20:	200274dc 	.word	0x200274dc
   2da24:	0003fd76 	.word	0x0003fd76
   2da28:	0003b77f 	.word	0x0003b77f
   2da2c:	0003fd3d 	.word	0x0003fd3d

0002da30 <z_pend_curr>:
{
   2da30:	b538      	push	{r3, r4, r5, lr}
   2da32:	4604      	mov	r4, r0
   2da34:	460d      	mov	r5, r1
   2da36:	4611      	mov	r1, r2
	pending_current = _current;
   2da38:	4a0e      	ldr	r2, [pc, #56]	; (2da74 <z_pend_curr+0x44>)
   2da3a:	6890      	ldr	r0, [r2, #8]
   2da3c:	4a0e      	ldr	r2, [pc, #56]	; (2da78 <z_pend_curr+0x48>)
   2da3e:	6010      	str	r0, [r2, #0]
	pend(_current, wait_q, timeout);
   2da40:	461a      	mov	r2, r3
   2da42:	f7ff ff6d 	bl	2d920 <pend>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2da46:	4620      	mov	r0, r4
   2da48:	f000 fd58 	bl	2e4fc <z_spin_unlock_valid>
   2da4c:	b968      	cbnz	r0, 2da6a <z_pend_curr+0x3a>
   2da4e:	239b      	movs	r3, #155	; 0x9b
   2da50:	4a0a      	ldr	r2, [pc, #40]	; (2da7c <z_pend_curr+0x4c>)
   2da52:	490b      	ldr	r1, [pc, #44]	; (2da80 <z_pend_curr+0x50>)
   2da54:	480b      	ldr	r0, [pc, #44]	; (2da84 <z_pend_curr+0x54>)
   2da56:	f005 fdb7 	bl	335c8 <printk>
   2da5a:	4621      	mov	r1, r4
   2da5c:	480a      	ldr	r0, [pc, #40]	; (2da88 <z_pend_curr+0x58>)
   2da5e:	f005 fdb3 	bl	335c8 <printk>
   2da62:	219b      	movs	r1, #155	; 0x9b
   2da64:	4805      	ldr	r0, [pc, #20]	; (2da7c <z_pend_curr+0x4c>)
   2da66:	f006 f8b0 	bl	33bca <assert_post_action>
   2da6a:	4628      	mov	r0, r5
}
   2da6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   2da70:	f7ed b83c 	b.w	1aaec <arch_swap>
   2da74:	200274dc 	.word	0x200274dc
   2da78:	20027510 	.word	0x20027510
   2da7c:	0003c751 	.word	0x0003c751
   2da80:	0003c7a4 	.word	0x0003c7a4
   2da84:	0003b77f 	.word	0x0003b77f
   2da88:	0003c7bb 	.word	0x0003c7bb

0002da8c <z_set_prio>:
{
   2da8c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2da8e:	4604      	mov	r4, r0
   2da90:	460d      	mov	r5, r1
	__asm__ volatile(
   2da92:	f04f 0320 	mov.w	r3, #32
   2da96:	f3ef 8611 	mrs	r6, BASEPRI
   2da9a:	f383 8811 	msr	BASEPRI, r3
   2da9e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2daa2:	4836      	ldr	r0, [pc, #216]	; (2db7c <z_set_prio+0xf0>)
   2daa4:	f000 fd1c 	bl	2e4e0 <z_spin_lock_valid>
   2daa8:	b968      	cbnz	r0, 2dac6 <z_set_prio+0x3a>
   2daaa:	235c      	movs	r3, #92	; 0x5c
   2daac:	4a34      	ldr	r2, [pc, #208]	; (2db80 <z_set_prio+0xf4>)
   2daae:	4935      	ldr	r1, [pc, #212]	; (2db84 <z_set_prio+0xf8>)
   2dab0:	4835      	ldr	r0, [pc, #212]	; (2db88 <z_set_prio+0xfc>)
   2dab2:	f005 fd89 	bl	335c8 <printk>
   2dab6:	4931      	ldr	r1, [pc, #196]	; (2db7c <z_set_prio+0xf0>)
   2dab8:	4834      	ldr	r0, [pc, #208]	; (2db8c <z_set_prio+0x100>)
   2daba:	f005 fd85 	bl	335c8 <printk>
   2dabe:	215c      	movs	r1, #92	; 0x5c
   2dac0:	482f      	ldr	r0, [pc, #188]	; (2db80 <z_set_prio+0xf4>)
   2dac2:	f006 f882 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2dac6:	482d      	ldr	r0, [pc, #180]	; (2db7c <z_set_prio+0xf0>)
   2dac8:	f000 fd28 	bl	2e51c <z_spin_lock_set_owner>
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2dacc:	7b63      	ldrb	r3, [r4, #13]
   2dace:	b26d      	sxtb	r5, r5
   2dad0:	06db      	lsls	r3, r3, #27
   2dad2:	d150      	bne.n	2db76 <z_set_prio+0xea>
		if (need_sched) {
   2dad4:	69a3      	ldr	r3, [r4, #24]
   2dad6:	2b00      	cmp	r3, #0
   2dad8:	d14d      	bne.n	2db76 <z_set_prio+0xea>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
   2dada:	4621      	mov	r1, r4
   2dadc:	482c      	ldr	r0, [pc, #176]	; (2db90 <z_set_prio+0x104>)
   2dade:	f7ff fa47 	bl	2cf70 <z_priq_dumb_remove>
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2dae2:	4b2c      	ldr	r3, [pc, #176]	; (2db94 <z_set_prio+0x108>)
				thread->base.prio = prio;
   2dae4:	73a5      	strb	r5, [r4, #14]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2dae6:	429c      	cmp	r4, r3
   2dae8:	d10b      	bne.n	2db02 <z_set_prio+0x76>
   2daea:	492b      	ldr	r1, [pc, #172]	; (2db98 <z_set_prio+0x10c>)
   2daec:	4826      	ldr	r0, [pc, #152]	; (2db88 <z_set_prio+0xfc>)
   2daee:	f240 3355 	movw	r3, #853	; 0x355
   2daf2:	4a2a      	ldr	r2, [pc, #168]	; (2db9c <z_set_prio+0x110>)
   2daf4:	f005 fd68 	bl	335c8 <printk>
   2daf8:	f240 3155 	movw	r1, #853	; 0x355
   2dafc:	4827      	ldr	r0, [pc, #156]	; (2db9c <z_set_prio+0x110>)
   2dafe:	f006 f864 	bl	33bca <assert_post_action>
	return list->head == list;
   2db02:	4a27      	ldr	r2, [pc, #156]	; (2dba0 <z_set_prio+0x114>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2db04:	f102 0128 	add.w	r1, r2, #40	; 0x28
   2db08:	e9d2 300a 	ldrd	r3, r0, [r2, #40]	; 0x28
   2db0c:	428b      	cmp	r3, r1
   2db0e:	d02c      	beq.n	2db6a <z_set_prio+0xde>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2db10:	b35b      	cbz	r3, 2db6a <z_set_prio+0xde>
	if (thread_1->base.prio < thread_2->base.prio) {
   2db12:	f994 500e 	ldrsb.w	r5, [r4, #14]
   2db16:	f993 700e 	ldrsb.w	r7, [r3, #14]
   2db1a:	42af      	cmp	r7, r5
   2db1c:	dd20      	ble.n	2db60 <z_set_prio+0xd4>
	node->prev = successor->prev;
   2db1e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2db20:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   2db24:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   2db26:	605c      	str	r4, [r3, #4]
			update_cache(1);
   2db28:	2001      	movs	r0, #1
   2db2a:	f7ff faa5 	bl	2d078 <update_cache>
   2db2e:	2401      	movs	r4, #1
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2db30:	4812      	ldr	r0, [pc, #72]	; (2db7c <z_set_prio+0xf0>)
   2db32:	f000 fce3 	bl	2e4fc <z_spin_unlock_valid>
   2db36:	b968      	cbnz	r0, 2db54 <z_set_prio+0xc8>
   2db38:	2384      	movs	r3, #132	; 0x84
   2db3a:	4a11      	ldr	r2, [pc, #68]	; (2db80 <z_set_prio+0xf4>)
   2db3c:	4919      	ldr	r1, [pc, #100]	; (2dba4 <z_set_prio+0x118>)
   2db3e:	4812      	ldr	r0, [pc, #72]	; (2db88 <z_set_prio+0xfc>)
   2db40:	f005 fd42 	bl	335c8 <printk>
   2db44:	490d      	ldr	r1, [pc, #52]	; (2db7c <z_set_prio+0xf0>)
   2db46:	4818      	ldr	r0, [pc, #96]	; (2dba8 <z_set_prio+0x11c>)
   2db48:	f005 fd3e 	bl	335c8 <printk>
   2db4c:	2184      	movs	r1, #132	; 0x84
   2db4e:	480c      	ldr	r0, [pc, #48]	; (2db80 <z_set_prio+0xf4>)
   2db50:	f006 f83b 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2db54:	f386 8811 	msr	BASEPRI, r6
   2db58:	f3bf 8f6f 	isb	sy
}
   2db5c:	4620      	mov	r0, r4
   2db5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
   2db60:	4298      	cmp	r0, r3
   2db62:	d002      	beq.n	2db6a <z_set_prio+0xde>
   2db64:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2db66:	2b00      	cmp	r3, #0
   2db68:	d1d5      	bne.n	2db16 <z_set_prio+0x8a>
	node->prev = list->tail;
   2db6a:	e9c4 1000 	strd	r1, r0, [r4]
	list->tail->next = node;
   2db6e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   2db70:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2db72:	62d4      	str	r4, [r2, #44]	; 0x2c
   2db74:	e7d8      	b.n	2db28 <z_set_prio+0x9c>
			thread->base.prio = prio;
   2db76:	73a5      	strb	r5, [r4, #14]
   2db78:	2400      	movs	r4, #0
   2db7a:	e7d9      	b.n	2db30 <z_set_prio+0xa4>
   2db7c:	20027514 	.word	0x20027514
   2db80:	0003c751 	.word	0x0003c751
   2db84:	0003c777 	.word	0x0003c777
   2db88:	0003b77f 	.word	0x0003b77f
   2db8c:	0003c78c 	.word	0x0003c78c
   2db90:	20027504 	.word	0x20027504
   2db94:	20022b04 	.word	0x20022b04
   2db98:	0003fdb3 	.word	0x0003fdb3
   2db9c:	0003fd3d 	.word	0x0003fd3d
   2dba0:	200274dc 	.word	0x200274dc
   2dba4:	0003c7a4 	.word	0x0003c7a4
   2dba8:	0003c7bb 	.word	0x0003c7bb

0002dbac <z_unpend_first_thread>:
{
   2dbac:	b538      	push	{r3, r4, r5, lr}
   2dbae:	4604      	mov	r4, r0
	__asm__ volatile(
   2dbb0:	f04f 0320 	mov.w	r3, #32
   2dbb4:	f3ef 8511 	mrs	r5, BASEPRI
   2dbb8:	f383 8811 	msr	BASEPRI, r3
   2dbbc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2dbc0:	483b      	ldr	r0, [pc, #236]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dbc2:	f000 fc8d 	bl	2e4e0 <z_spin_lock_valid>
   2dbc6:	b968      	cbnz	r0, 2dbe4 <z_unpend_first_thread+0x38>
   2dbc8:	235c      	movs	r3, #92	; 0x5c
   2dbca:	4a3a      	ldr	r2, [pc, #232]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dbcc:	493a      	ldr	r1, [pc, #232]	; (2dcb8 <z_unpend_first_thread+0x10c>)
   2dbce:	483b      	ldr	r0, [pc, #236]	; (2dcbc <z_unpend_first_thread+0x110>)
   2dbd0:	f005 fcfa 	bl	335c8 <printk>
   2dbd4:	4936      	ldr	r1, [pc, #216]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dbd6:	483a      	ldr	r0, [pc, #232]	; (2dcc0 <z_unpend_first_thread+0x114>)
   2dbd8:	f005 fcf6 	bl	335c8 <printk>
   2dbdc:	215c      	movs	r1, #92	; 0x5c
   2dbde:	4835      	ldr	r0, [pc, #212]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dbe0:	f005 fff3 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2dbe4:	4832      	ldr	r0, [pc, #200]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dbe6:	f000 fc99 	bl	2e51c <z_spin_lock_set_owner>
		ret = _priq_wait_best(&wait_q->waitq);
   2dbea:	4620      	mov	r0, r4
   2dbec:	f00b f883 	bl	38cf6 <z_priq_dumb_best>
   2dbf0:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2dbf2:	482f      	ldr	r0, [pc, #188]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dbf4:	f000 fc82 	bl	2e4fc <z_spin_unlock_valid>
   2dbf8:	b968      	cbnz	r0, 2dc16 <z_unpend_first_thread+0x6a>
   2dbfa:	2384      	movs	r3, #132	; 0x84
   2dbfc:	4a2d      	ldr	r2, [pc, #180]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dbfe:	4931      	ldr	r1, [pc, #196]	; (2dcc4 <z_unpend_first_thread+0x118>)
   2dc00:	482e      	ldr	r0, [pc, #184]	; (2dcbc <z_unpend_first_thread+0x110>)
   2dc02:	f005 fce1 	bl	335c8 <printk>
   2dc06:	492a      	ldr	r1, [pc, #168]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc08:	482f      	ldr	r0, [pc, #188]	; (2dcc8 <z_unpend_first_thread+0x11c>)
   2dc0a:	f005 fcdd 	bl	335c8 <printk>
   2dc0e:	2184      	movs	r1, #132	; 0x84
   2dc10:	4828      	ldr	r0, [pc, #160]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dc12:	f005 ffda 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2dc16:	f385 8811 	msr	BASEPRI, r5
   2dc1a:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   2dc1e:	2c00      	cmp	r4, #0
   2dc20:	d043      	beq.n	2dcaa <z_unpend_first_thread+0xfe>
	__asm__ volatile(
   2dc22:	f04f 0320 	mov.w	r3, #32
   2dc26:	f3ef 8511 	mrs	r5, BASEPRI
   2dc2a:	f383 8811 	msr	BASEPRI, r3
   2dc2e:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2dc32:	481f      	ldr	r0, [pc, #124]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc34:	f000 fc54 	bl	2e4e0 <z_spin_lock_valid>
   2dc38:	b968      	cbnz	r0, 2dc56 <z_unpend_first_thread+0xaa>
   2dc3a:	235c      	movs	r3, #92	; 0x5c
   2dc3c:	4a1d      	ldr	r2, [pc, #116]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dc3e:	491e      	ldr	r1, [pc, #120]	; (2dcb8 <z_unpend_first_thread+0x10c>)
   2dc40:	481e      	ldr	r0, [pc, #120]	; (2dcbc <z_unpend_first_thread+0x110>)
   2dc42:	f005 fcc1 	bl	335c8 <printk>
   2dc46:	491a      	ldr	r1, [pc, #104]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc48:	481d      	ldr	r0, [pc, #116]	; (2dcc0 <z_unpend_first_thread+0x114>)
   2dc4a:	f005 fcbd 	bl	335c8 <printk>
   2dc4e:	215c      	movs	r1, #92	; 0x5c
   2dc50:	4818      	ldr	r0, [pc, #96]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dc52:	f005 ffba 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2dc56:	4816      	ldr	r0, [pc, #88]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc58:	f000 fc60 	bl	2e51c <z_spin_lock_set_owner>
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
   2dc5c:	f104 0008 	add.w	r0, r4, #8
   2dc60:	f7fe ffa8 	bl	2cbb4 <pended_on.isra.18>
   2dc64:	4621      	mov	r1, r4
   2dc66:	f7ff f983 	bl	2cf70 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   2dc6a:	7b63      	ldrb	r3, [r4, #13]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2dc6c:	4810      	ldr	r0, [pc, #64]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc6e:	f023 0302 	bic.w	r3, r3, #2
   2dc72:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
   2dc74:	2300      	movs	r3, #0
   2dc76:	60a3      	str	r3, [r4, #8]
   2dc78:	f000 fc40 	bl	2e4fc <z_spin_unlock_valid>
   2dc7c:	b968      	cbnz	r0, 2dc9a <z_unpend_first_thread+0xee>
   2dc7e:	2384      	movs	r3, #132	; 0x84
   2dc80:	4a0c      	ldr	r2, [pc, #48]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dc82:	4910      	ldr	r1, [pc, #64]	; (2dcc4 <z_unpend_first_thread+0x118>)
   2dc84:	480d      	ldr	r0, [pc, #52]	; (2dcbc <z_unpend_first_thread+0x110>)
   2dc86:	f005 fc9f 	bl	335c8 <printk>
   2dc8a:	4909      	ldr	r1, [pc, #36]	; (2dcb0 <z_unpend_first_thread+0x104>)
   2dc8c:	480e      	ldr	r0, [pc, #56]	; (2dcc8 <z_unpend_first_thread+0x11c>)
   2dc8e:	f005 fc9b 	bl	335c8 <printk>
   2dc92:	2184      	movs	r1, #132	; 0x84
   2dc94:	4807      	ldr	r0, [pc, #28]	; (2dcb4 <z_unpend_first_thread+0x108>)
   2dc96:	f005 ff98 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2dc9a:	f385 8811 	msr	BASEPRI, r5
   2dc9e:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
   2dca2:	f104 0018 	add.w	r0, r4, #24
   2dca6:	f000 fe47 	bl	2e938 <z_abort_timeout>
}
   2dcaa:	4620      	mov	r0, r4
   2dcac:	bd38      	pop	{r3, r4, r5, pc}
   2dcae:	bf00      	nop
   2dcb0:	20027514 	.word	0x20027514
   2dcb4:	0003c751 	.word	0x0003c751
   2dcb8:	0003c777 	.word	0x0003c777
   2dcbc:	0003b77f 	.word	0x0003b77f
   2dcc0:	0003c78c 	.word	0x0003c78c
   2dcc4:	0003c7a4 	.word	0x0003c7a4
   2dcc8:	0003c7bb 	.word	0x0003c7bb

0002dccc <z_sched_init>:
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
   2dccc:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
   2dcce:	4b04      	ldr	r3, [pc, #16]	; (2dce0 <z_sched_init+0x14>)
   2dcd0:	4608      	mov	r0, r1
   2dcd2:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   2dcd6:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
   2dcda:	f7fe bf99 	b.w	2cc10 <k_sched_time_slice_set>
   2dcde:	bf00      	nop
   2dce0:	200274dc 	.word	0x200274dc

0002dce4 <z_impl_k_yield>:
#include <syscalls/k_thread_deadline_set_mrsh.c>
#endif
#endif

void z_impl_k_yield(void)
{
   2dce4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2dce6:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "");
   2dcea:	b173      	cbz	r3, 2dd0a <z_impl_k_yield+0x26>
   2dcec:	4945      	ldr	r1, [pc, #276]	; (2de04 <z_impl_k_yield+0x120>)
   2dcee:	f44f 638c 	mov.w	r3, #1120	; 0x460
   2dcf2:	4a45      	ldr	r2, [pc, #276]	; (2de08 <z_impl_k_yield+0x124>)
   2dcf4:	4845      	ldr	r0, [pc, #276]	; (2de0c <z_impl_k_yield+0x128>)
   2dcf6:	f005 fc67 	bl	335c8 <printk>
   2dcfa:	4845      	ldr	r0, [pc, #276]	; (2de10 <z_impl_k_yield+0x12c>)
   2dcfc:	f005 fc64 	bl	335c8 <printk>
   2dd00:	f44f 618c 	mov.w	r1, #1120	; 0x460
   2dd04:	4840      	ldr	r0, [pc, #256]	; (2de08 <z_impl_k_yield+0x124>)
   2dd06:	f005 ff60 	bl	33bca <assert_post_action>

	if (!z_is_idle_thread_object(_current)) {
   2dd0a:	4c42      	ldr	r4, [pc, #264]	; (2de14 <z_impl_k_yield+0x130>)
   2dd0c:	4e42      	ldr	r6, [pc, #264]	; (2de18 <z_impl_k_yield+0x134>)
   2dd0e:	68a2      	ldr	r2, [r4, #8]
   2dd10:	42b2      	cmp	r2, r6
   2dd12:	d05f      	beq.n	2ddd4 <z_impl_k_yield+0xf0>
	__asm__ volatile(
   2dd14:	f04f 0320 	mov.w	r3, #32
   2dd18:	f3ef 8711 	mrs	r7, BASEPRI
   2dd1c:	f383 8811 	msr	BASEPRI, r3
   2dd20:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2dd24:	483d      	ldr	r0, [pc, #244]	; (2de1c <z_impl_k_yield+0x138>)
   2dd26:	f000 fbdb 	bl	2e4e0 <z_spin_lock_valid>
   2dd2a:	b968      	cbnz	r0, 2dd48 <z_impl_k_yield+0x64>
   2dd2c:	235c      	movs	r3, #92	; 0x5c
   2dd2e:	4a3c      	ldr	r2, [pc, #240]	; (2de20 <z_impl_k_yield+0x13c>)
   2dd30:	493c      	ldr	r1, [pc, #240]	; (2de24 <z_impl_k_yield+0x140>)
   2dd32:	4836      	ldr	r0, [pc, #216]	; (2de0c <z_impl_k_yield+0x128>)
   2dd34:	f005 fc48 	bl	335c8 <printk>
   2dd38:	4938      	ldr	r1, [pc, #224]	; (2de1c <z_impl_k_yield+0x138>)
   2dd3a:	483b      	ldr	r0, [pc, #236]	; (2de28 <z_impl_k_yield+0x144>)
   2dd3c:	f005 fc44 	bl	335c8 <printk>
   2dd40:	215c      	movs	r1, #92	; 0x5c
   2dd42:	4837      	ldr	r0, [pc, #220]	; (2de20 <z_impl_k_yield+0x13c>)
   2dd44:	f005 ff41 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2dd48:	4834      	ldr	r0, [pc, #208]	; (2de1c <z_impl_k_yield+0x138>)
   2dd4a:	f000 fbe7 	bl	2e51c <z_spin_lock_set_owner>
		LOCKED(&sched_spinlock) {
			if (!IS_ENABLED(CONFIG_SMP) ||
			    z_is_thread_queued(_current)) {
				_priq_run_remove(&_kernel.ready_q.runq,
   2dd4e:	68a1      	ldr	r1, [r4, #8]
   2dd50:	4836      	ldr	r0, [pc, #216]	; (2de2c <z_impl_k_yield+0x148>)
   2dd52:	f7ff f90d 	bl	2cf70 <z_priq_dumb_remove>
						 _current);
			}
			_priq_run_add(&_kernel.ready_q.runq, _current);
   2dd56:	68a5      	ldr	r5, [r4, #8]
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));
   2dd58:	42b5      	cmp	r5, r6
   2dd5a:	d10b      	bne.n	2dd74 <z_impl_k_yield+0x90>
   2dd5c:	4934      	ldr	r1, [pc, #208]	; (2de30 <z_impl_k_yield+0x14c>)
   2dd5e:	482b      	ldr	r0, [pc, #172]	; (2de0c <z_impl_k_yield+0x128>)
   2dd60:	f240 3355 	movw	r3, #853	; 0x355
   2dd64:	4a28      	ldr	r2, [pc, #160]	; (2de08 <z_impl_k_yield+0x124>)
   2dd66:	f005 fc2f 	bl	335c8 <printk>
   2dd6a:	f240 3155 	movw	r1, #853	; 0x355
   2dd6e:	4826      	ldr	r0, [pc, #152]	; (2de08 <z_impl_k_yield+0x124>)
   2dd70:	f005 ff2b 	bl	33bca <assert_post_action>
	return list->head == list;
   2dd74:	e9d4 310a 	ldrd	r3, r1, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2dd78:	4a2c      	ldr	r2, [pc, #176]	; (2de2c <z_impl_k_yield+0x148>)
   2dd7a:	4293      	cmp	r3, r2
   2dd7c:	d03b      	beq.n	2ddf6 <z_impl_k_yield+0x112>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2dd7e:	2b00      	cmp	r3, #0
   2dd80:	d039      	beq.n	2ddf6 <z_impl_k_yield+0x112>
	if (thread_1->base.prio < thread_2->base.prio) {
   2dd82:	f995 000e 	ldrsb.w	r0, [r5, #14]
   2dd86:	f993 600e 	ldrsb.w	r6, [r3, #14]
   2dd8a:	4286      	cmp	r6, r0
   2dd8c:	dd2e      	ble.n	2ddec <z_impl_k_yield+0x108>
	node->prev = successor->prev;
   2dd8e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   2dd90:	e9c5 3200 	strd	r3, r2, [r5]
	successor->prev->next = node;
   2dd94:	6015      	str	r5, [r2, #0]
	successor->prev = node;
   2dd96:	605d      	str	r5, [r3, #4]
			z_mark_thread_as_queued(_current);
   2dd98:	68a2      	ldr	r2, [r4, #8]
			update_cache(1);
   2dd9a:	2001      	movs	r0, #1
	thread->base.thread_state |= states;
   2dd9c:	7b53      	ldrb	r3, [r2, #13]
   2dd9e:	f063 037f 	orn	r3, r3, #127	; 0x7f
   2dda2:	7353      	strb	r3, [r2, #13]
   2dda4:	f7ff f968 	bl	2d078 <update_cache>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2dda8:	481c      	ldr	r0, [pc, #112]	; (2de1c <z_impl_k_yield+0x138>)
   2ddaa:	f000 fba7 	bl	2e4fc <z_spin_unlock_valid>
   2ddae:	b968      	cbnz	r0, 2ddcc <z_impl_k_yield+0xe8>
   2ddb0:	2384      	movs	r3, #132	; 0x84
   2ddb2:	4a1b      	ldr	r2, [pc, #108]	; (2de20 <z_impl_k_yield+0x13c>)
   2ddb4:	491f      	ldr	r1, [pc, #124]	; (2de34 <z_impl_k_yield+0x150>)
   2ddb6:	4815      	ldr	r0, [pc, #84]	; (2de0c <z_impl_k_yield+0x128>)
   2ddb8:	f005 fc06 	bl	335c8 <printk>
   2ddbc:	4917      	ldr	r1, [pc, #92]	; (2de1c <z_impl_k_yield+0x138>)
   2ddbe:	481e      	ldr	r0, [pc, #120]	; (2de38 <z_impl_k_yield+0x154>)
   2ddc0:	f005 fc02 	bl	335c8 <printk>
   2ddc4:	2184      	movs	r1, #132	; 0x84
   2ddc6:	4816      	ldr	r0, [pc, #88]	; (2de20 <z_impl_k_yield+0x13c>)
   2ddc8:	f005 feff 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2ddcc:	f387 8811 	msr	BASEPRI, r7
   2ddd0:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2ddd4:	f04f 0320 	mov.w	r3, #32
   2ddd8:	f3ef 8011 	mrs	r0, BASEPRI
   2dddc:	f383 8811 	msr	BASEPRI, r3
   2dde0:	f3bf 8f6f 	isb	sy
		}
	}
	z_swap_unlocked();
}
   2dde4:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   2dde8:	f7ec be80 	b.w	1aaec <arch_swap>
	return (node == list->tail) ? NULL : node->next;
   2ddec:	4299      	cmp	r1, r3
   2ddee:	d002      	beq.n	2ddf6 <z_impl_k_yield+0x112>
   2ddf0:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   2ddf2:	2b00      	cmp	r3, #0
   2ddf4:	d1c7      	bne.n	2dd86 <z_impl_k_yield+0xa2>
	node->prev = list->tail;
   2ddf6:	e9c5 2100 	strd	r2, r1, [r5]
	list->tail->next = node;
   2ddfa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   2ddfc:	601d      	str	r5, [r3, #0]
	list->tail = node;
   2ddfe:	62e5      	str	r5, [r4, #44]	; 0x2c
   2de00:	e7ca      	b.n	2dd98 <z_impl_k_yield+0xb4>
   2de02:	bf00      	nop
   2de04:	0003fccb 	.word	0x0003fccb
   2de08:	0003fd3d 	.word	0x0003fd3d
   2de0c:	0003b77f 	.word	0x0003b77f
   2de10:	0003cb8b 	.word	0x0003cb8b
   2de14:	200274dc 	.word	0x200274dc
   2de18:	20022b04 	.word	0x20022b04
   2de1c:	20027514 	.word	0x20027514
   2de20:	0003c751 	.word	0x0003c751
   2de24:	0003c777 	.word	0x0003c777
   2de28:	0003c78c 	.word	0x0003c78c
   2de2c:	20027504 	.word	0x20027504
   2de30:	0003fdb3 	.word	0x0003fdb3
   2de34:	0003c7a4 	.word	0x0003c7a4
   2de38:	0003c7bb 	.word	0x0003c7bb

0002de3c <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
{
   2de3c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2de3e:	4604      	mov	r4, r0
   2de40:	f3ef 8305 	mrs	r3, IPSR
#ifdef CONFIG_MULTITHREADING
	u32_t expected_wakeup_time;

	__ASSERT(!arch_is_in_isr(), "");
   2de44:	b173      	cbz	r3, 2de64 <z_tick_sleep+0x28>
   2de46:	493b      	ldr	r1, [pc, #236]	; (2df34 <z_tick_sleep+0xf8>)
   2de48:	f240 437e 	movw	r3, #1150	; 0x47e
   2de4c:	4a3a      	ldr	r2, [pc, #232]	; (2df38 <z_tick_sleep+0xfc>)
   2de4e:	483b      	ldr	r0, [pc, #236]	; (2df3c <z_tick_sleep+0x100>)
   2de50:	f005 fbba 	bl	335c8 <printk>
   2de54:	483a      	ldr	r0, [pc, #232]	; (2df40 <z_tick_sleep+0x104>)
   2de56:	f005 fbb7 	bl	335c8 <printk>
   2de5a:	f240 417e 	movw	r1, #1150	; 0x47e
   2de5e:	4836      	ldr	r0, [pc, #216]	; (2df38 <z_tick_sleep+0xfc>)
   2de60:	f005 feb3 	bl	33bca <assert_post_action>

	K_DEBUG("thread %p for %d ticks\n", _current, ticks);

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
   2de64:	b924      	cbnz	r4, 2de70 <z_tick_sleep+0x34>
	z_impl_k_yield();
   2de66:	f7ff ff3d 	bl	2dce4 <z_impl_k_yield>
		return ticks;
	}
#endif

	return 0;
}
   2de6a:	4620      	mov	r0, r4
   2de6c:	b003      	add	sp, #12
   2de6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	expected_wakeup_time = ticks + z_tick_get_32();
   2de70:	f00a ffe0 	bl	38e34 <z_tick_get_32>
	struct k_spinlock local_lock = {};
   2de74:	2300      	movs	r3, #0
	ticks += _TICK_ALIGN;
   2de76:	1c66      	adds	r6, r4, #1
	expected_wakeup_time = ticks + z_tick_get_32();
   2de78:	1834      	adds	r4, r6, r0
	struct k_spinlock local_lock = {};
   2de7a:	9301      	str	r3, [sp, #4]
   2de7c:	f04f 0320 	mov.w	r3, #32
   2de80:	f3ef 8711 	mrs	r7, BASEPRI
   2de84:	f383 8811 	msr	BASEPRI, r3
   2de88:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2de8c:	a801      	add	r0, sp, #4
   2de8e:	f000 fb27 	bl	2e4e0 <z_spin_lock_valid>
   2de92:	b968      	cbnz	r0, 2deb0 <z_tick_sleep+0x74>
   2de94:	235c      	movs	r3, #92	; 0x5c
   2de96:	4a2b      	ldr	r2, [pc, #172]	; (2df44 <z_tick_sleep+0x108>)
   2de98:	492b      	ldr	r1, [pc, #172]	; (2df48 <z_tick_sleep+0x10c>)
   2de9a:	4828      	ldr	r0, [pc, #160]	; (2df3c <z_tick_sleep+0x100>)
   2de9c:	f005 fb94 	bl	335c8 <printk>
   2dea0:	a901      	add	r1, sp, #4
   2dea2:	482a      	ldr	r0, [pc, #168]	; (2df4c <z_tick_sleep+0x110>)
   2dea4:	f005 fb90 	bl	335c8 <printk>
   2dea8:	215c      	movs	r1, #92	; 0x5c
   2deaa:	4826      	ldr	r0, [pc, #152]	; (2df44 <z_tick_sleep+0x108>)
   2deac:	f005 fe8d 	bl	33bca <assert_post_action>
	pending_current = _current;
   2deb0:	4d27      	ldr	r5, [pc, #156]	; (2df50 <z_tick_sleep+0x114>)
	z_spin_lock_set_owner(l);
   2deb2:	a801      	add	r0, sp, #4
   2deb4:	f000 fb32 	bl	2e51c <z_spin_lock_set_owner>
   2deb8:	4b26      	ldr	r3, [pc, #152]	; (2df54 <z_tick_sleep+0x118>)
   2deba:	68a8      	ldr	r0, [r5, #8]
   2debc:	6018      	str	r0, [r3, #0]
	z_remove_thread_from_ready_q(_current);
   2debe:	f7ff fca7 	bl	2d810 <z_remove_thread_from_ready_q>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
   2dec2:	68a8      	ldr	r0, [r5, #8]
   2dec4:	4632      	mov	r2, r6
   2dec6:	3018      	adds	r0, #24
   2dec8:	4923      	ldr	r1, [pc, #140]	; (2df58 <z_tick_sleep+0x11c>)
   2deca:	f000 fc8d 	bl	2e7e8 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
   2dece:	68aa      	ldr	r2, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ded0:	a801      	add	r0, sp, #4
	thread->base.thread_state |= _THREAD_SUSPENDED;
   2ded2:	7b53      	ldrb	r3, [r2, #13]
   2ded4:	f043 0310 	orr.w	r3, r3, #16
   2ded8:	7353      	strb	r3, [r2, #13]
   2deda:	f000 fb0f 	bl	2e4fc <z_spin_unlock_valid>
   2dede:	b968      	cbnz	r0, 2defc <z_tick_sleep+0xc0>
   2dee0:	239b      	movs	r3, #155	; 0x9b
   2dee2:	4a18      	ldr	r2, [pc, #96]	; (2df44 <z_tick_sleep+0x108>)
   2dee4:	491d      	ldr	r1, [pc, #116]	; (2df5c <z_tick_sleep+0x120>)
   2dee6:	4815      	ldr	r0, [pc, #84]	; (2df3c <z_tick_sleep+0x100>)
   2dee8:	f005 fb6e 	bl	335c8 <printk>
   2deec:	a901      	add	r1, sp, #4
   2deee:	481c      	ldr	r0, [pc, #112]	; (2df60 <z_tick_sleep+0x124>)
   2def0:	f005 fb6a 	bl	335c8 <printk>
   2def4:	219b      	movs	r1, #155	; 0x9b
   2def6:	4813      	ldr	r0, [pc, #76]	; (2df44 <z_tick_sleep+0x108>)
   2def8:	f005 fe67 	bl	33bca <assert_post_action>
   2defc:	4638      	mov	r0, r7
   2defe:	f7ec fdf5 	bl	1aaec <arch_swap>
	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");
   2df02:	68ab      	ldr	r3, [r5, #8]
   2df04:	7b5b      	ldrb	r3, [r3, #13]
   2df06:	06db      	lsls	r3, r3, #27
   2df08:	d50e      	bpl.n	2df28 <z_tick_sleep+0xec>
   2df0a:	4916      	ldr	r1, [pc, #88]	; (2df64 <z_tick_sleep+0x128>)
   2df0c:	f240 43a3 	movw	r3, #1187	; 0x4a3
   2df10:	4a09      	ldr	r2, [pc, #36]	; (2df38 <z_tick_sleep+0xfc>)
   2df12:	480a      	ldr	r0, [pc, #40]	; (2df3c <z_tick_sleep+0x100>)
   2df14:	f005 fb58 	bl	335c8 <printk>
   2df18:	4809      	ldr	r0, [pc, #36]	; (2df40 <z_tick_sleep+0x104>)
   2df1a:	f005 fb55 	bl	335c8 <printk>
   2df1e:	f240 41a3 	movw	r1, #1187	; 0x4a3
   2df22:	4805      	ldr	r0, [pc, #20]	; (2df38 <z_tick_sleep+0xfc>)
   2df24:	f005 fe51 	bl	33bca <assert_post_action>
	ticks = expected_wakeup_time - z_tick_get_32();
   2df28:	f00a ff84 	bl	38e34 <z_tick_get_32>
   2df2c:	1a24      	subs	r4, r4, r0
   2df2e:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
   2df32:	e79a      	b.n	2de6a <z_tick_sleep+0x2e>
   2df34:	0003fccb 	.word	0x0003fccb
   2df38:	0003fd3d 	.word	0x0003fd3d
   2df3c:	0003b77f 	.word	0x0003b77f
   2df40:	0003cb8b 	.word	0x0003cb8b
   2df44:	0003c751 	.word	0x0003c751
   2df48:	0003c777 	.word	0x0003c777
   2df4c:	0003c78c 	.word	0x0003c78c
   2df50:	200274dc 	.word	0x200274dc
   2df54:	20027510 	.word	0x20027510
   2df58:	0002d2dd 	.word	0x0002d2dd
   2df5c:	0003c7a4 	.word	0x0003c7a4
   2df60:	0003c7bb 	.word	0x0003c7bb
   2df64:	0003fdd4 	.word	0x0003fdd4

0002df68 <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
   2df68:	b538      	push	{r3, r4, r5, lr}
   2df6a:	4604      	mov	r4, r0
   2df6c:	f3ef 8305 	mrs	r3, IPSR
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");
   2df70:	b173      	cbz	r3, 2df90 <z_impl_k_sleep+0x28>
   2df72:	4916      	ldr	r1, [pc, #88]	; (2dfcc <z_impl_k_sleep+0x64>)
   2df74:	f240 43b2 	movw	r3, #1202	; 0x4b2
   2df78:	4a15      	ldr	r2, [pc, #84]	; (2dfd0 <z_impl_k_sleep+0x68>)
   2df7a:	4816      	ldr	r0, [pc, #88]	; (2dfd4 <z_impl_k_sleep+0x6c>)
   2df7c:	f005 fb24 	bl	335c8 <printk>
   2df80:	4815      	ldr	r0, [pc, #84]	; (2dfd8 <z_impl_k_sleep+0x70>)
   2df82:	f005 fb21 	bl	335c8 <printk>
   2df86:	f240 41b2 	movw	r1, #1202	; 0x4b2
   2df8a:	4811      	ldr	r0, [pc, #68]	; (2dfd0 <z_impl_k_sleep+0x68>)
   2df8c:	f005 fe1d 	bl	33bca <assert_post_action>

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2df90:	1c63      	adds	r3, r4, #1
   2df92:	d105      	bne.n	2dfa0 <z_impl_k_sleep+0x38>
		k_thread_suspend(_current);
   2df94:	4b11      	ldr	r3, [pc, #68]	; (2dfdc <z_impl_k_sleep+0x74>)
   2df96:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
   2df98:	f7ff fb1c 	bl	2d5d4 <z_impl_k_thread_suspend>
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
   2df9c:	4620      	mov	r0, r4
   2df9e:	bd38      	pop	{r3, r4, r5, pc}
   2dfa0:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   2dfa4:	f240 30e7 	movw	r0, #999	; 0x3e7
   2dfa8:	2100      	movs	r1, #0
   2dfaa:	2300      	movs	r3, #0
   2dfac:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2dfb0:	fbe5 0104 	umlal	r0, r1, r5, r4
   2dfb4:	f7df fbdc 	bl	d770 <__aeabi_uldivmod>
	ticks = z_tick_sleep(ticks);
   2dfb8:	f7ff ff40 	bl	2de3c <z_tick_sleep>
			return (t * to_hz + off) / from_hz;
   2dfbc:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   2dfc0:	fba0 0103 	umull	r0, r1, r0, r3
   2dfc4:	0bc4      	lsrs	r4, r0, #15
   2dfc6:	ea44 4441 	orr.w	r4, r4, r1, lsl #17
	return k_ticks_to_ms_floor64(ticks);
   2dfca:	e7e7      	b.n	2df9c <z_impl_k_sleep+0x34>
   2dfcc:	0003fccb 	.word	0x0003fccb
   2dfd0:	0003fd3d 	.word	0x0003fd3d
   2dfd4:	0003b77f 	.word	0x0003b77f
   2dfd8:	0003cb8b 	.word	0x0003cb8b
   2dfdc:	200274dc 	.word	0x200274dc

0002dfe0 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
   2dfe0:	4b01      	ldr	r3, [pc, #4]	; (2dfe8 <z_impl_k_current_get+0x8>)
   2dfe2:	6898      	ldr	r0, [r3, #8]
   2dfe4:	4770      	bx	lr
   2dfe6:	bf00      	nop
   2dfe8:	200274dc 	.word	0x200274dc

0002dfec <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
   2dfec:	b538      	push	{r3, r4, r5, lr}
   2dfee:	4604      	mov	r4, r0
   2dff0:	f04f 0320 	mov.w	r3, #32
   2dff4:	f3ef 8511 	mrs	r5, BASEPRI
   2dff8:	f383 8811 	msr	BASEPRI, r3
   2dffc:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e000:	4817      	ldr	r0, [pc, #92]	; (2e060 <z_impl_k_sem_give+0x74>)
   2e002:	f000 fa6d 	bl	2e4e0 <z_spin_lock_valid>
   2e006:	b968      	cbnz	r0, 2e024 <z_impl_k_sem_give+0x38>
   2e008:	235c      	movs	r3, #92	; 0x5c
   2e00a:	4a16      	ldr	r2, [pc, #88]	; (2e064 <z_impl_k_sem_give+0x78>)
   2e00c:	4916      	ldr	r1, [pc, #88]	; (2e068 <z_impl_k_sem_give+0x7c>)
   2e00e:	4817      	ldr	r0, [pc, #92]	; (2e06c <z_impl_k_sem_give+0x80>)
   2e010:	f005 fada 	bl	335c8 <printk>
   2e014:	4912      	ldr	r1, [pc, #72]	; (2e060 <z_impl_k_sem_give+0x74>)
   2e016:	4816      	ldr	r0, [pc, #88]	; (2e070 <z_impl_k_sem_give+0x84>)
   2e018:	f005 fad6 	bl	335c8 <printk>
   2e01c:	215c      	movs	r1, #92	; 0x5c
   2e01e:	4811      	ldr	r0, [pc, #68]	; (2e064 <z_impl_k_sem_give+0x78>)
   2e020:	f005 fdd3 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e024:	480e      	ldr	r0, [pc, #56]	; (2e060 <z_impl_k_sem_give+0x74>)
   2e026:	f000 fa79 	bl	2e51c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
   2e02a:	4620      	mov	r0, r4
   2e02c:	f7ff fdbe 	bl	2dbac <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
   2e030:	b148      	cbz	r0, 2e046 <z_impl_k_sem_give+0x5a>
   2e032:	2200      	movs	r2, #0
   2e034:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
   2e036:	f7ff f909 	bl	2d24c <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
   2e03a:	4629      	mov	r1, r5
}
   2e03c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
   2e040:	4807      	ldr	r0, [pc, #28]	; (2e060 <z_impl_k_sem_give+0x74>)
   2e042:	f7fe bee1 	b.w	2ce08 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2e046:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   2e04a:	429a      	cmp	r2, r3
   2e04c:	bf18      	it	ne
   2e04e:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2e050:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
   2e052:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
   2e054:	f104 0010 	add.w	r0, r4, #16
   2e058:	f00a ff8f 	bl	38f7a <z_handle_obj_poll_events>
   2e05c:	e7ed      	b.n	2e03a <z_impl_k_sem_give+0x4e>
   2e05e:	bf00      	nop
   2e060:	20027520 	.word	0x20027520
   2e064:	0003c751 	.word	0x0003c751
   2e068:	0003c777 	.word	0x0003c777
   2e06c:	0003b77f 	.word	0x0003b77f
   2e070:	0003c78c 	.word	0x0003c78c

0002e074 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
   2e074:	b570      	push	{r4, r5, r6, lr}
   2e076:	4605      	mov	r5, r0
   2e078:	460e      	mov	r6, r1
   2e07a:	f3ef 8305 	mrs	r3, IPSR
	int ret = 0;

	__ASSERT(((arch_is_in_isr() == false) ||
   2e07e:	b16b      	cbz	r3, 2e09c <z_impl_k_sem_take+0x28>
   2e080:	b161      	cbz	r1, 2e09c <z_impl_k_sem_take+0x28>
   2e082:	4934      	ldr	r1, [pc, #208]	; (2e154 <z_impl_k_sem_take+0xe0>)
   2e084:	238d      	movs	r3, #141	; 0x8d
   2e086:	4a34      	ldr	r2, [pc, #208]	; (2e158 <z_impl_k_sem_take+0xe4>)
   2e088:	4834      	ldr	r0, [pc, #208]	; (2e15c <z_impl_k_sem_take+0xe8>)
   2e08a:	f005 fa9d 	bl	335c8 <printk>
   2e08e:	4834      	ldr	r0, [pc, #208]	; (2e160 <z_impl_k_sem_take+0xec>)
   2e090:	f005 fa9a 	bl	335c8 <printk>
   2e094:	218d      	movs	r1, #141	; 0x8d
   2e096:	4830      	ldr	r0, [pc, #192]	; (2e158 <z_impl_k_sem_take+0xe4>)
   2e098:	f005 fd97 	bl	33bca <assert_post_action>
   2e09c:	f04f 0320 	mov.w	r3, #32
   2e0a0:	f3ef 8411 	mrs	r4, BASEPRI
   2e0a4:	f383 8811 	msr	BASEPRI, r3
   2e0a8:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e0ac:	482d      	ldr	r0, [pc, #180]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e0ae:	f000 fa17 	bl	2e4e0 <z_spin_lock_valid>
   2e0b2:	b968      	cbnz	r0, 2e0d0 <z_impl_k_sem_take+0x5c>
   2e0b4:	235c      	movs	r3, #92	; 0x5c
   2e0b6:	4a2c      	ldr	r2, [pc, #176]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e0b8:	492c      	ldr	r1, [pc, #176]	; (2e16c <z_impl_k_sem_take+0xf8>)
   2e0ba:	4828      	ldr	r0, [pc, #160]	; (2e15c <z_impl_k_sem_take+0xe8>)
   2e0bc:	f005 fa84 	bl	335c8 <printk>
   2e0c0:	4928      	ldr	r1, [pc, #160]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e0c2:	482b      	ldr	r0, [pc, #172]	; (2e170 <z_impl_k_sem_take+0xfc>)
   2e0c4:	f005 fa80 	bl	335c8 <printk>
   2e0c8:	215c      	movs	r1, #92	; 0x5c
   2e0ca:	4827      	ldr	r0, [pc, #156]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e0cc:	f005 fd7d 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e0d0:	4824      	ldr	r0, [pc, #144]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e0d2:	f000 fa23 	bl	2e51c <z_spin_lock_set_owner>
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
   2e0d6:	68ab      	ldr	r3, [r5, #8]
   2e0d8:	b1cb      	cbz	r3, 2e10e <z_impl_k_sem_take+0x9a>
		sem->count--;
   2e0da:	3b01      	subs	r3, #1
   2e0dc:	60ab      	str	r3, [r5, #8]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e0de:	4821      	ldr	r0, [pc, #132]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e0e0:	f000 fa0c 	bl	2e4fc <z_spin_unlock_valid>
   2e0e4:	b968      	cbnz	r0, 2e102 <z_impl_k_sem_take+0x8e>
   2e0e6:	2384      	movs	r3, #132	; 0x84
   2e0e8:	4a1f      	ldr	r2, [pc, #124]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e0ea:	4922      	ldr	r1, [pc, #136]	; (2e174 <z_impl_k_sem_take+0x100>)
   2e0ec:	481b      	ldr	r0, [pc, #108]	; (2e15c <z_impl_k_sem_take+0xe8>)
   2e0ee:	f005 fa6b 	bl	335c8 <printk>
   2e0f2:	491c      	ldr	r1, [pc, #112]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e0f4:	4820      	ldr	r0, [pc, #128]	; (2e178 <z_impl_k_sem_take+0x104>)
   2e0f6:	f005 fa67 	bl	335c8 <printk>
   2e0fa:	2184      	movs	r1, #132	; 0x84
   2e0fc:	481a      	ldr	r0, [pc, #104]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e0fe:	f005 fd64 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e102:	f384 8811 	msr	BASEPRI, r4
   2e106:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
   2e10a:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
   2e10c:	bd70      	pop	{r4, r5, r6, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2e10e:	b9c6      	cbnz	r6, 2e142 <z_impl_k_sem_take+0xce>
   2e110:	4814      	ldr	r0, [pc, #80]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e112:	f000 f9f3 	bl	2e4fc <z_spin_unlock_valid>
   2e116:	b968      	cbnz	r0, 2e134 <z_impl_k_sem_take+0xc0>
   2e118:	2384      	movs	r3, #132	; 0x84
   2e11a:	4a13      	ldr	r2, [pc, #76]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e11c:	4915      	ldr	r1, [pc, #84]	; (2e174 <z_impl_k_sem_take+0x100>)
   2e11e:	480f      	ldr	r0, [pc, #60]	; (2e15c <z_impl_k_sem_take+0xe8>)
   2e120:	f005 fa52 	bl	335c8 <printk>
   2e124:	490f      	ldr	r1, [pc, #60]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e126:	4814      	ldr	r0, [pc, #80]	; (2e178 <z_impl_k_sem_take+0x104>)
   2e128:	f005 fa4e 	bl	335c8 <printk>
   2e12c:	2184      	movs	r1, #132	; 0x84
   2e12e:	480e      	ldr	r0, [pc, #56]	; (2e168 <z_impl_k_sem_take+0xf4>)
   2e130:	f005 fd4b 	bl	33bca <assert_post_action>
   2e134:	f384 8811 	msr	BASEPRI, r4
   2e138:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
   2e13c:	f06f 000f 	mvn.w	r0, #15
		goto out;
   2e140:	e7e4      	b.n	2e10c <z_impl_k_sem_take+0x98>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2e142:	4633      	mov	r3, r6
   2e144:	462a      	mov	r2, r5
   2e146:	4621      	mov	r1, r4
}
   2e148:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
   2e14c:	4805      	ldr	r0, [pc, #20]	; (2e164 <z_impl_k_sem_take+0xf0>)
   2e14e:	f7ff bc6f 	b.w	2da30 <z_pend_curr>
   2e152:	bf00      	nop
   2e154:	0003fe34 	.word	0x0003fe34
   2e158:	0003fe14 	.word	0x0003fe14
   2e15c:	0003b77f 	.word	0x0003b77f
   2e160:	0003cb8b 	.word	0x0003cb8b
   2e164:	20027520 	.word	0x20027520
   2e168:	0003c751 	.word	0x0003c751
   2e16c:	0003c777 	.word	0x0003c777
   2e170:	0003c78c 	.word	0x0003c78c
   2e174:	0003c7a4 	.word	0x0003c7a4
   2e178:	0003c7bb 	.word	0x0003c7bb

0002e17c <z_impl_k_stack_push>:
int z_impl_k_stack_push(struct k_stack *stack, stack_data_t data)
{
	struct k_thread *first_pending_thread;
	k_spinlock_key_t key;

	CHECKIF(stack->next == stack->top) {
   2e17c:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
   2e180:	429a      	cmp	r2, r3
{
   2e182:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e186:	4604      	mov	r4, r0
   2e188:	460f      	mov	r7, r1
	CHECKIF(stack->next == stack->top) {
   2e18a:	d04c      	beq.n	2e226 <z_impl_k_stack_push+0xaa>
		return -ENOMEM;
	}

	key = k_spin_lock(&stack->lock);
   2e18c:	f100 0508 	add.w	r5, r0, #8
	__asm__ volatile(
   2e190:	f04f 0320 	mov.w	r3, #32
   2e194:	f3ef 8611 	mrs	r6, BASEPRI
   2e198:	f383 8811 	msr	BASEPRI, r3
   2e19c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e1a0:	4628      	mov	r0, r5
   2e1a2:	f000 f99d 	bl	2e4e0 <z_spin_lock_valid>
   2e1a6:	b968      	cbnz	r0, 2e1c4 <z_impl_k_stack_push+0x48>
   2e1a8:	235c      	movs	r3, #92	; 0x5c
   2e1aa:	4a20      	ldr	r2, [pc, #128]	; (2e22c <z_impl_k_stack_push+0xb0>)
   2e1ac:	4920      	ldr	r1, [pc, #128]	; (2e230 <z_impl_k_stack_push+0xb4>)
   2e1ae:	4821      	ldr	r0, [pc, #132]	; (2e234 <z_impl_k_stack_push+0xb8>)
   2e1b0:	f005 fa0a 	bl	335c8 <printk>
   2e1b4:	4629      	mov	r1, r5
   2e1b6:	4820      	ldr	r0, [pc, #128]	; (2e238 <z_impl_k_stack_push+0xbc>)
   2e1b8:	f005 fa06 	bl	335c8 <printk>
   2e1bc:	215c      	movs	r1, #92	; 0x5c
   2e1be:	481b      	ldr	r0, [pc, #108]	; (2e22c <z_impl_k_stack_push+0xb0>)
   2e1c0:	f005 fd03 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e1c4:	4628      	mov	r0, r5
   2e1c6:	f000 f9a9 	bl	2e51c <z_spin_lock_set_owner>

	first_pending_thread = z_unpend_first_thread(&stack->wait_q);
   2e1ca:	4620      	mov	r0, r4
   2e1cc:	f7ff fcee 	bl	2dbac <z_unpend_first_thread>

	if (first_pending_thread != NULL) {
   2e1d0:	4680      	mov	r8, r0
   2e1d2:	b168      	cbz	r0, 2e1f0 <z_impl_k_stack_push+0x74>
   2e1d4:	2400      	movs	r4, #0
		z_ready_thread(first_pending_thread);
   2e1d6:	f7ff f839 	bl	2d24c <z_ready_thread>
   2e1da:	f8c8 4070 	str.w	r4, [r8, #112]	; 0x70
   2e1de:	f8c8 7014 	str.w	r7, [r8, #20]

		z_thread_return_value_set_with_data(first_pending_thread,
						   0, (void *)data);
		z_reschedule(&stack->lock, key);
   2e1e2:	4631      	mov	r1, r6
   2e1e4:	4628      	mov	r0, r5
   2e1e6:	f7fe fe0f 	bl	2ce08 <z_reschedule>
		*(stack->next) = data;
		stack->next++;
		k_spin_unlock(&stack->lock, key);
	}

	return 0;
   2e1ea:	2000      	movs	r0, #0
}
   2e1ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*(stack->next) = data;
   2e1f0:	6923      	ldr	r3, [r4, #16]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e1f2:	4628      	mov	r0, r5
   2e1f4:	f843 7b04 	str.w	r7, [r3], #4
		stack->next++;
   2e1f8:	6123      	str	r3, [r4, #16]
   2e1fa:	f000 f97f 	bl	2e4fc <z_spin_unlock_valid>
   2e1fe:	b968      	cbnz	r0, 2e21c <z_impl_k_stack_push+0xa0>
   2e200:	2384      	movs	r3, #132	; 0x84
   2e202:	4a0a      	ldr	r2, [pc, #40]	; (2e22c <z_impl_k_stack_push+0xb0>)
   2e204:	490d      	ldr	r1, [pc, #52]	; (2e23c <z_impl_k_stack_push+0xc0>)
   2e206:	480b      	ldr	r0, [pc, #44]	; (2e234 <z_impl_k_stack_push+0xb8>)
   2e208:	f005 f9de 	bl	335c8 <printk>
   2e20c:	4629      	mov	r1, r5
   2e20e:	480c      	ldr	r0, [pc, #48]	; (2e240 <z_impl_k_stack_push+0xc4>)
   2e210:	f005 f9da 	bl	335c8 <printk>
   2e214:	2184      	movs	r1, #132	; 0x84
   2e216:	4805      	ldr	r0, [pc, #20]	; (2e22c <z_impl_k_stack_push+0xb0>)
   2e218:	f005 fcd7 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e21c:	f386 8811 	msr	BASEPRI, r6
   2e220:	f3bf 8f6f 	isb	sy
   2e224:	e7e1      	b.n	2e1ea <z_impl_k_stack_push+0x6e>
		return -ENOMEM;
   2e226:	f06f 000b 	mvn.w	r0, #11
   2e22a:	e7df      	b.n	2e1ec <z_impl_k_stack_push+0x70>
   2e22c:	0003c751 	.word	0x0003c751
   2e230:	0003c777 	.word	0x0003c777
   2e234:	0003b77f 	.word	0x0003b77f
   2e238:	0003c78c 	.word	0x0003c78c
   2e23c:	0003c7a4 	.word	0x0003c7a4
   2e240:	0003c7bb 	.word	0x0003c7bb

0002e244 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
   2e244:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
   2e246:	4c08      	ldr	r4, [pc, #32]	; (2e268 <k_sys_work_q_init+0x24>)
   2e248:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2e24c:	f44f 6200 	mov.w	r2, #2048	; 0x800
   2e250:	4906      	ldr	r1, [pc, #24]	; (2e26c <k_sys_work_q_init+0x28>)
   2e252:	4620      	mov	r0, r4
   2e254:	f000 f96a 	bl	2e52c <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
   2e258:	4905      	ldr	r1, [pc, #20]	; (2e270 <k_sys_work_q_init+0x2c>)
   2e25a:	f104 001c 	add.w	r0, r4, #28
   2e25e:	f00a fd78 	bl	38d52 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
   2e262:	2000      	movs	r0, #0
   2e264:	bd10      	pop	{r4, pc}
   2e266:	bf00      	nop
   2e268:	20027524 	.word	0x20027524
   2e26c:	200351d8 	.word	0x200351d8
   2e270:	0003fe64 	.word	0x0003fe64

0002e274 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
   2e274:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2e278:	b086      	sub	sp, #24
   2e27a:	e9dd 6811 	ldrd	r6, r8, [sp, #68]	; 0x44
	Z_ASSERT_VALID_PRIO(prio, entry);
   2e27e:	2e0f      	cmp	r6, #15
{
   2e280:	4604      	mov	r4, r0
   2e282:	4689      	mov	r9, r1
   2e284:	4692      	mov	sl, r2
   2e286:	461f      	mov	r7, r3
	Z_ASSERT_VALID_PRIO(prio, entry);
   2e288:	d127      	bne.n	2e2da <z_setup_new_thread+0x66>
   2e28a:	4b20      	ldr	r3, [pc, #128]	; (2e30c <z_setup_new_thread+0x98>)
   2e28c:	429f      	cmp	r7, r3
   2e28e:	d128      	bne.n	2e2e2 <z_setup_new_thread+0x6e>
	sys_dlist_init(&w->waitq);
   2e290:	f104 0328 	add.w	r3, r4, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
   2e294:	e9c4 330a 	strd	r3, r3, [r4, #40]	; 0x28
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
	thread_base->thread_state = (u8_t)initial_state;
   2e298:	2304      	movs	r3, #4

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
   2e29a:	2500      	movs	r5, #0
	thread_base->thread_state = (u8_t)initial_state;
   2e29c:	7363      	strb	r3, [r4, #13]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2e29e:	9b10      	ldr	r3, [sp, #64]	; 0x40
	thread_base->user_options = (u8_t)options;
   2e2a0:	f884 800c 	strb.w	r8, [r4, #12]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2e2a4:	9302      	str	r3, [sp, #8]
   2e2a6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	thread_base->prio = priority;
   2e2a8:	73a6      	strb	r6, [r4, #14]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2e2aa:	9301      	str	r3, [sp, #4]
   2e2ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	thread_base->sched_locked = 0U;
   2e2ae:	73e5      	strb	r5, [r4, #15]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2e2b0:	9300      	str	r3, [sp, #0]
	node->prev = NULL;
   2e2b2:	e9c4 5506 	strd	r5, r5, [r4, #24]
   2e2b6:	463b      	mov	r3, r7
   2e2b8:	e9cd 6803 	strd	r6, r8, [sp, #12]
   2e2bc:	4652      	mov	r2, sl
   2e2be:	4649      	mov	r1, r9
   2e2c0:	4620      	mov	r0, r4
   2e2c2:	f7ec fce5 	bl	1ac90 <arch_new_thread>
	if (!_current) {
   2e2c6:	4b12      	ldr	r3, [pc, #72]	; (2e310 <z_setup_new_thread+0x9c>)
	new_thread->fn_abort = NULL;
   2e2c8:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
	if (!_current) {
   2e2cc:	689b      	ldr	r3, [r3, #8]
   2e2ce:	b103      	cbz	r3, 2e2d2 <z_setup_new_thread+0x5e>
	new_thread->resource_pool = _current->resource_pool;
   2e2d0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   2e2d2:	66a3      	str	r3, [r4, #104]	; 0x68
}
   2e2d4:	b006      	add	sp, #24
   2e2d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	Z_ASSERT_VALID_PRIO(prio, entry);
   2e2da:	f106 0310 	add.w	r3, r6, #16
   2e2de:	2b1e      	cmp	r3, #30
   2e2e0:	d9d6      	bls.n	2e290 <z_setup_new_thread+0x1c>
   2e2e2:	f44f 73e7 	mov.w	r3, #462	; 0x1ce
   2e2e6:	4a0b      	ldr	r2, [pc, #44]	; (2e314 <z_setup_new_thread+0xa0>)
   2e2e8:	490b      	ldr	r1, [pc, #44]	; (2e318 <z_setup_new_thread+0xa4>)
   2e2ea:	480c      	ldr	r0, [pc, #48]	; (2e31c <z_setup_new_thread+0xa8>)
   2e2ec:	f005 f96c 	bl	335c8 <printk>
   2e2f0:	4631      	mov	r1, r6
   2e2f2:	f06f 030f 	mvn.w	r3, #15
   2e2f6:	220e      	movs	r2, #14
   2e2f8:	4809      	ldr	r0, [pc, #36]	; (2e320 <z_setup_new_thread+0xac>)
   2e2fa:	f005 f965 	bl	335c8 <printk>
   2e2fe:	f44f 71e7 	mov.w	r1, #462	; 0x1ce
   2e302:	4804      	ldr	r0, [pc, #16]	; (2e314 <z_setup_new_thread+0xa0>)
   2e304:	f005 fc61 	bl	33bca <assert_post_action>
   2e308:	e7c2      	b.n	2e290 <z_setup_new_thread+0x1c>
   2e30a:	bf00      	nop
   2e30c:	0002b979 	.word	0x0002b979
   2e310:	200274dc 	.word	0x200274dc
   2e314:	0003febf 	.word	0x0003febf
   2e318:	0003fee2 	.word	0x0003fee2
   2e31c:	0003b77f 	.word	0x0003b77f
   2e320:	0003ff62 	.word	0x0003ff62

0002e324 <z_impl_k_thread_create>:
{
   2e324:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e328:	b086      	sub	sp, #24
   2e32a:	4604      	mov	r4, r0
   2e32c:	460e      	mov	r6, r1
   2e32e:	4617      	mov	r7, r2
   2e330:	4698      	mov	r8, r3
   2e332:	9d11      	ldr	r5, [sp, #68]	; 0x44
   2e334:	f3ef 8305 	mrs	r3, IPSR
	__ASSERT(!arch_is_in_isr(), "Threads may not be created in ISRs");
   2e338:	b173      	cbz	r3, 2e358 <z_impl_k_thread_create+0x34>
   2e33a:	491f      	ldr	r1, [pc, #124]	; (2e3b8 <z_impl_k_thread_create+0x94>)
   2e33c:	f240 2343 	movw	r3, #579	; 0x243
   2e340:	4a1e      	ldr	r2, [pc, #120]	; (2e3bc <z_impl_k_thread_create+0x98>)
   2e342:	481f      	ldr	r0, [pc, #124]	; (2e3c0 <z_impl_k_thread_create+0x9c>)
   2e344:	f005 f940 	bl	335c8 <printk>
   2e348:	481e      	ldr	r0, [pc, #120]	; (2e3c4 <z_impl_k_thread_create+0xa0>)
   2e34a:	f005 f93d 	bl	335c8 <printk>
   2e34e:	f240 2143 	movw	r1, #579	; 0x243
   2e352:	481a      	ldr	r0, [pc, #104]	; (2e3bc <z_impl_k_thread_create+0x98>)
   2e354:	f005 fc39 	bl	33bca <assert_post_action>
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
   2e358:	2300      	movs	r3, #0
   2e35a:	9305      	str	r3, [sp, #20]
   2e35c:	9b10      	ldr	r3, [sp, #64]	; 0x40
   2e35e:	463a      	mov	r2, r7
   2e360:	9304      	str	r3, [sp, #16]
   2e362:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
   2e364:	4631      	mov	r1, r6
   2e366:	9303      	str	r3, [sp, #12]
   2e368:	9b0e      	ldr	r3, [sp, #56]	; 0x38
   2e36a:	4620      	mov	r0, r4
   2e36c:	9302      	str	r3, [sp, #8]
   2e36e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   2e370:	9301      	str	r3, [sp, #4]
   2e372:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   2e374:	9300      	str	r3, [sp, #0]
   2e376:	4643      	mov	r3, r8
   2e378:	f7ff ff7c 	bl	2e274 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
   2e37c:	1c6b      	adds	r3, r5, #1
   2e37e:	d003      	beq.n	2e388 <z_impl_k_thread_create+0x64>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2e380:	b935      	cbnz	r5, 2e390 <z_impl_k_thread_create+0x6c>
	z_sched_start(thread);
   2e382:	4620      	mov	r0, r4
   2e384:	f7ff f80e 	bl	2d3a4 <z_sched_start>
}
   2e388:	4620      	mov	r0, r4
   2e38a:	b006      	add	sp, #24
   2e38c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return (u32_t)((t * to_hz + off) / from_hz);
   2e390:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2e394:	f240 30e7 	movw	r0, #999	; 0x3e7
   2e398:	2100      	movs	r1, #0
   2e39a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2e39e:	2300      	movs	r3, #0
   2e3a0:	fbe6 0105 	umlal	r0, r1, r6, r5
   2e3a4:	f7df f9e4 	bl	d770 <__aeabi_uldivmod>
   2e3a8:	4907      	ldr	r1, [pc, #28]	; (2e3c8 <z_impl_k_thread_create+0xa4>)
   2e3aa:	1c42      	adds	r2, r0, #1
   2e3ac:	f104 0018 	add.w	r0, r4, #24
   2e3b0:	f000 fa1a 	bl	2e7e8 <z_add_timeout>
   2e3b4:	e7e8      	b.n	2e388 <z_impl_k_thread_create+0x64>
   2e3b6:	bf00      	nop
   2e3b8:	0003fccb 	.word	0x0003fccb
   2e3bc:	0003febf 	.word	0x0003febf
   2e3c0:	0003b77f 	.word	0x0003b77f
   2e3c4:	0003fe6d 	.word	0x0003fe6d
   2e3c8:	0002d2dd 	.word	0x0002d2dd

0002e3cc <z_init_static_threads>:
{
   2e3cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
   2e3d0:	4f3c      	ldr	r7, [pc, #240]	; (2e4c4 <z_init_static_threads+0xf8>)
   2e3d2:	4d3d      	ldr	r5, [pc, #244]	; (2e4c8 <z_init_static_threads+0xfc>)
   2e3d4:	463e      	mov	r6, r7
   2e3d6:	f8df 8100 	ldr.w	r8, [pc, #256]	; 2e4d8 <z_init_static_threads+0x10c>
{
   2e3da:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
   2e3dc:	42bd      	cmp	r5, r7
   2e3de:	d90e      	bls.n	2e3fe <z_init_static_threads+0x32>
   2e3e0:	493a      	ldr	r1, [pc, #232]	; (2e4cc <z_init_static_threads+0x100>)
   2e3e2:	f44f 732a 	mov.w	r3, #680	; 0x2a8
   2e3e6:	4642      	mov	r2, r8
   2e3e8:	4839      	ldr	r0, [pc, #228]	; (2e4d0 <z_init_static_threads+0x104>)
   2e3ea:	f005 f8ed 	bl	335c8 <printk>
   2e3ee:	4839      	ldr	r0, [pc, #228]	; (2e4d4 <z_init_static_threads+0x108>)
   2e3f0:	f005 f8ea 	bl	335c8 <printk>
   2e3f4:	f44f 712a 	mov.w	r1, #680	; 0x2a8
   2e3f8:	4640      	mov	r0, r8
   2e3fa:	f005 fbe6 	bl	33bca <assert_post_action>
   2e3fe:	42b5      	cmp	r5, r6
   2e400:	f105 0430 	add.w	r4, r5, #48	; 0x30
   2e404:	d31f      	bcc.n	2e446 <z_init_static_threads+0x7a>
	k_sched_lock();
   2e406:	f7fe fd3b 	bl	2ce80 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
   2e40a:	4c2f      	ldr	r4, [pc, #188]	; (2e4c8 <z_init_static_threads+0xfc>)
   2e40c:	4d32      	ldr	r5, [pc, #200]	; (2e4d8 <z_init_static_threads+0x10c>)
   2e40e:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 2e4cc <z_init_static_threads+0x100>
   2e412:	f8df 90bc 	ldr.w	r9, [pc, #188]	; 2e4d0 <z_init_static_threads+0x104>
   2e416:	42b4      	cmp	r4, r6
   2e418:	d90e      	bls.n	2e438 <z_init_static_threads+0x6c>
   2e41a:	4641      	mov	r1, r8
   2e41c:	f240 23c7 	movw	r3, #711	; 0x2c7
   2e420:	462a      	mov	r2, r5
   2e422:	4648      	mov	r0, r9
   2e424:	f005 f8d0 	bl	335c8 <printk>
   2e428:	482a      	ldr	r0, [pc, #168]	; (2e4d4 <z_init_static_threads+0x108>)
   2e42a:	f005 f8cd 	bl	335c8 <printk>
   2e42e:	f240 21c7 	movw	r1, #711	; 0x2c7
   2e432:	4628      	mov	r0, r5
   2e434:	f005 fbc9 	bl	33bca <assert_post_action>
   2e438:	42b4      	cmp	r4, r6
   2e43a:	d321      	bcc.n	2e480 <z_init_static_threads+0xb4>
}
   2e43c:	b007      	add	sp, #28
   2e43e:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	k_sched_unlock();
   2e442:	f7fe be3d 	b.w	2d0c0 <k_sched_unlock>
		z_setup_new_thread(
   2e446:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2e44a:	9305      	str	r3, [sp, #20]
   2e44c:	f854 3c10 	ldr.w	r3, [r4, #-16]
   2e450:	9304      	str	r3, [sp, #16]
   2e452:	f854 3c14 	ldr.w	r3, [r4, #-20]
   2e456:	9303      	str	r3, [sp, #12]
   2e458:	f854 3c18 	ldr.w	r3, [r4, #-24]
   2e45c:	9302      	str	r3, [sp, #8]
   2e45e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
   2e462:	9301      	str	r3, [sp, #4]
   2e464:	f854 3c20 	ldr.w	r3, [r4, #-32]
   2e468:	9300      	str	r3, [sp, #0]
   2e46a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
   2e46e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
   2e472:	f7ff feff 	bl	2e274 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
   2e476:	f854 3c30 	ldr.w	r3, [r4, #-48]
   2e47a:	655d      	str	r5, [r3, #84]	; 0x54
   2e47c:	4625      	mov	r5, r4
   2e47e:	e7ad      	b.n	2e3dc <z_init_static_threads+0x10>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
   2e480:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24
   2e484:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
   2e488:	d006      	beq.n	2e498 <z_init_static_threads+0xcc>
			schedule_new_thread(thread_data->init_thread,
   2e48a:	6827      	ldr	r7, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2e48c:	f1bc 0f00 	cmp.w	ip, #0
   2e490:	d104      	bne.n	2e49c <z_init_static_threads+0xd0>
	z_sched_start(thread);
   2e492:	4638      	mov	r0, r7
   2e494:	f7fe ff86 	bl	2d3a4 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
   2e498:	3430      	adds	r4, #48	; 0x30
   2e49a:	e7bc      	b.n	2e416 <z_init_static_threads+0x4a>
   2e49c:	f44f 4e00 	mov.w	lr, #32768	; 0x8000
   2e4a0:	f240 30e7 	movw	r0, #999	; 0x3e7
   2e4a4:	2100      	movs	r1, #0
   2e4a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2e4aa:	2300      	movs	r3, #0
   2e4ac:	fbee 010c 	umlal	r0, r1, lr, ip
   2e4b0:	f7df f95e 	bl	d770 <__aeabi_uldivmod>
   2e4b4:	4909      	ldr	r1, [pc, #36]	; (2e4dc <z_init_static_threads+0x110>)
   2e4b6:	1c42      	adds	r2, r0, #1
   2e4b8:	f107 0018 	add.w	r0, r7, #24
   2e4bc:	f000 f994 	bl	2e7e8 <z_add_timeout>
   2e4c0:	e7ea      	b.n	2e498 <z_init_static_threads+0xcc>
   2e4c2:	bf00      	nop
   2e4c4:	200205e4 	.word	0x200205e4
   2e4c8:	200205b4 	.word	0x200205b4
   2e4cc:	0003fe92 	.word	0x0003fe92
   2e4d0:	0003b77f 	.word	0x0003b77f
   2e4d4:	0003cc09 	.word	0x0003cc09
   2e4d8:	0003febf 	.word	0x0003febf
   2e4dc:	0002d2dd 	.word	0x0002d2dd

0002e4e0 <z_spin_lock_valid>:
 * them in spinlock.h is a giant header ordering headache.
 */
#ifdef CONFIG_SPIN_VALIDATE
bool z_spin_lock_valid(struct k_spinlock *l)
{
	uintptr_t thread_cpu = l->thread_cpu;
   2e4e0:	6800      	ldr	r0, [r0, #0]

	if (thread_cpu) {
   2e4e2:	b138      	cbz	r0, 2e4f4 <z_spin_lock_valid+0x14>
		if ((thread_cpu & 3) == _current_cpu->id) {
   2e4e4:	4b04      	ldr	r3, [pc, #16]	; (2e4f8 <z_spin_lock_valid+0x18>)
   2e4e6:	f000 0003 	and.w	r0, r0, #3
   2e4ea:	7d1b      	ldrb	r3, [r3, #20]
   2e4ec:	1ac0      	subs	r0, r0, r3
   2e4ee:	bf18      	it	ne
   2e4f0:	2001      	movne	r0, #1
   2e4f2:	4770      	bx	lr
			return false;
		}
	}
	return true;
   2e4f4:	2001      	movs	r0, #1
}
   2e4f6:	4770      	bx	lr
   2e4f8:	200274dc 	.word	0x200274dc

0002e4fc <z_spin_unlock_valid>:

bool z_spin_unlock_valid(struct k_spinlock *l)
{
	if (l->thread_cpu != (_current_cpu->id | (uintptr_t)_current)) {
   2e4fc:	4a06      	ldr	r2, [pc, #24]	; (2e518 <z_spin_unlock_valid+0x1c>)
   2e4fe:	7d11      	ldrb	r1, [r2, #20]
   2e500:	6893      	ldr	r3, [r2, #8]
   2e502:	6802      	ldr	r2, [r0, #0]
   2e504:	430b      	orrs	r3, r1
   2e506:	429a      	cmp	r2, r3
   2e508:	f04f 0300 	mov.w	r3, #0
		return false;
	}
	l->thread_cpu = 0;
   2e50c:	bf06      	itte	eq
   2e50e:	6003      	streq	r3, [r0, #0]
	return true;
   2e510:	2001      	moveq	r0, #1
		return false;
   2e512:	4618      	movne	r0, r3
}
   2e514:	4770      	bx	lr
   2e516:	bf00      	nop
   2e518:	200274dc 	.word	0x200274dc

0002e51c <z_spin_lock_set_owner>:

void z_spin_lock_set_owner(struct k_spinlock *l)
{
	l->thread_cpu = _current_cpu->id | (uintptr_t)_current;
   2e51c:	4a02      	ldr	r2, [pc, #8]	; (2e528 <z_spin_lock_set_owner+0xc>)
   2e51e:	7d11      	ldrb	r1, [r2, #20]
   2e520:	6893      	ldr	r3, [r2, #8]
   2e522:	430b      	orrs	r3, r1
   2e524:	6003      	str	r3, [r0, #0]
}
   2e526:	4770      	bx	lr
   2e528:	200274dc 	.word	0x200274dc

0002e52c <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
   2e52c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e530:	4605      	mov	r5, r0
   2e532:	b086      	sub	sp, #24
   2e534:	460e      	mov	r6, r1
   2e536:	4617      	mov	r7, r2
   2e538:	4698      	mov	r8, r3
	z_impl_k_queue_init(queue);
   2e53a:	f00a fba6 	bl	38c8a <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
   2e53e:	f105 041c 	add.w	r4, r5, #28
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
   2e542:	2000      	movs	r0, #0
   2e544:	4b09      	ldr	r3, [pc, #36]	; (2e56c <k_work_q_start+0x40>)
   2e546:	e9cd 0004 	strd	r0, r0, [sp, #16]
   2e54a:	e9cd 0802 	strd	r0, r8, [sp, #8]
   2e54e:	e9cd 5000 	strd	r5, r0, [sp]
   2e552:	463a      	mov	r2, r7
   2e554:	4631      	mov	r1, r6
   2e556:	4620      	mov	r0, r4
   2e558:	f7ff fee4 	bl	2e324 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
   2e55c:	4620      	mov	r0, r4
   2e55e:	4904      	ldr	r1, [pc, #16]	; (2e570 <k_work_q_start+0x44>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
   2e560:	b006      	add	sp, #24
   2e562:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   2e566:	f00a bbf4 	b.w	38d52 <z_impl_k_thread_name_set>
   2e56a:	bf00      	nop
   2e56c:	00033639 	.word	0x00033639
   2e570:	0003ff93 	.word	0x0003ff93

0002e574 <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
   2e574:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2e578:	4606      	mov	r6, r0
   2e57a:	460d      	mov	r5, r1
   2e57c:	4690      	mov	r8, r2
	__asm__ volatile(
   2e57e:	f04f 0320 	mov.w	r3, #32
   2e582:	f3ef 8711 	mrs	r7, BASEPRI
   2e586:	f383 8811 	msr	BASEPRI, r3
   2e58a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e58e:	483a      	ldr	r0, [pc, #232]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e590:	f7ff ffa6 	bl	2e4e0 <z_spin_lock_valid>
   2e594:	b968      	cbnz	r0, 2e5b2 <k_delayed_work_submit_to_queue+0x3e>
   2e596:	235c      	movs	r3, #92	; 0x5c
   2e598:	4a38      	ldr	r2, [pc, #224]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e59a:	4939      	ldr	r1, [pc, #228]	; (2e680 <k_delayed_work_submit_to_queue+0x10c>)
   2e59c:	4839      	ldr	r0, [pc, #228]	; (2e684 <k_delayed_work_submit_to_queue+0x110>)
   2e59e:	f005 f813 	bl	335c8 <printk>
   2e5a2:	4935      	ldr	r1, [pc, #212]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e5a4:	4838      	ldr	r0, [pc, #224]	; (2e688 <k_delayed_work_submit_to_queue+0x114>)
   2e5a6:	f005 f80f 	bl	335c8 <printk>
   2e5aa:	215c      	movs	r1, #92	; 0x5c
   2e5ac:	4833      	ldr	r0, [pc, #204]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e5ae:	f005 fb0c 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e5b2:	4831      	ldr	r0, [pc, #196]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e5b4:	f7ff ffb2 	bl	2e51c <z_spin_lock_set_owner>
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
   2e5b8:	69eb      	ldr	r3, [r5, #28]
   2e5ba:	b30b      	cbz	r3, 2e600 <k_delayed_work_submit_to_queue+0x8c>
   2e5bc:	42b3      	cmp	r3, r6
   2e5be:	d157      	bne.n	2e670 <k_delayed_work_submit_to_queue+0xfc>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
   2e5c0:	4628      	mov	r0, r5
   2e5c2:	f00a fbec 	bl	38d9e <work_cancel>
		/* -EALREADY indicates the work has already completed so this
		 * is likely a recurring work.
		 */
		if (err == -EALREADY) {
   2e5c6:	f110 0f78 	cmn.w	r0, #120	; 0x78
		err = work_cancel(work);
   2e5ca:	4604      	mov	r4, r0
		if (err == -EALREADY) {
   2e5cc:	d01a      	beq.n	2e604 <k_delayed_work_submit_to_queue+0x90>
			err = 0;
		} else if (err < 0) {
   2e5ce:	2800      	cmp	r0, #0
   2e5d0:	da19      	bge.n	2e606 <k_delayed_work_submit_to_queue+0x92>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e5d2:	4829      	ldr	r0, [pc, #164]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e5d4:	f7ff ff92 	bl	2e4fc <z_spin_unlock_valid>
   2e5d8:	b968      	cbnz	r0, 2e5f6 <k_delayed_work_submit_to_queue+0x82>
   2e5da:	2384      	movs	r3, #132	; 0x84
   2e5dc:	4a27      	ldr	r2, [pc, #156]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e5de:	492b      	ldr	r1, [pc, #172]	; (2e68c <k_delayed_work_submit_to_queue+0x118>)
   2e5e0:	4828      	ldr	r0, [pc, #160]	; (2e684 <k_delayed_work_submit_to_queue+0x110>)
   2e5e2:	f004 fff1 	bl	335c8 <printk>
   2e5e6:	4924      	ldr	r1, [pc, #144]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e5e8:	4829      	ldr	r0, [pc, #164]	; (2e690 <k_delayed_work_submit_to_queue+0x11c>)
   2e5ea:	f004 ffed 	bl	335c8 <printk>
   2e5ee:	2184      	movs	r1, #132	; 0x84
   2e5f0:	4822      	ldr	r0, [pc, #136]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e5f2:	f005 faea 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e5f6:	f387 8811 	msr	BASEPRI, r7
   2e5fa:	f3bf 8f6f 	isb	sy
	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);

done:
	k_spin_unlock(&lock, key);
	return err;
   2e5fe:	e021      	b.n	2e644 <k_delayed_work_submit_to_queue+0xd0>
	if (work->work_q == work_q) {
   2e600:	2e00      	cmp	r6, #0
   2e602:	d0dd      	beq.n	2e5c0 <k_delayed_work_submit_to_queue+0x4c>
	int err = 0;
   2e604:	2400      	movs	r4, #0
	work->work_q = work_q;
   2e606:	61ee      	str	r6, [r5, #28]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
   2e608:	f1b8 0f00 	cmp.w	r8, #0
   2e60c:	d11d      	bne.n	2e64a <k_delayed_work_submit_to_queue+0xd6>
   2e60e:	481a      	ldr	r0, [pc, #104]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e610:	f7ff ff74 	bl	2e4fc <z_spin_unlock_valid>
   2e614:	b968      	cbnz	r0, 2e632 <k_delayed_work_submit_to_queue+0xbe>
   2e616:	2384      	movs	r3, #132	; 0x84
   2e618:	4a18      	ldr	r2, [pc, #96]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e61a:	491c      	ldr	r1, [pc, #112]	; (2e68c <k_delayed_work_submit_to_queue+0x118>)
   2e61c:	4819      	ldr	r0, [pc, #100]	; (2e684 <k_delayed_work_submit_to_queue+0x110>)
   2e61e:	f004 ffd3 	bl	335c8 <printk>
   2e622:	4915      	ldr	r1, [pc, #84]	; (2e678 <k_delayed_work_submit_to_queue+0x104>)
   2e624:	481a      	ldr	r0, [pc, #104]	; (2e690 <k_delayed_work_submit_to_queue+0x11c>)
   2e626:	f004 ffcf 	bl	335c8 <printk>
   2e62a:	2184      	movs	r1, #132	; 0x84
   2e62c:	4813      	ldr	r0, [pc, #76]	; (2e67c <k_delayed_work_submit_to_queue+0x108>)
   2e62e:	f005 facc 	bl	33bca <assert_post_action>
   2e632:	f387 8811 	msr	BASEPRI, r7
   2e636:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
   2e63a:	4629      	mov	r1, r5
   2e63c:	4630      	mov	r0, r6
   2e63e:	f00a fb95 	bl	38d6c <k_work_submit_to_queue>
		return 0;
   2e642:	2400      	movs	r4, #0
}
   2e644:	4620      	mov	r0, r4
   2e646:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2e64a:	f44f 4600 	mov.w	r6, #32768	; 0x8000
   2e64e:	f240 30e7 	movw	r0, #999	; 0x3e7
   2e652:	2100      	movs	r1, #0
   2e654:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2e658:	2300      	movs	r3, #0
   2e65a:	fbe6 0108 	umlal	r0, r1, r6, r8
   2e65e:	f7df f887 	bl	d770 <__aeabi_uldivmod>
	z_add_timeout(&work->timeout, work_timeout, delay);
   2e662:	490c      	ldr	r1, [pc, #48]	; (2e694 <k_delayed_work_submit_to_queue+0x120>)
   2e664:	1c42      	adds	r2, r0, #1
   2e666:	f105 000c 	add.w	r0, r5, #12
   2e66a:	f000 f8bd 	bl	2e7e8 <z_add_timeout>
   2e66e:	e7b0      	b.n	2e5d2 <k_delayed_work_submit_to_queue+0x5e>
		err = -EADDRINUSE;
   2e670:	f06f 046f 	mvn.w	r4, #111	; 0x6f
   2e674:	e7ad      	b.n	2e5d2 <k_delayed_work_submit_to_queue+0x5e>
   2e676:	bf00      	nop
   2e678:	200275f8 	.word	0x200275f8
   2e67c:	0003c751 	.word	0x0003c751
   2e680:	0003c777 	.word	0x0003c777
   2e684:	0003b77f 	.word	0x0003b77f
   2e688:	0003c78c 	.word	0x0003c78c
   2e68c:	0003c7a4 	.word	0x0003c7a4
   2e690:	0003c7bb 	.word	0x0003c7bb
   2e694:	00038d95 	.word	0x00038d95

0002e698 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
   2e698:	b538      	push	{r3, r4, r5, lr}
	if (!work->work_q) {
   2e69a:	69c3      	ldr	r3, [r0, #28]
{
   2e69c:	4604      	mov	r4, r0
	if (!work->work_q) {
   2e69e:	2b00      	cmp	r3, #0
   2e6a0:	d038      	beq.n	2e714 <k_delayed_work_cancel+0x7c>
	__asm__ volatile(
   2e6a2:	f04f 0320 	mov.w	r3, #32
   2e6a6:	f3ef 8511 	mrs	r5, BASEPRI
   2e6aa:	f383 8811 	msr	BASEPRI, r3
   2e6ae:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e6b2:	481a      	ldr	r0, [pc, #104]	; (2e71c <k_delayed_work_cancel+0x84>)
   2e6b4:	f7ff ff14 	bl	2e4e0 <z_spin_lock_valid>
   2e6b8:	b968      	cbnz	r0, 2e6d6 <k_delayed_work_cancel+0x3e>
   2e6ba:	235c      	movs	r3, #92	; 0x5c
   2e6bc:	4a18      	ldr	r2, [pc, #96]	; (2e720 <k_delayed_work_cancel+0x88>)
   2e6be:	4919      	ldr	r1, [pc, #100]	; (2e724 <k_delayed_work_cancel+0x8c>)
   2e6c0:	4819      	ldr	r0, [pc, #100]	; (2e728 <k_delayed_work_cancel+0x90>)
   2e6c2:	f004 ff81 	bl	335c8 <printk>
   2e6c6:	4915      	ldr	r1, [pc, #84]	; (2e71c <k_delayed_work_cancel+0x84>)
   2e6c8:	4818      	ldr	r0, [pc, #96]	; (2e72c <k_delayed_work_cancel+0x94>)
   2e6ca:	f004 ff7d 	bl	335c8 <printk>
   2e6ce:	215c      	movs	r1, #92	; 0x5c
   2e6d0:	4813      	ldr	r0, [pc, #76]	; (2e720 <k_delayed_work_cancel+0x88>)
   2e6d2:	f005 fa7a 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e6d6:	4811      	ldr	r0, [pc, #68]	; (2e71c <k_delayed_work_cancel+0x84>)
   2e6d8:	f7ff ff20 	bl	2e51c <z_spin_lock_set_owner>
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
   2e6dc:	4620      	mov	r0, r4
   2e6de:	f00a fb5e 	bl	38d9e <work_cancel>
   2e6e2:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e6e4:	480d      	ldr	r0, [pc, #52]	; (2e71c <k_delayed_work_cancel+0x84>)
   2e6e6:	f7ff ff09 	bl	2e4fc <z_spin_unlock_valid>
   2e6ea:	b968      	cbnz	r0, 2e708 <k_delayed_work_cancel+0x70>
   2e6ec:	2384      	movs	r3, #132	; 0x84
   2e6ee:	4a0c      	ldr	r2, [pc, #48]	; (2e720 <k_delayed_work_cancel+0x88>)
   2e6f0:	490f      	ldr	r1, [pc, #60]	; (2e730 <k_delayed_work_cancel+0x98>)
   2e6f2:	480d      	ldr	r0, [pc, #52]	; (2e728 <k_delayed_work_cancel+0x90>)
   2e6f4:	f004 ff68 	bl	335c8 <printk>
   2e6f8:	4908      	ldr	r1, [pc, #32]	; (2e71c <k_delayed_work_cancel+0x84>)
   2e6fa:	480e      	ldr	r0, [pc, #56]	; (2e734 <k_delayed_work_cancel+0x9c>)
   2e6fc:	f004 ff64 	bl	335c8 <printk>
   2e700:	2184      	movs	r1, #132	; 0x84
   2e702:	4807      	ldr	r0, [pc, #28]	; (2e720 <k_delayed_work_cancel+0x88>)
   2e704:	f005 fa61 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e708:	f385 8811 	msr	BASEPRI, r5
   2e70c:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
   2e710:	4620      	mov	r0, r4
   2e712:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   2e714:	f06f 0415 	mvn.w	r4, #21
   2e718:	e7fa      	b.n	2e710 <k_delayed_work_cancel+0x78>
   2e71a:	bf00      	nop
   2e71c:	200275f8 	.word	0x200275f8
   2e720:	0003c751 	.word	0x0003c751
   2e724:	0003c777 	.word	0x0003c777
   2e728:	0003b77f 	.word	0x0003b77f
   2e72c:	0003c78c 	.word	0x0003c78c
   2e730:	0003c7a4 	.word	0x0003c7a4
   2e734:	0003c7bb 	.word	0x0003c7bb

0002e738 <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
   2e738:	4b03      	ldr	r3, [pc, #12]	; (2e748 <elapsed+0x10>)
   2e73a:	681b      	ldr	r3, [r3, #0]
   2e73c:	b90b      	cbnz	r3, 2e742 <elapsed+0xa>
   2e73e:	f7eb be8f 	b.w	1a460 <z_clock_elapsed>
}
   2e742:	2000      	movs	r0, #0
   2e744:	4770      	bx	lr
   2e746:	bf00      	nop
   2e748:	200275fc 	.word	0x200275fc

0002e74c <next_timeout>:
	return list->head == list;
   2e74c:	4b0b      	ldr	r3, [pc, #44]	; (2e77c <next_timeout+0x30>)

static s32_t next_timeout(void)
{
   2e74e:	b510      	push	{r4, lr}
   2e750:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2e752:	429c      	cmp	r4, r3
   2e754:	bf08      	it	eq
   2e756:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
   2e758:	f7ff ffee 	bl	2e738 <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   2e75c:	b154      	cbz	r4, 2e774 <next_timeout+0x28>
   2e75e:	68a3      	ldr	r3, [r4, #8]
   2e760:	1a18      	subs	r0, r3, r0
   2e762:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
   2e766:	4b06      	ldr	r3, [pc, #24]	; (2e780 <next_timeout+0x34>)
   2e768:	691b      	ldr	r3, [r3, #16]
   2e76a:	b113      	cbz	r3, 2e772 <next_timeout+0x26>
   2e76c:	4298      	cmp	r0, r3
   2e76e:	bfa8      	it	ge
   2e770:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
   2e772:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
   2e774:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
   2e778:	e7f5      	b.n	2e766 <next_timeout+0x1a>
   2e77a:	bf00      	nop
   2e77c:	2002022c 	.word	0x2002022c
   2e780:	200274dc 	.word	0x200274dc

0002e784 <timeout_rem>:
	return ret;
}

/* must be locked */
static k_ticks_t timeout_rem(struct _timeout *timeout)
{
   2e784:	b510      	push	{r4, lr}
	k_ticks_t ticks = 0;

	if (z_is_inactive_timeout(timeout)) {
   2e786:	6804      	ldr	r4, [r0, #0]
   2e788:	b1b4      	cbz	r4, 2e7b8 <timeout_rem+0x34>
	return list->head == list;
   2e78a:	4a0c      	ldr	r2, [pc, #48]	; (2e7bc <timeout_rem+0x38>)
   2e78c:	6813      	ldr	r3, [r2, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2e78e:	4293      	cmp	r3, r2
   2e790:	d010      	beq.n	2e7b4 <timeout_rem+0x30>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2e792:	2400      	movs	r4, #0
   2e794:	6852      	ldr	r2, [r2, #4]
		return 0;
	}

	for (struct _timeout *t = first(); t != NULL; t = next(t)) {
   2e796:	b91b      	cbnz	r3, 2e7a0 <timeout_rem+0x1c>
		if (timeout == t) {
			break;
		}
	}

	return ticks - elapsed();
   2e798:	f7ff ffce 	bl	2e738 <elapsed>
   2e79c:	1a20      	subs	r0, r4, r0
}
   2e79e:	bd10      	pop	{r4, pc}
		ticks += t->dticks;
   2e7a0:	6899      	ldr	r1, [r3, #8]
		if (timeout == t) {
   2e7a2:	4283      	cmp	r3, r0
		ticks += t->dticks;
   2e7a4:	440c      	add	r4, r1
		if (timeout == t) {
   2e7a6:	d0f7      	beq.n	2e798 <timeout_rem+0x14>
   2e7a8:	2b00      	cmp	r3, #0
   2e7aa:	d0f5      	beq.n	2e798 <timeout_rem+0x14>
	return (node == list->tail) ? NULL : node->next;
   2e7ac:	4293      	cmp	r3, r2
   2e7ae:	d0f3      	beq.n	2e798 <timeout_rem+0x14>
   2e7b0:	681b      	ldr	r3, [r3, #0]
   2e7b2:	e7f0      	b.n	2e796 <timeout_rem+0x12>
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2e7b4:	2400      	movs	r4, #0
   2e7b6:	e7ef      	b.n	2e798 <timeout_rem+0x14>
		return 0;
   2e7b8:	4620      	mov	r0, r4
   2e7ba:	e7f0      	b.n	2e79e <timeout_rem+0x1a>
   2e7bc:	2002022c 	.word	0x2002022c

0002e7c0 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
   2e7c0:	6803      	ldr	r3, [r0, #0]
   2e7c2:	b140      	cbz	r0, 2e7d6 <remove_timeout+0x16>
   2e7c4:	4a07      	ldr	r2, [pc, #28]	; (2e7e4 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
   2e7c6:	6852      	ldr	r2, [r2, #4]
   2e7c8:	4290      	cmp	r0, r2
   2e7ca:	d004      	beq.n	2e7d6 <remove_timeout+0x16>
	if (next(t) != NULL) {
   2e7cc:	b11b      	cbz	r3, 2e7d6 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
   2e7ce:	689a      	ldr	r2, [r3, #8]
   2e7d0:	6881      	ldr	r1, [r0, #8]
   2e7d2:	440a      	add	r2, r1
   2e7d4:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
   2e7d6:	6842      	ldr	r2, [r0, #4]
   2e7d8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   2e7da:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2e7dc:	2300      	movs	r3, #0
	node->prev = NULL;
   2e7de:	e9c0 3300 	strd	r3, r3, [r0]
}
   2e7e2:	4770      	bx	lr
   2e7e4:	2002022c 	.word	0x2002022c

0002e7e8 <z_add_timeout>:
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2e7e8:	1c53      	adds	r3, r2, #1
{
   2e7ea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2e7ee:	4604      	mov	r4, r0
   2e7f0:	460e      	mov	r6, r1
   2e7f2:	4615      	mov	r5, r2
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   2e7f4:	d07f      	beq.n	2e8f6 <z_add_timeout+0x10e>
	__ASSERT(!sys_dnode_is_linked(&to->node), "");
   2e7f6:	6803      	ldr	r3, [r0, #0]
   2e7f8:	b163      	cbz	r3, 2e814 <z_add_timeout+0x2c>
   2e7fa:	4943      	ldr	r1, [pc, #268]	; (2e908 <z_add_timeout+0x120>)
   2e7fc:	2367      	movs	r3, #103	; 0x67
   2e7fe:	4a43      	ldr	r2, [pc, #268]	; (2e90c <z_add_timeout+0x124>)
   2e800:	4843      	ldr	r0, [pc, #268]	; (2e910 <z_add_timeout+0x128>)
   2e802:	f004 fee1 	bl	335c8 <printk>
   2e806:	4843      	ldr	r0, [pc, #268]	; (2e914 <z_add_timeout+0x12c>)
   2e808:	f004 fede 	bl	335c8 <printk>
   2e80c:	2167      	movs	r1, #103	; 0x67
   2e80e:	483f      	ldr	r0, [pc, #252]	; (2e90c <z_add_timeout+0x124>)
   2e810:	f005 f9db 	bl	33bca <assert_post_action>
	ticks = MAX(1, ticks);
   2e814:	2d00      	cmp	r5, #0
   2e816:	bf08      	it	eq
   2e818:	2501      	moveq	r5, #1
	to->fn = fn;
   2e81a:	60e6      	str	r6, [r4, #12]
	__asm__ volatile(
   2e81c:	f04f 0320 	mov.w	r3, #32
   2e820:	f3ef 8811 	mrs	r8, BASEPRI
   2e824:	f383 8811 	msr	BASEPRI, r3
   2e828:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e82c:	483a      	ldr	r0, [pc, #232]	; (2e918 <z_add_timeout+0x130>)
   2e82e:	f7ff fe57 	bl	2e4e0 <z_spin_lock_valid>
   2e832:	b968      	cbnz	r0, 2e850 <z_add_timeout+0x68>
   2e834:	235c      	movs	r3, #92	; 0x5c
   2e836:	4a39      	ldr	r2, [pc, #228]	; (2e91c <z_add_timeout+0x134>)
   2e838:	4939      	ldr	r1, [pc, #228]	; (2e920 <z_add_timeout+0x138>)
   2e83a:	4835      	ldr	r0, [pc, #212]	; (2e910 <z_add_timeout+0x128>)
   2e83c:	f004 fec4 	bl	335c8 <printk>
   2e840:	4935      	ldr	r1, [pc, #212]	; (2e918 <z_add_timeout+0x130>)
   2e842:	4838      	ldr	r0, [pc, #224]	; (2e924 <z_add_timeout+0x13c>)
   2e844:	f004 fec0 	bl	335c8 <printk>
   2e848:	215c      	movs	r1, #92	; 0x5c
   2e84a:	4834      	ldr	r0, [pc, #208]	; (2e91c <z_add_timeout+0x134>)
   2e84c:	f005 f9bd 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e850:	4831      	ldr	r0, [pc, #196]	; (2e918 <z_add_timeout+0x130>)
   2e852:	f7ff fe63 	bl	2e51c <z_spin_lock_set_owner>
		to->dticks = ticks + elapsed();
   2e856:	f7ff ff6f 	bl	2e738 <elapsed>
   2e85a:	4405      	add	r5, r0
   2e85c:	60a5      	str	r5, [r4, #8]
	return list->head == list;
   2e85e:	4d32      	ldr	r5, [pc, #200]	; (2e928 <z_add_timeout+0x140>)
   2e860:	682e      	ldr	r6, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2e862:	42ae      	cmp	r6, r5
   2e864:	d005      	beq.n	2e872 <z_add_timeout+0x8a>
			__ASSERT(t->dticks >= 0, "");
   2e866:	4f29      	ldr	r7, [pc, #164]	; (2e90c <z_add_timeout+0x124>)
   2e868:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 2e934 <z_add_timeout+0x14c>
   2e86c:	f8df a0a0 	ldr.w	sl, [pc, #160]	; 2e910 <z_add_timeout+0x128>
		for (t = first(); t != NULL; t = next(t)) {
   2e870:	b936      	cbnz	r6, 2e880 <z_add_timeout+0x98>
	node->prev = list->tail;
   2e872:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   2e874:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   2e876:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   2e878:	686b      	ldr	r3, [r5, #4]
   2e87a:	601c      	str	r4, [r3, #0]
	list->tail = node;
   2e87c:	606c      	str	r4, [r5, #4]
   2e87e:	e01a      	b.n	2e8b6 <z_add_timeout+0xce>
			__ASSERT(t->dticks >= 0, "");
   2e880:	68b3      	ldr	r3, [r6, #8]
   2e882:	2b00      	cmp	r3, #0
   2e884:	da0c      	bge.n	2e8a0 <z_add_timeout+0xb8>
   2e886:	4649      	mov	r1, r9
   2e888:	2370      	movs	r3, #112	; 0x70
   2e88a:	463a      	mov	r2, r7
   2e88c:	4650      	mov	r0, sl
   2e88e:	f004 fe9b 	bl	335c8 <printk>
   2e892:	4820      	ldr	r0, [pc, #128]	; (2e914 <z_add_timeout+0x12c>)
   2e894:	f004 fe98 	bl	335c8 <printk>
   2e898:	2170      	movs	r1, #112	; 0x70
   2e89a:	4638      	mov	r0, r7
   2e89c:	f005 f995 	bl	33bca <assert_post_action>
			if (t->dticks > to->dticks) {
   2e8a0:	68b2      	ldr	r2, [r6, #8]
   2e8a2:	68a3      	ldr	r3, [r4, #8]
   2e8a4:	429a      	cmp	r2, r3
   2e8a6:	dd28      	ble.n	2e8fa <z_add_timeout+0x112>
				t->dticks -= to->dticks;
   2e8a8:	1ad3      	subs	r3, r2, r3
   2e8aa:	60b3      	str	r3, [r6, #8]
	node->prev = successor->prev;
   2e8ac:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   2e8ae:	e9c4 6300 	strd	r6, r3, [r4]
	successor->prev->next = node;
   2e8b2:	601c      	str	r4, [r3, #0]
	successor->prev = node;
   2e8b4:	6074      	str	r4, [r6, #4]
	return list->head == list;
   2e8b6:	682b      	ldr	r3, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2e8b8:	42ab      	cmp	r3, r5
   2e8ba:	d006      	beq.n	2e8ca <z_add_timeout+0xe2>
		if (to == first()) {
   2e8bc:	429c      	cmp	r4, r3
   2e8be:	d104      	bne.n	2e8ca <z_add_timeout+0xe2>
			z_clock_set_timeout(next_timeout(), false);
   2e8c0:	f7ff ff44 	bl	2e74c <next_timeout>
   2e8c4:	2100      	movs	r1, #0
   2e8c6:	f7eb fd67 	bl	1a398 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e8ca:	4813      	ldr	r0, [pc, #76]	; (2e918 <z_add_timeout+0x130>)
   2e8cc:	f7ff fe16 	bl	2e4fc <z_spin_unlock_valid>
   2e8d0:	b968      	cbnz	r0, 2e8ee <z_add_timeout+0x106>
   2e8d2:	2384      	movs	r3, #132	; 0x84
   2e8d4:	4a11      	ldr	r2, [pc, #68]	; (2e91c <z_add_timeout+0x134>)
   2e8d6:	4915      	ldr	r1, [pc, #84]	; (2e92c <z_add_timeout+0x144>)
   2e8d8:	480d      	ldr	r0, [pc, #52]	; (2e910 <z_add_timeout+0x128>)
   2e8da:	f004 fe75 	bl	335c8 <printk>
   2e8de:	490e      	ldr	r1, [pc, #56]	; (2e918 <z_add_timeout+0x130>)
   2e8e0:	4813      	ldr	r0, [pc, #76]	; (2e930 <z_add_timeout+0x148>)
   2e8e2:	f004 fe71 	bl	335c8 <printk>
   2e8e6:	2184      	movs	r1, #132	; 0x84
   2e8e8:	480c      	ldr	r0, [pc, #48]	; (2e91c <z_add_timeout+0x134>)
   2e8ea:	f005 f96e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e8ee:	f388 8811 	msr	BASEPRI, r8
   2e8f2:	f3bf 8f6f 	isb	sy
}
   2e8f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			to->dticks -= t->dticks;
   2e8fa:	1a9b      	subs	r3, r3, r2
   2e8fc:	60a3      	str	r3, [r4, #8]
	return (node == list->tail) ? NULL : node->next;
   2e8fe:	686b      	ldr	r3, [r5, #4]
   2e900:	42b3      	cmp	r3, r6
   2e902:	d0b6      	beq.n	2e872 <z_add_timeout+0x8a>
   2e904:	6836      	ldr	r6, [r6, #0]
   2e906:	e7b3      	b.n	2e870 <z_add_timeout+0x88>
   2e908:	0003ffc1 	.word	0x0003ffc1
   2e90c:	0003ff9d 	.word	0x0003ff9d
   2e910:	0003b77f 	.word	0x0003b77f
   2e914:	0003cb8b 	.word	0x0003cb8b
   2e918:	20027600 	.word	0x20027600
   2e91c:	0003c751 	.word	0x0003c751
   2e920:	0003c777 	.word	0x0003c777
   2e924:	0003c78c 	.word	0x0003c78c
   2e928:	2002022c 	.word	0x2002022c
   2e92c:	0003c7a4 	.word	0x0003c7a4
   2e930:	0003c7bb 	.word	0x0003c7bb
   2e934:	0003ffe1 	.word	0x0003ffe1

0002e938 <z_abort_timeout>:
{
   2e938:	b538      	push	{r3, r4, r5, lr}
   2e93a:	4604      	mov	r4, r0
	__asm__ volatile(
   2e93c:	f04f 0320 	mov.w	r3, #32
   2e940:	f3ef 8511 	mrs	r5, BASEPRI
   2e944:	f383 8811 	msr	BASEPRI, r3
   2e948:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e94c:	481a      	ldr	r0, [pc, #104]	; (2e9b8 <z_abort_timeout+0x80>)
   2e94e:	f7ff fdc7 	bl	2e4e0 <z_spin_lock_valid>
   2e952:	b968      	cbnz	r0, 2e970 <z_abort_timeout+0x38>
   2e954:	235c      	movs	r3, #92	; 0x5c
   2e956:	4a19      	ldr	r2, [pc, #100]	; (2e9bc <z_abort_timeout+0x84>)
   2e958:	4919      	ldr	r1, [pc, #100]	; (2e9c0 <z_abort_timeout+0x88>)
   2e95a:	481a      	ldr	r0, [pc, #104]	; (2e9c4 <z_abort_timeout+0x8c>)
   2e95c:	f004 fe34 	bl	335c8 <printk>
   2e960:	4915      	ldr	r1, [pc, #84]	; (2e9b8 <z_abort_timeout+0x80>)
   2e962:	4819      	ldr	r0, [pc, #100]	; (2e9c8 <z_abort_timeout+0x90>)
   2e964:	f004 fe30 	bl	335c8 <printk>
   2e968:	215c      	movs	r1, #92	; 0x5c
   2e96a:	4814      	ldr	r0, [pc, #80]	; (2e9bc <z_abort_timeout+0x84>)
   2e96c:	f005 f92d 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2e970:	4811      	ldr	r0, [pc, #68]	; (2e9b8 <z_abort_timeout+0x80>)
   2e972:	f7ff fdd3 	bl	2e51c <z_spin_lock_set_owner>
		if (sys_dnode_is_linked(&to->node)) {
   2e976:	6823      	ldr	r3, [r4, #0]
   2e978:	b1db      	cbz	r3, 2e9b2 <z_abort_timeout+0x7a>
			remove_timeout(to);
   2e97a:	4620      	mov	r0, r4
   2e97c:	f7ff ff20 	bl	2e7c0 <remove_timeout>
			ret = 0;
   2e980:	2400      	movs	r4, #0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2e982:	480d      	ldr	r0, [pc, #52]	; (2e9b8 <z_abort_timeout+0x80>)
   2e984:	f7ff fdba 	bl	2e4fc <z_spin_unlock_valid>
   2e988:	b968      	cbnz	r0, 2e9a6 <z_abort_timeout+0x6e>
   2e98a:	2384      	movs	r3, #132	; 0x84
   2e98c:	4a0b      	ldr	r2, [pc, #44]	; (2e9bc <z_abort_timeout+0x84>)
   2e98e:	490f      	ldr	r1, [pc, #60]	; (2e9cc <z_abort_timeout+0x94>)
   2e990:	480c      	ldr	r0, [pc, #48]	; (2e9c4 <z_abort_timeout+0x8c>)
   2e992:	f004 fe19 	bl	335c8 <printk>
   2e996:	4908      	ldr	r1, [pc, #32]	; (2e9b8 <z_abort_timeout+0x80>)
   2e998:	480d      	ldr	r0, [pc, #52]	; (2e9d0 <z_abort_timeout+0x98>)
   2e99a:	f004 fe15 	bl	335c8 <printk>
   2e99e:	2184      	movs	r1, #132	; 0x84
   2e9a0:	4806      	ldr	r0, [pc, #24]	; (2e9bc <z_abort_timeout+0x84>)
   2e9a2:	f005 f912 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2e9a6:	f385 8811 	msr	BASEPRI, r5
   2e9aa:	f3bf 8f6f 	isb	sy
}
   2e9ae:	4620      	mov	r0, r4
   2e9b0:	bd38      	pop	{r3, r4, r5, pc}
	int ret = -EINVAL;
   2e9b2:	f06f 0415 	mvn.w	r4, #21
   2e9b6:	e7e4      	b.n	2e982 <z_abort_timeout+0x4a>
   2e9b8:	20027600 	.word	0x20027600
   2e9bc:	0003c751 	.word	0x0003c751
   2e9c0:	0003c777 	.word	0x0003c777
   2e9c4:	0003b77f 	.word	0x0003b77f
   2e9c8:	0003c78c 	.word	0x0003c78c
   2e9cc:	0003c7a4 	.word	0x0003c7a4
   2e9d0:	0003c7bb 	.word	0x0003c7bb

0002e9d4 <z_timeout_remaining>:

k_ticks_t z_timeout_remaining(struct _timeout *timeout)
{
   2e9d4:	b538      	push	{r3, r4, r5, lr}
   2e9d6:	4604      	mov	r4, r0
	__asm__ volatile(
   2e9d8:	f04f 0320 	mov.w	r3, #32
   2e9dc:	f3ef 8511 	mrs	r5, BASEPRI
   2e9e0:	f383 8811 	msr	BASEPRI, r3
   2e9e4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2e9e8:	4818      	ldr	r0, [pc, #96]	; (2ea4c <z_timeout_remaining+0x78>)
   2e9ea:	f7ff fd79 	bl	2e4e0 <z_spin_lock_valid>
   2e9ee:	b968      	cbnz	r0, 2ea0c <z_timeout_remaining+0x38>
   2e9f0:	235c      	movs	r3, #92	; 0x5c
   2e9f2:	4a17      	ldr	r2, [pc, #92]	; (2ea50 <z_timeout_remaining+0x7c>)
   2e9f4:	4917      	ldr	r1, [pc, #92]	; (2ea54 <z_timeout_remaining+0x80>)
   2e9f6:	4818      	ldr	r0, [pc, #96]	; (2ea58 <z_timeout_remaining+0x84>)
   2e9f8:	f004 fde6 	bl	335c8 <printk>
   2e9fc:	4913      	ldr	r1, [pc, #76]	; (2ea4c <z_timeout_remaining+0x78>)
   2e9fe:	4817      	ldr	r0, [pc, #92]	; (2ea5c <z_timeout_remaining+0x88>)
   2ea00:	f004 fde2 	bl	335c8 <printk>
   2ea04:	215c      	movs	r1, #92	; 0x5c
   2ea06:	4812      	ldr	r0, [pc, #72]	; (2ea50 <z_timeout_remaining+0x7c>)
   2ea08:	f005 f8df 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2ea0c:	480f      	ldr	r0, [pc, #60]	; (2ea4c <z_timeout_remaining+0x78>)
   2ea0e:	f7ff fd85 	bl	2e51c <z_spin_lock_set_owner>
	k_ticks_t ticks = 0;

	LOCKED(&timeout_lock) {
		ticks = timeout_rem(timeout);
   2ea12:	4620      	mov	r0, r4
   2ea14:	f7ff feb6 	bl	2e784 <timeout_rem>
   2ea18:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ea1a:	480c      	ldr	r0, [pc, #48]	; (2ea4c <z_timeout_remaining+0x78>)
   2ea1c:	f7ff fd6e 	bl	2e4fc <z_spin_unlock_valid>
   2ea20:	b968      	cbnz	r0, 2ea3e <z_timeout_remaining+0x6a>
   2ea22:	2384      	movs	r3, #132	; 0x84
   2ea24:	4a0a      	ldr	r2, [pc, #40]	; (2ea50 <z_timeout_remaining+0x7c>)
   2ea26:	490e      	ldr	r1, [pc, #56]	; (2ea60 <z_timeout_remaining+0x8c>)
   2ea28:	480b      	ldr	r0, [pc, #44]	; (2ea58 <z_timeout_remaining+0x84>)
   2ea2a:	f004 fdcd 	bl	335c8 <printk>
   2ea2e:	4907      	ldr	r1, [pc, #28]	; (2ea4c <z_timeout_remaining+0x78>)
   2ea30:	480c      	ldr	r0, [pc, #48]	; (2ea64 <z_timeout_remaining+0x90>)
   2ea32:	f004 fdc9 	bl	335c8 <printk>
   2ea36:	2184      	movs	r1, #132	; 0x84
   2ea38:	4805      	ldr	r0, [pc, #20]	; (2ea50 <z_timeout_remaining+0x7c>)
   2ea3a:	f005 f8c6 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2ea3e:	f385 8811 	msr	BASEPRI, r5
   2ea42:	f3bf 8f6f 	isb	sy
	}

	return ticks;
}
   2ea46:	4620      	mov	r0, r4
   2ea48:	bd38      	pop	{r3, r4, r5, pc}
   2ea4a:	bf00      	nop
   2ea4c:	20027600 	.word	0x20027600
   2ea50:	0003c751 	.word	0x0003c751
   2ea54:	0003c777 	.word	0x0003c777
   2ea58:	0003b77f 	.word	0x0003b77f
   2ea5c:	0003c78c 	.word	0x0003c78c
   2ea60:	0003c7a4 	.word	0x0003c7a4
   2ea64:	0003c7bb 	.word	0x0003c7bb

0002ea68 <z_get_next_timeout_expiry>:

	return ticks;
}

s32_t z_get_next_timeout_expiry(void)
{
   2ea68:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   2ea6a:	f04f 0320 	mov.w	r3, #32
   2ea6e:	f3ef 8511 	mrs	r5, BASEPRI
   2ea72:	f383 8811 	msr	BASEPRI, r3
   2ea76:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2ea7a:	4818      	ldr	r0, [pc, #96]	; (2eadc <z_get_next_timeout_expiry+0x74>)
   2ea7c:	f7ff fd30 	bl	2e4e0 <z_spin_lock_valid>
   2ea80:	b968      	cbnz	r0, 2ea9e <z_get_next_timeout_expiry+0x36>
   2ea82:	235c      	movs	r3, #92	; 0x5c
   2ea84:	4a16      	ldr	r2, [pc, #88]	; (2eae0 <z_get_next_timeout_expiry+0x78>)
   2ea86:	4917      	ldr	r1, [pc, #92]	; (2eae4 <z_get_next_timeout_expiry+0x7c>)
   2ea88:	4817      	ldr	r0, [pc, #92]	; (2eae8 <z_get_next_timeout_expiry+0x80>)
   2ea8a:	f004 fd9d 	bl	335c8 <printk>
   2ea8e:	4913      	ldr	r1, [pc, #76]	; (2eadc <z_get_next_timeout_expiry+0x74>)
   2ea90:	4816      	ldr	r0, [pc, #88]	; (2eaec <z_get_next_timeout_expiry+0x84>)
   2ea92:	f004 fd99 	bl	335c8 <printk>
   2ea96:	215c      	movs	r1, #92	; 0x5c
   2ea98:	4811      	ldr	r0, [pc, #68]	; (2eae0 <z_get_next_timeout_expiry+0x78>)
   2ea9a:	f005 f896 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2ea9e:	480f      	ldr	r0, [pc, #60]	; (2eadc <z_get_next_timeout_expiry+0x74>)
   2eaa0:	f7ff fd3c 	bl	2e51c <z_spin_lock_set_owner>
	s32_t ret = (s32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
   2eaa4:	f7ff fe52 	bl	2e74c <next_timeout>
   2eaa8:	4604      	mov	r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2eaaa:	480c      	ldr	r0, [pc, #48]	; (2eadc <z_get_next_timeout_expiry+0x74>)
   2eaac:	f7ff fd26 	bl	2e4fc <z_spin_unlock_valid>
   2eab0:	b968      	cbnz	r0, 2eace <z_get_next_timeout_expiry+0x66>
   2eab2:	2384      	movs	r3, #132	; 0x84
   2eab4:	4a0a      	ldr	r2, [pc, #40]	; (2eae0 <z_get_next_timeout_expiry+0x78>)
   2eab6:	490e      	ldr	r1, [pc, #56]	; (2eaf0 <z_get_next_timeout_expiry+0x88>)
   2eab8:	480b      	ldr	r0, [pc, #44]	; (2eae8 <z_get_next_timeout_expiry+0x80>)
   2eaba:	f004 fd85 	bl	335c8 <printk>
   2eabe:	4907      	ldr	r1, [pc, #28]	; (2eadc <z_get_next_timeout_expiry+0x74>)
   2eac0:	480c      	ldr	r0, [pc, #48]	; (2eaf4 <z_get_next_timeout_expiry+0x8c>)
   2eac2:	f004 fd81 	bl	335c8 <printk>
   2eac6:	2184      	movs	r1, #132	; 0x84
   2eac8:	4805      	ldr	r0, [pc, #20]	; (2eae0 <z_get_next_timeout_expiry+0x78>)
   2eaca:	f005 f87e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2eace:	f385 8811 	msr	BASEPRI, r5
   2ead2:	f3bf 8f6f 	isb	sy
	}
	return ret;
}
   2ead6:	4620      	mov	r0, r4
   2ead8:	bd38      	pop	{r3, r4, r5, pc}
   2eada:	bf00      	nop
   2eadc:	20027600 	.word	0x20027600
   2eae0:	0003c751 	.word	0x0003c751
   2eae4:	0003c777 	.word	0x0003c777
   2eae8:	0003b77f 	.word	0x0003b77f
   2eaec:	0003c78c 	.word	0x0003c78c
   2eaf0:	0003c7a4 	.word	0x0003c7a4
   2eaf4:	0003c7bb 	.word	0x0003c7bb

0002eaf8 <z_set_timeout_expiry>:

void z_set_timeout_expiry(s32_t ticks, bool idle)
{
   2eaf8:	b570      	push	{r4, r5, r6, lr}
   2eafa:	4604      	mov	r4, r0
   2eafc:	460e      	mov	r6, r1
	__asm__ volatile(
   2eafe:	f04f 0320 	mov.w	r3, #32
   2eb02:	f3ef 8511 	mrs	r5, BASEPRI
   2eb06:	f383 8811 	msr	BASEPRI, r3
   2eb0a:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2eb0e:	481b      	ldr	r0, [pc, #108]	; (2eb7c <z_set_timeout_expiry+0x84>)
   2eb10:	f7ff fce6 	bl	2e4e0 <z_spin_lock_valid>
   2eb14:	b968      	cbnz	r0, 2eb32 <z_set_timeout_expiry+0x3a>
   2eb16:	235c      	movs	r3, #92	; 0x5c
   2eb18:	4a19      	ldr	r2, [pc, #100]	; (2eb80 <z_set_timeout_expiry+0x88>)
   2eb1a:	491a      	ldr	r1, [pc, #104]	; (2eb84 <z_set_timeout_expiry+0x8c>)
   2eb1c:	481a      	ldr	r0, [pc, #104]	; (2eb88 <z_set_timeout_expiry+0x90>)
   2eb1e:	f004 fd53 	bl	335c8 <printk>
   2eb22:	4916      	ldr	r1, [pc, #88]	; (2eb7c <z_set_timeout_expiry+0x84>)
   2eb24:	4819      	ldr	r0, [pc, #100]	; (2eb8c <z_set_timeout_expiry+0x94>)
   2eb26:	f004 fd4f 	bl	335c8 <printk>
   2eb2a:	215c      	movs	r1, #92	; 0x5c
   2eb2c:	4814      	ldr	r0, [pc, #80]	; (2eb80 <z_set_timeout_expiry+0x88>)
   2eb2e:	f005 f84c 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2eb32:	4812      	ldr	r0, [pc, #72]	; (2eb7c <z_set_timeout_expiry+0x84>)
   2eb34:	f7ff fcf2 	bl	2e51c <z_spin_lock_set_owner>
	LOCKED(&timeout_lock) {
		int next = next_timeout();
   2eb38:	f7ff fe08 	bl	2e74c <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   2eb3c:	2801      	cmp	r0, #1
   2eb3e:	dd05      	ble.n	2eb4c <z_set_timeout_expiry+0x54>
   2eb40:	42a0      	cmp	r0, r4
   2eb42:	dd03      	ble.n	2eb4c <z_set_timeout_expiry+0x54>
			z_clock_set_timeout(ticks, idle);
   2eb44:	4631      	mov	r1, r6
   2eb46:	4620      	mov	r0, r4
   2eb48:	f7eb fc26 	bl	1a398 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2eb4c:	480b      	ldr	r0, [pc, #44]	; (2eb7c <z_set_timeout_expiry+0x84>)
   2eb4e:	f7ff fcd5 	bl	2e4fc <z_spin_unlock_valid>
   2eb52:	b968      	cbnz	r0, 2eb70 <z_set_timeout_expiry+0x78>
   2eb54:	2384      	movs	r3, #132	; 0x84
   2eb56:	4a0a      	ldr	r2, [pc, #40]	; (2eb80 <z_set_timeout_expiry+0x88>)
   2eb58:	490d      	ldr	r1, [pc, #52]	; (2eb90 <z_set_timeout_expiry+0x98>)
   2eb5a:	480b      	ldr	r0, [pc, #44]	; (2eb88 <z_set_timeout_expiry+0x90>)
   2eb5c:	f004 fd34 	bl	335c8 <printk>
   2eb60:	4906      	ldr	r1, [pc, #24]	; (2eb7c <z_set_timeout_expiry+0x84>)
   2eb62:	480c      	ldr	r0, [pc, #48]	; (2eb94 <z_set_timeout_expiry+0x9c>)
   2eb64:	f004 fd30 	bl	335c8 <printk>
   2eb68:	2184      	movs	r1, #132	; 0x84
   2eb6a:	4805      	ldr	r0, [pc, #20]	; (2eb80 <z_set_timeout_expiry+0x88>)
   2eb6c:	f005 f82d 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2eb70:	f385 8811 	msr	BASEPRI, r5
   2eb74:	f3bf 8f6f 	isb	sy
		}
	}
}
   2eb78:	bd70      	pop	{r4, r5, r6, pc}
   2eb7a:	bf00      	nop
   2eb7c:	20027600 	.word	0x20027600
   2eb80:	0003c751 	.word	0x0003c751
   2eb84:	0003c777 	.word	0x0003c777
   2eb88:	0003b77f 	.word	0x0003b77f
   2eb8c:	0003c78c 	.word	0x0003c78c
   2eb90:	0003c7a4 	.word	0x0003c7a4
   2eb94:	0003c7bb 	.word	0x0003c7bb

0002eb98 <z_clock_announce>:

void z_clock_announce(s32_t ticks)
{
   2eb98:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   2eb9c:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
   2eb9e:	f7fe fce3 	bl	2d568 <z_time_slice>
	__asm__ volatile(
   2eba2:	f04f 0320 	mov.w	r3, #32
   2eba6:	f3ef 8511 	mrs	r5, BASEPRI
   2ebaa:	f383 8811 	msr	BASEPRI, r3
   2ebae:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2ebb2:	4848      	ldr	r0, [pc, #288]	; (2ecd4 <z_clock_announce+0x13c>)
   2ebb4:	f7ff fc94 	bl	2e4e0 <z_spin_lock_valid>
   2ebb8:	b968      	cbnz	r0, 2ebd6 <z_clock_announce+0x3e>
   2ebba:	235c      	movs	r3, #92	; 0x5c
   2ebbc:	4a46      	ldr	r2, [pc, #280]	; (2ecd8 <z_clock_announce+0x140>)
   2ebbe:	4947      	ldr	r1, [pc, #284]	; (2ecdc <z_clock_announce+0x144>)
   2ebc0:	4847      	ldr	r0, [pc, #284]	; (2ece0 <z_clock_announce+0x148>)
   2ebc2:	f004 fd01 	bl	335c8 <printk>
   2ebc6:	4943      	ldr	r1, [pc, #268]	; (2ecd4 <z_clock_announce+0x13c>)
   2ebc8:	4846      	ldr	r0, [pc, #280]	; (2ece4 <z_clock_announce+0x14c>)
   2ebca:	f004 fcfd 	bl	335c8 <printk>
   2ebce:	215c      	movs	r1, #92	; 0x5c
   2ebd0:	4841      	ldr	r0, [pc, #260]	; (2ecd8 <z_clock_announce+0x140>)
   2ebd2:	f004 fffa 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2ebd6:	4f44      	ldr	r7, [pc, #272]	; (2ece8 <z_clock_announce+0x150>)
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
   2ebd8:	4e44      	ldr	r6, [pc, #272]	; (2ecec <z_clock_announce+0x154>)
   2ebda:	46b9      	mov	r9, r7
   2ebdc:	483d      	ldr	r0, [pc, #244]	; (2ecd4 <z_clock_announce+0x13c>)
	return list->head == list;
   2ebde:	f8df 8118 	ldr.w	r8, [pc, #280]	; 2ecf8 <z_clock_announce+0x160>
   2ebe2:	f7ff fc9b 	bl	2e51c <z_spin_lock_set_owner>
   2ebe6:	6034      	str	r4, [r6, #0]
   2ebe8:	f8d8 4000 	ldr.w	r4, [r8]
   2ebec:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2ebee:	4544      	cmp	r4, r8
   2ebf0:	e9d7 bc00 	ldrd	fp, ip, [r7]
   2ebf4:	d005      	beq.n	2ec02 <z_clock_announce+0x6a>

	while (first() != NULL && first()->dticks <= announce_remaining) {
   2ebf6:	b124      	cbz	r4, 2ec02 <z_clock_announce+0x6a>
   2ebf8:	68a3      	ldr	r3, [r4, #8]
   2ebfa:	4293      	cmp	r3, r2
   2ebfc:	dd26      	ble.n	2ec4c <z_clock_announce+0xb4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
   2ebfe:	1a9b      	subs	r3, r3, r2
   2ec00:	60a3      	str	r3, [r4, #8]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
   2ec02:	2400      	movs	r4, #0
	curr_tick += announce_remaining;
   2ec04:	eb1b 0002 	adds.w	r0, fp, r2
   2ec08:	eb4c 71e2 	adc.w	r1, ip, r2, asr #31
   2ec0c:	e9c9 0100 	strd	r0, r1, [r9]
	announce_remaining = 0;
   2ec10:	6034      	str	r4, [r6, #0]

	z_clock_set_timeout(next_timeout(), false);
   2ec12:	f7ff fd9b 	bl	2e74c <next_timeout>
   2ec16:	4621      	mov	r1, r4
   2ec18:	f7eb fbbe 	bl	1a398 <z_clock_set_timeout>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ec1c:	482d      	ldr	r0, [pc, #180]	; (2ecd4 <z_clock_announce+0x13c>)
   2ec1e:	f7ff fc6d 	bl	2e4fc <z_spin_unlock_valid>
   2ec22:	b968      	cbnz	r0, 2ec40 <z_clock_announce+0xa8>
   2ec24:	2384      	movs	r3, #132	; 0x84
   2ec26:	4a2c      	ldr	r2, [pc, #176]	; (2ecd8 <z_clock_announce+0x140>)
   2ec28:	4931      	ldr	r1, [pc, #196]	; (2ecf0 <z_clock_announce+0x158>)
   2ec2a:	482d      	ldr	r0, [pc, #180]	; (2ece0 <z_clock_announce+0x148>)
   2ec2c:	f004 fccc 	bl	335c8 <printk>
   2ec30:	4928      	ldr	r1, [pc, #160]	; (2ecd4 <z_clock_announce+0x13c>)
   2ec32:	4830      	ldr	r0, [pc, #192]	; (2ecf4 <z_clock_announce+0x15c>)
   2ec34:	f004 fcc8 	bl	335c8 <printk>
   2ec38:	2184      	movs	r1, #132	; 0x84
   2ec3a:	4827      	ldr	r0, [pc, #156]	; (2ecd8 <z_clock_announce+0x140>)
   2ec3c:	f004 ffc5 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2ec40:	f385 8811 	msr	BASEPRI, r5
   2ec44:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
   2ec48:	e8bd 8bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, pc}
		curr_tick += dt;
   2ec4c:	eb1b 0003 	adds.w	r0, fp, r3
   2ec50:	eb4c 71e3 	adc.w	r1, ip, r3, asr #31
		announce_remaining -= dt;
   2ec54:	1ad3      	subs	r3, r2, r3
   2ec56:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
   2ec58:	2300      	movs	r3, #0
		curr_tick += dt;
   2ec5a:	e9c7 0100 	strd	r0, r1, [r7]
		t->dticks = 0;
   2ec5e:	60a3      	str	r3, [r4, #8]
		remove_timeout(t);
   2ec60:	4620      	mov	r0, r4
   2ec62:	f7ff fdad 	bl	2e7c0 <remove_timeout>
   2ec66:	481b      	ldr	r0, [pc, #108]	; (2ecd4 <z_clock_announce+0x13c>)
   2ec68:	f7ff fc48 	bl	2e4fc <z_spin_unlock_valid>
   2ec6c:	b968      	cbnz	r0, 2ec8a <z_clock_announce+0xf2>
   2ec6e:	2384      	movs	r3, #132	; 0x84
   2ec70:	4a19      	ldr	r2, [pc, #100]	; (2ecd8 <z_clock_announce+0x140>)
   2ec72:	491f      	ldr	r1, [pc, #124]	; (2ecf0 <z_clock_announce+0x158>)
   2ec74:	481a      	ldr	r0, [pc, #104]	; (2ece0 <z_clock_announce+0x148>)
   2ec76:	f004 fca7 	bl	335c8 <printk>
   2ec7a:	4916      	ldr	r1, [pc, #88]	; (2ecd4 <z_clock_announce+0x13c>)
   2ec7c:	481d      	ldr	r0, [pc, #116]	; (2ecf4 <z_clock_announce+0x15c>)
   2ec7e:	f004 fca3 	bl	335c8 <printk>
   2ec82:	2184      	movs	r1, #132	; 0x84
   2ec84:	4814      	ldr	r0, [pc, #80]	; (2ecd8 <z_clock_announce+0x140>)
   2ec86:	f004 ffa0 	bl	33bca <assert_post_action>
   2ec8a:	f385 8811 	msr	BASEPRI, r5
   2ec8e:	f3bf 8f6f 	isb	sy
		t->fn(t);
   2ec92:	68e3      	ldr	r3, [r4, #12]
   2ec94:	4620      	mov	r0, r4
   2ec96:	4798      	blx	r3
	__asm__ volatile(
   2ec98:	f04f 0320 	mov.w	r3, #32
   2ec9c:	f3ef 8511 	mrs	r5, BASEPRI
   2eca0:	f383 8811 	msr	BASEPRI, r3
   2eca4:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2eca8:	480a      	ldr	r0, [pc, #40]	; (2ecd4 <z_clock_announce+0x13c>)
   2ecaa:	f7ff fc19 	bl	2e4e0 <z_spin_lock_valid>
   2ecae:	b968      	cbnz	r0, 2eccc <z_clock_announce+0x134>
   2ecb0:	235c      	movs	r3, #92	; 0x5c
   2ecb2:	4a09      	ldr	r2, [pc, #36]	; (2ecd8 <z_clock_announce+0x140>)
   2ecb4:	4909      	ldr	r1, [pc, #36]	; (2ecdc <z_clock_announce+0x144>)
   2ecb6:	480a      	ldr	r0, [pc, #40]	; (2ece0 <z_clock_announce+0x148>)
   2ecb8:	f004 fc86 	bl	335c8 <printk>
   2ecbc:	4905      	ldr	r1, [pc, #20]	; (2ecd4 <z_clock_announce+0x13c>)
   2ecbe:	4809      	ldr	r0, [pc, #36]	; (2ece4 <z_clock_announce+0x14c>)
   2ecc0:	f004 fc82 	bl	335c8 <printk>
   2ecc4:	215c      	movs	r1, #92	; 0x5c
   2ecc6:	4804      	ldr	r0, [pc, #16]	; (2ecd8 <z_clock_announce+0x140>)
   2ecc8:	f004 ff7f 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2eccc:	4801      	ldr	r0, [pc, #4]	; (2ecd4 <z_clock_announce+0x13c>)
   2ecce:	f7ff fc25 	bl	2e51c <z_spin_lock_set_owner>
	return k;
   2ecd2:	e789      	b.n	2ebe8 <z_clock_announce+0x50>
   2ecd4:	20027600 	.word	0x20027600
   2ecd8:	0003c751 	.word	0x0003c751
   2ecdc:	0003c777 	.word	0x0003c777
   2ece0:	0003b77f 	.word	0x0003b77f
   2ece4:	0003c78c 	.word	0x0003c78c
   2ece8:	20020a08 	.word	0x20020a08
   2ecec:	200275fc 	.word	0x200275fc
   2ecf0:	0003c7a4 	.word	0x0003c7a4
   2ecf4:	0003c7bb 	.word	0x0003c7bb
   2ecf8:	2002022c 	.word	0x2002022c

0002ecfc <z_tick_get>:

s64_t z_tick_get(void)
{
   2ecfc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2ed00:	f04f 0320 	mov.w	r3, #32
   2ed04:	f3ef 8611 	mrs	r6, BASEPRI
   2ed08:	f383 8811 	msr	BASEPRI, r3
   2ed0c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2ed10:	481b      	ldr	r0, [pc, #108]	; (2ed80 <z_tick_get+0x84>)
   2ed12:	f7ff fbe5 	bl	2e4e0 <z_spin_lock_valid>
   2ed16:	b968      	cbnz	r0, 2ed34 <z_tick_get+0x38>
   2ed18:	235c      	movs	r3, #92	; 0x5c
   2ed1a:	4a1a      	ldr	r2, [pc, #104]	; (2ed84 <z_tick_get+0x88>)
   2ed1c:	491a      	ldr	r1, [pc, #104]	; (2ed88 <z_tick_get+0x8c>)
   2ed1e:	481b      	ldr	r0, [pc, #108]	; (2ed8c <z_tick_get+0x90>)
   2ed20:	f004 fc52 	bl	335c8 <printk>
   2ed24:	4916      	ldr	r1, [pc, #88]	; (2ed80 <z_tick_get+0x84>)
   2ed26:	481a      	ldr	r0, [pc, #104]	; (2ed90 <z_tick_get+0x94>)
   2ed28:	f004 fc4e 	bl	335c8 <printk>
   2ed2c:	215c      	movs	r1, #92	; 0x5c
   2ed2e:	4815      	ldr	r0, [pc, #84]	; (2ed84 <z_tick_get+0x88>)
   2ed30:	f004 ff4b 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2ed34:	4812      	ldr	r0, [pc, #72]	; (2ed80 <z_tick_get+0x84>)
   2ed36:	f7ff fbf1 	bl	2e51c <z_spin_lock_set_owner>
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
   2ed3a:	f7eb fb91 	bl	1a460 <z_clock_elapsed>
   2ed3e:	4b15      	ldr	r3, [pc, #84]	; (2ed94 <z_tick_get+0x98>)
   2ed40:	e9d3 4500 	ldrd	r4, r5, [r3]
   2ed44:	1827      	adds	r7, r4, r0
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2ed46:	480e      	ldr	r0, [pc, #56]	; (2ed80 <z_tick_get+0x84>)
   2ed48:	f145 0800 	adc.w	r8, r5, #0
   2ed4c:	f7ff fbd6 	bl	2e4fc <z_spin_unlock_valid>
   2ed50:	b968      	cbnz	r0, 2ed6e <z_tick_get+0x72>
   2ed52:	2384      	movs	r3, #132	; 0x84
   2ed54:	4a0b      	ldr	r2, [pc, #44]	; (2ed84 <z_tick_get+0x88>)
   2ed56:	4910      	ldr	r1, [pc, #64]	; (2ed98 <z_tick_get+0x9c>)
   2ed58:	480c      	ldr	r0, [pc, #48]	; (2ed8c <z_tick_get+0x90>)
   2ed5a:	f004 fc35 	bl	335c8 <printk>
   2ed5e:	4908      	ldr	r1, [pc, #32]	; (2ed80 <z_tick_get+0x84>)
   2ed60:	480e      	ldr	r0, [pc, #56]	; (2ed9c <z_tick_get+0xa0>)
   2ed62:	f004 fc31 	bl	335c8 <printk>
   2ed66:	2184      	movs	r1, #132	; 0x84
   2ed68:	4806      	ldr	r0, [pc, #24]	; (2ed84 <z_tick_get+0x88>)
   2ed6a:	f004 ff2e 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2ed6e:	f386 8811 	msr	BASEPRI, r6
   2ed72:	f3bf 8f6f 	isb	sy
	}
	return t;
}
   2ed76:	4638      	mov	r0, r7
   2ed78:	4641      	mov	r1, r8
   2ed7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2ed7e:	bf00      	nop
   2ed80:	20027600 	.word	0x20027600
   2ed84:	0003c751 	.word	0x0003c751
   2ed88:	0003c777 	.word	0x0003c777
   2ed8c:	0003b77f 	.word	0x0003b77f
   2ed90:	0003c78c 	.word	0x0003c78c
   2ed94:	20020a08 	.word	0x20020a08
   2ed98:	0003c7a4 	.word	0x0003c7a4
   2ed9c:	0003c7bb 	.word	0x0003c7bb

0002eda0 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2eda0:	6a02      	ldr	r2, [r0, #32]
{
   2eda2:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2eda4:	1c53      	adds	r3, r2, #1
   2eda6:	2b01      	cmp	r3, #1
{
   2eda8:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
   2edaa:	d902      	bls.n	2edb2 <z_timer_expiration_handler+0x12>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2edac:	490b      	ldr	r1, [pc, #44]	; (2eddc <z_timer_expiration_handler+0x3c>)
   2edae:	f7ff fd1b 	bl	2e7e8 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
   2edb2:	6a63      	ldr	r3, [r4, #36]	; 0x24
   2edb4:	3301      	adds	r3, #1
   2edb6:	6263      	str	r3, [r4, #36]	; 0x24

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
   2edb8:	69a3      	ldr	r3, [r4, #24]
   2edba:	b10b      	cbz	r3, 2edc0 <z_timer_expiration_handler+0x20>
		timer->expiry_fn(timer);
   2edbc:	4620      	mov	r0, r4
   2edbe:	4798      	blx	r3
	return list->head == list;
   2edc0:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
   2edc4:	42a5      	cmp	r5, r4
   2edc6:	d008      	beq.n	2edda <z_timer_expiration_handler+0x3a>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
   2edc8:	b13d      	cbz	r5, 2edda <z_timer_expiration_handler+0x3a>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
   2edca:	4628      	mov	r0, r5
   2edcc:	f7fd ffca 	bl	2cd64 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
   2edd0:	4628      	mov	r0, r5
   2edd2:	f7fe fa3b 	bl	2d24c <z_ready_thread>
   2edd6:	2300      	movs	r3, #0
   2edd8:	672b      	str	r3, [r5, #112]	; 0x70

	arch_thread_return_value_set(thread, 0);
}
   2edda:	bd38      	pop	{r3, r4, r5, pc}
   2eddc:	0002eda1 	.word	0x0002eda1

0002ede0 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
   2ede0:	e92d 4bf0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
   2ede4:	f240 36e7 	movw	r6, #999	; 0x3e7
   2ede8:	2700      	movs	r7, #0
   2edea:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   2edee:	46b3      	mov	fp, r6
   2edf0:	46bc      	mov	ip, r7
   2edf2:	fbe5 bc01 	umlal	fp, ip, r5, r1
   2edf6:	4604      	mov	r4, r0
   2edf8:	4691      	mov	r9, r2
   2edfa:	4661      	mov	r1, ip
   2edfc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2ee00:	2300      	movs	r3, #0
   2ee02:	4658      	mov	r0, fp
   2ee04:	f7de fcb4 	bl	d770 <__aeabi_uldivmod>
   2ee08:	4639      	mov	r1, r7
   2ee0a:	4680      	mov	r8, r0
   2ee0c:	4630      	mov	r0, r6
   2ee0e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2ee12:	2300      	movs	r3, #0
   2ee14:	fbe5 0109 	umlal	r0, r1, r5, r9
   2ee18:	f7de fcaa 	bl	d770 <__aeabi_uldivmod>
   2ee1c:	4605      	mov	r5, r0
	if (Z_TICK_ABS(duration.ticks) < 0) {
		duration.ticks = MAX(duration.ticks - 1, 0);
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
   2ee1e:	4620      	mov	r0, r4
   2ee20:	f7ff fd8a 	bl	2e938 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
   2ee24:	2300      	movs	r3, #0
	period = k_ms_to_ticks_ceil32(period);
   2ee26:	6225      	str	r5, [r4, #32]
	timer->status = 0U;
   2ee28:	6263      	str	r3, [r4, #36]	; 0x24

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2ee2a:	4642      	mov	r2, r8
   2ee2c:	4620      	mov	r0, r4
		     duration);
}
   2ee2e:	e8bd 4bf0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
   2ee32:	4901      	ldr	r1, [pc, #4]	; (2ee38 <z_impl_k_timer_start+0x58>)
   2ee34:	f7ff bcd8 	b.w	2e7e8 <z_add_timeout>
   2ee38:	0002eda1 	.word	0x0002eda1

0002ee3c <k_poll_poller_cb>:

	return events_registered;
}

static int k_poll_poller_cb(struct k_poll_event *event, u32_t state)
{
   2ee3c:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
   2ee3e:	6883      	ldr	r3, [r0, #8]
{
   2ee40:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
   2ee42:	685c      	ldr	r4, [r3, #4]

	__ASSERT(thread != NULL, "poller should have a thread\n");
   2ee44:	b964      	cbnz	r4, 2ee60 <k_poll_poller_cb+0x24>
   2ee46:	4915      	ldr	r1, [pc, #84]	; (2ee9c <k_poll_poller_cb+0x60>)
   2ee48:	23e0      	movs	r3, #224	; 0xe0
   2ee4a:	4a15      	ldr	r2, [pc, #84]	; (2eea0 <k_poll_poller_cb+0x64>)
   2ee4c:	4815      	ldr	r0, [pc, #84]	; (2eea4 <k_poll_poller_cb+0x68>)
   2ee4e:	f004 fbbb 	bl	335c8 <printk>
   2ee52:	4815      	ldr	r0, [pc, #84]	; (2eea8 <k_poll_poller_cb+0x6c>)
   2ee54:	f004 fbb8 	bl	335c8 <printk>
   2ee58:	21e0      	movs	r1, #224	; 0xe0
   2ee5a:	4811      	ldr	r0, [pc, #68]	; (2eea0 <k_poll_poller_cb+0x64>)
   2ee5c:	f004 feb5 	bl	33bca <assert_post_action>

	if (!z_is_thread_pending(thread)) {
   2ee60:	7b63      	ldrb	r3, [r4, #13]
   2ee62:	079a      	lsls	r2, r3, #30
   2ee64:	d401      	bmi.n	2ee6a <k_poll_poller_cb+0x2e>
		return 0;
   2ee66:	2000      	movs	r0, #0
	}

	z_ready_thread(thread);

	return 0;
}
   2ee68:	bd38      	pop	{r3, r4, r5, pc}
	if (z_is_thread_timeout_expired(thread)) {
   2ee6a:	6a23      	ldr	r3, [r4, #32]
   2ee6c:	3302      	adds	r3, #2
   2ee6e:	d012      	beq.n	2ee96 <k_poll_poller_cb+0x5a>
	z_unpend_thread(thread);
   2ee70:	4620      	mov	r0, r4
   2ee72:	f7fe f8ab 	bl	2cfcc <z_unpend_thread>
	arch_thread_return_value_set(thread,
   2ee76:	2d08      	cmp	r5, #8
   2ee78:	bf0c      	ite	eq
   2ee7a:	f06f 0303 	mvneq.w	r3, #3
   2ee7e:	2300      	movne	r3, #0
   2ee80:	6723      	str	r3, [r4, #112]	; 0x70
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
   2ee82:	7b63      	ldrb	r3, [r4, #13]
   2ee84:	06db      	lsls	r3, r3, #27
   2ee86:	d1ee      	bne.n	2ee66 <k_poll_poller_cb+0x2a>
	if (!z_is_thread_ready(thread)) {
   2ee88:	69a5      	ldr	r5, [r4, #24]
   2ee8a:	2d00      	cmp	r5, #0
   2ee8c:	d1eb      	bne.n	2ee66 <k_poll_poller_cb+0x2a>
	z_ready_thread(thread);
   2ee8e:	4620      	mov	r0, r4
   2ee90:	f7fe f9dc 	bl	2d24c <z_ready_thread>
	return 0;
   2ee94:	e7e7      	b.n	2ee66 <k_poll_poller_cb+0x2a>
		return -EAGAIN;
   2ee96:	f06f 000a 	mvn.w	r0, #10
   2ee9a:	e7e5      	b.n	2ee68 <k_poll_poller_cb+0x2c>
   2ee9c:	000400b7 	.word	0x000400b7
   2eea0:	00040096 	.word	0x00040096
   2eea4:	0003b77f 	.word	0x0003b77f
   2eea8:	000400cd 	.word	0x000400cd

0002eeac <clear_event_registrations>:
{
   2eeac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   2eeb0:	2414      	movs	r4, #20
   2eeb2:	4680      	mov	r8, r0
   2eeb4:	4617      	mov	r7, r2
	while (num_events--) {
   2eeb6:	fb04 0401 	mla	r4, r4, r1, r0
		__ASSERT(false, "invalid event type\n");
   2eeba:	4d48      	ldr	r5, [pc, #288]	; (2efdc <clear_event_registrations+0x130>)
   2eebc:	f8df 9158 	ldr.w	r9, [pc, #344]	; 2f018 <clear_event_registrations+0x16c>
   2eec0:	4e47      	ldr	r6, [pc, #284]	; (2efe0 <clear_event_registrations+0x134>)
	while (num_events--) {
   2eec2:	4544      	cmp	r4, r8
   2eec4:	d101      	bne.n	2eeca <clear_event_registrations+0x1e>
}
   2eec6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	event->poller = NULL;
   2eeca:	2300      	movs	r3, #0
   2eecc:	f844 3c0c 	str.w	r3, [r4, #-12]
	switch (event->type) {
   2eed0:	f814 3c07 	ldrb.w	r3, [r4, #-7]
   2eed4:	f003 030f 	and.w	r3, r3, #15
   2eed8:	2b04      	cmp	r3, #4
   2eeda:	d83d      	bhi.n	2ef58 <clear_event_registrations+0xac>
   2eedc:	e8df f003 	tbb	[pc, r3]
   2eee0:	3c032d49 	.word	0x3c032d49
   2eee4:	1e          	.byte	0x1e
   2eee5:	00          	.byte	0x00
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   2eee6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2eeea:	b963      	cbnz	r3, 2ef06 <clear_event_registrations+0x5a>
   2eeec:	493d      	ldr	r1, [pc, #244]	; (2efe4 <clear_event_registrations+0x138>)
   2eeee:	2396      	movs	r3, #150	; 0x96
   2eef0:	462a      	mov	r2, r5
   2eef2:	4630      	mov	r0, r6
   2eef4:	f004 fb68 	bl	335c8 <printk>
   2eef8:	483b      	ldr	r0, [pc, #236]	; (2efe8 <clear_event_registrations+0x13c>)
   2eefa:	f004 fb65 	bl	335c8 <printk>
   2eefe:	2196      	movs	r1, #150	; 0x96
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2ef00:	4628      	mov	r0, r5
   2ef02:	f004 fe62 	bl	33bca <assert_post_action>
	if (remove && sys_dnode_is_linked(&event->_node)) {
   2ef06:	f854 3c14 	ldr.w	r3, [r4, #-20]
   2ef0a:	b393      	cbz	r3, 2ef72 <clear_event_registrations+0xc6>
	node->prev->next = node->next;
   2ef0c:	f854 2c10 	ldr.w	r2, [r4, #-16]
   2ef10:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
   2ef12:	605a      	str	r2, [r3, #4]
	node->next = NULL;
   2ef14:	2300      	movs	r3, #0
	node->prev = NULL;
   2ef16:	e944 3305 	strd	r3, r3, [r4, #-20]
   2ef1a:	e02a      	b.n	2ef72 <clear_event_registrations+0xc6>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   2ef1c:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2ef20:	2b00      	cmp	r3, #0
   2ef22:	d1f0      	bne.n	2ef06 <clear_event_registrations+0x5a>
   2ef24:	4931      	ldr	r1, [pc, #196]	; (2efec <clear_event_registrations+0x140>)
   2ef26:	239a      	movs	r3, #154	; 0x9a
   2ef28:	462a      	mov	r2, r5
   2ef2a:	4630      	mov	r0, r6
   2ef2c:	f004 fb4c 	bl	335c8 <printk>
   2ef30:	482f      	ldr	r0, [pc, #188]	; (2eff0 <clear_event_registrations+0x144>)
   2ef32:	f004 fb49 	bl	335c8 <printk>
   2ef36:	219a      	movs	r1, #154	; 0x9a
   2ef38:	e7e2      	b.n	2ef00 <clear_event_registrations+0x54>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2ef3a:	f854 3c04 	ldr.w	r3, [r4, #-4]
   2ef3e:	2b00      	cmp	r3, #0
   2ef40:	d1e1      	bne.n	2ef06 <clear_event_registrations+0x5a>
   2ef42:	492c      	ldr	r1, [pc, #176]	; (2eff4 <clear_event_registrations+0x148>)
   2ef44:	239e      	movs	r3, #158	; 0x9e
   2ef46:	462a      	mov	r2, r5
   2ef48:	4630      	mov	r0, r6
   2ef4a:	f004 fb3d 	bl	335c8 <printk>
   2ef4e:	482a      	ldr	r0, [pc, #168]	; (2eff8 <clear_event_registrations+0x14c>)
   2ef50:	f004 fb3a 	bl	335c8 <printk>
   2ef54:	219e      	movs	r1, #158	; 0x9e
   2ef56:	e7d3      	b.n	2ef00 <clear_event_registrations+0x54>
		__ASSERT(false, "invalid event type\n");
   2ef58:	4649      	mov	r1, r9
   2ef5a:	23a5      	movs	r3, #165	; 0xa5
   2ef5c:	462a      	mov	r2, r5
   2ef5e:	4630      	mov	r0, r6
   2ef60:	f004 fb32 	bl	335c8 <printk>
   2ef64:	4825      	ldr	r0, [pc, #148]	; (2effc <clear_event_registrations+0x150>)
   2ef66:	f004 fb2f 	bl	335c8 <printk>
   2ef6a:	21a5      	movs	r1, #165	; 0xa5
   2ef6c:	4628      	mov	r0, r5
   2ef6e:	f004 fe2c 	bl	33bca <assert_post_action>
   2ef72:	4823      	ldr	r0, [pc, #140]	; (2f000 <clear_event_registrations+0x154>)
   2ef74:	f7ff fac2 	bl	2e4fc <z_spin_unlock_valid>
   2ef78:	b968      	cbnz	r0, 2ef96 <clear_event_registrations+0xea>
   2ef7a:	2384      	movs	r3, #132	; 0x84
   2ef7c:	4a21      	ldr	r2, [pc, #132]	; (2f004 <clear_event_registrations+0x158>)
   2ef7e:	4922      	ldr	r1, [pc, #136]	; (2f008 <clear_event_registrations+0x15c>)
   2ef80:	4630      	mov	r0, r6
   2ef82:	f004 fb21 	bl	335c8 <printk>
   2ef86:	491e      	ldr	r1, [pc, #120]	; (2f000 <clear_event_registrations+0x154>)
   2ef88:	4820      	ldr	r0, [pc, #128]	; (2f00c <clear_event_registrations+0x160>)
   2ef8a:	f004 fb1d 	bl	335c8 <printk>
   2ef8e:	2184      	movs	r1, #132	; 0x84
   2ef90:	481c      	ldr	r0, [pc, #112]	; (2f004 <clear_event_registrations+0x158>)
   2ef92:	f004 fe1a 	bl	33bca <assert_post_action>
   2ef96:	f387 8811 	msr	BASEPRI, r7
   2ef9a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
   2ef9e:	f04f 0320 	mov.w	r3, #32
   2efa2:	f3ef 8711 	mrs	r7, BASEPRI
   2efa6:	f383 8811 	msr	BASEPRI, r3
   2efaa:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2efae:	4814      	ldr	r0, [pc, #80]	; (2f000 <clear_event_registrations+0x154>)
   2efb0:	f7ff fa96 	bl	2e4e0 <z_spin_lock_valid>
   2efb4:	b968      	cbnz	r0, 2efd2 <clear_event_registrations+0x126>
   2efb6:	235c      	movs	r3, #92	; 0x5c
   2efb8:	4a12      	ldr	r2, [pc, #72]	; (2f004 <clear_event_registrations+0x158>)
   2efba:	4915      	ldr	r1, [pc, #84]	; (2f010 <clear_event_registrations+0x164>)
   2efbc:	4630      	mov	r0, r6
   2efbe:	f004 fb03 	bl	335c8 <printk>
   2efc2:	490f      	ldr	r1, [pc, #60]	; (2f000 <clear_event_registrations+0x154>)
   2efc4:	4813      	ldr	r0, [pc, #76]	; (2f014 <clear_event_registrations+0x168>)
   2efc6:	f004 faff 	bl	335c8 <printk>
   2efca:	215c      	movs	r1, #92	; 0x5c
   2efcc:	480d      	ldr	r0, [pc, #52]	; (2f004 <clear_event_registrations+0x158>)
   2efce:	f004 fdfc 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2efd2:	480b      	ldr	r0, [pc, #44]	; (2f000 <clear_event_registrations+0x154>)
   2efd4:	f7ff faa2 	bl	2e51c <z_spin_lock_set_owner>
	return k;
   2efd8:	3c14      	subs	r4, #20
   2efda:	e772      	b.n	2eec2 <clear_event_registrations+0x16>
   2efdc:	00040096 	.word	0x00040096
   2efe0:	0003b77f 	.word	0x0003b77f
   2efe4:	0003fff0 	.word	0x0003fff0
   2efe8:	0004000a 	.word	0x0004000a
   2efec:	0004001f 	.word	0x0004001f
   2eff0:	0004003b 	.word	0x0004003b
   2eff4:	0004004c 	.word	0x0004004c
   2eff8:	00040069 	.word	0x00040069
   2effc:	00040080 	.word	0x00040080
   2f000:	20027604 	.word	0x20027604
   2f004:	0003c751 	.word	0x0003c751
   2f008:	0003c7a4 	.word	0x0003c7a4
   2f00c:	0003c7bb 	.word	0x0003c7bb
   2f010:	0003c777 	.word	0x0003c777
   2f014:	0003c78c 	.word	0x0003c78c
   2f018:	0003fd3b 	.word	0x0003fd3b

0002f01c <register_events>:
{
   2f01c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
   2f020:	2700      	movs	r7, #0
{
   2f022:	468a      	mov	sl, r1
   2f024:	4615      	mov	r5, r2
   2f026:	4604      	mov	r4, r0
	int events_registered = 0;
   2f028:	46b9      	mov	r9, r7
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2f02a:	4e69      	ldr	r6, [pc, #420]	; (2f1d0 <register_events+0x1b4>)
   2f02c:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 2f210 <register_events+0x1f4>
{
   2f030:	9301      	str	r3, [sp, #4]
	for (int ii = 0; ii < num_events; ii++) {
   2f032:	4557      	cmp	r7, sl
   2f034:	db03      	blt.n	2f03e <register_events+0x22>
}
   2f036:	4648      	mov	r0, r9
   2f038:	b003      	add	sp, #12
   2f03a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   2f03e:	f04f 0320 	mov.w	r3, #32
   2f042:	f3ef 8b11 	mrs	fp, BASEPRI
   2f046:	f383 8811 	msr	BASEPRI, r3
   2f04a:	f3bf 8f6f 	isb	sy
   2f04e:	4630      	mov	r0, r6
   2f050:	f7ff fa46 	bl	2e4e0 <z_spin_lock_valid>
   2f054:	b968      	cbnz	r0, 2f072 <register_events+0x56>
   2f056:	235c      	movs	r3, #92	; 0x5c
   2f058:	4642      	mov	r2, r8
   2f05a:	495e      	ldr	r1, [pc, #376]	; (2f1d4 <register_events+0x1b8>)
   2f05c:	485e      	ldr	r0, [pc, #376]	; (2f1d8 <register_events+0x1bc>)
   2f05e:	f004 fab3 	bl	335c8 <printk>
   2f062:	4631      	mov	r1, r6
   2f064:	485d      	ldr	r0, [pc, #372]	; (2f1dc <register_events+0x1c0>)
   2f066:	f004 faaf 	bl	335c8 <printk>
   2f06a:	215c      	movs	r1, #92	; 0x5c
   2f06c:	4640      	mov	r0, r8
   2f06e:	f004 fdac 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2f072:	4630      	mov	r0, r6
   2f074:	f7ff fa52 	bl	2e51c <z_spin_lock_set_owner>
	switch (event->type) {
   2f078:	7b63      	ldrb	r3, [r4, #13]
   2f07a:	f003 030f 	and.w	r3, r3, #15
   2f07e:	2b04      	cmp	r3, #4
   2f080:	d844      	bhi.n	2f10c <register_events+0xf0>
   2f082:	e8df f003 	tbb	[pc, r3]
   2f086:	3d2d      	.short	0x3d2d
   2f088:	4303      	.short	0x4303
   2f08a:	2a          	.byte	0x2a
   2f08b:	00          	.byte	0x00
		if (k_sem_count_get(event->sem) > 0) {
   2f08c:	6923      	ldr	r3, [r4, #16]
   2f08e:	689b      	ldr	r3, [r3, #8]
   2f090:	b333      	cbz	r3, 2f0e0 <register_events+0xc4>
			*state = K_POLL_STATE_SEM_AVAILABLE;
   2f092:	2202      	movs	r2, #2
	event->poller = NULL;
   2f094:	2100      	movs	r1, #0
	event->state |= state;
   2f096:	68e3      	ldr	r3, [r4, #12]
	event->poller = NULL;
   2f098:	60a1      	str	r1, [r4, #8]
	event->state |= state;
   2f09a:	f3c3 3004 	ubfx	r0, r3, #12, #5
   2f09e:	4302      	orrs	r2, r0
   2f0a0:	f362 3310 	bfi	r3, r2, #12, #5
   2f0a4:	60e3      	str	r3, [r4, #12]
			poller->is_polling = false;
   2f0a6:	7029      	strb	r1, [r5, #0]
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2f0a8:	4630      	mov	r0, r6
   2f0aa:	f7ff fa27 	bl	2e4fc <z_spin_unlock_valid>
   2f0ae:	b968      	cbnz	r0, 2f0cc <register_events+0xb0>
   2f0b0:	2384      	movs	r3, #132	; 0x84
   2f0b2:	4642      	mov	r2, r8
   2f0b4:	494a      	ldr	r1, [pc, #296]	; (2f1e0 <register_events+0x1c4>)
   2f0b6:	4848      	ldr	r0, [pc, #288]	; (2f1d8 <register_events+0x1bc>)
   2f0b8:	f004 fa86 	bl	335c8 <printk>
   2f0bc:	4631      	mov	r1, r6
   2f0be:	4849      	ldr	r0, [pc, #292]	; (2f1e4 <register_events+0x1c8>)
   2f0c0:	f004 fa82 	bl	335c8 <printk>
   2f0c4:	2184      	movs	r1, #132	; 0x84
   2f0c6:	4640      	mov	r0, r8
   2f0c8:	f004 fd7f 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2f0cc:	f38b 8811 	msr	BASEPRI, fp
   2f0d0:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
   2f0d4:	3701      	adds	r7, #1
   2f0d6:	3414      	adds	r4, #20
   2f0d8:	e7ab      	b.n	2f032 <register_events+0x16>
		if (!k_queue_is_empty(event->queue)) {
   2f0da:	6923      	ldr	r3, [r4, #16]
   2f0dc:	681b      	ldr	r3, [r3, #0]
   2f0de:	bb33      	cbnz	r3, 2f12e <register_events+0x112>
		} else if (!just_check && poller->is_polling) {
   2f0e0:	9b01      	ldr	r3, [sp, #4]
   2f0e2:	2b00      	cmp	r3, #0
   2f0e4:	d1e0      	bne.n	2f0a8 <register_events+0x8c>
   2f0e6:	782b      	ldrb	r3, [r5, #0]
   2f0e8:	2b00      	cmp	r3, #0
   2f0ea:	d0dd      	beq.n	2f0a8 <register_events+0x8c>
	switch (event->type) {
   2f0ec:	7b63      	ldrb	r3, [r4, #13]
   2f0ee:	f003 030f 	and.w	r3, r3, #15
   2f0f2:	2b04      	cmp	r3, #4
   2f0f4:	d85d      	bhi.n	2f1b2 <register_events+0x196>
   2f0f6:	e8df f003 	tbb	[pc, r3]
   2f0fa:	4931      	.short	0x4931
   2f0fc:	5c1c      	.short	0x5c1c
   2f0fe:	35          	.byte	0x35
   2f0ff:	00          	.byte	0x00
		if (event->signal->signaled != 0U) {
   2f100:	6923      	ldr	r3, [r4, #16]
   2f102:	689b      	ldr	r3, [r3, #8]
   2f104:	2b00      	cmp	r3, #0
   2f106:	d0eb      	beq.n	2f0e0 <register_events+0xc4>
			*state = K_POLL_STATE_SIGNALED;
   2f108:	2201      	movs	r2, #1
   2f10a:	e7c3      	b.n	2f094 <register_events+0x78>
		__ASSERT(false, "invalid event type (0x%x)\n", event->type);
   2f10c:	2350      	movs	r3, #80	; 0x50
   2f10e:	4a36      	ldr	r2, [pc, #216]	; (2f1e8 <register_events+0x1cc>)
   2f110:	4936      	ldr	r1, [pc, #216]	; (2f1ec <register_events+0x1d0>)
   2f112:	4831      	ldr	r0, [pc, #196]	; (2f1d8 <register_events+0x1bc>)
   2f114:	f004 fa58 	bl	335c8 <printk>
   2f118:	7b61      	ldrb	r1, [r4, #13]
   2f11a:	4835      	ldr	r0, [pc, #212]	; (2f1f0 <register_events+0x1d4>)
   2f11c:	f001 010f 	and.w	r1, r1, #15
   2f120:	f004 fa52 	bl	335c8 <printk>
   2f124:	2150      	movs	r1, #80	; 0x50
   2f126:	4830      	ldr	r0, [pc, #192]	; (2f1e8 <register_events+0x1cc>)
   2f128:	f004 fd4f 	bl	33bca <assert_post_action>
		break;
   2f12c:	e7d8      	b.n	2f0e0 <register_events+0xc4>
			*state = K_POLL_STATE_FIFO_DATA_AVAILABLE;
   2f12e:	2204      	movs	r2, #4
   2f130:	e7b0      	b.n	2f094 <register_events+0x78>
		__ASSERT(event->sem != NULL, "invalid semaphore\n");
   2f132:	6923      	ldr	r3, [r4, #16]
   2f134:	b963      	cbnz	r3, 2f150 <register_events+0x134>
   2f136:	492f      	ldr	r1, [pc, #188]	; (2f1f4 <register_events+0x1d8>)
   2f138:	2375      	movs	r3, #117	; 0x75
   2f13a:	4a2b      	ldr	r2, [pc, #172]	; (2f1e8 <register_events+0x1cc>)
   2f13c:	4826      	ldr	r0, [pc, #152]	; (2f1d8 <register_events+0x1bc>)
   2f13e:	f004 fa43 	bl	335c8 <printk>
   2f142:	482d      	ldr	r0, [pc, #180]	; (2f1f8 <register_events+0x1dc>)
   2f144:	f004 fa40 	bl	335c8 <printk>
   2f148:	2175      	movs	r1, #117	; 0x75
   2f14a:	4827      	ldr	r0, [pc, #156]	; (2f1e8 <register_events+0x1cc>)
   2f14c:	f004 fd3d 	bl	33bca <assert_post_action>
		add_event(&event->sem->poll_events, event, poller);
   2f150:	462a      	mov	r2, r5
   2f152:	4621      	mov	r1, r4
   2f154:	6920      	ldr	r0, [r4, #16]
   2f156:	3010      	adds	r0, #16
		add_event(&event->queue->poll_events, event, poller);
   2f158:	f009 fee1 	bl	38f1e <add_event>
	event->poller = poller;
   2f15c:	60a5      	str	r5, [r4, #8]
				events_registered += 1;
   2f15e:	f109 0901 	add.w	r9, r9, #1
   2f162:	e7a1      	b.n	2f0a8 <register_events+0x8c>
		__ASSERT(event->queue != NULL, "invalid queue\n");
   2f164:	6923      	ldr	r3, [r4, #16]
   2f166:	b963      	cbnz	r3, 2f182 <register_events+0x166>
   2f168:	4924      	ldr	r1, [pc, #144]	; (2f1fc <register_events+0x1e0>)
   2f16a:	2379      	movs	r3, #121	; 0x79
   2f16c:	4a1e      	ldr	r2, [pc, #120]	; (2f1e8 <register_events+0x1cc>)
   2f16e:	481a      	ldr	r0, [pc, #104]	; (2f1d8 <register_events+0x1bc>)
   2f170:	f004 fa2a 	bl	335c8 <printk>
   2f174:	4822      	ldr	r0, [pc, #136]	; (2f200 <register_events+0x1e4>)
   2f176:	f004 fa27 	bl	335c8 <printk>
   2f17a:	2179      	movs	r1, #121	; 0x79
   2f17c:	481a      	ldr	r0, [pc, #104]	; (2f1e8 <register_events+0x1cc>)
   2f17e:	f004 fd24 	bl	33bca <assert_post_action>
		add_event(&event->queue->poll_events, event, poller);
   2f182:	6920      	ldr	r0, [r4, #16]
   2f184:	462a      	mov	r2, r5
   2f186:	4621      	mov	r1, r4
   2f188:	3014      	adds	r0, #20
   2f18a:	e7e5      	b.n	2f158 <register_events+0x13c>
		__ASSERT(event->signal != NULL, "invalid poll signal\n");
   2f18c:	6923      	ldr	r3, [r4, #16]
   2f18e:	b963      	cbnz	r3, 2f1aa <register_events+0x18e>
   2f190:	491c      	ldr	r1, [pc, #112]	; (2f204 <register_events+0x1e8>)
   2f192:	237d      	movs	r3, #125	; 0x7d
   2f194:	4a14      	ldr	r2, [pc, #80]	; (2f1e8 <register_events+0x1cc>)
   2f196:	4810      	ldr	r0, [pc, #64]	; (2f1d8 <register_events+0x1bc>)
   2f198:	f004 fa16 	bl	335c8 <printk>
   2f19c:	481a      	ldr	r0, [pc, #104]	; (2f208 <register_events+0x1ec>)
   2f19e:	f004 fa13 	bl	335c8 <printk>
   2f1a2:	217d      	movs	r1, #125	; 0x7d
   2f1a4:	4810      	ldr	r0, [pc, #64]	; (2f1e8 <register_events+0x1cc>)
   2f1a6:	f004 fd10 	bl	33bca <assert_post_action>
		add_event(&event->signal->poll_events, event, poller);
   2f1aa:	462a      	mov	r2, r5
   2f1ac:	4621      	mov	r1, r4
   2f1ae:	6920      	ldr	r0, [r4, #16]
   2f1b0:	e7d2      	b.n	2f158 <register_events+0x13c>
		__ASSERT(false, "invalid event type\n");
   2f1b2:	2384      	movs	r3, #132	; 0x84
   2f1b4:	4a0c      	ldr	r2, [pc, #48]	; (2f1e8 <register_events+0x1cc>)
   2f1b6:	490d      	ldr	r1, [pc, #52]	; (2f1ec <register_events+0x1d0>)
   2f1b8:	4807      	ldr	r0, [pc, #28]	; (2f1d8 <register_events+0x1bc>)
   2f1ba:	f004 fa05 	bl	335c8 <printk>
   2f1be:	4813      	ldr	r0, [pc, #76]	; (2f20c <register_events+0x1f0>)
   2f1c0:	f004 fa02 	bl	335c8 <printk>
   2f1c4:	2184      	movs	r1, #132	; 0x84
   2f1c6:	4808      	ldr	r0, [pc, #32]	; (2f1e8 <register_events+0x1cc>)
   2f1c8:	f004 fcff 	bl	33bca <assert_post_action>
		break;
   2f1cc:	e7c6      	b.n	2f15c <register_events+0x140>
   2f1ce:	bf00      	nop
   2f1d0:	20027604 	.word	0x20027604
   2f1d4:	0003c777 	.word	0x0003c777
   2f1d8:	0003b77f 	.word	0x0003b77f
   2f1dc:	0003c78c 	.word	0x0003c78c
   2f1e0:	0003c7a4 	.word	0x0003c7a4
   2f1e4:	0003c7bb 	.word	0x0003c7bb
   2f1e8:	00040096 	.word	0x00040096
   2f1ec:	0003fd3b 	.word	0x0003fd3b
   2f1f0:	000400ec 	.word	0x000400ec
   2f1f4:	0003fff0 	.word	0x0003fff0
   2f1f8:	0004000a 	.word	0x0004000a
   2f1fc:	0004001f 	.word	0x0004001f
   2f200:	0004003b 	.word	0x0004003b
   2f204:	0004004c 	.word	0x0004004c
   2f208:	00040069 	.word	0x00040069
   2f20c:	00040080 	.word	0x00040080
   2f210:	0003c751 	.word	0x0003c751

0002f214 <z_impl_k_poll>:
int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
   2f214:	2301      	movs	r3, #1
{
   2f216:	b5f0      	push	{r4, r5, r6, r7, lr}
   2f218:	b087      	sub	sp, #28
	struct _poller poller = { .is_polling = true,
   2f21a:	f88d 300c 	strb.w	r3, [sp, #12]
				  .thread     = _current,
   2f21e:	4b71      	ldr	r3, [pc, #452]	; (2f3e4 <z_impl_k_poll+0x1d0>)
{
   2f220:	4604      	mov	r4, r0
	struct _poller poller = { .is_polling = true,
   2f222:	689b      	ldr	r3, [r3, #8]
{
   2f224:	460d      	mov	r5, r1
	struct _poller poller = { .is_polling = true,
   2f226:	9304      	str	r3, [sp, #16]
   2f228:	4b6f      	ldr	r3, [pc, #444]	; (2f3e8 <z_impl_k_poll+0x1d4>)
{
   2f22a:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
   2f22c:	9305      	str	r3, [sp, #20]
   2f22e:	f3ef 8305 	mrs	r3, IPSR
				  .cb         = k_poll_poller_cb };

	__ASSERT(!arch_is_in_isr(), "");
   2f232:	b173      	cbz	r3, 2f252 <z_impl_k_poll+0x3e>
   2f234:	496d      	ldr	r1, [pc, #436]	; (2f3ec <z_impl_k_poll+0x1d8>)
   2f236:	f44f 7380 	mov.w	r3, #256	; 0x100
   2f23a:	4a6d      	ldr	r2, [pc, #436]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f23c:	486d      	ldr	r0, [pc, #436]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f23e:	f004 f9c3 	bl	335c8 <printk>
   2f242:	486d      	ldr	r0, [pc, #436]	; (2f3f8 <z_impl_k_poll+0x1e4>)
   2f244:	f004 f9c0 	bl	335c8 <printk>
   2f248:	f44f 7180 	mov.w	r1, #256	; 0x100
   2f24c:	4868      	ldr	r0, [pc, #416]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f24e:	f004 fcbc 	bl	33bca <assert_post_action>
	__ASSERT(events != NULL, "NULL events\n");
   2f252:	b974      	cbnz	r4, 2f272 <z_impl_k_poll+0x5e>
   2f254:	4969      	ldr	r1, [pc, #420]	; (2f3fc <z_impl_k_poll+0x1e8>)
   2f256:	f240 1301 	movw	r3, #257	; 0x101
   2f25a:	4a65      	ldr	r2, [pc, #404]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f25c:	4865      	ldr	r0, [pc, #404]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f25e:	f004 f9b3 	bl	335c8 <printk>
   2f262:	4867      	ldr	r0, [pc, #412]	; (2f400 <z_impl_k_poll+0x1ec>)
   2f264:	f004 f9b0 	bl	335c8 <printk>
   2f268:	f240 1101 	movw	r1, #257	; 0x101
   2f26c:	4860      	ldr	r0, [pc, #384]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f26e:	f004 fcac 	bl	33bca <assert_post_action>
	__ASSERT(num_events >= 0, "<0 events\n");
   2f272:	2d00      	cmp	r5, #0
   2f274:	da0e      	bge.n	2f294 <z_impl_k_poll+0x80>
   2f276:	4963      	ldr	r1, [pc, #396]	; (2f404 <z_impl_k_poll+0x1f0>)
   2f278:	f44f 7381 	mov.w	r3, #258	; 0x102
   2f27c:	4a5c      	ldr	r2, [pc, #368]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f27e:	485d      	ldr	r0, [pc, #372]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f280:	f004 f9a2 	bl	335c8 <printk>
   2f284:	4860      	ldr	r0, [pc, #384]	; (2f408 <z_impl_k_poll+0x1f4>)
   2f286:	f004 f99f 	bl	335c8 <printk>
   2f28a:	f44f 7181 	mov.w	r1, #258	; 0x102
   2f28e:	4858      	ldr	r0, [pc, #352]	; (2f3f0 <z_impl_k_poll+0x1dc>)
   2f290:	f004 fc9b 	bl	33bca <assert_post_action>

	events_registered = register_events(events, num_events, &poller,
   2f294:	fab6 f386 	clz	r3, r6
   2f298:	aa03      	add	r2, sp, #12
   2f29a:	095b      	lsrs	r3, r3, #5
   2f29c:	4629      	mov	r1, r5
   2f29e:	4620      	mov	r0, r4
   2f2a0:	f7ff febc 	bl	2f01c <register_events>
   2f2a4:	4607      	mov	r7, r0
	__asm__ volatile(
   2f2a6:	f04f 0320 	mov.w	r3, #32
   2f2aa:	f3ef 8511 	mrs	r5, BASEPRI
   2f2ae:	f383 8811 	msr	BASEPRI, r3
   2f2b2:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2f2b6:	4855      	ldr	r0, [pc, #340]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f2b8:	f7ff f912 	bl	2e4e0 <z_spin_lock_valid>
   2f2bc:	b968      	cbnz	r0, 2f2da <z_impl_k_poll+0xc6>
   2f2be:	235c      	movs	r3, #92	; 0x5c
   2f2c0:	4a53      	ldr	r2, [pc, #332]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f2c2:	4954      	ldr	r1, [pc, #336]	; (2f414 <z_impl_k_poll+0x200>)
   2f2c4:	484b      	ldr	r0, [pc, #300]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f2c6:	f004 f97f 	bl	335c8 <printk>
   2f2ca:	4950      	ldr	r1, [pc, #320]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f2cc:	4852      	ldr	r0, [pc, #328]	; (2f418 <z_impl_k_poll+0x204>)
   2f2ce:	f004 f97b 	bl	335c8 <printk>
   2f2d2:	215c      	movs	r1, #92	; 0x5c
   2f2d4:	484e      	ldr	r0, [pc, #312]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f2d6:	f004 fc78 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2f2da:	484c      	ldr	r0, [pc, #304]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f2dc:	f7ff f91e 	bl	2e51c <z_spin_lock_set_owner>
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
   2f2e0:	f89d 300c 	ldrb.w	r3, [sp, #12]
   2f2e4:	b9f3      	cbnz	r3, 2f324 <z_impl_k_poll+0x110>
		clear_event_registrations(events, events_registered, key);
   2f2e6:	4620      	mov	r0, r4
   2f2e8:	462a      	mov	r2, r5
   2f2ea:	4639      	mov	r1, r7
   2f2ec:	f7ff fdde 	bl	2eeac <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2f2f0:	4846      	ldr	r0, [pc, #280]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f2f2:	f7ff f903 	bl	2e4fc <z_spin_unlock_valid>
   2f2f6:	b968      	cbnz	r0, 2f314 <z_impl_k_poll+0x100>
   2f2f8:	2384      	movs	r3, #132	; 0x84
   2f2fa:	4a45      	ldr	r2, [pc, #276]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f2fc:	4947      	ldr	r1, [pc, #284]	; (2f41c <z_impl_k_poll+0x208>)
   2f2fe:	483d      	ldr	r0, [pc, #244]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f300:	f004 f962 	bl	335c8 <printk>
   2f304:	4941      	ldr	r1, [pc, #260]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f306:	4846      	ldr	r0, [pc, #280]	; (2f420 <z_impl_k_poll+0x20c>)
   2f308:	f004 f95e 	bl	335c8 <printk>
   2f30c:	2184      	movs	r1, #132	; 0x84
   2f30e:	4840      	ldr	r0, [pc, #256]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f310:	f004 fc5b 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2f314:	f385 8811 	msr	BASEPRI, r5
   2f318:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		return 0;
   2f31c:	2500      	movs	r5, #0
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
   2f31e:	4628      	mov	r0, r5
   2f320:	b007      	add	sp, #28
   2f322:	bdf0      	pop	{r4, r5, r6, r7, pc}
	poller.is_polling = false;
   2f324:	2300      	movs	r3, #0
   2f326:	f88d 300c 	strb.w	r3, [sp, #12]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   2f32a:	b9c6      	cbnz	r6, 2f35e <z_impl_k_poll+0x14a>
   2f32c:	4837      	ldr	r0, [pc, #220]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f32e:	f7ff f8e5 	bl	2e4fc <z_spin_unlock_valid>
   2f332:	b968      	cbnz	r0, 2f350 <z_impl_k_poll+0x13c>
   2f334:	2384      	movs	r3, #132	; 0x84
   2f336:	4a36      	ldr	r2, [pc, #216]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f338:	4938      	ldr	r1, [pc, #224]	; (2f41c <z_impl_k_poll+0x208>)
   2f33a:	482e      	ldr	r0, [pc, #184]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f33c:	f004 f944 	bl	335c8 <printk>
   2f340:	4932      	ldr	r1, [pc, #200]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f342:	4837      	ldr	r0, [pc, #220]	; (2f420 <z_impl_k_poll+0x20c>)
   2f344:	f004 f940 	bl	335c8 <printk>
   2f348:	2184      	movs	r1, #132	; 0x84
   2f34a:	4831      	ldr	r0, [pc, #196]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f34c:	f004 fc3d 	bl	33bca <assert_post_action>
   2f350:	f385 8811 	msr	BASEPRI, r5
   2f354:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
   2f358:	f06f 050a 	mvn.w	r5, #10
   2f35c:	e7df      	b.n	2f31e <z_impl_k_poll+0x10a>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2f35e:	aa01      	add	r2, sp, #4
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2f360:	4629      	mov	r1, r5
   2f362:	4633      	mov	r3, r6
   2f364:	4829      	ldr	r0, [pc, #164]	; (2f40c <z_impl_k_poll+0x1f8>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
   2f366:	e9cd 2201 	strd	r2, r2, [sp, #4]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
   2f36a:	f7fe fb61 	bl	2da30 <z_pend_curr>
   2f36e:	4605      	mov	r5, r0
	__asm__ volatile(
   2f370:	f04f 0320 	mov.w	r3, #32
   2f374:	f3ef 8611 	mrs	r6, BASEPRI
   2f378:	f383 8811 	msr	BASEPRI, r3
   2f37c:	f3bf 8f6f 	isb	sy
	__ASSERT(z_spin_lock_valid(l), "Recursive spinlock %p", l);
   2f380:	4822      	ldr	r0, [pc, #136]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f382:	f7ff f8ad 	bl	2e4e0 <z_spin_lock_valid>
   2f386:	b968      	cbnz	r0, 2f3a4 <z_impl_k_poll+0x190>
   2f388:	235c      	movs	r3, #92	; 0x5c
   2f38a:	4a21      	ldr	r2, [pc, #132]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f38c:	4921      	ldr	r1, [pc, #132]	; (2f414 <z_impl_k_poll+0x200>)
   2f38e:	4819      	ldr	r0, [pc, #100]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f390:	f004 f91a 	bl	335c8 <printk>
   2f394:	491d      	ldr	r1, [pc, #116]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f396:	4820      	ldr	r0, [pc, #128]	; (2f418 <z_impl_k_poll+0x204>)
   2f398:	f004 f916 	bl	335c8 <printk>
   2f39c:	215c      	movs	r1, #92	; 0x5c
   2f39e:	481c      	ldr	r0, [pc, #112]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f3a0:	f004 fc13 	bl	33bca <assert_post_action>
	z_spin_lock_set_owner(l);
   2f3a4:	4819      	ldr	r0, [pc, #100]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f3a6:	f7ff f8b9 	bl	2e51c <z_spin_lock_set_owner>
	clear_event_registrations(events, events_registered, key);
   2f3aa:	4620      	mov	r0, r4
   2f3ac:	4632      	mov	r2, r6
   2f3ae:	4639      	mov	r1, r7
   2f3b0:	f7ff fd7c 	bl	2eeac <clear_event_registrations>
	__ASSERT(z_spin_unlock_valid(l), "Not my spinlock %p", l);
   2f3b4:	4815      	ldr	r0, [pc, #84]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f3b6:	f7ff f8a1 	bl	2e4fc <z_spin_unlock_valid>
   2f3ba:	b968      	cbnz	r0, 2f3d8 <z_impl_k_poll+0x1c4>
   2f3bc:	2384      	movs	r3, #132	; 0x84
   2f3be:	4a14      	ldr	r2, [pc, #80]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f3c0:	4916      	ldr	r1, [pc, #88]	; (2f41c <z_impl_k_poll+0x208>)
   2f3c2:	480c      	ldr	r0, [pc, #48]	; (2f3f4 <z_impl_k_poll+0x1e0>)
   2f3c4:	f004 f900 	bl	335c8 <printk>
   2f3c8:	4910      	ldr	r1, [pc, #64]	; (2f40c <z_impl_k_poll+0x1f8>)
   2f3ca:	4815      	ldr	r0, [pc, #84]	; (2f420 <z_impl_k_poll+0x20c>)
   2f3cc:	f004 f8fc 	bl	335c8 <printk>
   2f3d0:	2184      	movs	r1, #132	; 0x84
   2f3d2:	480f      	ldr	r0, [pc, #60]	; (2f410 <z_impl_k_poll+0x1fc>)
   2f3d4:	f004 fbf9 	bl	33bca <assert_post_action>
	__asm__ volatile(
   2f3d8:	f386 8811 	msr	BASEPRI, r6
   2f3dc:	f3bf 8f6f 	isb	sy
	return swap_rc;
   2f3e0:	e79d      	b.n	2f31e <z_impl_k_poll+0x10a>
   2f3e2:	bf00      	nop
   2f3e4:	200274dc 	.word	0x200274dc
   2f3e8:	0002ee3d 	.word	0x0002ee3d
   2f3ec:	0003fccb 	.word	0x0003fccb
   2f3f0:	00040096 	.word	0x00040096
   2f3f4:	0003b77f 	.word	0x0003b77f
   2f3f8:	0003cb8b 	.word	0x0003cb8b
   2f3fc:	00040109 	.word	0x00040109
   2f400:	0004011f 	.word	0x0004011f
   2f404:	0004012e 	.word	0x0004012e
   2f408:	0004013e 	.word	0x0004013e
   2f40c:	20027604 	.word	0x20027604
   2f410:	0003c751 	.word	0x0003c751
   2f414:	0003c777 	.word	0x0003c777
   2f418:	0003c78c 	.word	0x0003c78c
   2f41c:	0003c7a4 	.word	0x0003c7a4
   2f420:	0003c7bb 	.word	0x0003c7bb

0002f424 <fabs>:
   2f424:	ec51 0b10 	vmov	r0, r1, d0
   2f428:	ee10 2a10 	vmov	r2, s0
   2f42c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   2f430:	ec43 2b10 	vmov	d0, r2, r3
   2f434:	4770      	bx	lr
   2f436:	bf00      	nop

0002f438 <fabsf>:
   2f438:	ee10 3a10 	vmov	r3, s0
   2f43c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f440:	ee00 3a10 	vmov	s0, r3
   2f444:	4770      	bx	lr
   2f446:	bf00      	nop

0002f448 <floorf>:
   2f448:	febb 0a40 	vrintm.f32	s0, s0
   2f44c:	4770      	bx	lr
   2f44e:	bf00      	nop

0002f450 <fmaxf>:
   2f450:	b508      	push	{r3, lr}
   2f452:	ed2d 8b02 	vpush	{d8}
   2f456:	eeb0 8a60 	vmov.f32	s16, s1
   2f45a:	eef0 8a40 	vmov.f32	s17, s0
   2f45e:	f000 f833 	bl	2f4c8 <__fpclassifyf>
   2f462:	b920      	cbnz	r0, 2f46e <fmaxf+0x1e>
   2f464:	eeb0 0a48 	vmov.f32	s0, s16
   2f468:	ecbd 8b02 	vpop	{d8}
   2f46c:	bd08      	pop	{r3, pc}
   2f46e:	eeb0 0a48 	vmov.f32	s0, s16
   2f472:	f000 f829 	bl	2f4c8 <__fpclassifyf>
   2f476:	b120      	cbz	r0, 2f482 <fmaxf+0x32>
   2f478:	eef4 8ac8 	vcmpe.f32	s17, s16
   2f47c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f480:	ddf0      	ble.n	2f464 <fmaxf+0x14>
   2f482:	eeb0 0a68 	vmov.f32	s0, s17
   2f486:	ecbd 8b02 	vpop	{d8}
   2f48a:	bd08      	pop	{r3, pc}

0002f48c <fminf>:
   2f48c:	b508      	push	{r3, lr}
   2f48e:	ed2d 8b02 	vpush	{d8}
   2f492:	eeb0 8a60 	vmov.f32	s16, s1
   2f496:	eef0 8a40 	vmov.f32	s17, s0
   2f49a:	f000 f815 	bl	2f4c8 <__fpclassifyf>
   2f49e:	b920      	cbnz	r0, 2f4aa <fminf+0x1e>
   2f4a0:	eeb0 0a48 	vmov.f32	s0, s16
   2f4a4:	ecbd 8b02 	vpop	{d8}
   2f4a8:	bd08      	pop	{r3, pc}
   2f4aa:	eeb0 0a48 	vmov.f32	s0, s16
   2f4ae:	f000 f80b 	bl	2f4c8 <__fpclassifyf>
   2f4b2:	b120      	cbz	r0, 2f4be <fminf+0x32>
   2f4b4:	eef4 8ac8 	vcmpe.f32	s17, s16
   2f4b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f4bc:	d5f0      	bpl.n	2f4a0 <fminf+0x14>
   2f4be:	eeb0 0a68 	vmov.f32	s0, s17
   2f4c2:	ecbd 8b02 	vpop	{d8}
   2f4c6:	bd08      	pop	{r3, pc}

0002f4c8 <__fpclassifyf>:
   2f4c8:	ee10 3a10 	vmov	r3, s0
   2f4cc:	f033 4000 	bics.w	r0, r3, #2147483648	; 0x80000000
   2f4d0:	d00e      	beq.n	2f4f0 <__fpclassifyf+0x28>
   2f4d2:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
   2f4d6:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
   2f4da:	d30d      	bcc.n	2f4f8 <__fpclassifyf+0x30>
   2f4dc:	1e42      	subs	r2, r0, #1
   2f4de:	4b07      	ldr	r3, [pc, #28]	; (2f4fc <__fpclassifyf+0x34>)
   2f4e0:	429a      	cmp	r2, r3
   2f4e2:	d907      	bls.n	2f4f4 <__fpclassifyf+0x2c>
   2f4e4:	f1a0 40ff 	sub.w	r0, r0, #2139095040	; 0x7f800000
   2f4e8:	fab0 f080 	clz	r0, r0
   2f4ec:	0940      	lsrs	r0, r0, #5
   2f4ee:	4770      	bx	lr
   2f4f0:	2002      	movs	r0, #2
   2f4f2:	4770      	bx	lr
   2f4f4:	2003      	movs	r0, #3
   2f4f6:	4770      	bx	lr
   2f4f8:	2004      	movs	r0, #4
   2f4fa:	4770      	bx	lr
   2f4fc:	007ffffe 	.word	0x007ffffe

0002f500 <roundf>:
   2f500:	feb8 0a40 	vrinta.f32	s0, s0
   2f504:	4770      	bx	lr
   2f506:	bf00      	nop

0002f508 <sinf>:
   2f508:	ee10 3a10 	vmov	r3, s0
   2f50c:	4a21      	ldr	r2, [pc, #132]	; (2f594 <sinf+0x8c>)
   2f50e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2f512:	4293      	cmp	r3, r2
   2f514:	b500      	push	{lr}
   2f516:	b083      	sub	sp, #12
   2f518:	dd1a      	ble.n	2f550 <sinf+0x48>
   2f51a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2f51e:	db04      	blt.n	2f52a <sinf+0x22>
   2f520:	ee30 0a40 	vsub.f32	s0, s0, s0
   2f524:	b003      	add	sp, #12
   2f526:	f85d fb04 	ldr.w	pc, [sp], #4
   2f52a:	4668      	mov	r0, sp
   2f52c:	f000 ffc0 	bl	304b0 <__ieee754_rem_pio2f>
   2f530:	f000 0003 	and.w	r0, r0, #3
   2f534:	2801      	cmp	r0, #1
   2f536:	d013      	beq.n	2f560 <sinf+0x58>
   2f538:	2802      	cmp	r0, #2
   2f53a:	d020      	beq.n	2f57e <sinf+0x76>
   2f53c:	b1b8      	cbz	r0, 2f56e <sinf+0x66>
   2f53e:	eddd 0a01 	vldr	s1, [sp, #4]
   2f542:	ed9d 0a00 	vldr	s0, [sp]
   2f546:	f001 f8ed 	bl	30724 <__kernel_cosf>
   2f54a:	eeb1 0a40 	vneg.f32	s0, s0
   2f54e:	e7e9      	b.n	2f524 <sinf+0x1c>
   2f550:	2000      	movs	r0, #0
   2f552:	eddf 0a11 	vldr	s1, [pc, #68]	; 2f598 <sinf+0x90>
   2f556:	f001 fcb9 	bl	30ecc <__kernel_sinf>
   2f55a:	b003      	add	sp, #12
   2f55c:	f85d fb04 	ldr.w	pc, [sp], #4
   2f560:	eddd 0a01 	vldr	s1, [sp, #4]
   2f564:	ed9d 0a00 	vldr	s0, [sp]
   2f568:	f001 f8dc 	bl	30724 <__kernel_cosf>
   2f56c:	e7da      	b.n	2f524 <sinf+0x1c>
   2f56e:	2001      	movs	r0, #1
   2f570:	eddd 0a01 	vldr	s1, [sp, #4]
   2f574:	ed9d 0a00 	vldr	s0, [sp]
   2f578:	f001 fca8 	bl	30ecc <__kernel_sinf>
   2f57c:	e7d2      	b.n	2f524 <sinf+0x1c>
   2f57e:	2001      	movs	r0, #1
   2f580:	eddd 0a01 	vldr	s1, [sp, #4]
   2f584:	ed9d 0a00 	vldr	s0, [sp]
   2f588:	f001 fca0 	bl	30ecc <__kernel_sinf>
   2f58c:	eeb1 0a40 	vneg.f32	s0, s0
   2f590:	e7c8      	b.n	2f524 <sinf+0x1c>
   2f592:	bf00      	nop
   2f594:	3f490fd8 	.word	0x3f490fd8
   2f598:	00000000 	.word	0x00000000

0002f59c <expf>:
   2f59c:	b508      	push	{r3, lr}
   2f59e:	ed2d 8b02 	vpush	{d8}
   2f5a2:	eeb0 8a40 	vmov.f32	s16, s0
   2f5a6:	f000 fa37 	bl	2fa18 <__ieee754_expf>
   2f5aa:	4b16      	ldr	r3, [pc, #88]	; (2f604 <expf+0x68>)
   2f5ac:	eef0 8a40 	vmov.f32	s17, s0
   2f5b0:	f993 3000 	ldrsb.w	r3, [r3]
   2f5b4:	3301      	adds	r3, #1
   2f5b6:	d012      	beq.n	2f5de <expf+0x42>
   2f5b8:	eeb0 0a48 	vmov.f32	s0, s16
   2f5bc:	f001 fd6e 	bl	3109c <finitef>
   2f5c0:	b168      	cbz	r0, 2f5de <expf+0x42>
   2f5c2:	eddf 7a11 	vldr	s15, [pc, #68]	; 2f608 <expf+0x6c>
   2f5c6:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2f5ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f5ce:	dc12      	bgt.n	2f5f6 <expf+0x5a>
   2f5d0:	eddf 7a0e 	vldr	s15, [pc, #56]	; 2f60c <expf+0x70>
   2f5d4:	eeb4 8ae7 	vcmpe.f32	s16, s15
   2f5d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f5dc:	d404      	bmi.n	2f5e8 <expf+0x4c>
   2f5de:	eeb0 0a68 	vmov.f32	s0, s17
   2f5e2:	ecbd 8b02 	vpop	{d8}
   2f5e6:	bd08      	pop	{r3, pc}
   2f5e8:	f005 ff7e 	bl	354e8 <__errno>
   2f5ec:	2322      	movs	r3, #34	; 0x22
   2f5ee:	eddf 8a08 	vldr	s17, [pc, #32]	; 2f610 <expf+0x74>
   2f5f2:	6003      	str	r3, [r0, #0]
   2f5f4:	e7f3      	b.n	2f5de <expf+0x42>
   2f5f6:	f005 ff77 	bl	354e8 <__errno>
   2f5fa:	2322      	movs	r3, #34	; 0x22
   2f5fc:	eddf 8a05 	vldr	s17, [pc, #20]	; 2f614 <expf+0x78>
   2f600:	6003      	str	r3, [r0, #0]
   2f602:	e7ec      	b.n	2f5de <expf+0x42>
   2f604:	20020502 	.word	0x20020502
   2f608:	42b17180 	.word	0x42b17180
   2f60c:	c2cff1b5 	.word	0xc2cff1b5
   2f610:	00000000 	.word	0x00000000
   2f614:	7f800000 	.word	0x7f800000

0002f618 <logf>:
   2f618:	b508      	push	{r3, lr}
   2f61a:	ed2d 8b02 	vpush	{d8}
   2f61e:	eeb0 8a40 	vmov.f32	s16, s0
   2f622:	f000 faf1 	bl	2fc08 <__ieee754_logf>
   2f626:	4b14      	ldr	r3, [pc, #80]	; (2f678 <logf+0x60>)
   2f628:	f993 3000 	ldrsb.w	r3, [r3]
   2f62c:	3301      	adds	r3, #1
   2f62e:	d014      	beq.n	2f65a <logf+0x42>
   2f630:	eeb4 8a48 	vcmp.f32	s16, s16
   2f634:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f638:	d60f      	bvs.n	2f65a <logf+0x42>
   2f63a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   2f63e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f642:	dc0a      	bgt.n	2f65a <logf+0x42>
   2f644:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2f648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f64c:	d108      	bne.n	2f660 <logf+0x48>
   2f64e:	f005 ff4b 	bl	354e8 <__errno>
   2f652:	2322      	movs	r3, #34	; 0x22
   2f654:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2f67c <logf+0x64>
   2f658:	6003      	str	r3, [r0, #0]
   2f65a:	ecbd 8b02 	vpop	{d8}
   2f65e:	bd08      	pop	{r3, pc}
   2f660:	f005 ff42 	bl	354e8 <__errno>
   2f664:	2321      	movs	r3, #33	; 0x21
   2f666:	ecbd 8b02 	vpop	{d8}
   2f66a:	6003      	str	r3, [r0, #0]
   2f66c:	4804      	ldr	r0, [pc, #16]	; (2f680 <logf+0x68>)
   2f66e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2f672:	f001 bd1d 	b.w	310b0 <nanf>
   2f676:	bf00      	nop
   2f678:	20020502 	.word	0x20020502
   2f67c:	ff800000 	.word	0xff800000
   2f680:	0003aa18 	.word	0x0003aa18

0002f684 <log10f>:
   2f684:	b508      	push	{r3, lr}
   2f686:	ed2d 8b02 	vpush	{d8}
   2f68a:	eeb0 8a40 	vmov.f32	s16, s0
   2f68e:	f000 fbb7 	bl	2fe00 <__ieee754_log10f>
   2f692:	4b14      	ldr	r3, [pc, #80]	; (2f6e4 <log10f+0x60>)
   2f694:	f993 3000 	ldrsb.w	r3, [r3]
   2f698:	3301      	adds	r3, #1
   2f69a:	d014      	beq.n	2f6c6 <log10f+0x42>
   2f69c:	eeb4 8a48 	vcmp.f32	s16, s16
   2f6a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6a4:	d60f      	bvs.n	2f6c6 <log10f+0x42>
   2f6a6:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
   2f6aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6ae:	d80a      	bhi.n	2f6c6 <log10f+0x42>
   2f6b0:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2f6b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f6b8:	d108      	bne.n	2f6cc <log10f+0x48>
   2f6ba:	f005 ff15 	bl	354e8 <__errno>
   2f6be:	2322      	movs	r3, #34	; 0x22
   2f6c0:	ed9f 0a09 	vldr	s0, [pc, #36]	; 2f6e8 <log10f+0x64>
   2f6c4:	6003      	str	r3, [r0, #0]
   2f6c6:	ecbd 8b02 	vpop	{d8}
   2f6ca:	bd08      	pop	{r3, pc}
   2f6cc:	f005 ff0c 	bl	354e8 <__errno>
   2f6d0:	2321      	movs	r3, #33	; 0x21
   2f6d2:	ecbd 8b02 	vpop	{d8}
   2f6d6:	6003      	str	r3, [r0, #0]
   2f6d8:	4804      	ldr	r0, [pc, #16]	; (2f6ec <log10f+0x68>)
   2f6da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   2f6de:	f001 bce7 	b.w	310b0 <nanf>
   2f6e2:	bf00      	nop
   2f6e4:	20020502 	.word	0x20020502
   2f6e8:	ff800000 	.word	0xff800000
   2f6ec:	0003aa18 	.word	0x0003aa18

0002f6f0 <powf>:
   2f6f0:	b508      	push	{r3, lr}
   2f6f2:	ed2d 8b04 	vpush	{d8-d9}
   2f6f6:	eef0 8a40 	vmov.f32	s17, s0
   2f6fa:	eeb0 8a60 	vmov.f32	s16, s1
   2f6fe:	f000 fbdf 	bl	2fec0 <__ieee754_powf>
   2f702:	4b47      	ldr	r3, [pc, #284]	; (2f820 <powf+0x130>)
   2f704:	eeb0 9a40 	vmov.f32	s18, s0
   2f708:	f993 3000 	ldrsb.w	r3, [r3]
   2f70c:	3301      	adds	r3, #1
   2f70e:	d01f      	beq.n	2f750 <powf+0x60>
   2f710:	eeb4 8a48 	vcmp.f32	s16, s16
   2f714:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f718:	d61a      	bvs.n	2f750 <powf+0x60>
   2f71a:	eef4 8a68 	vcmp.f32	s17, s17
   2f71e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f722:	d659      	bvs.n	2f7d8 <powf+0xe8>
   2f724:	eddf 9a3f 	vldr	s19, [pc, #252]	; 2f824 <powf+0x134>
   2f728:	eef4 8a69 	vcmp.f32	s17, s19
   2f72c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f730:	d113      	bne.n	2f75a <powf+0x6a>
   2f732:	eeb4 8a69 	vcmp.f32	s16, s19
   2f736:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f73a:	d029      	beq.n	2f790 <powf+0xa0>
   2f73c:	eeb0 0a48 	vmov.f32	s0, s16
   2f740:	f001 fcac 	bl	3109c <finitef>
   2f744:	b120      	cbz	r0, 2f750 <powf+0x60>
   2f746:	eeb4 8ae9 	vcmpe.f32	s16, s19
   2f74a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f74e:	d44c      	bmi.n	2f7ea <powf+0xfa>
   2f750:	eeb0 0a49 	vmov.f32	s0, s18
   2f754:	ecbd 8b04 	vpop	{d8-d9}
   2f758:	bd08      	pop	{r3, pc}
   2f75a:	f001 fc9f 	bl	3109c <finitef>
   2f75e:	b1f0      	cbz	r0, 2f79e <powf+0xae>
   2f760:	eeb5 9a40 	vcmp.f32	s18, #0.0
   2f764:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f768:	d1f2      	bne.n	2f750 <powf+0x60>
   2f76a:	eeb0 0a68 	vmov.f32	s0, s17
   2f76e:	f001 fc95 	bl	3109c <finitef>
   2f772:	2800      	cmp	r0, #0
   2f774:	d0ec      	beq.n	2f750 <powf+0x60>
   2f776:	eeb0 0a48 	vmov.f32	s0, s16
   2f77a:	f001 fc8f 	bl	3109c <finitef>
   2f77e:	2800      	cmp	r0, #0
   2f780:	d0e6      	beq.n	2f750 <powf+0x60>
   2f782:	f005 feb1 	bl	354e8 <__errno>
   2f786:	2322      	movs	r3, #34	; 0x22
   2f788:	ed9f 9a26 	vldr	s18, [pc, #152]	; 2f824 <powf+0x134>
   2f78c:	6003      	str	r3, [r0, #0]
   2f78e:	e7df      	b.n	2f750 <powf+0x60>
   2f790:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
   2f794:	eeb0 0a49 	vmov.f32	s0, s18
   2f798:	ecbd 8b04 	vpop	{d8-d9}
   2f79c:	bd08      	pop	{r3, pc}
   2f79e:	eeb0 0a68 	vmov.f32	s0, s17
   2f7a2:	f001 fc7b 	bl	3109c <finitef>
   2f7a6:	2800      	cmp	r0, #0
   2f7a8:	d0da      	beq.n	2f760 <powf+0x70>
   2f7aa:	eeb0 0a48 	vmov.f32	s0, s16
   2f7ae:	f001 fc75 	bl	3109c <finitef>
   2f7b2:	2800      	cmp	r0, #0
   2f7b4:	d0d4      	beq.n	2f760 <powf+0x70>
   2f7b6:	eeb4 9a49 	vcmp.f32	s18, s18
   2f7ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f7be:	d627      	bvs.n	2f810 <powf+0x120>
   2f7c0:	f005 fe92 	bl	354e8 <__errno>
   2f7c4:	eef5 8ac0 	vcmpe.f32	s17, #0.0
   2f7c8:	2322      	movs	r3, #34	; 0x22
   2f7ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f7ce:	6003      	str	r3, [r0, #0]
   2f7d0:	d412      	bmi.n	2f7f8 <powf+0x108>
   2f7d2:	ed9f 9a15 	vldr	s18, [pc, #84]	; 2f828 <powf+0x138>
   2f7d6:	e7bb      	b.n	2f750 <powf+0x60>
   2f7d8:	eeb5 8a40 	vcmp.f32	s16, #0.0
   2f7dc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   2f7e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f7e4:	fe07 9a80 	vseleq.f32	s18, s15, s0
   2f7e8:	e7b2      	b.n	2f750 <powf+0x60>
   2f7ea:	f005 fe7d 	bl	354e8 <__errno>
   2f7ee:	2321      	movs	r3, #33	; 0x21
   2f7f0:	ed9f 9a0e 	vldr	s18, [pc, #56]	; 2f82c <powf+0x13c>
   2f7f4:	6003      	str	r3, [r0, #0]
   2f7f6:	e7ab      	b.n	2f750 <powf+0x60>
   2f7f8:	eeb0 0a48 	vmov.f32	s0, s16
   2f7fc:	f001 fc5e 	bl	310bc <rintf>
   2f800:	eeb4 0a48 	vcmp.f32	s0, s16
   2f804:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f808:	d0e3      	beq.n	2f7d2 <powf+0xe2>
   2f80a:	ed9f 9a08 	vldr	s18, [pc, #32]	; 2f82c <powf+0x13c>
   2f80e:	e79f      	b.n	2f750 <powf+0x60>
   2f810:	f005 fe6a 	bl	354e8 <__errno>
   2f814:	2321      	movs	r3, #33	; 0x21
   2f816:	ee89 9aa9 	vdiv.f32	s18, s19, s19
   2f81a:	6003      	str	r3, [r0, #0]
   2f81c:	e798      	b.n	2f750 <powf+0x60>
   2f81e:	bf00      	nop
   2f820:	20020502 	.word	0x20020502
   2f824:	00000000 	.word	0x00000000
   2f828:	7f800000 	.word	0x7f800000
   2f82c:	ff800000 	.word	0xff800000

0002f830 <sqrtf>:
   2f830:	b508      	push	{r3, lr}
   2f832:	ed2d 8b02 	vpush	{d8}
   2f836:	eeb0 8a40 	vmov.f32	s16, s0
   2f83a:	f000 ff6f 	bl	3071c <__ieee754_sqrtf>
   2f83e:	4b0e      	ldr	r3, [pc, #56]	; (2f878 <sqrtf+0x48>)
   2f840:	f993 3000 	ldrsb.w	r3, [r3]
   2f844:	3301      	adds	r3, #1
   2f846:	d00b      	beq.n	2f860 <sqrtf+0x30>
   2f848:	eeb4 8a48 	vcmp.f32	s16, s16
   2f84c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f850:	d606      	bvs.n	2f860 <sqrtf+0x30>
   2f852:	eddf 8a0a 	vldr	s17, [pc, #40]	; 2f87c <sqrtf+0x4c>
   2f856:	eeb4 8ae8 	vcmpe.f32	s16, s17
   2f85a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2f85e:	d402      	bmi.n	2f866 <sqrtf+0x36>
   2f860:	ecbd 8b02 	vpop	{d8}
   2f864:	bd08      	pop	{r3, pc}
   2f866:	f005 fe3f 	bl	354e8 <__errno>
   2f86a:	ee88 0aa8 	vdiv.f32	s0, s17, s17
   2f86e:	2321      	movs	r3, #33	; 0x21
   2f870:	6003      	str	r3, [r0, #0]
   2f872:	ecbd 8b02 	vpop	{d8}
   2f876:	bd08      	pop	{r3, pc}
   2f878:	20020502 	.word	0x20020502
   2f87c:	00000000 	.word	0x00000000

0002f880 <__ieee754_sqrt>:
   2f880:	4a63      	ldr	r2, [pc, #396]	; (2fa10 <__ieee754_sqrt+0x190>)
   2f882:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   2f886:	ec55 4b10 	vmov	r4, r5, d0
   2f88a:	43aa      	bics	r2, r5
   2f88c:	f000 8098 	beq.w	2f9c0 <__ieee754_sqrt+0x140>
   2f890:	2d00      	cmp	r5, #0
   2f892:	462b      	mov	r3, r5
   2f894:	ee10 0a10 	vmov	r0, s0
   2f898:	dd5a      	ble.n	2f950 <__ieee754_sqrt+0xd0>
   2f89a:	ea5f 5e25 	movs.w	lr, r5, asr #20
   2f89e:	f000 80ab 	beq.w	2f9f8 <__ieee754_sqrt+0x178>
   2f8a2:	f3c3 0113 	ubfx	r1, r3, #0, #20
   2f8a6:	f2ae 3eff 	subw	lr, lr, #1023	; 0x3ff
   2f8aa:	0fc3      	lsrs	r3, r0, #31
   2f8ac:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   2f8b0:	f01e 0f01 	tst.w	lr, #1
   2f8b4:	ea4f 0240 	mov.w	r2, r0, lsl #1
   2f8b8:	eb03 0341 	add.w	r3, r3, r1, lsl #1
   2f8bc:	d003      	beq.n	2f8c6 <__ieee754_sqrt+0x46>
   2f8be:	0fd1      	lsrs	r1, r2, #31
   2f8c0:	0082      	lsls	r2, r0, #2
   2f8c2:	eb01 0343 	add.w	r3, r1, r3, lsl #1
   2f8c6:	f04f 0c00 	mov.w	ip, #0
   2f8ca:	ea4f 0e6e 	mov.w	lr, lr, asr #1
   2f8ce:	2416      	movs	r4, #22
   2f8d0:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
   2f8d4:	4665      	mov	r5, ip
   2f8d6:	1868      	adds	r0, r5, r1
   2f8d8:	4298      	cmp	r0, r3
   2f8da:	dc02      	bgt.n	2f8e2 <__ieee754_sqrt+0x62>
   2f8dc:	1a1b      	subs	r3, r3, r0
   2f8de:	1845      	adds	r5, r0, r1
   2f8e0:	448c      	add	ip, r1
   2f8e2:	005b      	lsls	r3, r3, #1
   2f8e4:	3c01      	subs	r4, #1
   2f8e6:	ea4f 0151 	mov.w	r1, r1, lsr #1
   2f8ea:	eb03 73d2 	add.w	r3, r3, r2, lsr #31
   2f8ee:	ea4f 0242 	mov.w	r2, r2, lsl #1
   2f8f2:	d1f0      	bne.n	2f8d6 <__ieee754_sqrt+0x56>
   2f8f4:	4627      	mov	r7, r4
   2f8f6:	2620      	movs	r6, #32
   2f8f8:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
   2f8fc:	e014      	b.n	2f928 <__ieee754_sqrt+0xa8>
   2f8fe:	d10a      	bne.n	2f916 <__ieee754_sqrt+0x96>
   2f900:	4290      	cmp	r0, r2
   2f902:	d808      	bhi.n	2f916 <__ieee754_sqrt+0x96>
   2f904:	2800      	cmp	r0, #0
   2f906:	eb00 0401 	add.w	r4, r0, r1
   2f90a:	db1c      	blt.n	2f946 <__ieee754_sqrt+0xc6>
   2f90c:	46a8      	mov	r8, r5
   2f90e:	2300      	movs	r3, #0
   2f910:	1a12      	subs	r2, r2, r0
   2f912:	440f      	add	r7, r1
   2f914:	4645      	mov	r5, r8
   2f916:	0fd0      	lsrs	r0, r2, #31
   2f918:	3e01      	subs	r6, #1
   2f91a:	ea4f 0151 	mov.w	r1, r1, lsr #1
   2f91e:	eb00 0343 	add.w	r3, r0, r3, lsl #1
   2f922:	ea4f 0242 	mov.w	r2, r2, lsl #1
   2f926:	d034      	beq.n	2f992 <__ieee754_sqrt+0x112>
   2f928:	42ab      	cmp	r3, r5
   2f92a:	eb01 0004 	add.w	r0, r1, r4
   2f92e:	dde6      	ble.n	2f8fe <__ieee754_sqrt+0x7e>
   2f930:	2800      	cmp	r0, #0
   2f932:	eb00 0401 	add.w	r4, r0, r1
   2f936:	db06      	blt.n	2f946 <__ieee754_sqrt+0xc6>
   2f938:	46a8      	mov	r8, r5
   2f93a:	1b5b      	subs	r3, r3, r5
   2f93c:	4290      	cmp	r0, r2
   2f93e:	bf88      	it	hi
   2f940:	f103 33ff 	addhi.w	r3, r3, #4294967295	; 0xffffffff
   2f944:	e7e4      	b.n	2f910 <__ieee754_sqrt+0x90>
   2f946:	2c00      	cmp	r4, #0
   2f948:	dbf6      	blt.n	2f938 <__ieee754_sqrt+0xb8>
   2f94a:	f105 0801 	add.w	r8, r5, #1
   2f94e:	e7f4      	b.n	2f93a <__ieee754_sqrt+0xba>
   2f950:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
   2f954:	4322      	orrs	r2, r4
   2f956:	d02c      	beq.n	2f9b2 <__ieee754_sqrt+0x132>
   2f958:	2d00      	cmp	r5, #0
   2f95a:	d141      	bne.n	2f9e0 <__ieee754_sqrt+0x160>
   2f95c:	0ac4      	lsrs	r4, r0, #11
   2f95e:	3b15      	subs	r3, #21
   2f960:	0540      	lsls	r0, r0, #21
   2f962:	4622      	mov	r2, r4
   2f964:	2c00      	cmp	r4, #0
   2f966:	d0f9      	beq.n	2f95c <__ieee754_sqrt+0xdc>
   2f968:	02e5      	lsls	r5, r4, #11
   2f96a:	d44b      	bmi.n	2fa04 <__ieee754_sqrt+0x184>
   2f96c:	2100      	movs	r1, #0
   2f96e:	e000      	b.n	2f972 <__ieee754_sqrt+0xf2>
   2f970:	4629      	mov	r1, r5
   2f972:	0052      	lsls	r2, r2, #1
   2f974:	1c4d      	adds	r5, r1, #1
   2f976:	02d4      	lsls	r4, r2, #11
   2f978:	d5fa      	bpl.n	2f970 <__ieee754_sqrt+0xf0>
   2f97a:	4614      	mov	r4, r2
   2f97c:	4602      	mov	r2, r0
   2f97e:	40a8      	lsls	r0, r5
   2f980:	f1c5 0520 	rsb	r5, r5, #32
   2f984:	fa22 f505 	lsr.w	r5, r2, r5
   2f988:	eba3 0e01 	sub.w	lr, r3, r1
   2f98c:	ea45 0304 	orr.w	r3, r5, r4
   2f990:	e787      	b.n	2f8a2 <__ieee754_sqrt+0x22>
   2f992:	4313      	orrs	r3, r2
   2f994:	d10f      	bne.n	2f9b6 <__ieee754_sqrt+0x136>
   2f996:	087e      	lsrs	r6, r7, #1
   2f998:	491e      	ldr	r1, [pc, #120]	; (2fa14 <__ieee754_sqrt+0x194>)
   2f99a:	f01c 0f01 	tst.w	ip, #1
   2f99e:	eb01 016c 	add.w	r1, r1, ip, asr #1
   2f9a2:	bf18      	it	ne
   2f9a4:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
   2f9a8:	eb01 530e 	add.w	r3, r1, lr, lsl #20
   2f9ac:	4632      	mov	r2, r6
   2f9ae:	ec43 2b10 	vmov	d0, r2, r3
   2f9b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2f9b6:	1c7b      	adds	r3, r7, #1
   2f9b8:	d021      	beq.n	2f9fe <__ieee754_sqrt+0x17e>
   2f9ba:	1c7e      	adds	r6, r7, #1
   2f9bc:	0876      	lsrs	r6, r6, #1
   2f9be:	e7eb      	b.n	2f998 <__ieee754_sqrt+0x118>
   2f9c0:	ee10 2a10 	vmov	r2, s0
   2f9c4:	462b      	mov	r3, r5
   2f9c6:	ee10 0a10 	vmov	r0, s0
   2f9ca:	4629      	mov	r1, r5
   2f9cc:	f7dd fb6e 	bl	d0ac <__aeabi_dmul>
   2f9d0:	4622      	mov	r2, r4
   2f9d2:	462b      	mov	r3, r5
   2f9d4:	f7dd f9b4 	bl	cd40 <__adddf3>
   2f9d8:	ec41 0b10 	vmov	d0, r0, r1
   2f9dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   2f9e0:	ee10 2a10 	vmov	r2, s0
   2f9e4:	4629      	mov	r1, r5
   2f9e6:	f7dd f9a9 	bl	cd3c <__aeabi_dsub>
   2f9ea:	4602      	mov	r2, r0
   2f9ec:	460b      	mov	r3, r1
   2f9ee:	f7dd fc87 	bl	d300 <__aeabi_ddiv>
   2f9f2:	ec41 0b10 	vmov	d0, r0, r1
   2f9f6:	e7dc      	b.n	2f9b2 <__ieee754_sqrt+0x132>
   2f9f8:	462a      	mov	r2, r5
   2f9fa:	4673      	mov	r3, lr
   2f9fc:	e7b6      	b.n	2f96c <__ieee754_sqrt+0xec>
   2f9fe:	f10c 0c01 	add.w	ip, ip, #1
   2fa02:	e7c9      	b.n	2f998 <__ieee754_sqrt+0x118>
   2fa04:	4602      	mov	r2, r0
   2fa06:	2520      	movs	r5, #32
   2fa08:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   2fa0c:	e7ba      	b.n	2f984 <__ieee754_sqrt+0x104>
   2fa0e:	bf00      	nop
   2fa10:	7ff00000 	.word	0x7ff00000
   2fa14:	3fe00000 	.word	0x3fe00000

0002fa18 <__ieee754_expf>:
   2fa18:	ee10 3a10 	vmov	r3, s0
   2fa1c:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
   2fa20:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   2fa24:	d85d      	bhi.n	2fae2 <__ieee754_expf+0xca>
   2fa26:	ea4f 71d3 	mov.w	r1, r3, lsr #31
   2fa2a:	f000 8099 	beq.w	2fb60 <__ieee754_expf+0x148>
   2fa2e:	4864      	ldr	r0, [pc, #400]	; (2fbc0 <__ieee754_expf+0x1a8>)
   2fa30:	4283      	cmp	r3, r0
   2fa32:	dc59      	bgt.n	2fae8 <__ieee754_expf+0xd0>
   2fa34:	b129      	cbz	r1, 2fa42 <__ieee754_expf+0x2a>
   2fa36:	4b63      	ldr	r3, [pc, #396]	; (2fbc4 <__ieee754_expf+0x1ac>)
   2fa38:	429a      	cmp	r2, r3
   2fa3a:	d902      	bls.n	2fa42 <__ieee754_expf+0x2a>
   2fa3c:	ed9f 0a62 	vldr	s0, [pc, #392]	; 2fbc8 <__ieee754_expf+0x1b0>
   2fa40:	4770      	bx	lr
   2fa42:	4b62      	ldr	r3, [pc, #392]	; (2fbcc <__ieee754_expf+0x1b4>)
   2fa44:	429a      	cmp	r2, r3
   2fa46:	b410      	push	{r4}
   2fa48:	d953      	bls.n	2faf2 <__ieee754_expf+0xda>
   2fa4a:	4b61      	ldr	r3, [pc, #388]	; (2fbd0 <__ieee754_expf+0x1b8>)
   2fa4c:	429a      	cmp	r2, r3
   2fa4e:	f200 8099 	bhi.w	2fb84 <__ieee754_expf+0x16c>
   2fa52:	008c      	lsls	r4, r1, #2
   2fa54:	485f      	ldr	r0, [pc, #380]	; (2fbd4 <__ieee754_expf+0x1bc>)
   2fa56:	4a60      	ldr	r2, [pc, #384]	; (2fbd8 <__ieee754_expf+0x1c0>)
   2fa58:	f1c1 0301 	rsb	r3, r1, #1
   2fa5c:	4420      	add	r0, r4
   2fa5e:	4422      	add	r2, r4
   2fa60:	1a59      	subs	r1, r3, r1
   2fa62:	edd0 4a00 	vldr	s9, [r0]
   2fa66:	edd2 7a00 	vldr	s15, [r2]
   2fa6a:	ee70 4a64 	vsub.f32	s9, s0, s9
   2fa6e:	ee34 0ae7 	vsub.f32	s0, s9, s15
   2fa72:	ed9f 4a5a 	vldr	s8, [pc, #360]	; 2fbdc <__ieee754_expf+0x1c4>
   2fa76:	ed9f 5a5a 	vldr	s10, [pc, #360]	; 2fbe0 <__ieee754_expf+0x1c8>
   2fa7a:	eddf 5a5a 	vldr	s11, [pc, #360]	; 2fbe4 <__ieee754_expf+0x1cc>
   2fa7e:	ee20 7a00 	vmul.f32	s14, s0, s0
   2fa82:	ed9f 6a59 	vldr	s12, [pc, #356]	; 2fbe8 <__ieee754_expf+0x1d0>
   2fa86:	eddf 6a59 	vldr	s13, [pc, #356]	; 2fbec <__ieee754_expf+0x1d4>
   2fa8a:	eea7 5a04 	vfma.f32	s10, s14, s8
   2fa8e:	eee5 5a07 	vfma.f32	s11, s10, s14
   2fa92:	eea5 6a87 	vfma.f32	s12, s11, s14
   2fa96:	eee6 6a07 	vfma.f32	s13, s12, s14
   2fa9a:	eeb0 6a40 	vmov.f32	s12, s0
   2fa9e:	eea6 6ac7 	vfms.f32	s12, s13, s14
   2faa2:	eeb0 7a46 	vmov.f32	s14, s12
   2faa6:	ee20 6a06 	vmul.f32	s12, s0, s12
   2faaa:	2900      	cmp	r1, #0
   2faac:	d04b      	beq.n	2fb46 <__ieee754_expf+0x12e>
   2faae:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
   2fab2:	f111 0f7d 	cmn.w	r1, #125	; 0x7d
   2fab6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2faba:	ee36 7ac7 	vsub.f32	s14, s13, s14
   2fabe:	eec6 6a07 	vdiv.f32	s13, s12, s14
   2fac2:	ee77 7ae6 	vsub.f32	s15, s15, s13
   2fac6:	ee77 7ae4 	vsub.f32	s15, s15, s9
   2faca:	ee30 0a67 	vsub.f32	s0, s0, s15
   2face:	db4d      	blt.n	2fb6c <__ieee754_expf+0x154>
   2fad0:	ee10 3a10 	vmov	r3, s0
   2fad4:	eb03 53c1 	add.w	r3, r3, r1, lsl #23
   2fad8:	ee00 3a10 	vmov	s0, r3
   2fadc:	f85d 4b04 	ldr.w	r4, [sp], #4
   2fae0:	4770      	bx	lr
   2fae2:	ee30 0a00 	vadd.f32	s0, s0, s0
   2fae6:	4770      	bx	lr
   2fae8:	ed9f 0a41 	vldr	s0, [pc, #260]	; 2fbf0 <__ieee754_expf+0x1d8>
   2faec:	ee20 0a00 	vmul.f32	s0, s0, s0
   2faf0:	4770      	bx	lr
   2faf2:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
   2faf6:	d20a      	bcs.n	2fb0e <__ieee754_expf+0xf6>
   2faf8:	eddf 7a3d 	vldr	s15, [pc, #244]	; 2fbf0 <__ieee754_expf+0x1d8>
   2fafc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2fb00:	ee70 7a27 	vadd.f32	s15, s0, s15
   2fb04:	eef4 7ac7 	vcmpe.f32	s15, s14
   2fb08:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fb0c:	dc54      	bgt.n	2fbb8 <__ieee754_expf+0x1a0>
   2fb0e:	ee60 7a00 	vmul.f32	s15, s0, s0
   2fb12:	ed9f 7a32 	vldr	s14, [pc, #200]	; 2fbdc <__ieee754_expf+0x1c4>
   2fb16:	eddf 5a32 	vldr	s11, [pc, #200]	; 2fbe0 <__ieee754_expf+0x1c8>
   2fb1a:	ed9f 6a32 	vldr	s12, [pc, #200]	; 2fbe4 <__ieee754_expf+0x1cc>
   2fb1e:	eee7 5a87 	vfma.f32	s11, s15, s14
   2fb22:	eddf 6a31 	vldr	s13, [pc, #196]	; 2fbe8 <__ieee754_expf+0x1d0>
   2fb26:	ed9f 7a31 	vldr	s14, [pc, #196]	; 2fbec <__ieee754_expf+0x1d4>
   2fb2a:	eea7 6aa5 	vfma.f32	s12, s15, s11
   2fb2e:	eee7 6a86 	vfma.f32	s13, s15, s12
   2fb32:	eea7 7aa6 	vfma.f32	s14, s15, s13
   2fb36:	eef0 6a40 	vmov.f32	s13, s0
   2fb3a:	eee7 6ac7 	vfms.f32	s13, s15, s14
   2fb3e:	eeb0 7a66 	vmov.f32	s14, s13
   2fb42:	ee20 6a26 	vmul.f32	s12, s0, s13
   2fb46:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2fb4a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
   2fb4e:	ee37 7a67 	vsub.f32	s14, s14, s15
   2fb52:	eec6 7a07 	vdiv.f32	s15, s12, s14
   2fb56:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2fb5a:	ee36 0ac0 	vsub.f32	s0, s13, s0
   2fb5e:	e7bd      	b.n	2fadc <__ieee754_expf+0xc4>
   2fb60:	2900      	cmp	r1, #0
   2fb62:	eddf 7a19 	vldr	s15, [pc, #100]	; 2fbc8 <__ieee754_expf+0x1b0>
   2fb66:	fe00 0a27 	vseleq.f32	s0, s0, s15
   2fb6a:	4770      	bx	lr
   2fb6c:	ee10 3a10 	vmov	r3, s0
   2fb70:	3164      	adds	r1, #100	; 0x64
   2fb72:	eddf 7a20 	vldr	s15, [pc, #128]	; 2fbf4 <__ieee754_expf+0x1dc>
   2fb76:	eb03 53c1 	add.w	r3, r3, r1, lsl #23
   2fb7a:	ee00 3a10 	vmov	s0, r3
   2fb7e:	ee20 0a27 	vmul.f32	s0, s0, s15
   2fb82:	e7ab      	b.n	2fadc <__ieee754_expf+0xc4>
   2fb84:	4b1c      	ldr	r3, [pc, #112]	; (2fbf8 <__ieee754_expf+0x1e0>)
   2fb86:	eef0 4a40 	vmov.f32	s9, s0
   2fb8a:	eddf 7a1c 	vldr	s15, [pc, #112]	; 2fbfc <__ieee754_expf+0x1e4>
   2fb8e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   2fb92:	ed9f 6a1b 	vldr	s12, [pc, #108]	; 2fc00 <__ieee754_expf+0x1e8>
   2fb96:	eddf 6a1b 	vldr	s13, [pc, #108]	; 2fc04 <__ieee754_expf+0x1ec>
   2fb9a:	ed91 7a00 	vldr	s14, [r1]
   2fb9e:	eea0 7a27 	vfma.f32	s14, s0, s15
   2fba2:	eefd 7ac7 	vcvt.s32.f32	s15, s14
   2fba6:	ee17 1a90 	vmov	r1, s15
   2fbaa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fbae:	eee7 4ac6 	vfms.f32	s9, s15, s12
   2fbb2:	ee67 7aa6 	vmul.f32	s15, s15, s13
   2fbb6:	e75a      	b.n	2fa6e <__ieee754_expf+0x56>
   2fbb8:	ee30 0a07 	vadd.f32	s0, s0, s14
   2fbbc:	e78e      	b.n	2fadc <__ieee754_expf+0xc4>
   2fbbe:	bf00      	nop
   2fbc0:	42b17217 	.word	0x42b17217
   2fbc4:	42cff1b5 	.word	0x42cff1b5
   2fbc8:	00000000 	.word	0x00000000
   2fbcc:	3eb17218 	.word	0x3eb17218
   2fbd0:	3f851591 	.word	0x3f851591
   2fbd4:	0003afa0 	.word	0x0003afa0
   2fbd8:	0003afa8 	.word	0x0003afa8
   2fbdc:	3331bb4c 	.word	0x3331bb4c
   2fbe0:	b5ddea0e 	.word	0xb5ddea0e
   2fbe4:	388ab355 	.word	0x388ab355
   2fbe8:	bb360b61 	.word	0xbb360b61
   2fbec:	3e2aaaab 	.word	0x3e2aaaab
   2fbf0:	7149f2ca 	.word	0x7149f2ca
   2fbf4:	0d800000 	.word	0x0d800000
   2fbf8:	0003af98 	.word	0x0003af98
   2fbfc:	3fb8aa3b 	.word	0x3fb8aa3b
   2fc00:	3f317180 	.word	0x3f317180
   2fc04:	3717f7d1 	.word	0x3717f7d1

0002fc08 <__ieee754_logf>:
   2fc08:	ee10 3a10 	vmov	r3, s0
   2fc0c:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
   2fc10:	d02e      	beq.n	2fc70 <__ieee754_logf+0x68>
   2fc12:	2b00      	cmp	r3, #0
   2fc14:	db33      	blt.n	2fc7e <__ieee754_logf+0x76>
   2fc16:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2fc1a:	da40      	bge.n	2fc9e <__ieee754_logf+0x96>
   2fc1c:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   2fc20:	b430      	push	{r4, r5}
   2fc22:	db33      	blt.n	2fc8c <__ieee754_logf+0x84>
   2fc24:	2500      	movs	r5, #0
   2fc26:	f3c3 0416 	ubfx	r4, r3, #0, #23
   2fc2a:	4a64      	ldr	r2, [pc, #400]	; (2fdbc <__ieee754_logf+0x1b4>)
   2fc2c:	15db      	asrs	r3, r3, #23
   2fc2e:	4964      	ldr	r1, [pc, #400]	; (2fdc0 <__ieee754_logf+0x1b8>)
   2fc30:	4422      	add	r2, r4
   2fc32:	f104 000f 	add.w	r0, r4, #15
   2fc36:	3b7f      	subs	r3, #127	; 0x7f
   2fc38:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   2fc3c:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
   2fc40:	4001      	ands	r1, r0
   2fc42:	442b      	add	r3, r5
   2fc44:	f082 507e 	eor.w	r0, r2, #1065353216	; 0x3f800000
   2fc48:	eb03 53d2 	add.w	r3, r3, r2, lsr #23
   2fc4c:	ea40 0204 	orr.w	r2, r0, r4
   2fc50:	ee00 2a10 	vmov	s0, r2
   2fc54:	ee30 7a47 	vsub.f32	s14, s0, s14
   2fc58:	bb21      	cbnz	r1, 2fca4 <__ieee754_logf+0x9c>
   2fc5a:	eeb5 7a40 	vcmp.f32	s14, #0.0
   2fc5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   2fc62:	d160      	bne.n	2fd26 <__ieee754_logf+0x11e>
   2fc64:	2b00      	cmp	r3, #0
   2fc66:	f040 808d 	bne.w	2fd84 <__ieee754_logf+0x17c>
   2fc6a:	ed9f 0a56 	vldr	s0, [pc, #344]	; 2fdc4 <__ieee754_logf+0x1bc>
   2fc6e:	e069      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fc70:	ed9f 7a55 	vldr	s14, [pc, #340]	; 2fdc8 <__ieee754_logf+0x1c0>
   2fc74:	eddf 7a53 	vldr	s15, [pc, #332]	; 2fdc4 <__ieee754_logf+0x1bc>
   2fc78:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2fc7c:	4770      	bx	lr
   2fc7e:	ee70 7a40 	vsub.f32	s15, s0, s0
   2fc82:	ed9f 7a50 	vldr	s14, [pc, #320]	; 2fdc4 <__ieee754_logf+0x1bc>
   2fc86:	ee87 0a87 	vdiv.f32	s0, s15, s14
   2fc8a:	4770      	bx	lr
   2fc8c:	eddf 7a4f 	vldr	s15, [pc, #316]	; 2fdcc <__ieee754_logf+0x1c4>
   2fc90:	f06f 0518 	mvn.w	r5, #24
   2fc94:	ee60 7a27 	vmul.f32	s15, s0, s15
   2fc98:	ee17 3a90 	vmov	r3, s15
   2fc9c:	e7c3      	b.n	2fc26 <__ieee754_logf+0x1e>
   2fc9e:	ee30 0a00 	vadd.f32	s0, s0, s0
   2fca2:	4770      	bx	lr
   2fca4:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
   2fca8:	eddf 2a49 	vldr	s5, [pc, #292]	; 2fdd0 <__ieee754_logf+0x1c8>
   2fcac:	eddf 4a49 	vldr	s9, [pc, #292]	; 2fdd4 <__ieee754_logf+0x1cc>
   2fcb0:	ee06 3a90 	vmov	s13, r3
   2fcb4:	eddf 5a48 	vldr	s11, [pc, #288]	; 2fdd8 <__ieee754_logf+0x1d0>
   2fcb8:	ee77 7a27 	vadd.f32	s15, s14, s15
   2fcbc:	eddf 3a47 	vldr	s7, [pc, #284]	; 2fddc <__ieee754_logf+0x1d4>
   2fcc0:	ed9f 5a47 	vldr	s10, [pc, #284]	; 2fde0 <__ieee754_logf+0x1d8>
   2fcc4:	eeb8 3ae6 	vcvt.f32.s32	s6, s13
   2fcc8:	ed9f 0a46 	vldr	s0, [pc, #280]	; 2fde4 <__ieee754_logf+0x1dc>
   2fccc:	ee87 4a27 	vdiv.f32	s8, s14, s15
   2fcd0:	eddf 6a45 	vldr	s13, [pc, #276]	; 2fde8 <__ieee754_logf+0x1e0>
   2fcd4:	4945      	ldr	r1, [pc, #276]	; (2fdec <__ieee754_logf+0x1e4>)
   2fcd6:	4a46      	ldr	r2, [pc, #280]	; (2fdf0 <__ieee754_logf+0x1e8>)
   2fcd8:	4421      	add	r1, r4
   2fcda:	1b12      	subs	r2, r2, r4
   2fcdc:	430a      	orrs	r2, r1
   2fcde:	2a00      	cmp	r2, #0
   2fce0:	ee24 6a04 	vmul.f32	s12, s8, s8
   2fce4:	ee66 7a06 	vmul.f32	s15, s12, s12
   2fce8:	eee7 4aa2 	vfma.f32	s9, s15, s5
   2fcec:	eea7 5aa3 	vfma.f32	s10, s15, s7
   2fcf0:	eee4 5aa7 	vfma.f32	s11, s9, s15
   2fcf4:	eee5 6a27 	vfma.f32	s13, s10, s15
   2fcf8:	eea5 0aa7 	vfma.f32	s0, s11, s15
   2fcfc:	ee20 0a06 	vmul.f32	s0, s0, s12
   2fd00:	eea6 0aa7 	vfma.f32	s0, s13, s15
   2fd04:	dd20      	ble.n	2fd48 <__ieee754_logf+0x140>
   2fd06:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   2fd0a:	ee67 7a27 	vmul.f32	s15, s14, s15
   2fd0e:	ee67 7a87 	vmul.f32	s15, s15, s14
   2fd12:	ee30 0a27 	vadd.f32	s0, s0, s15
   2fd16:	ee20 0a04 	vmul.f32	s0, s0, s8
   2fd1a:	bb33      	cbnz	r3, 2fd6a <__ieee754_logf+0x162>
   2fd1c:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2fd20:	ee37 0a40 	vsub.f32	s0, s14, s0
   2fd24:	e00e      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fd26:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
   2fd2a:	eddf 7a32 	vldr	s15, [pc, #200]	; 2fdf4 <__ieee754_logf+0x1ec>
   2fd2e:	ee67 6a07 	vmul.f32	s13, s14, s14
   2fd32:	eea7 0a67 	vfms.f32	s0, s14, s15
   2fd36:	eef0 7a40 	vmov.f32	s15, s0
   2fd3a:	ee27 0aa6 	vmul.f32	s0, s15, s13
   2fd3e:	bb73      	cbnz	r3, 2fd9e <__ieee754_logf+0x196>
   2fd40:	ee37 0a40 	vsub.f32	s0, s14, s0
   2fd44:	bc30      	pop	{r4, r5}
   2fd46:	4770      	bx	lr
   2fd48:	ee37 0a40 	vsub.f32	s0, s14, s0
   2fd4c:	ee20 0a04 	vmul.f32	s0, s0, s8
   2fd50:	2b00      	cmp	r3, #0
   2fd52:	d0f5      	beq.n	2fd40 <__ieee754_logf+0x138>
   2fd54:	eddf 6a28 	vldr	s13, [pc, #160]	; 2fdf8 <__ieee754_logf+0x1f0>
   2fd58:	eddf 7a28 	vldr	s15, [pc, #160]	; 2fdfc <__ieee754_logf+0x1f4>
   2fd5c:	eea3 0a66 	vfms.f32	s0, s6, s13
   2fd60:	ee30 0a47 	vsub.f32	s0, s0, s14
   2fd64:	ee93 0a27 	vfnms.f32	s0, s6, s15
   2fd68:	e7ec      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fd6a:	ed9f 6a23 	vldr	s12, [pc, #140]	; 2fdf8 <__ieee754_logf+0x1f0>
   2fd6e:	eddf 6a23 	vldr	s13, [pc, #140]	; 2fdfc <__ieee754_logf+0x1f4>
   2fd72:	eea3 0a06 	vfma.f32	s0, s6, s12
   2fd76:	ee37 0ac0 	vsub.f32	s0, s15, s0
   2fd7a:	ee30 0a47 	vsub.f32	s0, s0, s14
   2fd7e:	ee93 0a26 	vfnms.f32	s0, s6, s13
   2fd82:	e7df      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fd84:	ee07 3a90 	vmov	s15, r3
   2fd88:	ed9f 0a1b 	vldr	s0, [pc, #108]	; 2fdf8 <__ieee754_logf+0x1f0>
   2fd8c:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 2fdfc <__ieee754_logf+0x1f4>
   2fd90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fd94:	ee27 0a80 	vmul.f32	s0, s15, s0
   2fd98:	eea7 0a87 	vfma.f32	s0, s15, s14
   2fd9c:	e7d2      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fd9e:	ee07 3a90 	vmov	s15, r3
   2fda2:	ed9f 6a15 	vldr	s12, [pc, #84]	; 2fdf8 <__ieee754_logf+0x1f0>
   2fda6:	eddf 6a15 	vldr	s13, [pc, #84]	; 2fdfc <__ieee754_logf+0x1f4>
   2fdaa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   2fdae:	eea7 0ac6 	vfms.f32	s0, s15, s12
   2fdb2:	ee30 0a47 	vsub.f32	s0, s0, s14
   2fdb6:	ee97 0aa6 	vfnms.f32	s0, s15, s13
   2fdba:	e7c3      	b.n	2fd44 <__ieee754_logf+0x13c>
   2fdbc:	004afb20 	.word	0x004afb20
   2fdc0:	007ffff0 	.word	0x007ffff0
   2fdc4:	00000000 	.word	0x00000000
   2fdc8:	cc000000 	.word	0xcc000000
   2fdcc:	4c000000 	.word	0x4c000000
   2fdd0:	3e178897 	.word	0x3e178897
   2fdd4:	3e3a3325 	.word	0x3e3a3325
   2fdd8:	3e924925 	.word	0x3e924925
   2fddc:	3e1cd04f 	.word	0x3e1cd04f
   2fde0:	3e638e29 	.word	0x3e638e29
   2fde4:	3f2aaaab 	.word	0x3f2aaaab
   2fde8:	3ecccccd 	.word	0x3ecccccd
   2fdec:	ffcf5c30 	.word	0xffcf5c30
   2fdf0:	0035c288 	.word	0x0035c288
   2fdf4:	3eaaaaab 	.word	0x3eaaaaab
   2fdf8:	3717f7d1 	.word	0x3717f7d1
   2fdfc:	3f317180 	.word	0x3f317180

0002fe00 <__ieee754_log10f>:
   2fe00:	b508      	push	{r3, lr}
   2fe02:	ee10 3a10 	vmov	r3, s0
   2fe06:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
   2fe0a:	ed2d 8b02 	vpush	{d8}
   2fe0e:	d02a      	beq.n	2fe66 <__ieee754_log10f+0x66>
   2fe10:	2b00      	cmp	r3, #0
   2fe12:	db31      	blt.n	2fe78 <__ieee754_log10f+0x78>
   2fe14:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
   2fe18:	da40      	bge.n	2fe9c <__ieee754_log10f+0x9c>
   2fe1a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   2fe1e:	db34      	blt.n	2fe8a <__ieee754_log10f+0x8a>
   2fe20:	2100      	movs	r1, #0
   2fe22:	15da      	asrs	r2, r3, #23
   2fe24:	f3c3 0316 	ubfx	r3, r3, #0, #23
   2fe28:	3a7f      	subs	r2, #127	; 0x7f
   2fe2a:	440a      	add	r2, r1
   2fe2c:	0fd1      	lsrs	r1, r2, #31
   2fe2e:	f1c1 007f 	rsb	r0, r1, #127	; 0x7f
   2fe32:	440a      	add	r2, r1
   2fe34:	ea43 53c0 	orr.w	r3, r3, r0, lsl #23
   2fe38:	ee07 2a90 	vmov	s15, r2
   2fe3c:	ee00 3a10 	vmov	s0, r3
   2fe40:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
   2fe44:	f7ff fee0 	bl	2fc08 <__ieee754_logf>
   2fe48:	eddf 7a17 	vldr	s15, [pc, #92]	; 2fea8 <__ieee754_log10f+0xa8>
   2fe4c:	ed9f 7a17 	vldr	s14, [pc, #92]	; 2feac <__ieee754_log10f+0xac>
   2fe50:	ee20 0a27 	vmul.f32	s0, s0, s15
   2fe54:	eddf 7a16 	vldr	s15, [pc, #88]	; 2feb0 <__ieee754_log10f+0xb0>
   2fe58:	eea8 0a07 	vfma.f32	s0, s16, s14
   2fe5c:	eea8 0a27 	vfma.f32	s0, s16, s15
   2fe60:	ecbd 8b02 	vpop	{d8}
   2fe64:	bd08      	pop	{r3, pc}
   2fe66:	ed9f 7a13 	vldr	s14, [pc, #76]	; 2feb4 <__ieee754_log10f+0xb4>
   2fe6a:	eddf 7a13 	vldr	s15, [pc, #76]	; 2feb8 <__ieee754_log10f+0xb8>
   2fe6e:	ecbd 8b02 	vpop	{d8}
   2fe72:	ee87 0a27 	vdiv.f32	s0, s14, s15
   2fe76:	bd08      	pop	{r3, pc}
   2fe78:	ee70 7a40 	vsub.f32	s15, s0, s0
   2fe7c:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 2feb8 <__ieee754_log10f+0xb8>
   2fe80:	ecbd 8b02 	vpop	{d8}
   2fe84:	ee87 0a87 	vdiv.f32	s0, s15, s14
   2fe88:	bd08      	pop	{r3, pc}
   2fe8a:	eddf 7a0c 	vldr	s15, [pc, #48]	; 2febc <__ieee754_log10f+0xbc>
   2fe8e:	f06f 0118 	mvn.w	r1, #24
   2fe92:	ee60 7a27 	vmul.f32	s15, s0, s15
   2fe96:	ee17 3a90 	vmov	r3, s15
   2fe9a:	e7c2      	b.n	2fe22 <__ieee754_log10f+0x22>
   2fe9c:	ecbd 8b02 	vpop	{d8}
   2fea0:	ee30 0a00 	vadd.f32	s0, s0, s0
   2fea4:	bd08      	pop	{r3, pc}
   2fea6:	bf00      	nop
   2fea8:	3ede5bd9 	.word	0x3ede5bd9
   2feac:	355427db 	.word	0x355427db
   2feb0:	3e9a2080 	.word	0x3e9a2080
   2feb4:	cc000000 	.word	0xcc000000
   2feb8:	00000000 	.word	0x00000000
   2febc:	4c000000 	.word	0x4c000000

0002fec0 <__ieee754_powf>:
   2fec0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   2fec4:	ed2d 8b06 	vpush	{d8-d10}
   2fec8:	b082      	sub	sp, #8
   2feca:	edcd 0a00 	vstr	s1, [sp]
   2fece:	9c00      	ldr	r4, [sp, #0]
   2fed0:	ed8d 0a01 	vstr	s0, [sp, #4]
   2fed4:	f034 4600 	bics.w	r6, r4, #2147483648	; 0x80000000
   2fed8:	f000 8109 	beq.w	300ee <__ieee754_powf+0x22e>
   2fedc:	9f01      	ldr	r7, [sp, #4]
   2fede:	f027 4a00 	bic.w	sl, r7, #2147483648	; 0x80000000
   2fee2:	f1ba 4fff 	cmp.w	sl, #2139095040	; 0x7f800000
   2fee6:	f300 80ff 	bgt.w	300e8 <__ieee754_powf+0x228>
   2feea:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
   2feee:	bfd4      	ite	le
   2fef0:	2300      	movle	r3, #0
   2fef2:	2301      	movgt	r3, #1
   2fef4:	2b00      	cmp	r3, #0
   2fef6:	f040 80f7 	bne.w	300e8 <__ieee754_powf+0x228>
   2fefa:	2f00      	cmp	r7, #0
   2fefc:	f2c0 8106 	blt.w	3010c <__ieee754_powf+0x24c>
   2ff00:	4698      	mov	r8, r3
   2ff02:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
   2ff06:	f000 8117 	beq.w	30138 <__ieee754_powf+0x278>
   2ff0a:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
   2ff0e:	f000 811c 	beq.w	3014a <__ieee754_powf+0x28a>
   2ff12:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
   2ff16:	f000 814f 	beq.w	301b8 <__ieee754_powf+0x2f8>
   2ff1a:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
   2ff1e:	d102      	bne.n	2ff26 <__ieee754_powf+0x66>
   2ff20:	2f00      	cmp	r7, #0
   2ff22:	f280 812d 	bge.w	30180 <__ieee754_powf+0x2c0>
   2ff26:	f8dd 9004 	ldr.w	r9, [sp, #4]
   2ff2a:	9d00      	ldr	r5, [sp, #0]
   2ff2c:	ee00 9a10 	vmov	s0, r9
   2ff30:	f7ff fa82 	bl	2f438 <fabsf>
   2ff34:	f027 4340 	bic.w	r3, r7, #3221225472	; 0xc0000000
   2ff38:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
   2ff3c:	f000 8129 	beq.w	30192 <__ieee754_powf+0x2d2>
   2ff40:	faba f38a 	clz	r3, sl
   2ff44:	095b      	lsrs	r3, r3, #5
   2ff46:	2b00      	cmp	r3, #0
   2ff48:	f040 8123 	bne.w	30192 <__ieee754_powf+0x2d2>
   2ff4c:	0ffa      	lsrs	r2, r7, #31
   2ff4e:	3a01      	subs	r2, #1
   2ff50:	ea58 0102 	orrs.w	r1, r8, r2
   2ff54:	f000 810d 	beq.w	30172 <__ieee754_powf+0x2b2>
   2ff58:	f1b6 4f9a 	cmp.w	r6, #1291845632	; 0x4d000000
   2ff5c:	f340 8158 	ble.w	30210 <__ieee754_powf+0x350>
   2ff60:	4b9a      	ldr	r3, [pc, #616]	; (301cc <__ieee754_powf+0x30c>)
   2ff62:	459a      	cmp	sl, r3
   2ff64:	f340 825e 	ble.w	30424 <__ieee754_powf+0x564>
   2ff68:	4b99      	ldr	r3, [pc, #612]	; (301d0 <__ieee754_powf+0x310>)
   2ff6a:	459a      	cmp	sl, r3
   2ff6c:	f300 8272 	bgt.w	30454 <__ieee754_powf+0x594>
   2ff70:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   2ff74:	eddf 6a97 	vldr	s13, [pc, #604]	; 301d4 <__ieee754_powf+0x314>
   2ff78:	eeb5 4a00 	vmov.f32	s8, #80	; 0x3e800000  0.250
   2ff7c:	eddf 7a96 	vldr	s15, [pc, #600]	; 301d8 <__ieee754_powf+0x318>
   2ff80:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   2ff84:	ed9f 6a95 	vldr	s12, [pc, #596]	; 301dc <__ieee754_powf+0x31c>
   2ff88:	ee30 0a65 	vsub.f32	s0, s0, s11
   2ff8c:	eddf 5a94 	vldr	s11, [pc, #592]	; 301e0 <__ieee754_powf+0x320>
   2ff90:	eeb1 5a40 	vneg.f32	s10, s0
   2ff94:	ee60 4a00 	vmul.f32	s9, s0, s0
   2ff98:	eee5 6a04 	vfma.f32	s13, s10, s8
   2ff9c:	eea6 7ac0 	vfms.f32	s14, s13, s0
   2ffa0:	ee27 7a24 	vmul.f32	s14, s14, s9
   2ffa4:	ee67 7ac7 	vnmul.f32	s15, s15, s14
   2ffa8:	eee0 7a06 	vfma.f32	s15, s0, s12
   2ffac:	eeb0 6a67 	vmov.f32	s12, s15
   2ffb0:	eea0 6a25 	vfma.f32	s12, s0, s11
   2ffb4:	ee16 3a10 	vmov	r3, s12
   2ffb8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   2ffbc:	f023 030f 	bic.w	r3, r3, #15
   2ffc0:	ee07 3a10 	vmov	s14, r3
   2ffc4:	ee06 3a10 	vmov	s12, r3
   2ffc8:	eea5 7a25 	vfma.f32	s14, s10, s11
   2ffcc:	ee77 7ac7 	vsub.f32	s15, s15, s14
   2ffd0:	f424 647f 	bic.w	r4, r4, #4080	; 0xff0
   2ffd4:	ee07 5a10 	vmov	s14, r5
   2ffd8:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   2ffdc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   2ffe0:	f024 040f 	bic.w	r4, r4, #15
   2ffe4:	ee67 7a87 	vmul.f32	s15, s15, s14
   2ffe8:	eeff 5a00 	vmov.f32	s11, #240	; 0xbf800000 -1.0
   2ffec:	4313      	orrs	r3, r2
   2ffee:	ee06 4a90 	vmov	s13, r4
   2fff2:	ee77 6a66 	vsub.f32	s13, s14, s13
   2fff6:	ee07 4a10 	vmov	s14, r4
   2fffa:	fe05 8a80 	vseleq.f32	s16, s11, s0
   2fffe:	ee26 7a07 	vmul.f32	s14, s12, s14
   30002:	eee6 7a86 	vfma.f32	s15, s13, s12
   30006:	ee77 6a87 	vadd.f32	s13, s15, s14
   3000a:	ee16 3a90 	vmov	r3, s13
   3000e:	2b00      	cmp	r3, #0
   30010:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
   30014:	f340 81b3 	ble.w	3037e <__ieee754_powf+0x4be>
   30018:	f1b2 4f86 	cmp.w	r2, #1124073472	; 0x43000000
   3001c:	f300 81fb 	bgt.w	30416 <__ieee754_powf+0x556>
   30020:	f000 81ee 	beq.w	30400 <__ieee754_powf+0x540>
   30024:	f1b2 5f7c 	cmp.w	r2, #1056964608	; 0x3f000000
   30028:	f300 81b5 	bgt.w	30396 <__ieee754_powf+0x4d6>
   3002c:	2200      	movs	r2, #0
   3002e:	4610      	mov	r0, r2
   30030:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   30034:	eddf 6a6b 	vldr	s13, [pc, #428]	; 301e4 <__ieee754_powf+0x324>
   30038:	ed9f 2a6b 	vldr	s4, [pc, #428]	; 301e8 <__ieee754_powf+0x328>
   3003c:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
   30040:	f023 030f 	bic.w	r3, r3, #15
   30044:	eddf 3a69 	vldr	s7, [pc, #420]	; 301ec <__ieee754_powf+0x32c>
   30048:	ed9f 4a69 	vldr	s8, [pc, #420]	; 301f0 <__ieee754_powf+0x330>
   3004c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30050:	ee06 3a10 	vmov	s12, r3
   30054:	eddf 2a67 	vldr	s5, [pc, #412]	; 301f4 <__ieee754_powf+0x334>
   30058:	eddf 4a67 	vldr	s9, [pc, #412]	; 301f8 <__ieee754_powf+0x338>
   3005c:	ee36 7a47 	vsub.f32	s14, s12, s14
   30060:	ed9f 5a66 	vldr	s10, [pc, #408]	; 301fc <__ieee754_powf+0x33c>
   30064:	ee66 6a26 	vmul.f32	s13, s12, s13
   30068:	eddf 5a65 	vldr	s11, [pc, #404]	; 30200 <__ieee754_powf+0x340>
   3006c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   30070:	eee7 6a82 	vfma.f32	s13, s15, s4
   30074:	eeb0 7a66 	vmov.f32	s14, s13
   30078:	eef0 7a66 	vmov.f32	s15, s13
   3007c:	eea6 7a23 	vfma.f32	s14, s12, s7
   30080:	eeb0 2a47 	vmov.f32	s4, s14
   30084:	ee67 6a07 	vmul.f32	s13, s14, s14
   30088:	eea6 2a63 	vfms.f32	s4, s12, s7
   3008c:	eeb0 6a44 	vmov.f32	s12, s8
   30090:	eea6 6aa2 	vfma.f32	s12, s13, s5
   30094:	ee77 7ac2 	vsub.f32	s15, s15, s4
   30098:	eee7 7a27 	vfma.f32	s15, s14, s15
   3009c:	eee6 4a26 	vfma.f32	s9, s12, s13
   300a0:	eea4 5aa6 	vfma.f32	s10, s9, s13
   300a4:	eee5 5a26 	vfma.f32	s11, s10, s13
   300a8:	eeb0 6a65 	vmov.f32	s12, s11
   300ac:	eef0 5a47 	vmov.f32	s11, s14
   300b0:	eee6 5a66 	vfms.f32	s11, s12, s13
   300b4:	eef0 6a65 	vmov.f32	s13, s11
   300b8:	ee67 5a25 	vmul.f32	s11, s14, s11
   300bc:	ee36 6ac3 	vsub.f32	s12, s13, s6
   300c0:	eec5 6a86 	vdiv.f32	s13, s11, s12
   300c4:	ee76 7ae7 	vsub.f32	s15, s13, s15
   300c8:	ee37 7ac7 	vsub.f32	s14, s15, s14
   300cc:	ee30 0a47 	vsub.f32	s0, s0, s14
   300d0:	ee10 3a10 	vmov	r3, s0
   300d4:	4413      	add	r3, r2
   300d6:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
   300da:	f2c0 81be 	blt.w	3045a <__ieee754_powf+0x59a>
   300de:	ee00 3a10 	vmov	s0, r3
   300e2:	ee20 0a08 	vmul.f32	s0, s0, s16
   300e6:	e004      	b.n	300f2 <__ieee754_powf+0x232>
   300e8:	f1ba 5f7e 	cmp.w	sl, #1065353216	; 0x3f800000
   300ec:	d106      	bne.n	300fc <__ieee754_powf+0x23c>
   300ee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   300f2:	b002      	add	sp, #8
   300f4:	ecbd 8b06 	vpop	{d8-d10}
   300f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   300fc:	4841      	ldr	r0, [pc, #260]	; (30204 <__ieee754_powf+0x344>)
   300fe:	b002      	add	sp, #8
   30100:	ecbd 8b06 	vpop	{d8-d10}
   30104:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30108:	f000 bfd2 	b.w	310b0 <nanf>
   3010c:	f1b6 4f97 	cmp.w	r6, #1266679808	; 0x4b800000
   30110:	da20      	bge.n	30154 <__ieee754_powf+0x294>
   30112:	f1b6 5f7e 	cmp.w	r6, #1065353216	; 0x3f800000
   30116:	db0d      	blt.n	30134 <__ieee754_powf+0x274>
   30118:	15f2      	asrs	r2, r6, #23
   3011a:	f1c2 0296 	rsb	r2, r2, #150	; 0x96
   3011e:	fa46 f102 	asr.w	r1, r6, r2
   30122:	fa01 f202 	lsl.w	r2, r1, r2
   30126:	42b2      	cmp	r2, r6
   30128:	d104      	bne.n	30134 <__ieee754_powf+0x274>
   3012a:	f001 0301 	and.w	r3, r1, #1
   3012e:	f1c3 0802 	rsb	r8, r3, #2
   30132:	e6ea      	b.n	2ff0a <__ieee754_powf+0x4a>
   30134:	4698      	mov	r8, r3
   30136:	e6e8      	b.n	2ff0a <__ieee754_powf+0x4a>
   30138:	f1ba 5f7e 	cmp.w	sl, #1065353216	; 0x3f800000
   3013c:	d0d7      	beq.n	300ee <__ieee754_powf+0x22e>
   3013e:	dd0c      	ble.n	3015a <__ieee754_powf+0x29a>
   30140:	2c00      	cmp	r4, #0
   30142:	db0c      	blt.n	3015e <__ieee754_powf+0x29e>
   30144:	ed9d 0a00 	vldr	s0, [sp]
   30148:	e7d3      	b.n	300f2 <__ieee754_powf+0x232>
   3014a:	2c00      	cmp	r4, #0
   3014c:	db0a      	blt.n	30164 <__ieee754_powf+0x2a4>
   3014e:	ed9d 0a01 	vldr	s0, [sp, #4]
   30152:	e7ce      	b.n	300f2 <__ieee754_powf+0x232>
   30154:	f04f 0802 	mov.w	r8, #2
   30158:	e6d3      	b.n	2ff02 <__ieee754_powf+0x42>
   3015a:	2c00      	cmp	r4, #0
   3015c:	db31      	blt.n	301c2 <__ieee754_powf+0x302>
   3015e:	ed9f 0a2a 	vldr	s0, [pc, #168]	; 30208 <__ieee754_powf+0x348>
   30162:	e7c6      	b.n	300f2 <__ieee754_powf+0x232>
   30164:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   30168:	ed9d 7a01 	vldr	s14, [sp, #4]
   3016c:	ee87 0a87 	vdiv.f32	s0, s15, s14
   30170:	e7bf      	b.n	300f2 <__ieee754_powf+0x232>
   30172:	ee07 9a90 	vmov	s15, r9
   30176:	ee77 7ae7 	vsub.f32	s15, s15, s15
   3017a:	ee87 0aa7 	vdiv.f32	s0, s15, s15
   3017e:	e7b8      	b.n	300f2 <__ieee754_powf+0x232>
   30180:	ed9d 0a01 	vldr	s0, [sp, #4]
   30184:	b002      	add	sp, #8
   30186:	ecbd 8b06 	vpop	{d8-d10}
   3018a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3018e:	f000 bac5 	b.w	3071c <__ieee754_sqrtf>
   30192:	2c00      	cmp	r4, #0
   30194:	da03      	bge.n	3019e <__ieee754_powf+0x2de>
   30196:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   3019a:	ee87 0a80 	vdiv.f32	s0, s15, s0
   3019e:	2f00      	cmp	r7, #0
   301a0:	daa7      	bge.n	300f2 <__ieee754_powf+0x232>
   301a2:	f1aa 5a7e 	sub.w	sl, sl, #1065353216	; 0x3f800000
   301a6:	ea5a 0308 	orrs.w	r3, sl, r8
   301aa:	f040 811a 	bne.w	303e2 <__ieee754_powf+0x522>
   301ae:	ee70 7a40 	vsub.f32	s15, s0, s0
   301b2:	ee87 0aa7 	vdiv.f32	s0, s15, s15
   301b6:	e79c      	b.n	300f2 <__ieee754_powf+0x232>
   301b8:	eddd 7a01 	vldr	s15, [sp, #4]
   301bc:	ee27 0aa7 	vmul.f32	s0, s15, s15
   301c0:	e797      	b.n	300f2 <__ieee754_powf+0x232>
   301c2:	eddd 7a00 	vldr	s15, [sp]
   301c6:	eeb1 0a67 	vneg.f32	s0, s15
   301ca:	e792      	b.n	300f2 <__ieee754_powf+0x232>
   301cc:	3f7ffff7 	.word	0x3f7ffff7
   301d0:	3f800007 	.word	0x3f800007
   301d4:	3eaaaaab 	.word	0x3eaaaaab
   301d8:	3fb8aa3b 	.word	0x3fb8aa3b
   301dc:	36eca570 	.word	0x36eca570
   301e0:	3fb8aa00 	.word	0x3fb8aa00
   301e4:	35bfbe8c 	.word	0x35bfbe8c
   301e8:	3f317218 	.word	0x3f317218
   301ec:	3f317200 	.word	0x3f317200
   301f0:	b5ddea0e 	.word	0xb5ddea0e
   301f4:	3331bb4c 	.word	0x3331bb4c
   301f8:	388ab355 	.word	0x388ab355
   301fc:	bb360b61 	.word	0xbb360b61
   30200:	3e2aaaab 	.word	0x3e2aaaab
   30204:	0003aa18 	.word	0x0003aa18
   30208:	00000000 	.word	0x00000000
   3020c:	4b800000 	.word	0x4b800000
   30210:	f017 4fff 	tst.w	r7, #2139095040	; 0x7f800000
   30214:	d107      	bne.n	30226 <__ieee754_powf+0x366>
   30216:	ed5f 7a03 	vldr	s15, [pc, #-12]	; 3020c <__ieee754_powf+0x34c>
   3021a:	f06f 0317 	mvn.w	r3, #23
   3021e:	ee60 7a27 	vmul.f32	s15, s0, s15
   30222:	ee17 aa90 	vmov	sl, s15
   30226:	ea4f 50ea 	mov.w	r0, sl, asr #23
   3022a:	4e8d      	ldr	r6, [pc, #564]	; (30460 <__ieee754_powf+0x5a0>)
   3022c:	f3ca 0a16 	ubfx	sl, sl, #0, #23
   30230:	387f      	subs	r0, #127	; 0x7f
   30232:	45b2      	cmp	sl, r6
   30234:	f04a 517e 	orr.w	r1, sl, #1065353216	; 0x3f800000
   30238:	4403      	add	r3, r0
   3023a:	f340 80d9 	ble.w	303f0 <__ieee754_powf+0x530>
   3023e:	4889      	ldr	r0, [pc, #548]	; (30464 <__ieee754_powf+0x5a4>)
   30240:	4582      	cmp	sl, r0
   30242:	f340 80f7 	ble.w	30434 <__ieee754_powf+0x574>
   30246:	ed9f 3a88 	vldr	s6, [pc, #544]	; 30468 <__ieee754_powf+0x5a8>
   3024a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   3024e:	3301      	adds	r3, #1
   30250:	f5a1 0100 	sub.w	r1, r1, #8388608	; 0x800000
   30254:	eeb0 2a43 	vmov.f32	s4, s6
   30258:	2600      	movs	r6, #0
   3025a:	ee07 1a90 	vmov	s15, r1
   3025e:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   30262:	1048      	asrs	r0, r1, #1
   30264:	ed9f aa81 	vldr	s20, [pc, #516]	; 3046c <__ieee754_powf+0x5ac>
   30268:	ee77 6a87 	vadd.f32	s13, s15, s14
   3026c:	ed9f 9a80 	vldr	s18, [pc, #512]	; 30470 <__ieee754_powf+0x5b0>
   30270:	ee77 5ac7 	vsub.f32	s11, s15, s14
   30274:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
   30278:	497e      	ldr	r1, [pc, #504]	; (30474 <__ieee754_powf+0x5b4>)
   3027a:	eeb0 4a08 	vmov.f32	s8, #8	; 0x40400000  3.0
   3027e:	eec6 9a26 	vdiv.f32	s19, s12, s13
   30282:	f500 2080 	add.w	r0, r0, #262144	; 0x40000
   30286:	eddf 8a7c 	vldr	s17, [pc, #496]	; 30478 <__ieee754_powf+0x5b8>
   3028a:	4430      	add	r0, r6
   3028c:	ed9f 8a7b 	vldr	s16, [pc, #492]	; 3047c <__ieee754_powf+0x5bc>
   30290:	ed9f 0a7b 	vldr	s0, [pc, #492]	; 30480 <__ieee754_powf+0x5c0>
   30294:	ee06 0a10 	vmov	s12, r0
   30298:	eddf 0a7a 	vldr	s1, [pc, #488]	; 30484 <__ieee754_powf+0x5c4>
   3029c:	ed9f 1a7a 	vldr	s2, [pc, #488]	; 30488 <__ieee754_powf+0x5c8>
   302a0:	ee36 7a47 	vsub.f32	s14, s12, s14
   302a4:	eddf 1a79 	vldr	s3, [pc, #484]	; 3048c <__ieee754_powf+0x5cc>
   302a8:	eddf 3a79 	vldr	s7, [pc, #484]	; 30490 <__ieee754_powf+0x5d0>
   302ac:	ee77 7ac7 	vsub.f32	s15, s15, s14
   302b0:	ee07 3a10 	vmov	s14, r3
   302b4:	eef8 6ac7 	vcvt.f32.s32	s13, s14
   302b8:	ee65 2aa9 	vmul.f32	s5, s11, s19
   302bc:	ee22 5aa2 	vmul.f32	s10, s5, s5
   302c0:	ee12 3a90 	vmov	r3, s5
   302c4:	400b      	ands	r3, r1
   302c6:	eea5 9a0a 	vfma.f32	s18, s10, s20
   302ca:	ee04 3a90 	vmov	s9, r3
   302ce:	eeb1 7a64 	vneg.f32	s14, s9
   302d2:	eee9 8a05 	vfma.f32	s17, s18, s10
   302d6:	eee7 5a06 	vfma.f32	s11, s14, s12
   302da:	eea8 8a85 	vfma.f32	s16, s17, s10
   302de:	eee7 5a27 	vfma.f32	s11, s14, s15
   302e2:	ee72 7aa4 	vadd.f32	s15, s5, s9
   302e6:	ee65 8a05 	vmul.f32	s17, s10, s10
   302ea:	eea8 0a05 	vfma.f32	s0, s16, s10
   302ee:	ee25 6aa9 	vmul.f32	s12, s11, s19
   302f2:	eef0 5a44 	vmov.f32	s11, s8
   302f6:	ee67 7a86 	vmul.f32	s15, s15, s12
   302fa:	eee4 5aa4 	vfma.f32	s11, s9, s9
   302fe:	eee0 0a05 	vfma.f32	s1, s0, s10
   30302:	eee8 7aa0 	vfma.f32	s15, s17, s1
   30306:	ee75 5aa7 	vadd.f32	s11, s11, s15
   3030a:	ee15 3a90 	vmov	r3, s11
   3030e:	400b      	ands	r3, r1
   30310:	ee05 3a90 	vmov	s11, r3
   30314:	ee35 5ac4 	vsub.f32	s10, s11, s8
   30318:	eea7 5a24 	vfma.f32	s10, s14, s9
   3031c:	ee77 7ac5 	vsub.f32	s15, s15, s10
   30320:	ee67 7aa2 	vmul.f32	s15, s15, s5
   30324:	eee6 7a25 	vfma.f32	s15, s12, s11
   30328:	eeb0 5a67 	vmov.f32	s10, s15
   3032c:	eea4 5aa5 	vfma.f32	s10, s9, s11
   30330:	ee15 3a10 	vmov	r3, s10
   30334:	400b      	ands	r3, r1
   30336:	ee06 3a10 	vmov	s12, r3
   3033a:	ee05 3a10 	vmov	s10, r3
   3033e:	eea7 6a25 	vfma.f32	s12, s14, s11
   30342:	ee37 7ac6 	vsub.f32	s14, s15, s12
   30346:	ee27 7a01 	vmul.f32	s14, s14, s2
   3034a:	eea5 7a21 	vfma.f32	s14, s10, s3
   3034e:	ee37 7a02 	vadd.f32	s14, s14, s4
   30352:	eeb0 6a47 	vmov.f32	s12, s14
   30356:	eea5 6a23 	vfma.f32	s12, s10, s7
   3035a:	ee36 6a03 	vadd.f32	s12, s12, s6
   3035e:	ee36 6a26 	vadd.f32	s12, s12, s13
   30362:	ee16 3a10 	vmov	r3, s12
   30366:	400b      	ands	r3, r1
   30368:	ee06 3a10 	vmov	s12, r3
   3036c:	ee76 7a66 	vsub.f32	s15, s12, s13
   30370:	ee77 7ac3 	vsub.f32	s15, s15, s6
   30374:	eee5 7a63 	vfms.f32	s15, s10, s7
   30378:	ee77 7a67 	vsub.f32	s15, s14, s15
   3037c:	e628      	b.n	2ffd0 <__ieee754_powf+0x110>
   3037e:	4945      	ldr	r1, [pc, #276]	; (30494 <__ieee754_powf+0x5d4>)
   30380:	428a      	cmp	r2, r1
   30382:	dc60      	bgt.n	30446 <__ieee754_powf+0x586>
   30384:	f47f ae4e 	bne.w	30024 <__ieee754_powf+0x164>
   30388:	ee76 6ac7 	vsub.f32	s13, s13, s14
   3038c:	eef4 6ae7 	vcmpe.f32	s13, s15
   30390:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30394:	da57      	bge.n	30446 <__ieee754_powf+0x586>
   30396:	15d2      	asrs	r2, r2, #23
   30398:	f44f 0100 	mov.w	r1, #8388608	; 0x800000
   3039c:	4c3e      	ldr	r4, [pc, #248]	; (30498 <__ieee754_powf+0x5d8>)
   3039e:	2b00      	cmp	r3, #0
   303a0:	f1a2 027e 	sub.w	r2, r2, #126	; 0x7e
   303a4:	fa41 f202 	asr.w	r2, r1, r2
   303a8:	441a      	add	r2, r3
   303aa:	f3c2 51c7 	ubfx	r1, r2, #23, #8
   303ae:	f3c2 0016 	ubfx	r0, r2, #0, #23
   303b2:	f1a1 017f 	sub.w	r1, r1, #127	; 0x7f
   303b6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   303ba:	fa44 f401 	asr.w	r4, r4, r1
   303be:	f1c1 0117 	rsb	r1, r1, #23
   303c2:	ea22 0204 	bic.w	r2, r2, r4
   303c6:	fa40 f001 	asr.w	r0, r0, r1
   303ca:	ee06 2a90 	vmov	s13, r2
   303ce:	bfb8      	it	lt
   303d0:	4240      	neglt	r0, r0
   303d2:	ee37 7a66 	vsub.f32	s14, s14, s13
   303d6:	05c2      	lsls	r2, r0, #23
   303d8:	ee77 6a87 	vadd.f32	s13, s15, s14
   303dc:	ee16 3a90 	vmov	r3, s13
   303e0:	e626      	b.n	30030 <__ieee754_powf+0x170>
   303e2:	f1b8 0f01 	cmp.w	r8, #1
   303e6:	f47f ae84 	bne.w	300f2 <__ieee754_powf+0x232>
   303ea:	eeb1 0a40 	vneg.f32	s0, s0
   303ee:	e680      	b.n	300f2 <__ieee754_powf+0x232>
   303f0:	ed9f 3a1d 	vldr	s6, [pc, #116]	; 30468 <__ieee754_powf+0x5a8>
   303f4:	2600      	movs	r6, #0
   303f6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
   303fa:	eeb0 2a43 	vmov.f32	s4, s6
   303fe:	e72c      	b.n	3025a <__ieee754_powf+0x39a>
   30400:	ed9f 6a26 	vldr	s12, [pc, #152]	; 3049c <__ieee754_powf+0x5dc>
   30404:	ee76 6ac7 	vsub.f32	s13, s13, s14
   30408:	ee37 6a86 	vadd.f32	s12, s15, s12
   3040c:	eeb4 6ae6 	vcmpe.f32	s12, s13
   30410:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30414:	ddbf      	ble.n	30396 <__ieee754_powf+0x4d6>
   30416:	eddf 7a22 	vldr	s15, [pc, #136]	; 304a0 <__ieee754_powf+0x5e0>
   3041a:	ee28 0a27 	vmul.f32	s0, s16, s15
   3041e:	ee20 0a27 	vmul.f32	s0, s0, s15
   30422:	e666      	b.n	300f2 <__ieee754_powf+0x232>
   30424:	2c00      	cmp	r4, #0
   30426:	f6bf ae9a 	bge.w	3015e <__ieee754_powf+0x29e>
   3042a:	ed9f 0a1d 	vldr	s0, [pc, #116]	; 304a0 <__ieee754_powf+0x5e0>
   3042e:	ee20 0a00 	vmul.f32	s0, s0, s0
   30432:	e65e      	b.n	300f2 <__ieee754_powf+0x232>
   30434:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
   30438:	ed9f 3a1a 	vldr	s6, [pc, #104]	; 304a4 <__ieee754_powf+0x5e4>
   3043c:	ed9f 2a1a 	vldr	s4, [pc, #104]	; 304a8 <__ieee754_powf+0x5e8>
   30440:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
   30444:	e709      	b.n	3025a <__ieee754_powf+0x39a>
   30446:	eddf 7a19 	vldr	s15, [pc, #100]	; 304ac <__ieee754_powf+0x5ec>
   3044a:	ee28 0a27 	vmul.f32	s0, s16, s15
   3044e:	ee20 0a27 	vmul.f32	s0, s0, s15
   30452:	e64e      	b.n	300f2 <__ieee754_powf+0x232>
   30454:	2c00      	cmp	r4, #0
   30456:	dce8      	bgt.n	3042a <__ieee754_powf+0x56a>
   30458:	e681      	b.n	3015e <__ieee754_powf+0x29e>
   3045a:	f000 fe33 	bl	310c4 <scalbnf>
   3045e:	e640      	b.n	300e2 <__ieee754_powf+0x222>
   30460:	001cc471 	.word	0x001cc471
   30464:	005db3d6 	.word	0x005db3d6
   30468:	00000000 	.word	0x00000000
   3046c:	3e53f142 	.word	0x3e53f142
   30470:	3e6c3255 	.word	0x3e6c3255
   30474:	fffff000 	.word	0xfffff000
   30478:	3e8ba305 	.word	0x3e8ba305
   3047c:	3eaaaaab 	.word	0x3eaaaaab
   30480:	3edb6db7 	.word	0x3edb6db7
   30484:	3f19999a 	.word	0x3f19999a
   30488:	3f76384f 	.word	0x3f76384f
   3048c:	369dc3a0 	.word	0x369dc3a0
   30490:	3f763800 	.word	0x3f763800
   30494:	43160000 	.word	0x43160000
   30498:	007fffff 	.word	0x007fffff
   3049c:	3338aa3c 	.word	0x3338aa3c
   304a0:	7149f2ca 	.word	0x7149f2ca
   304a4:	3f15c000 	.word	0x3f15c000
   304a8:	35d1cfdc 	.word	0x35d1cfdc
   304ac:	0da24260 	.word	0x0da24260

000304b0 <__ieee754_rem_pio2f>:
   304b0:	ee10 3a10 	vmov	r3, s0
   304b4:	4a8b      	ldr	r2, [pc, #556]	; (306e4 <__ieee754_rem_pio2f+0x234>)
   304b6:	b570      	push	{r4, r5, r6, lr}
   304b8:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
   304bc:	b086      	sub	sp, #24
   304be:	4605      	mov	r5, r0
   304c0:	4294      	cmp	r4, r2
   304c2:	dd68      	ble.n	30596 <__ieee754_rem_pio2f+0xe6>
   304c4:	4a88      	ldr	r2, [pc, #544]	; (306e8 <__ieee754_rem_pio2f+0x238>)
   304c6:	ee10 6a10 	vmov	r6, s0
   304ca:	4294      	cmp	r4, r2
   304cc:	dc1a      	bgt.n	30504 <__ieee754_rem_pio2f+0x54>
   304ce:	2b00      	cmp	r3, #0
   304d0:	f024 040f 	bic.w	r4, r4, #15
   304d4:	eddf 7a85 	vldr	s15, [pc, #532]	; 306ec <__ieee754_rem_pio2f+0x23c>
   304d8:	4a85      	ldr	r2, [pc, #532]	; (306f0 <__ieee754_rem_pio2f+0x240>)
   304da:	f340 80e7 	ble.w	306ac <__ieee754_rem_pio2f+0x1fc>
   304de:	4294      	cmp	r4, r2
   304e0:	ee70 7a67 	vsub.f32	s15, s0, s15
   304e4:	d066      	beq.n	305b4 <__ieee754_rem_pio2f+0x104>
   304e6:	ed9f 7a83 	vldr	s14, [pc, #524]	; 306f4 <__ieee754_rem_pio2f+0x244>
   304ea:	2001      	movs	r0, #1
   304ec:	ee77 6ac7 	vsub.f32	s13, s15, s14
   304f0:	ee77 7ae6 	vsub.f32	s15, s15, s13
   304f4:	edc5 6a00 	vstr	s13, [r5]
   304f8:	ee77 7ac7 	vsub.f32	s15, s15, s14
   304fc:	edc5 7a01 	vstr	s15, [r5, #4]
   30500:	b006      	add	sp, #24
   30502:	bd70      	pop	{r4, r5, r6, pc}
   30504:	4a7c      	ldr	r2, [pc, #496]	; (306f8 <__ieee754_rem_pio2f+0x248>)
   30506:	4294      	cmp	r4, r2
   30508:	dd5c      	ble.n	305c4 <__ieee754_rem_pio2f+0x114>
   3050a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
   3050e:	da49      	bge.n	305a4 <__ieee754_rem_pio2f+0xf4>
   30510:	15e2      	asrs	r2, r4, #23
   30512:	eddf 6a7a 	vldr	s13, [pc, #488]	; 306fc <__ieee754_rem_pio2f+0x24c>
   30516:	3a86      	subs	r2, #134	; 0x86
   30518:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
   3051c:	ee07 3a90 	vmov	s15, r3
   30520:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   30524:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   30528:	ee77 7ac7 	vsub.f32	s15, s15, s14
   3052c:	ed8d 7a03 	vstr	s14, [sp, #12]
   30530:	ee67 7aa6 	vmul.f32	s15, s15, s13
   30534:	eebd 7ae7 	vcvt.s32.f32	s14, s15
   30538:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
   3053c:	ee77 7ac7 	vsub.f32	s15, s15, s14
   30540:	ed8d 7a04 	vstr	s14, [sp, #16]
   30544:	ee67 7aa6 	vmul.f32	s15, s15, s13
   30548:	eef5 7a40 	vcmp.f32	s15, #0.0
   3054c:	edcd 7a05 	vstr	s15, [sp, #20]
   30550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30554:	f040 8097 	bne.w	30686 <__ieee754_rem_pio2f+0x1d6>
   30558:	eeb5 7a40 	vcmp.f32	s14, #0.0
   3055c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30560:	bf14      	ite	ne
   30562:	2302      	movne	r3, #2
   30564:	2301      	moveq	r3, #1
   30566:	4966      	ldr	r1, [pc, #408]	; (30700 <__ieee754_rem_pio2f+0x250>)
   30568:	2002      	movs	r0, #2
   3056a:	9101      	str	r1, [sp, #4]
   3056c:	4629      	mov	r1, r5
   3056e:	9000      	str	r0, [sp, #0]
   30570:	a803      	add	r0, sp, #12
   30572:	f000 f959 	bl	30828 <__kernel_rem_pio2f>
   30576:	2e00      	cmp	r6, #0
   30578:	dac2      	bge.n	30500 <__ieee754_rem_pio2f+0x50>
   3057a:	ed95 7a00 	vldr	s14, [r5]
   3057e:	4240      	negs	r0, r0
   30580:	edd5 7a01 	vldr	s15, [r5, #4]
   30584:	eeb1 7a47 	vneg.f32	s14, s14
   30588:	eef1 7a67 	vneg.f32	s15, s15
   3058c:	ed85 7a00 	vstr	s14, [r5]
   30590:	edc5 7a01 	vstr	s15, [r5, #4]
   30594:	e7b4      	b.n	30500 <__ieee754_rem_pio2f+0x50>
   30596:	2200      	movs	r2, #0
   30598:	2000      	movs	r0, #0
   3059a:	ed85 0a00 	vstr	s0, [r5]
   3059e:	606a      	str	r2, [r5, #4]
   305a0:	b006      	add	sp, #24
   305a2:	bd70      	pop	{r4, r5, r6, pc}
   305a4:	ee70 7a40 	vsub.f32	s15, s0, s0
   305a8:	2000      	movs	r0, #0
   305aa:	edc5 7a01 	vstr	s15, [r5, #4]
   305ae:	edc5 7a00 	vstr	s15, [r5]
   305b2:	e7a5      	b.n	30500 <__ieee754_rem_pio2f+0x50>
   305b4:	eddf 6a53 	vldr	s13, [pc, #332]	; 30704 <__ieee754_rem_pio2f+0x254>
   305b8:	2001      	movs	r0, #1
   305ba:	ed9f 7a53 	vldr	s14, [pc, #332]	; 30708 <__ieee754_rem_pio2f+0x258>
   305be:	ee77 7ae6 	vsub.f32	s15, s15, s13
   305c2:	e793      	b.n	304ec <__ieee754_rem_pio2f+0x3c>
   305c4:	f7fe ff38 	bl	2f438 <fabsf>
   305c8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
   305cc:	eddf 6a4f 	vldr	s13, [pc, #316]	; 3070c <__ieee754_rem_pio2f+0x25c>
   305d0:	eddf 5a46 	vldr	s11, [pc, #280]	; 306ec <__ieee754_rem_pio2f+0x23c>
   305d4:	eea0 7a26 	vfma.f32	s14, s0, s13
   305d8:	eddf 7a46 	vldr	s15, [pc, #280]	; 306f4 <__ieee754_rem_pio2f+0x244>
   305dc:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   305e0:	eef8 6ac7 	vcvt.f32.s32	s13, s14
   305e4:	ee17 0a10 	vmov	r0, s14
   305e8:	281f      	cmp	r0, #31
   305ea:	eeb1 6a66 	vneg.f32	s12, s13
   305ee:	ee66 7aa7 	vmul.f32	s15, s13, s15
   305f2:	eea6 0a25 	vfma.f32	s0, s12, s11
   305f6:	dc1e      	bgt.n	30636 <__ieee754_rem_pio2f+0x186>
   305f8:	4a45      	ldr	r2, [pc, #276]	; (30710 <__ieee754_rem_pio2f+0x260>)
   305fa:	1e41      	subs	r1, r0, #1
   305fc:	f024 03ff 	bic.w	r3, r4, #255	; 0xff
   30600:	ee30 7a67 	vsub.f32	s14, s0, s15
   30604:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
   30608:	4293      	cmp	r3, r2
   3060a:	d016      	beq.n	3063a <__ieee754_rem_pio2f+0x18a>
   3060c:	ed85 7a00 	vstr	s14, [r5]
   30610:	ee30 0a47 	vsub.f32	s0, s0, s14
   30614:	2e00      	cmp	r6, #0
   30616:	ee30 0a67 	vsub.f32	s0, s0, s15
   3061a:	ed85 0a01 	vstr	s0, [r5, #4]
   3061e:	f6bf af6f 	bge.w	30500 <__ieee754_rem_pio2f+0x50>
   30622:	eeb1 7a47 	vneg.f32	s14, s14
   30626:	4240      	negs	r0, r0
   30628:	eeb1 0a40 	vneg.f32	s0, s0
   3062c:	ed85 7a00 	vstr	s14, [r5]
   30630:	ed85 0a01 	vstr	s0, [r5, #4]
   30634:	e764      	b.n	30500 <__ieee754_rem_pio2f+0x50>
   30636:	ee30 7a67 	vsub.f32	s14, s0, s15
   3063a:	ee17 3a10 	vmov	r3, s14
   3063e:	15e4      	asrs	r4, r4, #23
   30640:	f3c3 53c7 	ubfx	r3, r3, #23, #8
   30644:	1ae3      	subs	r3, r4, r3
   30646:	2b08      	cmp	r3, #8
   30648:	dde0      	ble.n	3060c <__ieee754_rem_pio2f+0x15c>
   3064a:	eef0 5a40 	vmov.f32	s11, s0
   3064e:	eddf 7a2d 	vldr	s15, [pc, #180]	; 30704 <__ieee754_rem_pio2f+0x254>
   30652:	ed9f 7a2d 	vldr	s14, [pc, #180]	; 30708 <__ieee754_rem_pio2f+0x258>
   30656:	eee6 5a27 	vfma.f32	s11, s12, s15
   3065a:	ee30 0a65 	vsub.f32	s0, s0, s11
   3065e:	eea6 0a27 	vfma.f32	s0, s12, s15
   30662:	eef0 7a40 	vmov.f32	s15, s0
   30666:	eed6 7a87 	vfnms.f32	s15, s13, s14
   3066a:	ee35 7ae7 	vsub.f32	s14, s11, s15
   3066e:	ee17 3a10 	vmov	r3, s14
   30672:	f3c3 53c7 	ubfx	r3, r3, #23, #8
   30676:	1ae4      	subs	r4, r4, r3
   30678:	2c19      	cmp	r4, #25
   3067a:	dc06      	bgt.n	3068a <__ieee754_rem_pio2f+0x1da>
   3067c:	ed85 7a00 	vstr	s14, [r5]
   30680:	eeb0 0a65 	vmov.f32	s0, s11
   30684:	e7c4      	b.n	30610 <__ieee754_rem_pio2f+0x160>
   30686:	2303      	movs	r3, #3
   30688:	e76d      	b.n	30566 <__ieee754_rem_pio2f+0xb6>
   3068a:	eeb0 0a65 	vmov.f32	s0, s11
   3068e:	ed9f 7a21 	vldr	s14, [pc, #132]	; 30714 <__ieee754_rem_pio2f+0x264>
   30692:	ed9f 5a21 	vldr	s10, [pc, #132]	; 30718 <__ieee754_rem_pio2f+0x268>
   30696:	eea6 0a07 	vfma.f32	s0, s12, s14
   3069a:	ee75 7ac0 	vsub.f32	s15, s11, s0
   3069e:	eee6 7a07 	vfma.f32	s15, s12, s14
   306a2:	eed6 7a85 	vfnms.f32	s15, s13, s10
   306a6:	ee30 7a67 	vsub.f32	s14, s0, s15
   306aa:	e7af      	b.n	3060c <__ieee754_rem_pio2f+0x15c>
   306ac:	4294      	cmp	r4, r2
   306ae:	ee70 7a27 	vadd.f32	s15, s0, s15
   306b2:	d00e      	beq.n	306d2 <__ieee754_rem_pio2f+0x222>
   306b4:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 306f4 <__ieee754_rem_pio2f+0x244>
   306b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   306bc:	ee77 6a87 	vadd.f32	s13, s15, s14
   306c0:	ee77 7ae6 	vsub.f32	s15, s15, s13
   306c4:	edc5 6a00 	vstr	s13, [r5]
   306c8:	ee77 7a87 	vadd.f32	s15, s15, s14
   306cc:	edc5 7a01 	vstr	s15, [r5, #4]
   306d0:	e716      	b.n	30500 <__ieee754_rem_pio2f+0x50>
   306d2:	eddf 6a0c 	vldr	s13, [pc, #48]	; 30704 <__ieee754_rem_pio2f+0x254>
   306d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   306da:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 30708 <__ieee754_rem_pio2f+0x258>
   306de:	ee77 7aa6 	vadd.f32	s15, s15, s13
   306e2:	e7eb      	b.n	306bc <__ieee754_rem_pio2f+0x20c>
   306e4:	3f490fd8 	.word	0x3f490fd8
   306e8:	4016cbe3 	.word	0x4016cbe3
   306ec:	3fc90f80 	.word	0x3fc90f80
   306f0:	3fc90fd0 	.word	0x3fc90fd0
   306f4:	37354443 	.word	0x37354443
   306f8:	43490f80 	.word	0x43490f80
   306fc:	43800000 	.word	0x43800000
   30700:	0003b030 	.word	0x0003b030
   30704:	37354400 	.word	0x37354400
   30708:	2e85a308 	.word	0x2e85a308
   3070c:	3f22f984 	.word	0x3f22f984
   30710:	0003afb0 	.word	0x0003afb0
   30714:	2e85a300 	.word	0x2e85a300
   30718:	248d3132 	.word	0x248d3132

0003071c <__ieee754_sqrtf>:
   3071c:	eeb1 0ac0 	vsqrt.f32	s0, s0
   30720:	4770      	bx	lr
   30722:	bf00      	nop

00030724 <__kernel_cosf>:
   30724:	ee10 3a10 	vmov	r3, s0
   30728:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3072c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   30730:	da2c      	bge.n	3078c <__kernel_cosf+0x68>
   30732:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   30736:	ee17 3a90 	vmov	r3, s15
   3073a:	2b00      	cmp	r3, #0
   3073c:	d060      	beq.n	30800 <__kernel_cosf+0xdc>
   3073e:	ee20 7a00 	vmul.f32	s14, s0, s0
   30742:	eddf 7a31 	vldr	s15, [pc, #196]	; 30808 <__kernel_cosf+0xe4>
   30746:	ed9f 5a31 	vldr	s10, [pc, #196]	; 3080c <__kernel_cosf+0xe8>
   3074a:	eddf 5a31 	vldr	s11, [pc, #196]	; 30810 <__kernel_cosf+0xec>
   3074e:	eea7 5a27 	vfma.f32	s10, s14, s15
   30752:	ed9f 6a30 	vldr	s12, [pc, #192]	; 30814 <__kernel_cosf+0xf0>
   30756:	eddf 7a30 	vldr	s15, [pc, #192]	; 30818 <__kernel_cosf+0xf4>
   3075a:	eddf 6a30 	vldr	s13, [pc, #192]	; 3081c <__kernel_cosf+0xf8>
   3075e:	eee7 5a05 	vfma.f32	s11, s14, s10
   30762:	eea7 6a25 	vfma.f32	s12, s14, s11
   30766:	eee7 7a06 	vfma.f32	s15, s14, s12
   3076a:	eee7 6a27 	vfma.f32	s13, s14, s15
   3076e:	ee66 6a87 	vmul.f32	s13, s13, s14
   30772:	ee60 0ac0 	vnmul.f32	s1, s1, s0
   30776:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   3077a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   3077e:	eee7 0a26 	vfma.f32	s1, s14, s13
   30782:	eed7 0a06 	vfnms.f32	s1, s14, s12
   30786:	ee37 0ae0 	vsub.f32	s0, s15, s1
   3078a:	4770      	bx	lr
   3078c:	ee20 7a00 	vmul.f32	s14, s0, s0
   30790:	eddf 7a1d 	vldr	s15, [pc, #116]	; 30808 <__kernel_cosf+0xe4>
   30794:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 3080c <__kernel_cosf+0xe8>
   30798:	eddf 5a1d 	vldr	s11, [pc, #116]	; 30810 <__kernel_cosf+0xec>
   3079c:	eea7 5a27 	vfma.f32	s10, s14, s15
   307a0:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 30814 <__kernel_cosf+0xf0>
   307a4:	eddf 7a1c 	vldr	s15, [pc, #112]	; 30818 <__kernel_cosf+0xf4>
   307a8:	eddf 6a1c 	vldr	s13, [pc, #112]	; 3081c <__kernel_cosf+0xf8>
   307ac:	4a1c      	ldr	r2, [pc, #112]	; (30820 <__kernel_cosf+0xfc>)
   307ae:	4293      	cmp	r3, r2
   307b0:	eee5 5a07 	vfma.f32	s11, s10, s14
   307b4:	eea5 6a87 	vfma.f32	s12, s11, s14
   307b8:	eee6 7a07 	vfma.f32	s15, s12, s14
   307bc:	eee7 6a87 	vfma.f32	s13, s15, s14
   307c0:	ee66 6a87 	vmul.f32	s13, s13, s14
   307c4:	ddd5      	ble.n	30772 <__kernel_cosf+0x4e>
   307c6:	4a17      	ldr	r2, [pc, #92]	; (30824 <__kernel_cosf+0x100>)
   307c8:	4293      	cmp	r3, r2
   307ca:	dc14      	bgt.n	307f6 <__kernel_cosf+0xd2>
   307cc:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
   307d0:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
   307d4:	ee07 3a90 	vmov	s15, r3
   307d8:	ee36 6a67 	vsub.f32	s12, s12, s15
   307dc:	ee60 0ac0 	vnmul.f32	s1, s1, s0
   307e0:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
   307e4:	eee7 0a26 	vfma.f32	s1, s14, s13
   307e8:	eed7 7a25 	vfnms.f32	s15, s14, s11
   307ec:	ee77 7ae0 	vsub.f32	s15, s15, s1
   307f0:	ee36 0a67 	vsub.f32	s0, s12, s15
   307f4:	4770      	bx	lr
   307f6:	eeb6 6a07 	vmov.f32	s12, #103	; 0x3f380000  0.7187500
   307fa:	eef5 7a02 	vmov.f32	s15, #82	; 0x3e900000  0.2812500
   307fe:	e7ed      	b.n	307dc <__kernel_cosf+0xb8>
   30800:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30804:	4770      	bx	lr
   30806:	bf00      	nop
   30808:	ad47d74e 	.word	0xad47d74e
   3080c:	310f74f6 	.word	0x310f74f6
   30810:	b493f27c 	.word	0xb493f27c
   30814:	37d00d01 	.word	0x37d00d01
   30818:	bab60b61 	.word	0xbab60b61
   3081c:	3d2aaaab 	.word	0x3d2aaaab
   30820:	3e999999 	.word	0x3e999999
   30824:	3f480000 	.word	0x3f480000

00030828 <__kernel_rem_pio2f>:
   30828:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3082c:	ed2d 8b04 	vpush	{d8-d9}
   30830:	b0db      	sub	sp, #364	; 0x16c
   30832:	461c      	mov	r4, r3
   30834:	4681      	mov	r9, r0
   30836:	9304      	str	r3, [sp, #16]
   30838:	f104 38ff 	add.w	r8, r4, #4294967295	; 0xffffffff
   3083c:	4bd4      	ldr	r3, [pc, #848]	; (30b90 <__kernel_rem_pio2f+0x368>)
   3083e:	9107      	str	r1, [sp, #28]
   30840:	9968      	ldr	r1, [sp, #416]	; 0x1a0
   30842:	9209      	str	r2, [sp, #36]	; 0x24
   30844:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
   30848:	1d11      	adds	r1, r2, #4
   3084a:	f2c0 8274 	blt.w	30d36 <__kernel_rem_pio2f+0x50e>
   3084e:	1ed3      	subs	r3, r2, #3
   30850:	f100 82f1 	bmi.w	30e36 <__kernel_rem_pio2f+0x60e>
   30854:	10db      	asrs	r3, r3, #3
   30856:	9303      	str	r3, [sp, #12]
   30858:	3301      	adds	r3, #1
   3085a:	00db      	lsls	r3, r3, #3
   3085c:	9308      	str	r3, [sp, #32]
   3085e:	eb15 0108 	adds.w	r1, r5, r8
   30862:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   30866:	eba3 0302 	sub.w	r3, r3, r2
   3086a:	9306      	str	r3, [sp, #24]
   3086c:	9b03      	ldr	r3, [sp, #12]
   3086e:	eba3 0308 	sub.w	r3, r3, r8
   30872:	d414      	bmi.n	3089e <__kernel_rem_pio2f+0x76>
   30874:	3101      	adds	r1, #1
   30876:	aa1e      	add	r2, sp, #120	; 0x78
   30878:	ed9f 7ac8 	vldr	s14, [pc, #800]	; 30b9c <__kernel_rem_pio2f+0x374>
   3087c:	4419      	add	r1, r3
   3087e:	9869      	ldr	r0, [sp, #420]	; 0x1a4
   30880:	2b00      	cmp	r3, #0
   30882:	eef0 7a47 	vmov.f32	s15, s14
   30886:	db05      	blt.n	30894 <__kernel_rem_pio2f+0x6c>
   30888:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   3088c:	ee07 4a90 	vmov	s15, r4
   30890:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   30894:	3301      	adds	r3, #1
   30896:	ece2 7a01 	vstmia	r2!, {s15}
   3089a:	428b      	cmp	r3, r1
   3089c:	d1f0      	bne.n	30880 <__kernel_rem_pio2f+0x58>
   3089e:	9b04      	ldr	r3, [sp, #16]
   308a0:	2d00      	cmp	r5, #0
   308a2:	ea4f 0a85 	mov.w	sl, r5, lsl #2
   308a6:	ea4f 0483 	mov.w	r4, r3, lsl #2
   308aa:	db1d      	blt.n	308e8 <__kernel_rem_pio2f+0xc0>
   308ac:	ab1e      	add	r3, sp, #120	; 0x78
   308ae:	eb09 0104 	add.w	r1, r9, r4
   308b2:	a846      	add	r0, sp, #280	; 0x118
   308b4:	191e      	adds	r6, r3, r4
   308b6:	ab47      	add	r3, sp, #284	; 0x11c
   308b8:	eb03 070a 	add.w	r7, r3, sl
   308bc:	f1b8 0f00 	cmp.w	r8, #0
   308c0:	f2c0 8187 	blt.w	30bd2 <__kernel_rem_pio2f+0x3aa>
   308c4:	4632      	mov	r2, r6
   308c6:	464b      	mov	r3, r9
   308c8:	eddf 7ab4 	vldr	s15, [pc, #720]	; 30b9c <__kernel_rem_pio2f+0x374>
   308cc:	ecf3 6a01 	vldmia	r3!, {s13}
   308d0:	ed32 7a01 	vldmdb	r2!, {s14}
   308d4:	428b      	cmp	r3, r1
   308d6:	eee6 7a87 	vfma.f32	s15, s13, s14
   308da:	d1f7      	bne.n	308cc <__kernel_rem_pio2f+0xa4>
   308dc:	ece0 7a01 	vstmia	r0!, {s15}
   308e0:	42b8      	cmp	r0, r7
   308e2:	f106 0604 	add.w	r6, r6, #4
   308e6:	d1e9      	bne.n	308bc <__kernel_rem_pio2f+0x94>
   308e8:	f1aa 0308 	sub.w	r3, sl, #8
   308ec:	af0a      	add	r7, sp, #40	; 0x28
   308ee:	aa09      	add	r2, sp, #36	; 0x24
   308f0:	9500      	str	r5, [sp, #0]
   308f2:	18fb      	adds	r3, r7, r3
   308f4:	444c      	add	r4, r9
   308f6:	4492      	add	sl, r2
   308f8:	ae46      	add	r6, sp, #280	; 0x118
   308fa:	9305      	str	r3, [sp, #20]
   308fc:	462b      	mov	r3, r5
   308fe:	ed9f 9aa5 	vldr	s18, [pc, #660]	; 30b94 <__kernel_rem_pio2f+0x36c>
   30902:	eddf 8aa5 	vldr	s17, [pc, #660]	; 30b98 <__kernel_rem_pio2f+0x370>
   30906:	9d06      	ldr	r5, [sp, #24]
   30908:	0099      	lsls	r1, r3, #2
   3090a:	aa5a      	add	r2, sp, #360	; 0x168
   3090c:	2b00      	cmp	r3, #0
   3090e:	440a      	add	r2, r1
   30910:	ed12 0a14 	vldr	s0, [r2, #-80]	; 0xffffffb0
   30914:	dd16      	ble.n	30944 <__kernel_rem_pio2f+0x11c>
   30916:	eb06 0283 	add.w	r2, r6, r3, lsl #2
   3091a:	4638      	mov	r0, r7
   3091c:	ee60 7a09 	vmul.f32	s15, s0, s18
   30920:	ed72 6a01 	vldmdb	r2!, {s13}
   30924:	eeb0 7a40 	vmov.f32	s14, s0
   30928:	42b2      	cmp	r2, r6
   3092a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   3092e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   30932:	eea7 7ae8 	vfms.f32	s14, s15, s17
   30936:	ee37 0aa6 	vadd.f32	s0, s15, s13
   3093a:	eebd 7ac7 	vcvt.s32.f32	s14, s14
   3093e:	eca0 7a01 	vstmia	r0!, {s14}
   30942:	d1eb      	bne.n	3091c <__kernel_rem_pio2f+0xf4>
   30944:	4628      	mov	r0, r5
   30946:	e9cd 1301 	strd	r1, r3, [sp, #4]
   3094a:	f000 fbbb 	bl	310c4 <scalbnf>
   3094e:	eeb0 8a40 	vmov.f32	s16, s0
   30952:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
   30956:	ee28 0a00 	vmul.f32	s0, s16, s0
   3095a:	f7fe fd75 	bl	2f448 <floorf>
   3095e:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
   30962:	2d00      	cmp	r5, #0
   30964:	eea0 8a67 	vfms.f32	s16, s0, s15
   30968:	e9dd 1301 	ldrd	r1, r3, [sp, #4]
   3096c:	eefd 9ac8 	vcvt.s32.f32	s19, s16
   30970:	eef8 7ae9 	vcvt.f32.s32	s15, s19
   30974:	ee38 8a67 	vsub.f32	s16, s16, s15
   30978:	f340 8081 	ble.w	30a7e <__kernel_rem_pio2f+0x256>
   3097c:	1e58      	subs	r0, r3, #1
   3097e:	f1c5 0208 	rsb	r2, r5, #8
   30982:	f1c5 0b07 	rsb	fp, r5, #7
   30986:	f857 c020 	ldr.w	ip, [r7, r0, lsl #2]
   3098a:	fa4c fe02 	asr.w	lr, ip, r2
   3098e:	fa0e f202 	lsl.w	r2, lr, r2
   30992:	9201      	str	r2, [sp, #4]
   30994:	ee19 2a90 	vmov	r2, s19
   30998:	4472      	add	r2, lr
   3099a:	ee09 2a90 	vmov	s19, r2
   3099e:	9a01      	ldr	r2, [sp, #4]
   309a0:	ebac 0202 	sub.w	r2, ip, r2
   309a4:	fa42 fb0b 	asr.w	fp, r2, fp
   309a8:	f847 2020 	str.w	r2, [r7, r0, lsl #2]
   309ac:	f1bb 0f00 	cmp.w	fp, #0
   309b0:	dc6f      	bgt.n	30a92 <__kernel_rem_pio2f+0x26a>
   309b2:	eeb5 8a40 	vcmp.f32	s16, #0.0
   309b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   309ba:	f040 80aa 	bne.w	30b12 <__kernel_rem_pio2f+0x2ea>
   309be:	f103 3cff 	add.w	ip, r3, #4294967295	; 0xffffffff
   309c2:	9a00      	ldr	r2, [sp, #0]
   309c4:	4562      	cmp	r2, ip
   309c6:	dc0e      	bgt.n	309e6 <__kernel_rem_pio2f+0x1be>
   309c8:	f06f 4240 	mvn.w	r2, #3221225472	; 0xc0000000
   309cc:	2100      	movs	r1, #0
   309ce:	441a      	add	r2, r3
   309d0:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   309d4:	f852 0904 	ldr.w	r0, [r2], #-4
   309d8:	4552      	cmp	r2, sl
   309da:	ea41 0100 	orr.w	r1, r1, r0
   309de:	d1f9      	bne.n	309d4 <__kernel_rem_pio2f+0x1ac>
   309e0:	2900      	cmp	r1, #0
   309e2:	f040 80ff 	bne.w	30be4 <__kernel_rem_pio2f+0x3bc>
   309e6:	9a00      	ldr	r2, [sp, #0]
   309e8:	3a01      	subs	r2, #1
   309ea:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
   309ee:	2a00      	cmp	r2, #0
   309f0:	f040 80ea 	bne.w	30bc8 <__kernel_rem_pio2f+0x3a0>
   309f4:	9a05      	ldr	r2, [sp, #20]
   309f6:	2001      	movs	r0, #1
   309f8:	f852 1904 	ldr.w	r1, [r2], #-4
   309fc:	3001      	adds	r0, #1
   309fe:	2900      	cmp	r1, #0
   30a00:	d0fa      	beq.n	309f8 <__kernel_rem_pio2f+0x1d0>
   30a02:	f103 0e01 	add.w	lr, r3, #1
   30a06:	4418      	add	r0, r3
   30a08:	46f4      	mov	ip, lr
   30a0a:	9a03      	ldr	r2, [sp, #12]
   30a0c:	f06f 4b40 	mvn.w	fp, #3221225472	; 0xc0000000
   30a10:	9904      	ldr	r1, [sp, #16]
   30a12:	4472      	add	r2, lr
   30a14:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   30a18:	440b      	add	r3, r1
   30a1a:	4493      	add	fp, r2
   30a1c:	aa1e      	add	r2, sp, #120	; 0x78
   30a1e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
   30a22:	9b69      	ldr	r3, [sp, #420]	; 0x1a4
   30a24:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
   30a28:	f85b 3f04 	ldr.w	r3, [fp, #4]!
   30a2c:	4611      	mov	r1, r2
   30a2e:	f1b8 0f00 	cmp.w	r8, #0
   30a32:	ee07 3a90 	vmov	s15, r3
   30a36:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   30a3a:	ece1 7a01 	vstmia	r1!, {s15}
   30a3e:	db14      	blt.n	30a6a <__kernel_rem_pio2f+0x242>
   30a40:	464b      	mov	r3, r9
   30a42:	ed9f 7a56 	vldr	s14, [pc, #344]	; 30b9c <__kernel_rem_pio2f+0x374>
   30a46:	e001      	b.n	30a4c <__kernel_rem_pio2f+0x224>
   30a48:	ed72 7a01 	vldmdb	r2!, {s15}
   30a4c:	ecf3 6a01 	vldmia	r3!, {s13}
   30a50:	42a3      	cmp	r3, r4
   30a52:	eea6 7aa7 	vfma.f32	s14, s13, s15
   30a56:	d1f7      	bne.n	30a48 <__kernel_rem_pio2f+0x220>
   30a58:	f10c 0c01 	add.w	ip, ip, #1
   30a5c:	ecae 7a01 	vstmia	lr!, {s14}
   30a60:	460a      	mov	r2, r1
   30a62:	4584      	cmp	ip, r0
   30a64:	dde0      	ble.n	30a28 <__kernel_rem_pio2f+0x200>
   30a66:	4603      	mov	r3, r0
   30a68:	e74e      	b.n	30908 <__kernel_rem_pio2f+0xe0>
   30a6a:	f10c 0c01 	add.w	ip, ip, #1
   30a6e:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 30b9c <__kernel_rem_pio2f+0x374>
   30a72:	460a      	mov	r2, r1
   30a74:	4584      	cmp	ip, r0
   30a76:	ecae 7a01 	vstmia	lr!, {s14}
   30a7a:	ddd5      	ble.n	30a28 <__kernel_rem_pio2f+0x200>
   30a7c:	e7f3      	b.n	30a66 <__kernel_rem_pio2f+0x23e>
   30a7e:	f040 8098 	bne.w	30bb2 <__kernel_rem_pio2f+0x38a>
   30a82:	1e5a      	subs	r2, r3, #1
   30a84:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
   30a88:	ea4f 2b22 	mov.w	fp, r2, asr #8
   30a8c:	f1bb 0f00 	cmp.w	fp, #0
   30a90:	dd8f      	ble.n	309b2 <__kernel_rem_pio2f+0x18a>
   30a92:	ee19 2a90 	vmov	r2, s19
   30a96:	2b00      	cmp	r3, #0
   30a98:	f102 0201 	add.w	r2, r2, #1
   30a9c:	ee09 2a90 	vmov	s19, r2
   30aa0:	f340 81cc 	ble.w	30e3c <__kernel_rem_pio2f+0x614>
   30aa4:	6838      	ldr	r0, [r7, #0]
   30aa6:	2800      	cmp	r0, #0
   30aa8:	d162      	bne.n	30b70 <__kernel_rem_pio2f+0x348>
   30aaa:	2b01      	cmp	r3, #1
   30aac:	d00b      	beq.n	30ac6 <__kernel_rem_pio2f+0x29e>
   30aae:	46be      	mov	lr, r7
   30ab0:	f04f 0c01 	mov.w	ip, #1
   30ab4:	f85e 0f04 	ldr.w	r0, [lr, #4]!
   30ab8:	f10c 0201 	add.w	r2, ip, #1
   30abc:	2800      	cmp	r0, #0
   30abe:	d15a      	bne.n	30b76 <__kernel_rem_pio2f+0x34e>
   30ac0:	4293      	cmp	r3, r2
   30ac2:	4694      	mov	ip, r2
   30ac4:	d1f6      	bne.n	30ab4 <__kernel_rem_pio2f+0x28c>
   30ac6:	2d00      	cmp	r5, #0
   30ac8:	dd0b      	ble.n	30ae2 <__kernel_rem_pio2f+0x2ba>
   30aca:	2d01      	cmp	r5, #1
   30acc:	f000 811f 	beq.w	30d0e <__kernel_rem_pio2f+0x4e6>
   30ad0:	2d02      	cmp	r5, #2
   30ad2:	d106      	bne.n	30ae2 <__kernel_rem_pio2f+0x2ba>
   30ad4:	1e59      	subs	r1, r3, #1
   30ad6:	f857 2021 	ldr.w	r2, [r7, r1, lsl #2]
   30ada:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   30ade:	f847 2021 	str.w	r2, [r7, r1, lsl #2]
   30ae2:	f1bb 0f02 	cmp.w	fp, #2
   30ae6:	f47f af64 	bne.w	309b2 <__kernel_rem_pio2f+0x18a>
   30aea:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30aee:	ee30 8a48 	vsub.f32	s16, s0, s16
   30af2:	2800      	cmp	r0, #0
   30af4:	f43f af5d 	beq.w	309b2 <__kernel_rem_pio2f+0x18a>
   30af8:	4628      	mov	r0, r5
   30afa:	9301      	str	r3, [sp, #4]
   30afc:	f000 fae2 	bl	310c4 <scalbnf>
   30b00:	ee38 8a40 	vsub.f32	s16, s16, s0
   30b04:	9b01      	ldr	r3, [sp, #4]
   30b06:	eeb5 8a40 	vcmp.f32	s16, #0.0
   30b0a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30b0e:	f43f af56 	beq.w	309be <__kernel_rem_pio2f+0x196>
   30b12:	9301      	str	r3, [sp, #4]
   30b14:	eeb0 0a48 	vmov.f32	s0, s16
   30b18:	9d00      	ldr	r5, [sp, #0]
   30b1a:	46d8      	mov	r8, fp
   30b1c:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
   30b20:	1a98      	subs	r0, r3, r2
   30b22:	f000 facf 	bl	310c4 <scalbnf>
   30b26:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 30b98 <__kernel_rem_pio2f+0x370>
   30b2a:	9b01      	ldr	r3, [sp, #4]
   30b2c:	eeb4 0ac7 	vcmpe.f32	s0, s14
   30b30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30b34:	f2c0 8184 	blt.w	30e40 <__kernel_rem_pio2f+0x618>
   30b38:	eddf 7a16 	vldr	s15, [pc, #88]	; 30b94 <__kernel_rem_pio2f+0x36c>
   30b3c:	f103 0b01 	add.w	fp, r3, #1
   30b40:	9a06      	ldr	r2, [sp, #24]
   30b42:	ee60 7a27 	vmul.f32	s15, s0, s15
   30b46:	3208      	adds	r2, #8
   30b48:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   30b4c:	9206      	str	r2, [sp, #24]
   30b4e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   30b52:	eea7 0ac7 	vfms.f32	s0, s15, s14
   30b56:	eefd 7ae7 	vcvt.s32.f32	s15, s15
   30b5a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   30b5e:	ee10 2a10 	vmov	r2, s0
   30b62:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
   30b66:	ee17 3a90 	vmov	r3, s15
   30b6a:	f847 302b 	str.w	r3, [r7, fp, lsl #2]
   30b6e:	e04f      	b.n	30c10 <__kernel_rem_pio2f+0x3e8>
   30b70:	2201      	movs	r2, #1
   30b72:	f04f 0c00 	mov.w	ip, #0
   30b76:	f5c0 7080 	rsb	r0, r0, #256	; 0x100
   30b7a:	4293      	cmp	r3, r2
   30b7c:	f847 002c 	str.w	r0, [r7, ip, lsl #2]
   30b80:	dd15      	ble.n	30bae <__kernel_rem_pio2f+0x386>
   30b82:	f857 0022 	ldr.w	r0, [r7, r2, lsl #2]
   30b86:	4439      	add	r1, r7
   30b88:	eb07 0282 	add.w	r2, r7, r2, lsl #2
   30b8c:	e009      	b.n	30ba2 <__kernel_rem_pio2f+0x37a>
   30b8e:	bf00      	nop
   30b90:	0003b374 	.word	0x0003b374
   30b94:	3b800000 	.word	0x3b800000
   30b98:	43800000 	.word	0x43800000
   30b9c:	00000000 	.word	0x00000000
   30ba0:	6810      	ldr	r0, [r2, #0]
   30ba2:	f1c0 00ff 	rsb	r0, r0, #255	; 0xff
   30ba6:	f842 0b04 	str.w	r0, [r2], #4
   30baa:	428a      	cmp	r2, r1
   30bac:	d1f8      	bne.n	30ba0 <__kernel_rem_pio2f+0x378>
   30bae:	2001      	movs	r0, #1
   30bb0:	e789      	b.n	30ac6 <__kernel_rem_pio2f+0x29e>
   30bb2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
   30bb6:	eeb4 8ae7 	vcmpe.f32	s16, s15
   30bba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   30bbe:	f280 80ae 	bge.w	30d1e <__kernel_rem_pio2f+0x4f6>
   30bc2:	f04f 0b00 	mov.w	fp, #0
   30bc6:	e6f4      	b.n	309b2 <__kernel_rem_pio2f+0x18a>
   30bc8:	f103 0e01 	add.w	lr, r3, #1
   30bcc:	46f4      	mov	ip, lr
   30bce:	4670      	mov	r0, lr
   30bd0:	e71b      	b.n	30a0a <__kernel_rem_pio2f+0x1e2>
   30bd2:	ed5f 7a0e 	vldr	s15, [pc, #-56]	; 30b9c <__kernel_rem_pio2f+0x374>
   30bd6:	3604      	adds	r6, #4
   30bd8:	ece0 7a01 	vstmia	r0!, {s15}
   30bdc:	42b8      	cmp	r0, r7
   30bde:	f47f ae6d 	bne.w	308bc <__kernel_rem_pio2f+0x94>
   30be2:	e681      	b.n	308e8 <__kernel_rem_pio2f+0xc0>
   30be4:	9906      	ldr	r1, [sp, #24]
   30be6:	46d8      	mov	r8, fp
   30be8:	f857 202c 	ldr.w	r2, [r7, ip, lsl #2]
   30bec:	46e3      	mov	fp, ip
   30bee:	3908      	subs	r1, #8
   30bf0:	9d00      	ldr	r5, [sp, #0]
   30bf2:	9106      	str	r1, [sp, #24]
   30bf4:	b962      	cbnz	r2, 30c10 <__kernel_rem_pio2f+0x3e8>
   30bf6:	4ab0      	ldr	r2, [pc, #704]	; (30eb8 <__kernel_rem_pio2f+0x690>)
   30bf8:	441a      	add	r2, r3
   30bfa:	eb07 0382 	add.w	r3, r7, r2, lsl #2
   30bfe:	460a      	mov	r2, r1
   30c00:	f853 1904 	ldr.w	r1, [r3], #-4
   30c04:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
   30c08:	3a08      	subs	r2, #8
   30c0a:	2900      	cmp	r1, #0
   30c0c:	d0f8      	beq.n	30c00 <__kernel_rem_pio2f+0x3d8>
   30c0e:	9206      	str	r2, [sp, #24]
   30c10:	9806      	ldr	r0, [sp, #24]
   30c12:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
   30c16:	f000 fa55 	bl	310c4 <scalbnf>
   30c1a:	f1bb 0f00 	cmp.w	fp, #0
   30c1e:	f2c0 8136 	blt.w	30e8e <__kernel_rem_pio2f+0x666>
   30c22:	ea4f 048b 	mov.w	r4, fp, lsl #2
   30c26:	ab46      	add	r3, sp, #280	; 0x118
   30c28:	ed9f 7aa4 	vldr	s14, [pc, #656]	; 30ebc <__kernel_rem_pio2f+0x694>
   30c2c:	1d26      	adds	r6, r4, #4
   30c2e:	441c      	add	r4, r3
   30c30:	19bb      	adds	r3, r7, r6
   30c32:	1d22      	adds	r2, r4, #4
   30c34:	ed73 7a01 	vldmdb	r3!, {s15}
   30c38:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   30c3c:	42bb      	cmp	r3, r7
   30c3e:	ee67 7a80 	vmul.f32	s15, s15, s0
   30c42:	ee20 0a07 	vmul.f32	s0, s0, s14
   30c46:	ed62 7a01 	vstmdb	r2!, {s15}
   30c4a:	d1f3      	bne.n	30c34 <__kernel_rem_pio2f+0x40c>
   30c4c:	f10d 0cc8 	add.w	ip, sp, #200	; 0xc8
   30c50:	2d00      	cmp	r5, #0
   30c52:	f04f 0000 	mov.w	r0, #0
   30c56:	ed9f 6a9a 	vldr	s12, [pc, #616]	; 30ec0 <__kernel_rem_pio2f+0x698>
   30c5a:	4667      	mov	r7, ip
   30c5c:	db1d      	blt.n	30c9a <__kernel_rem_pio2f+0x472>
   30c5e:	4999      	ldr	r1, [pc, #612]	; (30ec4 <__kernel_rem_pio2f+0x69c>)
   30c60:	4622      	mov	r2, r4
   30c62:	eeb0 7a46 	vmov.f32	s14, s12
   30c66:	eddf 7a98 	vldr	s15, [pc, #608]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30c6a:	2300      	movs	r3, #0
   30c6c:	e003      	b.n	30c76 <__kernel_rem_pio2f+0x44e>
   30c6e:	4283      	cmp	r3, r0
   30c70:	dc08      	bgt.n	30c84 <__kernel_rem_pio2f+0x45c>
   30c72:	ecb1 7a01 	vldmia	r1!, {s14}
   30c76:	3301      	adds	r3, #1
   30c78:	ecf2 6a01 	vldmia	r2!, {s13}
   30c7c:	429d      	cmp	r5, r3
   30c7e:	eee6 7a87 	vfma.f32	s15, s13, s14
   30c82:	daf4      	bge.n	30c6e <__kernel_rem_pio2f+0x446>
   30c84:	4558      	cmp	r0, fp
   30c86:	ece7 7a01 	vstmia	r7!, {s15}
   30c8a:	f1a4 0404 	sub.w	r4, r4, #4
   30c8e:	f100 0301 	add.w	r3, r0, #1
   30c92:	d00c      	beq.n	30cae <__kernel_rem_pio2f+0x486>
   30c94:	2d00      	cmp	r5, #0
   30c96:	4618      	mov	r0, r3
   30c98:	dae1      	bge.n	30c5e <__kernel_rem_pio2f+0x436>
   30c9a:	eddf 7a8b 	vldr	s15, [pc, #556]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30c9e:	4558      	cmp	r0, fp
   30ca0:	f1a4 0404 	sub.w	r4, r4, #4
   30ca4:	f100 0301 	add.w	r3, r0, #1
   30ca8:	ece7 7a01 	vstmia	r7!, {s15}
   30cac:	d1f2      	bne.n	30c94 <__kernel_rem_pio2f+0x46c>
   30cae:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
   30cb0:	2b03      	cmp	r3, #3
   30cb2:	d823      	bhi.n	30cfc <__kernel_rem_pio2f+0x4d4>
   30cb4:	e8df f003 	tbb	[pc, r3]
   30cb8:	449c9cae 	.word	0x449c9cae
   30cbc:	eddf 7a82 	vldr	s15, [pc, #520]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30cc0:	4643      	mov	r3, r8
   30cc2:	ed9d 7a32 	vldr	s14, [sp, #200]	; 0xc8
   30cc6:	ee37 7a67 	vsub.f32	s14, s14, s15
   30cca:	2b00      	cmp	r3, #0
   30ccc:	f040 80c0 	bne.w	30e50 <__kernel_rem_pio2f+0x628>
   30cd0:	9b07      	ldr	r3, [sp, #28]
   30cd2:	f1bb 0f00 	cmp.w	fp, #0
   30cd6:	edc3 7a00 	vstr	s15, [r3]
   30cda:	dd0c      	ble.n	30cf6 <__kernel_rem_pio2f+0x4ce>
   30cdc:	aa33      	add	r2, sp, #204	; 0xcc
   30cde:	2301      	movs	r3, #1
   30ce0:	3301      	adds	r3, #1
   30ce2:	ecf2 7a01 	vldmia	r2!, {s15}
   30ce6:	459b      	cmp	fp, r3
   30ce8:	ee37 7a27 	vadd.f32	s14, s14, s15
   30cec:	daf8      	bge.n	30ce0 <__kernel_rem_pio2f+0x4b8>
   30cee:	4643      	mov	r3, r8
   30cf0:	b10b      	cbz	r3, 30cf6 <__kernel_rem_pio2f+0x4ce>
   30cf2:	eeb1 7a47 	vneg.f32	s14, s14
   30cf6:	9b07      	ldr	r3, [sp, #28]
   30cf8:	ed83 7a01 	vstr	s14, [r3, #4]
   30cfc:	ee19 3a90 	vmov	r3, s19
   30d00:	f003 0007 	and.w	r0, r3, #7
   30d04:	b05b      	add	sp, #364	; 0x16c
   30d06:	ecbd 8b04 	vpop	{d8-d9}
   30d0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30d0e:	1e59      	subs	r1, r3, #1
   30d10:	f857 2021 	ldr.w	r2, [r7, r1, lsl #2]
   30d14:	f002 027f 	and.w	r2, r2, #127	; 0x7f
   30d18:	f847 2021 	str.w	r2, [r7, r1, lsl #2]
   30d1c:	e6e1      	b.n	30ae2 <__kernel_rem_pio2f+0x2ba>
   30d1e:	ee19 2a90 	vmov	r2, s19
   30d22:	2b00      	cmp	r3, #0
   30d24:	f102 0201 	add.w	r2, r2, #1
   30d28:	ee09 2a90 	vmov	s19, r2
   30d2c:	f340 80a8 	ble.w	30e80 <__kernel_rem_pio2f+0x658>
   30d30:	f04f 0b02 	mov.w	fp, #2
   30d34:	e6b6      	b.n	30aa4 <__kernel_rem_pio2f+0x27c>
   30d36:	2308      	movs	r3, #8
   30d38:	9308      	str	r3, [sp, #32]
   30d3a:	2300      	movs	r3, #0
   30d3c:	9303      	str	r3, [sp, #12]
   30d3e:	e58e      	b.n	3085e <__kernel_rem_pio2f+0x36>
   30d40:	f1bb 0f00 	cmp.w	fp, #0
   30d44:	f340 80b5 	ble.w	30eb2 <__kernel_rem_pio2f+0x68a>
   30d48:	ab5a      	add	r3, sp, #360	; 0x168
   30d4a:	ea4f 028b 	mov.w	r2, fp, lsl #2
   30d4e:	f10d 0cc8 	add.w	ip, sp, #200	; 0xc8
   30d52:	1899      	adds	r1, r3, r2
   30d54:	eb0c 038b 	add.w	r3, ip, fp, lsl #2
   30d58:	ed51 6a28 	vldr	s13, [r1, #-160]	; 0xffffff60
   30d5c:	ed73 7a01 	vldmdb	r3!, {s15}
   30d60:	ee37 7aa6 	vadd.f32	s14, s15, s13
   30d64:	459c      	cmp	ip, r3
   30d66:	ee77 7ac7 	vsub.f32	s15, s15, s14
   30d6a:	ed83 7a00 	vstr	s14, [r3]
   30d6e:	ee77 7aa6 	vadd.f32	s15, s15, s13
   30d72:	eef0 6a47 	vmov.f32	s13, s14
   30d76:	edc3 7a01 	vstr	s15, [r3, #4]
   30d7a:	d1ef      	bne.n	30d5c <__kernel_rem_pio2f+0x534>
   30d7c:	f1bb 0f01 	cmp.w	fp, #1
   30d80:	f340 8097 	ble.w	30eb2 <__kernel_rem_pio2f+0x68a>
   30d84:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
   30d88:	a95a      	add	r1, sp, #360	; 0x168
   30d8a:	445b      	add	r3, fp
   30d8c:	440a      	add	r2, r1
   30d8e:	a933      	add	r1, sp, #204	; 0xcc
   30d90:	009b      	lsls	r3, r3, #2
   30d92:	ed52 6a28 	vldr	s13, [r2, #-160]	; 0xffffff60
   30d96:	1d1a      	adds	r2, r3, #4
   30d98:	4462      	add	r2, ip
   30d9a:	ed72 7a01 	vldmdb	r2!, {s15}
   30d9e:	ee37 7aa6 	vadd.f32	s14, s15, s13
   30da2:	4291      	cmp	r1, r2
   30da4:	ee77 7ac7 	vsub.f32	s15, s15, s14
   30da8:	ed82 7a00 	vstr	s14, [r2]
   30dac:	ee77 7aa6 	vadd.f32	s15, s15, s13
   30db0:	eef0 6a47 	vmov.f32	s13, s14
   30db4:	edc2 7a01 	vstr	s15, [r2, #4]
   30db8:	d1ef      	bne.n	30d9a <__kernel_rem_pio2f+0x572>
   30dba:	3308      	adds	r3, #8
   30dbc:	f10c 0208 	add.w	r2, ip, #8
   30dc0:	eddf 7a41 	vldr	s15, [pc, #260]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30dc4:	449c      	add	ip, r3
   30dc6:	ed3c 7a01 	vldmdb	ip!, {s14}
   30dca:	4562      	cmp	r2, ip
   30dcc:	ee77 7a87 	vadd.f32	s15, s15, s14
   30dd0:	d1f9      	bne.n	30dc6 <__kernel_rem_pio2f+0x59e>
   30dd2:	4643      	mov	r3, r8
   30dd4:	eddd 6a32 	vldr	s13, [sp, #200]	; 0xc8
   30dd8:	ed9d 7a33 	vldr	s14, [sp, #204]	; 0xcc
   30ddc:	2b00      	cmp	r3, #0
   30dde:	d141      	bne.n	30e64 <__kernel_rem_pio2f+0x63c>
   30de0:	9b07      	ldr	r3, [sp, #28]
   30de2:	edc3 6a00 	vstr	s13, [r3]
   30de6:	ed83 7a01 	vstr	s14, [r3, #4]
   30dea:	edc3 7a02 	vstr	s15, [r3, #8]
   30dee:	e785      	b.n	30cfc <__kernel_rem_pio2f+0x4d4>
   30df0:	4466      	add	r6, ip
   30df2:	eddf 7a35 	vldr	s15, [pc, #212]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30df6:	ed36 7a01 	vldmdb	r6!, {s14}
   30dfa:	45b4      	cmp	ip, r6
   30dfc:	ee77 7a87 	vadd.f32	s15, s15, s14
   30e00:	d1f9      	bne.n	30df6 <__kernel_rem_pio2f+0x5ce>
   30e02:	ed9d 7a32 	vldr	s14, [sp, #200]	; 0xc8
   30e06:	4643      	mov	r3, r8
   30e08:	ee37 7a67 	vsub.f32	s14, s14, s15
   30e0c:	2b00      	cmp	r3, #0
   30e0e:	f43f af5f 	beq.w	30cd0 <__kernel_rem_pio2f+0x4a8>
   30e12:	e01d      	b.n	30e50 <__kernel_rem_pio2f+0x628>
   30e14:	4466      	add	r6, ip
   30e16:	eddf 7a2c 	vldr	s15, [pc, #176]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30e1a:	ed36 7a01 	vldmdb	r6!, {s14}
   30e1e:	45b4      	cmp	ip, r6
   30e20:	ee77 7a87 	vadd.f32	s15, s15, s14
   30e24:	d1f9      	bne.n	30e1a <__kernel_rem_pio2f+0x5f2>
   30e26:	4643      	mov	r3, r8
   30e28:	b10b      	cbz	r3, 30e2e <__kernel_rem_pio2f+0x606>
   30e2a:	eef1 7a67 	vneg.f32	s15, s15
   30e2e:	9b07      	ldr	r3, [sp, #28]
   30e30:	edc3 7a00 	vstr	s15, [r3]
   30e34:	e762      	b.n	30cfc <__kernel_rem_pio2f+0x4d4>
   30e36:	4613      	mov	r3, r2
   30e38:	3304      	adds	r3, #4
   30e3a:	e50b      	b.n	30854 <__kernel_rem_pio2f+0x2c>
   30e3c:	2000      	movs	r0, #0
   30e3e:	e642      	b.n	30ac6 <__kernel_rem_pio2f+0x29e>
   30e40:	eebd 0ac0 	vcvt.s32.f32	s0, s0
   30e44:	469b      	mov	fp, r3
   30e46:	ee10 2a10 	vmov	r2, s0
   30e4a:	f847 2023 	str.w	r2, [r7, r3, lsl #2]
   30e4e:	e6df      	b.n	30c10 <__kernel_rem_pio2f+0x3e8>
   30e50:	eef1 7a67 	vneg.f32	s15, s15
   30e54:	9b07      	ldr	r3, [sp, #28]
   30e56:	f1bb 0f00 	cmp.w	fp, #0
   30e5a:	edc3 7a00 	vstr	s15, [r3]
   30e5e:	f73f af3d 	bgt.w	30cdc <__kernel_rem_pio2f+0x4b4>
   30e62:	e746      	b.n	30cf2 <__kernel_rem_pio2f+0x4ca>
   30e64:	eef1 6a66 	vneg.f32	s13, s13
   30e68:	9b07      	ldr	r3, [sp, #28]
   30e6a:	eeb1 7a47 	vneg.f32	s14, s14
   30e6e:	eef1 7a67 	vneg.f32	s15, s15
   30e72:	edc3 6a00 	vstr	s13, [r3]
   30e76:	ed83 7a01 	vstr	s14, [r3, #4]
   30e7a:	edc3 7a02 	vstr	s15, [r3, #8]
   30e7e:	e73d      	b.n	30cfc <__kernel_rem_pio2f+0x4d4>
   30e80:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
   30e84:	f04f 0b02 	mov.w	fp, #2
   30e88:	ee37 8ac8 	vsub.f32	s16, s15, s16
   30e8c:	e591      	b.n	309b2 <__kernel_rem_pio2f+0x18a>
   30e8e:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
   30e90:	2b03      	cmp	r3, #3
   30e92:	f63f af33 	bhi.w	30cfc <__kernel_rem_pio2f+0x4d4>
   30e96:	a201      	add	r2, pc, #4	; (adr r2, 30e9c <__kernel_rem_pio2f+0x674>)
   30e98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   30e9c:	00030ead 	.word	0x00030ead
   30ea0:	00030cbd 	.word	0x00030cbd
   30ea4:	00030cbd 	.word	0x00030cbd
   30ea8:	00030d41 	.word	0x00030d41
   30eac:	eddf 7a06 	vldr	s15, [pc, #24]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30eb0:	e7b9      	b.n	30e26 <__kernel_rem_pio2f+0x5fe>
   30eb2:	eddf 7a05 	vldr	s15, [pc, #20]	; 30ec8 <__kernel_rem_pio2f+0x6a0>
   30eb6:	e78c      	b.n	30dd2 <__kernel_rem_pio2f+0x5aa>
   30eb8:	3ffffffe 	.word	0x3ffffffe
   30ebc:	3b800000 	.word	0x3b800000
   30ec0:	3fc90000 	.word	0x3fc90000
   30ec4:	0003b34c 	.word	0x0003b34c
   30ec8:	00000000 	.word	0x00000000

00030ecc <__kernel_sinf>:
   30ecc:	ee10 3a10 	vmov	r3, s0
   30ed0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   30ed4:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
   30ed8:	da04      	bge.n	30ee4 <__kernel_sinf+0x18>
   30eda:	eefd 7ac0 	vcvt.s32.f32	s15, s0
   30ede:	ee17 3a90 	vmov	r3, s15
   30ee2:	b35b      	cbz	r3, 30f3c <__kernel_sinf+0x70>
   30ee4:	ee60 7a00 	vmul.f32	s15, s0, s0
   30ee8:	ed9f 7a15 	vldr	s14, [pc, #84]	; 30f40 <__kernel_sinf+0x74>
   30eec:	eddf 5a15 	vldr	s11, [pc, #84]	; 30f44 <__kernel_sinf+0x78>
   30ef0:	ed9f 6a15 	vldr	s12, [pc, #84]	; 30f48 <__kernel_sinf+0x7c>
   30ef4:	eee7 5a87 	vfma.f32	s11, s15, s14
   30ef8:	eddf 6a14 	vldr	s13, [pc, #80]	; 30f4c <__kernel_sinf+0x80>
   30efc:	ed9f 7a14 	vldr	s14, [pc, #80]	; 30f50 <__kernel_sinf+0x84>
   30f00:	ee20 5a27 	vmul.f32	s10, s0, s15
   30f04:	eea5 6aa7 	vfma.f32	s12, s11, s15
   30f08:	eee6 6a27 	vfma.f32	s13, s12, s15
   30f0c:	eea6 7aa7 	vfma.f32	s14, s13, s15
   30f10:	b930      	cbnz	r0, 30f20 <__kernel_sinf+0x54>
   30f12:	eddf 6a10 	vldr	s13, [pc, #64]	; 30f54 <__kernel_sinf+0x88>
   30f16:	eee7 6a87 	vfma.f32	s13, s15, s14
   30f1a:	eea6 0a85 	vfma.f32	s0, s13, s10
   30f1e:	4770      	bx	lr
   30f20:	ee27 7a45 	vnmul.f32	s14, s14, s10
   30f24:	eddf 6a0c 	vldr	s13, [pc, #48]	; 30f58 <__kernel_sinf+0x8c>
   30f28:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
   30f2c:	eea0 7a86 	vfma.f32	s14, s1, s12
   30f30:	eed7 0a27 	vfnms.f32	s1, s14, s15
   30f34:	eee5 0a26 	vfma.f32	s1, s10, s13
   30f38:	ee30 0a60 	vsub.f32	s0, s0, s1
   30f3c:	4770      	bx	lr
   30f3e:	bf00      	nop
   30f40:	2f2ec9d3 	.word	0x2f2ec9d3
   30f44:	b2d72f34 	.word	0xb2d72f34
   30f48:	3638ef1b 	.word	0x3638ef1b
   30f4c:	b9500d01 	.word	0xb9500d01
   30f50:	3c088889 	.word	0x3c088889
   30f54:	be2aaaab 	.word	0xbe2aaaab
   30f58:	3e2aaaab 	.word	0x3e2aaaab

00030f5c <finite>:
   30f5c:	ee10 3a90 	vmov	r3, s1
   30f60:	4802      	ldr	r0, [pc, #8]	; (30f6c <finite+0x10>)
   30f62:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   30f66:	4418      	add	r0, r3
   30f68:	0fc0      	lsrs	r0, r0, #31
   30f6a:	4770      	bx	lr
   30f6c:	80100000 	.word	0x80100000

00030f70 <rint>:
   30f70:	ec53 2b10 	vmov	r2, r3, d0
   30f74:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   30f78:	f3c3 560a 	ubfx	r6, r3, #20, #11
   30f7c:	b083      	sub	sp, #12
   30f7e:	4619      	mov	r1, r3
   30f80:	ee10 5a10 	vmov	r5, s0
   30f84:	f2a6 30ff 	subw	r0, r6, #1023	; 0x3ff
   30f88:	0fdc      	lsrs	r4, r3, #31
   30f8a:	2813      	cmp	r0, #19
   30f8c:	dc38      	bgt.n	31000 <rint+0x90>
   30f8e:	2800      	cmp	r0, #0
   30f90:	db2d      	blt.n	30fee <rint+0x7e>
   30f92:	4e3f      	ldr	r6, [pc, #252]	; (31090 <rint+0x120>)
   30f94:	4106      	asrs	r6, r0
   30f96:	ea03 0706 	and.w	r7, r3, r6
   30f9a:	4317      	orrs	r7, r2
   30f9c:	d02b      	beq.n	30ff6 <rint+0x86>
   30f9e:	0876      	lsrs	r6, r6, #1
   30fa0:	4033      	ands	r3, r6
   30fa2:	431d      	orrs	r5, r3
   30fa4:	d00b      	beq.n	30fbe <rint+0x4e>
   30fa6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   30faa:	2813      	cmp	r0, #19
   30fac:	ea21 0606 	bic.w	r6, r1, r6
   30fb0:	fa43 f100 	asr.w	r1, r3, r0
   30fb4:	bf0c      	ite	eq
   30fb6:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
   30fba:	2500      	movne	r5, #0
   30fbc:	4331      	orrs	r1, r6
   30fbe:	4835      	ldr	r0, [pc, #212]	; (31094 <rint+0x124>)
   30fc0:	462a      	mov	r2, r5
   30fc2:	460b      	mov	r3, r1
   30fc4:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
   30fc8:	e9d4 4500 	ldrd	r4, r5, [r4]
   30fcc:	4620      	mov	r0, r4
   30fce:	4629      	mov	r1, r5
   30fd0:	f7db feb6 	bl	cd40 <__adddf3>
   30fd4:	4622      	mov	r2, r4
   30fd6:	462b      	mov	r3, r5
   30fd8:	e9cd 0100 	strd	r0, r1, [sp]
   30fdc:	e9dd 0100 	ldrd	r0, r1, [sp]
   30fe0:	f7db feac 	bl	cd3c <__aeabi_dsub>
   30fe4:	ec41 0b10 	vmov	d0, r0, r1
   30fe8:	b003      	add	sp, #12
   30fea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   30fee:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   30ff2:	4310      	orrs	r0, r2
   30ff4:	d123      	bne.n	3103e <rint+0xce>
   30ff6:	ec43 2b10 	vmov	d0, r2, r3
   30ffa:	b003      	add	sp, #12
   30ffc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   31000:	2833      	cmp	r0, #51	; 0x33
   31002:	dd09      	ble.n	31018 <rint+0xa8>
   31004:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
   31008:	d1f5      	bne.n	30ff6 <rint+0x86>
   3100a:	ee10 0a10 	vmov	r0, s0
   3100e:	f7db fe97 	bl	cd40 <__adddf3>
   31012:	ec41 0b10 	vmov	d0, r0, r1
   31016:	e7f0      	b.n	30ffa <rint+0x8a>
   31018:	f2a6 4613 	subw	r6, r6, #1043	; 0x413
   3101c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   31020:	40f0      	lsrs	r0, r6
   31022:	4202      	tst	r2, r0
   31024:	d0e7      	beq.n	30ff6 <rint+0x86>
   31026:	0840      	lsrs	r0, r0, #1
   31028:	4202      	tst	r2, r0
   3102a:	d0c8      	beq.n	30fbe <rint+0x4e>
   3102c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   31030:	ea25 0000 	bic.w	r0, r5, r0
   31034:	fa43 f606 	asr.w	r6, r3, r6
   31038:	ea40 0506 	orr.w	r5, r0, r6
   3103c:	e7bf      	b.n	30fbe <rint+0x4e>
   3103e:	f3c3 0613 	ubfx	r6, r3, #0, #20
   31042:	4815      	ldr	r0, [pc, #84]	; (31098 <rint+0x128>)
   31044:	4a13      	ldr	r2, [pc, #76]	; (31094 <rint+0x124>)
   31046:	4335      	orrs	r5, r6
   31048:	4018      	ands	r0, r3
   3104a:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
   3104e:	426b      	negs	r3, r5
   31050:	432b      	orrs	r3, r5
   31052:	0b1b      	lsrs	r3, r3, #12
   31054:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
   31058:	e9d2 6700 	ldrd	r6, r7, [r2]
   3105c:	ea43 0900 	orr.w	r9, r3, r0
   31060:	ee10 2a10 	vmov	r2, s0
   31064:	4630      	mov	r0, r6
   31066:	4639      	mov	r1, r7
   31068:	464b      	mov	r3, r9
   3106a:	f7db fe69 	bl	cd40 <__adddf3>
   3106e:	463b      	mov	r3, r7
   31070:	4632      	mov	r2, r6
   31072:	e9cd 0100 	strd	r0, r1, [sp]
   31076:	e9dd 0100 	ldrd	r0, r1, [sp]
   3107a:	f7db fe5f 	bl	cd3c <__aeabi_dsub>
   3107e:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
   31082:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
   31086:	ec41 0b10 	vmov	d0, r0, r1
   3108a:	b003      	add	sp, #12
   3108c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   31090:	000fffff 	.word	0x000fffff
   31094:	0003a138 	.word	0x0003a138
   31098:	fffe0000 	.word	0xfffe0000

0003109c <finitef>:
   3109c:	ee10 3a10 	vmov	r3, s0
   310a0:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
   310a4:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
   310a8:	bfac      	ite	ge
   310aa:	2000      	movge	r0, #0
   310ac:	2001      	movlt	r0, #1
   310ae:	4770      	bx	lr

000310b0 <nanf>:
   310b0:	ed9f 0a01 	vldr	s0, [pc, #4]	; 310b8 <nanf+0x8>
   310b4:	4770      	bx	lr
   310b6:	bf00      	nop
   310b8:	7fc00000 	.word	0x7fc00000

000310bc <rintf>:
   310bc:	eeb7 0a40 	vrintx.f32	s0, s0
   310c0:	4770      	bx	lr
   310c2:	bf00      	nop

000310c4 <scalbnf>:
   310c4:	b082      	sub	sp, #8
   310c6:	ed8d 0a01 	vstr	s0, [sp, #4]
   310ca:	9b01      	ldr	r3, [sp, #4]
   310cc:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
   310d0:	d029      	beq.n	31126 <scalbnf+0x62>
   310d2:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
   310d6:	d222      	bcs.n	3111e <scalbnf+0x5a>
   310d8:	f013 4fff 	tst.w	r3, #2139095040	; 0x7f800000
   310dc:	d127      	bne.n	3112e <scalbnf+0x6a>
   310de:	ed9d 7a01 	vldr	s14, [sp, #4]
   310e2:	eddf 7a2d 	vldr	s15, [pc, #180]	; 31198 <scalbnf+0xd4>
   310e6:	4b2d      	ldr	r3, [pc, #180]	; (3119c <scalbnf+0xd8>)
   310e8:	ee67 7a27 	vmul.f32	s15, s14, s15
   310ec:	4298      	cmp	r0, r3
   310ee:	edcd 7a01 	vstr	s15, [sp, #4]
   310f2:	db3e      	blt.n	31172 <scalbnf+0xae>
   310f4:	9b01      	ldr	r3, [sp, #4]
   310f6:	f3c3 52c7 	ubfx	r2, r3, #23, #8
   310fa:	3a19      	subs	r2, #25
   310fc:	4402      	add	r2, r0
   310fe:	2afe      	cmp	r2, #254	; 0xfe
   31100:	dd19      	ble.n	31136 <scalbnf+0x72>
   31102:	9b01      	ldr	r3, [sp, #4]
   31104:	ed9f 0a26 	vldr	s0, [pc, #152]	; 311a0 <scalbnf+0xdc>
   31108:	2b00      	cmp	r3, #0
   3110a:	ed9f 7a26 	vldr	s14, [pc, #152]	; 311a4 <scalbnf+0xe0>
   3110e:	eef0 7a40 	vmov.f32	s15, s0
   31112:	fe20 0a07 	vselge.f32	s0, s0, s14
   31116:	ee20 0a27 	vmul.f32	s0, s0, s15
   3111a:	b002      	add	sp, #8
   3111c:	4770      	bx	lr
   3111e:	ee30 0a00 	vadd.f32	s0, s0, s0
   31122:	b002      	add	sp, #8
   31124:	4770      	bx	lr
   31126:	ed9d 0a01 	vldr	s0, [sp, #4]
   3112a:	b002      	add	sp, #8
   3112c:	4770      	bx	lr
   3112e:	0dd2      	lsrs	r2, r2, #23
   31130:	4402      	add	r2, r0
   31132:	2afe      	cmp	r2, #254	; 0xfe
   31134:	dce5      	bgt.n	31102 <scalbnf+0x3e>
   31136:	2a00      	cmp	r2, #0
   31138:	dc13      	bgt.n	31162 <scalbnf+0x9e>
   3113a:	f112 0f16 	cmn.w	r2, #22
   3113e:	da1f      	bge.n	31180 <scalbnf+0xbc>
   31140:	f24c 3350 	movw	r3, #50000	; 0xc350
   31144:	4298      	cmp	r0, r3
   31146:	9b01      	ldr	r3, [sp, #4]
   31148:	dcdc      	bgt.n	31104 <scalbnf+0x40>
   3114a:	ed9f 0a17 	vldr	s0, [pc, #92]	; 311a8 <scalbnf+0xe4>
   3114e:	2b00      	cmp	r3, #0
   31150:	ed9f 7a16 	vldr	s14, [pc, #88]	; 311ac <scalbnf+0xe8>
   31154:	eef0 7a40 	vmov.f32	s15, s0
   31158:	fe20 0a07 	vselge.f32	s0, s0, s14
   3115c:	ee20 0a27 	vmul.f32	s0, s0, s15
   31160:	e7df      	b.n	31122 <scalbnf+0x5e>
   31162:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   31166:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   3116a:	ee00 3a10 	vmov	s0, r3
   3116e:	b002      	add	sp, #8
   31170:	4770      	bx	lr
   31172:	ed9f 0a0d 	vldr	s0, [pc, #52]	; 311a8 <scalbnf+0xe4>
   31176:	eddd 7a01 	vldr	s15, [sp, #4]
   3117a:	ee27 0a80 	vmul.f32	s0, s15, s0
   3117e:	e7d0      	b.n	31122 <scalbnf+0x5e>
   31180:	3219      	adds	r2, #25
   31182:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
   31186:	eddf 7a0a 	vldr	s15, [pc, #40]	; 311b0 <scalbnf+0xec>
   3118a:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
   3118e:	ee07 3a10 	vmov	s14, r3
   31192:	ee27 0a27 	vmul.f32	s0, s14, s15
   31196:	e7c4      	b.n	31122 <scalbnf+0x5e>
   31198:	4c000000 	.word	0x4c000000
   3119c:	ffff3cb0 	.word	0xffff3cb0
   311a0:	7149f2ca 	.word	0x7149f2ca
   311a4:	f149f2ca 	.word	0xf149f2ca
   311a8:	0da24260 	.word	0x0da24260
   311ac:	8da24260 	.word	0x8da24260
   311b0:	33000000 	.word	0x33000000

000311b4 <__assert_func>:
   311b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   311b6:	461c      	mov	r4, r3
   311b8:	4b09      	ldr	r3, [pc, #36]	; (311e0 <__assert_func+0x2c>)
   311ba:	4605      	mov	r5, r0
   311bc:	681b      	ldr	r3, [r3, #0]
   311be:	68d8      	ldr	r0, [r3, #12]
   311c0:	b152      	cbz	r2, 311d8 <__assert_func+0x24>
   311c2:	4b08      	ldr	r3, [pc, #32]	; (311e4 <__assert_func+0x30>)
   311c4:	9100      	str	r1, [sp, #0]
   311c6:	4908      	ldr	r1, [pc, #32]	; (311e8 <__assert_func+0x34>)
   311c8:	e9cd 3201 	strd	r3, r2, [sp, #4]
   311cc:	462b      	mov	r3, r5
   311ce:	4622      	mov	r2, r4
   311d0:	f000 f816 	bl	31200 <fiprintf>
   311d4:	f008 f8c1 	bl	3935a <abort>
   311d8:	4b04      	ldr	r3, [pc, #16]	; (311ec <__assert_func+0x38>)
   311da:	461a      	mov	r2, r3
   311dc:	e7f2      	b.n	311c4 <__assert_func+0x10>
   311de:	bf00      	nop
   311e0:	20020234 	.word	0x20020234
   311e4:	0004014b 	.word	0x0004014b
   311e8:	00040158 	.word	0x00040158
   311ec:	0003c520 	.word	0x0003c520

000311f0 <calloc>:
   311f0:	4b02      	ldr	r3, [pc, #8]	; (311fc <calloc+0xc>)
   311f2:	460a      	mov	r2, r1
   311f4:	4601      	mov	r1, r0
   311f6:	6818      	ldr	r0, [r3, #0]
   311f8:	f007 bf30 	b.w	3905c <_calloc_r>
   311fc:	20020234 	.word	0x20020234

00031200 <fiprintf>:
   31200:	b40e      	push	{r1, r2, r3}
   31202:	b503      	push	{r0, r1, lr}
   31204:	ab03      	add	r3, sp, #12
   31206:	4601      	mov	r1, r0
   31208:	4805      	ldr	r0, [pc, #20]	; (31220 <fiprintf+0x20>)
   3120a:	f853 2b04 	ldr.w	r2, [r3], #4
   3120e:	6800      	ldr	r0, [r0, #0]
   31210:	9301      	str	r3, [sp, #4]
   31212:	f000 f8bf 	bl	31394 <_vfiprintf_r>
   31216:	b002      	add	sp, #8
   31218:	f85d eb04 	ldr.w	lr, [sp], #4
   3121c:	b003      	add	sp, #12
   3121e:	4770      	bx	lr
   31220:	20020234 	.word	0x20020234

00031224 <malloc>:
   31224:	4b02      	ldr	r3, [pc, #8]	; (31230 <malloc+0xc>)
   31226:	4601      	mov	r1, r0
   31228:	6818      	ldr	r0, [r3, #0]
   3122a:	f000 b859 	b.w	312e0 <_malloc_r>
   3122e:	bf00      	nop
   31230:	20020234 	.word	0x20020234

00031234 <free>:
   31234:	4b02      	ldr	r3, [pc, #8]	; (31240 <free+0xc>)
   31236:	4601      	mov	r1, r0
   31238:	6818      	ldr	r0, [r3, #0]
   3123a:	f000 b803 	b.w	31244 <_free_r>
   3123e:	bf00      	nop
   31240:	20020234 	.word	0x20020234

00031244 <_free_r>:
   31244:	b538      	push	{r3, r4, r5, lr}
   31246:	4605      	mov	r5, r0
   31248:	2900      	cmp	r1, #0
   3124a:	d045      	beq.n	312d8 <_free_r+0x94>
   3124c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   31250:	1f0c      	subs	r4, r1, #4
   31252:	2b00      	cmp	r3, #0
   31254:	bfb8      	it	lt
   31256:	18e4      	addlt	r4, r4, r3
   31258:	f001 fafe 	bl	32858 <__malloc_lock>
   3125c:	4a1f      	ldr	r2, [pc, #124]	; (312dc <_free_r+0x98>)
   3125e:	6813      	ldr	r3, [r2, #0]
   31260:	4610      	mov	r0, r2
   31262:	b933      	cbnz	r3, 31272 <_free_r+0x2e>
   31264:	6063      	str	r3, [r4, #4]
   31266:	6014      	str	r4, [r2, #0]
   31268:	4628      	mov	r0, r5
   3126a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   3126e:	f001 baf9 	b.w	32864 <__malloc_unlock>
   31272:	42a3      	cmp	r3, r4
   31274:	d90c      	bls.n	31290 <_free_r+0x4c>
   31276:	6821      	ldr	r1, [r4, #0]
   31278:	1862      	adds	r2, r4, r1
   3127a:	4293      	cmp	r3, r2
   3127c:	bf02      	ittt	eq
   3127e:	681a      	ldreq	r2, [r3, #0]
   31280:	685b      	ldreq	r3, [r3, #4]
   31282:	1852      	addeq	r2, r2, r1
   31284:	6063      	str	r3, [r4, #4]
   31286:	bf08      	it	eq
   31288:	6022      	streq	r2, [r4, #0]
   3128a:	6004      	str	r4, [r0, #0]
   3128c:	e7ec      	b.n	31268 <_free_r+0x24>
   3128e:	4613      	mov	r3, r2
   31290:	685a      	ldr	r2, [r3, #4]
   31292:	b10a      	cbz	r2, 31298 <_free_r+0x54>
   31294:	42a2      	cmp	r2, r4
   31296:	d9fa      	bls.n	3128e <_free_r+0x4a>
   31298:	6819      	ldr	r1, [r3, #0]
   3129a:	1858      	adds	r0, r3, r1
   3129c:	42a0      	cmp	r0, r4
   3129e:	d10b      	bne.n	312b8 <_free_r+0x74>
   312a0:	6820      	ldr	r0, [r4, #0]
   312a2:	4401      	add	r1, r0
   312a4:	1858      	adds	r0, r3, r1
   312a6:	6019      	str	r1, [r3, #0]
   312a8:	4282      	cmp	r2, r0
   312aa:	d1dd      	bne.n	31268 <_free_r+0x24>
   312ac:	6810      	ldr	r0, [r2, #0]
   312ae:	6852      	ldr	r2, [r2, #4]
   312b0:	4401      	add	r1, r0
   312b2:	605a      	str	r2, [r3, #4]
   312b4:	6019      	str	r1, [r3, #0]
   312b6:	e7d7      	b.n	31268 <_free_r+0x24>
   312b8:	d902      	bls.n	312c0 <_free_r+0x7c>
   312ba:	230c      	movs	r3, #12
   312bc:	602b      	str	r3, [r5, #0]
   312be:	e7d3      	b.n	31268 <_free_r+0x24>
   312c0:	6820      	ldr	r0, [r4, #0]
   312c2:	1821      	adds	r1, r4, r0
   312c4:	428a      	cmp	r2, r1
   312c6:	bf02      	ittt	eq
   312c8:	6811      	ldreq	r1, [r2, #0]
   312ca:	6852      	ldreq	r2, [r2, #4]
   312cc:	1809      	addeq	r1, r1, r0
   312ce:	6062      	str	r2, [r4, #4]
   312d0:	bf08      	it	eq
   312d2:	6021      	streq	r1, [r4, #0]
   312d4:	605c      	str	r4, [r3, #4]
   312d6:	e7c7      	b.n	31268 <_free_r+0x24>
   312d8:	bd38      	pop	{r3, r4, r5, pc}
   312da:	bf00      	nop
   312dc:	20027608 	.word	0x20027608

000312e0 <_malloc_r>:
   312e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   312e2:	1ccd      	adds	r5, r1, #3
   312e4:	4606      	mov	r6, r0
   312e6:	f025 0503 	bic.w	r5, r5, #3
   312ea:	3508      	adds	r5, #8
   312ec:	2d0c      	cmp	r5, #12
   312ee:	bf38      	it	cc
   312f0:	250c      	movcc	r5, #12
   312f2:	2d00      	cmp	r5, #0
   312f4:	db01      	blt.n	312fa <_malloc_r+0x1a>
   312f6:	42a9      	cmp	r1, r5
   312f8:	d903      	bls.n	31302 <_malloc_r+0x22>
   312fa:	230c      	movs	r3, #12
   312fc:	6033      	str	r3, [r6, #0]
   312fe:	2000      	movs	r0, #0
   31300:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   31302:	f001 faa9 	bl	32858 <__malloc_lock>
   31306:	4921      	ldr	r1, [pc, #132]	; (3138c <_malloc_r+0xac>)
   31308:	680a      	ldr	r2, [r1, #0]
   3130a:	4614      	mov	r4, r2
   3130c:	b99c      	cbnz	r4, 31336 <_malloc_r+0x56>
   3130e:	4f20      	ldr	r7, [pc, #128]	; (31390 <_malloc_r+0xb0>)
   31310:	683b      	ldr	r3, [r7, #0]
   31312:	b923      	cbnz	r3, 3131e <_malloc_r+0x3e>
   31314:	4621      	mov	r1, r4
   31316:	4630      	mov	r0, r6
   31318:	f000 fca2 	bl	31c60 <_sbrk_r>
   3131c:	6038      	str	r0, [r7, #0]
   3131e:	4629      	mov	r1, r5
   31320:	4630      	mov	r0, r6
   31322:	f000 fc9d 	bl	31c60 <_sbrk_r>
   31326:	1c43      	adds	r3, r0, #1
   31328:	d123      	bne.n	31372 <_malloc_r+0x92>
   3132a:	230c      	movs	r3, #12
   3132c:	4630      	mov	r0, r6
   3132e:	6033      	str	r3, [r6, #0]
   31330:	f001 fa98 	bl	32864 <__malloc_unlock>
   31334:	e7e3      	b.n	312fe <_malloc_r+0x1e>
   31336:	6823      	ldr	r3, [r4, #0]
   31338:	1b5b      	subs	r3, r3, r5
   3133a:	d417      	bmi.n	3136c <_malloc_r+0x8c>
   3133c:	2b0b      	cmp	r3, #11
   3133e:	d903      	bls.n	31348 <_malloc_r+0x68>
   31340:	6023      	str	r3, [r4, #0]
   31342:	441c      	add	r4, r3
   31344:	6025      	str	r5, [r4, #0]
   31346:	e004      	b.n	31352 <_malloc_r+0x72>
   31348:	6863      	ldr	r3, [r4, #4]
   3134a:	42a2      	cmp	r2, r4
   3134c:	bf0c      	ite	eq
   3134e:	600b      	streq	r3, [r1, #0]
   31350:	6053      	strne	r3, [r2, #4]
   31352:	4630      	mov	r0, r6
   31354:	f001 fa86 	bl	32864 <__malloc_unlock>
   31358:	f104 000b 	add.w	r0, r4, #11
   3135c:	1d23      	adds	r3, r4, #4
   3135e:	f020 0007 	bic.w	r0, r0, #7
   31362:	1ac2      	subs	r2, r0, r3
   31364:	d0cc      	beq.n	31300 <_malloc_r+0x20>
   31366:	1a1b      	subs	r3, r3, r0
   31368:	50a3      	str	r3, [r4, r2]
   3136a:	e7c9      	b.n	31300 <_malloc_r+0x20>
   3136c:	4622      	mov	r2, r4
   3136e:	6864      	ldr	r4, [r4, #4]
   31370:	e7cc      	b.n	3130c <_malloc_r+0x2c>
   31372:	1cc4      	adds	r4, r0, #3
   31374:	f024 0403 	bic.w	r4, r4, #3
   31378:	42a0      	cmp	r0, r4
   3137a:	d0e3      	beq.n	31344 <_malloc_r+0x64>
   3137c:	1a21      	subs	r1, r4, r0
   3137e:	4630      	mov	r0, r6
   31380:	f000 fc6e 	bl	31c60 <_sbrk_r>
   31384:	3001      	adds	r0, #1
   31386:	d1dd      	bne.n	31344 <_malloc_r+0x64>
   31388:	e7cf      	b.n	3132a <_malloc_r+0x4a>
   3138a:	bf00      	nop
   3138c:	20027608 	.word	0x20027608
   31390:	2002760c 	.word	0x2002760c

00031394 <_vfiprintf_r>:
   31394:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31398:	460d      	mov	r5, r1
   3139a:	b09d      	sub	sp, #116	; 0x74
   3139c:	4614      	mov	r4, r2
   3139e:	461e      	mov	r6, r3
   313a0:	4607      	mov	r7, r0
   313a2:	b118      	cbz	r0, 313ac <_vfiprintf_r+0x18>
   313a4:	6983      	ldr	r3, [r0, #24]
   313a6:	b90b      	cbnz	r3, 313ac <_vfiprintf_r+0x18>
   313a8:	f001 f994 	bl	326d4 <__sinit>
   313ac:	4b85      	ldr	r3, [pc, #532]	; (315c4 <_vfiprintf_r+0x230>)
   313ae:	429d      	cmp	r5, r3
   313b0:	d11b      	bne.n	313ea <_vfiprintf_r+0x56>
   313b2:	687d      	ldr	r5, [r7, #4]
   313b4:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   313b6:	07d9      	lsls	r1, r3, #31
   313b8:	d405      	bmi.n	313c6 <_vfiprintf_r+0x32>
   313ba:	89ab      	ldrh	r3, [r5, #12]
   313bc:	059a      	lsls	r2, r3, #22
   313be:	d402      	bmi.n	313c6 <_vfiprintf_r+0x32>
   313c0:	6da8      	ldr	r0, [r5, #88]	; 0x58
   313c2:	f008 f894 	bl	394ee <__retarget_lock_acquire_recursive>
   313c6:	89ab      	ldrh	r3, [r5, #12]
   313c8:	071b      	lsls	r3, r3, #28
   313ca:	d501      	bpl.n	313d0 <_vfiprintf_r+0x3c>
   313cc:	692b      	ldr	r3, [r5, #16]
   313ce:	b9eb      	cbnz	r3, 3140c <_vfiprintf_r+0x78>
   313d0:	4629      	mov	r1, r5
   313d2:	4638      	mov	r0, r7
   313d4:	f000 ffea 	bl	323ac <__swsetup_r>
   313d8:	b1c0      	cbz	r0, 3140c <_vfiprintf_r+0x78>
   313da:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   313dc:	07d8      	lsls	r0, r3, #31
   313de:	d50e      	bpl.n	313fe <_vfiprintf_r+0x6a>
   313e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   313e4:	b01d      	add	sp, #116	; 0x74
   313e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   313ea:	4b77      	ldr	r3, [pc, #476]	; (315c8 <_vfiprintf_r+0x234>)
   313ec:	429d      	cmp	r5, r3
   313ee:	d101      	bne.n	313f4 <_vfiprintf_r+0x60>
   313f0:	68bd      	ldr	r5, [r7, #8]
   313f2:	e7df      	b.n	313b4 <_vfiprintf_r+0x20>
   313f4:	4b75      	ldr	r3, [pc, #468]	; (315cc <_vfiprintf_r+0x238>)
   313f6:	429d      	cmp	r5, r3
   313f8:	bf08      	it	eq
   313fa:	68fd      	ldreq	r5, [r7, #12]
   313fc:	e7da      	b.n	313b4 <_vfiprintf_r+0x20>
   313fe:	89ab      	ldrh	r3, [r5, #12]
   31400:	0599      	lsls	r1, r3, #22
   31402:	d4ed      	bmi.n	313e0 <_vfiprintf_r+0x4c>
   31404:	6da8      	ldr	r0, [r5, #88]	; 0x58
   31406:	f008 f873 	bl	394f0 <__retarget_lock_release_recursive>
   3140a:	e7e9      	b.n	313e0 <_vfiprintf_r+0x4c>
   3140c:	2300      	movs	r3, #0
   3140e:	f8df 91c0 	ldr.w	r9, [pc, #448]	; 315d0 <_vfiprintf_r+0x23c>
   31412:	f04f 0a01 	mov.w	sl, #1
   31416:	9603      	str	r6, [sp, #12]
   31418:	9309      	str	r3, [sp, #36]	; 0x24
   3141a:	2320      	movs	r3, #32
   3141c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   31420:	2330      	movs	r3, #48	; 0x30
   31422:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   31426:	4623      	mov	r3, r4
   31428:	461e      	mov	r6, r3
   3142a:	f813 2b01 	ldrb.w	r2, [r3], #1
   3142e:	b10a      	cbz	r2, 31434 <_vfiprintf_r+0xa0>
   31430:	2a25      	cmp	r2, #37	; 0x25
   31432:	d1f9      	bne.n	31428 <_vfiprintf_r+0x94>
   31434:	ebb6 0b04 	subs.w	fp, r6, r4
   31438:	d00b      	beq.n	31452 <_vfiprintf_r+0xbe>
   3143a:	465b      	mov	r3, fp
   3143c:	4622      	mov	r2, r4
   3143e:	4629      	mov	r1, r5
   31440:	4638      	mov	r0, r7
   31442:	f007 fe30 	bl	390a6 <__sfputs_r>
   31446:	3001      	adds	r0, #1
   31448:	f000 80a3 	beq.w	31592 <_vfiprintf_r+0x1fe>
   3144c:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3144e:	445b      	add	r3, fp
   31450:	9309      	str	r3, [sp, #36]	; 0x24
   31452:	7833      	ldrb	r3, [r6, #0]
   31454:	2b00      	cmp	r3, #0
   31456:	f000 809c 	beq.w	31592 <_vfiprintf_r+0x1fe>
   3145a:	2300      	movs	r3, #0
   3145c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   31460:	3601      	adds	r6, #1
   31462:	9304      	str	r3, [sp, #16]
   31464:	9307      	str	r3, [sp, #28]
   31466:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   3146a:	931a      	str	r3, [sp, #104]	; 0x68
   3146c:	e9cd 2305 	strd	r2, r3, [sp, #20]
   31470:	4634      	mov	r4, r6
   31472:	2205      	movs	r2, #5
   31474:	4856      	ldr	r0, [pc, #344]	; (315d0 <_vfiprintf_r+0x23c>)
   31476:	f814 1b01 	ldrb.w	r1, [r4], #1
   3147a:	f007 fd91 	bl	38fa0 <memchr>
   3147e:	9b04      	ldr	r3, [sp, #16]
   31480:	b9c0      	cbnz	r0, 314b4 <_vfiprintf_r+0x120>
   31482:	06da      	lsls	r2, r3, #27
   31484:	bf44      	itt	mi
   31486:	2220      	movmi	r2, #32
   31488:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   3148c:	0718      	lsls	r0, r3, #28
   3148e:	bf44      	itt	mi
   31490:	222b      	movmi	r2, #43	; 0x2b
   31492:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   31496:	7832      	ldrb	r2, [r6, #0]
   31498:	2a2a      	cmp	r2, #42	; 0x2a
   3149a:	d013      	beq.n	314c4 <_vfiprintf_r+0x130>
   3149c:	4634      	mov	r4, r6
   3149e:	9a07      	ldr	r2, [sp, #28]
   314a0:	2000      	movs	r0, #0
   314a2:	260a      	movs	r6, #10
   314a4:	4621      	mov	r1, r4
   314a6:	f811 3b01 	ldrb.w	r3, [r1], #1
   314aa:	3b30      	subs	r3, #48	; 0x30
   314ac:	2b09      	cmp	r3, #9
   314ae:	d94b      	bls.n	31548 <_vfiprintf_r+0x1b4>
   314b0:	b970      	cbnz	r0, 314d0 <_vfiprintf_r+0x13c>
   314b2:	e014      	b.n	314de <_vfiprintf_r+0x14a>
   314b4:	eba0 0009 	sub.w	r0, r0, r9
   314b8:	4626      	mov	r6, r4
   314ba:	fa0a f000 	lsl.w	r0, sl, r0
   314be:	4318      	orrs	r0, r3
   314c0:	9004      	str	r0, [sp, #16]
   314c2:	e7d5      	b.n	31470 <_vfiprintf_r+0xdc>
   314c4:	9a03      	ldr	r2, [sp, #12]
   314c6:	1d11      	adds	r1, r2, #4
   314c8:	6812      	ldr	r2, [r2, #0]
   314ca:	2a00      	cmp	r2, #0
   314cc:	9103      	str	r1, [sp, #12]
   314ce:	db01      	blt.n	314d4 <_vfiprintf_r+0x140>
   314d0:	9207      	str	r2, [sp, #28]
   314d2:	e004      	b.n	314de <_vfiprintf_r+0x14a>
   314d4:	4252      	negs	r2, r2
   314d6:	f043 0302 	orr.w	r3, r3, #2
   314da:	9207      	str	r2, [sp, #28]
   314dc:	9304      	str	r3, [sp, #16]
   314de:	7823      	ldrb	r3, [r4, #0]
   314e0:	2b2e      	cmp	r3, #46	; 0x2e
   314e2:	d10c      	bne.n	314fe <_vfiprintf_r+0x16a>
   314e4:	7863      	ldrb	r3, [r4, #1]
   314e6:	2b2a      	cmp	r3, #42	; 0x2a
   314e8:	d133      	bne.n	31552 <_vfiprintf_r+0x1be>
   314ea:	9b03      	ldr	r3, [sp, #12]
   314ec:	3402      	adds	r4, #2
   314ee:	1d1a      	adds	r2, r3, #4
   314f0:	681b      	ldr	r3, [r3, #0]
   314f2:	2b00      	cmp	r3, #0
   314f4:	9203      	str	r2, [sp, #12]
   314f6:	bfb8      	it	lt
   314f8:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   314fc:	9305      	str	r3, [sp, #20]
   314fe:	4e35      	ldr	r6, [pc, #212]	; (315d4 <_vfiprintf_r+0x240>)
   31500:	2203      	movs	r2, #3
   31502:	7821      	ldrb	r1, [r4, #0]
   31504:	4630      	mov	r0, r6
   31506:	f007 fd4b 	bl	38fa0 <memchr>
   3150a:	b138      	cbz	r0, 3151c <_vfiprintf_r+0x188>
   3150c:	2340      	movs	r3, #64	; 0x40
   3150e:	1b80      	subs	r0, r0, r6
   31510:	3401      	adds	r4, #1
   31512:	fa03 f000 	lsl.w	r0, r3, r0
   31516:	9b04      	ldr	r3, [sp, #16]
   31518:	4303      	orrs	r3, r0
   3151a:	9304      	str	r3, [sp, #16]
   3151c:	f814 1b01 	ldrb.w	r1, [r4], #1
   31520:	2206      	movs	r2, #6
   31522:	482d      	ldr	r0, [pc, #180]	; (315d8 <_vfiprintf_r+0x244>)
   31524:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   31528:	f007 fd3a 	bl	38fa0 <memchr>
   3152c:	2800      	cmp	r0, #0
   3152e:	d03f      	beq.n	315b0 <_vfiprintf_r+0x21c>
   31530:	4b2a      	ldr	r3, [pc, #168]	; (315dc <_vfiprintf_r+0x248>)
   31532:	bb13      	cbnz	r3, 3157a <_vfiprintf_r+0x1e6>
   31534:	9b03      	ldr	r3, [sp, #12]
   31536:	3307      	adds	r3, #7
   31538:	f023 0307 	bic.w	r3, r3, #7
   3153c:	3308      	adds	r3, #8
   3153e:	9303      	str	r3, [sp, #12]
   31540:	9b09      	ldr	r3, [sp, #36]	; 0x24
   31542:	4443      	add	r3, r8
   31544:	9309      	str	r3, [sp, #36]	; 0x24
   31546:	e76e      	b.n	31426 <_vfiprintf_r+0x92>
   31548:	fb06 3202 	mla	r2, r6, r2, r3
   3154c:	2001      	movs	r0, #1
   3154e:	460c      	mov	r4, r1
   31550:	e7a8      	b.n	314a4 <_vfiprintf_r+0x110>
   31552:	2300      	movs	r3, #0
   31554:	3401      	adds	r4, #1
   31556:	260a      	movs	r6, #10
   31558:	4619      	mov	r1, r3
   3155a:	9305      	str	r3, [sp, #20]
   3155c:	4620      	mov	r0, r4
   3155e:	f810 2b01 	ldrb.w	r2, [r0], #1
   31562:	3a30      	subs	r2, #48	; 0x30
   31564:	2a09      	cmp	r2, #9
   31566:	d903      	bls.n	31570 <_vfiprintf_r+0x1dc>
   31568:	2b00      	cmp	r3, #0
   3156a:	d0c8      	beq.n	314fe <_vfiprintf_r+0x16a>
   3156c:	9105      	str	r1, [sp, #20]
   3156e:	e7c6      	b.n	314fe <_vfiprintf_r+0x16a>
   31570:	fb06 2101 	mla	r1, r6, r1, r2
   31574:	2301      	movs	r3, #1
   31576:	4604      	mov	r4, r0
   31578:	e7f0      	b.n	3155c <_vfiprintf_r+0x1c8>
   3157a:	ab03      	add	r3, sp, #12
   3157c:	462a      	mov	r2, r5
   3157e:	a904      	add	r1, sp, #16
   31580:	4638      	mov	r0, r7
   31582:	9300      	str	r3, [sp, #0]
   31584:	4b16      	ldr	r3, [pc, #88]	; (315e0 <_vfiprintf_r+0x24c>)
   31586:	f000 f82d 	bl	315e4 <_printf_float>
   3158a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   3158e:	4680      	mov	r8, r0
   31590:	d1d6      	bne.n	31540 <_vfiprintf_r+0x1ac>
   31592:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   31594:	07d9      	lsls	r1, r3, #31
   31596:	d405      	bmi.n	315a4 <_vfiprintf_r+0x210>
   31598:	89ab      	ldrh	r3, [r5, #12]
   3159a:	059a      	lsls	r2, r3, #22
   3159c:	d402      	bmi.n	315a4 <_vfiprintf_r+0x210>
   3159e:	6da8      	ldr	r0, [r5, #88]	; 0x58
   315a0:	f007 ffa6 	bl	394f0 <__retarget_lock_release_recursive>
   315a4:	89ab      	ldrh	r3, [r5, #12]
   315a6:	065b      	lsls	r3, r3, #25
   315a8:	f53f af1a 	bmi.w	313e0 <_vfiprintf_r+0x4c>
   315ac:	9809      	ldr	r0, [sp, #36]	; 0x24
   315ae:	e719      	b.n	313e4 <_vfiprintf_r+0x50>
   315b0:	ab03      	add	r3, sp, #12
   315b2:	462a      	mov	r2, r5
   315b4:	a904      	add	r1, sp, #16
   315b6:	4638      	mov	r0, r7
   315b8:	9300      	str	r3, [sp, #0]
   315ba:	4b09      	ldr	r3, [pc, #36]	; (315e0 <_vfiprintf_r+0x24c>)
   315bc:	f000 fa3c 	bl	31a38 <_printf_i>
   315c0:	e7e3      	b.n	3158a <_vfiprintf_r+0x1f6>
   315c2:	bf00      	nop
   315c4:	0003b3a4 	.word	0x0003b3a4
   315c8:	0003b3c4 	.word	0x0003b3c4
   315cc:	0003b384 	.word	0x0003b384
   315d0:	00040288 	.word	0x00040288
   315d4:	0004028e 	.word	0x0004028e
   315d8:	00040292 	.word	0x00040292
   315dc:	000315e5 	.word	0x000315e5
   315e0:	000390a7 	.word	0x000390a7

000315e4 <_printf_float>:
   315e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   315e8:	b08d      	sub	sp, #52	; 0x34
   315ea:	460c      	mov	r4, r1
   315ec:	4616      	mov	r6, r2
   315ee:	461f      	mov	r7, r3
   315f0:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
   315f4:	4605      	mov	r5, r0
   315f6:	f001 f8eb 	bl	327d0 <_localeconv_r>
   315fa:	6803      	ldr	r3, [r0, #0]
   315fc:	4618      	mov	r0, r3
   315fe:	9306      	str	r3, [sp, #24]
   31600:	f7e0 fd3e 	bl	12080 <strlen>
   31604:	2300      	movs	r3, #0
   31606:	9007      	str	r0, [sp, #28]
   31608:	930a      	str	r3, [sp, #40]	; 0x28
   3160a:	f8d8 3000 	ldr.w	r3, [r8]
   3160e:	f894 a018 	ldrb.w	sl, [r4, #24]
   31612:	3307      	adds	r3, #7
   31614:	f8d4 b000 	ldr.w	fp, [r4]
   31618:	f023 0307 	bic.w	r3, r3, #7
   3161c:	f103 0208 	add.w	r2, r3, #8
   31620:	f8c8 2000 	str.w	r2, [r8]
   31624:	e9d3 2300 	ldrd	r2, r3, [r3]
   31628:	e9c4 2312 	strd	r2, r3, [r4, #72]	; 0x48
   3162c:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
   31630:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   31634:	ed8d 7b04 	vstr	d7, [sp, #16]
   31638:	e9dd 8304 	ldrd	r8, r3, [sp, #16]
   3163c:	f023 4900 	bic.w	r9, r3, #2147483648	; 0x80000000
   31640:	4640      	mov	r0, r8
   31642:	4ba6      	ldr	r3, [pc, #664]	; (318dc <_printf_float+0x2f8>)
   31644:	4649      	mov	r1, r9
   31646:	f7e0 fb97 	bl	11d78 <__aeabi_dcmpun>
   3164a:	bb70      	cbnz	r0, 316aa <_printf_float+0xc6>
   3164c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   31650:	4ba2      	ldr	r3, [pc, #648]	; (318dc <_printf_float+0x2f8>)
   31652:	4640      	mov	r0, r8
   31654:	4649      	mov	r1, r9
   31656:	f7db ffa5 	bl	d5a4 <__aeabi_dcmple>
   3165a:	bb30      	cbnz	r0, 316aa <_printf_float+0xc6>
   3165c:	2200      	movs	r2, #0
   3165e:	2300      	movs	r3, #0
   31660:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
   31664:	f7db ff94 	bl	d590 <__aeabi_dcmplt>
   31668:	b110      	cbz	r0, 31670 <_printf_float+0x8c>
   3166a:	232d      	movs	r3, #45	; 0x2d
   3166c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   31670:	4a9b      	ldr	r2, [pc, #620]	; (318e0 <_printf_float+0x2fc>)
   31672:	4b9c      	ldr	r3, [pc, #624]	; (318e4 <_printf_float+0x300>)
   31674:	f1ba 0f47 	cmp.w	sl, #71	; 0x47
   31678:	bf94      	ite	ls
   3167a:	4690      	movls	r8, r2
   3167c:	4698      	movhi	r8, r3
   3167e:	f04f 0900 	mov.w	r9, #0
   31682:	2303      	movs	r3, #3
   31684:	f02b 0204 	bic.w	r2, fp, #4
   31688:	6123      	str	r3, [r4, #16]
   3168a:	6022      	str	r2, [r4, #0]
   3168c:	9700      	str	r7, [sp, #0]
   3168e:	4633      	mov	r3, r6
   31690:	aa0b      	add	r2, sp, #44	; 0x2c
   31692:	4621      	mov	r1, r4
   31694:	4628      	mov	r0, r5
   31696:	f007 fda8 	bl	391ea <_printf_common>
   3169a:	3001      	adds	r0, #1
   3169c:	f040 808c 	bne.w	317b8 <_printf_float+0x1d4>
   316a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   316a4:	b00d      	add	sp, #52	; 0x34
   316a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   316aa:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   316ae:	4610      	mov	r0, r2
   316b0:	4619      	mov	r1, r3
   316b2:	f7e0 fb61 	bl	11d78 <__aeabi_dcmpun>
   316b6:	b140      	cbz	r0, 316ca <_printf_float+0xe6>
   316b8:	9b05      	ldr	r3, [sp, #20]
   316ba:	4a8b      	ldr	r2, [pc, #556]	; (318e8 <_printf_float+0x304>)
   316bc:	2b00      	cmp	r3, #0
   316be:	bfbc      	itt	lt
   316c0:	232d      	movlt	r3, #45	; 0x2d
   316c2:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
   316c6:	4b89      	ldr	r3, [pc, #548]	; (318ec <_printf_float+0x308>)
   316c8:	e7d4      	b.n	31674 <_printf_float+0x90>
   316ca:	6863      	ldr	r3, [r4, #4]
   316cc:	f00a 09df 	and.w	r9, sl, #223	; 0xdf
   316d0:	1c5a      	adds	r2, r3, #1
   316d2:	d13e      	bne.n	31752 <_printf_float+0x16e>
   316d4:	2306      	movs	r3, #6
   316d6:	6063      	str	r3, [r4, #4]
   316d8:	2300      	movs	r3, #0
   316da:	f44b 6280 	orr.w	r2, fp, #1024	; 0x400
   316de:	6861      	ldr	r1, [r4, #4]
   316e0:	4628      	mov	r0, r5
   316e2:	9303      	str	r3, [sp, #12]
   316e4:	ab0a      	add	r3, sp, #40	; 0x28
   316e6:	6022      	str	r2, [r4, #0]
   316e8:	e9cd a301 	strd	sl, r3, [sp, #4]
   316ec:	ab09      	add	r3, sp, #36	; 0x24
   316ee:	ed9d 0b04 	vldr	d0, [sp, #16]
   316f2:	9300      	str	r3, [sp, #0]
   316f4:	f10d 0323 	add.w	r3, sp, #35	; 0x23
   316f8:	f007 fce7 	bl	390ca <__cvt>
   316fc:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   31700:	4680      	mov	r8, r0
   31702:	9909      	ldr	r1, [sp, #36]	; 0x24
   31704:	d108      	bne.n	31718 <_printf_float+0x134>
   31706:	1cc8      	adds	r0, r1, #3
   31708:	db02      	blt.n	31710 <_printf_float+0x12c>
   3170a:	6863      	ldr	r3, [r4, #4]
   3170c:	4299      	cmp	r1, r3
   3170e:	dd41      	ble.n	31794 <_printf_float+0x1b0>
   31710:	f1aa 0a02 	sub.w	sl, sl, #2
   31714:	fa5f fa8a 	uxtb.w	sl, sl
   31718:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   3171c:	d820      	bhi.n	31760 <_printf_float+0x17c>
   3171e:	3901      	subs	r1, #1
   31720:	4652      	mov	r2, sl
   31722:	f104 0050 	add.w	r0, r4, #80	; 0x50
   31726:	9109      	str	r1, [sp, #36]	; 0x24
   31728:	f007 fd2c 	bl	39184 <__exponent>
   3172c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   3172e:	4681      	mov	r9, r0
   31730:	1813      	adds	r3, r2, r0
   31732:	2a01      	cmp	r2, #1
   31734:	6123      	str	r3, [r4, #16]
   31736:	dc02      	bgt.n	3173e <_printf_float+0x15a>
   31738:	6822      	ldr	r2, [r4, #0]
   3173a:	07d2      	lsls	r2, r2, #31
   3173c:	d501      	bpl.n	31742 <_printf_float+0x15e>
   3173e:	3301      	adds	r3, #1
   31740:	6123      	str	r3, [r4, #16]
   31742:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
   31746:	2b00      	cmp	r3, #0
   31748:	d0a0      	beq.n	3168c <_printf_float+0xa8>
   3174a:	232d      	movs	r3, #45	; 0x2d
   3174c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   31750:	e79c      	b.n	3168c <_printf_float+0xa8>
   31752:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
   31756:	d1bf      	bne.n	316d8 <_printf_float+0xf4>
   31758:	2b00      	cmp	r3, #0
   3175a:	d1bd      	bne.n	316d8 <_printf_float+0xf4>
   3175c:	2301      	movs	r3, #1
   3175e:	e7ba      	b.n	316d6 <_printf_float+0xf2>
   31760:	f1ba 0f66 	cmp.w	sl, #102	; 0x66
   31764:	d118      	bne.n	31798 <_printf_float+0x1b4>
   31766:	2900      	cmp	r1, #0
   31768:	6863      	ldr	r3, [r4, #4]
   3176a:	dd0b      	ble.n	31784 <_printf_float+0x1a0>
   3176c:	6121      	str	r1, [r4, #16]
   3176e:	b913      	cbnz	r3, 31776 <_printf_float+0x192>
   31770:	6822      	ldr	r2, [r4, #0]
   31772:	07d0      	lsls	r0, r2, #31
   31774:	d502      	bpl.n	3177c <_printf_float+0x198>
   31776:	3301      	adds	r3, #1
   31778:	440b      	add	r3, r1
   3177a:	6123      	str	r3, [r4, #16]
   3177c:	65a1      	str	r1, [r4, #88]	; 0x58
   3177e:	f04f 0900 	mov.w	r9, #0
   31782:	e7de      	b.n	31742 <_printf_float+0x15e>
   31784:	b913      	cbnz	r3, 3178c <_printf_float+0x1a8>
   31786:	6822      	ldr	r2, [r4, #0]
   31788:	07d2      	lsls	r2, r2, #31
   3178a:	d501      	bpl.n	31790 <_printf_float+0x1ac>
   3178c:	3302      	adds	r3, #2
   3178e:	e7f4      	b.n	3177a <_printf_float+0x196>
   31790:	2301      	movs	r3, #1
   31792:	e7f2      	b.n	3177a <_printf_float+0x196>
   31794:	f04f 0a67 	mov.w	sl, #103	; 0x67
   31798:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3179a:	4299      	cmp	r1, r3
   3179c:	db05      	blt.n	317aa <_printf_float+0x1c6>
   3179e:	6823      	ldr	r3, [r4, #0]
   317a0:	6121      	str	r1, [r4, #16]
   317a2:	07d8      	lsls	r0, r3, #31
   317a4:	d5ea      	bpl.n	3177c <_printf_float+0x198>
   317a6:	1c4b      	adds	r3, r1, #1
   317a8:	e7e7      	b.n	3177a <_printf_float+0x196>
   317aa:	2900      	cmp	r1, #0
   317ac:	bfd4      	ite	le
   317ae:	f1c1 0202 	rsble	r2, r1, #2
   317b2:	2201      	movgt	r2, #1
   317b4:	4413      	add	r3, r2
   317b6:	e7e0      	b.n	3177a <_printf_float+0x196>
   317b8:	6823      	ldr	r3, [r4, #0]
   317ba:	055a      	lsls	r2, r3, #21
   317bc:	d407      	bmi.n	317ce <_printf_float+0x1ea>
   317be:	6923      	ldr	r3, [r4, #16]
   317c0:	4642      	mov	r2, r8
   317c2:	4631      	mov	r1, r6
   317c4:	4628      	mov	r0, r5
   317c6:	47b8      	blx	r7
   317c8:	3001      	adds	r0, #1
   317ca:	d12b      	bne.n	31824 <_printf_float+0x240>
   317cc:	e768      	b.n	316a0 <_printf_float+0xbc>
   317ce:	f1ba 0f65 	cmp.w	sl, #101	; 0x65
   317d2:	f240 80dc 	bls.w	3198e <_printf_float+0x3aa>
   317d6:	2200      	movs	r2, #0
   317d8:	2300      	movs	r3, #0
   317da:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   317de:	f7db fecd 	bl	d57c <__aeabi_dcmpeq>
   317e2:	2800      	cmp	r0, #0
   317e4:	d033      	beq.n	3184e <_printf_float+0x26a>
   317e6:	2301      	movs	r3, #1
   317e8:	4a41      	ldr	r2, [pc, #260]	; (318f0 <_printf_float+0x30c>)
   317ea:	4631      	mov	r1, r6
   317ec:	4628      	mov	r0, r5
   317ee:	47b8      	blx	r7
   317f0:	3001      	adds	r0, #1
   317f2:	f43f af55 	beq.w	316a0 <_printf_float+0xbc>
   317f6:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   317fa:	429a      	cmp	r2, r3
   317fc:	db02      	blt.n	31804 <_printf_float+0x220>
   317fe:	6823      	ldr	r3, [r4, #0]
   31800:	07d8      	lsls	r0, r3, #31
   31802:	d50f      	bpl.n	31824 <_printf_float+0x240>
   31804:	4631      	mov	r1, r6
   31806:	4628      	mov	r0, r5
   31808:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   3180c:	47b8      	blx	r7
   3180e:	3001      	adds	r0, #1
   31810:	f43f af46 	beq.w	316a0 <_printf_float+0xbc>
   31814:	f04f 0800 	mov.w	r8, #0
   31818:	f104 091a 	add.w	r9, r4, #26
   3181c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3181e:	3b01      	subs	r3, #1
   31820:	4543      	cmp	r3, r8
   31822:	dc09      	bgt.n	31838 <_printf_float+0x254>
   31824:	6823      	ldr	r3, [r4, #0]
   31826:	079b      	lsls	r3, r3, #30
   31828:	f100 8101 	bmi.w	31a2e <_printf_float+0x44a>
   3182c:	68e0      	ldr	r0, [r4, #12]
   3182e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   31830:	4298      	cmp	r0, r3
   31832:	bfb8      	it	lt
   31834:	4618      	movlt	r0, r3
   31836:	e735      	b.n	316a4 <_printf_float+0xc0>
   31838:	2301      	movs	r3, #1
   3183a:	464a      	mov	r2, r9
   3183c:	4631      	mov	r1, r6
   3183e:	4628      	mov	r0, r5
   31840:	47b8      	blx	r7
   31842:	3001      	adds	r0, #1
   31844:	f43f af2c 	beq.w	316a0 <_printf_float+0xbc>
   31848:	f108 0801 	add.w	r8, r8, #1
   3184c:	e7e6      	b.n	3181c <_printf_float+0x238>
   3184e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   31850:	2b00      	cmp	r3, #0
   31852:	dc2b      	bgt.n	318ac <_printf_float+0x2c8>
   31854:	2301      	movs	r3, #1
   31856:	4a26      	ldr	r2, [pc, #152]	; (318f0 <_printf_float+0x30c>)
   31858:	4631      	mov	r1, r6
   3185a:	4628      	mov	r0, r5
   3185c:	47b8      	blx	r7
   3185e:	3001      	adds	r0, #1
   31860:	f43f af1e 	beq.w	316a0 <_printf_float+0xbc>
   31864:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   31868:	4313      	orrs	r3, r2
   3186a:	d102      	bne.n	31872 <_printf_float+0x28e>
   3186c:	6823      	ldr	r3, [r4, #0]
   3186e:	07d9      	lsls	r1, r3, #31
   31870:	d5d8      	bpl.n	31824 <_printf_float+0x240>
   31872:	4631      	mov	r1, r6
   31874:	4628      	mov	r0, r5
   31876:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   3187a:	47b8      	blx	r7
   3187c:	3001      	adds	r0, #1
   3187e:	f43f af0f 	beq.w	316a0 <_printf_float+0xbc>
   31882:	f04f 0900 	mov.w	r9, #0
   31886:	f104 0a1a 	add.w	sl, r4, #26
   3188a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3188c:	425b      	negs	r3, r3
   3188e:	454b      	cmp	r3, r9
   31890:	dc01      	bgt.n	31896 <_printf_float+0x2b2>
   31892:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   31894:	e794      	b.n	317c0 <_printf_float+0x1dc>
   31896:	2301      	movs	r3, #1
   31898:	4652      	mov	r2, sl
   3189a:	4631      	mov	r1, r6
   3189c:	4628      	mov	r0, r5
   3189e:	47b8      	blx	r7
   318a0:	3001      	adds	r0, #1
   318a2:	f43f aefd 	beq.w	316a0 <_printf_float+0xbc>
   318a6:	f109 0901 	add.w	r9, r9, #1
   318aa:	e7ee      	b.n	3188a <_printf_float+0x2a6>
   318ac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   318ae:	6da3      	ldr	r3, [r4, #88]	; 0x58
   318b0:	429a      	cmp	r2, r3
   318b2:	bfa8      	it	ge
   318b4:	461a      	movge	r2, r3
   318b6:	2a00      	cmp	r2, #0
   318b8:	4691      	mov	r9, r2
   318ba:	dd07      	ble.n	318cc <_printf_float+0x2e8>
   318bc:	4613      	mov	r3, r2
   318be:	4631      	mov	r1, r6
   318c0:	4642      	mov	r2, r8
   318c2:	4628      	mov	r0, r5
   318c4:	47b8      	blx	r7
   318c6:	3001      	adds	r0, #1
   318c8:	f43f aeea 	beq.w	316a0 <_printf_float+0xbc>
   318cc:	f104 031a 	add.w	r3, r4, #26
   318d0:	f04f 0b00 	mov.w	fp, #0
   318d4:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   318d8:	9304      	str	r3, [sp, #16]
   318da:	e015      	b.n	31908 <_printf_float+0x324>
   318dc:	7fefffff 	.word	0x7fefffff
   318e0:	00040299 	.word	0x00040299
   318e4:	0003caeb 	.word	0x0003caeb
   318e8:	0004029d 	.word	0x0004029d
   318ec:	000402a1 	.word	0x000402a1
   318f0:	0003fd3b 	.word	0x0003fd3b
   318f4:	2301      	movs	r3, #1
   318f6:	9a04      	ldr	r2, [sp, #16]
   318f8:	4631      	mov	r1, r6
   318fa:	4628      	mov	r0, r5
   318fc:	47b8      	blx	r7
   318fe:	3001      	adds	r0, #1
   31900:	f43f aece 	beq.w	316a0 <_printf_float+0xbc>
   31904:	f10b 0b01 	add.w	fp, fp, #1
   31908:	f8d4 a058 	ldr.w	sl, [r4, #88]	; 0x58
   3190c:	ebaa 0309 	sub.w	r3, sl, r9
   31910:	455b      	cmp	r3, fp
   31912:	dcef      	bgt.n	318f4 <_printf_float+0x310>
   31914:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   31918:	429a      	cmp	r2, r3
   3191a:	db1b      	blt.n	31954 <_printf_float+0x370>
   3191c:	6823      	ldr	r3, [r4, #0]
   3191e:	07da      	lsls	r2, r3, #31
   31920:	d418      	bmi.n	31954 <_printf_float+0x370>
   31922:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   31926:	4592      	cmp	sl, r2
   31928:	db1c      	blt.n	31964 <_printf_float+0x380>
   3192a:	eba3 090a 	sub.w	r9, r3, sl
   3192e:	f1b9 0f00 	cmp.w	r9, #0
   31932:	dd08      	ble.n	31946 <_printf_float+0x362>
   31934:	464b      	mov	r3, r9
   31936:	eb08 020a 	add.w	r2, r8, sl
   3193a:	4631      	mov	r1, r6
   3193c:	4628      	mov	r0, r5
   3193e:	47b8      	blx	r7
   31940:	3001      	adds	r0, #1
   31942:	f43f aead 	beq.w	316a0 <_printf_float+0xbc>
   31946:	f04f 0800 	mov.w	r8, #0
   3194a:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
   3194e:	f104 0a1a 	add.w	sl, r4, #26
   31952:	e014      	b.n	3197e <_printf_float+0x39a>
   31954:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   31958:	4631      	mov	r1, r6
   3195a:	4628      	mov	r0, r5
   3195c:	47b8      	blx	r7
   3195e:	3001      	adds	r0, #1
   31960:	d1df      	bne.n	31922 <_printf_float+0x33e>
   31962:	e69d      	b.n	316a0 <_printf_float+0xbc>
   31964:	eba3 0902 	sub.w	r9, r3, r2
   31968:	e7e1      	b.n	3192e <_printf_float+0x34a>
   3196a:	2301      	movs	r3, #1
   3196c:	4652      	mov	r2, sl
   3196e:	4631      	mov	r1, r6
   31970:	4628      	mov	r0, r5
   31972:	47b8      	blx	r7
   31974:	3001      	adds	r0, #1
   31976:	f43f ae93 	beq.w	316a0 <_printf_float+0xbc>
   3197a:	f108 0801 	add.w	r8, r8, #1
   3197e:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   31982:	1a9b      	subs	r3, r3, r2
   31984:	eba3 0309 	sub.w	r3, r3, r9
   31988:	4543      	cmp	r3, r8
   3198a:	dcee      	bgt.n	3196a <_printf_float+0x386>
   3198c:	e74a      	b.n	31824 <_printf_float+0x240>
   3198e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   31990:	2a01      	cmp	r2, #1
   31992:	dc01      	bgt.n	31998 <_printf_float+0x3b4>
   31994:	07db      	lsls	r3, r3, #31
   31996:	d537      	bpl.n	31a08 <_printf_float+0x424>
   31998:	2301      	movs	r3, #1
   3199a:	4642      	mov	r2, r8
   3199c:	4631      	mov	r1, r6
   3199e:	4628      	mov	r0, r5
   319a0:	47b8      	blx	r7
   319a2:	3001      	adds	r0, #1
   319a4:	f43f ae7c 	beq.w	316a0 <_printf_float+0xbc>
   319a8:	4631      	mov	r1, r6
   319aa:	4628      	mov	r0, r5
   319ac:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
   319b0:	47b8      	blx	r7
   319b2:	3001      	adds	r0, #1
   319b4:	f43f ae74 	beq.w	316a0 <_printf_float+0xbc>
   319b8:	2200      	movs	r2, #0
   319ba:	2300      	movs	r3, #0
   319bc:	e9d4 0112 	ldrd	r0, r1, [r4, #72]	; 0x48
   319c0:	f7db fddc 	bl	d57c <__aeabi_dcmpeq>
   319c4:	b9d8      	cbnz	r0, 319fe <_printf_float+0x41a>
   319c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   319c8:	f108 0201 	add.w	r2, r8, #1
   319cc:	3b01      	subs	r3, #1
   319ce:	4631      	mov	r1, r6
   319d0:	4628      	mov	r0, r5
   319d2:	47b8      	blx	r7
   319d4:	3001      	adds	r0, #1
   319d6:	d10e      	bne.n	319f6 <_printf_float+0x412>
   319d8:	e662      	b.n	316a0 <_printf_float+0xbc>
   319da:	2301      	movs	r3, #1
   319dc:	4652      	mov	r2, sl
   319de:	4631      	mov	r1, r6
   319e0:	4628      	mov	r0, r5
   319e2:	47b8      	blx	r7
   319e4:	3001      	adds	r0, #1
   319e6:	f43f ae5b 	beq.w	316a0 <_printf_float+0xbc>
   319ea:	f108 0801 	add.w	r8, r8, #1
   319ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   319f0:	3b01      	subs	r3, #1
   319f2:	4543      	cmp	r3, r8
   319f4:	dcf1      	bgt.n	319da <_printf_float+0x3f6>
   319f6:	464b      	mov	r3, r9
   319f8:	f104 0250 	add.w	r2, r4, #80	; 0x50
   319fc:	e6e1      	b.n	317c2 <_printf_float+0x1de>
   319fe:	f04f 0800 	mov.w	r8, #0
   31a02:	f104 0a1a 	add.w	sl, r4, #26
   31a06:	e7f2      	b.n	319ee <_printf_float+0x40a>
   31a08:	2301      	movs	r3, #1
   31a0a:	4642      	mov	r2, r8
   31a0c:	e7df      	b.n	319ce <_printf_float+0x3ea>
   31a0e:	2301      	movs	r3, #1
   31a10:	464a      	mov	r2, r9
   31a12:	4631      	mov	r1, r6
   31a14:	4628      	mov	r0, r5
   31a16:	47b8      	blx	r7
   31a18:	3001      	adds	r0, #1
   31a1a:	f43f ae41 	beq.w	316a0 <_printf_float+0xbc>
   31a1e:	f108 0801 	add.w	r8, r8, #1
   31a22:	68e3      	ldr	r3, [r4, #12]
   31a24:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   31a26:	1a9b      	subs	r3, r3, r2
   31a28:	4543      	cmp	r3, r8
   31a2a:	dcf0      	bgt.n	31a0e <_printf_float+0x42a>
   31a2c:	e6fe      	b.n	3182c <_printf_float+0x248>
   31a2e:	f04f 0800 	mov.w	r8, #0
   31a32:	f104 0919 	add.w	r9, r4, #25
   31a36:	e7f4      	b.n	31a22 <_printf_float+0x43e>

00031a38 <_printf_i>:
   31a38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   31a3c:	4606      	mov	r6, r0
   31a3e:	460c      	mov	r4, r1
   31a40:	f101 0043 	add.w	r0, r1, #67	; 0x43
   31a44:	7e09      	ldrb	r1, [r1, #24]
   31a46:	b085      	sub	sp, #20
   31a48:	4698      	mov	r8, r3
   31a4a:	296e      	cmp	r1, #110	; 0x6e
   31a4c:	4617      	mov	r7, r2
   31a4e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
   31a50:	f000 80ba 	beq.w	31bc8 <_printf_i+0x190>
   31a54:	d824      	bhi.n	31aa0 <_printf_i+0x68>
   31a56:	2963      	cmp	r1, #99	; 0x63
   31a58:	d039      	beq.n	31ace <_printf_i+0x96>
   31a5a:	d80a      	bhi.n	31a72 <_printf_i+0x3a>
   31a5c:	2900      	cmp	r1, #0
   31a5e:	f000 80c3 	beq.w	31be8 <_printf_i+0x1b0>
   31a62:	2958      	cmp	r1, #88	; 0x58
   31a64:	f000 8091 	beq.w	31b8a <_printf_i+0x152>
   31a68:	f104 0542 	add.w	r5, r4, #66	; 0x42
   31a6c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   31a70:	e035      	b.n	31ade <_printf_i+0xa6>
   31a72:	2964      	cmp	r1, #100	; 0x64
   31a74:	d001      	beq.n	31a7a <_printf_i+0x42>
   31a76:	2969      	cmp	r1, #105	; 0x69
   31a78:	d1f6      	bne.n	31a68 <_printf_i+0x30>
   31a7a:	6825      	ldr	r5, [r4, #0]
   31a7c:	681a      	ldr	r2, [r3, #0]
   31a7e:	f015 0f80 	tst.w	r5, #128	; 0x80
   31a82:	f102 0104 	add.w	r1, r2, #4
   31a86:	d02c      	beq.n	31ae2 <_printf_i+0xaa>
   31a88:	6812      	ldr	r2, [r2, #0]
   31a8a:	6019      	str	r1, [r3, #0]
   31a8c:	2a00      	cmp	r2, #0
   31a8e:	da03      	bge.n	31a98 <_printf_i+0x60>
   31a90:	232d      	movs	r3, #45	; 0x2d
   31a92:	4252      	negs	r2, r2
   31a94:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   31a98:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 31c58 <_printf_i+0x220>
   31a9c:	230a      	movs	r3, #10
   31a9e:	e03f      	b.n	31b20 <_printf_i+0xe8>
   31aa0:	2973      	cmp	r1, #115	; 0x73
   31aa2:	f000 80a5 	beq.w	31bf0 <_printf_i+0x1b8>
   31aa6:	d808      	bhi.n	31aba <_printf_i+0x82>
   31aa8:	296f      	cmp	r1, #111	; 0x6f
   31aaa:	d021      	beq.n	31af0 <_printf_i+0xb8>
   31aac:	2970      	cmp	r1, #112	; 0x70
   31aae:	d1db      	bne.n	31a68 <_printf_i+0x30>
   31ab0:	6822      	ldr	r2, [r4, #0]
   31ab2:	f042 0220 	orr.w	r2, r2, #32
   31ab6:	6022      	str	r2, [r4, #0]
   31ab8:	e003      	b.n	31ac2 <_printf_i+0x8a>
   31aba:	2975      	cmp	r1, #117	; 0x75
   31abc:	d018      	beq.n	31af0 <_printf_i+0xb8>
   31abe:	2978      	cmp	r1, #120	; 0x78
   31ac0:	d1d2      	bne.n	31a68 <_printf_i+0x30>
   31ac2:	2278      	movs	r2, #120	; 0x78
   31ac4:	f8df c194 	ldr.w	ip, [pc, #404]	; 31c5c <_printf_i+0x224>
   31ac8:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
   31acc:	e061      	b.n	31b92 <_printf_i+0x15a>
   31ace:	681a      	ldr	r2, [r3, #0]
   31ad0:	f104 0542 	add.w	r5, r4, #66	; 0x42
   31ad4:	1d11      	adds	r1, r2, #4
   31ad6:	6019      	str	r1, [r3, #0]
   31ad8:	6813      	ldr	r3, [r2, #0]
   31ada:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   31ade:	2301      	movs	r3, #1
   31ae0:	e093      	b.n	31c0a <_printf_i+0x1d2>
   31ae2:	6812      	ldr	r2, [r2, #0]
   31ae4:	f015 0f40 	tst.w	r5, #64	; 0x40
   31ae8:	6019      	str	r1, [r3, #0]
   31aea:	bf18      	it	ne
   31aec:	b212      	sxthne	r2, r2
   31aee:	e7cd      	b.n	31a8c <_printf_i+0x54>
   31af0:	f8d4 c000 	ldr.w	ip, [r4]
   31af4:	681a      	ldr	r2, [r3, #0]
   31af6:	f01c 0f80 	tst.w	ip, #128	; 0x80
   31afa:	f102 0504 	add.w	r5, r2, #4
   31afe:	601d      	str	r5, [r3, #0]
   31b00:	d001      	beq.n	31b06 <_printf_i+0xce>
   31b02:	6812      	ldr	r2, [r2, #0]
   31b04:	e003      	b.n	31b0e <_printf_i+0xd6>
   31b06:	f01c 0f40 	tst.w	ip, #64	; 0x40
   31b0a:	d0fa      	beq.n	31b02 <_printf_i+0xca>
   31b0c:	8812      	ldrh	r2, [r2, #0]
   31b0e:	296f      	cmp	r1, #111	; 0x6f
   31b10:	f8df c144 	ldr.w	ip, [pc, #324]	; 31c58 <_printf_i+0x220>
   31b14:	bf0c      	ite	eq
   31b16:	2308      	moveq	r3, #8
   31b18:	230a      	movne	r3, #10
   31b1a:	2100      	movs	r1, #0
   31b1c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   31b20:	6865      	ldr	r5, [r4, #4]
   31b22:	2d00      	cmp	r5, #0
   31b24:	60a5      	str	r5, [r4, #8]
   31b26:	bfa2      	ittt	ge
   31b28:	6821      	ldrge	r1, [r4, #0]
   31b2a:	f021 0104 	bicge.w	r1, r1, #4
   31b2e:	6021      	strge	r1, [r4, #0]
   31b30:	b90a      	cbnz	r2, 31b36 <_printf_i+0xfe>
   31b32:	2d00      	cmp	r5, #0
   31b34:	d046      	beq.n	31bc4 <_printf_i+0x18c>
   31b36:	4605      	mov	r5, r0
   31b38:	4293      	cmp	r3, r2
   31b3a:	fbb2 f1f3 	udiv	r1, r2, r3
   31b3e:	fb03 2e11 	mls	lr, r3, r1, r2
   31b42:	f81c e00e 	ldrb.w	lr, [ip, lr]
   31b46:	f805 ed01 	strb.w	lr, [r5, #-1]!
   31b4a:	d939      	bls.n	31bc0 <_printf_i+0x188>
   31b4c:	2b08      	cmp	r3, #8
   31b4e:	d10b      	bne.n	31b68 <_printf_i+0x130>
   31b50:	6823      	ldr	r3, [r4, #0]
   31b52:	07da      	lsls	r2, r3, #31
   31b54:	d508      	bpl.n	31b68 <_printf_i+0x130>
   31b56:	6923      	ldr	r3, [r4, #16]
   31b58:	6862      	ldr	r2, [r4, #4]
   31b5a:	429a      	cmp	r2, r3
   31b5c:	bfde      	ittt	le
   31b5e:	2330      	movle	r3, #48	; 0x30
   31b60:	f805 3c01 	strble.w	r3, [r5, #-1]
   31b64:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
   31b68:	1b40      	subs	r0, r0, r5
   31b6a:	6120      	str	r0, [r4, #16]
   31b6c:	f8cd 8000 	str.w	r8, [sp]
   31b70:	463b      	mov	r3, r7
   31b72:	aa03      	add	r2, sp, #12
   31b74:	4621      	mov	r1, r4
   31b76:	4630      	mov	r0, r6
   31b78:	f007 fb37 	bl	391ea <_printf_common>
   31b7c:	3001      	adds	r0, #1
   31b7e:	d149      	bne.n	31c14 <_printf_i+0x1dc>
   31b80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   31b84:	b005      	add	sp, #20
   31b86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   31b8a:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 31c58 <_printf_i+0x220>
   31b8e:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   31b92:	681d      	ldr	r5, [r3, #0]
   31b94:	6821      	ldr	r1, [r4, #0]
   31b96:	f855 2b04 	ldr.w	r2, [r5], #4
   31b9a:	601d      	str	r5, [r3, #0]
   31b9c:	060d      	lsls	r5, r1, #24
   31b9e:	d50b      	bpl.n	31bb8 <_printf_i+0x180>
   31ba0:	07cd      	lsls	r5, r1, #31
   31ba2:	bf44      	itt	mi
   31ba4:	f041 0120 	orrmi.w	r1, r1, #32
   31ba8:	6021      	strmi	r1, [r4, #0]
   31baa:	b91a      	cbnz	r2, 31bb4 <_printf_i+0x17c>
   31bac:	6823      	ldr	r3, [r4, #0]
   31bae:	f023 0320 	bic.w	r3, r3, #32
   31bb2:	6023      	str	r3, [r4, #0]
   31bb4:	2310      	movs	r3, #16
   31bb6:	e7b0      	b.n	31b1a <_printf_i+0xe2>
   31bb8:	064b      	lsls	r3, r1, #25
   31bba:	bf48      	it	mi
   31bbc:	b292      	uxthmi	r2, r2
   31bbe:	e7ef      	b.n	31ba0 <_printf_i+0x168>
   31bc0:	460a      	mov	r2, r1
   31bc2:	e7b9      	b.n	31b38 <_printf_i+0x100>
   31bc4:	4605      	mov	r5, r0
   31bc6:	e7c1      	b.n	31b4c <_printf_i+0x114>
   31bc8:	681a      	ldr	r2, [r3, #0]
   31bca:	f8d4 c000 	ldr.w	ip, [r4]
   31bce:	1d15      	adds	r5, r2, #4
   31bd0:	6961      	ldr	r1, [r4, #20]
   31bd2:	f01c 0f80 	tst.w	ip, #128	; 0x80
   31bd6:	601d      	str	r5, [r3, #0]
   31bd8:	6813      	ldr	r3, [r2, #0]
   31bda:	d001      	beq.n	31be0 <_printf_i+0x1a8>
   31bdc:	6019      	str	r1, [r3, #0]
   31bde:	e003      	b.n	31be8 <_printf_i+0x1b0>
   31be0:	f01c 0f40 	tst.w	ip, #64	; 0x40
   31be4:	d0fa      	beq.n	31bdc <_printf_i+0x1a4>
   31be6:	8019      	strh	r1, [r3, #0]
   31be8:	2300      	movs	r3, #0
   31bea:	4605      	mov	r5, r0
   31bec:	6123      	str	r3, [r4, #16]
   31bee:	e7bd      	b.n	31b6c <_printf_i+0x134>
   31bf0:	681a      	ldr	r2, [r3, #0]
   31bf2:	1d11      	adds	r1, r2, #4
   31bf4:	6019      	str	r1, [r3, #0]
   31bf6:	2100      	movs	r1, #0
   31bf8:	6815      	ldr	r5, [r2, #0]
   31bfa:	6862      	ldr	r2, [r4, #4]
   31bfc:	4628      	mov	r0, r5
   31bfe:	f007 f9cf 	bl	38fa0 <memchr>
   31c02:	b108      	cbz	r0, 31c08 <_printf_i+0x1d0>
   31c04:	1b40      	subs	r0, r0, r5
   31c06:	6060      	str	r0, [r4, #4]
   31c08:	6863      	ldr	r3, [r4, #4]
   31c0a:	6123      	str	r3, [r4, #16]
   31c0c:	2300      	movs	r3, #0
   31c0e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   31c12:	e7ab      	b.n	31b6c <_printf_i+0x134>
   31c14:	6923      	ldr	r3, [r4, #16]
   31c16:	462a      	mov	r2, r5
   31c18:	4639      	mov	r1, r7
   31c1a:	4630      	mov	r0, r6
   31c1c:	47c0      	blx	r8
   31c1e:	3001      	adds	r0, #1
   31c20:	d0ae      	beq.n	31b80 <_printf_i+0x148>
   31c22:	6823      	ldr	r3, [r4, #0]
   31c24:	079b      	lsls	r3, r3, #30
   31c26:	d413      	bmi.n	31c50 <_printf_i+0x218>
   31c28:	68e0      	ldr	r0, [r4, #12]
   31c2a:	9b03      	ldr	r3, [sp, #12]
   31c2c:	4298      	cmp	r0, r3
   31c2e:	bfb8      	it	lt
   31c30:	4618      	movlt	r0, r3
   31c32:	e7a7      	b.n	31b84 <_printf_i+0x14c>
   31c34:	2301      	movs	r3, #1
   31c36:	464a      	mov	r2, r9
   31c38:	4639      	mov	r1, r7
   31c3a:	4630      	mov	r0, r6
   31c3c:	47c0      	blx	r8
   31c3e:	3001      	adds	r0, #1
   31c40:	d09e      	beq.n	31b80 <_printf_i+0x148>
   31c42:	3501      	adds	r5, #1
   31c44:	68e3      	ldr	r3, [r4, #12]
   31c46:	9a03      	ldr	r2, [sp, #12]
   31c48:	1a9b      	subs	r3, r3, r2
   31c4a:	42ab      	cmp	r3, r5
   31c4c:	dcf2      	bgt.n	31c34 <_printf_i+0x1fc>
   31c4e:	e7eb      	b.n	31c28 <_printf_i+0x1f0>
   31c50:	2500      	movs	r5, #0
   31c52:	f104 0919 	add.w	r9, r4, #25
   31c56:	e7f5      	b.n	31c44 <_printf_i+0x20c>
   31c58:	000402a5 	.word	0x000402a5
   31c5c:	000402b6 	.word	0x000402b6

00031c60 <_sbrk_r>:
   31c60:	b538      	push	{r3, r4, r5, lr}
   31c62:	2300      	movs	r3, #0
   31c64:	4c05      	ldr	r4, [pc, #20]	; (31c7c <_sbrk_r+0x1c>)
   31c66:	4605      	mov	r5, r0
   31c68:	4608      	mov	r0, r1
   31c6a:	6023      	str	r3, [r4, #0]
   31c6c:	f7e9 ff16 	bl	1ba9c <_sbrk>
   31c70:	1c43      	adds	r3, r0, #1
   31c72:	d102      	bne.n	31c7a <_sbrk_r+0x1a>
   31c74:	6823      	ldr	r3, [r4, #0]
   31c76:	b103      	cbz	r3, 31c7a <_sbrk_r+0x1a>
   31c78:	602b      	str	r3, [r5, #0]
   31c7a:	bd38      	pop	{r3, r4, r5, pc}
   31c7c:	200291f8 	.word	0x200291f8

00031c80 <sniprintf>:
   31c80:	b40c      	push	{r2, r3}
   31c82:	4b18      	ldr	r3, [pc, #96]	; (31ce4 <sniprintf+0x64>)
   31c84:	b530      	push	{r4, r5, lr}
   31c86:	1e0c      	subs	r4, r1, #0
   31c88:	b09d      	sub	sp, #116	; 0x74
   31c8a:	681d      	ldr	r5, [r3, #0]
   31c8c:	da08      	bge.n	31ca0 <sniprintf+0x20>
   31c8e:	238b      	movs	r3, #139	; 0x8b
   31c90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   31c94:	602b      	str	r3, [r5, #0]
   31c96:	b01d      	add	sp, #116	; 0x74
   31c98:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   31c9c:	b002      	add	sp, #8
   31c9e:	4770      	bx	lr
   31ca0:	f44f 7302 	mov.w	r3, #520	; 0x208
   31ca4:	9002      	str	r0, [sp, #8]
   31ca6:	9006      	str	r0, [sp, #24]
   31ca8:	a902      	add	r1, sp, #8
   31caa:	f8ad 3014 	strh.w	r3, [sp, #20]
   31cae:	bf14      	ite	ne
   31cb0:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   31cb4:	4623      	moveq	r3, r4
   31cb6:	9a20      	ldr	r2, [sp, #128]	; 0x80
   31cb8:	4628      	mov	r0, r5
   31cba:	9304      	str	r3, [sp, #16]
   31cbc:	9307      	str	r3, [sp, #28]
   31cbe:	f64f 73ff 	movw	r3, #65535	; 0xffff
   31cc2:	f8ad 3016 	strh.w	r3, [sp, #22]
   31cc6:	ab21      	add	r3, sp, #132	; 0x84
   31cc8:	9301      	str	r3, [sp, #4]
   31cca:	f000 fe1f 	bl	3290c <_svfiprintf_r>
   31cce:	1c43      	adds	r3, r0, #1
   31cd0:	bfbc      	itt	lt
   31cd2:	238b      	movlt	r3, #139	; 0x8b
   31cd4:	602b      	strlt	r3, [r5, #0]
   31cd6:	2c00      	cmp	r4, #0
   31cd8:	d0dd      	beq.n	31c96 <sniprintf+0x16>
   31cda:	9b02      	ldr	r3, [sp, #8]
   31cdc:	2200      	movs	r2, #0
   31cde:	701a      	strb	r2, [r3, #0]
   31ce0:	e7d9      	b.n	31c96 <sniprintf+0x16>
   31ce2:	bf00      	nop
   31ce4:	20020234 	.word	0x20020234

00031ce8 <siprintf>:
   31ce8:	b40e      	push	{r1, r2, r3}
   31cea:	b500      	push	{lr}
   31cec:	b09c      	sub	sp, #112	; 0x70
   31cee:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   31cf2:	ab1d      	add	r3, sp, #116	; 0x74
   31cf4:	9002      	str	r0, [sp, #8]
   31cf6:	9006      	str	r0, [sp, #24]
   31cf8:	9107      	str	r1, [sp, #28]
   31cfa:	9104      	str	r1, [sp, #16]
   31cfc:	4808      	ldr	r0, [pc, #32]	; (31d20 <siprintf+0x38>)
   31cfe:	4909      	ldr	r1, [pc, #36]	; (31d24 <siprintf+0x3c>)
   31d00:	f853 2b04 	ldr.w	r2, [r3], #4
   31d04:	9105      	str	r1, [sp, #20]
   31d06:	a902      	add	r1, sp, #8
   31d08:	6800      	ldr	r0, [r0, #0]
   31d0a:	9301      	str	r3, [sp, #4]
   31d0c:	f000 fdfe 	bl	3290c <_svfiprintf_r>
   31d10:	9b02      	ldr	r3, [sp, #8]
   31d12:	2200      	movs	r2, #0
   31d14:	701a      	strb	r2, [r3, #0]
   31d16:	b01c      	add	sp, #112	; 0x70
   31d18:	f85d eb04 	ldr.w	lr, [sp], #4
   31d1c:	b003      	add	sp, #12
   31d1e:	4770      	bx	lr
   31d20:	20020234 	.word	0x20020234
   31d24:	ffff0208 	.word	0xffff0208

00031d28 <_strerror_r>:
   31d28:	b510      	push	{r4, lr}
   31d2a:	4604      	mov	r4, r0
   31d2c:	4608      	mov	r0, r1
   31d2e:	4611      	mov	r1, r2
   31d30:	288e      	cmp	r0, #142	; 0x8e
   31d32:	f200 812f 	bhi.w	31f94 <_strerror_r+0x26c>
   31d36:	e8df f010 	tbh	[pc, r0, lsl #1]
   31d3a:	0138      	.short	0x0138
   31d3c:	0091008f 	.word	0x0091008f
   31d40:	00950093 	.word	0x00950093
   31d44:	00990097 	.word	0x00990097
   31d48:	009d009b 	.word	0x009d009b
   31d4c:	00a300a1 	.word	0x00a300a1
   31d50:	00a900a7 	.word	0x00a900a7
   31d54:	00ad00ab 	.word	0x00ad00ab
   31d58:	00af012d 	.word	0x00af012d
   31d5c:	00b300b1 	.word	0x00b300b1
   31d60:	00b700b5 	.word	0x00b700b5
   31d64:	00bf00bd 	.word	0x00bf00bd
   31d68:	00c700c5 	.word	0x00c700c5
   31d6c:	00cb00c9 	.word	0x00cb00c9
   31d70:	00d100cd 	.word	0x00d100cd
   31d74:	00d700d5 	.word	0x00d700d5
   31d78:	00db00d9 	.word	0x00db00d9
   31d7c:	00df00dd 	.word	0x00df00dd
   31d80:	00e300e1 	.word	0x00e300e1
   31d84:	012d012d 	.word	0x012d012d
   31d88:	012d012d 	.word	0x012d012d
   31d8c:	012d012d 	.word	0x012d012d
   31d90:	012d012d 	.word	0x012d012d
   31d94:	00eb00e7 	.word	0x00eb00e7
   31d98:	012d012d 	.word	0x012d012d
   31d9c:	012d012d 	.word	0x012d012d
   31da0:	012d012d 	.word	0x012d012d
   31da4:	012d012d 	.word	0x012d012d
   31da8:	012d012d 	.word	0x012d012d
   31dac:	012d012d 	.word	0x012d012d
   31db0:	00ed012d 	.word	0x00ed012d
   31db4:	00ef0107 	.word	0x00ef0107
   31db8:	012d00f1 	.word	0x012d00f1
   31dbc:	012d012d 	.word	0x012d012d
   31dc0:	012d00f3 	.word	0x012d00f3
   31dc4:	012d012d 	.word	0x012d012d
   31dc8:	012d00f5 	.word	0x012d00f5
   31dcc:	00f9012d 	.word	0x00f9012d
   31dd0:	012d012d 	.word	0x012d012d
   31dd4:	012d00fb 	.word	0x012d00fb
   31dd8:	012d012d 	.word	0x012d012d
   31ddc:	012d012d 	.word	0x012d012d
   31de0:	012d012d 	.word	0x012d012d
   31de4:	012d012d 	.word	0x012d012d
   31de8:	00fd012d 	.word	0x00fd012d
   31dec:	00ff012d 	.word	0x00ff012d
   31df0:	01030101 	.word	0x01030101
   31df4:	012d012d 	.word	0x012d012d
   31df8:	012d0125 	.word	0x012d0125
   31dfc:	012d012d 	.word	0x012d012d
   31e00:	012d012d 	.word	0x012d012d
   31e04:	012d012d 	.word	0x012d012d
   31e08:	0113012d 	.word	0x0113012d
   31e0c:	01090105 	.word	0x01090105
   31e10:	010d010b 	.word	0x010d010b
   31e14:	012d010f 	.word	0x012d010f
   31e18:	01150111 	.word	0x01150111
   31e1c:	00e90119 	.word	0x00e90119
   31e20:	012b00c1 	.word	0x012b00c1
   31e24:	00cf00b9 	.word	0x00cf00b9
   31e28:	009f00bb 	.word	0x009f00bb
   31e2c:	012900a5 	.word	0x012900a5
   31e30:	012d00f7 	.word	0x012d00f7
   31e34:	00c30117 	.word	0x00c30117
   31e38:	011b011d 	.word	0x011b011d
   31e3c:	012d012d 	.word	0x012d012d
   31e40:	012d012d 	.word	0x012d012d
   31e44:	00d3012d 	.word	0x00d3012d
   31e48:	012d012d 	.word	0x012d012d
   31e4c:	00e5012d 	.word	0x00e5012d
   31e50:	011f0127 	.word	0x011f0127
   31e54:	01230121 	.word	0x01230121
   31e58:	4855      	ldr	r0, [pc, #340]	; (31fb0 <_strerror_r+0x288>)
   31e5a:	bd10      	pop	{r4, pc}
   31e5c:	4855      	ldr	r0, [pc, #340]	; (31fb4 <_strerror_r+0x28c>)
   31e5e:	e7fc      	b.n	31e5a <_strerror_r+0x132>
   31e60:	4855      	ldr	r0, [pc, #340]	; (31fb8 <_strerror_r+0x290>)
   31e62:	e7fa      	b.n	31e5a <_strerror_r+0x132>
   31e64:	4855      	ldr	r0, [pc, #340]	; (31fbc <_strerror_r+0x294>)
   31e66:	e7f8      	b.n	31e5a <_strerror_r+0x132>
   31e68:	4855      	ldr	r0, [pc, #340]	; (31fc0 <_strerror_r+0x298>)
   31e6a:	e7f6      	b.n	31e5a <_strerror_r+0x132>
   31e6c:	4855      	ldr	r0, [pc, #340]	; (31fc4 <_strerror_r+0x29c>)
   31e6e:	e7f4      	b.n	31e5a <_strerror_r+0x132>
   31e70:	4855      	ldr	r0, [pc, #340]	; (31fc8 <_strerror_r+0x2a0>)
   31e72:	e7f2      	b.n	31e5a <_strerror_r+0x132>
   31e74:	4855      	ldr	r0, [pc, #340]	; (31fcc <_strerror_r+0x2a4>)
   31e76:	e7f0      	b.n	31e5a <_strerror_r+0x132>
   31e78:	4855      	ldr	r0, [pc, #340]	; (31fd0 <_strerror_r+0x2a8>)
   31e7a:	e7ee      	b.n	31e5a <_strerror_r+0x132>
   31e7c:	4855      	ldr	r0, [pc, #340]	; (31fd4 <_strerror_r+0x2ac>)
   31e7e:	e7ec      	b.n	31e5a <_strerror_r+0x132>
   31e80:	4855      	ldr	r0, [pc, #340]	; (31fd8 <_strerror_r+0x2b0>)
   31e82:	e7ea      	b.n	31e5a <_strerror_r+0x132>
   31e84:	4855      	ldr	r0, [pc, #340]	; (31fdc <_strerror_r+0x2b4>)
   31e86:	e7e8      	b.n	31e5a <_strerror_r+0x132>
   31e88:	4855      	ldr	r0, [pc, #340]	; (31fe0 <_strerror_r+0x2b8>)
   31e8a:	e7e6      	b.n	31e5a <_strerror_r+0x132>
   31e8c:	4855      	ldr	r0, [pc, #340]	; (31fe4 <_strerror_r+0x2bc>)
   31e8e:	e7e4      	b.n	31e5a <_strerror_r+0x132>
   31e90:	4855      	ldr	r0, [pc, #340]	; (31fe8 <_strerror_r+0x2c0>)
   31e92:	e7e2      	b.n	31e5a <_strerror_r+0x132>
   31e94:	4855      	ldr	r0, [pc, #340]	; (31fec <_strerror_r+0x2c4>)
   31e96:	e7e0      	b.n	31e5a <_strerror_r+0x132>
   31e98:	4855      	ldr	r0, [pc, #340]	; (31ff0 <_strerror_r+0x2c8>)
   31e9a:	e7de      	b.n	31e5a <_strerror_r+0x132>
   31e9c:	4855      	ldr	r0, [pc, #340]	; (31ff4 <_strerror_r+0x2cc>)
   31e9e:	e7dc      	b.n	31e5a <_strerror_r+0x132>
   31ea0:	4855      	ldr	r0, [pc, #340]	; (31ff8 <_strerror_r+0x2d0>)
   31ea2:	e7da      	b.n	31e5a <_strerror_r+0x132>
   31ea4:	4855      	ldr	r0, [pc, #340]	; (31ffc <_strerror_r+0x2d4>)
   31ea6:	e7d8      	b.n	31e5a <_strerror_r+0x132>
   31ea8:	4855      	ldr	r0, [pc, #340]	; (32000 <_strerror_r+0x2d8>)
   31eaa:	e7d6      	b.n	31e5a <_strerror_r+0x132>
   31eac:	4855      	ldr	r0, [pc, #340]	; (32004 <_strerror_r+0x2dc>)
   31eae:	e7d4      	b.n	31e5a <_strerror_r+0x132>
   31eb0:	4855      	ldr	r0, [pc, #340]	; (32008 <_strerror_r+0x2e0>)
   31eb2:	e7d2      	b.n	31e5a <_strerror_r+0x132>
   31eb4:	4855      	ldr	r0, [pc, #340]	; (3200c <_strerror_r+0x2e4>)
   31eb6:	e7d0      	b.n	31e5a <_strerror_r+0x132>
   31eb8:	4855      	ldr	r0, [pc, #340]	; (32010 <_strerror_r+0x2e8>)
   31eba:	e7ce      	b.n	31e5a <_strerror_r+0x132>
   31ebc:	4855      	ldr	r0, [pc, #340]	; (32014 <_strerror_r+0x2ec>)
   31ebe:	e7cc      	b.n	31e5a <_strerror_r+0x132>
   31ec0:	4855      	ldr	r0, [pc, #340]	; (32018 <_strerror_r+0x2f0>)
   31ec2:	e7ca      	b.n	31e5a <_strerror_r+0x132>
   31ec4:	4855      	ldr	r0, [pc, #340]	; (3201c <_strerror_r+0x2f4>)
   31ec6:	e7c8      	b.n	31e5a <_strerror_r+0x132>
   31ec8:	4855      	ldr	r0, [pc, #340]	; (32020 <_strerror_r+0x2f8>)
   31eca:	e7c6      	b.n	31e5a <_strerror_r+0x132>
   31ecc:	4855      	ldr	r0, [pc, #340]	; (32024 <_strerror_r+0x2fc>)
   31ece:	e7c4      	b.n	31e5a <_strerror_r+0x132>
   31ed0:	4855      	ldr	r0, [pc, #340]	; (32028 <_strerror_r+0x300>)
   31ed2:	e7c2      	b.n	31e5a <_strerror_r+0x132>
   31ed4:	4855      	ldr	r0, [pc, #340]	; (3202c <_strerror_r+0x304>)
   31ed6:	e7c0      	b.n	31e5a <_strerror_r+0x132>
   31ed8:	4855      	ldr	r0, [pc, #340]	; (32030 <_strerror_r+0x308>)
   31eda:	e7be      	b.n	31e5a <_strerror_r+0x132>
   31edc:	4855      	ldr	r0, [pc, #340]	; (32034 <_strerror_r+0x30c>)
   31ede:	e7bc      	b.n	31e5a <_strerror_r+0x132>
   31ee0:	4855      	ldr	r0, [pc, #340]	; (32038 <_strerror_r+0x310>)
   31ee2:	e7ba      	b.n	31e5a <_strerror_r+0x132>
   31ee4:	4855      	ldr	r0, [pc, #340]	; (3203c <_strerror_r+0x314>)
   31ee6:	e7b8      	b.n	31e5a <_strerror_r+0x132>
   31ee8:	4855      	ldr	r0, [pc, #340]	; (32040 <_strerror_r+0x318>)
   31eea:	e7b6      	b.n	31e5a <_strerror_r+0x132>
   31eec:	4855      	ldr	r0, [pc, #340]	; (32044 <_strerror_r+0x31c>)
   31eee:	e7b4      	b.n	31e5a <_strerror_r+0x132>
   31ef0:	4855      	ldr	r0, [pc, #340]	; (32048 <_strerror_r+0x320>)
   31ef2:	e7b2      	b.n	31e5a <_strerror_r+0x132>
   31ef4:	4855      	ldr	r0, [pc, #340]	; (3204c <_strerror_r+0x324>)
   31ef6:	e7b0      	b.n	31e5a <_strerror_r+0x132>
   31ef8:	4855      	ldr	r0, [pc, #340]	; (32050 <_strerror_r+0x328>)
   31efa:	e7ae      	b.n	31e5a <_strerror_r+0x132>
   31efc:	4855      	ldr	r0, [pc, #340]	; (32054 <_strerror_r+0x32c>)
   31efe:	e7ac      	b.n	31e5a <_strerror_r+0x132>
   31f00:	4855      	ldr	r0, [pc, #340]	; (32058 <_strerror_r+0x330>)
   31f02:	e7aa      	b.n	31e5a <_strerror_r+0x132>
   31f04:	4855      	ldr	r0, [pc, #340]	; (3205c <_strerror_r+0x334>)
   31f06:	e7a8      	b.n	31e5a <_strerror_r+0x132>
   31f08:	4855      	ldr	r0, [pc, #340]	; (32060 <_strerror_r+0x338>)
   31f0a:	e7a6      	b.n	31e5a <_strerror_r+0x132>
   31f0c:	4855      	ldr	r0, [pc, #340]	; (32064 <_strerror_r+0x33c>)
   31f0e:	e7a4      	b.n	31e5a <_strerror_r+0x132>
   31f10:	4855      	ldr	r0, [pc, #340]	; (32068 <_strerror_r+0x340>)
   31f12:	e7a2      	b.n	31e5a <_strerror_r+0x132>
   31f14:	4855      	ldr	r0, [pc, #340]	; (3206c <_strerror_r+0x344>)
   31f16:	e7a0      	b.n	31e5a <_strerror_r+0x132>
   31f18:	4855      	ldr	r0, [pc, #340]	; (32070 <_strerror_r+0x348>)
   31f1a:	e79e      	b.n	31e5a <_strerror_r+0x132>
   31f1c:	4855      	ldr	r0, [pc, #340]	; (32074 <_strerror_r+0x34c>)
   31f1e:	e79c      	b.n	31e5a <_strerror_r+0x132>
   31f20:	4855      	ldr	r0, [pc, #340]	; (32078 <_strerror_r+0x350>)
   31f22:	e79a      	b.n	31e5a <_strerror_r+0x132>
   31f24:	4855      	ldr	r0, [pc, #340]	; (3207c <_strerror_r+0x354>)
   31f26:	e798      	b.n	31e5a <_strerror_r+0x132>
   31f28:	4855      	ldr	r0, [pc, #340]	; (32080 <_strerror_r+0x358>)
   31f2a:	e796      	b.n	31e5a <_strerror_r+0x132>
   31f2c:	4855      	ldr	r0, [pc, #340]	; (32084 <_strerror_r+0x35c>)
   31f2e:	e794      	b.n	31e5a <_strerror_r+0x132>
   31f30:	4855      	ldr	r0, [pc, #340]	; (32088 <_strerror_r+0x360>)
   31f32:	e792      	b.n	31e5a <_strerror_r+0x132>
   31f34:	4855      	ldr	r0, [pc, #340]	; (3208c <_strerror_r+0x364>)
   31f36:	e790      	b.n	31e5a <_strerror_r+0x132>
   31f38:	4855      	ldr	r0, [pc, #340]	; (32090 <_strerror_r+0x368>)
   31f3a:	e78e      	b.n	31e5a <_strerror_r+0x132>
   31f3c:	4855      	ldr	r0, [pc, #340]	; (32094 <_strerror_r+0x36c>)
   31f3e:	e78c      	b.n	31e5a <_strerror_r+0x132>
   31f40:	4855      	ldr	r0, [pc, #340]	; (32098 <_strerror_r+0x370>)
   31f42:	e78a      	b.n	31e5a <_strerror_r+0x132>
   31f44:	4855      	ldr	r0, [pc, #340]	; (3209c <_strerror_r+0x374>)
   31f46:	e788      	b.n	31e5a <_strerror_r+0x132>
   31f48:	4855      	ldr	r0, [pc, #340]	; (320a0 <_strerror_r+0x378>)
   31f4a:	e786      	b.n	31e5a <_strerror_r+0x132>
   31f4c:	4855      	ldr	r0, [pc, #340]	; (320a4 <_strerror_r+0x37c>)
   31f4e:	e784      	b.n	31e5a <_strerror_r+0x132>
   31f50:	4855      	ldr	r0, [pc, #340]	; (320a8 <_strerror_r+0x380>)
   31f52:	e782      	b.n	31e5a <_strerror_r+0x132>
   31f54:	4855      	ldr	r0, [pc, #340]	; (320ac <_strerror_r+0x384>)
   31f56:	e780      	b.n	31e5a <_strerror_r+0x132>
   31f58:	4855      	ldr	r0, [pc, #340]	; (320b0 <_strerror_r+0x388>)
   31f5a:	e77e      	b.n	31e5a <_strerror_r+0x132>
   31f5c:	4855      	ldr	r0, [pc, #340]	; (320b4 <_strerror_r+0x38c>)
   31f5e:	e77c      	b.n	31e5a <_strerror_r+0x132>
   31f60:	4855      	ldr	r0, [pc, #340]	; (320b8 <_strerror_r+0x390>)
   31f62:	e77a      	b.n	31e5a <_strerror_r+0x132>
   31f64:	4855      	ldr	r0, [pc, #340]	; (320bc <_strerror_r+0x394>)
   31f66:	e778      	b.n	31e5a <_strerror_r+0x132>
   31f68:	4855      	ldr	r0, [pc, #340]	; (320c0 <_strerror_r+0x398>)
   31f6a:	e776      	b.n	31e5a <_strerror_r+0x132>
   31f6c:	4855      	ldr	r0, [pc, #340]	; (320c4 <_strerror_r+0x39c>)
   31f6e:	e774      	b.n	31e5a <_strerror_r+0x132>
   31f70:	4855      	ldr	r0, [pc, #340]	; (320c8 <_strerror_r+0x3a0>)
   31f72:	e772      	b.n	31e5a <_strerror_r+0x132>
   31f74:	4855      	ldr	r0, [pc, #340]	; (320cc <_strerror_r+0x3a4>)
   31f76:	e770      	b.n	31e5a <_strerror_r+0x132>
   31f78:	4855      	ldr	r0, [pc, #340]	; (320d0 <_strerror_r+0x3a8>)
   31f7a:	e76e      	b.n	31e5a <_strerror_r+0x132>
   31f7c:	4855      	ldr	r0, [pc, #340]	; (320d4 <_strerror_r+0x3ac>)
   31f7e:	e76c      	b.n	31e5a <_strerror_r+0x132>
   31f80:	4855      	ldr	r0, [pc, #340]	; (320d8 <_strerror_r+0x3b0>)
   31f82:	e76a      	b.n	31e5a <_strerror_r+0x132>
   31f84:	4855      	ldr	r0, [pc, #340]	; (320dc <_strerror_r+0x3b4>)
   31f86:	e768      	b.n	31e5a <_strerror_r+0x132>
   31f88:	4855      	ldr	r0, [pc, #340]	; (320e0 <_strerror_r+0x3b8>)
   31f8a:	e766      	b.n	31e5a <_strerror_r+0x132>
   31f8c:	4855      	ldr	r0, [pc, #340]	; (320e4 <_strerror_r+0x3bc>)
   31f8e:	e764      	b.n	31e5a <_strerror_r+0x132>
   31f90:	4855      	ldr	r0, [pc, #340]	; (320e8 <_strerror_r+0x3c0>)
   31f92:	e762      	b.n	31e5a <_strerror_r+0x132>
   31f94:	2b00      	cmp	r3, #0
   31f96:	bf14      	ite	ne
   31f98:	461a      	movne	r2, r3
   31f9a:	4622      	moveq	r2, r4
   31f9c:	f007 f9db 	bl	39356 <_user_strerror>
   31fa0:	4b52      	ldr	r3, [pc, #328]	; (320ec <_strerror_r+0x3c4>)
   31fa2:	2800      	cmp	r0, #0
   31fa4:	bf08      	it	eq
   31fa6:	4618      	moveq	r0, r3
   31fa8:	e757      	b.n	31e5a <_strerror_r+0x132>
   31faa:	4851      	ldr	r0, [pc, #324]	; (320f0 <_strerror_r+0x3c8>)
   31fac:	e755      	b.n	31e5a <_strerror_r+0x132>
   31fae:	bf00      	nop
   31fb0:	000402c7 	.word	0x000402c7
   31fb4:	000402d1 	.word	0x000402d1
   31fb8:	000402eb 	.word	0x000402eb
   31fbc:	000402fb 	.word	0x000402fb
   31fc0:	00040313 	.word	0x00040313
   31fc4:	0004031d 	.word	0x0004031d
   31fc8:	00040337 	.word	0x00040337
   31fcc:	00040349 	.word	0x00040349
   31fd0:	0004035b 	.word	0x0004035b
   31fd4:	00040374 	.word	0x00040374
   31fd8:	00040384 	.word	0x00040384
   31fdc:	00040390 	.word	0x00040390
   31fe0:	000403ad 	.word	0x000403ad
   31fe4:	000403bf 	.word	0x000403bf
   31fe8:	000403d0 	.word	0x000403d0
   31fec:	000403e2 	.word	0x000403e2
   31ff0:	000403ee 	.word	0x000403ee
   31ff4:	00040406 	.word	0x00040406
   31ff8:	00040412 	.word	0x00040412
   31ffc:	00040424 	.word	0x00040424
   32000:	00040433 	.word	0x00040433
   32004:	00040443 	.word	0x00040443
   32008:	00040450 	.word	0x00040450
   3200c:	0004046f 	.word	0x0004046f
   32010:	0004047e 	.word	0x0004047e
   32014:	0004048f 	.word	0x0004048f
   32018:	000404b3 	.word	0x000404b3
   3201c:	000404d1 	.word	0x000404d1
   32020:	000404ef 	.word	0x000404ef
   32024:	0004050f 	.word	0x0004050f
   32028:	00040526 	.word	0x00040526
   3202c:	00040535 	.word	0x00040535
   32030:	00040544 	.word	0x00040544
   32034:	00040558 	.word	0x00040558
   32038:	00040570 	.word	0x00040570
   3203c:	0004057e 	.word	0x0004057e
   32040:	0004058b 	.word	0x0004058b
   32044:	000405a1 	.word	0x000405a1
   32048:	000405b0 	.word	0x000405b0
   3204c:	000405bc 	.word	0x000405bc
   32050:	000405eb 	.word	0x000405eb
   32054:	000405fc 	.word	0x000405fc
   32058:	00040617 	.word	0x00040617
   3205c:	0004062a 	.word	0x0004062a
   32060:	00040640 	.word	0x00040640
   32064:	00040649 	.word	0x00040649
   32068:	00040660 	.word	0x00040660
   3206c:	00040668 	.word	0x00040668
   32070:	00040675 	.word	0x00040675
   32074:	0004068a 	.word	0x0004068a
   32078:	0004069e 	.word	0x0004069e
   3207c:	000406b6 	.word	0x000406b6
   32080:	000406c5 	.word	0x000406c5
   32084:	000406d6 	.word	0x000406d6
   32088:	000406e9 	.word	0x000406e9
   3208c:	000406f5 	.word	0x000406f5
   32090:	0004070e 	.word	0x0004070e
   32094:	00040722 	.word	0x00040722
   32098:	0004073d 	.word	0x0004073d
   3209c:	00040755 	.word	0x00040755
   320a0:	0004076f 	.word	0x0004076f
   320a4:	00040777 	.word	0x00040777
   320a8:	000407a7 	.word	0x000407a7
   320ac:	000407c6 	.word	0x000407c6
   320b0:	000407e5 	.word	0x000407e5
   320b4:	000407fc 	.word	0x000407fc
   320b8:	0004080f 	.word	0x0004080f
   320bc:	00040828 	.word	0x00040828
   320c0:	0004083f 	.word	0x0004083f
   320c4:	00040855 	.word	0x00040855
   320c8:	00040876 	.word	0x00040876
   320cc:	0004088e 	.word	0x0004088e
   320d0:	000408aa 	.word	0x000408aa
   320d4:	000408bd 	.word	0x000408bd
   320d8:	000408d3 	.word	0x000408d3
   320dc:	000408e7 	.word	0x000408e7
   320e0:	00040909 	.word	0x00040909
   320e4:	0004092f 	.word	0x0004092f
   320e8:	00040940 	.word	0x00040940
   320ec:	0003c520 	.word	0x0003c520
   320f0:	00040955 	.word	0x00040955

000320f4 <strerror>:
   320f4:	2300      	movs	r3, #0
   320f6:	4601      	mov	r1, r0
   320f8:	4802      	ldr	r0, [pc, #8]	; (32104 <strerror+0x10>)
   320fa:	461a      	mov	r2, r3
   320fc:	6800      	ldr	r0, [r0, #0]
   320fe:	f7ff be13 	b.w	31d28 <_strerror_r>
   32102:	bf00      	nop
   32104:	20020234 	.word	0x20020234

00032108 <_strtol_l.isra.0>:
   32108:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3210c:	4686      	mov	lr, r0
   3210e:	4f39      	ldr	r7, [pc, #228]	; (321f4 <_strtol_l.isra.0+0xec>)
   32110:	4608      	mov	r0, r1
   32112:	4605      	mov	r5, r0
   32114:	f815 4b01 	ldrb.w	r4, [r5], #1
   32118:	5de6      	ldrb	r6, [r4, r7]
   3211a:	f016 0608 	ands.w	r6, r6, #8
   3211e:	d135      	bne.n	3218c <_strtol_l.isra.0+0x84>
   32120:	2c2d      	cmp	r4, #45	; 0x2d
   32122:	d135      	bne.n	32190 <_strtol_l.isra.0+0x88>
   32124:	782c      	ldrb	r4, [r5, #0]
   32126:	f04f 0801 	mov.w	r8, #1
   3212a:	1c85      	adds	r5, r0, #2
   3212c:	2b00      	cmp	r3, #0
   3212e:	d05c      	beq.n	321ea <_strtol_l.isra.0+0xe2>
   32130:	2b10      	cmp	r3, #16
   32132:	d109      	bne.n	32148 <_strtol_l.isra.0+0x40>
   32134:	2c30      	cmp	r4, #48	; 0x30
   32136:	d107      	bne.n	32148 <_strtol_l.isra.0+0x40>
   32138:	7828      	ldrb	r0, [r5, #0]
   3213a:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   3213e:	2858      	cmp	r0, #88	; 0x58
   32140:	d14e      	bne.n	321e0 <_strtol_l.isra.0+0xd8>
   32142:	786c      	ldrb	r4, [r5, #1]
   32144:	2310      	movs	r3, #16
   32146:	3502      	adds	r5, #2
   32148:	f1b8 0f00 	cmp.w	r8, #0
   3214c:	f04f 0700 	mov.w	r7, #0
   32150:	bf14      	ite	ne
   32152:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
   32156:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
   3215a:	4638      	mov	r0, r7
   3215c:	fbbc f9f3 	udiv	r9, ip, r3
   32160:	fb03 ca19 	mls	sl, r3, r9, ip
   32164:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
   32168:	2e09      	cmp	r6, #9
   3216a:	d817      	bhi.n	3219c <_strtol_l.isra.0+0x94>
   3216c:	4634      	mov	r4, r6
   3216e:	42a3      	cmp	r3, r4
   32170:	dd23      	ble.n	321ba <_strtol_l.isra.0+0xb2>
   32172:	1c7e      	adds	r6, r7, #1
   32174:	d007      	beq.n	32186 <_strtol_l.isra.0+0x7e>
   32176:	4581      	cmp	r9, r0
   32178:	d31c      	bcc.n	321b4 <_strtol_l.isra.0+0xac>
   3217a:	d101      	bne.n	32180 <_strtol_l.isra.0+0x78>
   3217c:	45a2      	cmp	sl, r4
   3217e:	db19      	blt.n	321b4 <_strtol_l.isra.0+0xac>
   32180:	fb00 4003 	mla	r0, r0, r3, r4
   32184:	2701      	movs	r7, #1
   32186:	f815 4b01 	ldrb.w	r4, [r5], #1
   3218a:	e7eb      	b.n	32164 <_strtol_l.isra.0+0x5c>
   3218c:	4628      	mov	r0, r5
   3218e:	e7c0      	b.n	32112 <_strtol_l.isra.0+0xa>
   32190:	2c2b      	cmp	r4, #43	; 0x2b
   32192:	46b0      	mov	r8, r6
   32194:	bf04      	itt	eq
   32196:	782c      	ldrbeq	r4, [r5, #0]
   32198:	1c85      	addeq	r5, r0, #2
   3219a:	e7c7      	b.n	3212c <_strtol_l.isra.0+0x24>
   3219c:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
   321a0:	2e19      	cmp	r6, #25
   321a2:	d801      	bhi.n	321a8 <_strtol_l.isra.0+0xa0>
   321a4:	3c37      	subs	r4, #55	; 0x37
   321a6:	e7e2      	b.n	3216e <_strtol_l.isra.0+0x66>
   321a8:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
   321ac:	2e19      	cmp	r6, #25
   321ae:	d804      	bhi.n	321ba <_strtol_l.isra.0+0xb2>
   321b0:	3c57      	subs	r4, #87	; 0x57
   321b2:	e7dc      	b.n	3216e <_strtol_l.isra.0+0x66>
   321b4:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   321b8:	e7e5      	b.n	32186 <_strtol_l.isra.0+0x7e>
   321ba:	1c7b      	adds	r3, r7, #1
   321bc:	d106      	bne.n	321cc <_strtol_l.isra.0+0xc4>
   321be:	2322      	movs	r3, #34	; 0x22
   321c0:	4660      	mov	r0, ip
   321c2:	f8ce 3000 	str.w	r3, [lr]
   321c6:	b942      	cbnz	r2, 321da <_strtol_l.isra.0+0xd2>
   321c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   321cc:	f1b8 0f00 	cmp.w	r8, #0
   321d0:	d000      	beq.n	321d4 <_strtol_l.isra.0+0xcc>
   321d2:	4240      	negs	r0, r0
   321d4:	2a00      	cmp	r2, #0
   321d6:	d0f7      	beq.n	321c8 <_strtol_l.isra.0+0xc0>
   321d8:	b107      	cbz	r7, 321dc <_strtol_l.isra.0+0xd4>
   321da:	1e69      	subs	r1, r5, #1
   321dc:	6011      	str	r1, [r2, #0]
   321de:	e7f3      	b.n	321c8 <_strtol_l.isra.0+0xc0>
   321e0:	2430      	movs	r4, #48	; 0x30
   321e2:	2b00      	cmp	r3, #0
   321e4:	d1b0      	bne.n	32148 <_strtol_l.isra.0+0x40>
   321e6:	2308      	movs	r3, #8
   321e8:	e7ae      	b.n	32148 <_strtol_l.isra.0+0x40>
   321ea:	2c30      	cmp	r4, #48	; 0x30
   321ec:	d0a4      	beq.n	32138 <_strtol_l.isra.0+0x30>
   321ee:	230a      	movs	r3, #10
   321f0:	e7aa      	b.n	32148 <_strtol_l.isra.0+0x40>
   321f2:	bf00      	nop
   321f4:	00040188 	.word	0x00040188

000321f8 <strtol>:
   321f8:	4613      	mov	r3, r2
   321fa:	460a      	mov	r2, r1
   321fc:	4601      	mov	r1, r0
   321fe:	4802      	ldr	r0, [pc, #8]	; (32208 <strtol+0x10>)
   32200:	6800      	ldr	r0, [r0, #0]
   32202:	f7ff bf81 	b.w	32108 <_strtol_l.isra.0>
   32206:	bf00      	nop
   32208:	20020234 	.word	0x20020234

0003220c <_strtoul_l.isra.0>:
   3220c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   32210:	4686      	mov	lr, r0
   32212:	4f37      	ldr	r7, [pc, #220]	; (322f0 <_strtoul_l.isra.0+0xe4>)
   32214:	4608      	mov	r0, r1
   32216:	4605      	mov	r5, r0
   32218:	f815 4b01 	ldrb.w	r4, [r5], #1
   3221c:	5de6      	ldrb	r6, [r4, r7]
   3221e:	f016 0608 	ands.w	r6, r6, #8
   32222:	d131      	bne.n	32288 <_strtoul_l.isra.0+0x7c>
   32224:	2c2d      	cmp	r4, #45	; 0x2d
   32226:	d131      	bne.n	3228c <_strtoul_l.isra.0+0x80>
   32228:	782c      	ldrb	r4, [r5, #0]
   3222a:	f04f 0801 	mov.w	r8, #1
   3222e:	1c85      	adds	r5, r0, #2
   32230:	2b00      	cmp	r3, #0
   32232:	d059      	beq.n	322e8 <_strtoul_l.isra.0+0xdc>
   32234:	2b10      	cmp	r3, #16
   32236:	d109      	bne.n	3224c <_strtoul_l.isra.0+0x40>
   32238:	2c30      	cmp	r4, #48	; 0x30
   3223a:	d107      	bne.n	3224c <_strtoul_l.isra.0+0x40>
   3223c:	7828      	ldrb	r0, [r5, #0]
   3223e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   32242:	2858      	cmp	r0, #88	; 0x58
   32244:	d14b      	bne.n	322de <_strtoul_l.isra.0+0xd2>
   32246:	786c      	ldrb	r4, [r5, #1]
   32248:	2310      	movs	r3, #16
   3224a:	3502      	adds	r5, #2
   3224c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   32250:	2600      	movs	r6, #0
   32252:	fbbc fcf3 	udiv	ip, ip, r3
   32256:	fb03 f90c 	mul.w	r9, r3, ip
   3225a:	4630      	mov	r0, r6
   3225c:	ea6f 0909 	mvn.w	r9, r9
   32260:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
   32264:	2f09      	cmp	r7, #9
   32266:	d817      	bhi.n	32298 <_strtoul_l.isra.0+0x8c>
   32268:	463c      	mov	r4, r7
   3226a:	42a3      	cmp	r3, r4
   3226c:	dd23      	ble.n	322b6 <_strtoul_l.isra.0+0xaa>
   3226e:	2e00      	cmp	r6, #0
   32270:	db1e      	blt.n	322b0 <_strtoul_l.isra.0+0xa4>
   32272:	4584      	cmp	ip, r0
   32274:	d31c      	bcc.n	322b0 <_strtoul_l.isra.0+0xa4>
   32276:	d101      	bne.n	3227c <_strtoul_l.isra.0+0x70>
   32278:	45a1      	cmp	r9, r4
   3227a:	db19      	blt.n	322b0 <_strtoul_l.isra.0+0xa4>
   3227c:	fb00 4003 	mla	r0, r0, r3, r4
   32280:	2601      	movs	r6, #1
   32282:	f815 4b01 	ldrb.w	r4, [r5], #1
   32286:	e7eb      	b.n	32260 <_strtoul_l.isra.0+0x54>
   32288:	4628      	mov	r0, r5
   3228a:	e7c4      	b.n	32216 <_strtoul_l.isra.0+0xa>
   3228c:	2c2b      	cmp	r4, #43	; 0x2b
   3228e:	46b0      	mov	r8, r6
   32290:	bf04      	itt	eq
   32292:	782c      	ldrbeq	r4, [r5, #0]
   32294:	1c85      	addeq	r5, r0, #2
   32296:	e7cb      	b.n	32230 <_strtoul_l.isra.0+0x24>
   32298:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
   3229c:	2f19      	cmp	r7, #25
   3229e:	d801      	bhi.n	322a4 <_strtoul_l.isra.0+0x98>
   322a0:	3c37      	subs	r4, #55	; 0x37
   322a2:	e7e2      	b.n	3226a <_strtoul_l.isra.0+0x5e>
   322a4:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
   322a8:	2f19      	cmp	r7, #25
   322aa:	d804      	bhi.n	322b6 <_strtoul_l.isra.0+0xaa>
   322ac:	3c57      	subs	r4, #87	; 0x57
   322ae:	e7dc      	b.n	3226a <_strtoul_l.isra.0+0x5e>
   322b0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   322b4:	e7e5      	b.n	32282 <_strtoul_l.isra.0+0x76>
   322b6:	2e00      	cmp	r6, #0
   322b8:	da07      	bge.n	322ca <_strtoul_l.isra.0+0xbe>
   322ba:	2322      	movs	r3, #34	; 0x22
   322bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   322c0:	f8ce 3000 	str.w	r3, [lr]
   322c4:	b942      	cbnz	r2, 322d8 <_strtoul_l.isra.0+0xcc>
   322c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   322ca:	f1b8 0f00 	cmp.w	r8, #0
   322ce:	d000      	beq.n	322d2 <_strtoul_l.isra.0+0xc6>
   322d0:	4240      	negs	r0, r0
   322d2:	2a00      	cmp	r2, #0
   322d4:	d0f7      	beq.n	322c6 <_strtoul_l.isra.0+0xba>
   322d6:	b106      	cbz	r6, 322da <_strtoul_l.isra.0+0xce>
   322d8:	1e69      	subs	r1, r5, #1
   322da:	6011      	str	r1, [r2, #0]
   322dc:	e7f3      	b.n	322c6 <_strtoul_l.isra.0+0xba>
   322de:	2430      	movs	r4, #48	; 0x30
   322e0:	2b00      	cmp	r3, #0
   322e2:	d1b3      	bne.n	3224c <_strtoul_l.isra.0+0x40>
   322e4:	2308      	movs	r3, #8
   322e6:	e7b1      	b.n	3224c <_strtoul_l.isra.0+0x40>
   322e8:	2c30      	cmp	r4, #48	; 0x30
   322ea:	d0a7      	beq.n	3223c <_strtoul_l.isra.0+0x30>
   322ec:	230a      	movs	r3, #10
   322ee:	e7ad      	b.n	3224c <_strtoul_l.isra.0+0x40>
   322f0:	00040188 	.word	0x00040188

000322f4 <strtoul>:
   322f4:	4613      	mov	r3, r2
   322f6:	460a      	mov	r2, r1
   322f8:	4601      	mov	r1, r0
   322fa:	4802      	ldr	r0, [pc, #8]	; (32304 <strtoul+0x10>)
   322fc:	6800      	ldr	r0, [r0, #0]
   322fe:	f7ff bf85 	b.w	3220c <_strtoul_l.isra.0>
   32302:	bf00      	nop
   32304:	20020234 	.word	0x20020234

00032308 <__swbuf_r>:
   32308:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   3230a:	460e      	mov	r6, r1
   3230c:	4614      	mov	r4, r2
   3230e:	4605      	mov	r5, r0
   32310:	b118      	cbz	r0, 3231a <__swbuf_r+0x12>
   32312:	6983      	ldr	r3, [r0, #24]
   32314:	b90b      	cbnz	r3, 3231a <__swbuf_r+0x12>
   32316:	f000 f9dd 	bl	326d4 <__sinit>
   3231a:	4b21      	ldr	r3, [pc, #132]	; (323a0 <__swbuf_r+0x98>)
   3231c:	429c      	cmp	r4, r3
   3231e:	d12b      	bne.n	32378 <__swbuf_r+0x70>
   32320:	686c      	ldr	r4, [r5, #4]
   32322:	69a3      	ldr	r3, [r4, #24]
   32324:	60a3      	str	r3, [r4, #8]
   32326:	89a3      	ldrh	r3, [r4, #12]
   32328:	071a      	lsls	r2, r3, #28
   3232a:	d52f      	bpl.n	3238c <__swbuf_r+0x84>
   3232c:	6923      	ldr	r3, [r4, #16]
   3232e:	b36b      	cbz	r3, 3238c <__swbuf_r+0x84>
   32330:	6923      	ldr	r3, [r4, #16]
   32332:	b2f6      	uxtb	r6, r6
   32334:	6820      	ldr	r0, [r4, #0]
   32336:	4637      	mov	r7, r6
   32338:	1ac0      	subs	r0, r0, r3
   3233a:	6963      	ldr	r3, [r4, #20]
   3233c:	4283      	cmp	r3, r0
   3233e:	dc04      	bgt.n	3234a <__swbuf_r+0x42>
   32340:	4621      	mov	r1, r4
   32342:	4628      	mov	r0, r5
   32344:	f000 f948 	bl	325d8 <_fflush_r>
   32348:	bb30      	cbnz	r0, 32398 <__swbuf_r+0x90>
   3234a:	68a3      	ldr	r3, [r4, #8]
   3234c:	3001      	adds	r0, #1
   3234e:	3b01      	subs	r3, #1
   32350:	60a3      	str	r3, [r4, #8]
   32352:	6823      	ldr	r3, [r4, #0]
   32354:	1c5a      	adds	r2, r3, #1
   32356:	6022      	str	r2, [r4, #0]
   32358:	701e      	strb	r6, [r3, #0]
   3235a:	6963      	ldr	r3, [r4, #20]
   3235c:	4283      	cmp	r3, r0
   3235e:	d004      	beq.n	3236a <__swbuf_r+0x62>
   32360:	89a3      	ldrh	r3, [r4, #12]
   32362:	07db      	lsls	r3, r3, #31
   32364:	d506      	bpl.n	32374 <__swbuf_r+0x6c>
   32366:	2e0a      	cmp	r6, #10
   32368:	d104      	bne.n	32374 <__swbuf_r+0x6c>
   3236a:	4621      	mov	r1, r4
   3236c:	4628      	mov	r0, r5
   3236e:	f000 f933 	bl	325d8 <_fflush_r>
   32372:	b988      	cbnz	r0, 32398 <__swbuf_r+0x90>
   32374:	4638      	mov	r0, r7
   32376:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32378:	4b0a      	ldr	r3, [pc, #40]	; (323a4 <__swbuf_r+0x9c>)
   3237a:	429c      	cmp	r4, r3
   3237c:	d101      	bne.n	32382 <__swbuf_r+0x7a>
   3237e:	68ac      	ldr	r4, [r5, #8]
   32380:	e7cf      	b.n	32322 <__swbuf_r+0x1a>
   32382:	4b09      	ldr	r3, [pc, #36]	; (323a8 <__swbuf_r+0xa0>)
   32384:	429c      	cmp	r4, r3
   32386:	bf08      	it	eq
   32388:	68ec      	ldreq	r4, [r5, #12]
   3238a:	e7ca      	b.n	32322 <__swbuf_r+0x1a>
   3238c:	4621      	mov	r1, r4
   3238e:	4628      	mov	r0, r5
   32390:	f000 f80c 	bl	323ac <__swsetup_r>
   32394:	2800      	cmp	r0, #0
   32396:	d0cb      	beq.n	32330 <__swbuf_r+0x28>
   32398:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   3239c:	e7ea      	b.n	32374 <__swbuf_r+0x6c>
   3239e:	bf00      	nop
   323a0:	0003b3a4 	.word	0x0003b3a4
   323a4:	0003b3c4 	.word	0x0003b3c4
   323a8:	0003b384 	.word	0x0003b384

000323ac <__swsetup_r>:
   323ac:	4b32      	ldr	r3, [pc, #200]	; (32478 <__swsetup_r+0xcc>)
   323ae:	b570      	push	{r4, r5, r6, lr}
   323b0:	681d      	ldr	r5, [r3, #0]
   323b2:	4606      	mov	r6, r0
   323b4:	460c      	mov	r4, r1
   323b6:	b125      	cbz	r5, 323c2 <__swsetup_r+0x16>
   323b8:	69ab      	ldr	r3, [r5, #24]
   323ba:	b913      	cbnz	r3, 323c2 <__swsetup_r+0x16>
   323bc:	4628      	mov	r0, r5
   323be:	f000 f989 	bl	326d4 <__sinit>
   323c2:	4b2e      	ldr	r3, [pc, #184]	; (3247c <__swsetup_r+0xd0>)
   323c4:	429c      	cmp	r4, r3
   323c6:	d10f      	bne.n	323e8 <__swsetup_r+0x3c>
   323c8:	686c      	ldr	r4, [r5, #4]
   323ca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   323ce:	b29a      	uxth	r2, r3
   323d0:	0715      	lsls	r5, r2, #28
   323d2:	d42c      	bmi.n	3242e <__swsetup_r+0x82>
   323d4:	06d0      	lsls	r0, r2, #27
   323d6:	d411      	bmi.n	323fc <__swsetup_r+0x50>
   323d8:	2209      	movs	r2, #9
   323da:	6032      	str	r2, [r6, #0]
   323dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   323e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   323e4:	81a3      	strh	r3, [r4, #12]
   323e6:	e03e      	b.n	32466 <__swsetup_r+0xba>
   323e8:	4b25      	ldr	r3, [pc, #148]	; (32480 <__swsetup_r+0xd4>)
   323ea:	429c      	cmp	r4, r3
   323ec:	d101      	bne.n	323f2 <__swsetup_r+0x46>
   323ee:	68ac      	ldr	r4, [r5, #8]
   323f0:	e7eb      	b.n	323ca <__swsetup_r+0x1e>
   323f2:	4b24      	ldr	r3, [pc, #144]	; (32484 <__swsetup_r+0xd8>)
   323f4:	429c      	cmp	r4, r3
   323f6:	bf08      	it	eq
   323f8:	68ec      	ldreq	r4, [r5, #12]
   323fa:	e7e6      	b.n	323ca <__swsetup_r+0x1e>
   323fc:	0751      	lsls	r1, r2, #29
   323fe:	d512      	bpl.n	32426 <__swsetup_r+0x7a>
   32400:	6b61      	ldr	r1, [r4, #52]	; 0x34
   32402:	b141      	cbz	r1, 32416 <__swsetup_r+0x6a>
   32404:	f104 0344 	add.w	r3, r4, #68	; 0x44
   32408:	4299      	cmp	r1, r3
   3240a:	d002      	beq.n	32412 <__swsetup_r+0x66>
   3240c:	4630      	mov	r0, r6
   3240e:	f7fe ff19 	bl	31244 <_free_r>
   32412:	2300      	movs	r3, #0
   32414:	6363      	str	r3, [r4, #52]	; 0x34
   32416:	89a3      	ldrh	r3, [r4, #12]
   32418:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   3241c:	81a3      	strh	r3, [r4, #12]
   3241e:	2300      	movs	r3, #0
   32420:	6063      	str	r3, [r4, #4]
   32422:	6923      	ldr	r3, [r4, #16]
   32424:	6023      	str	r3, [r4, #0]
   32426:	89a3      	ldrh	r3, [r4, #12]
   32428:	f043 0308 	orr.w	r3, r3, #8
   3242c:	81a3      	strh	r3, [r4, #12]
   3242e:	6923      	ldr	r3, [r4, #16]
   32430:	b94b      	cbnz	r3, 32446 <__swsetup_r+0x9a>
   32432:	89a3      	ldrh	r3, [r4, #12]
   32434:	f403 7320 	and.w	r3, r3, #640	; 0x280
   32438:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   3243c:	d003      	beq.n	32446 <__swsetup_r+0x9a>
   3243e:	4621      	mov	r1, r4
   32440:	4630      	mov	r0, r6
   32442:	f000 f9c9 	bl	327d8 <__smakebuf_r>
   32446:	89a2      	ldrh	r2, [r4, #12]
   32448:	f012 0301 	ands.w	r3, r2, #1
   3244c:	d00c      	beq.n	32468 <__swsetup_r+0xbc>
   3244e:	2300      	movs	r3, #0
   32450:	60a3      	str	r3, [r4, #8]
   32452:	6963      	ldr	r3, [r4, #20]
   32454:	425b      	negs	r3, r3
   32456:	61a3      	str	r3, [r4, #24]
   32458:	6923      	ldr	r3, [r4, #16]
   3245a:	b953      	cbnz	r3, 32472 <__swsetup_r+0xc6>
   3245c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   32460:	f013 0080 	ands.w	r0, r3, #128	; 0x80
   32464:	d1ba      	bne.n	323dc <__swsetup_r+0x30>
   32466:	bd70      	pop	{r4, r5, r6, pc}
   32468:	0792      	lsls	r2, r2, #30
   3246a:	bf58      	it	pl
   3246c:	6963      	ldrpl	r3, [r4, #20]
   3246e:	60a3      	str	r3, [r4, #8]
   32470:	e7f2      	b.n	32458 <__swsetup_r+0xac>
   32472:	2000      	movs	r0, #0
   32474:	e7f7      	b.n	32466 <__swsetup_r+0xba>
   32476:	bf00      	nop
   32478:	20020234 	.word	0x20020234
   3247c:	0003b3a4 	.word	0x0003b3a4
   32480:	0003b3c4 	.word	0x0003b3c4
   32484:	0003b384 	.word	0x0003b384

00032488 <__chk_fail>:
   32488:	b500      	push	{lr}
   3248a:	b08d      	sub	sp, #52	; 0x34
   3248c:	4b0f      	ldr	r3, [pc, #60]	; (324cc <__chk_fail+0x44>)
   3248e:	466a      	mov	r2, sp
   32490:	f103 0628 	add.w	r6, r3, #40	; 0x28
   32494:	4615      	mov	r5, r2
   32496:	6818      	ldr	r0, [r3, #0]
   32498:	3308      	adds	r3, #8
   3249a:	f853 1c04 	ldr.w	r1, [r3, #-4]
   3249e:	4614      	mov	r4, r2
   324a0:	42b3      	cmp	r3, r6
   324a2:	c403      	stmia	r4!, {r0, r1}
   324a4:	4622      	mov	r2, r4
   324a6:	d1f6      	bne.n	32496 <__chk_fail+0xe>
   324a8:	6818      	ldr	r0, [r3, #0]
   324aa:	889b      	ldrh	r3, [r3, #4]
   324ac:	6020      	str	r0, [r4, #0]
   324ae:	4628      	mov	r0, r5
   324b0:	80a3      	strh	r3, [r4, #4]
   324b2:	f7df fde5 	bl	12080 <strlen>
   324b6:	4629      	mov	r1, r5
   324b8:	4602      	mov	r2, r0
   324ba:	2002      	movs	r0, #2
   324bc:	f003 f800 	bl	354c0 <_write>
   324c0:	2006      	movs	r0, #6
   324c2:	f000 fb1b 	bl	32afc <raise>
   324c6:	207f      	movs	r0, #127	; 0x7f
   324c8:	f7e9 fae0 	bl	1ba8c <_exit>
   324cc:	0004095d 	.word	0x0004095d

000324d0 <__sflush_r>:
   324d0:	898a      	ldrh	r2, [r1, #12]
   324d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   324d6:	4605      	mov	r5, r0
   324d8:	0710      	lsls	r0, r2, #28
   324da:	460c      	mov	r4, r1
   324dc:	d458      	bmi.n	32590 <__sflush_r+0xc0>
   324de:	684b      	ldr	r3, [r1, #4]
   324e0:	2b00      	cmp	r3, #0
   324e2:	dc05      	bgt.n	324f0 <__sflush_r+0x20>
   324e4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   324e6:	2b00      	cmp	r3, #0
   324e8:	dc02      	bgt.n	324f0 <__sflush_r+0x20>
   324ea:	2000      	movs	r0, #0
   324ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   324f0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   324f2:	2e00      	cmp	r6, #0
   324f4:	d0f9      	beq.n	324ea <__sflush_r+0x1a>
   324f6:	2300      	movs	r3, #0
   324f8:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   324fc:	682f      	ldr	r7, [r5, #0]
   324fe:	602b      	str	r3, [r5, #0]
   32500:	d032      	beq.n	32568 <__sflush_r+0x98>
   32502:	6d60      	ldr	r0, [r4, #84]	; 0x54
   32504:	89a3      	ldrh	r3, [r4, #12]
   32506:	075a      	lsls	r2, r3, #29
   32508:	d505      	bpl.n	32516 <__sflush_r+0x46>
   3250a:	6863      	ldr	r3, [r4, #4]
   3250c:	1ac0      	subs	r0, r0, r3
   3250e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   32510:	b10b      	cbz	r3, 32516 <__sflush_r+0x46>
   32512:	6c23      	ldr	r3, [r4, #64]	; 0x40
   32514:	1ac0      	subs	r0, r0, r3
   32516:	2300      	movs	r3, #0
   32518:	4602      	mov	r2, r0
   3251a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   3251c:	4628      	mov	r0, r5
   3251e:	6a21      	ldr	r1, [r4, #32]
   32520:	47b0      	blx	r6
   32522:	1c43      	adds	r3, r0, #1
   32524:	89a3      	ldrh	r3, [r4, #12]
   32526:	d106      	bne.n	32536 <__sflush_r+0x66>
   32528:	6829      	ldr	r1, [r5, #0]
   3252a:	291d      	cmp	r1, #29
   3252c:	d82c      	bhi.n	32588 <__sflush_r+0xb8>
   3252e:	4a29      	ldr	r2, [pc, #164]	; (325d4 <__sflush_r+0x104>)
   32530:	40ca      	lsrs	r2, r1
   32532:	07d6      	lsls	r6, r2, #31
   32534:	d528      	bpl.n	32588 <__sflush_r+0xb8>
   32536:	2200      	movs	r2, #0
   32538:	04d9      	lsls	r1, r3, #19
   3253a:	6062      	str	r2, [r4, #4]
   3253c:	6922      	ldr	r2, [r4, #16]
   3253e:	6022      	str	r2, [r4, #0]
   32540:	d504      	bpl.n	3254c <__sflush_r+0x7c>
   32542:	1c42      	adds	r2, r0, #1
   32544:	d101      	bne.n	3254a <__sflush_r+0x7a>
   32546:	682b      	ldr	r3, [r5, #0]
   32548:	b903      	cbnz	r3, 3254c <__sflush_r+0x7c>
   3254a:	6560      	str	r0, [r4, #84]	; 0x54
   3254c:	6b61      	ldr	r1, [r4, #52]	; 0x34
   3254e:	602f      	str	r7, [r5, #0]
   32550:	2900      	cmp	r1, #0
   32552:	d0ca      	beq.n	324ea <__sflush_r+0x1a>
   32554:	f104 0344 	add.w	r3, r4, #68	; 0x44
   32558:	4299      	cmp	r1, r3
   3255a:	d002      	beq.n	32562 <__sflush_r+0x92>
   3255c:	4628      	mov	r0, r5
   3255e:	f7fe fe71 	bl	31244 <_free_r>
   32562:	2000      	movs	r0, #0
   32564:	6360      	str	r0, [r4, #52]	; 0x34
   32566:	e7c1      	b.n	324ec <__sflush_r+0x1c>
   32568:	6a21      	ldr	r1, [r4, #32]
   3256a:	2301      	movs	r3, #1
   3256c:	4628      	mov	r0, r5
   3256e:	47b0      	blx	r6
   32570:	1c41      	adds	r1, r0, #1
   32572:	d1c7      	bne.n	32504 <__sflush_r+0x34>
   32574:	682b      	ldr	r3, [r5, #0]
   32576:	2b00      	cmp	r3, #0
   32578:	d0c4      	beq.n	32504 <__sflush_r+0x34>
   3257a:	2b1d      	cmp	r3, #29
   3257c:	d001      	beq.n	32582 <__sflush_r+0xb2>
   3257e:	2b16      	cmp	r3, #22
   32580:	d101      	bne.n	32586 <__sflush_r+0xb6>
   32582:	602f      	str	r7, [r5, #0]
   32584:	e7b1      	b.n	324ea <__sflush_r+0x1a>
   32586:	89a3      	ldrh	r3, [r4, #12]
   32588:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   3258c:	81a3      	strh	r3, [r4, #12]
   3258e:	e7ad      	b.n	324ec <__sflush_r+0x1c>
   32590:	690f      	ldr	r7, [r1, #16]
   32592:	2f00      	cmp	r7, #0
   32594:	d0a9      	beq.n	324ea <__sflush_r+0x1a>
   32596:	0793      	lsls	r3, r2, #30
   32598:	680e      	ldr	r6, [r1, #0]
   3259a:	600f      	str	r7, [r1, #0]
   3259c:	bf0c      	ite	eq
   3259e:	694b      	ldreq	r3, [r1, #20]
   325a0:	2300      	movne	r3, #0
   325a2:	eba6 0807 	sub.w	r8, r6, r7
   325a6:	608b      	str	r3, [r1, #8]
   325a8:	f1b8 0f00 	cmp.w	r8, #0
   325ac:	dd9d      	ble.n	324ea <__sflush_r+0x1a>
   325ae:	4643      	mov	r3, r8
   325b0:	463a      	mov	r2, r7
   325b2:	6a21      	ldr	r1, [r4, #32]
   325b4:	4628      	mov	r0, r5
   325b6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   325b8:	47b0      	blx	r6
   325ba:	2800      	cmp	r0, #0
   325bc:	dc06      	bgt.n	325cc <__sflush_r+0xfc>
   325be:	89a3      	ldrh	r3, [r4, #12]
   325c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   325c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   325c8:	81a3      	strh	r3, [r4, #12]
   325ca:	e78f      	b.n	324ec <__sflush_r+0x1c>
   325cc:	4407      	add	r7, r0
   325ce:	eba8 0800 	sub.w	r8, r8, r0
   325d2:	e7e9      	b.n	325a8 <__sflush_r+0xd8>
   325d4:	20400001 	.word	0x20400001

000325d8 <_fflush_r>:
   325d8:	b538      	push	{r3, r4, r5, lr}
   325da:	690b      	ldr	r3, [r1, #16]
   325dc:	4605      	mov	r5, r0
   325de:	460c      	mov	r4, r1
   325e0:	b913      	cbnz	r3, 325e8 <_fflush_r+0x10>
   325e2:	2500      	movs	r5, #0
   325e4:	4628      	mov	r0, r5
   325e6:	bd38      	pop	{r3, r4, r5, pc}
   325e8:	b118      	cbz	r0, 325f2 <_fflush_r+0x1a>
   325ea:	6983      	ldr	r3, [r0, #24]
   325ec:	b90b      	cbnz	r3, 325f2 <_fflush_r+0x1a>
   325ee:	f000 f871 	bl	326d4 <__sinit>
   325f2:	4b14      	ldr	r3, [pc, #80]	; (32644 <_fflush_r+0x6c>)
   325f4:	429c      	cmp	r4, r3
   325f6:	d11b      	bne.n	32630 <_fflush_r+0x58>
   325f8:	686c      	ldr	r4, [r5, #4]
   325fa:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   325fe:	2b00      	cmp	r3, #0
   32600:	d0ef      	beq.n	325e2 <_fflush_r+0xa>
   32602:	6e62      	ldr	r2, [r4, #100]	; 0x64
   32604:	07d0      	lsls	r0, r2, #31
   32606:	d404      	bmi.n	32612 <_fflush_r+0x3a>
   32608:	0599      	lsls	r1, r3, #22
   3260a:	d402      	bmi.n	32612 <_fflush_r+0x3a>
   3260c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   3260e:	f006 ff6e 	bl	394ee <__retarget_lock_acquire_recursive>
   32612:	4628      	mov	r0, r5
   32614:	4621      	mov	r1, r4
   32616:	f7ff ff5b 	bl	324d0 <__sflush_r>
   3261a:	6e63      	ldr	r3, [r4, #100]	; 0x64
   3261c:	4605      	mov	r5, r0
   3261e:	07da      	lsls	r2, r3, #31
   32620:	d4e0      	bmi.n	325e4 <_fflush_r+0xc>
   32622:	89a3      	ldrh	r3, [r4, #12]
   32624:	059b      	lsls	r3, r3, #22
   32626:	d4dd      	bmi.n	325e4 <_fflush_r+0xc>
   32628:	6da0      	ldr	r0, [r4, #88]	; 0x58
   3262a:	f006 ff61 	bl	394f0 <__retarget_lock_release_recursive>
   3262e:	e7d9      	b.n	325e4 <_fflush_r+0xc>
   32630:	4b05      	ldr	r3, [pc, #20]	; (32648 <_fflush_r+0x70>)
   32632:	429c      	cmp	r4, r3
   32634:	d101      	bne.n	3263a <_fflush_r+0x62>
   32636:	68ac      	ldr	r4, [r5, #8]
   32638:	e7df      	b.n	325fa <_fflush_r+0x22>
   3263a:	4b04      	ldr	r3, [pc, #16]	; (3264c <_fflush_r+0x74>)
   3263c:	429c      	cmp	r4, r3
   3263e:	bf08      	it	eq
   32640:	68ec      	ldreq	r4, [r5, #12]
   32642:	e7da      	b.n	325fa <_fflush_r+0x22>
   32644:	0003b3a4 	.word	0x0003b3a4
   32648:	0003b3c4 	.word	0x0003b3c4
   3264c:	0003b384 	.word	0x0003b384

00032650 <std>:
   32650:	2300      	movs	r3, #0
   32652:	b510      	push	{r4, lr}
   32654:	4604      	mov	r4, r0
   32656:	6083      	str	r3, [r0, #8]
   32658:	8181      	strh	r1, [r0, #12]
   3265a:	4619      	mov	r1, r3
   3265c:	6643      	str	r3, [r0, #100]	; 0x64
   3265e:	81c2      	strh	r2, [r0, #14]
   32660:	2208      	movs	r2, #8
   32662:	6183      	str	r3, [r0, #24]
   32664:	e9c0 3300 	strd	r3, r3, [r0]
   32668:	e9c0 3304 	strd	r3, r3, [r0, #16]
   3266c:	305c      	adds	r0, #92	; 0x5c
   3266e:	f006 fced 	bl	3904c <memset>
   32672:	4b05      	ldr	r3, [pc, #20]	; (32688 <std+0x38>)
   32674:	6224      	str	r4, [r4, #32]
   32676:	6263      	str	r3, [r4, #36]	; 0x24
   32678:	4b04      	ldr	r3, [pc, #16]	; (3268c <std+0x3c>)
   3267a:	62a3      	str	r3, [r4, #40]	; 0x28
   3267c:	4b04      	ldr	r3, [pc, #16]	; (32690 <std+0x40>)
   3267e:	62e3      	str	r3, [r4, #44]	; 0x2c
   32680:	4b04      	ldr	r3, [pc, #16]	; (32694 <std+0x44>)
   32682:	6323      	str	r3, [r4, #48]	; 0x30
   32684:	bd10      	pop	{r4, pc}
   32686:	bf00      	nop
   32688:	00039ba7 	.word	0x00039ba7
   3268c:	00039bc9 	.word	0x00039bc9
   32690:	00039c01 	.word	0x00039c01
   32694:	00039c25 	.word	0x00039c25

00032698 <_cleanup_r>:
   32698:	4901      	ldr	r1, [pc, #4]	; (326a0 <_cleanup_r+0x8>)
   3269a:	f006 bf09 	b.w	394b0 <_fwalk_reent>
   3269e:	bf00      	nop
   326a0:	000325d9 	.word	0x000325d9

000326a4 <__sfp_lock_acquire>:
   326a4:	4801      	ldr	r0, [pc, #4]	; (326ac <__sfp_lock_acquire+0x8>)
   326a6:	f006 bf22 	b.w	394ee <__retarget_lock_acquire_recursive>
   326aa:	bf00      	nop
   326ac:	20029204 	.word	0x20029204

000326b0 <__sfp_lock_release>:
   326b0:	4801      	ldr	r0, [pc, #4]	; (326b8 <__sfp_lock_release+0x8>)
   326b2:	f006 bf1d 	b.w	394f0 <__retarget_lock_release_recursive>
   326b6:	bf00      	nop
   326b8:	20029204 	.word	0x20029204

000326bc <__sinit_lock_acquire>:
   326bc:	4801      	ldr	r0, [pc, #4]	; (326c4 <__sinit_lock_acquire+0x8>)
   326be:	f006 bf16 	b.w	394ee <__retarget_lock_acquire_recursive>
   326c2:	bf00      	nop
   326c4:	200291ff 	.word	0x200291ff

000326c8 <__sinit_lock_release>:
   326c8:	4801      	ldr	r0, [pc, #4]	; (326d0 <__sinit_lock_release+0x8>)
   326ca:	f006 bf11 	b.w	394f0 <__retarget_lock_release_recursive>
   326ce:	bf00      	nop
   326d0:	200291ff 	.word	0x200291ff

000326d4 <__sinit>:
   326d4:	b510      	push	{r4, lr}
   326d6:	4604      	mov	r4, r0
   326d8:	f7ff fff0 	bl	326bc <__sinit_lock_acquire>
   326dc:	69a3      	ldr	r3, [r4, #24]
   326de:	b11b      	cbz	r3, 326e8 <__sinit+0x14>
   326e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   326e4:	f7ff bff0 	b.w	326c8 <__sinit_lock_release>
   326e8:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   326ec:	6523      	str	r3, [r4, #80]	; 0x50
   326ee:	4620      	mov	r0, r4
   326f0:	4b12      	ldr	r3, [pc, #72]	; (3273c <__sinit+0x68>)
   326f2:	4a13      	ldr	r2, [pc, #76]	; (32740 <__sinit+0x6c>)
   326f4:	681b      	ldr	r3, [r3, #0]
   326f6:	62a2      	str	r2, [r4, #40]	; 0x28
   326f8:	42a3      	cmp	r3, r4
   326fa:	bf04      	itt	eq
   326fc:	2301      	moveq	r3, #1
   326fe:	61a3      	streq	r3, [r4, #24]
   32700:	f000 f820 	bl	32744 <__sfp>
   32704:	6060      	str	r0, [r4, #4]
   32706:	4620      	mov	r0, r4
   32708:	f000 f81c 	bl	32744 <__sfp>
   3270c:	60a0      	str	r0, [r4, #8]
   3270e:	4620      	mov	r0, r4
   32710:	f000 f818 	bl	32744 <__sfp>
   32714:	2200      	movs	r2, #0
   32716:	60e0      	str	r0, [r4, #12]
   32718:	2104      	movs	r1, #4
   3271a:	6860      	ldr	r0, [r4, #4]
   3271c:	f7ff ff98 	bl	32650 <std>
   32720:	2201      	movs	r2, #1
   32722:	2109      	movs	r1, #9
   32724:	68a0      	ldr	r0, [r4, #8]
   32726:	f7ff ff93 	bl	32650 <std>
   3272a:	2202      	movs	r2, #2
   3272c:	2112      	movs	r1, #18
   3272e:	68e0      	ldr	r0, [r4, #12]
   32730:	f7ff ff8e 	bl	32650 <std>
   32734:	2301      	movs	r3, #1
   32736:	61a3      	str	r3, [r4, #24]
   32738:	e7d2      	b.n	326e0 <__sinit+0xc>
   3273a:	bf00      	nop
   3273c:	0003b380 	.word	0x0003b380
   32740:	00032699 	.word	0x00032699

00032744 <__sfp>:
   32744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   32746:	4607      	mov	r7, r0
   32748:	f7ff ffac 	bl	326a4 <__sfp_lock_acquire>
   3274c:	4b1e      	ldr	r3, [pc, #120]	; (327c8 <__sfp+0x84>)
   3274e:	681e      	ldr	r6, [r3, #0]
   32750:	69b3      	ldr	r3, [r6, #24]
   32752:	b913      	cbnz	r3, 3275a <__sfp+0x16>
   32754:	4630      	mov	r0, r6
   32756:	f7ff ffbd 	bl	326d4 <__sinit>
   3275a:	3648      	adds	r6, #72	; 0x48
   3275c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   32760:	3b01      	subs	r3, #1
   32762:	d503      	bpl.n	3276c <__sfp+0x28>
   32764:	6833      	ldr	r3, [r6, #0]
   32766:	b30b      	cbz	r3, 327ac <__sfp+0x68>
   32768:	6836      	ldr	r6, [r6, #0]
   3276a:	e7f7      	b.n	3275c <__sfp+0x18>
   3276c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   32770:	b9d5      	cbnz	r5, 327a8 <__sfp+0x64>
   32772:	4b16      	ldr	r3, [pc, #88]	; (327cc <__sfp+0x88>)
   32774:	f104 0058 	add.w	r0, r4, #88	; 0x58
   32778:	6665      	str	r5, [r4, #100]	; 0x64
   3277a:	60e3      	str	r3, [r4, #12]
   3277c:	f006 feb6 	bl	394ec <__retarget_lock_init_recursive>
   32780:	f7ff ff96 	bl	326b0 <__sfp_lock_release>
   32784:	6025      	str	r5, [r4, #0]
   32786:	61a5      	str	r5, [r4, #24]
   32788:	2208      	movs	r2, #8
   3278a:	4629      	mov	r1, r5
   3278c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   32790:	e9c4 5501 	strd	r5, r5, [r4, #4]
   32794:	e9c4 5504 	strd	r5, r5, [r4, #16]
   32798:	f006 fc58 	bl	3904c <memset>
   3279c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   327a0:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   327a4:	4620      	mov	r0, r4
   327a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   327a8:	3468      	adds	r4, #104	; 0x68
   327aa:	e7d9      	b.n	32760 <__sfp+0x1c>
   327ac:	2104      	movs	r1, #4
   327ae:	4638      	mov	r0, r7
   327b0:	f006 fe68 	bl	39484 <__sfmoreglue>
   327b4:	4604      	mov	r4, r0
   327b6:	6030      	str	r0, [r6, #0]
   327b8:	2800      	cmp	r0, #0
   327ba:	d1d5      	bne.n	32768 <__sfp+0x24>
   327bc:	f7ff ff78 	bl	326b0 <__sfp_lock_release>
   327c0:	230c      	movs	r3, #12
   327c2:	603b      	str	r3, [r7, #0]
   327c4:	e7ee      	b.n	327a4 <__sfp+0x60>
   327c6:	bf00      	nop
   327c8:	0003b380 	.word	0x0003b380
   327cc:	ffff0001 	.word	0xffff0001

000327d0 <_localeconv_r>:
   327d0:	4800      	ldr	r0, [pc, #0]	; (327d4 <_localeconv_r+0x4>)
   327d2:	4770      	bx	lr
   327d4:	20020388 	.word	0x20020388

000327d8 <__smakebuf_r>:
   327d8:	898b      	ldrh	r3, [r1, #12]
   327da:	b573      	push	{r0, r1, r4, r5, r6, lr}
   327dc:	079d      	lsls	r5, r3, #30
   327de:	4606      	mov	r6, r0
   327e0:	460c      	mov	r4, r1
   327e2:	d507      	bpl.n	327f4 <__smakebuf_r+0x1c>
   327e4:	f104 0347 	add.w	r3, r4, #71	; 0x47
   327e8:	6023      	str	r3, [r4, #0]
   327ea:	6123      	str	r3, [r4, #16]
   327ec:	2301      	movs	r3, #1
   327ee:	6163      	str	r3, [r4, #20]
   327f0:	b002      	add	sp, #8
   327f2:	bd70      	pop	{r4, r5, r6, pc}
   327f4:	ab01      	add	r3, sp, #4
   327f6:	466a      	mov	r2, sp
   327f8:	f006 fe7b 	bl	394f2 <__swhatbuf_r>
   327fc:	9900      	ldr	r1, [sp, #0]
   327fe:	4605      	mov	r5, r0
   32800:	4630      	mov	r0, r6
   32802:	f7fe fd6d 	bl	312e0 <_malloc_r>
   32806:	b948      	cbnz	r0, 3281c <__smakebuf_r+0x44>
   32808:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   3280c:	059a      	lsls	r2, r3, #22
   3280e:	d4ef      	bmi.n	327f0 <__smakebuf_r+0x18>
   32810:	f023 0303 	bic.w	r3, r3, #3
   32814:	f043 0302 	orr.w	r3, r3, #2
   32818:	81a3      	strh	r3, [r4, #12]
   3281a:	e7e3      	b.n	327e4 <__smakebuf_r+0xc>
   3281c:	4b0d      	ldr	r3, [pc, #52]	; (32854 <__smakebuf_r+0x7c>)
   3281e:	62b3      	str	r3, [r6, #40]	; 0x28
   32820:	89a3      	ldrh	r3, [r4, #12]
   32822:	6020      	str	r0, [r4, #0]
   32824:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   32828:	6120      	str	r0, [r4, #16]
   3282a:	81a3      	strh	r3, [r4, #12]
   3282c:	9b00      	ldr	r3, [sp, #0]
   3282e:	6163      	str	r3, [r4, #20]
   32830:	9b01      	ldr	r3, [sp, #4]
   32832:	b15b      	cbz	r3, 3284c <__smakebuf_r+0x74>
   32834:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   32838:	4630      	mov	r0, r6
   3283a:	f000 f9ad 	bl	32b98 <_isatty_r>
   3283e:	b128      	cbz	r0, 3284c <__smakebuf_r+0x74>
   32840:	89a3      	ldrh	r3, [r4, #12]
   32842:	f023 0303 	bic.w	r3, r3, #3
   32846:	f043 0301 	orr.w	r3, r3, #1
   3284a:	81a3      	strh	r3, [r4, #12]
   3284c:	89a3      	ldrh	r3, [r4, #12]
   3284e:	431d      	orrs	r5, r3
   32850:	81a5      	strh	r5, [r4, #12]
   32852:	e7cd      	b.n	327f0 <__smakebuf_r+0x18>
   32854:	00032699 	.word	0x00032699

00032858 <__malloc_lock>:
   32858:	4801      	ldr	r0, [pc, #4]	; (32860 <__malloc_lock+0x8>)
   3285a:	f006 be48 	b.w	394ee <__retarget_lock_acquire_recursive>
   3285e:	bf00      	nop
   32860:	20029200 	.word	0x20029200

00032864 <__malloc_unlock>:
   32864:	4801      	ldr	r0, [pc, #4]	; (3286c <__malloc_unlock+0x8>)
   32866:	f006 be43 	b.w	394f0 <__retarget_lock_release_recursive>
   3286a:	bf00      	nop
   3286c:	20029200 	.word	0x20029200

00032870 <__pow5mult>:
   32870:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   32874:	4615      	mov	r5, r2
   32876:	f012 0203 	ands.w	r2, r2, #3
   3287a:	4606      	mov	r6, r0
   3287c:	460f      	mov	r7, r1
   3287e:	d007      	beq.n	32890 <__pow5mult+0x20>
   32880:	3a01      	subs	r2, #1
   32882:	4c21      	ldr	r4, [pc, #132]	; (32908 <__pow5mult+0x98>)
   32884:	2300      	movs	r3, #0
   32886:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
   3288a:	f006 fea1 	bl	395d0 <__multadd>
   3288e:	4607      	mov	r7, r0
   32890:	10ad      	asrs	r5, r5, #2
   32892:	d035      	beq.n	32900 <__pow5mult+0x90>
   32894:	6a74      	ldr	r4, [r6, #36]	; 0x24
   32896:	b93c      	cbnz	r4, 328a8 <__pow5mult+0x38>
   32898:	2010      	movs	r0, #16
   3289a:	f7fe fcc3 	bl	31224 <malloc>
   3289e:	6270      	str	r0, [r6, #36]	; 0x24
   328a0:	6004      	str	r4, [r0, #0]
   328a2:	60c4      	str	r4, [r0, #12]
   328a4:	e9c0 4401 	strd	r4, r4, [r0, #4]
   328a8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
   328ac:	f8d8 4008 	ldr.w	r4, [r8, #8]
   328b0:	b94c      	cbnz	r4, 328c6 <__pow5mult+0x56>
   328b2:	f240 2171 	movw	r1, #625	; 0x271
   328b6:	4630      	mov	r0, r6
   328b8:	f006 ff17 	bl	396ea <__i2b>
   328bc:	2300      	movs	r3, #0
   328be:	4604      	mov	r4, r0
   328c0:	f8c8 0008 	str.w	r0, [r8, #8]
   328c4:	6003      	str	r3, [r0, #0]
   328c6:	f04f 0800 	mov.w	r8, #0
   328ca:	07eb      	lsls	r3, r5, #31
   328cc:	d50a      	bpl.n	328e4 <__pow5mult+0x74>
   328ce:	4639      	mov	r1, r7
   328d0:	4622      	mov	r2, r4
   328d2:	4630      	mov	r0, r6
   328d4:	f006 ff12 	bl	396fc <__multiply>
   328d8:	4681      	mov	r9, r0
   328da:	4639      	mov	r1, r7
   328dc:	4630      	mov	r0, r6
   328de:	464f      	mov	r7, r9
   328e0:	f006 fe5f 	bl	395a2 <_Bfree>
   328e4:	106d      	asrs	r5, r5, #1
   328e6:	d00b      	beq.n	32900 <__pow5mult+0x90>
   328e8:	6820      	ldr	r0, [r4, #0]
   328ea:	b938      	cbnz	r0, 328fc <__pow5mult+0x8c>
   328ec:	4622      	mov	r2, r4
   328ee:	4621      	mov	r1, r4
   328f0:	4630      	mov	r0, r6
   328f2:	f006 ff03 	bl	396fc <__multiply>
   328f6:	6020      	str	r0, [r4, #0]
   328f8:	f8c0 8000 	str.w	r8, [r0]
   328fc:	4604      	mov	r4, r0
   328fe:	e7e4      	b.n	328ca <__pow5mult+0x5a>
   32900:	4638      	mov	r0, r7
   32902:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   32906:	bf00      	nop
   32908:	0003b3e4 	.word	0x0003b3e4

0003290c <_svfiprintf_r>:
   3290c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32910:	461e      	mov	r6, r3
   32912:	898b      	ldrh	r3, [r1, #12]
   32914:	b09d      	sub	sp, #116	; 0x74
   32916:	4607      	mov	r7, r0
   32918:	061b      	lsls	r3, r3, #24
   3291a:	460d      	mov	r5, r1
   3291c:	4614      	mov	r4, r2
   3291e:	d50e      	bpl.n	3293e <_svfiprintf_r+0x32>
   32920:	690b      	ldr	r3, [r1, #16]
   32922:	b963      	cbnz	r3, 3293e <_svfiprintf_r+0x32>
   32924:	2140      	movs	r1, #64	; 0x40
   32926:	f7fe fcdb 	bl	312e0 <_malloc_r>
   3292a:	6028      	str	r0, [r5, #0]
   3292c:	6128      	str	r0, [r5, #16]
   3292e:	b920      	cbnz	r0, 3293a <_svfiprintf_r+0x2e>
   32930:	230c      	movs	r3, #12
   32932:	603b      	str	r3, [r7, #0]
   32934:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   32938:	e0c9      	b.n	32ace <_svfiprintf_r+0x1c2>
   3293a:	2340      	movs	r3, #64	; 0x40
   3293c:	616b      	str	r3, [r5, #20]
   3293e:	2300      	movs	r3, #0
   32940:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 32ae8 <_svfiprintf_r+0x1dc>
   32944:	f04f 0a01 	mov.w	sl, #1
   32948:	9603      	str	r6, [sp, #12]
   3294a:	9309      	str	r3, [sp, #36]	; 0x24
   3294c:	2320      	movs	r3, #32
   3294e:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   32952:	2330      	movs	r3, #48	; 0x30
   32954:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   32958:	4623      	mov	r3, r4
   3295a:	461e      	mov	r6, r3
   3295c:	f813 2b01 	ldrb.w	r2, [r3], #1
   32960:	b10a      	cbz	r2, 32966 <_svfiprintf_r+0x5a>
   32962:	2a25      	cmp	r2, #37	; 0x25
   32964:	d1f9      	bne.n	3295a <_svfiprintf_r+0x4e>
   32966:	ebb6 0b04 	subs.w	fp, r6, r4
   3296a:	d00b      	beq.n	32984 <_svfiprintf_r+0x78>
   3296c:	465b      	mov	r3, fp
   3296e:	4622      	mov	r2, r4
   32970:	4629      	mov	r1, r5
   32972:	4638      	mov	r0, r7
   32974:	f007 f892 	bl	39a9c <__ssputs_r>
   32978:	3001      	adds	r0, #1
   3297a:	f000 80a3 	beq.w	32ac4 <_svfiprintf_r+0x1b8>
   3297e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   32980:	445b      	add	r3, fp
   32982:	9309      	str	r3, [sp, #36]	; 0x24
   32984:	7833      	ldrb	r3, [r6, #0]
   32986:	2b00      	cmp	r3, #0
   32988:	f000 809c 	beq.w	32ac4 <_svfiprintf_r+0x1b8>
   3298c:	2300      	movs	r3, #0
   3298e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   32992:	3601      	adds	r6, #1
   32994:	9304      	str	r3, [sp, #16]
   32996:	9307      	str	r3, [sp, #28]
   32998:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   3299c:	931a      	str	r3, [sp, #104]	; 0x68
   3299e:	e9cd 2305 	strd	r2, r3, [sp, #20]
   329a2:	4634      	mov	r4, r6
   329a4:	2205      	movs	r2, #5
   329a6:	4850      	ldr	r0, [pc, #320]	; (32ae8 <_svfiprintf_r+0x1dc>)
   329a8:	f814 1b01 	ldrb.w	r1, [r4], #1
   329ac:	f006 faf8 	bl	38fa0 <memchr>
   329b0:	9b04      	ldr	r3, [sp, #16]
   329b2:	b9c0      	cbnz	r0, 329e6 <_svfiprintf_r+0xda>
   329b4:	06d9      	lsls	r1, r3, #27
   329b6:	bf44      	itt	mi
   329b8:	2220      	movmi	r2, #32
   329ba:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   329be:	071a      	lsls	r2, r3, #28
   329c0:	bf44      	itt	mi
   329c2:	222b      	movmi	r2, #43	; 0x2b
   329c4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
   329c8:	7832      	ldrb	r2, [r6, #0]
   329ca:	2a2a      	cmp	r2, #42	; 0x2a
   329cc:	d013      	beq.n	329f6 <_svfiprintf_r+0xea>
   329ce:	4634      	mov	r4, r6
   329d0:	9a07      	ldr	r2, [sp, #28]
   329d2:	2000      	movs	r0, #0
   329d4:	260a      	movs	r6, #10
   329d6:	4621      	mov	r1, r4
   329d8:	f811 3b01 	ldrb.w	r3, [r1], #1
   329dc:	3b30      	subs	r3, #48	; 0x30
   329de:	2b09      	cmp	r3, #9
   329e0:	d94b      	bls.n	32a7a <_svfiprintf_r+0x16e>
   329e2:	b970      	cbnz	r0, 32a02 <_svfiprintf_r+0xf6>
   329e4:	e014      	b.n	32a10 <_svfiprintf_r+0x104>
   329e6:	eba0 0009 	sub.w	r0, r0, r9
   329ea:	4626      	mov	r6, r4
   329ec:	fa0a f000 	lsl.w	r0, sl, r0
   329f0:	4318      	orrs	r0, r3
   329f2:	9004      	str	r0, [sp, #16]
   329f4:	e7d5      	b.n	329a2 <_svfiprintf_r+0x96>
   329f6:	9a03      	ldr	r2, [sp, #12]
   329f8:	1d11      	adds	r1, r2, #4
   329fa:	6812      	ldr	r2, [r2, #0]
   329fc:	2a00      	cmp	r2, #0
   329fe:	9103      	str	r1, [sp, #12]
   32a00:	db01      	blt.n	32a06 <_svfiprintf_r+0xfa>
   32a02:	9207      	str	r2, [sp, #28]
   32a04:	e004      	b.n	32a10 <_svfiprintf_r+0x104>
   32a06:	4252      	negs	r2, r2
   32a08:	f043 0302 	orr.w	r3, r3, #2
   32a0c:	9207      	str	r2, [sp, #28]
   32a0e:	9304      	str	r3, [sp, #16]
   32a10:	7823      	ldrb	r3, [r4, #0]
   32a12:	2b2e      	cmp	r3, #46	; 0x2e
   32a14:	d10c      	bne.n	32a30 <_svfiprintf_r+0x124>
   32a16:	7863      	ldrb	r3, [r4, #1]
   32a18:	2b2a      	cmp	r3, #42	; 0x2a
   32a1a:	d133      	bne.n	32a84 <_svfiprintf_r+0x178>
   32a1c:	9b03      	ldr	r3, [sp, #12]
   32a1e:	3402      	adds	r4, #2
   32a20:	1d1a      	adds	r2, r3, #4
   32a22:	681b      	ldr	r3, [r3, #0]
   32a24:	2b00      	cmp	r3, #0
   32a26:	9203      	str	r2, [sp, #12]
   32a28:	bfb8      	it	lt
   32a2a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   32a2e:	9305      	str	r3, [sp, #20]
   32a30:	4e2e      	ldr	r6, [pc, #184]	; (32aec <_svfiprintf_r+0x1e0>)
   32a32:	2203      	movs	r2, #3
   32a34:	7821      	ldrb	r1, [r4, #0]
   32a36:	4630      	mov	r0, r6
   32a38:	f006 fab2 	bl	38fa0 <memchr>
   32a3c:	b138      	cbz	r0, 32a4e <_svfiprintf_r+0x142>
   32a3e:	2340      	movs	r3, #64	; 0x40
   32a40:	1b80      	subs	r0, r0, r6
   32a42:	3401      	adds	r4, #1
   32a44:	fa03 f000 	lsl.w	r0, r3, r0
   32a48:	9b04      	ldr	r3, [sp, #16]
   32a4a:	4303      	orrs	r3, r0
   32a4c:	9304      	str	r3, [sp, #16]
   32a4e:	f814 1b01 	ldrb.w	r1, [r4], #1
   32a52:	2206      	movs	r2, #6
   32a54:	4826      	ldr	r0, [pc, #152]	; (32af0 <_svfiprintf_r+0x1e4>)
   32a56:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   32a5a:	f006 faa1 	bl	38fa0 <memchr>
   32a5e:	2800      	cmp	r0, #0
   32a60:	d038      	beq.n	32ad4 <_svfiprintf_r+0x1c8>
   32a62:	4b24      	ldr	r3, [pc, #144]	; (32af4 <_svfiprintf_r+0x1e8>)
   32a64:	bb13      	cbnz	r3, 32aac <_svfiprintf_r+0x1a0>
   32a66:	9b03      	ldr	r3, [sp, #12]
   32a68:	3307      	adds	r3, #7
   32a6a:	f023 0307 	bic.w	r3, r3, #7
   32a6e:	3308      	adds	r3, #8
   32a70:	9303      	str	r3, [sp, #12]
   32a72:	9b09      	ldr	r3, [sp, #36]	; 0x24
   32a74:	4443      	add	r3, r8
   32a76:	9309      	str	r3, [sp, #36]	; 0x24
   32a78:	e76e      	b.n	32958 <_svfiprintf_r+0x4c>
   32a7a:	fb06 3202 	mla	r2, r6, r2, r3
   32a7e:	2001      	movs	r0, #1
   32a80:	460c      	mov	r4, r1
   32a82:	e7a8      	b.n	329d6 <_svfiprintf_r+0xca>
   32a84:	2300      	movs	r3, #0
   32a86:	3401      	adds	r4, #1
   32a88:	260a      	movs	r6, #10
   32a8a:	4619      	mov	r1, r3
   32a8c:	9305      	str	r3, [sp, #20]
   32a8e:	4620      	mov	r0, r4
   32a90:	f810 2b01 	ldrb.w	r2, [r0], #1
   32a94:	3a30      	subs	r2, #48	; 0x30
   32a96:	2a09      	cmp	r2, #9
   32a98:	d903      	bls.n	32aa2 <_svfiprintf_r+0x196>
   32a9a:	2b00      	cmp	r3, #0
   32a9c:	d0c8      	beq.n	32a30 <_svfiprintf_r+0x124>
   32a9e:	9105      	str	r1, [sp, #20]
   32aa0:	e7c6      	b.n	32a30 <_svfiprintf_r+0x124>
   32aa2:	fb06 2101 	mla	r1, r6, r1, r2
   32aa6:	2301      	movs	r3, #1
   32aa8:	4604      	mov	r4, r0
   32aaa:	e7f0      	b.n	32a8e <_svfiprintf_r+0x182>
   32aac:	ab03      	add	r3, sp, #12
   32aae:	462a      	mov	r2, r5
   32ab0:	a904      	add	r1, sp, #16
   32ab2:	4638      	mov	r0, r7
   32ab4:	9300      	str	r3, [sp, #0]
   32ab6:	4b10      	ldr	r3, [pc, #64]	; (32af8 <_svfiprintf_r+0x1ec>)
   32ab8:	f7fe fd94 	bl	315e4 <_printf_float>
   32abc:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
   32ac0:	4680      	mov	r8, r0
   32ac2:	d1d6      	bne.n	32a72 <_svfiprintf_r+0x166>
   32ac4:	89ab      	ldrh	r3, [r5, #12]
   32ac6:	065b      	lsls	r3, r3, #25
   32ac8:	f53f af34 	bmi.w	32934 <_svfiprintf_r+0x28>
   32acc:	9809      	ldr	r0, [sp, #36]	; 0x24
   32ace:	b01d      	add	sp, #116	; 0x74
   32ad0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   32ad4:	ab03      	add	r3, sp, #12
   32ad6:	462a      	mov	r2, r5
   32ad8:	a904      	add	r1, sp, #16
   32ada:	4638      	mov	r0, r7
   32adc:	9300      	str	r3, [sp, #0]
   32ade:	4b06      	ldr	r3, [pc, #24]	; (32af8 <_svfiprintf_r+0x1ec>)
   32ae0:	f7fe ffaa 	bl	31a38 <_printf_i>
   32ae4:	e7ea      	b.n	32abc <_svfiprintf_r+0x1b0>
   32ae6:	bf00      	nop
   32ae8:	00040288 	.word	0x00040288
   32aec:	0004028e 	.word	0x0004028e
   32af0:	00040292 	.word	0x00040292
   32af4:	000315e5 	.word	0x000315e5
   32af8:	00039a9d 	.word	0x00039a9d

00032afc <raise>:
   32afc:	4b02      	ldr	r3, [pc, #8]	; (32b08 <raise+0xc>)
   32afe:	4601      	mov	r1, r0
   32b00:	6818      	ldr	r0, [r3, #0]
   32b02:	f007 b826 	b.w	39b52 <_raise_r>
   32b06:	bf00      	nop
   32b08:	20020234 	.word	0x20020234

00032b0c <_kill_r>:
   32b0c:	b538      	push	{r3, r4, r5, lr}
   32b0e:	2300      	movs	r3, #0
   32b10:	4c06      	ldr	r4, [pc, #24]	; (32b2c <_kill_r+0x20>)
   32b12:	4605      	mov	r5, r0
   32b14:	4608      	mov	r0, r1
   32b16:	4611      	mov	r1, r2
   32b18:	6023      	str	r3, [r4, #0]
   32b1a:	f002 fcdc 	bl	354d6 <_kill>
   32b1e:	1c43      	adds	r3, r0, #1
   32b20:	d102      	bne.n	32b28 <_kill_r+0x1c>
   32b22:	6823      	ldr	r3, [r4, #0]
   32b24:	b103      	cbz	r3, 32b28 <_kill_r+0x1c>
   32b26:	602b      	str	r3, [r5, #0]
   32b28:	bd38      	pop	{r3, r4, r5, pc}
   32b2a:	bf00      	nop
   32b2c:	200291f8 	.word	0x200291f8

00032b30 <_write_r>:
   32b30:	b538      	push	{r3, r4, r5, lr}
   32b32:	4605      	mov	r5, r0
   32b34:	4c06      	ldr	r4, [pc, #24]	; (32b50 <_write_r+0x20>)
   32b36:	4608      	mov	r0, r1
   32b38:	4611      	mov	r1, r2
   32b3a:	2200      	movs	r2, #0
   32b3c:	6022      	str	r2, [r4, #0]
   32b3e:	461a      	mov	r2, r3
   32b40:	f002 fcbe 	bl	354c0 <_write>
   32b44:	1c43      	adds	r3, r0, #1
   32b46:	d102      	bne.n	32b4e <_write_r+0x1e>
   32b48:	6823      	ldr	r3, [r4, #0]
   32b4a:	b103      	cbz	r3, 32b4e <_write_r+0x1e>
   32b4c:	602b      	str	r3, [r5, #0]
   32b4e:	bd38      	pop	{r3, r4, r5, pc}
   32b50:	200291f8 	.word	0x200291f8

00032b54 <_close_r>:
   32b54:	b538      	push	{r3, r4, r5, lr}
   32b56:	2300      	movs	r3, #0
   32b58:	4c05      	ldr	r4, [pc, #20]	; (32b70 <_close_r+0x1c>)
   32b5a:	4605      	mov	r5, r0
   32b5c:	4608      	mov	r0, r1
   32b5e:	6023      	str	r3, [r4, #0]
   32b60:	f002 fcb2 	bl	354c8 <_close>
   32b64:	1c43      	adds	r3, r0, #1
   32b66:	d102      	bne.n	32b6e <_close_r+0x1a>
   32b68:	6823      	ldr	r3, [r4, #0]
   32b6a:	b103      	cbz	r3, 32b6e <_close_r+0x1a>
   32b6c:	602b      	str	r3, [r5, #0]
   32b6e:	bd38      	pop	{r3, r4, r5, pc}
   32b70:	200291f8 	.word	0x200291f8

00032b74 <_fstat_r>:
   32b74:	b538      	push	{r3, r4, r5, lr}
   32b76:	2300      	movs	r3, #0
   32b78:	4c06      	ldr	r4, [pc, #24]	; (32b94 <_fstat_r+0x20>)
   32b7a:	4605      	mov	r5, r0
   32b7c:	4608      	mov	r0, r1
   32b7e:	4611      	mov	r1, r2
   32b80:	6023      	str	r3, [r4, #0]
   32b82:	f002 fcac 	bl	354de <_fstat>
   32b86:	1c43      	adds	r3, r0, #1
   32b88:	d102      	bne.n	32b90 <_fstat_r+0x1c>
   32b8a:	6823      	ldr	r3, [r4, #0]
   32b8c:	b103      	cbz	r3, 32b90 <_fstat_r+0x1c>
   32b8e:	602b      	str	r3, [r5, #0]
   32b90:	bd38      	pop	{r3, r4, r5, pc}
   32b92:	bf00      	nop
   32b94:	200291f8 	.word	0x200291f8

00032b98 <_isatty_r>:
   32b98:	b538      	push	{r3, r4, r5, lr}
   32b9a:	2300      	movs	r3, #0
   32b9c:	4c05      	ldr	r4, [pc, #20]	; (32bb4 <_isatty_r+0x1c>)
   32b9e:	4605      	mov	r5, r0
   32ba0:	4608      	mov	r0, r1
   32ba2:	6023      	str	r3, [r4, #0]
   32ba4:	f002 fc95 	bl	354d2 <_isatty>
   32ba8:	1c43      	adds	r3, r0, #1
   32baa:	d102      	bne.n	32bb2 <_isatty_r+0x1a>
   32bac:	6823      	ldr	r3, [r4, #0]
   32bae:	b103      	cbz	r3, 32bb2 <_isatty_r+0x1a>
   32bb0:	602b      	str	r3, [r5, #0]
   32bb2:	bd38      	pop	{r3, r4, r5, pc}
   32bb4:	200291f8 	.word	0x200291f8

00032bb8 <_lseek_r>:
   32bb8:	b538      	push	{r3, r4, r5, lr}
   32bba:	4605      	mov	r5, r0
   32bbc:	4c06      	ldr	r4, [pc, #24]	; (32bd8 <_lseek_r+0x20>)
   32bbe:	4608      	mov	r0, r1
   32bc0:	4611      	mov	r1, r2
   32bc2:	2200      	movs	r2, #0
   32bc4:	6022      	str	r2, [r4, #0]
   32bc6:	461a      	mov	r2, r3
   32bc8:	f002 fc81 	bl	354ce <_lseek>
   32bcc:	1c43      	adds	r3, r0, #1
   32bce:	d102      	bne.n	32bd6 <_lseek_r+0x1e>
   32bd0:	6823      	ldr	r3, [r4, #0]
   32bd2:	b103      	cbz	r3, 32bd6 <_lseek_r+0x1e>
   32bd4:	602b      	str	r3, [r5, #0]
   32bd6:	bd38      	pop	{r3, r4, r5, pc}
   32bd8:	200291f8 	.word	0x200291f8

00032bdc <_read_r>:
   32bdc:	b538      	push	{r3, r4, r5, lr}
   32bde:	4605      	mov	r5, r0
   32be0:	4c06      	ldr	r4, [pc, #24]	; (32bfc <_read_r+0x20>)
   32be2:	4608      	mov	r0, r1
   32be4:	4611      	mov	r1, r2
   32be6:	2200      	movs	r2, #0
   32be8:	6022      	str	r2, [r4, #0]
   32bea:	461a      	mov	r2, r3
   32bec:	f002 fc64 	bl	354b8 <_read>
   32bf0:	1c43      	adds	r3, r0, #1
   32bf2:	d102      	bne.n	32bfa <_read_r+0x1e>
   32bf4:	6823      	ldr	r3, [r4, #0]
   32bf6:	b103      	cbz	r3, 32bfa <_read_r+0x1e>
   32bf8:	602b      	str	r3, [r5, #0]
   32bfa:	bd38      	pop	{r3, r4, r5, pc}
   32bfc:	200291f8 	.word	0x200291f8

00032c00 <received_config_handler>:
void received_config_handler(const struct mqtt_publish_message *message) {
   32c00:	b508      	push	{r3, lr}
	cJSON * data_json = cJSON_Parse(message->payload.data);
   32c02:	68c0      	ldr	r0, [r0, #12]
   32c04:	f000 f8cd 	bl	32da2 <cJSON_Parse>
}
   32c08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	cJSON_Delete(data_json);
   32c0c:	f7e4 b9bc 	b.w	16f88 <cJSON_Delete>

00032c10 <calculate_avg_val>:
{
   32c10:	b5f0      	push	{r4, r5, r6, r7, lr}
    for(s32_t i=0; i<sz; i++) {
   32c12:	2500      	movs	r5, #0
        } else if (is_qual && a[i] != EXCLUDE) {
   32c14:	f240 3ce7 	movw	ip, #999	; 0x3e7
    s32_t excl_cnt = 0;
   32c18:	462e      	mov	r6, r5
    s32_t sum = 0;
   32c1a:	462c      	mov	r4, r5
    for(s32_t i=0; i<sz; i++) {
   32c1c:	428d      	cmp	r5, r1
   32c1e:	db08      	blt.n	32c32 <calculate_avg_val+0x22>
    *val_cnt = sz-excl_cnt;
   32c20:	1b88      	subs	r0, r1, r6
    if (excl_cnt == sz) {
   32c22:	428e      	cmp	r6, r1
    *val_cnt = sz-excl_cnt;
   32c24:	6018      	str	r0, [r3, #0]
        return (sum/(*val_cnt));
   32c26:	bf14      	ite	ne
   32c28:	fb94 f0f0 	sdivne	r0, r4, r0
        return (EXCLUDE);
   32c2c:	f240 30e7 	movweq	r0, #999	; 0x3e7
}
   32c30:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (!is_qual) {
   32c32:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
   32c36:	b912      	cbnz	r2, 32c3e <calculate_avg_val+0x2e>
            sum += a[i];
   32c38:	443c      	add	r4, r7
    for(s32_t i=0; i<sz; i++) {
   32c3a:	3501      	adds	r5, #1
   32c3c:	e7ee      	b.n	32c1c <calculate_avg_val+0xc>
        } else if (is_qual && a[i] != EXCLUDE) {
   32c3e:	4567      	cmp	r7, ip
   32c40:	d1fa      	bne.n	32c38 <calculate_avg_val+0x28>
            excl_cnt += 1;
   32c42:	3601      	adds	r6, #1
   32c44:	e7f9      	b.n	32c3a <calculate_avg_val+0x2a>

00032c46 <calculate_min_val>:
    for(i=0; i<sz; i++) {
   32c46:	2300      	movs	r3, #0
{
   32c48:	b510      	push	{r4, lr}
 	min=a[0];
   32c4a:	6802      	ldr	r2, [r0, #0]
    for(i=0; i<sz; i++) {
   32c4c:	428b      	cmp	r3, r1
   32c4e:	db01      	blt.n	32c54 <calculate_min_val+0xe>
}
   32c50:	4610      	mov	r0, r2
   32c52:	bd10      	pop	{r4, pc}
        if(min>a[i]) {
   32c54:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
    for(i=0; i<sz; i++) {
   32c58:	3301      	adds	r3, #1
   32c5a:	42a2      	cmp	r2, r4
   32c5c:	bfa8      	it	ge
   32c5e:	4622      	movge	r2, r4
   32c60:	e7f4      	b.n	32c4c <calculate_min_val+0x6>

00032c62 <calculate_max_val>:
{
   32c62:	b570      	push	{r4, r5, r6, lr}
    for(i=0; i<sz; i++) 
   32c64:	2500      	movs	r5, #0
            if(max==EXCLUDE || max<a[i]) {
   32c66:	f240 36e7 	movw	r6, #999	; 0x3e7
    max=a[0];
   32c6a:	6803      	ldr	r3, [r0, #0]
    for(i=0; i<sz; i++) 
   32c6c:	428d      	cmp	r5, r1
   32c6e:	db01      	blt.n	32c74 <calculate_max_val+0x12>
}
   32c70:	4618      	mov	r0, r3
   32c72:	bd70      	pop	{r4, r5, r6, pc}
        if (is_qual) {
   32c74:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
   32c78:	b10a      	cbz	r2, 32c7e <calculate_max_val+0x1c>
            if(max==EXCLUDE || max<a[i]) {
   32c7a:	42b3      	cmp	r3, r6
   32c7c:	d002      	beq.n	32c84 <calculate_max_val+0x22>
            if(max<a[i]) {
   32c7e:	429c      	cmp	r4, r3
   32c80:	bfb8      	it	lt
   32c82:	461c      	movlt	r4, r3
    for(i=0; i<sz; i++) 
   32c84:	3501      	adds	r5, #1
   32c86:	4623      	mov	r3, r4
   32c88:	e7f0      	b.n	32c6c <calculate_max_val+0xa>

00032c8a <k_msgq_get_atomic>:
int k_msgq_get_atomic(struct k_msgq *q, void *data, k_timeout_t timeout){
   32c8a:	b510      	push	{r4, lr}
	__asm__ volatile(
   32c8c:	f04f 0320 	mov.w	r3, #32
   32c90:	f3ef 8411 	mrs	r4, BASEPRI
   32c94:	f383 8811 	msr	BASEPRI, r3
   32c98:	f3bf 8f6f 	isb	sy
	return z_impl_k_msgq_get(msgq, data, timeout);
   32c9c:	f7f9 fbd2 	bl	2c444 <z_impl_k_msgq_get>
	__asm__ volatile(
   32ca0:	f384 8811 	msr	BASEPRI, r4
   32ca4:	f3bf 8f6f 	isb	sy
}
   32ca8:	bd10      	pop	{r4, pc}

00032caa <k_msgq_put_atomic>:
int k_msgq_put_atomic(struct k_msgq *q, void *data, k_timeout_t timeout){
   32caa:	b510      	push	{r4, lr}
	__asm__ volatile(
   32cac:	f04f 0320 	mov.w	r3, #32
   32cb0:	f3ef 8411 	mrs	r4, BASEPRI
   32cb4:	f383 8811 	msr	BASEPRI, r3
   32cb8:	f3bf 8f6f 	isb	sy
	return z_impl_k_msgq_put(msgq, data, timeout);
   32cbc:	f7f9 fb28 	bl	2c310 <z_impl_k_msgq_put>
	__asm__ volatile(
   32cc0:	f384 8811 	msr	BASEPRI, r4
   32cc4:	f3bf 8f6f 	isb	sy
}
   32cc8:	bd10      	pop	{r4, pc}

00032cca <parse_hex4>:
{
   32cca:	b510      	push	{r4, lr}
	if (*str >= '0' && *str <= '9')
   32ccc:	7802      	ldrb	r2, [r0, #0]
   32cce:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   32cd2:	b2d9      	uxtb	r1, r3
   32cd4:	2909      	cmp	r1, #9
   32cd6:	d905      	bls.n	32ce4 <parse_hex4+0x1a>
	else if (*str >= 'A' && *str <= 'F')
   32cd8:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
   32cdc:	2b05      	cmp	r3, #5
   32cde:	d81a      	bhi.n	32d16 <parse_hex4+0x4c>
		h += 10 + (*str) - 'A';
   32ce0:	f1a2 0337 	sub.w	r3, r2, #55	; 0x37
	if (*str >= '0' && *str <= '9')
   32ce4:	7842      	ldrb	r2, [r0, #1]
	h = h << 4;
   32ce6:	011b      	lsls	r3, r3, #4
	if (*str >= '0' && *str <= '9')
   32ce8:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   32cec:	b2cc      	uxtb	r4, r1
   32cee:	2c09      	cmp	r4, #9
   32cf0:	d818      	bhi.n	32d24 <parse_hex4+0x5a>
		h += (*str) - '0';
   32cf2:	440b      	add	r3, r1
	if (*str >= '0' && *str <= '9')
   32cf4:	7882      	ldrb	r2, [r0, #2]
	h = h << 4;
   32cf6:	011b      	lsls	r3, r3, #4
	if (*str >= '0' && *str <= '9')
   32cf8:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
   32cfc:	b2cc      	uxtb	r4, r1
   32cfe:	2c09      	cmp	r4, #9
   32d00:	d81d      	bhi.n	32d3e <parse_hex4+0x74>
		h += (*str) - '0';
   32d02:	440b      	add	r3, r1
	if (*str >= '0' && *str <= '9')
   32d04:	78c0      	ldrb	r0, [r0, #3]
	h = h << 4;
   32d06:	011b      	lsls	r3, r3, #4
	if (*str >= '0' && *str <= '9')
   32d08:	f1a0 0230 	sub.w	r2, r0, #48	; 0x30
   32d0c:	b2d1      	uxtb	r1, r2
   32d0e:	2909      	cmp	r1, #9
   32d10:	d822      	bhi.n	32d58 <parse_hex4+0x8e>
		h += (*str) - '0';
   32d12:	18d0      	adds	r0, r2, r3
}
   32d14:	bd10      	pop	{r4, pc}
	else if (*str >= 'a' && *str <= 'f')
   32d16:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
   32d1a:	2b05      	cmp	r3, #5
   32d1c:	d829      	bhi.n	32d72 <parse_hex4+0xa8>
		h += 10 + (*str) - 'a';
   32d1e:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
   32d22:	e7df      	b.n	32ce4 <parse_hex4+0x1a>
	else if (*str >= 'A' && *str <= 'F')
   32d24:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
   32d28:	2905      	cmp	r1, #5
   32d2a:	d802      	bhi.n	32d32 <parse_hex4+0x68>
		h += 10 + (*str) - 'A';
   32d2c:	3a37      	subs	r2, #55	; 0x37
		h += 10 + (*str) - 'a';
   32d2e:	4413      	add	r3, r2
   32d30:	e7e0      	b.n	32cf4 <parse_hex4+0x2a>
	else if (*str >= 'a' && *str <= 'f')
   32d32:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
   32d36:	2905      	cmp	r1, #5
   32d38:	d81b      	bhi.n	32d72 <parse_hex4+0xa8>
		h += 10 + (*str) - 'a';
   32d3a:	3a57      	subs	r2, #87	; 0x57
   32d3c:	e7f7      	b.n	32d2e <parse_hex4+0x64>
	else if (*str >= 'A' && *str <= 'F')
   32d3e:	f1a2 0141 	sub.w	r1, r2, #65	; 0x41
   32d42:	2905      	cmp	r1, #5
   32d44:	d802      	bhi.n	32d4c <parse_hex4+0x82>
		h += 10 + (*str) - 'A';
   32d46:	3a37      	subs	r2, #55	; 0x37
		h += 10 + (*str) - 'a';
   32d48:	4413      	add	r3, r2
   32d4a:	e7db      	b.n	32d04 <parse_hex4+0x3a>
	else if (*str >= 'a' && *str <= 'f')
   32d4c:	f1a2 0161 	sub.w	r1, r2, #97	; 0x61
   32d50:	2905      	cmp	r1, #5
   32d52:	d80e      	bhi.n	32d72 <parse_hex4+0xa8>
		h += 10 + (*str) - 'a';
   32d54:	3a57      	subs	r2, #87	; 0x57
   32d56:	e7f7      	b.n	32d48 <parse_hex4+0x7e>
	else if (*str >= 'A' && *str <= 'F')
   32d58:	f1a0 0241 	sub.w	r2, r0, #65	; 0x41
   32d5c:	2a05      	cmp	r2, #5
   32d5e:	d802      	bhi.n	32d66 <parse_hex4+0x9c>
		h += 10 + (*str) - 'A';
   32d60:	3837      	subs	r0, #55	; 0x37
		h += 10 + (*str) - 'a';
   32d62:	4418      	add	r0, r3
   32d64:	e7d6      	b.n	32d14 <parse_hex4+0x4a>
	else if (*str >= 'a' && *str <= 'f')
   32d66:	f1a0 0261 	sub.w	r2, r0, #97	; 0x61
   32d6a:	2a05      	cmp	r2, #5
   32d6c:	d801      	bhi.n	32d72 <parse_hex4+0xa8>
		h += 10 + (*str) - 'a';
   32d6e:	3857      	subs	r0, #87	; 0x57
   32d70:	e7f7      	b.n	32d62 <parse_hex4+0x98>
		return 0;
   32d72:	2000      	movs	r0, #0
   32d74:	e7ce      	b.n	32d14 <parse_hex4+0x4a>

00032d76 <skip>:
{
   32d76:	4603      	mov	r3, r0
	while (in && *in && (unsigned char)*in <= 32)
   32d78:	4618      	mov	r0, r3
   32d7a:	b123      	cbz	r3, 32d86 <skip+0x10>
   32d7c:	7802      	ldrb	r2, [r0, #0]
   32d7e:	3301      	adds	r3, #1
   32d80:	3a01      	subs	r2, #1
   32d82:	2a1f      	cmp	r2, #31
   32d84:	d9f8      	bls.n	32d78 <skip+0x2>
}
   32d86:	4770      	bx	lr

00032d88 <update>:
{
   32d88:	b510      	push	{r4, lr}
	if (!p || !p->buffer)
   32d8a:	b138      	cbz	r0, 32d9c <update+0x14>
   32d8c:	6803      	ldr	r3, [r0, #0]
   32d8e:	b133      	cbz	r3, 32d9e <update+0x16>
	str = p->buffer + p->offset;
   32d90:	6884      	ldr	r4, [r0, #8]
	return p->offset + strlens(str);
   32d92:	1918      	adds	r0, r3, r4
   32d94:	d001      	beq.n	32d9a <update+0x12>
   32d96:	f7df f973 	bl	12080 <strlen>
   32d9a:	4420      	add	r0, r4
}
   32d9c:	bd10      	pop	{r4, pc}
		return 0;
   32d9e:	4618      	mov	r0, r3
   32da0:	e7fc      	b.n	32d9c <update+0x14>

00032da2 <cJSON_Parse>:
	return cJSON_ParseWithOpts(value, 0, 0);
   32da2:	2200      	movs	r2, #0
   32da4:	4611      	mov	r1, r2
   32da6:	f7e4 b913 	b.w	16fd0 <cJSON_ParseWithOpts>

00032daa <cJSON_Print>:
char *cJSON_Print(cJSON *item) { return print_value(item, 0, 1, 0); }
   32daa:	2300      	movs	r3, #0
   32dac:	2201      	movs	r2, #1
   32dae:	4619      	mov	r1, r3
   32db0:	f7e3 be9a 	b.w	16ae8 <print_value>

00032db4 <cJSON_AddItemToArray>:
	if (!item)
   32db4:	b149      	cbz	r1, 32dca <cJSON_AddItemToArray+0x16>
	cJSON *c = array->child;
   32db6:	6883      	ldr	r3, [r0, #8]
	if (!c) {
   32db8:	b913      	cbnz	r3, 32dc0 <cJSON_AddItemToArray+0xc>
		array->child = item;
   32dba:	6081      	str	r1, [r0, #8]
   32dbc:	4770      	bx	lr
   32dbe:	4613      	mov	r3, r2
		while (c && c->next)
   32dc0:	681a      	ldr	r2, [r3, #0]
   32dc2:	2a00      	cmp	r2, #0
   32dc4:	d1fb      	bne.n	32dbe <cJSON_AddItemToArray+0xa>
	prev->next = item;
   32dc6:	6019      	str	r1, [r3, #0]
	item->prev = prev;
   32dc8:	604b      	str	r3, [r1, #4]
}
   32dca:	4770      	bx	lr

00032dcc <cJSON_CreateNumber>:
	if (item)
		item->type = b ? cJSON_True : cJSON_False;
	return item;
}
cJSON *cJSON_CreateNumber(double num)
{
   32dcc:	b513      	push	{r0, r1, r4, lr}
   32dce:	ed8d 0b00 	vstr	d0, [sp]
	cJSON *item = cJSON_New_Item();
   32dd2:	f7e3 fb77 	bl	164c4 <cJSON_New_Item>
	if (item) {
   32dd6:	4604      	mov	r4, r0
   32dd8:	b150      	cbz	r0, 32df0 <cJSON_CreateNumber+0x24>
		item->type = cJSON_Number;
		item->valuedouble = num;
   32dda:	ed9d 0b00 	vldr	d0, [sp]
		item->type = cJSON_Number;
   32dde:	2303      	movs	r3, #3
		item->valuedouble = num;
   32de0:	ed80 0b06 	vstr	d0, [r0, #24]
		item->type = cJSON_Number;
   32de4:	60c3      	str	r3, [r0, #12]
		item->valueint = (int)num;
   32de6:	ec51 0b10 	vmov	r0, r1, d0
   32dea:	f7da fbf9 	bl	d5e0 <__aeabi_d2iz>
   32dee:	6160      	str	r0, [r4, #20]
	}
	return item;
}
   32df0:	4620      	mov	r0, r4
   32df2:	b002      	add	sp, #8
   32df4:	bd10      	pop	{r4, pc}

00032df6 <cJSON_CreateString>:
cJSON *cJSON_CreateString(const char *string)
{
   32df6:	b538      	push	{r3, r4, r5, lr}
   32df8:	4605      	mov	r5, r0
	cJSON *item = cJSON_New_Item();
   32dfa:	f7e3 fb63 	bl	164c4 <cJSON_New_Item>
	if (item) {
   32dfe:	4604      	mov	r4, r0
   32e00:	b128      	cbz	r0, 32e0e <cJSON_CreateString+0x18>
		item->type = cJSON_String;
   32e02:	2304      	movs	r3, #4
   32e04:	60c3      	str	r3, [r0, #12]
		item->valuestring = cJSON_strdup(string);
   32e06:	4628      	mov	r0, r5
   32e08:	f7e3 fc9e 	bl	16748 <cJSON_strdup>
   32e0c:	6120      	str	r0, [r4, #16]
	}
	return item;
}
   32e0e:	4620      	mov	r0, r4
   32e10:	bd38      	pop	{r3, r4, r5, pc}

00032e12 <cJSON_CreateObject>:
	if (item)
		item->type = cJSON_Array;
	return item;
}
cJSON *cJSON_CreateObject(void)
{
   32e12:	b508      	push	{r3, lr}
	cJSON *item = cJSON_New_Item();
   32e14:	f7e3 fb56 	bl	164c4 <cJSON_New_Item>
	if (item)
   32e18:	b108      	cbz	r0, 32e1e <cJSON_CreateObject+0xc>
		item->type = cJSON_Object;
   32e1a:	2306      	movs	r3, #6
   32e1c:	60c3      	str	r3, [r0, #12]
	return item;
}
   32e1e:	bd08      	pop	{r3, pc}

00032e20 <config_load>:
}
   32e20:	2000      	movs	r0, #0
   32e22:	4770      	bx	lr

00032e24 <get_timestamp_us>:
{
   32e24:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_uptime_ticks();
   32e26:	f006 f809 	bl	38e3c <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   32e2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   32e2e:	fba0 4502 	umull	r4, r5, r0, r2
   32e32:	fb02 5501 	mla	r5, r2, r1, r5
   32e36:	0be3      	lsrs	r3, r4, #15
   32e38:	ea43 4345 	orr.w	r3, r3, r5, lsl #17
	return k_uptime_get()*1000;
   32e3c:	fba3 0102 	umull	r0, r1, r3, r2
   32e40:	0bec      	lsrs	r4, r5, #15
   32e42:	fb02 1104 	mla	r1, r2, r4, r1
}
   32e46:	bd38      	pop	{r3, r4, r5, pc}

00032e48 <k_sleep>:
	return z_impl_k_sleep(timeout);
   32e48:	f7fb b88e 	b.w	2df68 <z_impl_k_sleep>

00032e4c <delay_ms>:
	k_sleep(K_MSEC(period));
   32e4c:	f7ff bffc 	b.w	32e48 <k_sleep>

00032e50 <null_ptr_check>:
 */
static int8_t null_ptr_check(const struct bme680_dev *dev)
{
	int8_t rslt;

	if ((dev == NULL) || (dev->read == NULL) || (dev->write == NULL) || (dev->delay_ms == NULL)) {
   32e50:	b148      	cbz	r0, 32e66 <null_ptr_check+0x16>
   32e52:	6c83      	ldr	r3, [r0, #72]	; 0x48
   32e54:	b13b      	cbz	r3, 32e66 <null_ptr_check+0x16>
   32e56:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   32e58:	b12b      	cbz	r3, 32e66 <null_ptr_check+0x16>
   32e5a:	6d00      	ldr	r0, [r0, #80]	; 0x50
   32e5c:	fab0 f080 	clz	r0, r0
   32e60:	0940      	lsrs	r0, r0, #5
   32e62:	4240      	negs	r0, r0
   32e64:	4770      	bx	lr
		/* Device structure pointer is not valid */
		rslt = BME680_E_NULL_PTR;
   32e66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		/* Device structure is fine */
		rslt = BME680_OK;
	}

	return rslt;
}
   32e6a:	4770      	bx	lr

00032e6c <set_mem_page>:
{
   32e6c:	b573      	push	{r0, r1, r4, r5, r6, lr}
   32e6e:	4602      	mov	r2, r0
	rslt = null_ptr_check(dev);
   32e70:	4608      	mov	r0, r1
{
   32e72:	460c      	mov	r4, r1
	rslt = null_ptr_check(dev);
   32e74:	f7ff ffec 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   32e78:	4605      	mov	r5, r0
   32e7a:	bb40      	cbnz	r0, 32ece <set_mem_page+0x62>
			mem_page = BME680_MEM_PAGE0;
   32e7c:	f012 0f80 	tst.w	r2, #128	; 0x80
   32e80:	bf14      	ite	ne
   32e82:	2300      	movne	r3, #0
   32e84:	2310      	moveq	r3, #16
		if (mem_page != dev->mem_page) {
   32e86:	78ca      	ldrb	r2, [r1, #3]
   32e88:	429a      	cmp	r2, r3
   32e8a:	d020      	beq.n	32ece <set_mem_page+0x62>
			dev->mem_page = mem_page;
   32e8c:	70cb      	strb	r3, [r1, #3]
			dev->com_rslt = dev->read(dev->dev_id, BME680_MEM_PAGE_ADDR | BME680_SPI_RD_MSK, &reg, 1);
   32e8e:	6c8e      	ldr	r6, [r1, #72]	; 0x48
   32e90:	2301      	movs	r3, #1
   32e92:	f10d 0207 	add.w	r2, sp, #7
   32e96:	21f3      	movs	r1, #243	; 0xf3
   32e98:	7860      	ldrb	r0, [r4, #1]
   32e9a:	47b0      	blx	r6
   32e9c:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
			if (dev->com_rslt != 0)
   32ea0:	b998      	cbnz	r0, 32eca <set_mem_page+0x5e>
				reg = reg & (~BME680_MEM_PAGE_MSK);
   32ea2:	f89d 2007 	ldrb.w	r2, [sp, #7]
				reg = reg | (dev->mem_page & BME680_MEM_PAGE_MSK);
   32ea6:	78e3      	ldrb	r3, [r4, #3]
				reg = reg & (~BME680_MEM_PAGE_MSK);
   32ea8:	f022 0210 	bic.w	r2, r2, #16
				reg = reg | (dev->mem_page & BME680_MEM_PAGE_MSK);
   32eac:	f003 0310 	and.w	r3, r3, #16
   32eb0:	4313      	orrs	r3, r2
   32eb2:	f88d 3007 	strb.w	r3, [sp, #7]
				dev->com_rslt = dev->write(dev->dev_id, BME680_MEM_PAGE_ADDR & BME680_SPI_WR_MSK,
   32eb6:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
   32eb8:	2301      	movs	r3, #1
   32eba:	f10d 0207 	add.w	r2, sp, #7
   32ebe:	2173      	movs	r1, #115	; 0x73
   32ec0:	7860      	ldrb	r0, [r4, #1]
   32ec2:	47b0      	blx	r6
   32ec4:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
				if (dev->com_rslt != 0)
   32ec8:	b108      	cbz	r0, 32ece <set_mem_page+0x62>
					rslt = BME680_E_COM_FAIL;
   32eca:	f06f 0501 	mvn.w	r5, #1
}
   32ece:	4628      	mov	r0, r5
   32ed0:	b002      	add	sp, #8
   32ed2:	bd70      	pop	{r4, r5, r6, pc}

00032ed4 <get_mem_page.part.3>:
static int8_t get_mem_page(struct bme680_dev *dev)
   32ed4:	b537      	push	{r0, r1, r2, r4, r5, lr}
		dev->com_rslt = dev->read(dev->dev_id, BME680_MEM_PAGE_ADDR | BME680_SPI_RD_MSK, &reg, 1);
   32ed6:	2301      	movs	r3, #1
static int8_t get_mem_page(struct bme680_dev *dev)
   32ed8:	4604      	mov	r4, r0
		dev->com_rslt = dev->read(dev->dev_id, BME680_MEM_PAGE_ADDR | BME680_SPI_RD_MSK, &reg, 1);
   32eda:	6c85      	ldr	r5, [r0, #72]	; 0x48
   32edc:	f10d 0207 	add.w	r2, sp, #7
   32ee0:	21f3      	movs	r1, #243	; 0xf3
   32ee2:	7840      	ldrb	r0, [r0, #1]
   32ee4:	47a8      	blx	r5
   32ee6:	f884 0054 	strb.w	r0, [r4, #84]	; 0x54
		if (dev->com_rslt != 0)
   32eea:	b930      	cbnz	r0, 32efa <get_mem_page.part.3+0x26>
			dev->mem_page = reg & BME680_MEM_PAGE_MSK;
   32eec:	f89d 3007 	ldrb.w	r3, [sp, #7]
   32ef0:	f003 0310 	and.w	r3, r3, #16
   32ef4:	70e3      	strb	r3, [r4, #3]
}
   32ef6:	b003      	add	sp, #12
   32ef8:	bd30      	pop	{r4, r5, pc}
			rslt = BME680_E_COM_FAIL;
   32efa:	f06f 0001 	mvn.w	r0, #1
   32efe:	e7fa      	b.n	32ef6 <get_mem_page.part.3+0x22>

00032f00 <boundary_check.isra.1.constprop.6>:
		if (*value > max) {
   32f00:	7803      	ldrb	r3, [r0, #0]
   32f02:	428b      	cmp	r3, r1
			*value = max;
   32f04:	bf84      	itt	hi
   32f06:	7001      	strbhi	r1, [r0, #0]
			dev->info_msg |= BME680_I_MAX_CORRECTION;
   32f08:	7813      	ldrbhi	r3, [r2, #0]
}
   32f0a:	f04f 0000 	mov.w	r0, #0
			dev->info_msg |= BME680_I_MAX_CORRECTION;
   32f0e:	bf84      	itt	hi
   32f10:	f043 0302 	orrhi.w	r3, r3, #2
   32f14:	7013      	strbhi	r3, [r2, #0]
}
   32f16:	4770      	bx	lr

00032f18 <bme680_get_regs>:
{
   32f18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   32f1c:	4606      	mov	r6, r0
	rslt = null_ptr_check(dev);
   32f1e:	4618      	mov	r0, r3
{
   32f20:	4688      	mov	r8, r1
   32f22:	4691      	mov	r9, r2
   32f24:	461d      	mov	r5, r3
	rslt = null_ptr_check(dev);
   32f26:	f7ff ff93 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   32f2a:	4604      	mov	r4, r0
   32f2c:	b9a8      	cbnz	r0, 32f5a <bme680_get_regs+0x42>
		if (dev->intf == BME680_SPI_INTF) {
   32f2e:	78ab      	ldrb	r3, [r5, #2]
   32f30:	b93b      	cbnz	r3, 32f42 <bme680_get_regs+0x2a>
			rslt = set_mem_page(reg_addr, dev);
   32f32:	4629      	mov	r1, r5
   32f34:	4630      	mov	r0, r6
   32f36:	f7ff ff99 	bl	32e6c <set_mem_page>
			if (rslt == BME680_OK)
   32f3a:	4604      	mov	r4, r0
   32f3c:	b908      	cbnz	r0, 32f42 <bme680_get_regs+0x2a>
				reg_addr = reg_addr | BME680_SPI_RD_MSK;
   32f3e:	f046 0680 	orr.w	r6, r6, #128	; 0x80
		dev->com_rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
   32f42:	6caf      	ldr	r7, [r5, #72]	; 0x48
   32f44:	464b      	mov	r3, r9
   32f46:	4642      	mov	r2, r8
   32f48:	4631      	mov	r1, r6
   32f4a:	7868      	ldrb	r0, [r5, #1]
   32f4c:	47b8      	blx	r7
		if (dev->com_rslt != 0)
   32f4e:	2800      	cmp	r0, #0
			rslt = BME680_E_COM_FAIL;
   32f50:	bf18      	it	ne
   32f52:	f06f 0401 	mvnne.w	r4, #1
		dev->com_rslt = dev->read(dev->dev_id, reg_addr, reg_data, len);
   32f56:	f885 0054 	strb.w	r0, [r5, #84]	; 0x54
}
   32f5a:	4620      	mov	r0, r4
   32f5c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00032f60 <bme680_set_regs>:
{
   32f60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   32f64:	461e      	mov	r6, r3
   32f66:	b08a      	sub	sp, #40	; 0x28
   32f68:	4680      	mov	r8, r0
   32f6a:	4689      	mov	r9, r1
   32f6c:	4615      	mov	r5, r2
	uint8_t tmp_buff[BME680_TMP_BUFFER_LENGTH] = { 0 };
   32f6e:	2100      	movs	r1, #0
   32f70:	2228      	movs	r2, #40	; 0x28
   32f72:	4668      	mov	r0, sp
   32f74:	f006 f86a 	bl	3904c <memset>
	rslt = null_ptr_check(dev);
   32f78:	4630      	mov	r0, r6
   32f7a:	f7ff ff69 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   32f7e:	bb68      	cbnz	r0, 32fdc <bme680_set_regs+0x7c>
		if ((len > 0) && (len < BME680_TMP_BUFFER_LENGTH / 2)) {
   32f80:	1e6b      	subs	r3, r5, #1
   32f82:	2b12      	cmp	r3, #18
   32f84:	d82d      	bhi.n	32fe2 <bme680_set_regs+0x82>
   32f86:	466c      	mov	r4, sp
   32f88:	4607      	mov	r7, r0
			for (index = 0; index < len; index++) {
   32f8a:	fa1f fa85 	uxth.w	sl, r5
				if (dev->intf == BME680_SPI_INTF) {
   32f8e:	78b2      	ldrb	r2, [r6, #2]
   32f90:	f818 3007 	ldrb.w	r3, [r8, r7]
   32f94:	b93a      	cbnz	r2, 32fa6 <bme680_set_regs+0x46>
					rslt = set_mem_page(reg_addr[index], dev);
   32f96:	4618      	mov	r0, r3
   32f98:	4631      	mov	r1, r6
   32f9a:	f7ff ff67 	bl	32e6c <set_mem_page>
					tmp_buff[(2 * index)] = reg_addr[index] & BME680_SPI_WR_MSK;
   32f9e:	f818 3007 	ldrb.w	r3, [r8, r7]
   32fa2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
					tmp_buff[(2 * index)] = reg_addr[index];
   32fa6:	7023      	strb	r3, [r4, #0]
				tmp_buff[(2 * index) + 1] = reg_data[index];
   32fa8:	f819 3007 	ldrb.w	r3, [r9, r7]
   32fac:	3701      	adds	r7, #1
   32fae:	7063      	strb	r3, [r4, #1]
			for (index = 0; index < len; index++) {
   32fb0:	b2bb      	uxth	r3, r7
   32fb2:	4553      	cmp	r3, sl
   32fb4:	f104 0402 	add.w	r4, r4, #2
   32fb8:	d3e9      	bcc.n	32f8e <bme680_set_regs+0x2e>
			if (rslt == BME680_OK) {
   32fba:	b978      	cbnz	r0, 32fdc <bme680_set_regs+0x7c>
				dev->com_rslt = dev->write(dev->dev_id, tmp_buff[0], &tmp_buff[1], (2 * len) - 1);
   32fbc:	006b      	lsls	r3, r5, #1
   32fbe:	3b01      	subs	r3, #1
   32fc0:	6cf4      	ldr	r4, [r6, #76]	; 0x4c
   32fc2:	b29b      	uxth	r3, r3
   32fc4:	f10d 0201 	add.w	r2, sp, #1
   32fc8:	f89d 1000 	ldrb.w	r1, [sp]
   32fcc:	7870      	ldrb	r0, [r6, #1]
   32fce:	47a0      	blx	r4
					rslt = BME680_E_COM_FAIL;
   32fd0:	2800      	cmp	r0, #0
				dev->com_rslt = dev->write(dev->dev_id, tmp_buff[0], &tmp_buff[1], (2 * len) - 1);
   32fd2:	f886 0054 	strb.w	r0, [r6, #84]	; 0x54
					rslt = BME680_E_COM_FAIL;
   32fd6:	bf18      	it	ne
   32fd8:	f06f 0001 	mvnne.w	r0, #1
}
   32fdc:	b00a      	add	sp, #40	; 0x28
   32fde:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			rslt = BME680_E_INVALID_LENGTH;
   32fe2:	f06f 0003 	mvn.w	r0, #3
   32fe6:	e7f9      	b.n	32fdc <bme680_set_regs+0x7c>

00032fe8 <bme680_soft_reset>:
	uint8_t reg_addr = BME680_SOFT_RESET_ADDR;
   32fe8:	23e0      	movs	r3, #224	; 0xe0
{
   32fea:	b537      	push	{r0, r1, r2, r4, r5, lr}
	uint8_t reg_addr = BME680_SOFT_RESET_ADDR;
   32fec:	f88d 3006 	strb.w	r3, [sp, #6]
	uint8_t soft_rst_cmd = BME680_SOFT_RESET_CMD;
   32ff0:	23b6      	movs	r3, #182	; 0xb6
{
   32ff2:	4605      	mov	r5, r0
	uint8_t soft_rst_cmd = BME680_SOFT_RESET_CMD;
   32ff4:	f88d 3007 	strb.w	r3, [sp, #7]
	rslt = null_ptr_check(dev);
   32ff8:	f7ff ff2a 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   32ffc:	4604      	mov	r4, r0
   32ffe:	b970      	cbnz	r0, 3301e <bme680_soft_reset+0x36>
		if (dev->intf == BME680_SPI_INTF)
   33000:	78ab      	ldrb	r3, [r5, #2]
   33002:	b17b      	cbz	r3, 33024 <bme680_soft_reset+0x3c>
			rslt = bme680_set_regs(&reg_addr, &soft_rst_cmd, 1, dev);
   33004:	462b      	mov	r3, r5
   33006:	2201      	movs	r2, #1
   33008:	f10d 0107 	add.w	r1, sp, #7
   3300c:	f10d 0006 	add.w	r0, sp, #6
   33010:	f7ff ffa6 	bl	32f60 <bme680_set_regs>
   33014:	4604      	mov	r4, r0
			dev->delay_ms(BME680_RESET_PERIOD);
   33016:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   33018:	200a      	movs	r0, #10
   3301a:	4798      	blx	r3
			if (rslt == BME680_OK) {
   3301c:	b14c      	cbz	r4, 33032 <bme680_soft_reset+0x4a>
}
   3301e:	4620      	mov	r0, r4
   33020:	b003      	add	sp, #12
   33022:	bd30      	pop	{r4, r5, pc}
	if (rslt == BME680_OK) {
   33024:	4628      	mov	r0, r5
   33026:	f7ff ff55 	bl	32ed4 <get_mem_page.part.3>
		if (rslt == BME680_OK) {
   3302a:	4604      	mov	r4, r0
   3302c:	2800      	cmp	r0, #0
   3302e:	d1f6      	bne.n	3301e <bme680_soft_reset+0x36>
   33030:	e7e8      	b.n	33004 <bme680_soft_reset+0x1c>
				if (dev->intf == BME680_SPI_INTF)
   33032:	78ab      	ldrb	r3, [r5, #2]
   33034:	2b00      	cmp	r3, #0
   33036:	d1f2      	bne.n	3301e <bme680_soft_reset+0x36>
	rslt = null_ptr_check(dev);
   33038:	4628      	mov	r0, r5
   3303a:	f7ff ff09 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   3303e:	4604      	mov	r4, r0
   33040:	2800      	cmp	r0, #0
   33042:	d1ec      	bne.n	3301e <bme680_soft_reset+0x36>
   33044:	4628      	mov	r0, r5
   33046:	f7ff ff45 	bl	32ed4 <get_mem_page.part.3>
   3304a:	4604      	mov	r4, r0
   3304c:	e7e7      	b.n	3301e <bme680_soft_reset+0x36>

0003304e <bme680_init>:
{
   3304e:	b530      	push	{r4, r5, lr}
   33050:	b08d      	sub	sp, #52	; 0x34
   33052:	4604      	mov	r4, r0
	rslt = null_ptr_check(dev);
   33054:	f7ff fefc 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   33058:	4605      	mov	r5, r0
   3305a:	2800      	cmp	r0, #0
   3305c:	f040 80c8 	bne.w	331f0 <bme680_init+0x1a2>
		rslt = bme680_soft_reset(dev);
   33060:	4620      	mov	r0, r4
   33062:	f7ff ffc1 	bl	32fe8 <bme680_soft_reset>
		if (rslt == BME680_OK) {
   33066:	4605      	mov	r5, r0
   33068:	2800      	cmp	r0, #0
   3306a:	f040 80c1 	bne.w	331f0 <bme680_init+0x1a2>
			rslt = bme680_get_regs(BME680_CHIP_ID_ADDR, &dev->chip_id, 1, dev);
   3306e:	4623      	mov	r3, r4
   33070:	2201      	movs	r2, #1
   33072:	4621      	mov	r1, r4
   33074:	20d0      	movs	r0, #208	; 0xd0
   33076:	f7ff ff4f 	bl	32f18 <bme680_get_regs>
			if (rslt == BME680_OK) {
   3307a:	4605      	mov	r5, r0
   3307c:	2800      	cmp	r0, #0
   3307e:	f040 80b7 	bne.w	331f0 <bme680_init+0x1a2>
				if (dev->chip_id == BME680_CHIP_ID) {
   33082:	7823      	ldrb	r3, [r4, #0]
   33084:	2b61      	cmp	r3, #97	; 0x61
   33086:	f040 80b6 	bne.w	331f6 <bme680_init+0x1a8>
	uint8_t coeff_array[BME680_COEFF_SIZE] = { 0 };
   3308a:	4601      	mov	r1, r0
   3308c:	2229      	movs	r2, #41	; 0x29
   3308e:	a801      	add	r0, sp, #4
   33090:	f005 ffdc 	bl	3904c <memset>
	rslt = null_ptr_check(dev);
   33094:	4620      	mov	r0, r4
	uint8_t temp_var = 0; /* Temporary variable */
   33096:	f88d 5003 	strb.w	r5, [sp, #3]
	rslt = null_ptr_check(dev);
   3309a:	f7ff fed9 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   3309e:	4605      	mov	r5, r0
   330a0:	2800      	cmp	r0, #0
   330a2:	f040 80a5 	bne.w	331f0 <bme680_init+0x1a2>
		rslt = bme680_get_regs(BME680_COEFF_ADDR1, coeff_array, BME680_COEFF_ADDR1_LEN, dev);
   330a6:	4623      	mov	r3, r4
   330a8:	2219      	movs	r2, #25
   330aa:	a901      	add	r1, sp, #4
   330ac:	2089      	movs	r0, #137	; 0x89
   330ae:	f7ff ff33 	bl	32f18 <bme680_get_regs>
		if (rslt == BME680_OK)
   330b2:	4605      	mov	r5, r0
   330b4:	b938      	cbnz	r0, 330c6 <bme680_init+0x78>
			rslt = bme680_get_regs(BME680_COEFF_ADDR2, &coeff_array[BME680_COEFF_ADDR1_LEN]
   330b6:	4623      	mov	r3, r4
   330b8:	2210      	movs	r2, #16
   330ba:	f10d 011d 	add.w	r1, sp, #29
   330be:	20e1      	movs	r0, #225	; 0xe1
   330c0:	f7ff ff2a 	bl	32f18 <bme680_get_regs>
   330c4:	4605      	mov	r5, r0
		dev->calib.par_t1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T1_MSB_REG],
   330c6:	f89d 2026 	ldrb.w	r2, [sp, #38]	; 0x26
   330ca:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   330ce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   330d2:	82e3      	strh	r3, [r4, #22]
		dev->calib.par_t2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_T2_MSB_REG],
   330d4:	f89d 2006 	ldrb.w	r2, [sp, #6]
   330d8:	f89d 3005 	ldrb.w	r3, [sp, #5]
   330dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   330e0:	8323      	strh	r3, [r4, #24]
		dev->calib.par_t3 = (int8_t) (coeff_array[BME680_T3_REG]);
   330e2:	f89d 3007 	ldrb.w	r3, [sp, #7]
		dev->calib.par_p1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P1_MSB_REG],
   330e6:	f89d 200a 	ldrb.w	r2, [sp, #10]
		dev->calib.par_t3 = (int8_t) (coeff_array[BME680_T3_REG]);
   330ea:	76a3      	strb	r3, [r4, #26]
		dev->calib.par_p1 = (uint16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P1_MSB_REG],
   330ec:	f89d 3009 	ldrb.w	r3, [sp, #9]
   330f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   330f4:	83a3      	strh	r3, [r4, #28]
		dev->calib.par_p2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P2_MSB_REG],
   330f6:	f89d 200c 	ldrb.w	r2, [sp, #12]
   330fa:	f89d 300b 	ldrb.w	r3, [sp, #11]
   330fe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33102:	83e3      	strh	r3, [r4, #30]
		dev->calib.par_p3 = (int8_t) coeff_array[BME680_P3_REG];
   33104:	f89d 300d 	ldrb.w	r3, [sp, #13]
		dev->calib.par_p4 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P4_MSB_REG],
   33108:	f89d 2010 	ldrb.w	r2, [sp, #16]
		dev->calib.par_p3 = (int8_t) coeff_array[BME680_P3_REG];
   3310c:	f884 3020 	strb.w	r3, [r4, #32]
		dev->calib.par_p4 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P4_MSB_REG],
   33110:	f89d 300f 	ldrb.w	r3, [sp, #15]
   33114:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33118:	8463      	strh	r3, [r4, #34]	; 0x22
		dev->calib.par_p5 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P5_MSB_REG],
   3311a:	f89d 2012 	ldrb.w	r2, [sp, #18]
   3311e:	f89d 3011 	ldrb.w	r3, [sp, #17]
   33122:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33126:	84a3      	strh	r3, [r4, #36]	; 0x24
		dev->calib.par_p6 = (int8_t) (coeff_array[BME680_P6_REG]);
   33128:	f89d 3014 	ldrb.w	r3, [sp, #20]
		dev->calib.par_p8 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P8_MSB_REG],
   3312c:	f89d 2018 	ldrb.w	r2, [sp, #24]
		dev->calib.par_p6 = (int8_t) (coeff_array[BME680_P6_REG]);
   33130:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
		dev->calib.par_p7 = (int8_t) (coeff_array[BME680_P7_REG]);
   33134:	f89d 3013 	ldrb.w	r3, [sp, #19]
   33138:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
		dev->calib.par_p8 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P8_MSB_REG],
   3313c:	f89d 3017 	ldrb.w	r3, [sp, #23]
   33140:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33144:	8523      	strh	r3, [r4, #40]	; 0x28
		dev->calib.par_p9 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_P9_MSB_REG],
   33146:	f89d 201a 	ldrb.w	r2, [sp, #26]
   3314a:	f89d 3019 	ldrb.w	r3, [sp, #25]
   3314e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33152:	8563      	strh	r3, [r4, #42]	; 0x2a
		dev->calib.par_p10 = (uint8_t) (coeff_array[BME680_P10_REG]);
   33154:	f89d 301b 	ldrb.w	r3, [sp, #27]
		dev->calib.par_h1 = (uint16_t) (((uint16_t) coeff_array[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
   33158:	f89d 101f 	ldrb.w	r1, [sp, #31]
		dev->calib.par_p10 = (uint8_t) (coeff_array[BME680_P10_REG]);
   3315c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
			| (coeff_array[BME680_H1_LSB_REG] & BME680_BIT_H1_DATA_MSK));
   33160:	f89d 301e 	ldrb.w	r3, [sp, #30]
   33164:	f003 020f 	and.w	r2, r3, #15
   33168:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
		dev->calib.par_h1 = (uint16_t) (((uint16_t) coeff_array[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
   3316c:	8122      	strh	r2, [r4, #8]
		dev->calib.par_h2 = (uint16_t) (((uint16_t) coeff_array[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
   3316e:	f89d 201d 	ldrb.w	r2, [sp, #29]
			| ((coeff_array[BME680_H2_LSB_REG]) >> BME680_HUM_REG_SHIFT_VAL));
   33172:	091b      	lsrs	r3, r3, #4
   33174:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
		dev->calib.par_h2 = (uint16_t) (((uint16_t) coeff_array[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL)
   33178:	8163      	strh	r3, [r4, #10]
		dev->calib.par_h3 = (int8_t) coeff_array[BME680_H3_REG];
   3317a:	9b08      	ldr	r3, [sp, #32]
		dev->calib.par_gh2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_GH2_MSB_REG],
   3317c:	f89d 2028 	ldrb.w	r2, [sp, #40]	; 0x28
		dev->calib.par_h3 = (int8_t) coeff_array[BME680_H3_REG];
   33180:	60e3      	str	r3, [r4, #12]
		dev->calib.par_h7 = (int8_t) coeff_array[BME680_H7_REG];
   33182:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   33186:	7423      	strb	r3, [r4, #16]
		dev->calib.par_gh1 = (int8_t) coeff_array[BME680_GH1_REG];
   33188:	f89d 3029 	ldrb.w	r3, [sp, #41]	; 0x29
   3318c:	7463      	strb	r3, [r4, #17]
		dev->calib.par_gh2 = (int16_t) (BME680_CONCAT_BYTES(coeff_array[BME680_GH2_MSB_REG],
   3318e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
   33192:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   33196:	8263      	strh	r3, [r4, #18]
		dev->calib.par_gh3 = (int8_t) coeff_array[BME680_GH3_REG];
   33198:	f89d 302a 	ldrb.w	r3, [sp, #42]	; 0x2a
   3319c:	7523      	strb	r3, [r4, #20]
		if (rslt == BME680_OK) {
   3319e:	bb15      	cbnz	r5, 331e6 <bme680_init+0x198>
			rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_RANGE_ADDR, &temp_var, 1, dev);
   331a0:	4623      	mov	r3, r4
   331a2:	2201      	movs	r2, #1
   331a4:	f10d 0103 	add.w	r1, sp, #3
   331a8:	2002      	movs	r0, #2
   331aa:	f7ff feb5 	bl	32f18 <bme680_get_regs>
			dev->calib.res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16);
   331ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
			if (rslt == BME680_OK) {
   331b2:	4605      	mov	r5, r0
			dev->calib.res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16);
   331b4:	f3c3 1301 	ubfx	r3, r3, #4, #2
   331b8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
			if (rslt == BME680_OK) {
   331bc:	b998      	cbnz	r0, 331e6 <bme680_init+0x198>
				rslt = bme680_get_regs(BME680_ADDR_RES_HEAT_VAL_ADDR, &temp_var, 1, dev);
   331be:	4623      	mov	r3, r4
   331c0:	2201      	movs	r2, #1
   331c2:	f10d 0103 	add.w	r1, sp, #3
   331c6:	f7ff fea7 	bl	32f18 <bme680_get_regs>
				dev->calib.res_heat_val = (int8_t) temp_var;
   331ca:	f89d 3003 	ldrb.w	r3, [sp, #3]
				if (rslt == BME680_OK)
   331ce:	4605      	mov	r5, r0
				dev->calib.res_heat_val = (int8_t) temp_var;
   331d0:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
				if (rslt == BME680_OK)
   331d4:	b938      	cbnz	r0, 331e6 <bme680_init+0x198>
					rslt = bme680_get_regs(BME680_ADDR_RANGE_SW_ERR_ADDR, &temp_var, 1, dev);
   331d6:	4623      	mov	r3, r4
   331d8:	2201      	movs	r2, #1
   331da:	f10d 0103 	add.w	r1, sp, #3
   331de:	2004      	movs	r0, #4
   331e0:	f7ff fe9a 	bl	32f18 <bme680_get_regs>
   331e4:	4605      	mov	r5, r0
		dev->calib.range_sw_err = ((int8_t) temp_var & (int8_t) BME680_RSERROR_MSK) / 16;
   331e6:	f99d 3003 	ldrsb.w	r3, [sp, #3]
   331ea:	111b      	asrs	r3, r3, #4
   331ec:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
}
   331f0:	4628      	mov	r0, r5
   331f2:	b00d      	add	sp, #52	; 0x34
   331f4:	bd30      	pop	{r4, r5, pc}
					rslt = BME680_E_DEV_NOT_FOUND;
   331f6:	f06f 0502 	mvn.w	r5, #2
   331fa:	e7f9      	b.n	331f0 <bme680_init+0x1a2>

000331fc <bme680_set_sensor_mode>:
	uint8_t reg_addr = BME680_CONF_T_P_MODE_ADDR;
   331fc:	2374      	movs	r3, #116	; 0x74
{
   331fe:	b537      	push	{r0, r1, r2, r4, r5, lr}
   33200:	4604      	mov	r4, r0
	uint8_t reg_addr = BME680_CONF_T_P_MODE_ADDR;
   33202:	f88d 3007 	strb.w	r3, [sp, #7]
	rslt = null_ptr_check(dev);
   33206:	f7ff fe23 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   3320a:	bba0      	cbnz	r0, 33276 <bme680_set_sensor_mode+0x7a>
	uint8_t pow_mode = 0;
   3320c:	4605      	mov	r5, r0
			rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &tmp_pow_mode, 1, dev);
   3320e:	4623      	mov	r3, r4
   33210:	2201      	movs	r2, #1
   33212:	f10d 0106 	add.w	r1, sp, #6
   33216:	2074      	movs	r0, #116	; 0x74
   33218:	f7ff fe7e 	bl	32f18 <bme680_get_regs>
			if (rslt == BME680_OK) {
   3321c:	b9a0      	cbnz	r0, 33248 <bme680_set_sensor_mode+0x4c>
				pow_mode = (tmp_pow_mode & BME680_MODE_MSK);
   3321e:	f89d 3006 	ldrb.w	r3, [sp, #6]
				if (pow_mode != BME680_SLEEP_MODE) {
   33222:	f013 0503 	ands.w	r5, r3, #3
   33226:	d011      	beq.n	3324c <bme680_set_sensor_mode+0x50>
					tmp_pow_mode = tmp_pow_mode & (~BME680_MODE_MSK); /* Set to sleep */
   33228:	f023 0303 	bic.w	r3, r3, #3
   3322c:	f88d 3006 	strb.w	r3, [sp, #6]
					rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   33230:	2201      	movs	r2, #1
   33232:	4623      	mov	r3, r4
   33234:	f10d 0106 	add.w	r1, sp, #6
   33238:	f10d 0007 	add.w	r0, sp, #7
   3323c:	f7ff fe90 	bl	32f60 <bme680_set_regs>
					dev->delay_ms(BME680_POLL_PERIOD_MS);
   33240:	6d23      	ldr	r3, [r4, #80]	; 0x50
   33242:	200a      	movs	r0, #10
   33244:	4798      	blx	r3
   33246:	e7e2      	b.n	3320e <bme680_set_sensor_mode+0x12>
		} while (pow_mode != BME680_SLEEP_MODE);
   33248:	2d00      	cmp	r5, #0
   3324a:	d1e0      	bne.n	3320e <bme680_set_sensor_mode+0x12>
		if (dev->power_mode != BME680_SLEEP_MODE) {
   3324c:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
   33250:	b18a      	cbz	r2, 33276 <bme680_set_sensor_mode+0x7a>
			tmp_pow_mode = (tmp_pow_mode & ~BME680_MODE_MSK) | (dev->power_mode & BME680_MODE_MSK);
   33252:	f89d 3006 	ldrb.w	r3, [sp, #6]
   33256:	f002 0203 	and.w	r2, r2, #3
   3325a:	f023 0303 	bic.w	r3, r3, #3
   3325e:	4313      	orrs	r3, r2
   33260:	f88d 3006 	strb.w	r3, [sp, #6]
			if (rslt == BME680_OK)
   33264:	b938      	cbnz	r0, 33276 <bme680_set_sensor_mode+0x7a>
				rslt = bme680_set_regs(&reg_addr, &tmp_pow_mode, 1, dev);
   33266:	4623      	mov	r3, r4
   33268:	2201      	movs	r2, #1
   3326a:	f10d 0106 	add.w	r1, sp, #6
   3326e:	f10d 0007 	add.w	r0, sp, #7
   33272:	f7ff fe75 	bl	32f60 <bme680_set_regs>
}
   33276:	b003      	add	sp, #12
   33278:	bd30      	pop	{r4, r5, pc}

0003327a <bme680_get_sensor_mode>:
{
   3327a:	b513      	push	{r0, r1, r4, lr}
   3327c:	4604      	mov	r4, r0
	rslt = null_ptr_check(dev);
   3327e:	f7ff fde7 	bl	32e50 <null_ptr_check>
	if (rslt == BME680_OK) {
   33282:	b960      	cbnz	r0, 3329e <bme680_get_sensor_mode+0x24>
		rslt = bme680_get_regs(BME680_CONF_T_P_MODE_ADDR, &mode, 1, dev);
   33284:	4623      	mov	r3, r4
   33286:	2201      	movs	r2, #1
   33288:	f10d 0107 	add.w	r1, sp, #7
   3328c:	2074      	movs	r0, #116	; 0x74
   3328e:	f7ff fe43 	bl	32f18 <bme680_get_regs>
		dev->power_mode = mode & BME680_MODE_MSK;
   33292:	f89d 3007 	ldrb.w	r3, [sp, #7]
   33296:	f003 0303 	and.w	r3, r3, #3
   3329a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
}
   3329e:	b002      	add	sp, #8
   332a0:	bd10      	pop	{r4, pc}

000332a2 <arch_printk_char_out>:
}
   332a2:	2000      	movs	r0, #0
   332a4:	4770      	bx	lr

000332a6 <print_err>:
{
   332a6:	b570      	push	{r4, r5, r6, lr}
   332a8:	460d      	mov	r5, r1
   332aa:	4604      	mov	r4, r0
	out('E', ctx);
   332ac:	2045      	movs	r0, #69	; 0x45
   332ae:	47a0      	blx	r4
	out('R', ctx);
   332b0:	4629      	mov	r1, r5
   332b2:	2052      	movs	r0, #82	; 0x52
   332b4:	47a0      	blx	r4
	out('R', ctx);
   332b6:	4629      	mov	r1, r5
   332b8:	4623      	mov	r3, r4
}
   332ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
   332be:	2052      	movs	r0, #82	; 0x52
   332c0:	4718      	bx	r3

000332c2 <str_out>:
{
   332c2:	b530      	push	{r4, r5, lr}
   332c4:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
   332c6:	680c      	ldr	r4, [r1, #0]
   332c8:	1c55      	adds	r5, r2, #1
   332ca:	b114      	cbz	r4, 332d2 <str_out+0x10>
   332cc:	684b      	ldr	r3, [r1, #4]
   332ce:	4293      	cmp	r3, r2
   332d0:	dc01      	bgt.n	332d6 <str_out+0x14>
		ctx->count++;
   332d2:	608d      	str	r5, [r1, #8]
}
   332d4:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
   332d6:	3b01      	subs	r3, #1
   332d8:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
   332da:	bf08      	it	eq
   332dc:	2200      	moveq	r2, #0
   332de:	608d      	str	r5, [r1, #8]
   332e0:	bf0c      	ite	eq
   332e2:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
   332e4:	54a0      	strbne	r0, [r4, r2]
   332e6:	e7f5      	b.n	332d4 <str_out+0x12>

000332e8 <z_vprintk>:
{
   332e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
   332ec:	f04f 0800 	mov.w	r8, #0
{
   332f0:	4606      	mov	r6, r0
   332f2:	460f      	mov	r7, r1
	int min_width = -1;
   332f4:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
	enum pad_type padding = PAD_NONE;
   332f8:	46c1      	mov	r9, r8
{
   332fa:	b08b      	sub	sp, #44	; 0x2c
   332fc:	461c      	mov	r4, r3
	while (*fmt) {
   332fe:	1e53      	subs	r3, r2, #1
   33300:	9302      	str	r3, [sp, #8]
			might_format = 0;
   33302:	2500      	movs	r5, #0
					break;
   33304:	e005      	b.n	33312 <z_vprintk+0x2a>
		if (!might_format) {
   33306:	b96d      	cbnz	r5, 33324 <z_vprintk+0x3c>
			if (*fmt != '%') {
   33308:	2825      	cmp	r0, #37	; 0x25
   3330a:	f000 814f 	beq.w	335ac <z_vprintk+0x2c4>
				out((int)*fmt, ctx);
   3330e:	4639      	mov	r1, r7
   33310:	47b0      	blx	r6
	while (*fmt) {
   33312:	9b02      	ldr	r3, [sp, #8]
   33314:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   33318:	9302      	str	r3, [sp, #8]
   3331a:	2800      	cmp	r0, #0
   3331c:	d1f3      	bne.n	33306 <z_vprintk+0x1e>
}
   3331e:	b00b      	add	sp, #44	; 0x2c
   33320:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
   33324:	2864      	cmp	r0, #100	; 0x64
   33326:	d06e      	beq.n	33406 <z_vprintk+0x11e>
   33328:	d81a      	bhi.n	33360 <z_vprintk+0x78>
   3332a:	2839      	cmp	r0, #57	; 0x39
   3332c:	d80a      	bhi.n	33344 <z_vprintk+0x5c>
   3332e:	2831      	cmp	r0, #49	; 0x31
   33330:	d260      	bcs.n	333f4 <z_vprintk+0x10c>
   33332:	282d      	cmp	r0, #45	; 0x2d
   33334:	f000 8140 	beq.w	335b8 <z_vprintk+0x2d0>
   33338:	2830      	cmp	r0, #48	; 0x30
   3333a:	d04c      	beq.n	333d6 <z_vprintk+0xee>
   3333c:	2825      	cmp	r0, #37	; 0x25
   3333e:	d107      	bne.n	33350 <z_vprintk+0x68>
				out((int)'%', ctx);
   33340:	4639      	mov	r1, r7
   33342:	e00b      	b.n	3335c <z_vprintk+0x74>
			switch (*fmt) {
   33344:	2858      	cmp	r0, #88	; 0x58
   33346:	f000 80bb 	beq.w	334c0 <z_vprintk+0x1d8>
   3334a:	2863      	cmp	r0, #99	; 0x63
   3334c:	f000 812a 	beq.w	335a4 <z_vprintk+0x2bc>
					out((int)'%', ctx);
   33350:	4639      	mov	r1, r7
   33352:	2025      	movs	r0, #37	; 0x25
   33354:	47b0      	blx	r6
					out((int)*fmt, ctx);
   33356:	4639      	mov	r1, r7
   33358:	9b02      	ldr	r3, [sp, #8]
   3335a:	7818      	ldrb	r0, [r3, #0]
   3335c:	47b0      	blx	r6
   3335e:	e7d0      	b.n	33302 <z_vprintk+0x1a>
			switch (*fmt) {
   33360:	2870      	cmp	r0, #112	; 0x70
   33362:	f000 80a3 	beq.w	334ac <z_vprintk+0x1c4>
   33366:	d811      	bhi.n	3338c <z_vprintk+0xa4>
   33368:	2869      	cmp	r0, #105	; 0x69
   3336a:	d04c      	beq.n	33406 <z_vprintk+0x11e>
   3336c:	286c      	cmp	r0, #108	; 0x6c
   3336e:	d105      	bne.n	3337c <z_vprintk+0x94>
				} else if (*fmt == 'l' && length_mod == 'l') {
   33370:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   33374:	d12a      	bne.n	333cc <z_vprintk+0xe4>
					length_mod = 'L';
   33376:	f04f 084c 	mov.w	r8, #76	; 0x4c
   3337a:	e7ca      	b.n	33312 <z_vprintk+0x2a>
			switch (*fmt) {
   3337c:	2868      	cmp	r0, #104	; 0x68
   3337e:	d1e7      	bne.n	33350 <z_vprintk+0x68>
				if (*fmt == 'h' && length_mod == 'h') {
   33380:	f1b8 0f68 	cmp.w	r8, #104	; 0x68
   33384:	d122      	bne.n	333cc <z_vprintk+0xe4>
					length_mod = 'H';
   33386:	f04f 0848 	mov.w	r8, #72	; 0x48
   3338a:	e7c2      	b.n	33312 <z_vprintk+0x2a>
			switch (*fmt) {
   3338c:	2875      	cmp	r0, #117	; 0x75
   3338e:	d071      	beq.n	33474 <z_vprintk+0x18c>
   33390:	d818      	bhi.n	333c4 <z_vprintk+0xdc>
   33392:	2873      	cmp	r0, #115	; 0x73
   33394:	d1dc      	bne.n	33350 <z_vprintk+0x68>
				char *s = va_arg(ap, char *);
   33396:	f854 5b04 	ldr.w	r5, [r4], #4
				while (*s) {
   3339a:	46ab      	mov	fp, r5
   3339c:	465b      	mov	r3, fp
   3339e:	f81b 0b01 	ldrb.w	r0, [fp], #1
   333a2:	2800      	cmp	r0, #0
   333a4:	f040 80fb 	bne.w	3359e <z_vprintk+0x2b6>
				if (padding == PAD_SPACE_AFTER) {
   333a8:	f1b9 0f03 	cmp.w	r9, #3
   333ac:	f040 810a 	bne.w	335c4 <z_vprintk+0x2dc>
					int remaining = min_width - (s - start);
   333b0:	1b5d      	subs	r5, r3, r5
   333b2:	ebaa 0505 	sub.w	r5, sl, r5
					while (remaining-- > 0) {
   333b6:	2d00      	cmp	r5, #0
   333b8:	dda3      	ble.n	33302 <z_vprintk+0x1a>
						out(' ', ctx);
   333ba:	4639      	mov	r1, r7
   333bc:	2020      	movs	r0, #32
   333be:	47b0      	blx	r6
   333c0:	3d01      	subs	r5, #1
   333c2:	e7f8      	b.n	333b6 <z_vprintk+0xce>
			switch (*fmt) {
   333c4:	2878      	cmp	r0, #120	; 0x78
   333c6:	d07b      	beq.n	334c0 <z_vprintk+0x1d8>
   333c8:	287a      	cmp	r0, #122	; 0x7a
   333ca:	d1c1      	bne.n	33350 <z_vprintk+0x68>
				} else if (length_mod == 0) {
   333cc:	f1b8 0f00 	cmp.w	r8, #0
   333d0:	d1be      	bne.n	33350 <z_vprintk+0x68>
   333d2:	4680      	mov	r8, r0
   333d4:	e79d      	b.n	33312 <z_vprintk+0x2a>
				if (min_width < 0 && padding == PAD_NONE) {
   333d6:	f1ba 0f00 	cmp.w	sl, #0
   333da:	da0e      	bge.n	333fa <z_vprintk+0x112>
   333dc:	f1b9 0f00 	cmp.w	r9, #0
   333e0:	f000 80ed 	beq.w	335be <z_vprintk+0x2d6>
					min_width = *fmt - '0';
   333e4:	f1a0 0a30 	sub.w	sl, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
   333e8:	f1b9 0f00 	cmp.w	r9, #0
   333ec:	bf08      	it	eq
   333ee:	f04f 0902 	moveq.w	r9, #2
   333f2:	e78e      	b.n	33312 <z_vprintk+0x2a>
				if (min_width < 0) {
   333f4:	f1ba 0f00 	cmp.w	sl, #0
   333f8:	dbf4      	blt.n	333e4 <z_vprintk+0xfc>
					min_width = 10 * min_width + *fmt - '0';
   333fa:	230a      	movs	r3, #10
   333fc:	fb03 0a0a 	mla	sl, r3, sl, r0
   33400:	f1aa 0a30 	sub.w	sl, sl, #48	; 0x30
   33404:	e7f0      	b.n	333e8 <z_vprintk+0x100>
				if (length_mod == 'z') {
   33406:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   3340a:	d102      	bne.n	33412 <z_vprintk+0x12a>
					d = va_arg(ap, int);
   3340c:	f854 5b04 	ldr.w	r5, [r4], #4
   33410:	e01f      	b.n	33452 <z_vprintk+0x16a>
				} else if (length_mod == 'l') {
   33412:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   33416:	d0f9      	beq.n	3340c <z_vprintk+0x124>
				} else if (length_mod == 'L') {
   33418:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   3341c:	d1f6      	bne.n	3340c <z_vprintk+0x124>
					long long lld = va_arg(ap, long long);
   3341e:	3407      	adds	r4, #7
   33420:	f024 0407 	bic.w	r4, r4, #7
   33424:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (lld > __LONG_MAX__ ||
   33428:	f112 4100 	adds.w	r1, r2, #2147483648	; 0x80000000
   3342c:	9106      	str	r1, [sp, #24]
   3342e:	f143 0100 	adc.w	r1, r3, #0
   33432:	9107      	str	r1, [sp, #28]
   33434:	2100      	movs	r1, #0
   33436:	e9dd bc06 	ldrd	fp, ip, [sp, #24]
   3343a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3343e:	4561      	cmp	r1, ip
   33440:	bf08      	it	eq
   33442:	4558      	cmpeq	r0, fp
   33444:	d204      	bcs.n	33450 <z_vprintk+0x168>
						print_err(out, ctx);
   33446:	4639      	mov	r1, r7
   33448:	4630      	mov	r0, r6
   3344a:	f7ff ff2c 	bl	332a6 <print_err>
						break;
   3344e:	e758      	b.n	33302 <z_vprintk+0x1a>
					d = lld;
   33450:	4615      	mov	r5, r2
				if (d < 0) {
   33452:	2d00      	cmp	r5, #0
   33454:	da05      	bge.n	33462 <z_vprintk+0x17a>
					out((int)'-', ctx);
   33456:	4639      	mov	r1, r7
   33458:	202d      	movs	r0, #45	; 0x2d
   3345a:	47b0      	blx	r6
					d = -d;
   3345c:	426d      	negs	r5, r5
					min_width--;
   3345e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
				_printk_dec_ulong(out, ctx, d, padding,
   33462:	464b      	mov	r3, r9
   33464:	462a      	mov	r2, r5
   33466:	f8cd a000 	str.w	sl, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
   3346a:	4639      	mov	r1, r7
   3346c:	4630      	mov	r0, r6
   3346e:	f7e5 fa79 	bl	18964 <_printk_dec_ulong>
				break;
   33472:	e746      	b.n	33302 <z_vprintk+0x1a>
				if (length_mod == 'z') {
   33474:	f1b8 0f7a 	cmp.w	r8, #122	; 0x7a
   33478:	d102      	bne.n	33480 <z_vprintk+0x198>
					u = va_arg(ap, unsigned int);
   3347a:	f854 2b04 	ldr.w	r2, [r4], #4
   3347e:	e011      	b.n	334a4 <z_vprintk+0x1bc>
				} else if (length_mod == 'l') {
   33480:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   33484:	d0f9      	beq.n	3347a <z_vprintk+0x192>
				} else if (length_mod == 'L') {
   33486:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   3348a:	d1f6      	bne.n	3347a <z_vprintk+0x192>
					if (llu > ~0UL) {
   3348c:	2100      	movs	r1, #0
   3348e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
					unsigned long long llu =
   33492:	3407      	adds	r4, #7
   33494:	f024 0407 	bic.w	r4, r4, #7
   33498:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
   3349c:	4299      	cmp	r1, r3
   3349e:	bf08      	it	eq
   334a0:	4290      	cmpeq	r0, r2
   334a2:	d3d0      	bcc.n	33446 <z_vprintk+0x15e>
				_printk_dec_ulong(out, ctx, u, padding,
   334a4:	f8cd a000 	str.w	sl, [sp]
   334a8:	464b      	mov	r3, r9
   334aa:	e7de      	b.n	3346a <z_vprintk+0x182>
				out('0', ctx);
   334ac:	4639      	mov	r1, r7
   334ae:	2030      	movs	r0, #48	; 0x30
   334b0:	47b0      	blx	r6
				out('x', ctx);
   334b2:	4639      	mov	r1, r7
   334b4:	2078      	movs	r0, #120	; 0x78
   334b6:	47b0      	blx	r6
					min_width = 8;
   334b8:	f04f 0a08 	mov.w	sl, #8
				padding = PAD_ZERO_BEFORE;
   334bc:	f04f 0901 	mov.w	r9, #1
				if (*fmt == 'p') {
   334c0:	9b02      	ldr	r3, [sp, #8]
   334c2:	781b      	ldrb	r3, [r3, #0]
   334c4:	2b70      	cmp	r3, #112	; 0x70
   334c6:	d104      	bne.n	334d2 <z_vprintk+0x1ea>
					x = va_arg(ap, unsigned int);
   334c8:	f854 3b04 	ldr.w	r3, [r4], #4
   334cc:	9304      	str	r3, [sp, #16]
   334ce:	2300      	movs	r3, #0
   334d0:	e00d      	b.n	334ee <z_vprintk+0x206>
				} else if (length_mod == 'l') {
   334d2:	f1b8 0f6c 	cmp.w	r8, #108	; 0x6c
   334d6:	d0f7      	beq.n	334c8 <z_vprintk+0x1e0>
				} else if (length_mod == 'L') {
   334d8:	f1b8 0f4c 	cmp.w	r8, #76	; 0x4c
   334dc:	d1f4      	bne.n	334c8 <z_vprintk+0x1e0>
					x = va_arg(ap, unsigned long long);
   334de:	3407      	adds	r4, #7
   334e0:	f024 0307 	bic.w	r3, r4, #7
   334e4:	461c      	mov	r4, r3
   334e6:	f854 2b08 	ldr.w	r2, [r4], #8
   334ea:	685b      	ldr	r3, [r3, #4]
   334ec:	9204      	str	r2, [sp, #16]
	int digits = 0;
   334ee:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
   334f0:	2210      	movs	r2, #16
	int shift = sizeof(num) * 8;
   334f2:	f04f 0b40 	mov.w	fp, #64	; 0x40
	int digits = 0;
   334f6:	9103      	str	r1, [sp, #12]
	int found_largest_digit = 0;
   334f8:	9105      	str	r1, [sp, #20]
		shift -= 4;
   334fa:	f1ab 0b04 	sub.w	fp, fp, #4
		nibble = (num >> shift) & 0xf;
   334fe:	9804      	ldr	r0, [sp, #16]
   33500:	f1cb 0c20 	rsb	ip, fp, #32
   33504:	f1ab 0120 	sub.w	r1, fp, #32
   33508:	fa20 f00b 	lsr.w	r0, r0, fp
   3350c:	fa03 fc0c 	lsl.w	ip, r3, ip
   33510:	ea40 000c 	orr.w	r0, r0, ip
   33514:	fa23 f101 	lsr.w	r1, r3, r1
   33518:	4308      	orrs	r0, r1
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
   3351a:	f010 000f 	ands.w	r0, r0, #15
   3351e:	d106      	bne.n	3352e <z_vprintk+0x246>
   33520:	9905      	ldr	r1, [sp, #20]
   33522:	b911      	cbnz	r1, 3352a <z_vprintk+0x242>
   33524:	f1bb 0f00 	cmp.w	fp, #0
   33528:	d122      	bne.n	33570 <z_vprintk+0x288>
			nibble += nibble > 9 ? 87 : 48;
   3352a:	2130      	movs	r1, #48	; 0x30
   3352c:	e003      	b.n	33536 <z_vprintk+0x24e>
   3352e:	2809      	cmp	r0, #9
   33530:	bf8c      	ite	hi
   33532:	2157      	movhi	r1, #87	; 0x57
   33534:	2130      	movls	r1, #48	; 0x30
   33536:	4408      	add	r0, r1
			out((int)nibble, ctx);
   33538:	b240      	sxtb	r0, r0
   3353a:	4639      	mov	r1, r7
   3353c:	9308      	str	r3, [sp, #32]
   3353e:	9205      	str	r2, [sp, #20]
   33540:	47b0      	blx	r6
			digits++;
   33542:	9b03      	ldr	r3, [sp, #12]
	while (shift >= 4) {
   33544:	9a05      	ldr	r2, [sp, #20]
			digits++;
   33546:	3301      	adds	r3, #1
   33548:	9303      	str	r3, [sp, #12]
	while (shift >= 4) {
   3354a:	9b08      	ldr	r3, [sp, #32]
   3354c:	f1bb 0f00 	cmp.w	fp, #0
   33550:	d123      	bne.n	3359a <z_vprintk+0x2b2>
	if (padding == PAD_SPACE_AFTER) {
   33552:	f1b9 0f03 	cmp.w	r9, #3
   33556:	f47f aed4 	bne.w	33302 <z_vprintk+0x1a>
		remaining = min_width * 2 - digits;
   3355a:	9b03      	ldr	r3, [sp, #12]
   3355c:	ebc3 054a 	rsb	r5, r3, sl, lsl #1
		while (remaining-- > 0) {
   33560:	2d00      	cmp	r5, #0
   33562:	f77f aece 	ble.w	33302 <z_vprintk+0x1a>
			out(' ', ctx);
   33566:	4639      	mov	r1, r7
   33568:	2020      	movs	r0, #32
   3356a:	47b0      	blx	r6
   3356c:	3d01      	subs	r5, #1
   3356e:	e7f7      	b.n	33560 <z_vprintk+0x278>
		if (remaining-- <= min_width) {
   33570:	1e51      	subs	r1, r2, #1
   33572:	4592      	cmp	sl, r2
   33574:	9108      	str	r1, [sp, #32]
   33576:	db07      	blt.n	33588 <z_vprintk+0x2a0>
			if (padding == PAD_ZERO_BEFORE) {
   33578:	f1b9 0f01 	cmp.w	r9, #1
   3357c:	d106      	bne.n	3358c <z_vprintk+0x2a4>
				out('0', ctx);
   3357e:	4639      	mov	r1, r7
   33580:	2030      	movs	r0, #48	; 0x30
   33582:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   33584:	47b0      	blx	r6
   33586:	9b09      	ldr	r3, [sp, #36]	; 0x24
			nibble += nibble > 9 ? 87 : 48;
   33588:	9a08      	ldr	r2, [sp, #32]
   3358a:	e7b6      	b.n	334fa <z_vprintk+0x212>
			} else if (padding == PAD_SPACE_BEFORE) {
   3358c:	f1b9 0f02 	cmp.w	r9, #2
   33590:	d1fa      	bne.n	33588 <z_vprintk+0x2a0>
   33592:	9309      	str	r3, [sp, #36]	; 0x24
				out(' ', ctx);
   33594:	4639      	mov	r1, r7
   33596:	2020      	movs	r0, #32
   33598:	e7f4      	b.n	33584 <z_vprintk+0x29c>
			found_largest_digit = 1;
   3359a:	9505      	str	r5, [sp, #20]
   3359c:	e7ad      	b.n	334fa <z_vprintk+0x212>
					out((int)(*s++), ctx);
   3359e:	4639      	mov	r1, r7
   335a0:	47b0      	blx	r6
   335a2:	e6fb      	b.n	3339c <z_vprintk+0xb4>
				out(c, ctx);
   335a4:	4639      	mov	r1, r7
   335a6:	f854 0b04 	ldr.w	r0, [r4], #4
   335aa:	e6d7      	b.n	3335c <z_vprintk+0x74>
				length_mod = 0;
   335ac:	46a8      	mov	r8, r5
				padding = PAD_NONE;
   335ae:	46a9      	mov	r9, r5
				min_width = -1;
   335b0:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
				might_format = 1;
   335b4:	2501      	movs	r5, #1
   335b6:	e6ac      	b.n	33312 <z_vprintk+0x2a>
				padding = PAD_SPACE_AFTER;
   335b8:	f04f 0903 	mov.w	r9, #3
   335bc:	e6a9      	b.n	33312 <z_vprintk+0x2a>
					padding = PAD_ZERO_BEFORE;
   335be:	f04f 0901 	mov.w	r9, #1
   335c2:	e6a6      	b.n	33312 <z_vprintk+0x2a>
			might_format = 0;
   335c4:	4605      	mov	r5, r0
		++fmt;
   335c6:	e6a4      	b.n	33312 <z_vprintk+0x2a>

000335c8 <printk>:
{
   335c8:	b40f      	push	{r0, r1, r2, r3}
   335ca:	b507      	push	{r0, r1, r2, lr}
   335cc:	a904      	add	r1, sp, #16
   335ce:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
   335d2:	9101      	str	r1, [sp, #4]
		log_printk(fmt, ap);
   335d4:	f000 fb0a 	bl	33bec <log_printk>
}
   335d8:	b003      	add	sp, #12
   335da:	f85d eb04 	ldr.w	lr, [sp], #4
   335de:	b004      	add	sp, #16
   335e0:	4770      	bx	lr

000335e2 <snprintk>:
{
   335e2:	b40c      	push	{r2, r3}
   335e4:	b507      	push	{r0, r1, r2, lr}
   335e6:	ab04      	add	r3, sp, #16
   335e8:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
   335ec:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
   335ee:	f7e5 fa0b 	bl	18a08 <vsnprintk>
}
   335f2:	b003      	add	sp, #12
   335f4:	f85d eb04 	ldr.w	lr, [sp], #4
   335f8:	b002      	add	sp, #8
   335fa:	4770      	bx	lr

000335fc <sys_sem_give>:

	return 0;
}

int sys_sem_give(struct sys_sem *sem)
{
   335fc:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
   335fe:	f7fa fcf5 	bl	2dfec <z_impl_k_sem_give>
	k_sem_give(&sem->kernel_sem);

	return 0;
}
   33602:	2000      	movs	r0, #0
   33604:	bd08      	pop	{r3, pc}

00033606 <sys_sem_take>:

int sys_sem_take(struct sys_sem *sem, k_timeout_t timeout)
{
   33606:	b508      	push	{r3, lr}
	return z_impl_k_sem_take(sem, timeout);
   33608:	f7fa fd34 	bl	2e074 <z_impl_k_sem_take>
	int ret_value = 0;

	ret_value = k_sem_take(&sem->kernel_sem, timeout);
	if (ret_value == -EAGAIN || ret_value == -EBUSY) {
   3360c:	f110 0f0b 	cmn.w	r0, #11
   33610:	d005      	beq.n	3361e <sys_sem_take+0x18>
   33612:	f110 0f10 	cmn.w	r0, #16
		ret_value = -ETIMEDOUT;
   33616:	bf08      	it	eq
   33618:	f06f 0073 	mvneq.w	r0, #115	; 0x73
	}

	return ret_value;
}
   3361c:	bd08      	pop	{r3, pc}
		ret_value = -ETIMEDOUT;
   3361e:	f06f 0073 	mvn.w	r0, #115	; 0x73
	return ret_value;
   33622:	e7fb      	b.n	3361c <sys_sem_take+0x16>

00033624 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   33624:	4604      	mov	r4, r0
   33626:	b508      	push	{r3, lr}
   33628:	4608      	mov	r0, r1
   3362a:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   3362c:	461a      	mov	r2, r3
   3362e:	47a0      	blx	r4
	return z_impl_k_current_get();
   33630:	f7fa fcd6 	bl	2dfe0 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   33634:	f7e7 ff98 	bl	1b568 <z_impl_k_thread_abort>

00033638 <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
   33638:	b510      	push	{r4, lr}
   3363a:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
   3363c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   33640:	4620      	mov	r0, r4
   33642:	f7f9 fa4d 	bl	2cae0 <z_impl_k_queue_get>
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
   33646:	4603      	mov	r3, r0
   33648:	2800      	cmp	r0, #0
   3364a:	d0f7      	beq.n	3363c <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
   3364c:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   3364e:	3308      	adds	r3, #8
   33650:	e8d3 1fef 	ldaex	r1, [r3]
   33654:	f021 0c01 	bic.w	ip, r1, #1
   33658:	e8c3 cfee 	stlex	lr, ip, [r3]
   3365c:	f1be 0f00 	cmp.w	lr, #0
   33660:	d1f6      	bne.n	33650 <z_work_q_main+0x18>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
   33662:	07cb      	lsls	r3, r1, #31
   33664:	d500      	bpl.n	33668 <z_work_q_main+0x30>
					      K_WORK_STATE_PENDING)) {
			handler(work);
   33666:	4790      	blx	r2
	z_impl_k_yield();
   33668:	f7fa fb3c 	bl	2dce4 <z_impl_k_yield>
   3366c:	e7e6      	b.n	3363c <z_work_q_main+0x4>

0003366e <chunk_field>:
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
	void *cmem = &h->buf[c];
   3366e:	6803      	ldr	r3, [r0, #0]
   33670:	eb03 01c1 	add.w	r1, r3, r1, lsl #3

	if (big_heap(h)) {
   33674:	6883      	ldr	r3, [r0, #8]
   33676:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((u32_t *)cmem)[f];
   3367a:	bf2c      	ite	cs
   3367c:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((u16_t *)cmem)[f];
   33680:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
   33684:	4770      	bx	lr

00033686 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
   33686:	b510      	push	{r4, lr}
	CHECK(c >= h->chunk0 && c < h->len);
	CHECK((val & ~((h->size_mask << 1) + 1)) == 0);
	CHECK((val & h->size_mask) < h->len);

	void *cmem = &h->buf[c];
   33688:	6804      	ldr	r4, [r0, #0]

	if (big_heap(h)) {
   3368a:	6880      	ldr	r0, [r0, #8]
	void *cmem = &h->buf[c];
   3368c:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	if (big_heap(h)) {
   33690:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		((u32_t *)cmem)[f] = (u32_t) val;
   33694:	bf2c      	ite	cs
   33696:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		((u16_t *)cmem)[f] = (u16_t) val;
   3369a:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
   3369e:	bd10      	pop	{r4, pc}

000336a0 <right_chunk>:
{
	return c - left_size(h, c);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
   336a0:	b538      	push	{r3, r4, r5, lr}
   336a2:	4605      	mov	r5, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   336a4:	2200      	movs	r2, #0
{
   336a6:	460c      	mov	r4, r1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   336a8:	f7ff ffe1 	bl	3366e <chunk_field>
   336ac:	68eb      	ldr	r3, [r5, #12]
   336ae:	4018      	ands	r0, r3
	return c + size(h, c);
}
   336b0:	4420      	add	r0, r4
   336b2:	bd38      	pop	{r3, r4, r5, pc}

000336b4 <free_list_remove>:
	return ret;
}

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
   336b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct z_heap_bucket *b = &h->buckets[bidx];
   336b8:	6847      	ldr	r7, [r0, #4]
{
   336ba:	4616      	mov	r6, r2
	struct z_heap_bucket *b = &h->buckets[bidx];
   336bc:	eb07 02c1 	add.w	r2, r7, r1, lsl #3
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
   336c0:	6853      	ldr	r3, [r2, #4]
{
   336c2:	4604      	mov	r4, r0
	b->list_size--;
   336c4:	3b01      	subs	r3, #1
{
   336c6:	460d      	mov	r5, r1
	b->list_size--;
   336c8:	6053      	str	r3, [r2, #4]

	if (b->list_size == 0) {
   336ca:	b953      	cbnz	r3, 336e2 <free_list_remove+0x2e>
		h->avail_buckets &= ~(1 << bidx);
   336cc:	2201      	movs	r2, #1
   336ce:	fa02 f101 	lsl.w	r1, r2, r1
   336d2:	6942      	ldr	r2, [r0, #20]
   336d4:	ea22 0201 	bic.w	r2, r2, r1
   336d8:	6142      	str	r2, [r0, #20]
		b->next = 0;
   336da:	f847 3035 	str.w	r3, [r7, r5, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
   336de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
   336e2:	4631      	mov	r1, r6
   336e4:	2202      	movs	r2, #2
   336e6:	f7ff ffc2 	bl	3366e <chunk_field>
	return chunk_field(h, c, FREE_NEXT);
   336ea:	4631      	mov	r1, r6
	return chunk_field(h, c, FREE_PREV);
   336ec:	4680      	mov	r8, r0
	return chunk_field(h, c, FREE_NEXT);
   336ee:	2203      	movs	r2, #3
   336f0:	4620      	mov	r0, r4
   336f2:	f7ff ffbc 	bl	3366e <chunk_field>
   336f6:	4606      	mov	r6, r0
		b->next = second;
   336f8:	f847 0035 	str.w	r0, [r7, r5, lsl #3]
		chunk_set(h, first, FREE_NEXT, second);
   336fc:	4603      	mov	r3, r0
   336fe:	4641      	mov	r1, r8
   33700:	4620      	mov	r0, r4
   33702:	2203      	movs	r2, #3
   33704:	f7ff ffbf 	bl	33686 <chunk_set>
		chunk_set(h, second, FREE_PREV, first);
   33708:	4643      	mov	r3, r8
   3370a:	4631      	mov	r1, r6
   3370c:	4620      	mov	r0, r4
}
   3370e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, first);
   33712:	2202      	movs	r2, #2
   33714:	f7ff bfb7 	b.w	33686 <chunk_set>

00033718 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   33718:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3371c:	4604      	mov	r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   3371e:	2200      	movs	r2, #0
   33720:	460d      	mov	r5, r1
   33722:	f7ff ffa4 	bl	3366e <chunk_field>
   33726:	68e3      	ldr	r3, [r4, #12]
   33728:	4018      	ands	r0, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   3372a:	68a3      	ldr	r3, [r4, #8]
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   3372c:	fab0 f280 	clz	r2, r0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33730:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   33734:	bf34      	ite	cc
   33736:	2000      	movcc	r0, #0
   33738:	2001      	movcs	r0, #1
	int b = bucket_idx(h, size(h, c));

	if (h->buckets[b].list_size++ == 0) {
   3373a:	6863      	ldr	r3, [r4, #4]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   3373c:	f1c0 001f 	rsb	r0, r0, #31
   33740:	1a80      	subs	r0, r0, r2
   33742:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
   33746:	684a      	ldr	r2, [r1, #4]
   33748:	1c56      	adds	r6, r2, #1
   3374a:	604e      	str	r6, [r1, #4]
   3374c:	b9a2      	cbnz	r2, 33778 <free_list_add+0x60>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
   3374e:	2201      	movs	r2, #1
   33750:	fa02 f100 	lsl.w	r1, r2, r0
   33754:	6962      	ldr	r2, [r4, #20]
   33756:	430a      	orrs	r2, r1
   33758:	6162      	str	r2, [r4, #20]
		h->buckets[b].next = c;
		chunk_set(h, c, FREE_PREV, c);
   3375a:	4629      	mov	r1, r5
		h->buckets[b].next = c;
   3375c:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
		chunk_set(h, c, FREE_PREV, c);
   33760:	2202      	movs	r2, #2
   33762:	462b      	mov	r3, r5
   33764:	4620      	mov	r0, r4
   33766:	f7ff ff8e 	bl	33686 <chunk_set>
		chunk_set(h, c, FREE_NEXT, c);
   3376a:	2203      	movs	r2, #3
   3376c:	4629      	mov	r1, r5
		chunkid_t first = free_prev(h, second);

		chunk_set(h, c, FREE_PREV, first);
		chunk_set(h, c, FREE_NEXT, second);
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
   3376e:	4620      	mov	r0, r4
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
   33770:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, c);
   33774:	f7ff bf87 	b.w	33686 <chunk_set>
		chunkid_t second = h->buckets[b].next;
   33778:	f853 6030 	ldr.w	r6, [r3, r0, lsl #3]
	return chunk_field(h, c, FREE_PREV);
   3377c:	2202      	movs	r2, #2
   3377e:	4631      	mov	r1, r6
   33780:	4620      	mov	r0, r4
   33782:	f7ff ff74 	bl	3366e <chunk_field>
   33786:	4607      	mov	r7, r0
		chunk_set(h, c, FREE_PREV, first);
   33788:	4603      	mov	r3, r0
   3378a:	2202      	movs	r2, #2
   3378c:	4629      	mov	r1, r5
   3378e:	4620      	mov	r0, r4
   33790:	f7ff ff79 	bl	33686 <chunk_set>
		chunk_set(h, c, FREE_NEXT, second);
   33794:	4633      	mov	r3, r6
   33796:	2203      	movs	r2, #3
   33798:	4629      	mov	r1, r5
   3379a:	4620      	mov	r0, r4
   3379c:	f7ff ff73 	bl	33686 <chunk_set>
		chunk_set(h, first, FREE_NEXT, c);
   337a0:	2203      	movs	r2, #3
   337a2:	4639      	mov	r1, r7
   337a4:	462b      	mov	r3, r5
   337a6:	4620      	mov	r0, r4
   337a8:	f7ff ff6d 	bl	33686 <chunk_set>
		chunk_set(h, second, FREE_PREV, c);
   337ac:	2202      	movs	r2, #2
   337ae:	4631      	mov	r1, r6
   337b0:	e7dd      	b.n	3376e <free_list_add+0x56>

000337b2 <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
   337b2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   337b6:	4604      	mov	r4, r0
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
   337b8:	6843      	ldr	r3, [r0, #4]
{
   337ba:	4691      	mov	r9, r2
	chunkid_t c = h->buckets[bidx].next;
   337bc:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]

	free_list_remove(h, bidx, c);
   337c0:	462a      	mov	r2, r5
   337c2:	f7ff ff77 	bl	336b4 <free_list_remove>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   337c6:	2200      	movs	r2, #0
   337c8:	4629      	mov	r1, r5
   337ca:	4620      	mov	r0, r4
   337cc:	f7ff ff4f 	bl	3366e <chunk_field>
	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
   337d0:	68a3      	ldr	r3, [r4, #8]
   337d2:	68e6      	ldr	r6, [r4, #12]
   337d4:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   337d8:	bf2c      	ite	cs
   337da:	2302      	movcs	r3, #2
   337dc:	2301      	movcc	r3, #1
   337de:	4006      	ands	r6, r0
	size_t rem = size(h, c) - sz;
   337e0:	eba6 0609 	sub.w	r6, r6, r9
	if (rem >= (big_heap(h) ? 2 : 1)) {
   337e4:	42b3      	cmp	r3, r6
   337e6:	d82d      	bhi.n	33844 <split_alloc+0x92>
		chunkid_t c2 = c + sz;
		chunkid_t c3 = right_chunk(h, c);
   337e8:	4629      	mov	r1, r5
   337ea:	4620      	mov	r0, r4
   337ec:	f7ff ff58 	bl	336a0 <right_chunk>
		chunkid_t c2 = c + sz;
   337f0:	eb05 0709 	add.w	r7, r5, r9

		chunk_set(h, c, SIZE_AND_USED, sz);
   337f4:	464b      	mov	r3, r9
   337f6:	2200      	movs	r2, #0
   337f8:	4629      	mov	r1, r5
		chunkid_t c3 = right_chunk(h, c);
   337fa:	4680      	mov	r8, r0
		chunk_set(h, c, SIZE_AND_USED, sz);
   337fc:	4620      	mov	r0, r4
   337fe:	f7ff ff42 	bl	33686 <chunk_set>
		chunk_set(h, c2, SIZE_AND_USED, rem);
   33802:	4633      	mov	r3, r6
   33804:	2200      	movs	r2, #0
   33806:	4639      	mov	r1, r7
   33808:	4620      	mov	r0, r4
   3380a:	f7ff ff3c 	bl	33686 <chunk_set>
		chunk_set(h, c2, LEFT_SIZE, sz);
   3380e:	464b      	mov	r3, r9
   33810:	2201      	movs	r2, #1
   33812:	4639      	mov	r1, r7
   33814:	4620      	mov	r0, r4
   33816:	f7ff ff36 	bl	33686 <chunk_set>
   3381a:	2200      	movs	r2, #0
   3381c:	4639      	mov	r1, r7
   3381e:	4620      	mov	r0, r4
   33820:	f7ff ff25 	bl	3366e <chunk_field>
   33824:	68e3      	ldr	r3, [r4, #12]
   33826:	4018      	ands	r0, r3
		if (!last_chunk(h, c2)) {
   33828:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   3382a:	4438      	add	r0, r7
		if (!last_chunk(h, c2)) {
   3382c:	4298      	cmp	r0, r3
   3382e:	d005      	beq.n	3383c <split_alloc+0x8a>
			chunk_set(h, c3, LEFT_SIZE, rem);
   33830:	4633      	mov	r3, r6
   33832:	2201      	movs	r2, #1
   33834:	4641      	mov	r1, r8
   33836:	4620      	mov	r0, r4
   33838:	f7ff ff25 	bl	33686 <chunk_set>
		}
		free_list_add(h, c2);
   3383c:	4639      	mov	r1, r7
   3383e:	4620      	mov	r0, r4
   33840:	f7ff ff6a 	bl	33718 <free_list_add>
   33844:	4629      	mov	r1, r5
   33846:	2200      	movs	r2, #0
   33848:	4620      	mov	r0, r4
   3384a:	f7ff ff10 	bl	3366e <chunk_field>
   3384e:	68e2      	ldr	r2, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
   33850:	4629      	mov	r1, r5
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   33852:	ea00 0302 	and.w	r3, r0, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
   33856:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
   33858:	4313      	orrs	r3, r2
   3385a:	4620      	mov	r0, r4
   3385c:	2200      	movs	r2, #0
   3385e:	f7ff ff12 	bl	33686 <chunk_set>
	return big_heap(h) ? 8 : 4;
   33862:	68a3      	ldr	r3, [r4, #8]
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
   33864:	6820      	ldr	r0, [r4, #0]
   33866:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   3386a:	bf2c      	ite	cs
   3386c:	2308      	movcs	r3, #8
   3386e:	2304      	movcc	r3, #4
   33870:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
}
   33874:	4428      	add	r0, r5
   33876:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0003387a <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
   3387a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (mem == NULL) {
   3387e:	2900      	cmp	r1, #0
   33880:	f000 80ab 	beq.w	339da <sys_heap_free+0x160>
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
   33884:	6804      	ldr	r4, [r0, #0]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   33886:	2200      	movs	r2, #0
	return big_heap(h) ? 8 : 4;
   33888:	68a7      	ldr	r7, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   3388a:	4620      	mov	r0, r4
	return big_heap(h) ? 8 : 4;
   3388c:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   33890:	bf2c      	ite	cs
   33892:	2508      	movcs	r5, #8
   33894:	2504      	movcc	r5, #4
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
   33896:	1b4d      	subs	r5, r1, r5
		       - (u8_t *)h->buf) / CHUNK_UNIT;
   33898:	6821      	ldr	r1, [r4, #0]
   3389a:	1a6d      	subs	r5, r5, r1
   3389c:	bf48      	it	mi
   3389e:	3507      	addmi	r5, #7
   338a0:	10ed      	asrs	r5, r5, #3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   338a2:	4629      	mov	r1, r5
   338a4:	f7ff fee3 	bl	3366e <chunk_field>
   338a8:	68e6      	ldr	r6, [r4, #12]
   338aa:	ea06 0800 	and.w	r8, r6, r0
	return (c + size(h, c)) == h->len;
   338ae:	eb05 0308 	add.w	r3, r5, r8

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
   338b2:	42bb      	cmp	r3, r7
   338b4:	d036      	beq.n	33924 <sys_heap_free+0xaa>
   338b6:	4629      	mov	r1, r5
   338b8:	4620      	mov	r0, r4
   338ba:	f7ff fef1 	bl	336a0 <right_chunk>
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   338be:	2200      	movs	r2, #0
   338c0:	4601      	mov	r1, r0
   338c2:	4682      	mov	sl, r0
   338c4:	4620      	mov	r0, r4
   338c6:	f7ff fed2 	bl	3366e <chunk_field>
   338ca:	ea30 0906 	bics.w	r9, r0, r6
   338ce:	d129      	bne.n	33924 <sys_heap_free+0xaa>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   338d0:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
   338d4:	bf34      	ite	cc
   338d6:	2100      	movcc	r1, #0
   338d8:	2101      	movcs	r1, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   338da:	4006      	ands	r6, r0
		chunkid_t rc = right_chunk(h, c);
		size_t newsz = size(h, c) + size(h, rc);
   338dc:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   338de:	fab6 f686 	clz	r6, r6
   338e2:	f1c1 011f 	rsb	r1, r1, #31

		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
   338e6:	4652      	mov	r2, sl
   338e8:	1b89      	subs	r1, r1, r6
   338ea:	4620      	mov	r0, r4
   338ec:	f7ff fee2 	bl	336b4 <free_list_remove>
		chunk_set(h, c, SIZE_AND_USED, newsz);
   338f0:	4643      	mov	r3, r8
   338f2:	464a      	mov	r2, r9
   338f4:	4629      	mov	r1, r5
   338f6:	4620      	mov	r0, r4
   338f8:	f7ff fec5 	bl	33686 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   338fc:	4629      	mov	r1, r5
   338fe:	4620      	mov	r0, r4
   33900:	f7ff feb5 	bl	3366e <chunk_field>
   33904:	68e3      	ldr	r3, [r4, #12]
   33906:	4018      	ands	r0, r3
		if (!last_chunk(h, c)) {
   33908:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   3390a:	4428      	add	r0, r5
		if (!last_chunk(h, c)) {
   3390c:	4283      	cmp	r3, r0
   3390e:	d009      	beq.n	33924 <sys_heap_free+0xaa>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
   33910:	4629      	mov	r1, r5
   33912:	4620      	mov	r0, r4
   33914:	f7ff fec4 	bl	336a0 <right_chunk>
   33918:	4643      	mov	r3, r8
   3391a:	4601      	mov	r1, r0
   3391c:	2201      	movs	r2, #1
   3391e:	4620      	mov	r0, r4
   33920:	f7ff feb1 	bl	33686 <chunk_set>
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
   33924:	6923      	ldr	r3, [r4, #16]
   33926:	42ab      	cmp	r3, r5
   33928:	d045      	beq.n	339b6 <sys_heap_free+0x13c>
	return chunk_field(h, c, LEFT_SIZE);
   3392a:	2201      	movs	r2, #1
   3392c:	4629      	mov	r1, r5
   3392e:	4620      	mov	r0, r4
   33930:	f7ff fe9d 	bl	3366e <chunk_field>
	return c - left_size(h, c);
   33934:	eba5 0800 	sub.w	r8, r5, r0
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
   33938:	2200      	movs	r2, #0
   3393a:	4641      	mov	r1, r8
   3393c:	4620      	mov	r0, r4
   3393e:	f7ff fe96 	bl	3366e <chunk_field>
   33942:	68e7      	ldr	r7, [r4, #12]
   33944:	4606      	mov	r6, r0
   33946:	ea30 0907 	bics.w	r9, r0, r7
   3394a:	d134      	bne.n	339b6 <sys_heap_free+0x13c>
   3394c:	464a      	mov	r2, r9
   3394e:	4629      	mov	r1, r5
   33950:	4620      	mov	r0, r4
   33952:	f7ff fe8c 	bl	3366e <chunk_field>
   33956:	4682      	mov	sl, r0
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
   33958:	4629      	mov	r1, r5
   3395a:	4620      	mov	r0, r4
   3395c:	f7ff fea0 	bl	336a0 <right_chunk>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33960:	68a1      	ldr	r1, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   33962:	403e      	ands	r6, r7
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33964:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   33968:	bf34      	ite	cc
   3396a:	2100      	movcc	r1, #0
   3396c:	2101      	movcs	r1, #1
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
   3396e:	ea07 070a 	and.w	r7, r7, sl
   33972:	4437      	add	r7, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   33974:	fab6 f686 	clz	r6, r6
   33978:	f1c1 011f 	rsb	r1, r1, #31

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   3397c:	4642      	mov	r2, r8
   3397e:	1b89      	subs	r1, r1, r6
		chunkid_t rc = right_chunk(h, c);
   33980:	4605      	mov	r5, r0
		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
   33982:	4620      	mov	r0, r4
   33984:	f7ff fe96 	bl	336b4 <free_list_remove>
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
   33988:	463b      	mov	r3, r7
   3398a:	464a      	mov	r2, r9
   3398c:	4641      	mov	r1, r8
   3398e:	4620      	mov	r0, r4
   33990:	f7ff fe79 	bl	33686 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   33994:	4641      	mov	r1, r8
   33996:	4620      	mov	r0, r4
   33998:	f7ff fe69 	bl	3366e <chunk_field>
   3399c:	68e3      	ldr	r3, [r4, #12]
   3399e:	4018      	ands	r0, r3
		if (!last_chunk(h, lc)) {
   339a0:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
   339a2:	4440      	add	r0, r8
		if (!last_chunk(h, lc)) {
   339a4:	4298      	cmp	r0, r3
   339a6:	d005      	beq.n	339b4 <sys_heap_free+0x13a>
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
   339a8:	463b      	mov	r3, r7
   339aa:	2201      	movs	r2, #1
   339ac:	4629      	mov	r1, r5
   339ae:	4620      	mov	r0, r4
   339b0:	f7ff fe69 	bl	33686 <chunk_set>
		}

		c = lc;
   339b4:	4645      	mov	r5, r8
   339b6:	4629      	mov	r1, r5
   339b8:	2200      	movs	r2, #0
   339ba:	4620      	mov	r0, r4
   339bc:	f7ff fe57 	bl	3366e <chunk_field>
   339c0:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
   339c2:	4629      	mov	r1, r5
   339c4:	4003      	ands	r3, r0
   339c6:	2200      	movs	r2, #0
   339c8:	4620      	mov	r0, r4
   339ca:	f7ff fe5c 	bl	33686 <chunk_set>
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
   339ce:	4629      	mov	r1, r5
   339d0:	4620      	mov	r0, r4
}
   339d2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	free_list_add(h, c);
   339d6:	f7ff be9f 	b.w	33718 <free_list_add>
}
   339da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000339de <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
   339de:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct z_heap *h = heap->heap;
   339e2:	6804      	ldr	r4, [r0, #0]
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   339e4:	1dcd      	adds	r5, r1, #7
	return big_heap(h) ? 8 : 4;
   339e6:	68a2      	ldr	r2, [r4, #8]
   339e8:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
   339ec:	bf2c      	ite	cs
   339ee:	2308      	movcs	r3, #8
   339f0:	2304      	movcc	r3, #4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   339f2:	441d      	add	r5, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   339f4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   339f8:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   339fc:	fab5 f685 	clz	r6, r5
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33a00:	bf34      	ite	cc
   33a02:	2300      	movcc	r3, #0
   33a04:	2301      	movcs	r3, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   33a06:	441e      	add	r6, r3
   33a08:	f1c6 081f 	rsb	r8, r6, #31
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
   33a0c:	2900      	cmp	r1, #0
   33a0e:	d03b      	beq.n	33a88 <sys_heap_alloc+0xaa>
   33a10:	fab2 f282 	clz	r2, r2
   33a14:	f1c3 031f 	rsb	r3, r3, #31
   33a18:	1a9b      	subs	r3, r3, r2
   33a1a:	4598      	cmp	r8, r3
   33a1c:	dc34      	bgt.n	33a88 <sys_heap_alloc+0xaa>
	struct z_heap_bucket *b = &h->buckets[bi];
   33a1e:	6867      	ldr	r7, [r4, #4]
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);

	for (int i = 0; i < loops; i++) {
   33a20:	f04f 0a00 	mov.w	sl, #0
	struct z_heap_bucket *b = &h->buckets[bi];
   33a24:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
   33a28:	687b      	ldr	r3, [r7, #4]
   33a2a:	2b03      	cmp	r3, #3
   33a2c:	bf28      	it	cs
   33a2e:	2303      	movcs	r3, #3
   33a30:	4699      	mov	r9, r3
	for (int i = 0; i < loops; i++) {
   33a32:	45ca      	cmp	sl, r9
   33a34:	db0d      	blt.n	33a52 <sys_heap_alloc+0x74>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
   33a36:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   33a3a:	f1c6 0620 	rsb	r6, r6, #32
   33a3e:	6963      	ldr	r3, [r4, #20]
   33a40:	40b1      	lsls	r1, r6

	if ((bmask & h->avail_buckets) != 0) {
   33a42:	4019      	ands	r1, r3
   33a44:	d020      	beq.n	33a88 <sys_heap_alloc+0xaa>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);

		return split_alloc(h, minbucket, sz);
   33a46:	fa91 f1a1 	rbit	r1, r1
   33a4a:	462a      	mov	r2, r5
   33a4c:	fab1 f181 	clz	r1, r1
   33a50:	e00c      	b.n	33a6c <sys_heap_alloc+0x8e>
		if (size(h, b->next) >= sz) {
   33a52:	f8d7 b000 	ldr.w	fp, [r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
   33a56:	2200      	movs	r2, #0
   33a58:	4659      	mov	r1, fp
   33a5a:	4620      	mov	r0, r4
   33a5c:	f7ff fe07 	bl	3366e <chunk_field>
   33a60:	68e3      	ldr	r3, [r4, #12]
   33a62:	4018      	ands	r0, r3
   33a64:	42a8      	cmp	r0, r5
   33a66:	d306      	bcc.n	33a76 <sys_heap_alloc+0x98>
			return split_alloc(h, bi, sz);
   33a68:	462a      	mov	r2, r5
   33a6a:	4641      	mov	r1, r8
		return split_alloc(h, minbucket, sz);
   33a6c:	4620      	mov	r0, r4
	}

	return NULL;
}
   33a6e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return split_alloc(h, minbucket, sz);
   33a72:	f7ff be9e 	b.w	337b2 <split_alloc>
	return chunk_field(h, c, FREE_NEXT);
   33a76:	2203      	movs	r2, #3
   33a78:	4659      	mov	r1, fp
   33a7a:	4620      	mov	r0, r4
   33a7c:	f7ff fdf7 	bl	3366e <chunk_field>
	for (int i = 0; i < loops; i++) {
   33a80:	f10a 0a01 	add.w	sl, sl, #1
		b->next = free_next(h, b->next);
   33a84:	6038      	str	r0, [r7, #0]
   33a86:	e7d4      	b.n	33a32 <sys_heap_alloc+0x54>
}
   33a88:	2000      	movs	r0, #0
   33a8a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00033a8e <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   33a8e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if __SIZEOF_SIZE_T__ > 4
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
   33a90:	1dcc      	adds	r4, r1, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   33a92:	4411      	add	r1, r2

	heap->heap = (struct z_heap *)addr;
	h->buf = (u64_t *)addr;
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
	h->len = buf_sz;
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   33a94:	f647 72ff 	movw	r2, #32767	; 0x7fff
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
   33a98:	f024 0407 	bic.w	r4, r4, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
   33a9c:	f021 0107 	bic.w	r1, r1, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   33aa0:	1b09      	subs	r1, r1, r4
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   33aa2:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   33aa6:	ea4f 03d1 	mov.w	r3, r1, lsr #3
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   33aaa:	bf2c      	ite	cs
   33aac:	f06f 4100 	mvncs.w	r1, #2147483648	; 0x80000000
   33ab0:	4611      	movcc	r1, r2
	heap->heap = (struct z_heap *)addr;
   33ab2:	6004      	str	r4, [r0, #0]
	h->avail_buckets = 0;
   33ab4:	2000      	movs	r0, #0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33ab6:	4293      	cmp	r3, r2
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
   33ab8:	60e1      	str	r1, [r4, #12]
   33aba:	bf94      	ite	ls
   33abc:	2100      	movls	r1, #0
   33abe:	2101      	movhi	r1, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   33ac0:	fab3 f683 	clz	r6, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33ac4:	4617      	mov	r7, r2
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
		heap->heap->buckets[i].list_size = 0;
   33ac6:	4684      	mov	ip, r0
				* sizeof(struct z_heap_bucket));
   33ac8:	f1c1 0120 	rsb	r1, r1, #32
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
   33acc:	f104 0518 	add.w	r5, r4, #24
				* sizeof(struct z_heap_bucket));
   33ad0:	1b89      	subs	r1, r1, r6
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
   33ad2:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
	h->len = buf_sz;
   33ad6:	e9c4 5301 	strd	r5, r3, [r4, #4]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   33ada:	3103      	adds	r1, #3
	h->buf = (u64_t *)addr;
   33adc:	6024      	str	r4, [r4, #0]
	h->avail_buckets = 0;
   33ade:	6160      	str	r0, [r4, #20]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
   33ae0:	6121      	str	r1, [r4, #16]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
   33ae2:	68a2      	ldr	r2, [r4, #8]
   33ae4:	42ba      	cmp	r2, r7
   33ae6:	bf94      	ite	ls
   33ae8:	2200      	movls	r2, #0
   33aea:	2201      	movhi	r2, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
   33aec:	f1c2 021f 	rsb	r2, r2, #31
   33af0:	1b92      	subs	r2, r2, r6
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   33af2:	4290      	cmp	r0, r2
   33af4:	dd0a      	ble.n	33b0c <sys_heap_init+0x7e>
		heap->heap->buckets[i].next = 0;
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
   33af6:	1a5b      	subs	r3, r3, r1
   33af8:	4620      	mov	r0, r4
   33afa:	2200      	movs	r2, #0
   33afc:	f7ff fdc3 	bl	33686 <chunk_set>
	free_list_add(h, h->chunk0);
   33b00:	6921      	ldr	r1, [r4, #16]
   33b02:	4620      	mov	r0, r4
}
   33b04:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, h->chunk0);
   33b08:	f7ff be06 	b.w	33718 <free_list_add>
		heap->heap->buckets[i].list_size = 0;
   33b0c:	f8c5 c004 	str.w	ip, [r5, #4]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
   33b10:	3001      	adds	r0, #1
		heap->heap->buckets[i].next = 0;
   33b12:	f845 cb08 	str.w	ip, [r5], #8
   33b16:	e7e4      	b.n	33ae2 <sys_heap_init+0x54>

00033b18 <get_elem_size>:
{
   33b18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   33b1c:	4605      	mov	r5, r0
   33b1e:	2701      	movs	r7, #1
	switch (descr->type) {
   33b20:	796b      	ldrb	r3, [r5, #5]
   33b22:	085b      	lsrs	r3, r3, #1
   33b24:	2b5b      	cmp	r3, #91	; 0x5b
   33b26:	d02d      	beq.n	33b84 <get_elem_size+0x6c>
   33b28:	d80b      	bhi.n	33b42 <get_elem_size+0x2a>
   33b2a:	2b22      	cmp	r3, #34	; 0x22
   33b2c:	d02e      	beq.n	33b8c <get_elem_size+0x74>
		return -EINVAL;
   33b2e:	2b30      	cmp	r3, #48	; 0x30
   33b30:	bf08      	it	eq
   33b32:	2404      	moveq	r4, #4
   33b34:	bf18      	it	ne
   33b36:	f06f 0415 	mvnne.w	r4, #21
}
   33b3a:	fb07 f004 	mul.w	r0, r7, r4
   33b3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	switch (descr->type) {
   33b42:	2b74      	cmp	r3, #116	; 0x74
   33b44:	d024      	beq.n	33b90 <get_elem_size+0x78>
   33b46:	2b7b      	cmp	r3, #123	; 0x7b
   33b48:	d003      	beq.n	33b52 <get_elem_size+0x3a>
		return -EINVAL;
   33b4a:	2b66      	cmp	r3, #102	; 0x66
   33b4c:	bf08      	it	eq
   33b4e:	2401      	moveq	r4, #1
   33b50:	e7f0      	b.n	33b34 <get_elem_size+0x1c>
		for (i = 0; i < descr->object.sub_descr_len; i++) {
   33b52:	2600      	movs	r6, #0
			total += ROUND_UP(s, 1 << descr->align_shift);
   33b54:	f04f 0901 	mov.w	r9, #1
		ptrdiff_t total = 0;
   33b58:	4634      	mov	r4, r6
		for (i = 0; i < descr->object.sub_descr_len; i++) {
   33b5a:	f8d5 800c 	ldr.w	r8, [r5, #12]
   33b5e:	45b0      	cmp	r8, r6
   33b60:	d0eb      	beq.n	33b3a <get_elem_size+0x22>
			ptrdiff_t s = get_elem_size(&descr->object.sub_descr[i]);
   33b62:	68a8      	ldr	r0, [r5, #8]
   33b64:	eb00 1006 	add.w	r0, r0, r6, lsl #4
   33b68:	f7ff ffd6 	bl	33b18 <get_elem_size>
			total += ROUND_UP(s, 1 << descr->align_shift);
   33b6c:	792b      	ldrb	r3, [r5, #4]
		for (i = 0; i < descr->object.sub_descr_len; i++) {
   33b6e:	3601      	adds	r6, #1
			total += ROUND_UP(s, 1 << descr->align_shift);
   33b70:	f003 0303 	and.w	r3, r3, #3
   33b74:	fa09 f303 	lsl.w	r3, r9, r3
   33b78:	1e5a      	subs	r2, r3, #1
   33b7a:	4410      	add	r0, r2
   33b7c:	425b      	negs	r3, r3
   33b7e:	4003      	ands	r3, r0
   33b80:	441c      	add	r4, r3
   33b82:	e7ec      	b.n	33b5e <get_elem_size+0x46>
		return descr->array.n_elements * get_elem_size(descr->array.element_descr);
   33b84:	e9d5 5302 	ldrd	r5, r3, [r5, #8]
   33b88:	435f      	muls	r7, r3
   33b8a:	e7c9      	b.n	33b20 <get_elem_size+0x8>
		return sizeof(s32_t);
   33b8c:	2404      	movs	r4, #4
   33b8e:	e7d4      	b.n	33b3a <get_elem_size+0x22>
		return sizeof(bool);
   33b90:	2401      	movs	r4, #1
   33b92:	e7d2      	b.n	33b3a <get_elem_size+0x22>

00033b94 <escape_as>:
	switch (chr) {
   33b94:	280c      	cmp	r0, #12
   33b96:	d012      	beq.n	33bbe <escape_as+0x2a>
   33b98:	d809      	bhi.n	33bae <escape_as+0x1a>
   33b9a:	2809      	cmp	r0, #9
   33b9c:	d011      	beq.n	33bc2 <escape_as+0x2e>
   33b9e:	280a      	cmp	r0, #10
   33ba0:	d011      	beq.n	33bc6 <escape_as+0x32>
	return 0;
   33ba2:	2808      	cmp	r0, #8
   33ba4:	bf08      	it	eq
   33ba6:	2062      	moveq	r0, #98	; 0x62
   33ba8:	bf18      	it	ne
   33baa:	2000      	movne	r0, #0
   33bac:	4770      	bx	lr
	switch (chr) {
   33bae:	2822      	cmp	r0, #34	; 0x22
   33bb0:	d00a      	beq.n	33bc8 <escape_as+0x34>
   33bb2:	285c      	cmp	r0, #92	; 0x5c
   33bb4:	d008      	beq.n	33bc8 <escape_as+0x34>
	return 0;
   33bb6:	280d      	cmp	r0, #13
   33bb8:	bf08      	it	eq
   33bba:	2072      	moveq	r0, #114	; 0x72
   33bbc:	e7f4      	b.n	33ba8 <escape_as+0x14>
		return 'f';
   33bbe:	2066      	movs	r0, #102	; 0x66
   33bc0:	4770      	bx	lr
		return 't';
   33bc2:	2074      	movs	r0, #116	; 0x74
   33bc4:	4770      	bx	lr
		return 'n';
   33bc6:	206e      	movs	r0, #110	; 0x6e
}
   33bc8:	4770      	bx	lr

00033bca <assert_post_action>:
	if (_is_user_context()) {
		k_oops();
	}
#endif

	k_panic();
   33bca:	4040      	eors	r0, r0
   33bcc:	f380 8811 	msr	BASEPRI, r0
   33bd0:	f04f 0004 	mov.w	r0, #4
   33bd4:	df02      	svc	2
}
   33bd6:	4770      	bx	lr

00033bd8 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   33bd8:	4770      	bx	lr

00033bda <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
   33bda:	f7f6 bf3b 	b.w	2aa54 <SystemInit>

00033bde <log_backend_is_active>:
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
   33bde:	6843      	ldr	r3, [r0, #4]
}
   33be0:	7958      	ldrb	r0, [r3, #5]
   33be2:	4770      	bx	lr

00033be4 <k_cycle_get_32_wrapper>:
   33be4:	f7e6 bc8c 	b.w	1a500 <z_timer_cycle_get_32>

00033be8 <dummy_timestamp>:
   33be8:	2000      	movs	r0, #0
   33bea:	4770      	bx	lr

00033bec <log_printk>:
			log_generic(src_level_union.structure, fmt, ap);
   33bec:	460a      	mov	r2, r1
   33bee:	4601      	mov	r1, r0
   33bf0:	f04f 0000 	mov.w	r0, #0
   33bf4:	f7e5 b8b6 	b.w	18d64 <log_generic>

00033bf8 <log_string_sync>:
{
   33bf8:	b40e      	push	{r1, r2, r3}
   33bfa:	b503      	push	{r0, r1, lr}
   33bfc:	aa03      	add	r2, sp, #12
   33bfe:	f852 1b04 	ldr.w	r1, [r2], #4
	va_start(ap, fmt);
   33c02:	9201      	str	r2, [sp, #4]
	log_generic(src_level, fmt, ap);
   33c04:	f7e5 f8ae 	bl	18d64 <log_generic>
}
   33c08:	b002      	add	sp, #8
   33c0a:	f85d eb04 	ldr.w	lr, [sp], #4
   33c0e:	b003      	add	sp, #12
   33c10:	4770      	bx	lr

00033c12 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
   33c12:	b508      	push	{r3, lr}
				K_THREAD_STACK_SIZEOF(logging_stack),
				log_process_thread_func, NULL, NULL, NULL,
				K_LOWEST_APPLICATION_THREAD_PRIO, 0, K_NO_WAIT);
		k_thread_name_set(&logging_thread, "logging");
	} else {
		log_init();
   33c14:	f7e5 f91c 	bl	18e50 <log_init>
	}

	return 0;
}
   33c18:	2000      	movs	r0, #0
   33c1a:	bd08      	pop	{r3, pc}

00033c1c <log_strdup>:
}
   33c1c:	4770      	bx	lr

00033c1e <out_func>:
{
   33c1e:	b507      	push	{r0, r1, r2, lr}
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   33c20:	e9d1 3200 	ldrd	r3, r2, [r1]
{
   33c24:	9001      	str	r0, [sp, #4]
		out_ctx->func((u8_t *)&c, 1, out_ctx->control_block->ctx);
   33c26:	6852      	ldr	r2, [r2, #4]
   33c28:	2101      	movs	r1, #1
   33c2a:	a801      	add	r0, sp, #4
   33c2c:	4798      	blx	r3
}
   33c2e:	2000      	movs	r0, #0
   33c30:	b003      	add	sp, #12
   33c32:	f85d fb04 	ldr.w	pc, [sp], #4

00033c36 <buffer_write>:
{
   33c36:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33c38:	4606      	mov	r6, r0
   33c3a:	460d      	mov	r5, r1
   33c3c:	4614      	mov	r4, r2
   33c3e:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
   33c40:	4621      	mov	r1, r4
   33c42:	4628      	mov	r0, r5
   33c44:	463a      	mov	r2, r7
   33c46:	47b0      	blx	r6
	} while (len != 0);
   33c48:	1a24      	subs	r4, r4, r0
		buf += processed;
   33c4a:	4405      	add	r5, r0
	} while (len != 0);
   33c4c:	d1f8      	bne.n	33c40 <buffer_write+0xa>
}
   33c4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00033c50 <log_output_flush>:
		     log_output->control_block->offset,
   33c50:	6842      	ldr	r2, [r0, #4]
{
   33c52:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
   33c54:	e9d2 2300 	ldrd	r2, r3, [r2]
{
   33c58:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
   33c5a:	6881      	ldr	r1, [r0, #8]
   33c5c:	6800      	ldr	r0, [r0, #0]
   33c5e:	f7ff ffea 	bl	33c36 <buffer_write>
	log_output->control_block->offset = 0;
   33c62:	2200      	movs	r2, #0
   33c64:	6863      	ldr	r3, [r4, #4]
   33c66:	601a      	str	r2, [r3, #0]
}
   33c68:	bd10      	pop	{r4, pc}

00033c6a <char_out>:
{
   33c6a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33c6c:	460d      	mov	r5, r1
   33c6e:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
   33c70:	4604      	mov	r4, r0
   33c72:	1847      	adds	r7, r0, r1
   33c74:	42bc      	cmp	r4, r7
   33c76:	d101      	bne.n	33c7c <char_out+0x12>
}
   33c78:	4628      	mov	r0, r5
   33c7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uart_poll_out(dev, data[i]);
   33c7c:	f814 1b01 	ldrb.w	r1, [r4], #1
   33c80:	68b3      	ldr	r3, [r6, #8]
   33c82:	4630      	mov	r0, r6
   33c84:	685b      	ldr	r3, [r3, #4]
   33c86:	4798      	blx	r3
   33c88:	e7f4      	b.n	33c74 <char_out+0xa>

00033c8a <sntp_init>:
{
   33c8a:	b570      	push	{r4, r5, r6, lr}
   33c8c:	460d      	mov	r5, r1
   33c8e:	4616      	mov	r6, r2
	if (!ctx || !addr) {
   33c90:	4604      	mov	r4, r0
   33c92:	b330      	cbz	r0, 33ce2 <sntp_init+0x58>
   33c94:	b329      	cbz	r1, 33ce2 <sntp_init+0x58>
__ssp_bos_icheck3(memset, void *, int)
   33c96:	2214      	movs	r2, #20
   33c98:	2100      	movs	r1, #0
   33c9a:	f005 f9d7 	bl	3904c <memset>
	ctx->sock.fd = socket(addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
   33c9e:	8828      	ldrh	r0, [r5, #0]
	return z_impl_zsock_socket(family, type, proto);
   33ca0:	2211      	movs	r2, #17
   33ca2:	2102      	movs	r1, #2
   33ca4:	f7e5 fbae 	bl	19404 <z_impl_zsock_socket>
	if (ctx->sock.fd < 0) {
   33ca8:	2800      	cmp	r0, #0
	ctx->sock.fd = socket(addr->sa_family, SOCK_DGRAM, IPPROTO_UDP);
   33caa:	60e0      	str	r0, [r4, #12]
	if (ctx->sock.fd < 0) {
   33cac:	da04      	bge.n	33cb8 <sntp_init+0x2e>
		return -errno;
   33cae:	f001 fc1b 	bl	354e8 <__errno>
   33cb2:	6800      	ldr	r0, [r0, #0]
   33cb4:	4240      	negs	r0, r0
}
   33cb6:	bd70      	pop	{r4, r5, r6, pc}
	return z_impl_zsock_connect(sock, addr, addrlen);
   33cb8:	4632      	mov	r2, r6
   33cba:	4629      	mov	r1, r5
   33cbc:	f000 f8c7 	bl	33e4e <z_impl_zsock_connect>
	if (ret < 0) {
   33cc0:	2800      	cmp	r0, #0
   33cc2:	68e0      	ldr	r0, [r4, #12]
   33cc4:	da02      	bge.n	33ccc <sntp_init+0x42>
	return z_impl_zsock_close(sock);
   33cc6:	f000 f8a9 	bl	33e1c <z_impl_zsock_close>
   33cca:	e7f0      	b.n	33cae <sntp_init+0x24>
	ctx->sock.fds[ctx->sock.nfds].events = POLLIN;
   33ccc:	2101      	movs	r1, #1
	ctx->sock.fds[ctx->sock.nfds].fd = ctx->sock.fd;
   33cce:	68a3      	ldr	r3, [r4, #8]
   33cd0:	f844 0033 	str.w	r0, [r4, r3, lsl #3]
	ctx->sock.fds[ctx->sock.nfds].events = POLLIN;
   33cd4:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
	ctx->sock.nfds++;
   33cd8:	440b      	add	r3, r1
	ctx->sock.fds[ctx->sock.nfds].events = POLLIN;
   33cda:	8091      	strh	r1, [r2, #4]
	return 0;
   33cdc:	2000      	movs	r0, #0
	ctx->sock.nfds++;
   33cde:	60a3      	str	r3, [r4, #8]
	return 0;
   33ce0:	e7e9      	b.n	33cb6 <sntp_init+0x2c>
		return -EFAULT;
   33ce2:	f06f 000d 	mvn.w	r0, #13
   33ce6:	e7e6      	b.n	33cb6 <sntp_init+0x2c>

00033ce8 <sntp_close>:

void sntp_close(struct sntp_ctx *ctx)
{
	if (ctx) {
   33ce8:	b110      	cbz	r0, 33cf0 <sntp_close+0x8>
		(void)close(ctx->sock.fd);
   33cea:	68c0      	ldr	r0, [r0, #12]
   33cec:	f000 b896 	b.w	33e1c <z_impl_zsock_close>
	}
}
   33cf0:	4770      	bx	lr

00033cf2 <zsock_getaddrinfo>:
int zsock_getaddrinfo(const char *host, const char *service,
		      const struct zsock_addrinfo *hints,
		      struct zsock_addrinfo **res)
{
	if (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD)) {
		return socket_offload_getaddrinfo(host, service, hints, res);
   33cf2:	f7e5 bf5f 	b.w	19bb4 <socket_offload_getaddrinfo>

00033cf6 <zsock_freeaddrinfo>:
}

void zsock_freeaddrinfo(struct zsock_addrinfo *ai)
{
	if (IS_ENABLED(CONFIG_NET_SOCKETS_OFFLOAD)) {
		return socket_offload_freeaddrinfo(ai);
   33cf6:	f7e5 bf91 	b.w	19c1c <socket_offload_freeaddrinfo>

00033cfa <z_fdtable_call_ioctl>:
 * @param request ioctl request number
 * @param ... Variadic arguments to ioctl
 */
static inline int z_fdtable_call_ioctl(const struct fd_op_vtable *vtable, void *obj,
				       unsigned long request, ...)
{
   33cfa:	b40c      	push	{r2, r3}
   33cfc:	b513      	push	{r0, r1, r4, lr}
   33cfe:	460c      	mov	r4, r1
   33d00:	aa04      	add	r2, sp, #16
   33d02:	f852 1b04 	ldr.w	r1, [r2], #4
	va_list args;
	int res;

	va_start(args, request);
	res = vtable->ioctl(obj, request, args);
   33d06:	6883      	ldr	r3, [r0, #8]
   33d08:	4620      	mov	r0, r4
	va_start(args, request);
   33d0a:	9201      	str	r2, [sp, #4]
	res = vtable->ioctl(obj, request, args);
   33d0c:	4798      	blx	r3
	va_end(args);

	return res;
}
   33d0e:	b002      	add	sp, #8
   33d10:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33d14:	b002      	add	sp, #8
   33d16:	4770      	bx	lr

00033d18 <sock_getsockopt_vmeth>:
   33d18:	b508      	push	{r3, lr}
   33d1a:	f001 fbe5 	bl	354e8 <__errno>
   33d1e:	236d      	movs	r3, #109	; 0x6d
   33d20:	6003      	str	r3, [r0, #0]
   33d22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33d26:	bd08      	pop	{r3, pc}

00033d28 <k_fifo_wait_non_empty>:
{
   33d28:	b530      	push	{r4, r5, lr}
   33d2a:	b087      	sub	sp, #28
   33d2c:	4605      	mov	r5, r0
   33d2e:	460c      	mov	r4, r1
	struct k_poll_event events[] = {
   33d30:	2210      	movs	r2, #16
   33d32:	2100      	movs	r1, #0
   33d34:	a801      	add	r0, sp, #4
   33d36:	f005 f989 	bl	3904c <memset>
   33d3a:	2304      	movs	r3, #4
   33d3c:	9505      	str	r5, [sp, #20]
   33d3e:	f88d 3011 	strb.w	r3, [sp, #17]
	return z_impl_k_poll(events, num_events, timeout);
   33d42:	2101      	movs	r1, #1
   33d44:	4622      	mov	r2, r4
   33d46:	eb0d 0003 	add.w	r0, sp, r3
   33d4a:	f7fb fa63 	bl	2f214 <z_impl_k_poll>
}
   33d4e:	b007      	add	sp, #28
   33d50:	bd30      	pop	{r4, r5, pc}

00033d52 <zsock_received_cb>:
{
   33d52:	b570      	push	{r4, r5, r6, lr}
   33d54:	4604      	mov	r4, r0
   33d56:	f100 065c 	add.w	r6, r0, #92	; 0x5c
	if (!pkt) {
   33d5a:	460d      	mov	r5, r1
   33d5c:	b999      	cbnz	r1, 33d86 <zsock_received_cb+0x34>
	return z_queue_node_peek(sys_sflist_peek_tail(&queue->data_q), false);
   33d5e:	6e00      	ldr	r0, [r0, #96]	; 0x60
   33d60:	f004 ff87 	bl	38c72 <z_queue_node_peek>
		if (!last_pkt) {
   33d64:	b940      	cbnz	r0, 33d78 <zsock_received_cb+0x26>
	val = (val & ~mask) | flag;
   33d66:	6da3      	ldr	r3, [r4, #88]	; 0x58
   33d68:	f043 0301 	orr.w	r3, r3, #1
	(ctx)->socket_data = UINT_TO_POINTER(val);
   33d6c:	65a3      	str	r3, [r4, #88]	; 0x58
	z_impl_k_queue_cancel_wait(queue);
   33d6e:	4630      	mov	r0, r6
}
   33d70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   33d74:	f7f8 be76 	b.w	2ca64 <z_impl_k_queue_cancel_wait>
	pkt->sent_or_eof = eof;
   33d78:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
   33d7c:	f043 0302 	orr.w	r3, r3, #2
   33d80:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
   33d84:	bd70      	pop	{r4, r5, r6, pc}
   33d86:	f891 303d 	ldrb.w	r3, [r1, #61]	; 0x3d
   33d8a:	f36f 0341 	bfc	r3, #1, #1
   33d8e:	f881 303d 	strb.w	r3, [r1, #61]	; 0x3d
	if (net_context_get_type(ctx) == SOCK_STREAM) {
   33d92:	f7e5 fac5 	bl	19320 <net_context_get_type>
   33d96:	2801      	cmp	r0, #1
   33d98:	d106      	bne.n	33da8 <zsock_received_cb+0x56>
		net_context_update_recv_wnd(ctx, -net_pkt_remaining_data(pkt));
   33d9a:	4628      	mov	r0, r5
   33d9c:	f002 f904 	bl	35fa8 <net_pkt_remaining_data>
   33da0:	4241      	negs	r1, r0
   33da2:	4620      	mov	r0, r4
   33da4:	f001 feb3 	bl	35b0e <net_context_update_recv_wnd>
	k_fifo_put(&ctx->recv_q, pkt);
   33da8:	4629      	mov	r1, r5
   33daa:	4630      	mov	r0, r6
}
   33dac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	k_fifo_put(&ctx->recv_q, pkt);
   33db0:	f004 bf78 	b.w	38ca4 <k_queue_append>

00033db4 <zsock_close_ctx>:
{
   33db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   33db6:	4604      	mov	r4, r0
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
   33db8:	f7e5 fa92 	bl	192e0 <net_context_get_state>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   33dbc:	2300      	movs	r3, #0
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
   33dbe:	2803      	cmp	r0, #3
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   33dc0:	461a      	mov	r2, r3
   33dc2:	4619      	mov	r1, r3
   33dc4:	4620      	mov	r0, r4
	if (net_context_get_state(ctx) == NET_CONTEXT_LISTENING) {
   33dc6:	d11c      	bne.n	33e02 <zsock_close_ctx+0x4e>
		(void)net_context_accept(ctx, NULL, K_NO_WAIT, NULL);
   33dc8:	f7e9 f932 	bl	1d030 <net_context_accept>
	bool is_listen = net_context_get_state(ctx) == NET_CONTEXT_LISTENING;
   33dcc:	4620      	mov	r0, r4
   33dce:	f7e5 fa87 	bl	192e0 <net_context_get_state>
   33dd2:	4607      	mov	r7, r0
	while ((p = k_fifo_get(&ctx->recv_q, K_NO_WAIT)) != NULL) {
   33dd4:	f104 065c 	add.w	r6, r4, #92	; 0x5c
	return z_impl_k_queue_get(queue, timeout);
   33dd8:	2100      	movs	r1, #0
   33dda:	4630      	mov	r0, r6
   33ddc:	f7f8 fe80 	bl	2cae0 <z_impl_k_queue_get>
   33de0:	4605      	mov	r5, r0
   33de2:	b988      	cbnz	r0, 33e08 <zsock_close_ctx+0x54>
	z_impl_k_queue_cancel_wait(queue);
   33de4:	4630      	mov	r0, r6
   33de6:	f7f8 fe3d 	bl	2ca64 <z_impl_k_queue_cancel_wait>
	SET_ERRNO(net_context_put(ctx));
   33dea:	4620      	mov	r0, r4
   33dec:	f7e8 fe02 	bl	1c9f4 <net_context_put>
   33df0:	1e04      	subs	r4, r0, #0
   33df2:	da11      	bge.n	33e18 <zsock_close_ctx+0x64>
   33df4:	f001 fb78 	bl	354e8 <__errno>
   33df8:	4264      	negs	r4, r4
   33dfa:	6004      	str	r4, [r0, #0]
   33dfc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   33e00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		(void)net_context_recv(ctx, NULL, K_NO_WAIT, NULL);
   33e02:	f7e9 f965 	bl	1d0d0 <net_context_recv>
   33e06:	e7e1      	b.n	33dcc <zsock_close_ctx+0x18>
		if (is_listen) {
   33e08:	2f03      	cmp	r7, #3
   33e0a:	d102      	bne.n	33e12 <zsock_close_ctx+0x5e>
			net_context_put(p);
   33e0c:	f7e8 fdf2 	bl	1c9f4 <net_context_put>
   33e10:	e7e2      	b.n	33dd8 <zsock_close_ctx+0x24>
			net_pkt_unref(p);
   33e12:	f001 ff61 	bl	35cd8 <net_pkt_unref>
   33e16:	e7df      	b.n	33dd8 <zsock_close_ctx+0x24>
	return 0;
   33e18:	4628      	mov	r0, r5
   33e1a:	e7f1      	b.n	33e00 <zsock_close_ctx+0x4c>

00033e1c <z_impl_zsock_close>:
{
   33e1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   33e1e:	a901      	add	r1, sp, #4
{
   33e20:	4605      	mov	r5, r0
	void *ctx = z_get_fd_obj_and_vtable(sock, &vtable);
   33e22:	f7e4 fd57 	bl	188d4 <z_get_fd_obj_and_vtable>
	if (ctx == NULL) {
   33e26:	4604      	mov	r4, r0
   33e28:	b150      	cbz	r0, 33e40 <z_impl_zsock_close+0x24>
	z_free_fd(sock);
   33e2a:	4628      	mov	r0, r5
   33e2c:	f7e4 fd92 	bl	18954 <z_free_fd>
	return z_fdtable_call_ioctl(vtable, ctx, ZFD_IOCTL_CLOSE);
   33e30:	f44f 7280 	mov.w	r2, #256	; 0x100
   33e34:	4621      	mov	r1, r4
   33e36:	9801      	ldr	r0, [sp, #4]
   33e38:	f7ff ff5f 	bl	33cfa <z_fdtable_call_ioctl>
}
   33e3c:	b003      	add	sp, #12
   33e3e:	bd30      	pop	{r4, r5, pc}
		return -1;
   33e40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33e44:	e7fa      	b.n	33e3c <z_impl_zsock_close+0x20>

00033e46 <sock_bind_vmeth>:
}

static int sock_bind_vmeth(void *obj, const struct sockaddr *addr,
			   socklen_t addrlen)
{
	return zsock_bind_ctx(obj, addr, addrlen);
   33e46:	f7e5 bb31 	b.w	194ac <zsock_bind_ctx>

00033e4a <sock_connect_vmeth>:
}

static int sock_connect_vmeth(void *obj, const struct sockaddr *addr,
			      socklen_t addrlen)
{
	return zsock_connect_ctx(obj, addr, addrlen);
   33e4a:	f7e5 bb53 	b.w	194f4 <zsock_connect_ctx>

00033e4e <z_impl_zsock_connect>:
{
   33e4e:	b537      	push	{r0, r1, r2, r4, r5, lr}
   33e50:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   33e52:	a901      	add	r1, sp, #4
{
   33e54:	4615      	mov	r5, r2
	return z_get_fd_obj_and_vtable(sock,
   33e56:	f7e4 fd3d 	bl	188d4 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(connect, sock, addr, addrlen);
   33e5a:	b138      	cbz	r0, 33e6c <z_impl_zsock_connect+0x1e>
   33e5c:	9b01      	ldr	r3, [sp, #4]
   33e5e:	691b      	ldr	r3, [r3, #16]
   33e60:	b123      	cbz	r3, 33e6c <z_impl_zsock_connect+0x1e>
   33e62:	462a      	mov	r2, r5
   33e64:	4621      	mov	r1, r4
   33e66:	4798      	blx	r3
}
   33e68:	b003      	add	sp, #12
   33e6a:	bd30      	pop	{r4, r5, pc}
	VTABLE_CALL(connect, sock, addr, addrlen);
   33e6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33e70:	e7fa      	b.n	33e68 <z_impl_zsock_connect+0x1a>

00033e72 <sock_listen_vmeth>:
}

static int sock_listen_vmeth(void *obj, int backlog)
{
	return zsock_listen_ctx(obj, backlog);
   33e72:	f7e5 bb5f 	b.w	19534 <zsock_listen_ctx>

00033e76 <sock_accept_vmeth>:
}

static int sock_accept_vmeth(void *obj, struct sockaddr *addr,
			     socklen_t *addrlen)
{
	return zsock_accept_ctx(obj, addr, addrlen);
   33e76:	f7e5 bb77 	b.w	19568 <zsock_accept_ctx>

00033e7a <sock_sendto_vmeth>:

static ssize_t sock_sendto_vmeth(void *obj, const void *buf, size_t len,
				 int flags, const struct sockaddr *dest_addr,
				 socklen_t addrlen)
{
	return zsock_sendto_ctx(obj, buf, len, flags, dest_addr, addrlen);
   33e7a:	f7e5 bbdd 	b.w	19638 <zsock_sendto_ctx>

00033e7e <sock_write_vmeth>:
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
   33e7e:	2300      	movs	r3, #0
{
   33e80:	b507      	push	{r0, r1, r2, lr}
	return zsock_sendto_ctx(obj, buffer, count, 0, NULL, 0);
   33e82:	e9cd 3300 	strd	r3, r3, [sp]
   33e86:	f7e5 fbd7 	bl	19638 <zsock_sendto_ctx>
}
   33e8a:	b003      	add	sp, #12
   33e8c:	f85d fb04 	ldr.w	pc, [sp], #4

00033e90 <z_impl_zsock_sendto>:
{
   33e90:	b5f0      	push	{r4, r5, r6, r7, lr}
   33e92:	b085      	sub	sp, #20
   33e94:	460d      	mov	r5, r1
	return z_get_fd_obj_and_vtable(sock,
   33e96:	a903      	add	r1, sp, #12
{
   33e98:	4616      	mov	r6, r2
   33e9a:	461f      	mov	r7, r3
	return z_get_fd_obj_and_vtable(sock,
   33e9c:	f7e4 fd1a 	bl	188d4 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   33ea0:	b160      	cbz	r0, 33ebc <z_impl_zsock_sendto+0x2c>
   33ea2:	9b03      	ldr	r3, [sp, #12]
   33ea4:	69dc      	ldr	r4, [r3, #28]
   33ea6:	b14c      	cbz	r4, 33ebc <z_impl_zsock_sendto+0x2c>
   33ea8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   33eaa:	4632      	mov	r2, r6
   33eac:	9301      	str	r3, [sp, #4]
   33eae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   33eb0:	4629      	mov	r1, r5
   33eb2:	9300      	str	r3, [sp, #0]
   33eb4:	463b      	mov	r3, r7
   33eb6:	47a0      	blx	r4
}
   33eb8:	b005      	add	sp, #20
   33eba:	bdf0      	pop	{r4, r5, r6, r7, pc}
	VTABLE_CALL(sendto, sock, buf, len, flags, dest_addr, addrlen);
   33ebc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33ec0:	e7fa      	b.n	33eb8 <z_impl_zsock_sendto+0x28>

00033ec2 <zsock_sendmsg_ctx>:
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   33ec2:	0653      	lsls	r3, r2, #25
{
   33ec4:	b513      	push	{r0, r1, r4, lr}
	status = net_context_sendmsg(ctx, msg, flags, NULL, timeout, NULL);
   33ec6:	f04f 0300 	mov.w	r3, #0
		timeout = K_NO_WAIT;
   33eca:	bf4f      	iteee	mi
   33ecc:	2400      	movmi	r4, #0
	if ((flags & ZSOCK_MSG_DONTWAIT) || sock_is_nonblock(ctx)) {
   33ece:	6d84      	ldrpl	r4, [r0, #88]	; 0x58
   33ed0:	f084 0402 	eorpl.w	r4, r4, #2
   33ed4:	f344 0440 	sbfxpl	r4, r4, #1, #1
	status = net_context_sendmsg(ctx, msg, flags, NULL, timeout, NULL);
   33ed8:	e9cd 4300 	strd	r4, r3, [sp]
   33edc:	f001 fdd9 	bl	35a92 <net_context_sendmsg>
	if (status < 0) {
   33ee0:	1e04      	subs	r4, r0, #0
   33ee2:	da05      	bge.n	33ef0 <zsock_sendmsg_ctx+0x2e>
		errno = -status;
   33ee4:	f001 fb00 	bl	354e8 <__errno>
   33ee8:	4264      	negs	r4, r4
   33eea:	6004      	str	r4, [r0, #0]
		return -1;
   33eec:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
   33ef0:	4620      	mov	r0, r4
   33ef2:	b002      	add	sp, #8
   33ef4:	bd10      	pop	{r4, pc}

00033ef6 <sock_sendmsg_vmeth>:
}

static ssize_t sock_sendmsg_vmeth(void *obj, const struct msghdr *msg,
				  int flags)
{
	return zsock_sendmsg_ctx(obj, msg, flags);
   33ef6:	f7ff bfe4 	b.w	33ec2 <zsock_sendmsg_ctx>

00033efa <z_impl_zsock_sendmsg>:
{
   33efa:	b537      	push	{r0, r1, r2, r4, r5, lr}
   33efc:	460c      	mov	r4, r1
	return z_get_fd_obj_and_vtable(sock,
   33efe:	a901      	add	r1, sp, #4
{
   33f00:	4615      	mov	r5, r2
	return z_get_fd_obj_and_vtable(sock,
   33f02:	f7e4 fce7 	bl	188d4 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(sendmsg, sock, msg, flags);
   33f06:	b138      	cbz	r0, 33f18 <z_impl_zsock_sendmsg+0x1e>
   33f08:	9b01      	ldr	r3, [sp, #4]
   33f0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   33f0c:	b123      	cbz	r3, 33f18 <z_impl_zsock_sendmsg+0x1e>
   33f0e:	462a      	mov	r2, r5
   33f10:	4621      	mov	r1, r4
   33f12:	4798      	blx	r3
}
   33f14:	b003      	add	sp, #12
   33f16:	bd30      	pop	{r4, r5, pc}
	VTABLE_CALL(sendmsg, sock, msg, flags);
   33f18:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33f1c:	e7fa      	b.n	33f14 <z_impl_zsock_sendmsg+0x1a>

00033f1e <sock_recvfrom_vmeth>:

static ssize_t sock_recvfrom_vmeth(void *obj, void *buf, size_t max_len,
				   int flags, struct sockaddr *src_addr,
				   socklen_t *addrlen)
{
	return zsock_recvfrom_ctx(obj, buf, max_len, flags,
   33f1e:	f7e5 bbcf 	b.w	196c0 <zsock_recvfrom_ctx>

00033f22 <sock_read_vmeth>:
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
   33f22:	2300      	movs	r3, #0
{
   33f24:	b507      	push	{r0, r1, r2, lr}
	return zsock_recvfrom_ctx(obj, buffer, count, 0, NULL, 0);
   33f26:	e9cd 3300 	strd	r3, r3, [sp]
   33f2a:	f7e5 fbc9 	bl	196c0 <zsock_recvfrom_ctx>
}
   33f2e:	b003      	add	sp, #12
   33f30:	f85d fb04 	ldr.w	pc, [sp], #4

00033f34 <z_impl_zsock_recvfrom>:
{
   33f34:	b5f0      	push	{r4, r5, r6, r7, lr}
   33f36:	b085      	sub	sp, #20
   33f38:	460d      	mov	r5, r1
	return z_get_fd_obj_and_vtable(sock,
   33f3a:	a903      	add	r1, sp, #12
{
   33f3c:	4616      	mov	r6, r2
   33f3e:	461f      	mov	r7, r3
	return z_get_fd_obj_and_vtable(sock,
   33f40:	f7e4 fcc8 	bl	188d4 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   33f44:	b160      	cbz	r0, 33f60 <z_impl_zsock_recvfrom+0x2c>
   33f46:	9b03      	ldr	r3, [sp, #12]
   33f48:	6a1c      	ldr	r4, [r3, #32]
   33f4a:	b14c      	cbz	r4, 33f60 <z_impl_zsock_recvfrom+0x2c>
   33f4c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   33f4e:	4632      	mov	r2, r6
   33f50:	9301      	str	r3, [sp, #4]
   33f52:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   33f54:	4629      	mov	r1, r5
   33f56:	9300      	str	r3, [sp, #0]
   33f58:	463b      	mov	r3, r7
   33f5a:	47a0      	blx	r4
}
   33f5c:	b005      	add	sp, #20
   33f5e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	VTABLE_CALL(recvfrom, sock, buf, max_len, flags, src_addr, addrlen);
   33f60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33f64:	e7fa      	b.n	33f5c <z_impl_zsock_recvfrom+0x28>

00033f66 <zsock_setsockopt_ctx>:
	switch (level) {
   33f66:	2906      	cmp	r1, #6
{
   33f68:	b508      	push	{r3, lr}
	switch (level) {
   33f6a:	d00c      	beq.n	33f86 <zsock_setsockopt_ctx+0x20>
   33f6c:	2929      	cmp	r1, #41	; 0x29
   33f6e:	d00c      	beq.n	33f8a <zsock_setsockopt_ctx+0x24>
   33f70:	2901      	cmp	r1, #1
   33f72:	d101      	bne.n	33f78 <zsock_setsockopt_ctx+0x12>
		switch (optname) {
   33f74:	2a02      	cmp	r2, #2
   33f76:	d00a      	beq.n	33f8e <zsock_setsockopt_ctx+0x28>
	errno = ENOPROTOOPT;
   33f78:	f001 fab6 	bl	354e8 <__errno>
   33f7c:	236d      	movs	r3, #109	; 0x6d
   33f7e:	6003      	str	r3, [r0, #0]
   33f80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   33f84:	bd08      	pop	{r3, pc}
		switch (optname) {
   33f86:	2a01      	cmp	r2, #1
   33f88:	e7f5      	b.n	33f76 <zsock_setsockopt_ctx+0x10>
		switch (optname) {
   33f8a:	2a1a      	cmp	r2, #26
   33f8c:	e7f3      	b.n	33f76 <zsock_setsockopt_ctx+0x10>
			return 0;
   33f8e:	2000      	movs	r0, #0
   33f90:	e7f8      	b.n	33f84 <zsock_setsockopt_ctx+0x1e>

00033f92 <sock_setsockopt_vmeth>:
}

static int sock_setsockopt_vmeth(void *obj, int level, int optname,
				 const void *optval, socklen_t optlen)
{
	return zsock_setsockopt_ctx(obj, level, optname, optval, optlen);
   33f92:	f7ff bfe8 	b.w	33f66 <zsock_setsockopt_ctx>

00033f96 <z_impl_zsock_setsockopt>:
{
   33f96:	b5f0      	push	{r4, r5, r6, r7, lr}
   33f98:	b085      	sub	sp, #20
   33f9a:	460d      	mov	r5, r1
	return z_get_fd_obj_and_vtable(sock,
   33f9c:	a903      	add	r1, sp, #12
{
   33f9e:	4616      	mov	r6, r2
   33fa0:	461f      	mov	r7, r3
	return z_get_fd_obj_and_vtable(sock,
   33fa2:	f7e4 fc97 	bl	188d4 <z_get_fd_obj_and_vtable>
	VTABLE_CALL(setsockopt, sock, level, optname, optval, optlen);
   33fa6:	b150      	cbz	r0, 33fbe <z_impl_zsock_setsockopt+0x28>
   33fa8:	9b03      	ldr	r3, [sp, #12]
   33faa:	6a9c      	ldr	r4, [r3, #40]	; 0x28
   33fac:	b13c      	cbz	r4, 33fbe <z_impl_zsock_setsockopt+0x28>
   33fae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   33fb0:	4632      	mov	r2, r6
   33fb2:	9300      	str	r3, [sp, #0]
   33fb4:	4629      	mov	r1, r5
   33fb6:	463b      	mov	r3, r7
   33fb8:	47a0      	blx	r4
}
   33fba:	b005      	add	sp, #20
   33fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	VTABLE_CALL(setsockopt, sock, level, optname, optval, optlen);
   33fbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33fc2:	e7fa      	b.n	33fba <z_impl_zsock_setsockopt+0x24>

00033fc4 <zsock_getsockname_ctx>:
{
   33fc4:	4603      	mov	r3, r0
   33fc6:	b513      	push	{r0, r1, r4, lr}
   33fc8:	4614      	mov	r4, r2
	if (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.family == AF_INET) {
   33fca:	8b9a      	ldrh	r2, [r3, #28]
{
   33fcc:	4608      	mov	r0, r1
	if (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.family == AF_INET) {
   33fce:	2a01      	cmp	r2, #1
   33fd0:	d113      	bne.n	33ffa <zsock_getsockname_ctx+0x36>
		addr4.sin_family = AF_INET;
   33fd2:	f8ad 2000 	strh.w	r2, [sp]
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
   33fd6:	8bda      	ldrh	r2, [r3, #30]
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
   33fd8:	6a1b      	ldr	r3, [r3, #32]
		addr4.sin_port = net_sin_ptr(&ctx->local)->sin_port;
   33fda:	f8ad 2002 	strh.w	r2, [sp, #2]
		memcpy(addr, &addr4, MIN(*addrlen, newlen));
   33fde:	6822      	ldr	r2, [r4, #0]
		memcpy(&addr4.sin_addr, net_sin_ptr(&ctx->local)->sin_addr,
   33fe0:	681b      	ldr	r3, [r3, #0]
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   33fe2:	2a08      	cmp	r2, #8
   33fe4:	bf28      	it	cs
   33fe6:	2208      	movcs	r2, #8
   33fe8:	4669      	mov	r1, sp
   33fea:	9301      	str	r3, [sp, #4]
   33fec:	f004 fff4 	bl	38fd8 <memcpy>
		newlen = sizeof(struct sockaddr_in);
   33ff0:	2308      	movs	r3, #8
}
   33ff2:	2000      	movs	r0, #0
	*addrlen = newlen;
   33ff4:	6023      	str	r3, [r4, #0]
}
   33ff6:	b002      	add	sp, #8
   33ff8:	bd10      	pop	{r4, pc}
	socklen_t newlen = 0;
   33ffa:	2300      	movs	r3, #0
   33ffc:	e7f9      	b.n	33ff2 <zsock_getsockname_ctx+0x2e>

00033ffe <sock_ioctl_vmeth>:
	switch (request) {
   33ffe:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
{
   34002:	b538      	push	{r3, r4, r5, lr}
   34004:	4604      	mov	r4, r0
   34006:	4613      	mov	r3, r2
	switch (request) {
   34008:	d04e      	beq.n	340a8 <sock_ioctl_vmeth+0xaa>
   3400a:	d80a      	bhi.n	34022 <sock_ioctl_vmeth+0x24>
   3400c:	2903      	cmp	r1, #3
   3400e:	d039      	beq.n	34084 <sock_ioctl_vmeth+0x86>
   34010:	2904      	cmp	r1, #4
   34012:	d03c      	beq.n	3408e <sock_ioctl_vmeth+0x90>
		errno = EOPNOTSUPP;
   34014:	f001 fa68 	bl	354e8 <__errno>
   34018:	235f      	movs	r3, #95	; 0x5f
   3401a:	6003      	str	r3, [r0, #0]
		return -1;
   3401c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   34020:	e034      	b.n	3408c <sock_ioctl_vmeth+0x8e>
	switch (request) {
   34022:	f5b1 7f82 	cmp.w	r1, #260	; 0x104
   34026:	d043      	beq.n	340b0 <sock_ioctl_vmeth+0xb2>
   34028:	f5b1 7f83 	cmp.w	r1, #262	; 0x106
   3402c:	d05a      	beq.n	340e4 <sock_ioctl_vmeth+0xe6>
   3402e:	f240 1203 	movw	r2, #259	; 0x103
   34032:	4291      	cmp	r1, r2
   34034:	d1ee      	bne.n	34014 <sock_ioctl_vmeth+0x16>
		return zsock_poll_prepare_ctx(obj, pfd, pev, pev_end);
   34036:	681a      	ldr	r2, [r3, #0]
	if (pfd->events & ZSOCK_POLLIN) {
   34038:	8891      	ldrh	r1, [r2, #4]
   3403a:	07c8      	lsls	r0, r1, #31
   3403c:	d51a      	bpl.n	34074 <sock_ioctl_vmeth+0x76>
		pev = va_arg(args, struct k_poll_event **);
   3403e:	685a      	ldr	r2, [r3, #4]
		if (*pev == pev_end) {
   34040:	689b      	ldr	r3, [r3, #8]
   34042:	6810      	ldr	r0, [r2, #0]
   34044:	4283      	cmp	r3, r0
   34046:	d056      	beq.n	340f6 <sock_ioctl_vmeth+0xf8>
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
   34048:	2504      	movs	r5, #4
		(*pev)->obj = &ctx->recv_q;
   3404a:	f104 035c 	add.w	r3, r4, #92	; 0x5c
   3404e:	6103      	str	r3, [r0, #16]
		(*pev)->type = K_POLL_TYPE_FIFO_DATA_AVAILABLE;
   34050:	6813      	ldr	r3, [r2, #0]
   34052:	7b58      	ldrb	r0, [r3, #13]
   34054:	f365 0003 	bfi	r0, r5, #0, #4
   34058:	7358      	strb	r0, [r3, #13]
		(*pev)->mode = K_POLL_MODE_NOTIFY_ONLY;
   3405a:	6813      	ldr	r3, [r2, #0]
   3405c:	7b98      	ldrb	r0, [r3, #14]
   3405e:	f36f 0041 	bfc	r0, #1, #1
   34062:	7398      	strb	r0, [r3, #14]
		(*pev)->state = K_POLL_STATE_NOT_READY;
   34064:	6813      	ldr	r3, [r2, #0]
   34066:	68d8      	ldr	r0, [r3, #12]
   34068:	f36f 3010 	bfc	r0, #12, #5
   3406c:	60d8      	str	r0, [r3, #12]
		(*pev)++;
   3406e:	6813      	ldr	r3, [r2, #0]
   34070:	3314      	adds	r3, #20
   34072:	6013      	str	r3, [r2, #0]
	if (pfd->events & ZSOCK_POLLOUT) {
   34074:	0749      	lsls	r1, r1, #29
   34076:	d402      	bmi.n	3407e <sock_ioctl_vmeth+0x80>
	return POINTER_TO_UINT(ctx->socket_data) & mask;
   34078:	6da3      	ldr	r3, [r4, #88]	; 0x58
	if (sock_is_eof(ctx)) {
   3407a:	07da      	lsls	r2, r3, #31
   3407c:	d505      	bpl.n	3408a <sock_ioctl_vmeth+0x8c>
		return -EALREADY;
   3407e:	f06f 0077 	mvn.w	r0, #119	; 0x77
   34082:	e003      	b.n	3408c <sock_ioctl_vmeth+0x8e>
   34084:	6d83      	ldr	r3, [r0, #88]	; 0x58
		if (sock_is_nonblock(obj)) {
   34086:	079c      	lsls	r4, r3, #30
   34088:	d432      	bmi.n	340f0 <sock_ioctl_vmeth+0xf2>
		return 0;
   3408a:	2000      	movs	r0, #0
}
   3408c:	bd38      	pop	{r3, r4, r5, pc}
		if (flags & O_NONBLOCK) {
   3408e:	6810      	ldr	r0, [r2, #0]
   34090:	6da3      	ldr	r3, [r4, #88]	; 0x58
   34092:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
   34096:	f023 0302 	bic.w	r3, r3, #2
   3409a:	d003      	beq.n	340a4 <sock_ioctl_vmeth+0xa6>
	val = (val & ~mask) | flag;
   3409c:	f043 0302 	orr.w	r3, r3, #2
	(ctx)->socket_data = UINT_TO_POINTER(val);
   340a0:	65a3      	str	r3, [r4, #88]	; 0x58
   340a2:	e7f2      	b.n	3408a <sock_ioctl_vmeth+0x8c>
   340a4:	65a3      	str	r3, [r4, #88]	; 0x58
   340a6:	e7f1      	b.n	3408c <sock_ioctl_vmeth+0x8e>
}
   340a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return zsock_close_ctx(obj);
   340ac:	f7ff be82 	b.w	33db4 <zsock_close_ctx>
		pev = va_arg(args, struct k_poll_event **);
   340b0:	e9d2 2000 	ldrd	r2, r0, [r2]
	if (pfd->events & ZSOCK_POLLOUT) {
   340b4:	8891      	ldrh	r1, [r2, #4]
   340b6:	074b      	lsls	r3, r1, #29
		pfd->revents |= ZSOCK_POLLOUT;
   340b8:	bf42      	ittt	mi
   340ba:	88d3      	ldrhmi	r3, [r2, #6]
   340bc:	f043 0304 	orrmi.w	r3, r3, #4
   340c0:	80d3      	strhmi	r3, [r2, #6]
	if (pfd->events & ZSOCK_POLLIN) {
   340c2:	07cd      	lsls	r5, r1, #31
   340c4:	d5e1      	bpl.n	3408a <sock_ioctl_vmeth+0x8c>
		if ((*pev)->state != K_POLL_STATE_NOT_READY || sock_is_eof(ctx)) {
   340c6:	6803      	ldr	r3, [r0, #0]
   340c8:	68d9      	ldr	r1, [r3, #12]
   340ca:	f411 3ff8 	tst.w	r1, #126976	; 0x1f000
   340ce:	d102      	bne.n	340d6 <sock_ioctl_vmeth+0xd8>
	return POINTER_TO_UINT(ctx->socket_data) & mask;
   340d0:	6da1      	ldr	r1, [r4, #88]	; 0x58
   340d2:	07c9      	lsls	r1, r1, #31
   340d4:	d503      	bpl.n	340de <sock_ioctl_vmeth+0xe0>
			pfd->revents |= ZSOCK_POLLIN;
   340d6:	88d1      	ldrh	r1, [r2, #6]
   340d8:	f041 0101 	orr.w	r1, r1, #1
   340dc:	80d1      	strh	r1, [r2, #6]
		(*pev)++;
   340de:	3314      	adds	r3, #20
   340e0:	6003      	str	r3, [r0, #0]
   340e2:	e7d2      	b.n	3408a <sock_ioctl_vmeth+0x8c>
		return zsock_getsockname_ctx(obj, addr, addrlen);
   340e4:	e9d2 1200 	ldrd	r1, r2, [r2]
}
   340e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return zsock_getsockname_ctx(obj, addr, addrlen);
   340ec:	f7ff bf6a 	b.w	33fc4 <zsock_getsockname_ctx>
		    return O_NONBLOCK;
   340f0:	f44f 4080 	mov.w	r0, #16384	; 0x4000
   340f4:	e7ca      	b.n	3408c <sock_ioctl_vmeth+0x8e>
			return -ENOMEM;
   340f6:	f06f 000b 	mvn.w	r0, #11
   340fa:	e7c7      	b.n	3408c <sock_ioctl_vmeth+0x8e>

000340fc <settings_load>:
	return settings_load_subtree(NULL);
   340fc:	2000      	movs	r0, #0
   340fe:	f7e5 bddb 	b.w	19cb8 <settings_load_subtree>

00034102 <settings_name_steq>:
{
   34102:	b530      	push	{r4, r5, lr}
	if (next) {
   34104:	b10a      	cbz	r2, 3410a <settings_name_steq+0x8>
		*next = NULL;
   34106:	2300      	movs	r3, #0
   34108:	6013      	str	r3, [r2, #0]
	if ((!name) || (!key)) {
   3410a:	b190      	cbz	r0, 34132 <settings_name_steq+0x30>
   3410c:	b151      	cbz	r1, 34124 <settings_name_steq+0x22>
   3410e:	1e4d      	subs	r5, r1, #1
	while ((*key != '\0') && (*key == *name) &&
   34110:	f815 4f01 	ldrb.w	r4, [r5, #1]!
   34114:	4603      	mov	r3, r0
   34116:	f810 1b01 	ldrb.w	r1, [r0], #1
   3411a:	b15c      	cbz	r4, 34134 <settings_name_steq+0x32>
   3411c:	428c      	cmp	r4, r1
   3411e:	d101      	bne.n	34124 <settings_name_steq+0x22>
	       (*name != '\0') && (*name != SETTINGS_NAME_END)) {
   34120:	2c3d      	cmp	r4, #61	; 0x3d
   34122:	d1f5      	bne.n	34110 <settings_name_steq+0xe>
	return 0;
   34124:	2000      	movs	r0, #0
   34126:	e004      	b.n	34132 <settings_name_steq+0x30>
	if ((*name == SETTINGS_NAME_END) || (*name == '\0')) {
   34128:	293d      	cmp	r1, #61	; 0x3d
   3412a:	d008      	beq.n	3413e <settings_name_steq+0x3c>
   3412c:	fab1 f081 	clz	r0, r1
   34130:	0940      	lsrs	r0, r0, #5
}
   34132:	bd30      	pop	{r4, r5, pc}
	if (*name == SETTINGS_NAME_SEPARATOR) {
   34134:	292f      	cmp	r1, #47	; 0x2f
   34136:	d1f7      	bne.n	34128 <settings_name_steq+0x26>
		if (next) {
   34138:	b10a      	cbz	r2, 3413e <settings_name_steq+0x3c>
			*next = name + 1;
   3413a:	3301      	adds	r3, #1
   3413c:	6013      	str	r3, [r2, #0]
		return 1;
   3413e:	2001      	movs	r0, #1
   34140:	e7f7      	b.n	34132 <settings_name_steq+0x30>

00034142 <settings_backend_init>:
 */

int settings_backend_init(void)
{
	return 0;
}
   34142:	2000      	movs	r0, #0
   34144:	4770      	bx	lr

00034146 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
   34146:	2200      	movs	r2, #0
   34148:	f7e5 bf0c 	b.w	19f64 <clock_async_start>

0003414c <wdt_nrf_disable>:
}
   3414c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   34150:	4770      	bx	lr

00034152 <wdt_nrf_feed>:
{
   34152:	b508      	push	{r3, lr}
	if (channel_id > get_dev_data(dev)->m_allocated_channels) {
   34154:	68c3      	ldr	r3, [r0, #12]
   34156:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   3415a:	428b      	cmp	r3, r1
   3415c:	db05      	blt.n	3416a <wdt_nrf_feed+0x18>
	nrfx_wdt_channel_feed(&get_dev_config(dev)->wdt,
   3415e:	6840      	ldr	r0, [r0, #4]
   34160:	b2c9      	uxtb	r1, r1
   34162:	f7f7 fb0f 	bl	2b784 <nrfx_wdt_channel_feed>
	return 0;
   34166:	2000      	movs	r0, #0
}
   34168:	bd08      	pop	{r3, pc}
		return -EINVAL;
   3416a:	f06f 0015 	mvn.w	r0, #21
   3416e:	e7fb      	b.n	34168 <wdt_nrf_feed+0x16>

00034170 <wdt_nrf_setup>:
		behaviour &= ~NRF_WDT_BEHAVIOUR_RUN_SLEEP;
   34170:	f011 0f01 	tst.w	r1, #1
{
   34174:	b538      	push	{r3, r4, r5, lr}
		behaviour &= ~NRF_WDT_BEHAVIOUR_RUN_SLEEP;
   34176:	bf0c      	ite	eq
   34178:	2309      	moveq	r3, #9
   3417a:	2308      	movne	r3, #8
	nrf_wdt_behaviour_set(get_dev_config(dev)->wdt.p_reg, behaviour);
   3417c:	6844      	ldr	r4, [r0, #4]
	if (options & WDT_OPT_PAUSE_HALTED_BY_DBG) {
   3417e:	078a      	lsls	r2, r1, #30
	nrf_wdt_behaviour_set(get_dev_config(dev)->wdt.p_reg, behaviour);
   34180:	6825      	ldr	r5, [r4, #0]
		behaviour &= ~NRF_WDT_BEHAVIOUR_RUN_HALT;
   34182:	bf48      	it	mi
   34184:	f003 0301 	andmi.w	r3, r3, #1
    p_reg->CONFIG = behaviour;
   34188:	f8c5 350c 	str.w	r3, [r5, #1292]	; 0x50c
		(uint32_t)(((uint64_t)get_dev_data(dev)->m_timeout * 32768U)
   3418c:	68c3      	ldr	r3, [r0, #12]
			   / 1000));
   3418e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
		(uint32_t)(((uint64_t)get_dev_data(dev)->m_timeout * 32768U)
   34192:	6a19      	ldr	r1, [r3, #32]
			   / 1000));
   34194:	2300      	movs	r3, #0
   34196:	03c8      	lsls	r0, r1, #15
   34198:	0c49      	lsrs	r1, r1, #17
   3419a:	f7d9 fae9 	bl	d770 <__aeabi_uldivmod>
    p_reg->CRV = reload_value;
   3419e:	f8c5 0504 	str.w	r0, [r5, #1284]	; 0x504
	nrfx_wdt_enable(&get_dev_config(dev)->wdt);
   341a2:	4620      	mov	r0, r4
   341a4:	f7f7 fa70 	bl	2b688 <nrfx_wdt_enable>
}
   341a8:	2000      	movs	r0, #0
   341aa:	bd38      	pop	{r3, r4, r5, pc}

000341ac <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   341ac:	4770      	bx	lr

000341ae <sys_clock_disable>:
   341ae:	4770      	bx	lr

000341b0 <_copy>:
#define MASK_TWENTY_SEVEN 0x1b

unsigned int _copy(uint8_t *to, unsigned int to_len,
		   const uint8_t *from, unsigned int from_len)
{
	if (from_len <= to_len) {
   341b0:	428b      	cmp	r3, r1
{
   341b2:	b538      	push	{r3, r4, r5, lr}
   341b4:	4615      	mov	r5, r2
   341b6:	461c      	mov	r4, r3
	if (from_len <= to_len) {
   341b8:	d805      	bhi.n	341c6 <_copy+0x16>
   341ba:	461a      	mov	r2, r3
   341bc:	4629      	mov	r1, r5
   341be:	f004 ff0b 	bl	38fd8 <memcpy>
		(void)memcpy(to, from, from_len);
		return from_len;
	} else {
		return TC_CRYPTO_FAIL;
	}
}
   341c2:	4620      	mov	r0, r4
   341c4:	bd38      	pop	{r3, r4, r5, pc}
		return TC_CRYPTO_FAIL;
   341c6:	2400      	movs	r4, #0
   341c8:	e7fb      	b.n	341c2 <_copy+0x12>

000341ca <_set>:
__ssp_bos_icheck3(memset, void *, int)
   341ca:	f004 bf3f 	b.w	3904c <memset>

000341ce <_double_byte>:
/*
 * Doubles the value of a byte for values up to 127.
 */
uint8_t _double_byte(uint8_t a)
{
	return ((a<<1) ^ ((a>>7) * MASK_TWENTY_SEVEN));
   341ce:	09c3      	lsrs	r3, r0, #7
   341d0:	005a      	lsls	r2, r3, #1
   341d2:	4413      	add	r3, r2
   341d4:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
   341d8:	ea83 0040 	eor.w	r0, r3, r0, lsl #1
}
   341dc:	b2c0      	uxtb	r0, r0
   341de:	4770      	bx	lr

000341e0 <bits2int>:
static uECC_RNG_Function g_rng_function = 0;
#endif

static void bits2int(uECC_word_t *native, const uint8_t *bits,
		     unsigned bits_size, uECC_Curve curve)
{
   341e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   341e4:	461f      	mov	r7, r3
	unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
   341e6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
   341ea:	4689      	mov	r9, r1
	unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   341ec:	f113 011f 	adds.w	r1, r3, #31
   341f0:	bf48      	it	mi
   341f2:	f103 013e 	addmi.w	r1, r3, #62	; 0x3e
   341f6:	114d      	asrs	r5, r1, #5
	unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);
   341f8:	1dd9      	adds	r1, r3, #7
   341fa:	bf48      	it	mi
   341fc:	f103 010e 	addmi.w	r1, r3, #14
   34200:	10cc      	asrs	r4, r1, #3
   34202:	4294      	cmp	r4, r2
   34204:	bf28      	it	cs
   34206:	4614      	movcs	r4, r2
{
   34208:	4606      	mov	r6, r0

	if (bits_size > num_n_bytes) {
		bits_size = num_n_bytes;
	}

	uECC_vli_clear(native, num_n_words);
   3420a:	fa4f f885 	sxtb.w	r8, r5
   3420e:	4641      	mov	r1, r8
   34210:	f000 f9c2 	bl	34598 <uECC_vli_clear>
	uECC_vli_bytesToNative(native, bits, bits_size);
   34214:	4622      	mov	r2, r4
   34216:	4649      	mov	r1, r9
   34218:	4630      	mov	r0, r6
   3421a:	f000 febd 	bl	34f98 <uECC_vli_bytesToNative>
	if (bits_size * 8 <= (unsigned)curve->num_n_bits) {
   3421e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
   34222:	00e4      	lsls	r4, r4, #3
   34224:	4294      	cmp	r4, r2
   34226:	d920      	bls.n	3426a <bits2int+0x8a>
		return;
	}
	shift = bits_size * 8 - curve->num_n_bits;
   34228:	1aa4      	subs	r4, r4, r2
	carry = 0;
   3422a:	2200      	movs	r2, #0
	ptr = native + num_n_words;
   3422c:	eb06 0185 	add.w	r1, r6, r5, lsl #2
	while (ptr-- > native) {
		uECC_word_t temp = *ptr;
		*ptr = (temp >> shift) | carry;
		carry = temp << (uECC_WORD_BITS - shift);
   34230:	f1c4 0520 	rsb	r5, r4, #32
	while (ptr-- > native) {
   34234:	428e      	cmp	r6, r1
   34236:	d30f      	bcc.n	34258 <bits2int+0x78>
	}

	/* Reduce mod curve_n */
	if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {
   34238:	3724      	adds	r7, #36	; 0x24
   3423a:	4642      	mov	r2, r8
   3423c:	4631      	mov	r1, r6
   3423e:	4638      	mov	r0, r7
   34240:	f000 f9fb 	bl	3463a <uECC_vli_cmp_unsafe>
   34244:	2801      	cmp	r0, #1
   34246:	d010      	beq.n	3426a <bits2int+0x8a>
		uECC_vli_sub(native, native, curve->n, num_n_words);
   34248:	4643      	mov	r3, r8
   3424a:	463a      	mov	r2, r7
   3424c:	4631      	mov	r1, r6
   3424e:	4630      	mov	r0, r6
	}
}
   34250:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		uECC_vli_sub(native, native, curve->n, num_n_words);
   34254:	f000 ba08 	b.w	34668 <uECC_vli_sub>
		uECC_word_t temp = *ptr;
   34258:	f851 0d04 	ldr.w	r0, [r1, #-4]!
		*ptr = (temp >> shift) | carry;
   3425c:	fa20 f304 	lsr.w	r3, r0, r4
   34260:	4313      	orrs	r3, r2
   34262:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - shift);
   34264:	fa00 f205 	lsl.w	r2, r0, r5
   34268:	e7e4      	b.n	34234 <bits2int+0x54>
}
   3426a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0003426e <uECC_sign_with_k>:

int uECC_sign_with_k(const uint8_t *private_key, const uint8_t *message_hash,
		     unsigned hash_size, uECC_word_t *k, uint8_t *signature,
		     uECC_Curve curve)
{
   3426e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34272:	461e      	mov	r6, r3
   34274:	b0a9      	sub	sp, #164	; 0xa4
   34276:	9d33      	ldr	r5, [sp, #204]	; 0xcc
   34278:	e9cd 0103 	strd	r0, r1, [sp, #12]
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t s[NUM_ECC_WORDS];
	uECC_word_t *k2[2] = {tmp, s};
	uECC_word_t p[NUM_ECC_WORDS * 2];
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
   3427c:	f995 a000 	ldrsb.w	sl, [r5]
	uECC_word_t *k2[2] = {tmp, s};
   34280:	f10d 0920 	add.w	r9, sp, #32
   34284:	ab10      	add	r3, sp, #64	; 0x40
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
	bitcount_t num_n_bits = curve->num_n_bits;

	/* Make sure 0 < k < curve_n */
  	if (uECC_vli_isZero(k, num_words) ||
   34286:	4651      	mov	r1, sl
   34288:	4630      	mov	r0, r6
{
   3428a:	9205      	str	r2, [sp, #20]
	uECC_word_t *k2[2] = {tmp, s};
   3428c:	f8cd 9018 	str.w	r9, [sp, #24]
   34290:	9307      	str	r3, [sp, #28]
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   34292:	f9b5 7002 	ldrsh.w	r7, [r5, #2]
  	if (uECC_vli_isZero(k, num_words) ||
   34296:	f000 f98a 	bl	345ae <uECC_vli_isZero>
   3429a:	b118      	cbz	r0, 342a4 <uECC_sign_with_k+0x36>
	    uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
		return 0;
   3429c:	2000      	movs	r0, #0
		return 0;
	}

	uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);
	return 1;
}
   3429e:	b029      	add	sp, #164	; 0xa4
   342a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   342a4:	f117 041f 	adds.w	r4, r7, #31
   342a8:	bf48      	it	mi
   342aa:	f107 043e 	addmi.w	r4, r7, #62	; 0x3e
   342ae:	f344 1447 	sbfx	r4, r4, #5, #8
	    uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
   342b2:	f105 0824 	add.w	r8, r5, #36	; 0x24
   342b6:	4622      	mov	r2, r4
   342b8:	4631      	mov	r1, r6
   342ba:	4640      	mov	r0, r8
   342bc:	f000 f9ed 	bl	3469a <uECC_vli_cmp>
  	if (uECC_vli_isZero(k, num_words) ||
   342c0:	2801      	cmp	r0, #1
	    uECC_vli_cmp(curve->n, k, num_n_words) != 1) {
   342c2:	4683      	mov	fp, r0
  	if (uECC_vli_isZero(k, num_words) ||
   342c4:	d1ea      	bne.n	3429c <uECC_sign_with_k+0x2e>
	carry = regularize_k(k, tmp, s, curve);
   342c6:	462b      	mov	r3, r5
   342c8:	aa10      	add	r2, sp, #64	; 0x40
   342ca:	4649      	mov	r1, r9
   342cc:	4630      	mov	r0, r6
   342ce:	f000 fe22 	bl	34f16 <regularize_k>
	EccPoint_mult(p, curve->G, k2[!carry], 0, num_n_bits + 1, curve);
   342d2:	fab0 f080 	clz	r0, r0
   342d6:	3701      	adds	r7, #1
   342d8:	ab28      	add	r3, sp, #160	; 0xa0
   342da:	0940      	lsrs	r0, r0, #5
   342dc:	b23f      	sxth	r7, r7
   342de:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   342e2:	9501      	str	r5, [sp, #4]
   342e4:	9700      	str	r7, [sp, #0]
   342e6:	f850 2c88 	ldr.w	r2, [r0, #-136]
   342ea:	f105 0144 	add.w	r1, r5, #68	; 0x44
   342ee:	a818      	add	r0, sp, #96	; 0x60
   342f0:	2300      	movs	r3, #0
   342f2:	f000 fd41 	bl	34d78 <EccPoint_mult>
	if (uECC_vli_isZero(p, num_words)) {
   342f6:	4651      	mov	r1, sl
   342f8:	a818      	add	r0, sp, #96	; 0x60
   342fa:	f000 f958 	bl	345ae <uECC_vli_isZero>
   342fe:	2800      	cmp	r0, #0
   34300:	d1cc      	bne.n	3429c <uECC_sign_with_k+0x2e>
		uECC_vli_clear(tmp, num_n_words);
   34302:	4621      	mov	r1, r4
   34304:	4648      	mov	r0, r9
   34306:	f000 f947 	bl	34598 <uECC_vli_clear>
	uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */
   3430a:	4643      	mov	r3, r8
   3430c:	464a      	mov	r2, r9
   3430e:	4631      	mov	r1, r6
   34310:	4630      	mov	r0, r6
   34312:	9400      	str	r4, [sp, #0]
		tmp[0] = 1;
   34314:	f8cd b020 	str.w	fp, [sp, #32]
	uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k' = rand * k */
   34318:	f000 faa0 	bl	3485c <uECC_vli_modMult>
	uECC_vli_modInv(k, k, curve->n, num_n_words);       /* k = 1 / k' */
   3431c:	4623      	mov	r3, r4
   3431e:	4642      	mov	r2, r8
   34320:	4631      	mov	r1, r6
   34322:	4630      	mov	r0, r6
   34324:	f000 fc21 	bl	34b6a <uECC_vli_modInv>
	uECC_vli_modMult(k, k, tmp, curve->n, num_n_words); /* k = 1 / k */
   34328:	4643      	mov	r3, r8
   3432a:	464a      	mov	r2, r9
   3432c:	4631      	mov	r1, r6
   3432e:	4630      	mov	r0, r6
   34330:	9400      	str	r4, [sp, #0]
   34332:	f000 fa93 	bl	3485c <uECC_vli_modMult>
	uECC_vli_nativeToBytes(signature, curve->num_bytes, p); /* store r */
   34336:	aa18      	add	r2, sp, #96	; 0x60
   34338:	f995 1001 	ldrsb.w	r1, [r5, #1]
   3433c:	9832      	ldr	r0, [sp, #200]	; 0xc8
   3433e:	f000 fe17 	bl	34f70 <uECC_vli_nativeToBytes>
	uECC_vli_bytesToNative(tmp, private_key, BITS_TO_BYTES(curve->num_n_bits));
   34342:	f9b5 3002 	ldrsh.w	r3, [r5, #2]
   34346:	9903      	ldr	r1, [sp, #12]
   34348:	1dda      	adds	r2, r3, #7
   3434a:	bf48      	it	mi
   3434c:	f103 020e 	addmi.w	r2, r3, #14
   34350:	10d2      	asrs	r2, r2, #3
   34352:	a808      	add	r0, sp, #32
   34354:	f000 fe20 	bl	34f98 <uECC_vli_bytesToNative>
	s[num_n_words - 1] = 0;
   34358:	aa28      	add	r2, sp, #160	; 0xa0
   3435a:	1e63      	subs	r3, r4, #1
   3435c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   34360:	2200      	movs	r2, #0
	uECC_vli_set(s, p, num_words);
   34362:	a918      	add	r1, sp, #96	; 0x60
	s[num_n_words - 1] = 0;
   34364:	f843 2c60 	str.w	r2, [r3, #-96]
	uECC_vli_set(s, p, num_words);
   34368:	a810      	add	r0, sp, #64	; 0x40
   3436a:	4652      	mov	r2, sl
   3436c:	f000 f959 	bl	34622 <uECC_vli_set>
	uECC_vli_modMult(s, tmp, s, curve->n, num_n_words); /* s = r*d */
   34370:	aa10      	add	r2, sp, #64	; 0x40
   34372:	4610      	mov	r0, r2
   34374:	4643      	mov	r3, r8
   34376:	a908      	add	r1, sp, #32
   34378:	9400      	str	r4, [sp, #0]
   3437a:	f000 fa6f 	bl	3485c <uECC_vli_modMult>
	bits2int(tmp, message_hash, hash_size, curve);
   3437e:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
   34382:	462b      	mov	r3, r5
   34384:	a808      	add	r0, sp, #32
   34386:	f7ff ff2b 	bl	341e0 <bits2int>
	uECC_vli_modAdd(s, tmp, s, curve->n, num_n_words); /* s = e + r*d */
   3438a:	aa10      	add	r2, sp, #64	; 0x40
   3438c:	4610      	mov	r0, r2
   3438e:	4643      	mov	r3, r8
   34390:	a908      	add	r1, sp, #32
   34392:	9400      	str	r4, [sp, #0]
   34394:	f000 f99a 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modMult(s, s, k, curve->n, num_n_words);  /* s = (e + r*d) / k */
   34398:	a910      	add	r1, sp, #64	; 0x40
   3439a:	4608      	mov	r0, r1
   3439c:	4643      	mov	r3, r8
   3439e:	4632      	mov	r2, r6
   343a0:	9400      	str	r4, [sp, #0]
   343a2:	f000 fa5b 	bl	3485c <uECC_vli_modMult>
	if (uECC_vli_numBits(s, num_n_words) > (bitcount_t)curve->num_bytes * 8) {
   343a6:	4621      	mov	r1, r4
   343a8:	a810      	add	r0, sp, #64	; 0x40
   343aa:	f000 f919 	bl	345e0 <uECC_vli_numBits>
   343ae:	f995 1001 	ldrsb.w	r1, [r5, #1]
   343b2:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
   343b6:	f73f af71 	bgt.w	3429c <uECC_sign_with_k+0x2e>
	uECC_vli_nativeToBytes(signature + curve->num_bytes, curve->num_bytes, s);
   343ba:	9b32      	ldr	r3, [sp, #200]	; 0xc8
   343bc:	aa10      	add	r2, sp, #64	; 0x40
   343be:	1858      	adds	r0, r3, r1
   343c0:	f000 fdd6 	bl	34f70 <uECC_vli_nativeToBytes>
	return 1;
   343c4:	2001      	movs	r0, #1
   343c6:	e76a      	b.n	3429e <uECC_sign_with_k+0x30>

000343c8 <uECC_sign>:

int uECC_sign(const uint8_t *private_key, const uint8_t *message_hash,
	      unsigned hash_size, uint8_t *signature, uECC_Curve curve)
{
   343c8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   343cc:	4606      	mov	r6, r0
   343ce:	460f      	mov	r7, r1
   343d0:	4690      	mov	r8, r2
   343d2:	4699      	mov	r9, r3
   343d4:	2440      	movs	r4, #64	; 0x40
   343d6:	b09a      	sub	sp, #104	; 0x68
   343d8:	9d22      	ldr	r5, [sp, #136]	; 0x88
		    !rng_function((uint8_t *)_random, 2*NUM_ECC_WORDS*uECC_WORD_SIZE)) {
			return 0;
		}

		// computing k as modular reduction of _random (see FIPS 186.4 B.5.1):
		uECC_vli_mmod(k, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   343da:	f105 0a24 	add.w	sl, r5, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
   343de:	f7e6 f8e7 	bl	1a5b0 <uECC_get_rng>
		if (!rng_function ||
   343e2:	4603      	mov	r3, r0
   343e4:	b1e0      	cbz	r0, 34420 <uECC_sign+0x58>
		    !rng_function((uint8_t *)_random, 2*NUM_ECC_WORDS*uECC_WORD_SIZE)) {
   343e6:	2140      	movs	r1, #64	; 0x40
   343e8:	a80a      	add	r0, sp, #40	; 0x28
   343ea:	4798      	blx	r3
		if (!rng_function ||
   343ec:	b1c0      	cbz	r0, 34420 <uECC_sign+0x58>
		uECC_vli_mmod(k, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
   343ee:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
   343f2:	a90a      	add	r1, sp, #40	; 0x28
   343f4:	f112 031f 	adds.w	r3, r2, #31
   343f8:	bf48      	it	mi
   343fa:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
   343fe:	f343 1347 	sbfx	r3, r3, #5, #8
   34402:	4652      	mov	r2, sl
   34404:	a802      	add	r0, sp, #8
   34406:	f000 f98c 	bl	34722 <uECC_vli_mmod>

		if (uECC_sign_with_k(private_key, message_hash, hash_size, k, signature, 
   3440a:	e9cd 9500 	strd	r9, r5, [sp]
   3440e:	ab02      	add	r3, sp, #8
   34410:	4642      	mov	r2, r8
   34412:	4639      	mov	r1, r7
   34414:	4630      	mov	r0, r6
   34416:	f7ff ff2a 	bl	3426e <uECC_sign_with_k>
   3441a:	b928      	cbnz	r0, 34428 <uECC_sign+0x60>
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
   3441c:	3c01      	subs	r4, #1
   3441e:	d1de      	bne.n	343de <uECC_sign+0x16>
			return 0;
   34420:	2000      	movs	r0, #0
		    curve)) {
			return 1;
		}
	}
	return 0;
}
   34422:	b01a      	add	sp, #104	; 0x68
   34424:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return 1;
   34428:	2001      	movs	r0, #1
   3442a:	e7fa      	b.n	34422 <uECC_sign+0x5a>

0003442c <uECC_vli_add>:
{
   3442c:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   3442e:	2400      	movs	r4, #0
{
   34430:	4607      	mov	r7, r0
	uECC_word_t carry = 0;
   34432:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   34434:	b265      	sxtb	r5, r4
   34436:	42ab      	cmp	r3, r5
   34438:	dc00      	bgt.n	3443c <uECC_vli_add+0x10>
}
   3443a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
   3443c:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   34440:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
   34444:	4435      	add	r5, r6
   34446:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
   34448:	42ae      	cmp	r6, r5
		uECC_word_t val = (sum < left[i]);
   3444a:	bf8c      	ite	hi
   3444c:	2601      	movhi	r6, #1
   3444e:	2600      	movls	r6, #0
		result[i] = sum;
   34450:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   34454:	bf18      	it	ne
   34456:	4630      	movne	r0, r6
		result[i] = sum;
   34458:	3401      	adds	r4, #1
   3445a:	e7eb      	b.n	34434 <uECC_vli_add+0x8>

0003445c <uECC_vli_rshift1>:
	uECC_word_t carry = 0;
   3445c:	2300      	movs	r3, #0
	vli += num_words;
   3445e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	while (vli-- > end) {
   34462:	4288      	cmp	r0, r1
   34464:	d300      	bcc.n	34468 <uECC_vli_rshift1+0xc>
}
   34466:	4770      	bx	lr
		uECC_word_t temp = *vli;
   34468:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
   3446c:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
   34470:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
   34472:	07d3      	lsls	r3, r2, #31
   34474:	e7f5      	b.n	34462 <uECC_vli_rshift1+0x6>

00034476 <vli_modInv_update>:
	if (!EVEN(uv)) {
   34476:	6803      	ldr	r3, [r0, #0]
{
   34478:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
   3447a:	f013 0601 	ands.w	r6, r3, #1
{
   3447e:	4605      	mov	r5, r0
   34480:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
   34482:	d005      	beq.n	34490 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
   34484:	4613      	mov	r3, r2
   34486:	460a      	mov	r2, r1
   34488:	4601      	mov	r1, r0
   3448a:	f7ff ffcf 	bl	3442c <uECC_vli_add>
   3448e:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
   34490:	4621      	mov	r1, r4
   34492:	4628      	mov	r0, r5
   34494:	f7ff ffe2 	bl	3445c <uECC_vli_rshift1>
	if (carry) {
   34498:	b146      	cbz	r6, 344ac <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
   3449a:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
   3449e:	3a01      	subs	r2, #1
   344a0:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
   344a4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   344a8:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
   344ac:	bd70      	pop	{r4, r5, r6, pc}

000344ae <uECC_vli_mult>:
{
   344ae:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
   344b2:	2500      	movs	r5, #0
{
   344b4:	b087      	sub	sp, #28
   344b6:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
   344ba:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
   344bc:	462a      	mov	r2, r5
   344be:	fa4f f885 	sxtb.w	r8, r5
	for (k = 0; k < num_words; ++k) {
   344c2:	4543      	cmp	r3, r8
   344c4:	dc16      	bgt.n	344f4 <uECC_vli_mult+0x46>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
   344c6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   344ca:	f04f 0a00 	mov.w	sl, #0
   344ce:	eb05 0543 	add.w	r5, r5, r3, lsl #1
   344d2:	9502      	str	r5, [sp, #8]
   344d4:	fa5f f58a 	uxtb.w	r5, sl
   344d8:	eb05 0c03 	add.w	ip, r5, r3
   344dc:	9e02      	ldr	r6, [sp, #8]
   344de:	fa4f fc8c 	sxtb.w	ip, ip
   344e2:	45b4      	cmp	ip, r6
   344e4:	db2d      	blt.n	34542 <uECC_vli_mult+0x94>
	result[num_words * 2 - 1] = r0;
   344e6:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   344ea:	f840 2c04 	str.w	r2, [r0, #-4]
}
   344ee:	b007      	add	sp, #28
   344f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
   344f4:	f04f 0c00 	mov.w	ip, #0
   344f8:	46e6      	mov	lr, ip
   344fa:	9e01      	ldr	r6, [sp, #4]
   344fc:	eb06 0985 	add.w	r9, r6, r5, lsl #2
	uECC_dword_t p = (uECC_dword_t)a * b;
   34500:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   34502:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
   34506:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   3450a:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
   3450e:	fba7 ab06 	umull	sl, fp, r7, r6
   34512:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   34516:	eb1a 0601 	adds.w	r6, sl, r1
   3451a:	eb5b 0702 	adcs.w	r7, fp, r2
   3451e:	bf2c      	ite	cs
   34520:	2201      	movcs	r2, #1
   34522:	2200      	movcc	r2, #0
	*r2 += (r01 < p);
   34524:	f10c 0c01 	add.w	ip, ip, #1
		for (i = 0; i <= k; ++i) {
   34528:	fa4f fa8c 	sxtb.w	sl, ip
   3452c:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
   3452e:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
   34530:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
   34532:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
   34534:	dde4      	ble.n	34500 <uECC_vli_mult+0x52>
		result[k] = r0;
   34536:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
   3453a:	463a      	mov	r2, r7
   3453c:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   3453e:	4674      	mov	r4, lr
   34540:	e7bd      	b.n	344be <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   34542:	3501      	adds	r5, #1
   34544:	b26d      	sxtb	r5, r5
   34546:	9e01      	ldr	r6, [sp, #4]
   34548:	ebac 0e05 	sub.w	lr, ip, r5
   3454c:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
   34550:	4626      	mov	r6, r4
   34552:	2400      	movs	r4, #0
   34554:	9900      	ldr	r1, [sp, #0]
   34556:	eb01 0b85 	add.w	fp, r1, r5, lsl #2
   3455a:	429d      	cmp	r5, r3
   3455c:	db05      	blt.n	3456a <uECC_vli_mult+0xbc>
		result[k] = r0;
   3455e:	f840 202c 	str.w	r2, [r0, ip, lsl #2]
		r2 = 0;
   34562:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
   34566:	4632      	mov	r2, r6
   34568:	e7b4      	b.n	344d4 <uECC_vli_mult+0x26>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
   3456a:	f85e 7904 	ldr.w	r7, [lr], #-4
   3456e:	f85b 8b04 	ldr.w	r8, [fp], #4
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
   34572:	e9cd 2604 	strd	r2, r6, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
   34576:	fba8 8907 	umull	r8, r9, r8, r7
   3457a:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
   3457e:	eb18 0601 	adds.w	r6, r8, r1
   34582:	eb59 0702 	adcs.w	r7, r9, r2
   34586:	bf2c      	ite	cs
   34588:	2201      	movcs	r2, #1
   3458a:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   3458c:	3501      	adds	r5, #1
	*r2 += (r01 < p);
   3458e:	4414      	add	r4, r2
		for (i = (k + 1) - num_words; i < num_words; ++i) {
   34590:	b26d      	sxtb	r5, r5
	*r0 = (uECC_word_t)r01;
   34592:	4632      	mov	r2, r6
	*r1 = r01 >> uECC_WORD_BITS;
   34594:	463e      	mov	r6, r7
   34596:	e7e0      	b.n	3455a <uECC_vli_mult+0xac>

00034598 <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
   34598:	2300      	movs	r3, #0
{
   3459a:	b510      	push	{r4, lr}
		 vli[i] = 0;
   3459c:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
   3459e:	b25a      	sxtb	r2, r3
   345a0:	4291      	cmp	r1, r2
   345a2:	dc00      	bgt.n	345a6 <uECC_vli_clear+0xe>
}
   345a4:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
   345a6:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   345aa:	3301      	adds	r3, #1
   345ac:	e7f7      	b.n	3459e <uECC_vli_clear+0x6>

000345ae <uECC_vli_isZero>:
	for (i = 0; i < num_words; ++i) {
   345ae:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
   345b0:	461a      	mov	r2, r3
{
   345b2:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   345b4:	b25c      	sxtb	r4, r3
   345b6:	42a1      	cmp	r1, r4
   345b8:	dc03      	bgt.n	345c2 <uECC_vli_isZero+0x14>
}
   345ba:	fab2 f082 	clz	r0, r2
   345be:	0940      	lsrs	r0, r0, #5
   345c0:	bd10      	pop	{r4, pc}
		bits |= vli[i];
   345c2:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
   345c6:	3301      	adds	r3, #1
   345c8:	4322      	orrs	r2, r4
   345ca:	e7f3      	b.n	345b4 <uECC_vli_isZero+0x6>

000345cc <uECC_vli_testBit>:
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   345cc:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   345ce:	114a      	asrs	r2, r1, #5
   345d0:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
   345d4:	f001 011f 	and.w	r1, r1, #31
   345d8:	fa03 f101 	lsl.w	r1, r3, r1
}
   345dc:	4008      	ands	r0, r1
   345de:	4770      	bx	lr

000345e0 <uECC_vli_numBits>:
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   345e0:	3901      	subs	r1, #1
   345e2:	b249      	sxtb	r1, r1
   345e4:	eb00 0381 	add.w	r3, r0, r1, lsl #2
   345e8:	2900      	cmp	r1, #0
   345ea:	da04      	bge.n	345f6 <uECC_vli_numBits+0x16>
	return (i + 1);
   345ec:	3101      	adds	r1, #1
   345ee:	b249      	sxtb	r1, r1
	if (num_digits == 0) {
   345f0:	b941      	cbnz	r1, 34604 <uECC_vli_numBits+0x24>
		return 0;
   345f2:	4608      	mov	r0, r1
}
   345f4:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
   345f6:	f853 2904 	ldr.w	r2, [r3], #-4
   345fa:	2a00      	cmp	r2, #0
   345fc:	d1f6      	bne.n	345ec <uECC_vli_numBits+0xc>
   345fe:	3901      	subs	r1, #1
   34600:	b249      	sxtb	r1, r1
   34602:	e7f1      	b.n	345e8 <uECC_vli_numBits+0x8>
	digit = vli[num_digits - 1];
   34604:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
   34608:	3b01      	subs	r3, #1
   3460a:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
	for (i = 0; digit; ++i) {
   3460e:	2000      	movs	r0, #0
   34610:	b923      	cbnz	r3, 3461c <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
   34612:	3901      	subs	r1, #1
   34614:	eb00 1141 	add.w	r1, r0, r1, lsl #5
   34618:	b208      	sxth	r0, r1
   3461a:	4770      	bx	lr
		digit >>= 1;
   3461c:	085b      	lsrs	r3, r3, #1
	for (i = 0; digit; ++i) {
   3461e:	3001      	adds	r0, #1
   34620:	e7f6      	b.n	34610 <uECC_vli_numBits+0x30>

00034622 <uECC_vli_set>:
	for (i = 0; i < num_words; ++i) {
   34622:	2300      	movs	r3, #0
{
   34624:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
   34626:	b25c      	sxtb	r4, r3
   34628:	42a2      	cmp	r2, r4
   3462a:	dc00      	bgt.n	3462e <uECC_vli_set+0xc>
}
   3462c:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
   3462e:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   34632:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
   34636:	3301      	adds	r3, #1
   34638:	e7f5      	b.n	34626 <uECC_vli_set+0x4>

0003463a <uECC_vli_cmp_unsafe>:
{
   3463a:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
   3463c:	3a01      	subs	r2, #1
   3463e:	b252      	sxtb	r2, r2
   34640:	0093      	lsls	r3, r2, #2
   34642:	2a00      	cmp	r2, #0
   34644:	da01      	bge.n	3464a <uECC_vli_cmp_unsafe+0x10>
	return 0;
   34646:	2000      	movs	r0, #0
}
   34648:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
   3464a:	58c5      	ldr	r5, [r0, r3]
   3464c:	58cc      	ldr	r4, [r1, r3]
   3464e:	42a5      	cmp	r5, r4
   34650:	d805      	bhi.n	3465e <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
   34652:	f1a3 0304 	sub.w	r3, r3, #4
   34656:	d304      	bcc.n	34662 <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
   34658:	3a01      	subs	r2, #1
   3465a:	b252      	sxtb	r2, r2
   3465c:	e7f1      	b.n	34642 <uECC_vli_cmp_unsafe+0x8>
			return 1;
   3465e:	2001      	movs	r0, #1
   34660:	e7f2      	b.n	34648 <uECC_vli_cmp_unsafe+0xe>
			return -1;
   34662:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   34666:	e7ef      	b.n	34648 <uECC_vli_cmp_unsafe+0xe>

00034668 <uECC_vli_sub>:
{
   34668:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
   3466a:	2400      	movs	r4, #0
{
   3466c:	4607      	mov	r7, r0
   3466e:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
   34670:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
   34672:	b265      	sxtb	r5, r4
   34674:	45ac      	cmp	ip, r5
   34676:	dc00      	bgt.n	3467a <uECC_vli_sub+0x12>
}
   34678:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
   3467a:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
   3467e:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
   34682:	1a35      	subs	r5, r6, r0
   34684:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
   34686:	42ae      	cmp	r6, r5
		uECC_word_t val = (diff > left[i]);
   34688:	bf34      	ite	cc
   3468a:	2601      	movcc	r6, #1
   3468c:	2600      	movcs	r6, #0
		result[i] = diff;
   3468e:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
   34692:	bf18      	it	ne
   34694:	4630      	movne	r0, r6
		result[i] = diff;
   34696:	3401      	adds	r4, #1
   34698:	e7eb      	b.n	34672 <uECC_vli_sub+0xa>

0003469a <uECC_vli_cmp>:
{
   3469a:	b530      	push	{r4, r5, lr}
   3469c:	b089      	sub	sp, #36	; 0x24
	uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
   3469e:	4613      	mov	r3, r2
{
   346a0:	4615      	mov	r5, r2
	uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
   346a2:	460a      	mov	r2, r1
   346a4:	4601      	mov	r1, r0
   346a6:	4668      	mov	r0, sp
   346a8:	f7ff ffde 	bl	34668 <uECC_vli_sub>
   346ac:	4604      	mov	r4, r0
	uECC_word_t equal = uECC_vli_isZero(tmp, num_words);
   346ae:	4629      	mov	r1, r5
   346b0:	4668      	mov	r0, sp
   346b2:	f7ff ff7c 	bl	345ae <uECC_vli_isZero>
	uECC_word_t neg = !!uECC_vli_sub(tmp, left, right, num_words);
   346b6:	3400      	adds	r4, #0
   346b8:	bf18      	it	ne
   346ba:	2401      	movne	r4, #1
	return (!equal - 2 * neg);
   346bc:	0064      	lsls	r4, r4, #1
}
   346be:	2800      	cmp	r0, #0
   346c0:	bf14      	ite	ne
   346c2:	4260      	negne	r0, r4
   346c4:	f1c4 0001 	rsbeq	r0, r4, #1
   346c8:	b009      	add	sp, #36	; 0x24
   346ca:	bd30      	pop	{r4, r5, pc}

000346cc <uECC_vli_modAdd>:
{
   346cc:	b570      	push	{r4, r5, r6, lr}
   346ce:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   346d2:	461e      	mov	r6, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   346d4:	4623      	mov	r3, r4
{
   346d6:	4605      	mov	r5, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
   346d8:	f7ff fea8 	bl	3442c <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
   346dc:	b930      	cbnz	r0, 346ec <uECC_vli_modAdd+0x20>
   346de:	4622      	mov	r2, r4
   346e0:	4629      	mov	r1, r5
   346e2:	4630      	mov	r0, r6
   346e4:	f7ff ffa9 	bl	3463a <uECC_vli_cmp_unsafe>
   346e8:	2801      	cmp	r0, #1
   346ea:	d007      	beq.n	346fc <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
   346ec:	4623      	mov	r3, r4
   346ee:	4632      	mov	r2, r6
   346f0:	4629      	mov	r1, r5
   346f2:	4628      	mov	r0, r5
}
   346f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
   346f8:	f7ff bfb6 	b.w	34668 <uECC_vli_sub>
}
   346fc:	bd70      	pop	{r4, r5, r6, pc}

000346fe <uECC_vli_modSub>:
{
   346fe:	b570      	push	{r4, r5, r6, lr}
   34700:	f99d 4010 	ldrsb.w	r4, [sp, #16]
   34704:	461e      	mov	r6, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   34706:	4623      	mov	r3, r4
{
   34708:	4605      	mov	r5, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
   3470a:	f7ff ffad 	bl	34668 <uECC_vli_sub>
	if (l_borrow) {
   3470e:	b138      	cbz	r0, 34720 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
   34710:	4623      	mov	r3, r4
   34712:	4632      	mov	r2, r6
   34714:	4629      	mov	r1, r5
   34716:	4628      	mov	r0, r5
}
   34718:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
   3471c:	f7ff be86 	b.w	3442c <uECC_vli_add>
}
   34720:	bd70      	pop	{r4, r5, r6, pc}

00034722 <uECC_vli_mmod>:
{
   34722:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34726:	461d      	mov	r5, r3
   34728:	b0a5      	sub	sp, #148	; 0x94
	uECC_word_t *v[2] = {tmp, product};
   3472a:	ab14      	add	r3, sp, #80	; 0x50
   3472c:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
   34730:	4681      	mov	r9, r0
			   uECC_vli_numBits(mod, num_words);
   34732:	4629      	mov	r1, r5
   34734:	4610      	mov	r0, r2
{
   34736:	4617      	mov	r7, r2
			   uECC_vli_numBits(mod, num_words);
   34738:	f7ff ff52 	bl	345e0 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
   3473c:	ebc0 1085 	rsb	r0, r0, r5, lsl #6
   34740:	b204      	sxth	r4, r0
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   34742:	4626      	mov	r6, r4
   34744:	2c00      	cmp	r4, #0
   34746:	bfb8      	it	lt
   34748:	f104 061f 	addlt.w	r6, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   3474c:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
   3474e:	f346 1647 	sbfx	r6, r6, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   34752:	f003 031f 	and.w	r3, r3, #31
   34756:	f004 081f 	and.w	r8, r4, #31
	uECC_vli_clear(mod_multiple, word_shift);
   3475a:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
   3475c:	bf58      	it	pl
   3475e:	f1c3 0800 	rsbpl	r8, r3, #0
	uECC_vli_clear(mod_multiple, word_shift);
   34762:	4631      	mov	r1, r6
   34764:	f7ff ff18 	bl	34598 <uECC_vli_clear>
	if (bit_shift > 0) {
   34768:	f1b8 0f00 	cmp.w	r8, #0
   3476c:	b230      	sxth	r0, r6
   3476e:	dd2d      	ble.n	347cc <uECC_vli_mmod+0xaa>
	uECC_word_t carry = 0;
   34770:	2200      	movs	r2, #0
   34772:	ab04      	add	r3, sp, #16
   34774:	eb03 0080 	add.w	r0, r3, r0, lsl #2
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   34778:	4613      	mov	r3, r2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   3477a:	f1c8 0c20 	rsb	ip, r8, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   3477e:	429d      	cmp	r5, r3
   34780:	d819      	bhi.n	347b6 <uECC_vli_mmod+0x94>
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   34782:	2601      	movs	r6, #1
		for (i = 0; i < num_words * 2; ++i) {
   34784:	b22f      	sxth	r7, r5
   34786:	007b      	lsls	r3, r7, #1
   34788:	9301      	str	r3, [sp, #4]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   3478a:	ab04      	add	r3, sp, #16
   3478c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   34790:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
   34794:	ab24      	add	r3, sp, #144	; 0x90
   34796:	eb03 0888 	add.w	r8, r3, r8, lsl #2
	for (index = 1; shift >= 0; --shift) {
   3479a:	2c00      	cmp	r4, #0
   3479c:	da54      	bge.n	34848 <uECC_vli_mmod+0x126>
	uECC_vli_set(result, v[index], num_words);
   3479e:	ab24      	add	r3, sp, #144	; 0x90
   347a0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
   347a4:	462a      	mov	r2, r5
   347a6:	f856 1c88 	ldr.w	r1, [r6, #-136]
   347aa:	4648      	mov	r0, r9
   347ac:	f7ff ff39 	bl	34622 <uECC_vli_set>
}
   347b0:	b025      	add	sp, #148	; 0x94
   347b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   347b6:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
   347ba:	3301      	adds	r3, #1
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
   347bc:	fa06 f108 	lsl.w	r1, r6, r8
   347c0:	430a      	orrs	r2, r1
   347c2:	f840 2b04 	str.w	r2, [r0], #4
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
   347c6:	fa26 f20c 	lsr.w	r2, r6, ip
   347ca:	e7d8      	b.n	3477e <uECC_vli_mmod+0x5c>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
   347cc:	ab04      	add	r3, sp, #16
   347ce:	462a      	mov	r2, r5
   347d0:	4639      	mov	r1, r7
   347d2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   347d6:	f7ff ff24 	bl	34622 <uECC_vli_set>
   347da:	e7d2      	b.n	34782 <uECC_vli_mmod+0x60>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   347dc:	f85a 3c88 	ldr.w	r3, [sl, #-136]
   347e0:	fa0f fe82 	sxth.w	lr, r2
   347e4:	f853 b02e 	ldr.w	fp, [r3, lr, lsl #2]
   347e8:	ab24      	add	r3, sp, #144	; 0x90
   347ea:	eb03 0282 	add.w	r2, r3, r2, lsl #2
   347ee:	f852 3c80 	ldr.w	r3, [r2, #-128]
   347f2:	3001      	adds	r0, #1
   347f4:	440b      	add	r3, r1
   347f6:	ebbb 0303 	subs.w	r3, fp, r3
   347fa:	bf34      	ite	cc
   347fc:	2201      	movcc	r2, #1
   347fe:	2200      	movcs	r2, #0
			if (diff != v[index][i]) {
   34800:	459b      	cmp	fp, r3
				borrow = (diff > v[index][i]);
   34802:	bf18      	it	ne
   34804:	4611      	movne	r1, r2
			v[1 - index][i] = diff;
   34806:	f85c 2c88 	ldr.w	r2, [ip, #-136]
   3480a:	f842 302e 	str.w	r3, [r2, lr, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
   3480e:	9b01      	ldr	r3, [sp, #4]
   34810:	b242      	sxtb	r2, r0
   34812:	429a      	cmp	r2, r3
   34814:	dbe2      	blt.n	347dc <uECC_vli_mmod+0xba>
		index = !(index ^ borrow);
   34816:	1a73      	subs	r3, r6, r1
   34818:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   3481a:	4629      	mov	r1, r5
   3481c:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
   3481e:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
   34820:	f7ff fe1c 	bl	3445c <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   34824:	ab24      	add	r3, sp, #144	; 0x90
   34826:	eb03 0385 	add.w	r3, r3, r5, lsl #2
   3482a:	f853 2c80 	ldr.w	r2, [r3, #-128]
   3482e:	f858 3c80 	ldr.w	r3, [r8, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   34832:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   34834:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   34838:	4638      	mov	r0, r7
	for (index = 1; shift >= 0; --shift) {
   3483a:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
   3483c:	f848 3c80 	str.w	r3, [r8, #-128]
	for (index = 1; shift >= 0; --shift) {
   34840:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
   34842:	f7ff fe0b 	bl	3445c <uECC_vli_rshift1>
   34846:	e7a8      	b.n	3479a <uECC_vli_mmod+0x78>
   34848:	2000      	movs	r0, #0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   3484a:	ab24      	add	r3, sp, #144	; 0x90
			v[1 - index][i] = diff;
   3484c:	f1c6 0c01 	rsb	ip, r6, #1
		uECC_word_t borrow = 0;
   34850:	4601      	mov	r1, r0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
   34852:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
   34856:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
   3485a:	e7d8      	b.n	3480e <uECC_vli_mmod+0xec>

0003485c <uECC_vli_modMult>:
{
   3485c:	b570      	push	{r4, r5, r6, lr}
   3485e:	4605      	mov	r5, r0
   34860:	461e      	mov	r6, r3
   34862:	b090      	sub	sp, #64	; 0x40
   34864:	f99d 4050 	ldrsb.w	r4, [sp, #80]	; 0x50
	uECC_vli_mult(product, left, right, num_words);
   34868:	4668      	mov	r0, sp
   3486a:	4623      	mov	r3, r4
   3486c:	f7ff fe1f 	bl	344ae <uECC_vli_mult>
	uECC_vli_mmod(result, product, mod, num_words);
   34870:	4632      	mov	r2, r6
   34872:	4669      	mov	r1, sp
   34874:	4628      	mov	r0, r5
   34876:	f7ff ff54 	bl	34722 <uECC_vli_mmod>
}
   3487a:	b010      	add	sp, #64	; 0x40
   3487c:	bd70      	pop	{r4, r5, r6, pc}

0003487e <uECC_vli_modMult_fast>:
{
   3487e:	b530      	push	{r4, r5, lr}
   34880:	4605      	mov	r5, r0
   34882:	461c      	mov	r4, r3
   34884:	b091      	sub	sp, #68	; 0x44
	uECC_vli_mult(product, left, right, curve->num_words);
   34886:	4668      	mov	r0, sp
   34888:	f993 3000 	ldrsb.w	r3, [r3]
   3488c:	f7ff fe0f 	bl	344ae <uECC_vli_mult>
	curve->mmod_fast(result, product);
   34890:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
   34894:	4669      	mov	r1, sp
   34896:	4628      	mov	r0, r5
   34898:	4798      	blx	r3
}
   3489a:	b011      	add	sp, #68	; 0x44
   3489c:	bd30      	pop	{r4, r5, pc}

0003489e <uECC_vli_modSquare_fast>:
	uECC_vli_modMult_fast(result, left, left, curve);
   3489e:	4613      	mov	r3, r2
   348a0:	460a      	mov	r2, r1
   348a2:	f7ff bfec 	b.w	3487e <uECC_vli_modMult_fast>

000348a6 <double_jacobian_default>:
{
   348a6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
   348aa:	f993 6000 	ldrsb.w	r6, [r3]
{
   348ae:	b092      	sub	sp, #72	; 0x48
   348b0:	4604      	mov	r4, r0
   348b2:	4689      	mov	r9, r1
	if (uECC_vli_isZero(Z1, num_words)) {
   348b4:	4610      	mov	r0, r2
   348b6:	4631      	mov	r1, r6
{
   348b8:	4615      	mov	r5, r2
   348ba:	4698      	mov	r8, r3
	if (uECC_vli_isZero(Z1, num_words)) {
   348bc:	f7ff fe77 	bl	345ae <uECC_vli_isZero>
   348c0:	2800      	cmp	r0, #0
   348c2:	f040 8091 	bne.w	349e8 <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
   348c6:	4642      	mov	r2, r8
   348c8:	4649      	mov	r1, r9
   348ca:	a802      	add	r0, sp, #8
   348cc:	f7ff ffe7 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
   348d0:	4643      	mov	r3, r8
   348d2:	aa02      	add	r2, sp, #8
   348d4:	4621      	mov	r1, r4
   348d6:	a80a      	add	r0, sp, #40	; 0x28
   348d8:	f7ff ffd1 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
   348dc:	a902      	add	r1, sp, #8
   348de:	4608      	mov	r0, r1
   348e0:	4642      	mov	r2, r8
   348e2:	f7ff ffdc 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
   348e6:	4643      	mov	r3, r8
   348e8:	462a      	mov	r2, r5
   348ea:	4649      	mov	r1, r9
   348ec:	4648      	mov	r0, r9
   348ee:	f7ff ffc6 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   348f2:	f108 0704 	add.w	r7, r8, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
   348f6:	4642      	mov	r2, r8
   348f8:	4629      	mov	r1, r5
   348fa:	4628      	mov	r0, r5
   348fc:	f7ff ffcf 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
   34900:	463b      	mov	r3, r7
   34902:	462a      	mov	r2, r5
   34904:	4621      	mov	r1, r4
   34906:	4620      	mov	r0, r4
   34908:	9600      	str	r6, [sp, #0]
   3490a:	f7ff fedf 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
   3490e:	463b      	mov	r3, r7
   34910:	462a      	mov	r2, r5
   34912:	4629      	mov	r1, r5
   34914:	4628      	mov	r0, r5
   34916:	9600      	str	r6, [sp, #0]
   34918:	f7ff fed8 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
   3491c:	463b      	mov	r3, r7
   3491e:	462a      	mov	r2, r5
   34920:	4621      	mov	r1, r4
   34922:	4628      	mov	r0, r5
   34924:	9600      	str	r6, [sp, #0]
   34926:	f7ff feea 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
   3492a:	4643      	mov	r3, r8
   3492c:	462a      	mov	r2, r5
   3492e:	4621      	mov	r1, r4
   34930:	4620      	mov	r0, r4
   34932:	f7ff ffa4 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
   34936:	463b      	mov	r3, r7
   34938:	4622      	mov	r2, r4
   3493a:	4621      	mov	r1, r4
   3493c:	4628      	mov	r0, r5
   3493e:	9600      	str	r6, [sp, #0]
   34940:	f7ff fec4 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
   34944:	463b      	mov	r3, r7
   34946:	9600      	str	r6, [sp, #0]
   34948:	462a      	mov	r2, r5
   3494a:	4621      	mov	r1, r4
   3494c:	4620      	mov	r0, r4
   3494e:	f7ff febd 	bl	346cc <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   34952:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
   34954:	07db      	lsls	r3, r3, #31
   34956:	d54a      	bpl.n	349ee <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
   34958:	4633      	mov	r3, r6
   3495a:	463a      	mov	r2, r7
   3495c:	4621      	mov	r1, r4
   3495e:	4620      	mov	r0, r4
   34960:	f7ff fd64 	bl	3442c <uECC_vli_add>
   34964:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
   34966:	4631      	mov	r1, r6
   34968:	4620      	mov	r0, r4
   3496a:	f7ff fd77 	bl	3445c <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
   3496e:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
   34972:	3b01      	subs	r3, #1
   34974:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
   34978:	ea40 70ca 	orr.w	r0, r0, sl, lsl #31
   3497c:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
   34980:	4642      	mov	r2, r8
   34982:	4621      	mov	r1, r4
   34984:	4628      	mov	r0, r5
   34986:	f7ff ff8a 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
   3498a:	463b      	mov	r3, r7
   3498c:	aa0a      	add	r2, sp, #40	; 0x28
   3498e:	4629      	mov	r1, r5
   34990:	4628      	mov	r0, r5
   34992:	9600      	str	r6, [sp, #0]
   34994:	f7ff feb3 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
   34998:	463b      	mov	r3, r7
   3499a:	aa0a      	add	r2, sp, #40	; 0x28
   3499c:	4629      	mov	r1, r5
   3499e:	4628      	mov	r0, r5
   349a0:	9600      	str	r6, [sp, #0]
   349a2:	f7ff feac 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
   349a6:	a90a      	add	r1, sp, #40	; 0x28
   349a8:	4608      	mov	r0, r1
   349aa:	463b      	mov	r3, r7
   349ac:	462a      	mov	r2, r5
   349ae:	9600      	str	r6, [sp, #0]
   349b0:	f7ff fea5 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
   349b4:	4643      	mov	r3, r8
   349b6:	aa0a      	add	r2, sp, #40	; 0x28
   349b8:	4621      	mov	r1, r4
   349ba:	4620      	mov	r0, r4
   349bc:	f7ff ff5f 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
   349c0:	aa02      	add	r2, sp, #8
   349c2:	463b      	mov	r3, r7
   349c4:	4610      	mov	r0, r2
   349c6:	4621      	mov	r1, r4
   349c8:	9600      	str	r6, [sp, #0]
   349ca:	f7ff fe98 	bl	346fe <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
   349ce:	4632      	mov	r2, r6
   349d0:	4629      	mov	r1, r5
   349d2:	4620      	mov	r0, r4
   349d4:	f7ff fe25 	bl	34622 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
   349d8:	4649      	mov	r1, r9
   349da:	4628      	mov	r0, r5
   349dc:	f7ff fe21 	bl	34622 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
   349e0:	a902      	add	r1, sp, #8
   349e2:	4648      	mov	r0, r9
   349e4:	f7ff fe1d 	bl	34622 <uECC_vli_set>
}
   349e8:	b012      	add	sp, #72	; 0x48
   349ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
   349ee:	4631      	mov	r1, r6
   349f0:	4620      	mov	r0, r4
   349f2:	f7ff fd33 	bl	3445c <uECC_vli_rshift1>
   349f6:	e7c3      	b.n	34980 <double_jacobian_default+0xda>

000349f8 <x_side_default>:
{
   349f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   349fc:	4615      	mov	r5, r2
   349fe:	b08a      	sub	sp, #40	; 0x28
   34a00:	4604      	mov	r4, r0
   34a02:	4688      	mov	r8, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   34a04:	221c      	movs	r2, #28
   34a06:	2100      	movs	r1, #0
   34a08:	a803      	add	r0, sp, #12
   34a0a:	f004 fb1f 	bl	3904c <memset>
   34a0e:	2303      	movs	r3, #3
	wordcount_t num_words = curve->num_words;
   34a10:	f995 7000 	ldrsb.w	r7, [r5]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   34a14:	462a      	mov	r2, r5
   34a16:	4641      	mov	r1, r8
   34a18:	4620      	mov	r0, r4
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   34a1a:	1d2e      	adds	r6, r5, #4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
   34a1c:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
   34a1e:	f7ff ff3e 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
   34a22:	4633      	mov	r3, r6
   34a24:	aa02      	add	r2, sp, #8
   34a26:	4621      	mov	r1, r4
   34a28:	4620      	mov	r0, r4
   34a2a:	9700      	str	r7, [sp, #0]
   34a2c:	f7ff fe67 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
   34a30:	462b      	mov	r3, r5
   34a32:	4642      	mov	r2, r8
   34a34:	4621      	mov	r1, r4
   34a36:	4620      	mov	r0, r4
   34a38:	f7ff ff21 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
   34a3c:	9700      	str	r7, [sp, #0]
   34a3e:	4633      	mov	r3, r6
   34a40:	f105 0284 	add.w	r2, r5, #132	; 0x84
   34a44:	4621      	mov	r1, r4
   34a46:	4620      	mov	r0, r4
   34a48:	f7ff fe40 	bl	346cc <uECC_vli_modAdd>
}
   34a4c:	b00a      	add	sp, #40	; 0x28
   34a4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00034a52 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
   34a52:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   34a56:	4616      	mov	r6, r2
   34a58:	4607      	mov	r7, r0
   34a5a:	4698      	mov	r8, r3
   34a5c:	4689      	mov	r9, r1
   34a5e:	b09b      	sub	sp, #108	; 0x6c
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
   34a60:	9c22      	ldr	r4, [sp, #136]	; 0x88

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   34a62:	4602      	mov	r2, r0
	wordcount_t num_words = curve->num_words;
   34a64:	f914 5b04 	ldrsb.w	r5, [r4], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   34a68:	4631      	mov	r1, r6
   34a6a:	4623      	mov	r3, r4
   34a6c:	a802      	add	r0, sp, #8
   34a6e:	9500      	str	r5, [sp, #0]
   34a70:	f7ff fe45 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   34a74:	a902      	add	r1, sp, #8
   34a76:	9a22      	ldr	r2, [sp, #136]	; 0x88
   34a78:	4608      	mov	r0, r1
   34a7a:	f7ff ff10 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   34a7e:	9b22      	ldr	r3, [sp, #136]	; 0x88
   34a80:	aa02      	add	r2, sp, #8
   34a82:	4639      	mov	r1, r7
   34a84:	4638      	mov	r0, r7
   34a86:	f7ff fefa 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   34a8a:	9b22      	ldr	r3, [sp, #136]	; 0x88
   34a8c:	aa02      	add	r2, sp, #8
   34a8e:	4631      	mov	r1, r6
   34a90:	4630      	mov	r0, r6
   34a92:	f7ff fef4 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
   34a96:	4623      	mov	r3, r4
   34a98:	464a      	mov	r2, r9
   34a9a:	4641      	mov	r1, r8
   34a9c:	a802      	add	r0, sp, #8
   34a9e:	9500      	str	r5, [sp, #0]
   34aa0:	f7ff fe14 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   34aa4:	4623      	mov	r3, r4
   34aa6:	464a      	mov	r2, r9
   34aa8:	4641      	mov	r1, r8
   34aaa:	4640      	mov	r0, r8
   34aac:	9500      	str	r5, [sp, #0]
   34aae:	f7ff fe26 	bl	346fe <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
   34ab2:	4623      	mov	r3, r4
   34ab4:	463a      	mov	r2, r7
   34ab6:	4631      	mov	r1, r6
   34ab8:	a80a      	add	r0, sp, #40	; 0x28
   34aba:	9500      	str	r5, [sp, #0]
   34abc:	f7ff fe1f 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
   34ac0:	9b22      	ldr	r3, [sp, #136]	; 0x88
   34ac2:	aa0a      	add	r2, sp, #40	; 0x28
   34ac4:	4649      	mov	r1, r9
   34ac6:	4648      	mov	r0, r9
   34ac8:	f7ff fed9 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
   34acc:	4623      	mov	r3, r4
   34ace:	4632      	mov	r2, r6
   34ad0:	4639      	mov	r1, r7
   34ad2:	a80a      	add	r0, sp, #40	; 0x28
   34ad4:	9500      	str	r5, [sp, #0]
   34ad6:	f7ff fdf9 	bl	346cc <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
   34ada:	9a22      	ldr	r2, [sp, #136]	; 0x88
   34adc:	4641      	mov	r1, r8
   34ade:	4630      	mov	r0, r6
   34ae0:	f7ff fedd 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
   34ae4:	4623      	mov	r3, r4
   34ae6:	aa0a      	add	r2, sp, #40	; 0x28
   34ae8:	4631      	mov	r1, r6
   34aea:	4630      	mov	r0, r6
   34aec:	9500      	str	r5, [sp, #0]
   34aee:	f7ff fe06 	bl	346fe <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
   34af2:	4623      	mov	r3, r4
   34af4:	4632      	mov	r2, r6
   34af6:	4639      	mov	r1, r7
   34af8:	a812      	add	r0, sp, #72	; 0x48
   34afa:	9500      	str	r5, [sp, #0]
   34afc:	f7ff fdff 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
   34b00:	9b22      	ldr	r3, [sp, #136]	; 0x88
   34b02:	aa12      	add	r2, sp, #72	; 0x48
   34b04:	4641      	mov	r1, r8
   34b06:	4640      	mov	r0, r8
   34b08:	f7ff feb9 	bl	3487e <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
   34b0c:	4623      	mov	r3, r4
   34b0e:	464a      	mov	r2, r9
   34b10:	4641      	mov	r1, r8
   34b12:	4640      	mov	r0, r8
   34b14:	9500      	str	r5, [sp, #0]
   34b16:	f7ff fdf2 	bl	346fe <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
   34b1a:	9a22      	ldr	r2, [sp, #136]	; 0x88
   34b1c:	a902      	add	r1, sp, #8
   34b1e:	a812      	add	r0, sp, #72	; 0x48
   34b20:	f7ff febd 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
   34b24:	a912      	add	r1, sp, #72	; 0x48
   34b26:	4623      	mov	r3, r4
   34b28:	aa0a      	add	r2, sp, #40	; 0x28
   34b2a:	4608      	mov	r0, r1
   34b2c:	9500      	str	r5, [sp, #0]
   34b2e:	f7ff fde6 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
   34b32:	4623      	mov	r3, r4
   34b34:	463a      	mov	r2, r7
   34b36:	a912      	add	r1, sp, #72	; 0x48
   34b38:	a80a      	add	r0, sp, #40	; 0x28
   34b3a:	9500      	str	r5, [sp, #0]
   34b3c:	f7ff fddf 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
   34b40:	a90a      	add	r1, sp, #40	; 0x28
   34b42:	9b22      	ldr	r3, [sp, #136]	; 0x88
   34b44:	aa02      	add	r2, sp, #8
   34b46:	4608      	mov	r0, r1
   34b48:	f7ff fe99 	bl	3487e <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
   34b4c:	4623      	mov	r3, r4
   34b4e:	464a      	mov	r2, r9
   34b50:	a90a      	add	r1, sp, #40	; 0x28
   34b52:	4648      	mov	r0, r9
   34b54:	9500      	str	r5, [sp, #0]
   34b56:	f7ff fdd2 	bl	346fe <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
   34b5a:	462a      	mov	r2, r5
   34b5c:	a912      	add	r1, sp, #72	; 0x48
   34b5e:	4638      	mov	r0, r7
   34b60:	f7ff fd5f 	bl	34622 <uECC_vli_set>
}
   34b64:	b01b      	add	sp, #108	; 0x6c
   34b66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00034b6a <uECC_vli_modInv>:
{
   34b6a:	b5f0      	push	{r4, r5, r6, r7, lr}
   34b6c:	460f      	mov	r7, r1
   34b6e:	b0a1      	sub	sp, #132	; 0x84
   34b70:	4606      	mov	r6, r0
	if (uECC_vli_isZero(input, num_words)) {
   34b72:	4619      	mov	r1, r3
   34b74:	4638      	mov	r0, r7
{
   34b76:	4615      	mov	r5, r2
   34b78:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
   34b7a:	f7ff fd18 	bl	345ae <uECC_vli_isZero>
   34b7e:	b120      	cbz	r0, 34b8a <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
   34b80:	4630      	mov	r0, r6
   34b82:	f7ff fd09 	bl	34598 <uECC_vli_clear>
}
   34b86:	b021      	add	sp, #132	; 0x84
   34b88:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
   34b8a:	4622      	mov	r2, r4
   34b8c:	4639      	mov	r1, r7
   34b8e:	4668      	mov	r0, sp
   34b90:	f7ff fd47 	bl	34622 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
   34b94:	4629      	mov	r1, r5
   34b96:	a808      	add	r0, sp, #32
   34b98:	f7ff fd43 	bl	34622 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
   34b9c:	a810      	add	r0, sp, #64	; 0x40
   34b9e:	4621      	mov	r1, r4
   34ba0:	f7ff fcfa 	bl	34598 <uECC_vli_clear>
	u[0] = 1;
   34ba4:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
   34ba6:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
   34ba8:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
   34baa:	f7ff fcf5 	bl	34598 <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
   34bae:	4622      	mov	r2, r4
   34bb0:	a908      	add	r1, sp, #32
   34bb2:	4668      	mov	r0, sp
   34bb4:	f7ff fd41 	bl	3463a <uECC_vli_cmp_unsafe>
   34bb8:	b928      	cbnz	r0, 34bc6 <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
   34bba:	4622      	mov	r2, r4
   34bbc:	a910      	add	r1, sp, #64	; 0x40
   34bbe:	4630      	mov	r0, r6
   34bc0:	f7ff fd2f 	bl	34622 <uECC_vli_set>
   34bc4:	e7df      	b.n	34b86 <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
   34bc6:	9b00      	ldr	r3, [sp, #0]
   34bc8:	07da      	lsls	r2, r3, #31
   34bca:	d409      	bmi.n	34be0 <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
   34bcc:	4621      	mov	r1, r4
   34bce:	4668      	mov	r0, sp
   34bd0:	f7ff fc44 	bl	3445c <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
   34bd4:	4622      	mov	r2, r4
   34bd6:	4629      	mov	r1, r5
   34bd8:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
   34bda:	f7ff fc4c 	bl	34476 <vli_modInv_update>
   34bde:	e7e6      	b.n	34bae <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
   34be0:	9b08      	ldr	r3, [sp, #32]
   34be2:	07db      	lsls	r3, r3, #31
   34be4:	d407      	bmi.n	34bf6 <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
   34be6:	4621      	mov	r1, r4
   34be8:	a808      	add	r0, sp, #32
   34bea:	f7ff fc37 	bl	3445c <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
   34bee:	4622      	mov	r2, r4
   34bf0:	4629      	mov	r1, r5
   34bf2:	a818      	add	r0, sp, #96	; 0x60
   34bf4:	e7f1      	b.n	34bda <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
   34bf6:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
   34bf8:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
   34bfa:	dd1c      	ble.n	34c36 <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
   34bfc:	aa08      	add	r2, sp, #32
   34bfe:	4669      	mov	r1, sp
   34c00:	4668      	mov	r0, sp
   34c02:	f7ff fd31 	bl	34668 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
   34c06:	4621      	mov	r1, r4
   34c08:	4668      	mov	r0, sp
   34c0a:	f7ff fc27 	bl	3445c <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
   34c0e:	4622      	mov	r2, r4
   34c10:	a918      	add	r1, sp, #96	; 0x60
   34c12:	a810      	add	r0, sp, #64	; 0x40
   34c14:	f7ff fd11 	bl	3463a <uECC_vli_cmp_unsafe>
   34c18:	2800      	cmp	r0, #0
   34c1a:	da05      	bge.n	34c28 <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
   34c1c:	a910      	add	r1, sp, #64	; 0x40
   34c1e:	4623      	mov	r3, r4
   34c20:	462a      	mov	r2, r5
   34c22:	4608      	mov	r0, r1
   34c24:	f7ff fc02 	bl	3442c <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
   34c28:	a910      	add	r1, sp, #64	; 0x40
   34c2a:	4623      	mov	r3, r4
   34c2c:	aa18      	add	r2, sp, #96	; 0x60
   34c2e:	4608      	mov	r0, r1
   34c30:	f7ff fd1a 	bl	34668 <uECC_vli_sub>
   34c34:	e7ce      	b.n	34bd4 <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
   34c36:	a908      	add	r1, sp, #32
   34c38:	466a      	mov	r2, sp
   34c3a:	4608      	mov	r0, r1
   34c3c:	f7ff fd14 	bl	34668 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
   34c40:	4621      	mov	r1, r4
   34c42:	a808      	add	r0, sp, #32
   34c44:	f7ff fc0a 	bl	3445c <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
   34c48:	4622      	mov	r2, r4
   34c4a:	a910      	add	r1, sp, #64	; 0x40
   34c4c:	a818      	add	r0, sp, #96	; 0x60
   34c4e:	f7ff fcf4 	bl	3463a <uECC_vli_cmp_unsafe>
   34c52:	2800      	cmp	r0, #0
   34c54:	da05      	bge.n	34c62 <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
   34c56:	a918      	add	r1, sp, #96	; 0x60
   34c58:	4623      	mov	r3, r4
   34c5a:	462a      	mov	r2, r5
   34c5c:	4608      	mov	r0, r1
   34c5e:	f7ff fbe5 	bl	3442c <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
   34c62:	a918      	add	r1, sp, #96	; 0x60
   34c64:	4623      	mov	r3, r4
   34c66:	aa10      	add	r2, sp, #64	; 0x40
   34c68:	4608      	mov	r0, r1
   34c6a:	f7ff fcfd 	bl	34668 <uECC_vli_sub>
   34c6e:	e7be      	b.n	34bee <uECC_vli_modInv+0x84>

00034c70 <apply_z>:
{
   34c70:	b5f0      	push	{r4, r5, r6, r7, lr}
   34c72:	4615      	mov	r5, r2
   34c74:	461c      	mov	r4, r3
   34c76:	4607      	mov	r7, r0
   34c78:	460e      	mov	r6, r1
   34c7a:	b089      	sub	sp, #36	; 0x24
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
   34c7c:	461a      	mov	r2, r3
   34c7e:	4629      	mov	r1, r5
   34c80:	4668      	mov	r0, sp
   34c82:	f7ff fe0c 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
   34c86:	4623      	mov	r3, r4
   34c88:	466a      	mov	r2, sp
   34c8a:	4639      	mov	r1, r7
   34c8c:	4638      	mov	r0, r7
   34c8e:	f7ff fdf6 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
   34c92:	4623      	mov	r3, r4
   34c94:	462a      	mov	r2, r5
   34c96:	4669      	mov	r1, sp
   34c98:	4668      	mov	r0, sp
   34c9a:	f7ff fdf0 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
   34c9e:	4623      	mov	r3, r4
   34ca0:	466a      	mov	r2, sp
   34ca2:	4631      	mov	r1, r6
   34ca4:	4630      	mov	r0, r6
   34ca6:	f7ff fdea 	bl	3487e <uECC_vli_modMult_fast>
}
   34caa:	b009      	add	sp, #36	; 0x24
   34cac:	bdf0      	pop	{r4, r5, r6, r7, pc}

00034cae <XYcZ_add>:
{
   34cae:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   34cb2:	4614      	mov	r4, r2
   34cb4:	4680      	mov	r8, r0
   34cb6:	461f      	mov	r7, r3
   34cb8:	4689      	mov	r9, r1
   34cba:	b08b      	sub	sp, #44	; 0x2c
	wordcount_t num_words = curve->num_words;
   34cbc:	9d12      	ldr	r5, [sp, #72]	; 0x48
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   34cbe:	4602      	mov	r2, r0
	wordcount_t num_words = curve->num_words;
   34cc0:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
   34cc4:	4621      	mov	r1, r4
   34cc6:	462b      	mov	r3, r5
   34cc8:	a802      	add	r0, sp, #8
   34cca:	9600      	str	r6, [sp, #0]
   34ccc:	f7ff fd17 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
   34cd0:	a902      	add	r1, sp, #8
   34cd2:	9a12      	ldr	r2, [sp, #72]	; 0x48
   34cd4:	4608      	mov	r0, r1
   34cd6:	f7ff fde2 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
   34cda:	9b12      	ldr	r3, [sp, #72]	; 0x48
   34cdc:	aa02      	add	r2, sp, #8
   34cde:	4641      	mov	r1, r8
   34ce0:	4640      	mov	r0, r8
   34ce2:	f7ff fdcc 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
   34ce6:	9b12      	ldr	r3, [sp, #72]	; 0x48
   34ce8:	aa02      	add	r2, sp, #8
   34cea:	4621      	mov	r1, r4
   34cec:	4620      	mov	r0, r4
   34cee:	f7ff fdc6 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
   34cf2:	462b      	mov	r3, r5
   34cf4:	464a      	mov	r2, r9
   34cf6:	4639      	mov	r1, r7
   34cf8:	4638      	mov	r0, r7
   34cfa:	9600      	str	r6, [sp, #0]
   34cfc:	f7ff fcff 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
   34d00:	9a12      	ldr	r2, [sp, #72]	; 0x48
   34d02:	4639      	mov	r1, r7
   34d04:	a802      	add	r0, sp, #8
   34d06:	f7ff fdca 	bl	3489e <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
   34d0a:	a902      	add	r1, sp, #8
   34d0c:	462b      	mov	r3, r5
   34d0e:	4642      	mov	r2, r8
   34d10:	4608      	mov	r0, r1
   34d12:	9600      	str	r6, [sp, #0]
   34d14:	f7ff fcf3 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
   34d18:	a902      	add	r1, sp, #8
   34d1a:	462b      	mov	r3, r5
   34d1c:	4622      	mov	r2, r4
   34d1e:	4608      	mov	r0, r1
   34d20:	9600      	str	r6, [sp, #0]
   34d22:	f7ff fcec 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
   34d26:	462b      	mov	r3, r5
   34d28:	4642      	mov	r2, r8
   34d2a:	4621      	mov	r1, r4
   34d2c:	4620      	mov	r0, r4
   34d2e:	9600      	str	r6, [sp, #0]
   34d30:	f7ff fce5 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
   34d34:	9b12      	ldr	r3, [sp, #72]	; 0x48
   34d36:	4622      	mov	r2, r4
   34d38:	4649      	mov	r1, r9
   34d3a:	4648      	mov	r0, r9
   34d3c:	f7ff fd9f 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
   34d40:	462b      	mov	r3, r5
   34d42:	aa02      	add	r2, sp, #8
   34d44:	4641      	mov	r1, r8
   34d46:	4620      	mov	r0, r4
   34d48:	9600      	str	r6, [sp, #0]
   34d4a:	f7ff fcd8 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
   34d4e:	9b12      	ldr	r3, [sp, #72]	; 0x48
   34d50:	4622      	mov	r2, r4
   34d52:	4639      	mov	r1, r7
   34d54:	4638      	mov	r0, r7
   34d56:	f7ff fd92 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
   34d5a:	462b      	mov	r3, r5
   34d5c:	464a      	mov	r2, r9
   34d5e:	4639      	mov	r1, r7
   34d60:	4638      	mov	r0, r7
   34d62:	9600      	str	r6, [sp, #0]
   34d64:	f7ff fccb 	bl	346fe <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
   34d68:	4632      	mov	r2, r6
   34d6a:	a902      	add	r1, sp, #8
   34d6c:	4620      	mov	r0, r4
   34d6e:	f7ff fc58 	bl	34622 <uECC_vli_set>
}
   34d72:	b00b      	add	sp, #44	; 0x2c
   34d74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00034d78 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
   34d78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34d7c:	461e      	mov	r6, r3
   34d7e:	b0b1      	sub	sp, #196	; 0xc4
   34d80:	9c3b      	ldr	r4, [sp, #236]	; 0xec
   34d82:	e9cd 0104 	strd	r0, r1, [sp, #16]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
   34d86:	f994 7000 	ldrsb.w	r7, [r4]
{
   34d8a:	9206      	str	r2, [sp, #24]

	uECC_vli_set(Rx[1], point, num_words);
   34d8c:	a818      	add	r0, sp, #96	; 0x60
   34d8e:	463a      	mov	r2, r7
   34d90:	f7ff fc47 	bl	34622 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
   34d94:	00bb      	lsls	r3, r7, #2
   34d96:	9307      	str	r3, [sp, #28]
   34d98:	9b05      	ldr	r3, [sp, #20]
   34d9a:	00ba      	lsls	r2, r7, #2
   34d9c:	4413      	add	r3, r2
   34d9e:	4619      	mov	r1, r3
   34da0:	463a      	mov	r2, r7
   34da2:	a828      	add	r0, sp, #160	; 0xa0
   34da4:	9302      	str	r3, [sp, #8]
   34da6:	f7ff fc3c 	bl	34622 <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
   34daa:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
   34dae:	2e00      	cmp	r6, #0
   34db0:	f000 8087 	beq.w	34ec2 <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
   34db4:	462a      	mov	r2, r5
   34db6:	4631      	mov	r1, r6
   34db8:	a808      	add	r0, sp, #32
   34dba:	f7ff fc32 	bl	34622 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
   34dbe:	ae10      	add	r6, sp, #64	; 0x40
   34dc0:	462a      	mov	r2, r5
   34dc2:	a918      	add	r1, sp, #96	; 0x60
   34dc4:	4630      	mov	r0, r6
	uECC_vli_set(Y2, Y1, num_words);
   34dc6:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
   34dca:	f7ff fc2a 	bl	34622 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
   34dce:	a928      	add	r1, sp, #160	; 0xa0
   34dd0:	4648      	mov	r0, r9
   34dd2:	f7ff fc26 	bl	34622 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
   34dd6:	4623      	mov	r3, r4
   34dd8:	aa08      	add	r2, sp, #32
   34dda:	a928      	add	r1, sp, #160	; 0xa0
   34ddc:	a818      	add	r0, sp, #96	; 0x60
   34dde:	f7ff ff47 	bl	34c70 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
   34de2:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
   34de6:	4623      	mov	r3, r4
   34de8:	aa08      	add	r2, sp, #32
   34dea:	a928      	add	r1, sp, #160	; 0xa0
   34dec:	a818      	add	r0, sp, #96	; 0x60
   34dee:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
   34df0:	4623      	mov	r3, r4
   34df2:	aa08      	add	r2, sp, #32
   34df4:	4649      	mov	r1, r9
   34df6:	4630      	mov	r0, r6
   34df8:	f7ff ff3a 	bl	34c70 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
   34dfc:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
   34e00:	3d02      	subs	r5, #2
   34e02:	b22d      	sxth	r5, r5
   34e04:	2d00      	cmp	r5, #0
   34e06:	dc63      	bgt.n	34ed0 <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   34e08:	9b06      	ldr	r3, [sp, #24]

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   34e0a:	f104 0a04 	add.w	sl, r4, #4
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   34e0e:	681d      	ldr	r5, [r3, #0]
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   34e10:	ab10      	add	r3, sp, #64	; 0x40
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
   34e12:	f005 0601 	and.w	r6, r5, #1
   34e16:	43ed      	mvns	r5, r5
   34e18:	0176      	lsls	r6, r6, #5
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   34e1a:	eb03 0806 	add.w	r8, r3, r6
   34e1e:	f005 0501 	and.w	r5, r5, #1
   34e22:	ab20      	add	r3, sp, #128	; 0x80
   34e24:	441e      	add	r6, r3
   34e26:	016d      	lsls	r5, r5, #5
   34e28:	ab10      	add	r3, sp, #64	; 0x40
   34e2a:	eb03 0905 	add.w	r9, r3, r5
   34e2e:	ab20      	add	r3, sp, #128	; 0x80
   34e30:	441d      	add	r5, r3
   34e32:	9400      	str	r4, [sp, #0]
   34e34:	462b      	mov	r3, r5
   34e36:	464a      	mov	r2, r9
   34e38:	4631      	mov	r1, r6
   34e3a:	4640      	mov	r0, r8
   34e3c:	f7ff fe09 	bl	34a52 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
   34e40:	4653      	mov	r3, sl
   34e42:	aa10      	add	r2, sp, #64	; 0x40
   34e44:	a918      	add	r1, sp, #96	; 0x60
   34e46:	a808      	add	r0, sp, #32
   34e48:	9700      	str	r7, [sp, #0]
   34e4a:	f7ff fc58 	bl	346fe <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
   34e4e:	a908      	add	r1, sp, #32
   34e50:	4623      	mov	r3, r4
   34e52:	4632      	mov	r2, r6
   34e54:	4608      	mov	r0, r1
   34e56:	f7ff fd12 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
   34e5a:	a908      	add	r1, sp, #32
   34e5c:	4623      	mov	r3, r4
   34e5e:	9a05      	ldr	r2, [sp, #20]
   34e60:	4608      	mov	r0, r1
   34e62:	f7ff fd0c 	bl	3487e <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
   34e66:	a908      	add	r1, sp, #32
   34e68:	463b      	mov	r3, r7
   34e6a:	4652      	mov	r2, sl
   34e6c:	4608      	mov	r0, r1
   34e6e:	f7ff fe7c 	bl	34b6a <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
   34e72:	a908      	add	r1, sp, #32
   34e74:	4623      	mov	r3, r4
   34e76:	9a02      	ldr	r2, [sp, #8]
   34e78:	4608      	mov	r0, r1
   34e7a:	f7ff fd00 	bl	3487e <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
   34e7e:	a908      	add	r1, sp, #32
   34e80:	4623      	mov	r3, r4
   34e82:	4642      	mov	r2, r8
   34e84:	4608      	mov	r0, r1
   34e86:	f7ff fcfa 	bl	3487e <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   34e8a:	9400      	str	r4, [sp, #0]
   34e8c:	4633      	mov	r3, r6
   34e8e:	4642      	mov	r2, r8
   34e90:	4629      	mov	r1, r5
   34e92:	4648      	mov	r0, r9
   34e94:	f7ff ff0b 	bl	34cae <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
   34e98:	4623      	mov	r3, r4
   34e9a:	aa08      	add	r2, sp, #32
   34e9c:	a920      	add	r1, sp, #128	; 0x80
   34e9e:	a810      	add	r0, sp, #64	; 0x40
   34ea0:	f7ff fee6 	bl	34c70 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
   34ea4:	463a      	mov	r2, r7
   34ea6:	a910      	add	r1, sp, #64	; 0x40
   34ea8:	9804      	ldr	r0, [sp, #16]
   34eaa:	f7ff fbba 	bl	34622 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
   34eae:	9b04      	ldr	r3, [sp, #16]
   34eb0:	9c07      	ldr	r4, [sp, #28]
   34eb2:	a920      	add	r1, sp, #128	; 0x80
   34eb4:	4423      	add	r3, r4
   34eb6:	4618      	mov	r0, r3
   34eb8:	f7ff fbb3 	bl	34622 <uECC_vli_set>
}
   34ebc:	b031      	add	sp, #196	; 0xc4
   34ebe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
   34ec2:	4629      	mov	r1, r5
   34ec4:	a808      	add	r0, sp, #32
   34ec6:	f7ff fb67 	bl	34598 <uECC_vli_clear>
		z[0] = 1;
   34eca:	2301      	movs	r3, #1
   34ecc:	9308      	str	r3, [sp, #32]
   34ece:	e776      	b.n	34dbe <EccPoint_mult+0x46>
		nb = !uECC_vli_testBit(scalar, i);
   34ed0:	4629      	mov	r1, r5
   34ed2:	9806      	ldr	r0, [sp, #24]
   34ed4:	f7ff fb7a 	bl	345cc <uECC_vli_testBit>
   34ed8:	fab0 f080 	clz	r0, r0
   34edc:	0940      	lsrs	r0, r0, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
   34ede:	f1c0 0801 	rsb	r8, r0, #1
   34ee2:	ea4f 1848 	mov.w	r8, r8, lsl #5
   34ee6:	0140      	lsls	r0, r0, #5
   34ee8:	eb06 0b08 	add.w	fp, r6, r8
   34eec:	eb06 0a00 	add.w	sl, r6, r0
   34ef0:	44c8      	add	r8, r9
   34ef2:	eb09 0300 	add.w	r3, r9, r0
   34ef6:	4652      	mov	r2, sl
   34ef8:	4641      	mov	r1, r8
   34efa:	4658      	mov	r0, fp
   34efc:	9400      	str	r4, [sp, #0]
   34efe:	9303      	str	r3, [sp, #12]
   34f00:	f7ff fda7 	bl	34a52 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
   34f04:	9400      	str	r4, [sp, #0]
   34f06:	4643      	mov	r3, r8
   34f08:	465a      	mov	r2, fp
   34f0a:	9903      	ldr	r1, [sp, #12]
   34f0c:	4650      	mov	r0, sl
   34f0e:	f7ff fece 	bl	34cae <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
   34f12:	3d01      	subs	r5, #1
   34f14:	e775      	b.n	34e02 <EccPoint_mult+0x8a>

00034f16 <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
   34f16:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34f1a:	460f      	mov	r7, r1

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   34f1c:	f9b3 4002 	ldrsh.w	r4, [r3, #2]

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   34f20:	f103 0624 	add.w	r6, r3, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
   34f24:	f114 051f 	adds.w	r5, r4, #31
   34f28:	bf48      	it	mi
   34f2a:	f104 053e 	addmi.w	r5, r4, #62	; 0x3e
   34f2e:	f345 1547 	sbfx	r5, r5, #5, #8
{
   34f32:	4690      	mov	r8, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   34f34:	4601      	mov	r1, r0
   34f36:	462b      	mov	r3, r5
   34f38:	4632      	mov	r2, r6
   34f3a:	4638      	mov	r0, r7
   34f3c:	f7ff fa76 	bl	3442c <uECC_vli_add>
   34f40:	b990      	cbnz	r0, 34f68 <regularize_k+0x52>
   34f42:	ebb4 1f45 	cmp.w	r4, r5, lsl #5
   34f46:	da11      	bge.n	34f6c <regularize_k+0x56>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
   34f48:	4621      	mov	r1, r4
   34f4a:	4638      	mov	r0, r7
   34f4c:	f7ff fb3e 	bl	345cc <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
   34f50:	1c04      	adds	r4, r0, #0
   34f52:	bf18      	it	ne
   34f54:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
   34f56:	462b      	mov	r3, r5
   34f58:	4632      	mov	r2, r6
   34f5a:	4639      	mov	r1, r7
   34f5c:	4640      	mov	r0, r8
   34f5e:	f7ff fa65 	bl	3442c <uECC_vli_add>

	return carry;
}
   34f62:	4620      	mov	r0, r4
   34f64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
   34f68:	2401      	movs	r4, #1
   34f6a:	e7f4      	b.n	34f56 <regularize_k+0x40>
   34f6c:	4604      	mov	r4, r0
   34f6e:	e7f2      	b.n	34f56 <regularize_k+0x40>

00034f70 <uECC_vli_nativeToBytes>:
}

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
   34f70:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
   34f72:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
   34f74:	1e4f      	subs	r7, r1, #1
   34f76:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
   34f78:	428c      	cmp	r4, r1
   34f7a:	f105 0501 	add.w	r5, r5, #1
   34f7e:	db00      	blt.n	34f82 <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
   34f80:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   34f82:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
   34f84:	f023 0603 	bic.w	r6, r3, #3
   34f88:	5996      	ldr	r6, [r2, r6]
   34f8a:	f003 0303 	and.w	r3, r3, #3
   34f8e:	00db      	lsls	r3, r3, #3
   34f90:	fa26 f303 	lsr.w	r3, r6, r3
   34f94:	5503      	strb	r3, [r0, r4]
   34f96:	e7ee      	b.n	34f76 <uECC_vli_nativeToBytes+0x6>

00034f98 <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
   34f98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   34f9a:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   34f9c:	1cd1      	adds	r1, r2, #3
   34f9e:	bf48      	it	mi
   34fa0:	1d91      	addmi	r1, r2, #6
{
   34fa2:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   34fa4:	f341 0187 	sbfx	r1, r1, #2, #8
{
   34fa8:	4605      	mov	r5, r0
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
   34faa:	f7ff faf5 	bl	34598 <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
   34fae:	2100      	movs	r1, #0
		unsigned b = num_bytes - 1 - i;
   34fb0:	1e67      	subs	r7, r4, #1
   34fb2:	b24a      	sxtb	r2, r1
	for (i = 0; i < num_bytes; ++i) {
   34fb4:	42a2      	cmp	r2, r4
   34fb6:	f101 0101 	add.w	r1, r1, #1
   34fba:	db00      	blt.n	34fbe <uECC_vli_bytesToNative+0x26>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
   34fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
   34fbe:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
   34fc0:	f023 0003 	bic.w	r0, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
   34fc4:	5cb2      	ldrb	r2, [r6, r2]
   34fc6:	f003 0303 	and.w	r3, r3, #3
   34fca:	00db      	lsls	r3, r3, #3
   34fcc:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
   34fd0:	582a      	ldr	r2, [r5, r0]
   34fd2:	431a      	orrs	r2, r3
   34fd4:	502a      	str	r2, [r5, r0]
   34fd6:	e7ec      	b.n	34fb2 <uECC_vli_bytesToNative+0x1a>

00034fd8 <add_round_key>:
	s[0] ^= (uint8_t)(k[0] >> 24); s[1] ^= (uint8_t)(k[0] >> 16);
   34fd8:	78cb      	ldrb	r3, [r1, #3]
   34fda:	7802      	ldrb	r2, [r0, #0]
   34fdc:	4053      	eors	r3, r2
   34fde:	7003      	strb	r3, [r0, #0]
   34fe0:	884b      	ldrh	r3, [r1, #2]
   34fe2:	7842      	ldrb	r2, [r0, #1]
   34fe4:	4053      	eors	r3, r2
   34fe6:	7043      	strb	r3, [r0, #1]
	s[2] ^= (uint8_t)(k[0] >> 8); s[3] ^= (uint8_t)(k[0]);
   34fe8:	680a      	ldr	r2, [r1, #0]
   34fea:	7883      	ldrb	r3, [r0, #2]
   34fec:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   34ff0:	7083      	strb	r3, [r0, #2]
   34ff2:	680a      	ldr	r2, [r1, #0]
   34ff4:	78c3      	ldrb	r3, [r0, #3]
   34ff6:	4053      	eors	r3, r2
   34ff8:	70c3      	strb	r3, [r0, #3]
	s[4] ^= (uint8_t)(k[1] >> 24); s[5] ^= (uint8_t)(k[1] >> 16);
   34ffa:	79cb      	ldrb	r3, [r1, #7]
   34ffc:	7902      	ldrb	r2, [r0, #4]
   34ffe:	4053      	eors	r3, r2
   35000:	7103      	strb	r3, [r0, #4]
   35002:	88cb      	ldrh	r3, [r1, #6]
   35004:	7942      	ldrb	r2, [r0, #5]
   35006:	4053      	eors	r3, r2
   35008:	7143      	strb	r3, [r0, #5]
	s[6] ^= (uint8_t)(k[1] >> 8); s[7] ^= (uint8_t)(k[1]);
   3500a:	684a      	ldr	r2, [r1, #4]
   3500c:	7983      	ldrb	r3, [r0, #6]
   3500e:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   35012:	7183      	strb	r3, [r0, #6]
   35014:	684a      	ldr	r2, [r1, #4]
   35016:	79c3      	ldrb	r3, [r0, #7]
   35018:	4053      	eors	r3, r2
   3501a:	71c3      	strb	r3, [r0, #7]
	s[8] ^= (uint8_t)(k[2] >> 24); s[9] ^= (uint8_t)(k[2] >> 16);
   3501c:	7acb      	ldrb	r3, [r1, #11]
   3501e:	7a02      	ldrb	r2, [r0, #8]
   35020:	4053      	eors	r3, r2
   35022:	7203      	strb	r3, [r0, #8]
   35024:	7a42      	ldrb	r2, [r0, #9]
   35026:	894b      	ldrh	r3, [r1, #10]
   35028:	4053      	eors	r3, r2
   3502a:	7243      	strb	r3, [r0, #9]
	s[10] ^= (uint8_t)(k[2] >> 8); s[11] ^= (uint8_t)(k[2]);
   3502c:	688a      	ldr	r2, [r1, #8]
   3502e:	7a83      	ldrb	r3, [r0, #10]
   35030:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   35034:	7283      	strb	r3, [r0, #10]
   35036:	688a      	ldr	r2, [r1, #8]
   35038:	7ac3      	ldrb	r3, [r0, #11]
   3503a:	4053      	eors	r3, r2
   3503c:	72c3      	strb	r3, [r0, #11]
	s[12] ^= (uint8_t)(k[3] >> 24); s[13] ^= (uint8_t)(k[3] >> 16);
   3503e:	7bcb      	ldrb	r3, [r1, #15]
   35040:	7b02      	ldrb	r2, [r0, #12]
   35042:	4053      	eors	r3, r2
   35044:	7303      	strb	r3, [r0, #12]
   35046:	89cb      	ldrh	r3, [r1, #14]
   35048:	7b42      	ldrb	r2, [r0, #13]
   3504a:	4053      	eors	r3, r2
   3504c:	7343      	strb	r3, [r0, #13]
	s[14] ^= (uint8_t)(k[3] >> 8); s[15] ^= (uint8_t)(k[3]);
   3504e:	68ca      	ldr	r2, [r1, #12]
   35050:	7b83      	ldrb	r3, [r0, #14]
   35052:	ea83 2312 	eor.w	r3, r3, r2, lsr #8
   35056:	7383      	strb	r3, [r0, #14]
   35058:	68ca      	ldr	r2, [r1, #12]
   3505a:	7bc3      	ldrb	r3, [r0, #15]
   3505c:	4053      	eors	r3, r2
   3505e:	73c3      	strb	r3, [r0, #15]
}
   35060:	4770      	bx	lr

00035062 <shift_rows>:
{
   35062:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   35064:	7802      	ldrb	r2, [r0, #0]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   35066:	7ac3      	ldrb	r3, [r0, #11]
	t[0]  = s[0]; t[1] = s[5]; t[2] = s[10]; t[3] = s[15];
   35068:	f88d 2000 	strb.w	r2, [sp]
   3506c:	7942      	ldrb	r2, [r0, #5]
   3506e:	f88d 2001 	strb.w	r2, [sp, #1]
   35072:	7a82      	ldrb	r2, [r0, #10]
   35074:	f88d 2002 	strb.w	r2, [sp, #2]
   35078:	7bc2      	ldrb	r2, [r0, #15]
   3507a:	f88d 2003 	strb.w	r2, [sp, #3]
	t[4]  = s[4]; t[5] = s[9]; t[6] = s[14]; t[7] = s[3];
   3507e:	7902      	ldrb	r2, [r0, #4]
   35080:	f88d 2004 	strb.w	r2, [sp, #4]
   35084:	7a42      	ldrb	r2, [r0, #9]
   35086:	f88d 2005 	strb.w	r2, [sp, #5]
   3508a:	7b82      	ldrb	r2, [r0, #14]
   3508c:	f88d 2006 	strb.w	r2, [sp, #6]
   35090:	78c2      	ldrb	r2, [r0, #3]
   35092:	f88d 2007 	strb.w	r2, [sp, #7]
	t[8]  = s[8]; t[9] = s[13]; t[10] = s[2]; t[11] = s[7];
   35096:	7a02      	ldrb	r2, [r0, #8]
   35098:	f88d 2008 	strb.w	r2, [sp, #8]
   3509c:	7b42      	ldrb	r2, [r0, #13]
   3509e:	f88d 2009 	strb.w	r2, [sp, #9]
   350a2:	7882      	ldrb	r2, [r0, #2]
   350a4:	f88d 200a 	strb.w	r2, [sp, #10]
   350a8:	79c2      	ldrb	r2, [r0, #7]
   350aa:	f88d 200b 	strb.w	r2, [sp, #11]
	t[12] = s[12]; t[13] = s[1]; t[14] = s[6]; t[15] = s[11];
   350ae:	7b02      	ldrb	r2, [r0, #12]
   350b0:	f88d 200c 	strb.w	r2, [sp, #12]
   350b4:	7842      	ldrb	r2, [r0, #1]
   350b6:	f88d 200d 	strb.w	r2, [sp, #13]
   350ba:	7982      	ldrb	r2, [r0, #6]
   350bc:	f88d 200e 	strb.w	r2, [sp, #14]
   350c0:	f88d 300f 	strb.w	r3, [sp, #15]
	(void) _copy(s, sizeof(t), t, sizeof(t));
   350c4:	2310      	movs	r3, #16
   350c6:	466a      	mov	r2, sp
   350c8:	4619      	mov	r1, r3
   350ca:	f7ff f871 	bl	341b0 <_copy>
}
   350ce:	b005      	add	sp, #20
   350d0:	f85d fb04 	ldr.w	pc, [sp], #4

000350d4 <mult_row_column>:
{
   350d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   350d6:	4606      	mov	r6, r0
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   350d8:	7808      	ldrb	r0, [r1, #0]
{
   350da:	460c      	mov	r4, r1
	out[0] = _double_byte(in[0]) ^ triple(in[1]) ^ in[2] ^ in[3];
   350dc:	f7ff f877 	bl	341ce <_double_byte>
   350e0:	4605      	mov	r5, r0
   350e2:	7860      	ldrb	r0, [r4, #1]
   350e4:	f7ff f873 	bl	341ce <_double_byte>
   350e8:	78a2      	ldrb	r2, [r4, #2]
   350ea:	7863      	ldrb	r3, [r4, #1]
   350ec:	4053      	eors	r3, r2
   350ee:	78e2      	ldrb	r2, [r4, #3]
   350f0:	4053      	eors	r3, r2
   350f2:	405d      	eors	r5, r3
   350f4:	4045      	eors	r5, r0
   350f6:	7035      	strb	r5, [r6, #0]
	out[1] = in[0] ^ _double_byte(in[1]) ^ triple(in[2]) ^ in[3];
   350f8:	7860      	ldrb	r0, [r4, #1]
   350fa:	7827      	ldrb	r7, [r4, #0]
   350fc:	f7ff f867 	bl	341ce <_double_byte>
   35100:	4605      	mov	r5, r0
   35102:	78a0      	ldrb	r0, [r4, #2]
   35104:	f7ff f863 	bl	341ce <_double_byte>
   35108:	78a3      	ldrb	r3, [r4, #2]
   3510a:	405f      	eors	r7, r3
   3510c:	78e3      	ldrb	r3, [r4, #3]
   3510e:	405f      	eors	r7, r3
   35110:	407d      	eors	r5, r7
   35112:	4045      	eors	r5, r0
   35114:	7075      	strb	r5, [r6, #1]
	out[2] = in[0] ^ in[1] ^ _double_byte(in[2]) ^ triple(in[3]);
   35116:	78a0      	ldrb	r0, [r4, #2]
   35118:	7865      	ldrb	r5, [r4, #1]
   3511a:	7827      	ldrb	r7, [r4, #0]
   3511c:	f7ff f857 	bl	341ce <_double_byte>
   35120:	406f      	eors	r7, r5
   35122:	4605      	mov	r5, r0
   35124:	78e0      	ldrb	r0, [r4, #3]
   35126:	f7ff f852 	bl	341ce <_double_byte>
   3512a:	78e3      	ldrb	r3, [r4, #3]
   3512c:	405f      	eors	r7, r3
   3512e:	407d      	eors	r5, r7
   35130:	4045      	eors	r5, r0
   35132:	70b5      	strb	r5, [r6, #2]
	out[3] = triple(in[0]) ^ in[1] ^ in[2] ^ _double_byte(in[3]);
   35134:	7820      	ldrb	r0, [r4, #0]
   35136:	f7ff f84a 	bl	341ce <_double_byte>
   3513a:	7863      	ldrb	r3, [r4, #1]
   3513c:	7825      	ldrb	r5, [r4, #0]
   3513e:	405d      	eors	r5, r3
   35140:	78a3      	ldrb	r3, [r4, #2]
   35142:	405d      	eors	r5, r3
   35144:	4045      	eors	r5, r0
   35146:	78e0      	ldrb	r0, [r4, #3]
   35148:	f7ff f841 	bl	341ce <_double_byte>
   3514c:	b2ed      	uxtb	r5, r5
   3514e:	4068      	eors	r0, r5
   35150:	70f0      	strb	r0, [r6, #3]
}
   35152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00035154 <tc_sha256_update>:
{
   35154:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35158:	460d      	mov	r5, r1
	if (s == (TCSha256State_t) 0 ||
   3515a:	4604      	mov	r4, r0
   3515c:	b110      	cbz	r0, 35164 <tc_sha256_update+0x10>
   3515e:	b319      	cbz	r1, 351a8 <tc_sha256_update+0x54>
	} else if (datalen == 0) {
   35160:	b912      	cbnz	r2, 35168 <tc_sha256_update+0x14>
		return TC_CRYPTO_SUCCESS;
   35162:	2001      	movs	r0, #1
}
   35164:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			s->leftover_offset = 0;
   35168:	f04f 0800 	mov.w	r8, #0
   3516c:	188e      	adds	r6, r1, r2
			compress(s->iv, s->leftover);
   3516e:	f100 0728 	add.w	r7, r0, #40	; 0x28
	while (datalen-- > 0) {
   35172:	42ae      	cmp	r6, r5
   35174:	d0f5      	beq.n	35162 <tc_sha256_update+0xe>
		s->leftover[s->leftover_offset++] = *(data++);
   35176:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   35178:	1c5a      	adds	r2, r3, #1
   3517a:	66a2      	str	r2, [r4, #104]	; 0x68
   3517c:	f815 1b01 	ldrb.w	r1, [r5], #1
   35180:	4423      	add	r3, r4
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
   35182:	2a3f      	cmp	r2, #63	; 0x3f
		s->leftover[s->leftover_offset++] = *(data++);
   35184:	f883 1028 	strb.w	r1, [r3, #40]	; 0x28
		if (s->leftover_offset >= TC_SHA256_BLOCK_SIZE) {
   35188:	d9f3      	bls.n	35172 <tc_sha256_update+0x1e>
			compress(s->iv, s->leftover);
   3518a:	4639      	mov	r1, r7
   3518c:	4620      	mov	r0, r4
   3518e:	f7e5 fba5 	bl	1a8dc <compress>
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
   35192:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
   35196:	f513 7300 	adds.w	r3, r3, #512	; 0x200
   3519a:	f142 0200 	adc.w	r2, r2, #0
			s->leftover_offset = 0;
   3519e:	f8c4 8068 	str.w	r8, [r4, #104]	; 0x68
			s->bits_hashed += (TC_SHA256_BLOCK_SIZE << 3);
   351a2:	e9c4 3208 	strd	r3, r2, [r4, #32]
   351a6:	e7e4      	b.n	35172 <tc_sha256_update+0x1e>
		return TC_CRYPTO_FAIL;
   351a8:	4608      	mov	r0, r1
   351aa:	e7db      	b.n	35164 <tc_sha256_update+0x10>

000351ac <tc_sha256_final>:
{
   351ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   351ae:	460c      	mov	r4, r1
	if (digest == (uint8_t *) 0 ||
   351b0:	4605      	mov	r5, r0
   351b2:	2800      	cmp	r0, #0
   351b4:	d054      	beq.n	35260 <tc_sha256_final+0xb4>
   351b6:	2900      	cmp	r1, #0
   351b8:	d053      	beq.n	35262 <tc_sha256_final+0xb6>
	s->bits_hashed += (s->leftover_offset << 3);
   351ba:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
   351be:	6e89      	ldr	r1, [r1, #104]	; 0x68
   351c0:	00c8      	lsls	r0, r1, #3
   351c2:	1816      	adds	r6, r2, r0
   351c4:	f143 0700 	adc.w	r7, r3, #0
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   351c8:	2380      	movs	r3, #128	; 0x80
   351ca:	1c48      	adds	r0, r1, #1
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
   351cc:	2838      	cmp	r0, #56	; 0x38
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   351ce:	4421      	add	r1, r4
	s->bits_hashed += (s->leftover_offset << 3);
   351d0:	e9c4 6708 	strd	r6, r7, [r4, #32]
	s->leftover[s->leftover_offset++] = 0x80; /* always room for one byte */
   351d4:	66a0      	str	r0, [r4, #104]	; 0x68
   351d6:	f104 0628 	add.w	r6, r4, #40	; 0x28
   351da:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
	if (s->leftover_offset > (sizeof(s->leftover) - 8)) {
   351de:	d90b      	bls.n	351f8 <tc_sha256_final+0x4c>
		_set(s->leftover + s->leftover_offset, 0x00,
   351e0:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
   351e4:	2100      	movs	r1, #0
   351e6:	4430      	add	r0, r6
   351e8:	f7fe ffef 	bl	341ca <_set>
		compress(s->iv, s->leftover);
   351ec:	4631      	mov	r1, r6
   351ee:	4620      	mov	r0, r4
   351f0:	f7e5 fb74 	bl	1a8dc <compress>
		s->leftover_offset = 0;
   351f4:	2300      	movs	r3, #0
   351f6:	66a3      	str	r3, [r4, #104]	; 0x68
	_set(s->leftover + s->leftover_offset, 0x00,
   351f8:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   351fa:	2100      	movs	r1, #0
   351fc:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
   35200:	4430      	add	r0, r6
   35202:	f7fe ffe2 	bl	341ca <_set>
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
   35206:	6a23      	ldr	r3, [r4, #32]
	compress(s->iv, s->leftover);
   35208:	4631      	mov	r1, r6
   3520a:	ba1a      	rev	r2, r3
	s->leftover[sizeof(s->leftover) - 1] = (uint8_t)(s->bits_hashed);
   3520c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	s->leftover[sizeof(s->leftover) - 4] = (uint8_t)(s->bits_hashed >> 24);
   3520e:	6662      	str	r2, [r4, #100]	; 0x64
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
   35210:	0a1a      	lsrs	r2, r3, #8
	s->leftover[sizeof(s->leftover) - 5] = (uint8_t)(s->bits_hashed >> 32);
   35212:	f884 3063 	strb.w	r3, [r4, #99]	; 0x63
	s->leftover[sizeof(s->leftover) - 6] = (uint8_t)(s->bits_hashed >> 40);
   35216:	f884 2062 	strb.w	r2, [r4, #98]	; 0x62
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
   3521a:	0c1a      	lsrs	r2, r3, #16
	s->leftover[sizeof(s->leftover) - 8] = (uint8_t)(s->bits_hashed >> 56);
   3521c:	0e1b      	lsrs	r3, r3, #24
   3521e:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
	compress(s->iv, s->leftover);
   35222:	4620      	mov	r0, r4
	s->leftover[sizeof(s->leftover) - 7] = (uint8_t)(s->bits_hashed >> 48);
   35224:	f884 2061 	strb.w	r2, [r4, #97]	; 0x61
	compress(s->iv, s->leftover);
   35228:	f7e5 fb58 	bl	1a8dc <compress>
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   3522c:	1d2b      	adds	r3, r5, #4
   3522e:	1f21      	subs	r1, r4, #4
   35230:	f105 0024 	add.w	r0, r5, #36	; 0x24
		unsigned int t = *((unsigned int *) &s->iv[i]);
   35234:	f851 2f04 	ldr.w	r2, [r1, #4]!
		*digest++ = (uint8_t)(t >> 24);
   35238:	3304      	adds	r3, #4
   3523a:	0e15      	lsrs	r5, r2, #24
   3523c:	f803 5c08 	strb.w	r5, [r3, #-8]
		*digest++ = (uint8_t)(t >> 16);
   35240:	0c15      	lsrs	r5, r2, #16
   35242:	f803 5c07 	strb.w	r5, [r3, #-7]
		*digest++ = (uint8_t)(t >> 8);
   35246:	0a15      	lsrs	r5, r2, #8
   35248:	f803 5c06 	strb.w	r5, [r3, #-6]
		*digest++ = (uint8_t)(t);
   3524c:	f803 2c05 	strb.w	r2, [r3, #-5]
	for (i = 0; i < TC_SHA256_STATE_BLOCKS; ++i) {
   35250:	4283      	cmp	r3, r0
   35252:	d1ef      	bne.n	35234 <tc_sha256_final+0x88>
	_set(s, 0, sizeof(*s));
   35254:	4620      	mov	r0, r4
   35256:	2270      	movs	r2, #112	; 0x70
   35258:	2100      	movs	r1, #0
   3525a:	f7fe ffb6 	bl	341ca <_set>
	return TC_CRYPTO_SUCCESS;
   3525e:	2001      	movs	r0, #1
}
   35260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return TC_CRYPTO_FAIL;
   35262:	4608      	mov	r0, r1
   35264:	e7fc      	b.n	35260 <tc_sha256_final+0xb4>

00035266 <tc_ctr_prng_update.part.1>:
 *  @return none
 *  @note Assumes: providedData is (TC_AES_KEY_SIZE + TC_AES_BLOCK_SIZE) bytes long
 *  @param ctx IN/OUT -- CTR PRNG state
 *  @param providedData IN -- data used when updating the internal state
 */
static void tc_ctr_prng_update(TCCtrPrng_t * const ctx, uint8_t const * const providedData)
   35266:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3526a:	4604      	mov	r4, r0
   3526c:	460e      	mov	r6, r1
{
	if (0 != ctx) {
		/* 10.2.1.2 step 1 */
		uint8_t temp[TC_AES_KEY_SIZE + TC_AES_BLOCK_SIZE];
		unsigned int len = 0U;
   3526e:	2500      	movs	r5, #0
static void tc_ctr_prng_update(TCCtrPrng_t * const ctx, uint8_t const * const providedData)
   35270:	b08c      	sub	sp, #48	; 0x30
   35272:	f100 0810 	add.w	r8, r0, #16

		/* 10.2.1.2 step 2 */
		while (len < sizeof temp) {
			unsigned int blocklen = sizeof(temp) - len;
   35276:	f1c5 0720 	rsb	r7, r5, #32
	if (0 != arr) {
   3527a:	b144      	cbz	r4, 3528e <tc_ctr_prng_update.part.1+0x28>
   3527c:	4642      	mov	r2, r8
			if (++arr[i-1] != 0U) {
   3527e:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
   35282:	3301      	adds	r3, #1
   35284:	b2db      	uxtb	r3, r3
   35286:	7013      	strb	r3, [r2, #0]
   35288:	b90b      	cbnz	r3, 3528e <tc_ctr_prng_update.part.1+0x28>
		for (i = len; i > 0U; i--) {
   3528a:	42a2      	cmp	r2, r4
   3528c:	d1f7      	bne.n	3527e <tc_ctr_prng_update.part.1+0x18>

			/* 10.2.1.2 step 2.1 */
			arrInc(ctx->V, sizeof ctx->V);

			/* 10.2.1.2 step 2.2 */
			if (blocklen > TC_AES_BLOCK_SIZE) {
   3528e:	2f10      	cmp	r7, #16
   35290:	bf28      	it	cs
   35292:	2710      	movcs	r7, #16
				blocklen = TC_AES_BLOCK_SIZE;
			}
			(void)tc_aes_encrypt(output_block, ctx->V, &ctx->key);
   35294:	4642      	mov	r2, r8
   35296:	4621      	mov	r1, r4
   35298:	4668      	mov	r0, sp
   3529a:	f7e5 fab5 	bl	1a808 <tc_aes_encrypt>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   3529e:	ab04      	add	r3, sp, #16
   352a0:	1958      	adds	r0, r3, r5
   352a2:	463a      	mov	r2, r7
   352a4:	4669      	mov	r1, sp

			/* 10.2.1.2 step 2.3/step 3 */
			memcpy(&(temp[len]), output_block, blocklen);

			len += blocklen;
   352a6:	443d      	add	r5, r7
   352a8:	f003 fe96 	bl	38fd8 <memcpy>
		while (len < sizeof temp) {
   352ac:	2d1f      	cmp	r5, #31
   352ae:	d9e2      	bls.n	35276 <tc_ctr_prng_update.part.1+0x10>
   352b0:	1e73      	subs	r3, r6, #1
   352b2:	aa04      	add	r2, sp, #16
   352b4:	361f      	adds	r6, #31

		/* 10.2.1.2 step 4 */
		if (0 != providedData) {
			unsigned int i;
			for (i = 0U; i < sizeof temp; i++) {
				temp[i] ^= providedData[i];
   352b6:	7811      	ldrb	r1, [r2, #0]
   352b8:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   352bc:	4041      	eors	r1, r0
			for (i = 0U; i < sizeof temp; i++) {
   352be:	42b3      	cmp	r3, r6
				temp[i] ^= providedData[i];
   352c0:	f802 1b01 	strb.w	r1, [r2], #1
			for (i = 0U; i < sizeof temp; i++) {
   352c4:	d1f7      	bne.n	352b6 <_flash_used+0x16>
			}
		}

		/* 10.2.1.2 step 5 */
		(void)tc_aes128_set_encrypt_key(&ctx->key, temp);
   352c6:	a904      	add	r1, sp, #16
   352c8:	4640      	mov	r0, r8
   352ca:	f7e5 fa47 	bl	1a75c <tc_aes128_set_encrypt_key>
   352ce:	ad0c      	add	r5, sp, #48	; 0x30
   352d0:	aa08      	add	r2, sp, #32
   352d2:	4613      	mov	r3, r2
   352d4:	cb03      	ldmia	r3!, {r0, r1}
   352d6:	42ab      	cmp	r3, r5
   352d8:	6020      	str	r0, [r4, #0]
   352da:	6061      	str	r1, [r4, #4]
   352dc:	461a      	mov	r2, r3
   352de:	f104 0408 	add.w	r4, r4, #8
   352e2:	d1f6      	bne.n	352d2 <_flash_used+0x32>
    
		/* 10.2.1.2 step 6 */
		memcpy(ctx->V, &(temp[TC_AES_KEY_SIZE]), TC_AES_BLOCK_SIZE);
	}
}
   352e4:	b00c      	add	sp, #48	; 0x30
   352e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000352ea <tc_ctr_prng_init>:
int tc_ctr_prng_init(TCCtrPrng_t * const ctx, 
		     uint8_t const * const entropy,
		     unsigned int entropyLen, 
		     uint8_t const * const personalization,
		     unsigned int pLen)
{
   352ea:	b5f0      	push	{r4, r5, r6, r7, lr}
   352ec:	461e      	mov	r6, r3
   352ee:	b095      	sub	sp, #84	; 0x54
   352f0:	4605      	mov	r5, r0
   352f2:	460c      	mov	r4, r1
   352f4:	4617      	mov	r7, r2
	int result = TC_CRYPTO_FAIL;	
	unsigned int i;
	uint8_t personalization_buf[TC_AES_KEY_SIZE + TC_AES_BLOCK_SIZE] = {0U};
   352f6:	2100      	movs	r1, #0
   352f8:	2220      	movs	r2, #32
   352fa:	a804      	add	r0, sp, #16
   352fc:	f003 fea6 	bl	3904c <memset>
	uint8_t seed_material[TC_AES_KEY_SIZE + TC_AES_BLOCK_SIZE];
	uint8_t zeroArr[TC_AES_BLOCK_SIZE] = {0U};
   35300:	2210      	movs	r2, #16
   35302:	2100      	movs	r1, #0
   35304:	4668      	mov	r0, sp
   35306:	f003 fea1 	bl	3904c <memset>
  
	if (0 != personalization) {
   3530a:	b146      	cbz	r6, 3531e <tc_ctr_prng_init+0x34>
		if (len > sizeof personalization_buf) {
			len = sizeof personalization_buf;
		}

		/* 10.2.1.3.1 step 2 */
		memcpy(personalization_buf, personalization, len);
   3530c:	2320      	movs	r3, #32
   3530e:	9a1a      	ldr	r2, [sp, #104]	; 0x68
   35310:	4631      	mov	r1, r6
   35312:	429a      	cmp	r2, r3
   35314:	bf28      	it	cs
   35316:	461a      	movcs	r2, r3
   35318:	a804      	add	r0, sp, #16
   3531a:	f003 fe6a 	bl	38ff2 <__memcpy_chk>
	}

	if ((0 != ctx) && (0 != entropy) && (entropyLen >= sizeof seed_material)) {
   3531e:	b385      	cbz	r5, 35382 <tc_ctr_prng_init+0x98>
   35320:	b37c      	cbz	r4, 35382 <tc_ctr_prng_init+0x98>
   35322:	2f1f      	cmp	r7, #31
   35324:	d92d      	bls.n	35382 <tc_ctr_prng_init+0x98>
		/* 10.2.1.3.1 step 3 */
		memcpy(seed_material, entropy, sizeof seed_material);
   35326:	aa0c      	add	r2, sp, #48	; 0x30
   35328:	4623      	mov	r3, r4
   3532a:	4616      	mov	r6, r2
   3532c:	f104 0720 	add.w	r7, r4, #32
   35330:	4614      	mov	r4, r2
   35332:	6818      	ldr	r0, [r3, #0]
   35334:	6859      	ldr	r1, [r3, #4]
   35336:	3308      	adds	r3, #8
   35338:	c403      	stmia	r4!, {r0, r1}
   3533a:	42bb      	cmp	r3, r7
   3533c:	4622      	mov	r2, r4
   3533e:	d1f7      	bne.n	35330 <tc_ctr_prng_init+0x46>
		for (i = 0U; i < sizeof seed_material; i++) {
   35340:	4632      	mov	r2, r6
		memcpy(seed_material, entropy, sizeof seed_material);
   35342:	2420      	movs	r4, #32
   35344:	ab04      	add	r3, sp, #16
			seed_material[i] ^= personalization_buf[i];
   35346:	7811      	ldrb	r1, [r2, #0]
   35348:	f813 0b01 	ldrb.w	r0, [r3], #1
		for (i = 0U; i < sizeof seed_material; i++) {
   3534c:	3c01      	subs	r4, #1
			seed_material[i] ^= personalization_buf[i];
   3534e:	ea81 0100 	eor.w	r1, r1, r0
   35352:	f802 1b01 	strb.w	r1, [r2], #1
		for (i = 0U; i < sizeof seed_material; i++) {
   35356:	d1f6      	bne.n	35346 <tc_ctr_prng_init+0x5c>
		}

		/* 10.2.1.3.1 step 4 */
		(void)tc_aes128_set_encrypt_key(&ctx->key, zeroArr);
   35358:	4669      	mov	r1, sp
   3535a:	f105 0010 	add.w	r0, r5, #16
   3535e:	f7e5 f9fd 	bl	1a75c <tc_aes128_set_encrypt_key>
__ssp_bos_icheck3(memset, void *, int)
   35362:	2210      	movs	r2, #16
   35364:	4621      	mov	r1, r4
   35366:	4628      	mov	r0, r5
   35368:	f003 fe70 	bl	3904c <memset>
	if (0 != ctx) {
   3536c:	4628      	mov	r0, r5
   3536e:	4631      	mov	r1, r6
   35370:	f7ff ff79 	bl	35266 <tc_ctr_prng_update.part.1>
    
		/* 10.2.1.3.1 step 6 */    
		tc_ctr_prng_update(ctx, seed_material);

		/* 10.2.1.3.1 step 7 */
		ctx->reseedCount = 1U;
   35374:	2201      	movs	r2, #1
   35376:	2300      	movs	r3, #0

		result = TC_CRYPTO_SUCCESS;
   35378:	2001      	movs	r0, #1
		ctx->reseedCount = 1U;
   3537a:	e9c5 2330 	strd	r2, r3, [r5, #192]	; 0xc0
	}
	return result;
}
   3537e:	b015      	add	sp, #84	; 0x54
   35380:	bdf0      	pop	{r4, r5, r6, r7, pc}
	int result = TC_CRYPTO_FAIL;	
   35382:	2000      	movs	r0, #0
	return result;
   35384:	e7fb      	b.n	3537e <tc_ctr_prng_init+0x94>

00035386 <tc_ctr_prng_generate>:
int tc_ctr_prng_generate(TCCtrPrng_t * const ctx,
			uint8_t const * const additional_input,
			unsigned int additionallen,
			uint8_t * const out,
			unsigned int outlen)
{
   35386:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3538a:	b08c      	sub	sp, #48	; 0x30
   3538c:	460e      	mov	r6, r1
   3538e:	4690      	mov	r8, r2
   35390:	461d      	mov	r5, r3
   35392:	9f12      	ldr	r7, [sp, #72]	; 0x48
	/* 2^19 bits - see section 10.2.1 */ 
	static const unsigned int MAX_BYTES_PER_REQ = 65536U; 

	unsigned int result = TC_CRYPTO_FAIL;

	if ((0 != ctx) && (0 != out) && (outlen < MAX_BYTES_PER_REQ)) {
   35394:	4604      	mov	r4, r0
   35396:	2800      	cmp	r0, #0
   35398:	d04d      	beq.n	35436 <tc_ctr_prng_generate+0xb0>
   3539a:	2b00      	cmp	r3, #0
   3539c:	d04b      	beq.n	35436 <tc_ctr_prng_generate+0xb0>
   3539e:	f5b7 3f80 	cmp.w	r7, #65536	; 0x10000
   353a2:	d248      	bcs.n	35436 <tc_ctr_prng_generate+0xb0>
		/* 10.2.1.5.1 step 1 */
		if (ctx->reseedCount > MAX_REQS_BEFORE_RESEED) {
   353a4:	e9d0 2330 	ldrd	r2, r3, [r0, #192]	; 0xc0
   353a8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   353ac:	bf08      	it	eq
   353ae:	2a01      	cmpeq	r2, #1
   353b0:	d243      	bcs.n	3543a <tc_ctr_prng_generate+0xb4>
			result = TC_CTR_PRNG_RESEED_REQ;
		} else {
			uint8_t additional_input_buf[TC_AES_KEY_SIZE + TC_AES_BLOCK_SIZE] = {0U};
   353b2:	2220      	movs	r2, #32
   353b4:	2100      	movs	r1, #0
   353b6:	a804      	add	r0, sp, #16
   353b8:	f003 fe48 	bl	3904c <memset>
			if (0 != additional_input) {
   353bc:	b166      	cbz	r6, 353d8 <tc_ctr_prng_generate+0x52>
				/* 10.2.1.5.1 step 2  */
				unsigned int len = additionallen;
				if (len > sizeof additional_input_buf) {
					len = sizeof additional_input_buf;
				}
				memcpy(additional_input_buf, additional_input, len);
   353be:	2320      	movs	r3, #32
   353c0:	4598      	cmp	r8, r3
   353c2:	4642      	mov	r2, r8
   353c4:	4631      	mov	r1, r6
   353c6:	bf28      	it	cs
   353c8:	461a      	movcs	r2, r3
   353ca:	a804      	add	r0, sp, #16
   353cc:	f003 fe11 	bl	38ff2 <__memcpy_chk>
	if (0 != ctx) {
   353d0:	a904      	add	r1, sp, #16
   353d2:	4620      	mov	r0, r4
   353d4:	f7ff ff47 	bl	35266 <tc_ctr_prng_update.part.1>
{
   353d8:	2600      	movs	r6, #0
   353da:	e01b      	b.n	35414 <tc_ctr_prng_generate+0x8e>
			/* 10.2.1.5.1 step 3 - implicit */

			/* 10.2.1.5.1 step 4 */
			unsigned int len = 0U;      
			while (len < outlen) {
				unsigned int blocklen = outlen - len;
   353dc:	f104 0110 	add.w	r1, r4, #16
   353e0:	460a      	mov	r2, r1
   353e2:	eba7 0806 	sub.w	r8, r7, r6
			if (++arr[i-1] != 0U) {
   353e6:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
   353ea:	3301      	adds	r3, #1
   353ec:	b2db      	uxtb	r3, r3
   353ee:	700b      	strb	r3, [r1, #0]
   353f0:	b90b      	cbnz	r3, 353f6 <tc_ctr_prng_generate+0x70>
		for (i = len; i > 0U; i--) {
   353f2:	42a1      	cmp	r1, r4
   353f4:	d1f7      	bne.n	353e6 <tc_ctr_prng_generate+0x60>

				/* 10.2.1.5.1 step 4.1 */
				arrInc(ctx->V, sizeof ctx->V);

				/* 10.2.1.5.1 step 4.2 */
				(void)tc_aes_encrypt(output_block, ctx->V, &ctx->key);
   353f6:	4621      	mov	r1, r4
   353f8:	4668      	mov	r0, sp
   353fa:	f7e5 fa05 	bl	1a808 <tc_aes_encrypt>
      
				/* 10.2.1.5.1 step 4.3/step 5 */
				if (blocklen > TC_AES_BLOCK_SIZE) {
   353fe:	f1b8 0f10 	cmp.w	r8, #16
   35402:	bf28      	it	cs
   35404:	f04f 0810 	movcs.w	r8, #16
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   35408:	19a8      	adds	r0, r5, r6
   3540a:	4642      	mov	r2, r8
   3540c:	4669      	mov	r1, sp
   3540e:	f003 fde3 	bl	38fd8 <memcpy>
					blocklen = TC_AES_BLOCK_SIZE;
				}
				memcpy(&(out[len]), output_block, blocklen);

				len += blocklen;
   35412:	4446      	add	r6, r8
			while (len < outlen) {
   35414:	42be      	cmp	r6, r7
   35416:	d3e1      	bcc.n	353dc <tc_ctr_prng_generate+0x56>
	if (0 != ctx) {
   35418:	4620      	mov	r0, r4
   3541a:	a904      	add	r1, sp, #16
   3541c:	f7ff ff23 	bl	35266 <tc_ctr_prng_update.part.1>
      
			/* 10.2.1.5.1 step 6 */
			tc_ctr_prng_update(ctx, additional_input_buf);

			/* 10.2.1.5.1 step 7 */
			ctx->reseedCount++;
   35420:	e9d4 3230 	ldrd	r3, r2, [r4, #192]	; 0xc0

			/* 10.2.1.5.1 step 8 */
			result = TC_CRYPTO_SUCCESS;
   35424:	2001      	movs	r0, #1
			ctx->reseedCount++;
   35426:	3301      	adds	r3, #1
   35428:	f142 0200 	adc.w	r2, r2, #0
   3542c:	e9c4 3230 	strd	r3, r2, [r4, #192]	; 0xc0
		}
	}

	return result;
}
   35430:	b00c      	add	sp, #48	; 0x30
   35432:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	unsigned int result = TC_CRYPTO_FAIL;
   35436:	2000      	movs	r0, #0
   35438:	e7fa      	b.n	35430 <tc_ctr_prng_generate+0xaa>
			result = TC_CTR_PRNG_RESEED_REQ;
   3543a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3543e:	e7f7      	b.n	35430 <tc_ctr_prng_generate+0xaa>

00035440 <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   35440:	2100      	movs	r1, #0
   35442:	2001      	movs	r0, #1
   35444:	f7e5 bc7c 	b.w	1ad40 <z_arm_fatal_error>

00035448 <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   35448:	6e03      	ldr	r3, [r0, #96]	; 0x60
   3544a:	f383 880b 	msr	PSPLIM, r3
}
   3544e:	4770      	bx	lr

00035450 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   35450:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
   35452:	6800      	ldr	r0, [r0, #0]
   35454:	f7e5 bc74 	b.w	1ad40 <z_arm_fatal_error>

00035458 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   35458:	b508      	push	{r3, lr}
	handler();
   3545a:	f7e5 fd05 	bl	1ae68 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   3545e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   35462:	f7e6 b855 	b.w	1b510 <z_arm_exc_exit>

00035466 <mpu_configure_region>:
{
   35466:	b530      	push	{r4, r5, lr}
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
   35468:	684b      	ldr	r3, [r1, #4]
{
   3546a:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
   3546c:	680c      	ldr	r4, [r1, #0]
	p_attr->rbar = attr->rbar &
   3546e:	f89d 2008 	ldrb.w	r2, [sp, #8]
   35472:	890d      	ldrh	r5, [r1, #8]
   35474:	9400      	str	r4, [sp, #0]
	p_attr->mair_idx = attr->mair_idx;
   35476:	8949      	ldrh	r1, [r1, #10]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   35478:	f024 041f 	bic.w	r4, r4, #31
   3547c:	3b01      	subs	r3, #1
	p_attr->rbar = attr->rbar &
   3547e:	f365 0204 	bfi	r2, r5, #0, #5
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   35482:	4423      	add	r3, r4
	p_attr->mair_idx = attr->mair_idx;
   35484:	f361 1247 	bfi	r2, r1, #5, #3
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   35488:	f023 031f 	bic.w	r3, r3, #31
	return region_allocate_and_init(index,
   3548c:	4669      	mov	r1, sp
	p_attr->mair_idx = attr->mair_idx;
   3548e:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   35492:	9303      	str	r3, [sp, #12]
   35494:	f7e6 f8e8 	bl	1b668 <region_allocate_and_init>
}
   35498:	b005      	add	sp, #20
   3549a:	bd30      	pop	{r4, r5, pc}

0003549c <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   3549c:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   354a0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   354a4:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   354a6:	bf08      	it	eq
   354a8:	f06f 0015 	mvneq.w	r0, #21
   354ac:	4770      	bx	lr

000354ae <_stdout_hook_default>:
}
   354ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   354b2:	4770      	bx	lr

000354b4 <_stdin_hook_default>:
}
   354b4:	2000      	movs	r0, #0
   354b6:	4770      	bx	lr

000354b8 <_read>:
{
   354b8:	4608      	mov	r0, r1
	return z_impl_zephyr_read_stdin(buf, nbytes);
   354ba:	4611      	mov	r1, r2
   354bc:	f7e6 baba 	b.w	1ba34 <z_impl_zephyr_read_stdin>

000354c0 <_write>:
{
   354c0:	4608      	mov	r0, r1
	return z_impl_zephyr_write_stdout(buf, nbytes);
   354c2:	4611      	mov	r1, r2
   354c4:	f7e6 baca 	b.w	1ba5c <z_impl_zephyr_write_stdout>

000354c8 <_close>:
   354c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   354cc:	4770      	bx	lr

000354ce <_lseek>:
}
   354ce:	2000      	movs	r0, #0
   354d0:	4770      	bx	lr

000354d2 <_isatty>:
}
   354d2:	2001      	movs	r0, #1
   354d4:	4770      	bx	lr

000354d6 <_kill>:
}
   354d6:	2000      	movs	r0, #0
   354d8:	4770      	bx	lr

000354da <_getpid>:
}
   354da:	2000      	movs	r0, #0
   354dc:	4770      	bx	lr

000354de <_fstat>:
	st->st_mode = S_IFCHR;
   354de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
}
   354e2:	2000      	movs	r0, #0
	st->st_mode = S_IFCHR;
   354e4:	604b      	str	r3, [r1, #4]
}
   354e6:	4770      	bx	lr

000354e8 <__errno>:
	if (z_syscall_trap()) {
		return (int *) arch_syscall_invoke0(K_SYSCALL_Z_ERRNO);
	}
#endif
	compiler_barrier();
	return z_impl_z_errno();
   354e8:	f7f6 b9b8 	b.w	2b85c <z_impl_z_errno>

000354ec <close>:
   354ec:	f7fe bc96 	b.w	33e1c <z_impl_zsock_close>

000354f0 <fixed_data_unref>:
}
   354f0:	4770      	bx	lr

000354f2 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
   354f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
   354f4:	460a      	mov	r2, r1
   354f6:	685b      	ldr	r3, [r3, #4]
   354f8:	6819      	ldr	r1, [r3, #0]
   354fa:	f7e6 bc29 	b.w	1bd50 <net_buf_alloc_len>

000354fe <net_buf_simple_tailroom>:
	return buf->data - buf->__buf;
}

size_t net_buf_simple_tailroom(struct net_buf_simple *buf)
{
	return buf->size - net_buf_simple_headroom(buf) - buf->len;
   354fe:	8883      	ldrh	r3, [r0, #4]
   35500:	88c2      	ldrh	r2, [r0, #6]
   35502:	1ad2      	subs	r2, r2, r3
	return buf->data - buf->__buf;
   35504:	6803      	ldr	r3, [r0, #0]
   35506:	6880      	ldr	r0, [r0, #8]
   35508:	1a18      	subs	r0, r3, r0
}
   3550a:	1a10      	subs	r0, r2, r0
   3550c:	4770      	bx	lr

0003550e <processing_data>:
		locally_routed = true;
	}
#endif

	/* If there is no data, then drop the packet. */
	if (!pkt->frags) {
   3550e:	6903      	ldr	r3, [r0, #16]

	return NET_DROP;
}

static void processing_data(struct net_pkt *pkt, bool is_loopback)
{
   35510:	b510      	push	{r4, lr}
   35512:	4604      	mov	r4, r0
	if (!pkt->frags) {
   35514:	b923      	cbnz	r3, 35520 <processing_data+0x12>
		NET_DBG("Consumed pkt %p", pkt);
		break;
	case NET_DROP:
	default:
		NET_DBG("Dropping pkt %p", pkt);
		net_pkt_unref(pkt);
   35516:	4620      	mov	r0, r4
		break;
	}
}
   35518:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_pkt_unref(pkt);
   3551c:	f000 bbdc 	b.w	35cd8 <net_pkt_unref>
	if (!is_loopback && !locally_routed) {
   35520:	b169      	cbz	r1, 3553e <processing_data+0x30>
	net_pkt_cursor_init(pkt);
   35522:	4620      	mov	r0, r4
   35524:	f000 fc3c 	bl	35da0 <net_pkt_cursor_init>
	return pkt->frags->data;
   35528:	6923      	ldr	r3, [r4, #16]
	switch (NET_IPV6_HDR(pkt)->vtc & 0xf0) {
   3552a:	689b      	ldr	r3, [r3, #8]
   3552c:	781b      	ldrb	r3, [r3, #0]
   3552e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   35532:	2b40      	cmp	r3, #64	; 0x40
   35534:	d1ef      	bne.n	35516 <processing_data+0x8>
		return net_ipv4_input(pkt);
   35536:	4620      	mov	r0, r4
   35538:	f000 ffd9 	bl	364ee <net_ipv4_input>
   3553c:	e005      	b.n	3554a <processing_data+0x3c>
		ret = net_if_recv_data(net_pkt_iface(pkt), pkt);
   3553e:	4601      	mov	r1, r0
   35540:	6a00      	ldr	r0, [r0, #32]
   35542:	f000 f908 	bl	35756 <net_if_recv_data>
		if (ret != NET_CONTINUE) {
   35546:	2801      	cmp	r0, #1
   35548:	d0eb      	beq.n	35522 <processing_data+0x14>
	switch (process_data(pkt, is_loopback)) {
   3554a:	2800      	cmp	r0, #0
   3554c:	d1e3      	bne.n	35516 <processing_data+0x8>
}
   3554e:	bd10      	pop	{r4, pc}

00035550 <net_init>:

	return status;
}

static int net_init(struct device *unused)
{
   35550:	b508      	push	{r3, lr}
	net_hostname_init();

	NET_DBG("Priority %d", CONFIG_NET_INIT_PRIO);

	net_pkt_init();
   35552:	f000 fe28 	bl	361a6 <net_pkt_init>

	net_context_init();
   35556:	f7e7 fe57 	bl	1d208 <net_context_init>
	net_icmpv4_init();
   3555a:	f7e7 ffc7 	bl	1d4ec <net_icmpv4_init>
		net_conn_init();
   3555e:	f7e8 f9bb 	bl	1d8d8 <net_conn_init>
	net_tcp_init();
   35562:	f001 fa73 	bl	36a4c <net_tcp_init>
	net_if_init();
   35566:	f7e6 fff7 	bl	1c558 <net_if_init>
	net_tc_rx_init();
   3556a:	f7e7 ff5b 	bl	1d424 <net_tc_rx_init>
	net_if_post_init();
   3556e:	f7e7 f821 	bl	1c5b4 <net_if_post_init>
	dns_init_resolver();
   35572:	f002 fbac 	bl	37cce <dns_init_resolver>
	net_mgmt_event_init();

	init_rx_queues();

	return services_init();
}
   35576:	2000      	movs	r0, #0
   35578:	bd08      	pop	{r3, pc}

0003557a <net_send_data>:
{
   3557a:	b570      	push	{r4, r5, r6, lr}
	if (!pkt || !pkt->frags) {
   3557c:	4604      	mov	r4, r0
   3557e:	2800      	cmp	r0, #0
   35580:	d065      	beq.n	3564e <net_send_data+0xd4>
   35582:	6903      	ldr	r3, [r0, #16]
   35584:	2b00      	cmp	r3, #0
   35586:	d062      	beq.n	3564e <net_send_data+0xd4>
	if (!net_pkt_iface(pkt)) {
   35588:	6a03      	ldr	r3, [r0, #32]
   3558a:	2b00      	cmp	r3, #0
   3558c:	d062      	beq.n	35654 <net_send_data+0xda>
	net_pkt_trim_buffer(pkt);
   3558e:	f000 fbed 	bl	35d6c <net_pkt_trim_buffer>
	net_pkt_cursor_init(pkt);
   35592:	4620      	mov	r0, r4
   35594:	f000 fc04 	bl	35da0 <net_pkt_cursor_init>
	return pkt->family;
   35598:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
	if (net_pkt_family(pkt) == AF_INET) {
   3559c:	f3c3 0342 	ubfx	r3, r3, #1, #3
   355a0:	2b01      	cmp	r3, #1
   355a2:	d14a      	bne.n	3563a <net_send_data+0xc0>
	return pkt->frags->data;
   355a4:	6923      	ldr	r3, [r4, #16]
   355a6:	689d      	ldr	r5, [r3, #8]
		if (net_ipv4_addr_cmp(&NET_IPV4_HDR(pkt)->dst,
   355a8:	f7e7 f818 	bl	1c5dc <net_ipv4_unspecified_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   355ac:	692a      	ldr	r2, [r5, #16]
   355ae:	6803      	ldr	r3, [r0, #0]
   355b0:	429a      	cmp	r2, r3
   355b2:	d102      	bne.n	355ba <net_send_data+0x40>
			return -EADDRNOTAVAIL;
   355b4:	f06f 007c 	mvn.w	r0, #124	; 0x7c
}
   355b8:	bd70      	pop	{r4, r5, r6, pc}
   355ba:	6923      	ldr	r3, [r4, #16]
   355bc:	689d      	ldr	r5, [r3, #8]
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
   355be:	7c2b      	ldrb	r3, [r5, #16]
   355c0:	2b7f      	cmp	r3, #127	; 0x7f
   355c2:	d10f      	bne.n	355e4 <net_send_data+0x6a>
   355c4:	6923      	ldr	r3, [r4, #16]
			net_ipaddr_copy(&addr, &NET_IPV4_HDR(pkt)->src);
   355c6:	689b      	ldr	r3, [r3, #8]
   355c8:	68da      	ldr	r2, [r3, #12]
   355ca:	6923      	ldr	r3, [r4, #16]
   355cc:	689b      	ldr	r3, [r3, #8]
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->src,
   355ce:	6919      	ldr	r1, [r3, #16]
   355d0:	60d9      	str	r1, [r3, #12]
   355d2:	6923      	ldr	r3, [r4, #16]
   355d4:	689b      	ldr	r3, [r3, #8]
			net_ipaddr_copy(&NET_IPV4_HDR(pkt)->dst, &addr);
   355d6:	611a      	str	r2, [r3, #16]
		processing_data(pkt, true);
   355d8:	2101      	movs	r1, #1
   355da:	4620      	mov	r0, r4
   355dc:	f7ff ff97 	bl	3550e <processing_data>
		return 0;
   355e0:	2000      	movs	r0, #0
   355e2:	e7e9      	b.n	355b8 <net_send_data+0x3e>
		    (net_ipv4_is_addr_bcast(net_pkt_iface(pkt),
   355e4:	6a26      	ldr	r6, [r4, #32]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   355e6:	f7e6 fffd 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   355ea:	692a      	ldr	r2, [r5, #16]
   355ec:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   355ee:	429a      	cmp	r2, r3
   355f0:	d01e      	beq.n	35630 <net_send_data+0xb6>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   355f2:	f105 0110 	add.w	r1, r5, #16
   355f6:	4630      	mov	r0, r6
   355f8:	f7e6 fe28 	bl	1c24c <net_if_ipv4_is_addr_bcast>
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->dst) ||
   355fc:	4601      	mov	r1, r0
   355fe:	b9b8      	cbnz	r0, 35630 <net_send_data+0xb6>
   35600:	6923      	ldr	r3, [r4, #16]
   35602:	689e      	ldr	r6, [r3, #8]
		     net_ipv4_is_my_addr(&NET_IPV4_HDR(pkt)->dst))) {
   35604:	f106 0510 	add.w	r5, r6, #16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   35608:	4628      	mov	r0, r5
   3560a:	f7e6 fe9f 	bl	1c34c <net_if_ipv4_addr_lookup>
   3560e:	2800      	cmp	r0, #0
   35610:	bf14      	ite	ne
   35612:	2001      	movne	r0, #1
   35614:	2000      	moveq	r0, #0
	if (!ret) {
   35616:	d109      	bne.n	3562c <net_send_data+0xb2>
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   35618:	f7e6 ffe4 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   3561c:	6932      	ldr	r2, [r6, #16]
   3561e:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   35620:	429a      	cmp	r2, r3
   35622:	d0cf      	beq.n	355c4 <net_send_data+0x4a>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   35624:	4629      	mov	r1, r5
   35626:	2000      	movs	r0, #0
   35628:	f7e6 fe10 	bl	1c24c <net_if_ipv4_is_addr_bcast>
				     &NET_IPV4_HDR(pkt)->dst) == false &&
   3562c:	2800      	cmp	r0, #0
   3562e:	d1c9      	bne.n	355c4 <net_send_data+0x4a>
   35630:	6923      	ldr	r3, [r4, #16]
		if (net_ipv4_is_addr_loopback(&NET_IPV4_HDR(pkt)->src)) {
   35632:	689b      	ldr	r3, [r3, #8]
   35634:	7b1b      	ldrb	r3, [r3, #12]
   35636:	2b7f      	cmp	r3, #127	; 0x7f
   35638:	d0bc      	beq.n	355b4 <net_send_data+0x3a>
	if (net_if_send_data(net_pkt_iface(pkt), pkt) == NET_DROP) {
   3563a:	4621      	mov	r1, r4
   3563c:	6a20      	ldr	r0, [r4, #32]
   3563e:	f000 f893 	bl	35768 <net_if_send_data>
		return -EIO;
   35642:	2802      	cmp	r0, #2
   35644:	bf14      	ite	ne
   35646:	2000      	movne	r0, #0
   35648:	f06f 0004 	mvneq.w	r0, #4
   3564c:	e7b4      	b.n	355b8 <net_send_data+0x3e>
		return -ENODATA;
   3564e:	f06f 003c 	mvn.w	r0, #60	; 0x3c
   35652:	e7b1      	b.n	355b8 <net_send_data+0x3e>
		return -EINVAL;
   35654:	f06f 0015 	mvn.w	r0, #21
   35658:	e7ae      	b.n	355b8 <net_send_data+0x3e>

0003565a <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   3565a:	6800      	ldr	r0, [r0, #0]
   3565c:	ba00      	rev	r0, r0
   3565e:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   35662:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   35666:	4258      	negs	r0, r3
   35668:	4158      	adcs	r0, r3
   3566a:	4770      	bx	lr

0003566c <net_if_l2>:
	if (!iface || !iface->if_dev) {
   3566c:	b110      	cbz	r0, 35674 <net_if_l2+0x8>
   3566e:	6800      	ldr	r0, [r0, #0]
   35670:	b100      	cbz	r0, 35674 <net_if_l2+0x8>
	return iface->if_dev->l2;
   35672:	6840      	ldr	r0, [r0, #4]
}
   35674:	4770      	bx	lr

00035676 <net_context_send_cb>:
	if (!context) {
   35676:	b118      	cbz	r0, 35680 <net_context_send_cb+0xa>
	if (context->send_cb) {
   35678:	6b43      	ldr	r3, [r0, #52]	; 0x34
   3567a:	b10b      	cbz	r3, 35680 <net_context_send_cb+0xa>
		context->send_cb(context, status, context->user_data);
   3567c:	6802      	ldr	r2, [r0, #0]
   3567e:	4718      	bx	r3
}
   35680:	4770      	bx	lr

00035682 <l2_flags_get>:
{
   35682:	b510      	push	{r4, lr}
   35684:	4602      	mov	r2, r0
	if (net_if_l2(iface) && net_if_l2(iface)->get_flags) {
   35686:	f7ff fff1 	bl	3566c <net_if_l2>
   3568a:	b128      	cbz	r0, 35698 <l2_flags_get+0x16>
   3568c:	68c3      	ldr	r3, [r0, #12]
   3568e:	b11b      	cbz	r3, 35698 <l2_flags_get+0x16>
}
   35690:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		flags = net_if_l2(iface)->get_flags(iface);
   35694:	4610      	mov	r0, r2
   35696:	4718      	bx	r3
}
   35698:	2000      	movs	r0, #0
   3569a:	bd10      	pop	{r4, pc}

0003569c <if_ipv4_get_addr>:
{
   3569c:	b538      	push	{r3, r4, r5, lr}
   3569e:	4615      	mov	r5, r2
	if (!iface) {
   356a0:	4604      	mov	r4, r0
   356a2:	b1c0      	cbz	r0, 356d6 <if_ipv4_get_addr+0x3a>
	ipv4 = iface->config.ip.ipv4;
   356a4:	6844      	ldr	r4, [r0, #4]
	if (!ipv4) {
   356a6:	b1b4      	cbz	r4, 356d6 <if_ipv4_get_addr+0x3a>
		if (!ipv4->unicast[i].is_used ||
   356a8:	7da3      	ldrb	r3, [r4, #22]
   356aa:	f3c3 0340 	ubfx	r3, r3, #1, #1
   356ae:	b90b      	cbnz	r3, 356b4 <if_ipv4_get_addr+0x18>
	return NULL;
   356b0:	461c      	mov	r4, r3
   356b2:	e010      	b.n	356d6 <if_ipv4_get_addr+0x3a>
		if (!ipv4->unicast[i].is_used ||
   356b4:	1c4b      	adds	r3, r1, #1
   356b6:	d003      	beq.n	356c0 <if_ipv4_get_addr+0x24>
		    (addr_state != NET_ADDR_ANY_STATE &&
   356b8:	f994 3015 	ldrsb.w	r3, [r4, #21]
   356bc:	428b      	cmp	r3, r1
   356be:	d110      	bne.n	356e2 <if_ipv4_get_addr+0x46>
		     ipv4->unicast[i].addr_state != addr_state) ||
   356c0:	8823      	ldrh	r3, [r4, #0]
   356c2:	2b01      	cmp	r3, #1
   356c4:	d10d      	bne.n	356e2 <if_ipv4_get_addr+0x46>
		if (net_ipv4_is_ll_addr(&ipv4->unicast[i].address.in_addr)) {
   356c6:	3404      	adds	r4, #4
   356c8:	4620      	mov	r0, r4
   356ca:	f7e6 fca5 	bl	1c018 <net_ipv4_is_ll_addr>
   356ce:	b120      	cbz	r0, 356da <if_ipv4_get_addr+0x3e>
	return NULL;
   356d0:	2d00      	cmp	r5, #0
   356d2:	bf08      	it	eq
   356d4:	2400      	moveq	r4, #0
}
   356d6:	4620      	mov	r0, r4
   356d8:	bd38      	pop	{r3, r4, r5, pc}
	return NULL;
   356da:	2d00      	cmp	r5, #0
   356dc:	bf18      	it	ne
   356de:	2400      	movne	r4, #0
   356e0:	e7f9      	b.n	356d6 <if_ipv4_get_addr+0x3a>
   356e2:	2400      	movs	r4, #0
   356e4:	e7f7      	b.n	356d6 <if_ipv4_get_addr+0x3a>

000356e6 <k_uptime_get_32>:
{
   356e6:	b510      	push	{r4, lr}
	return z_impl_k_uptime_ticks();
   356e8:	f003 fba8 	bl	38e3c <z_impl_k_uptime_ticks>
   356ec:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   356f0:	fba0 2304 	umull	r2, r3, r0, r4
   356f4:	fb04 3301 	mla	r3, r4, r1, r3
   356f8:	0bd0      	lsrs	r0, r2, #15
}
   356fa:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   356fe:	bd10      	pop	{r4, pc}

00035700 <net_if_ipv4_addr_mask_cmp>:
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
   35700:	6843      	ldr	r3, [r0, #4]
	if (!ipv4) {
   35702:	b17b      	cbz	r3, 35724 <net_if_ipv4_addr_mask_cmp+0x24>
		if (!ipv4->unicast[i].is_used ||
   35704:	7d98      	ldrb	r0, [r3, #22]
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
   35706:	6b5a      	ldr	r2, [r3, #52]	; 0x34
   35708:	6809      	ldr	r1, [r1, #0]
		if (!ipv4->unicast[i].is_used ||
   3570a:	f3c0 0040 	ubfx	r0, r0, #1, #1
	subnet = UNALIGNED_GET(&addr->s_addr) & ipv4->netmask.s_addr;
   3570e:	4011      	ands	r1, r2
		if (!ipv4->unicast[i].is_used ||
   35710:	b148      	cbz	r0, 35726 <net_if_ipv4_addr_mask_cmp+0x26>
   35712:	8818      	ldrh	r0, [r3, #0]
   35714:	2801      	cmp	r0, #1
   35716:	d105      	bne.n	35724 <net_if_ipv4_addr_mask_cmp+0x24>
		if ((ipv4->unicast[i].address.in_addr.s_addr &
   35718:	6858      	ldr	r0, [r3, #4]
   3571a:	4010      	ands	r0, r2
   3571c:	1a43      	subs	r3, r0, r1
   3571e:	4258      	negs	r0, r3
   35720:	4158      	adcs	r0, r3
   35722:	4770      	bx	lr
		return false;
   35724:	2000      	movs	r0, #0
}
   35726:	4770      	bx	lr

00035728 <ipv4_is_broadcast_address>:
{
   35728:	b538      	push	{r3, r4, r5, lr}
	struct net_if_ipv4 *ipv4 = iface->config.ip.ipv4;
   3572a:	6844      	ldr	r4, [r0, #4]
{
   3572c:	460d      	mov	r5, r1
	if (!ipv4) {
   3572e:	b154      	cbz	r4, 35746 <ipv4_is_broadcast_address+0x1e>
	if (!net_if_ipv4_addr_mask_cmp(iface, addr)) {
   35730:	f7ff ffe6 	bl	35700 <net_if_ipv4_addr_mask_cmp>
   35734:	b130      	cbz	r0, 35744 <ipv4_is_broadcast_address+0x1c>
	if ((UNALIGNED_GET(&addr->s_addr) & ~ipv4->netmask.s_addr) ==
   35736:	6b63      	ldr	r3, [r4, #52]	; 0x34
   35738:	682a      	ldr	r2, [r5, #0]
   3573a:	43db      	mvns	r3, r3
   3573c:	4393      	bics	r3, r2
   3573e:	bf0c      	ite	eq
   35740:	2001      	moveq	r0, #1
   35742:	2000      	movne	r0, #0
}
   35744:	bd38      	pop	{r3, r4, r5, pc}
		return false;
   35746:	4620      	mov	r0, r4
   35748:	e7fc      	b.n	35744 <ipv4_is_broadcast_address+0x1c>

0003574a <net_if_ipv4_get_ll>:
	return if_ipv4_get_addr(iface, addr_state, true);
   3574a:	2201      	movs	r2, #1
   3574c:	f7ff bfa6 	b.w	3569c <if_ipv4_get_addr>

00035750 <net_if_ipv4_get_global_addr>:
	return if_ipv4_get_addr(iface, addr_state, false);
   35750:	2200      	movs	r2, #0
   35752:	f7ff bfa3 	b.w	3569c <if_ipv4_get_addr>

00035756 <net_if_recv_data>:
{
   35756:	b510      	push	{r4, lr}
   35758:	4602      	mov	r2, r0
	return net_if_l2(iface)->recv(iface, pkt);
   3575a:	f7ff ff87 	bl	3566c <net_if_l2>
}
   3575e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return net_if_l2(iface)->recv(iface, pkt);
   35762:	6803      	ldr	r3, [r0, #0]
   35764:	4610      	mov	r0, r2
   35766:	4718      	bx	r3

00035768 <net_if_send_data>:
{
   35768:	b570      	push	{r4, r5, r6, lr}
   3576a:	460c      	mov	r4, r1
	struct net_context *context = net_pkt_context(pkt);
   3576c:	69ce      	ldr	r6, [r1, #28]
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
   3576e:	2100      	movs	r1, #0
{
   35770:	4605      	mov	r5, r0
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
   35772:	f7e6 fc5d 	bl	1c030 <net_if_flag_is_set>
   35776:	b958      	cbnz	r0, 35790 <net_if_send_data+0x28>
		if (context) {
   35778:	bb26      	cbnz	r6, 357c4 <net_if_send_data+0x5c>
		if (dst->addr) {
   3577a:	6b23      	ldr	r3, [r4, #48]	; 0x30
   3577c:	b133      	cbz	r3, 3578c <net_if_send_data+0x24>
			net_if_call_link_cb(iface, dst, status);
   3577e:	f06f 0272 	mvn.w	r2, #114	; 0x72
   35782:	f104 0130 	add.w	r1, r4, #48	; 0x30
   35786:	4628      	mov	r0, r5
   35788:	f7e6 fe22 	bl	1c3d0 <net_if_call_link_cb>
		verdict = NET_DROP;
   3578c:	2002      	movs	r0, #2
   3578e:	e018      	b.n	357c2 <net_if_send_data+0x5a>
	    net_if_flag_is_set(iface, NET_IF_SUSPENDED)) {
   35790:	2104      	movs	r1, #4
   35792:	4628      	mov	r0, r5
   35794:	f7e6 fc4c 	bl	1c030 <net_if_flag_is_set>
	if (!net_if_flag_is_set(iface, NET_IF_UP) ||
   35798:	2800      	cmp	r0, #0
   3579a:	d1ed      	bne.n	35778 <net_if_send_data+0x10>
	if (!net_if_flag_is_set(iface, NET_IF_POINTOPOINT) &&
   3579c:	2101      	movs	r1, #1
   3579e:	4628      	mov	r0, r5
   357a0:	f7e6 fc46 	bl	1c030 <net_if_flag_is_set>
   357a4:	b940      	cbnz	r0, 357b8 <net_if_send_data+0x50>
   357a6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   357a8:	b933      	cbnz	r3, 357b8 <net_if_send_data+0x50>
	return net_if_get_link_addr(pkt->iface);
   357aa:	6a23      	ldr	r3, [r4, #32]
   357ac:	681b      	ldr	r3, [r3, #0]
		net_pkt_lladdr_src(pkt)->addr = net_pkt_lladdr_if(pkt)->addr;
   357ae:	691a      	ldr	r2, [r3, #16]
   357b0:	62a2      	str	r2, [r4, #40]	; 0x28
		net_pkt_lladdr_src(pkt)->len = net_pkt_lladdr_if(pkt)->len;
   357b2:	7d1b      	ldrb	r3, [r3, #20]
   357b4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
		net_if_queue_tx(iface, pkt);
   357b8:	4628      	mov	r0, r5
   357ba:	4621      	mov	r1, r4
   357bc:	f7e6 fd2a 	bl	1c214 <net_if_queue_tx>
   357c0:	2000      	movs	r0, #0
}
   357c2:	bd70      	pop	{r4, r5, r6, pc}
			net_context_send_cb(context, status);
   357c4:	f06f 0172 	mvn.w	r1, #114	; 0x72
   357c8:	4630      	mov	r0, r6
   357ca:	f7ff ff54 	bl	35676 <net_context_send_cb>
   357ce:	e7d4      	b.n	3577a <net_if_send_data+0x12>

000357d0 <net_if_need_calc_tx_checksum>:
   357d0:	2001      	movs	r0, #1
   357d2:	4770      	bx	lr

000357d4 <net_if_need_calc_rx_checksum>:
}
   357d4:	2001      	movs	r0, #1
   357d6:	4770      	bx	lr

000357d8 <calc_chksum>:
{
   357d8:	b510      	push	{r4, lr}
	end = data + len - 1;
   357da:	3a01      	subs	r2, #1
   357dc:	440a      	add	r2, r1
	while (data < end) {
   357de:	4291      	cmp	r1, r2
   357e0:	d309      	bcc.n	357f6 <calc_chksum+0x1e>
	if (data == end) {
   357e2:	d107      	bne.n	357f4 <calc_chksum+0x1c>
		tmp = data[0] << 8;
   357e4:	780b      	ldrb	r3, [r1, #0]
   357e6:	021b      	lsls	r3, r3, #8
		sum += tmp;
   357e8:	4418      	add	r0, r3
   357ea:	b280      	uxth	r0, r0
		if (sum < tmp) {
   357ec:	4283      	cmp	r3, r0
			sum++;
   357ee:	bf84      	itt	hi
   357f0:	3001      	addhi	r0, #1
   357f2:	b280      	uxthhi	r0, r0
}
   357f4:	bd10      	pop	{r4, pc}
		tmp = (data[0] << 8) + data[1];
   357f6:	780c      	ldrb	r4, [r1, #0]
   357f8:	784b      	ldrb	r3, [r1, #1]
		data += 2;
   357fa:	3102      	adds	r1, #2
		tmp = (data[0] << 8) + data[1];
   357fc:	eb03 2304 	add.w	r3, r3, r4, lsl #8
   35800:	b29b      	uxth	r3, r3
		sum += tmp;
   35802:	4418      	add	r0, r3
   35804:	b280      	uxth	r0, r0
		if (sum < tmp) {
   35806:	4283      	cmp	r3, r0
			sum++;
   35808:	bf84      	itt	hi
   3580a:	3001      	addhi	r0, #1
   3580c:	b280      	uxthhi	r0, r0
		data += 2;
   3580e:	e7e6      	b.n	357de <calc_chksum+0x6>

00035810 <net_calc_chksum>:
	return pkt->family;
   35810:	f890 303f 	ldrb.w	r3, [r0, #63]	; 0x3f
{
   35814:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   35818:	f3c3 0342 	ubfx	r3, r3, #1, #3
   3581c:	2b01      	cmp	r3, #1
{
   3581e:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_NET_IPV4) &&
   35820:	d179      	bne.n	35916 <net_calc_chksum+0x106>
		if (proto != IPPROTO_ICMP) {
   35822:	2901      	cmp	r1, #1
   35824:	d050      	beq.n	358c8 <net_calc_chksum+0xb8>
	size_t bytes = 0;
   35826:	2200      	movs	r2, #0
			sum = net_pkt_get_len(pkt) -
   35828:	6903      	ldr	r3, [r0, #16]
	while (buf) {
   3582a:	2b00      	cmp	r3, #0
   3582c:	d148      	bne.n	358c0 <net_calc_chksum+0xb0>
			len = 2 * sizeof(struct in_addr);
   3582e:	f04f 0908 	mov.w	r9, #8
				net_pkt_ip_hdr_len(pkt) -
   35832:	f894 503c 	ldrb.w	r5, [r4, #60]	; 0x3c
				net_pkt_ipv4_opts_len(pkt) + proto;
   35836:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
			sum = net_pkt_get_len(pkt) -
   3583a:	441d      	add	r5, r3
   3583c:	1b4d      	subs	r5, r1, r5
   3583e:	4415      	add	r5, r2
   35840:	b2ad      	uxth	r5, r5
	net_pkt_cursor_init(pkt);
   35842:	4620      	mov	r0, r4
	backup->pos = pkt->cursor.pos;
   35844:	e9d4 8705 	ldrd	r8, r7, [r4, #20]
   35848:	f000 faaa 	bl	35da0 <net_pkt_cursor_init>
	return pkt->overwrite;
   3584c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) - len);
   35850:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
   35854:	f003 0601 	and.w	r6, r3, #1
	pkt->overwrite = overwrite;
   35858:	f043 0301 	orr.w	r3, r3, #1
   3585c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   35860:	eba1 0109 	sub.w	r1, r1, r9
   35864:	4620      	mov	r0, r4
   35866:	f000 fb25 	bl	35eb4 <net_pkt_skip>
	sum = calc_chksum(sum, pkt->cursor.pos, len);
   3586a:	464a      	mov	r2, r9
   3586c:	69a1      	ldr	r1, [r4, #24]
   3586e:	4628      	mov	r0, r5
   35870:	f7ff ffb2 	bl	357d8 <calc_chksum>
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
   35874:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
	sum = calc_chksum(sum, pkt->cursor.pos, len);
   35878:	4605      	mov	r5, r0
	net_pkt_skip(pkt, len + net_pkt_ip_opts_len(pkt));
   3587a:	4449      	add	r1, r9
   3587c:	4620      	mov	r0, r4
   3587e:	f000 fb19 	bl	35eb4 <net_pkt_skip>
	if (!cur->buf || !cur->pos) {
   35882:	6962      	ldr	r2, [r4, #20]
   35884:	b162      	cbz	r2, 358a0 <net_calc_chksum+0x90>
   35886:	69a3      	ldr	r3, [r4, #24]
   35888:	b153      	cbz	r3, 358a0 <net_calc_chksum+0x90>
	len = cur->buf->len - (cur->pos - cur->buf->data);
   3588a:	f8b2 900c 	ldrh.w	r9, [r2, #12]
   3588e:	6892      	ldr	r2, [r2, #8]
   35890:	1a9b      	subs	r3, r3, r2
   35892:	eba9 0903 	sub.w	r9, r9, r3
	while (cur->buf) {
   35896:	f8d4 a014 	ldr.w	sl, [r4, #20]
   3589a:	f1ba 0f00 	cmp.w	sl, #0
   3589e:	d116      	bne.n	358ce <net_calc_chksum+0xbe>
	sum = (sum == 0U) ? 0xffff : htons(sum);
   358a0:	2d00      	cmp	r5, #0
   358a2:	d035      	beq.n	35910 <net_calc_chksum+0x100>
   358a4:	ba68      	rev16	r0, r5
   358a6:	b280      	uxth	r0, r0
	return ~sum;
   358a8:	43c0      	mvns	r0, r0
   358aa:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	pkt->cursor.pos = backup->pos;
   358ae:	e9c4 8705 	strd	r8, r7, [r4, #20]
	pkt->overwrite = overwrite;
   358b2:	f366 0300 	bfi	r3, r6, #0, #1
   358b6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   358ba:	b280      	uxth	r0, r0
}
   358bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		bytes += buf->len;
   358c0:	8998      	ldrh	r0, [r3, #12]
		buf = buf->frags;
   358c2:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   358c4:	4402      	add	r2, r0
		buf = buf->frags;
   358c6:	e7b0      	b.n	3582a <net_calc_chksum+0x1a>
	u16_t sum = 0U;
   358c8:	2500      	movs	r5, #0
	size_t len = 0U;
   358ca:	46a9      	mov	r9, r5
   358cc:	e7b9      	b.n	35842 <net_calc_chksum+0x32>
		sum = calc_chksum(sum, cur->pos, len);
   358ce:	4628      	mov	r0, r5
   358d0:	464a      	mov	r2, r9
   358d2:	69a1      	ldr	r1, [r4, #24]
   358d4:	f7ff ff80 	bl	357d8 <calc_chksum>
		cur->buf = cur->buf->frags;
   358d8:	f8da 3000 	ldr.w	r3, [sl]
		sum = calc_chksum(sum, cur->pos, len);
   358dc:	4605      	mov	r5, r0
		cur->buf = cur->buf->frags;
   358de:	6163      	str	r3, [r4, #20]
		if (!cur->buf || !cur->buf->len) {
   358e0:	2b00      	cmp	r3, #0
   358e2:	d0dd      	beq.n	358a0 <net_calc_chksum+0x90>
   358e4:	899a      	ldrh	r2, [r3, #12]
   358e6:	2a00      	cmp	r2, #0
   358e8:	d0da      	beq.n	358a0 <net_calc_chksum+0x90>
		cur->pos = cur->buf->data;
   358ea:	689b      	ldr	r3, [r3, #8]
		if (len % 2) {
   358ec:	f019 0f01 	tst.w	r9, #1
		cur->pos = cur->buf->data;
   358f0:	61a3      	str	r3, [r4, #24]
		if (len % 2) {
   358f2:	d00b      	beq.n	3590c <net_calc_chksum+0xfc>
			sum += *cur->pos;
   358f4:	7819      	ldrb	r1, [r3, #0]
			cur->pos++;
   358f6:	3301      	adds	r3, #1
			sum += *cur->pos;
   358f8:	440d      	add	r5, r1
   358fa:	b2ad      	uxth	r5, r5
			if (sum < *cur->pos) {
   358fc:	42a9      	cmp	r1, r5
				sum++;
   358fe:	bf84      	itt	hi
   35900:	3501      	addhi	r5, #1
   35902:	b2ad      	uxthhi	r5, r5
			cur->pos++;
   35904:	61a3      	str	r3, [r4, #24]
			len = cur->buf->len - 1;
   35906:	f102 39ff 	add.w	r9, r2, #4294967295	; 0xffffffff
   3590a:	e7c4      	b.n	35896 <net_calc_chksum+0x86>
			len = cur->buf->len;
   3590c:	4691      	mov	r9, r2
   3590e:	e7c2      	b.n	35896 <net_calc_chksum+0x86>
	sum = (sum == 0U) ? 0xffff : htons(sum);
   35910:	f64f 70ff 	movw	r0, #65535	; 0xffff
   35914:	e7c8      	b.n	358a8 <net_calc_chksum+0x98>
		return 0;
   35916:	2000      	movs	r0, #0
   35918:	e7d0      	b.n	358bc <net_calc_chksum+0xac>

0003591a <net_calc_chksum_ipv4>:
{
   3591a:	b508      	push	{r3, lr}
			  net_pkt_ipv4_opts_len(pkt));
   3591c:	f890 2043 	ldrb.w	r2, [r0, #67]	; 0x43
			  net_pkt_ip_hdr_len(pkt) +
   35920:	f890 103c 	ldrb.w	r1, [r0, #60]	; 0x3c
	sum = calc_chksum(0, pkt->buffer->data,
   35924:	6903      	ldr	r3, [r0, #16]
   35926:	440a      	add	r2, r1
   35928:	2000      	movs	r0, #0
   3592a:	6899      	ldr	r1, [r3, #8]
   3592c:	f7ff ff54 	bl	357d8 <calc_chksum>
	sum = (sum == 0U) ? 0xffff : htons(sum);
   35930:	b120      	cbz	r0, 3593c <net_calc_chksum_ipv4+0x22>
   35932:	ba40      	rev16	r0, r0
   35934:	b280      	uxth	r0, r0
	return ~sum;
   35936:	43c0      	mvns	r0, r0
}
   35938:	b280      	uxth	r0, r0
   3593a:	bd08      	pop	{r3, pc}
	sum = (sum == 0U) ? 0xffff : htons(sum);
   3593c:	f64f 70ff 	movw	r0, #65535	; 0xffff
   35940:	e7f9      	b.n	35936 <net_calc_chksum_ipv4+0x1c>

00035942 <net_ipv4_is_addr_mcast>:
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   35942:	6800      	ldr	r0, [r0, #0]
   35944:	ba00      	rev	r0, r0
   35946:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   3594a:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   3594e:	4258      	negs	r0, r3
   35950:	4158      	adcs	r0, r3
   35952:	4770      	bx	lr

00035954 <k_mutex_unlock>:
	return z_impl_k_mutex_unlock(mutex);
   35954:	f7f6 bf38 	b.w	2c7c8 <z_impl_k_mutex_unlock>

00035958 <context_write_data>:
{
   35958:	b570      	push	{r4, r5, r6, lr}
   3595a:	4606      	mov	r6, r0
	if (msghdr) {
   3595c:	461d      	mov	r5, r3
   3595e:	b99b      	cbnz	r3, 35988 <context_write_data+0x30>
}
   35960:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		ret = net_pkt_write(pkt, buf, buf_len);
   35964:	f000 bbdf 	b.w	36126 <net_pkt_write>
			ret = net_pkt_write(pkt, msghdr->msg_iov[i].iov_base,
   35968:	68ab      	ldr	r3, [r5, #8]
   3596a:	4630      	mov	r0, r6
   3596c:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
   35970:	6852      	ldr	r2, [r2, #4]
   35972:	f853 1034 	ldr.w	r1, [r3, r4, lsl #3]
   35976:	f000 fbd6 	bl	36126 <net_pkt_write>
			if (ret < 0) {
   3597a:	2800      	cmp	r0, #0
   3597c:	db03      	blt.n	35986 <context_write_data+0x2e>
		for (i = 0; i < msghdr->msg_iovlen; i++) {
   3597e:	3401      	adds	r4, #1
   35980:	68eb      	ldr	r3, [r5, #12]
   35982:	42a3      	cmp	r3, r4
   35984:	d8f0      	bhi.n	35968 <context_write_data+0x10>
}
   35986:	bd70      	pop	{r4, r5, r6, pc}
		for (i = 0; i < msghdr->msg_iovlen; i++) {
   35988:	2400      	movs	r4, #0
	int ret = 0;
   3598a:	4620      	mov	r0, r4
   3598c:	e7f8      	b.n	35980 <context_write_data+0x28>

0003598e <k_mutex_lock.constprop.28>:
	return z_impl_k_mutex_lock(mutex, timeout);
   3598e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   35992:	f7f6 be3b 	b.w	2c60c <z_impl_k_mutex_lock>

00035996 <net_context_ref>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
   35996:	1d03      	adds	r3, r0, #4
   35998:	e8d3 0fef 	ldaex	r0, [r3]
   3599c:	1c42      	adds	r2, r0, #1
   3599e:	e8c3 2fe1 	stlex	r1, r2, [r3]
   359a2:	2900      	cmp	r1, #0
   359a4:	d1f8      	bne.n	35998 <net_context_ref+0x2>
}
   359a6:	3001      	adds	r0, #1
   359a8:	4770      	bx	lr

000359aa <net_context_unref>:
{
   359aa:	b538      	push	{r3, r4, r5, lr}
   359ac:	4604      	mov	r4, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
   359ae:	1d03      	adds	r3, r0, #4
   359b0:	e8d3 0fef 	ldaex	r0, [r3]
   359b4:	1e42      	subs	r2, r0, #1
   359b6:	e8c3 2fe1 	stlex	r1, r2, [r3]
   359ba:	2900      	cmp	r1, #0
   359bc:	d1f8      	bne.n	359b0 <net_context_unref+0x6>
	if (old_rc != 1) {
   359be:	2801      	cmp	r0, #1
   359c0:	d001      	beq.n	359c6 <net_context_unref+0x1c>
		return old_rc - 1;
   359c2:	3801      	subs	r0, #1
}
   359c4:	bd38      	pop	{r3, r4, r5, pc}
	k_mutex_lock(&context->lock, K_FOREVER);
   359c6:	f104 0508 	add.w	r5, r4, #8
   359ca:	4628      	mov	r0, r5
   359cc:	f7ff ffdf 	bl	3598e <k_mutex_lock.constprop.28>
	net_tcp_unref(context);
   359d0:	4620      	mov	r0, r4
   359d2:	f7e8 ff53 	bl	1e87c <net_tcp_unref>
	if (context->conn_handler) {
   359d6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   359d8:	b118      	cbz	r0, 359e2 <net_context_unref+0x38>
			net_conn_unregister(context->conn_handler);
   359da:	f7e7 fe5f 	bl	1d69c <net_conn_unregister>
		context->conn_handler = NULL;
   359de:	2300      	movs	r3, #0
   359e0:	62e3      	str	r3, [r4, #44]	; 0x2c
	context->flags &= ~NET_CONTEXT_IN_USE;
   359e2:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
	k_mutex_unlock(&context->lock);
   359e6:	4628      	mov	r0, r5
	context->flags &= ~NET_CONTEXT_IN_USE;
   359e8:	f023 0307 	bic.w	r3, r3, #7
   359ec:	f8a4 307a 	strh.w	r3, [r4, #122]	; 0x7a
	k_mutex_unlock(&context->lock);
   359f0:	f7ff ffb0 	bl	35954 <k_mutex_unlock>
   359f4:	2000      	movs	r0, #0
   359f6:	e7e5      	b.n	359c4 <net_context_unref+0x1a>

000359f8 <bind_default>:
{
   359f8:	b513      	push	{r0, r1, r4, lr}
   359fa:	4604      	mov	r4, r0
	sa_family_t family = net_context_get_family(context);
   359fc:	f7e6 fe5c 	bl	1c6b8 <net_context_get_family>
	if (IS_ENABLED(CONFIG_NET_IPV4) && family == AF_INET) {
   35a00:	2801      	cmp	r0, #1
   35a02:	d113      	bne.n	35a2c <bind_default+0x34>
		if (net_sin_ptr(&context->local)->sin_addr) {
   35a04:	6a23      	ldr	r3, [r4, #32]
   35a06:	b97b      	cbnz	r3, 35a28 <bind_default+0x30>
		addr4.sin_family = AF_INET;
   35a08:	f8ad 0000 	strh.w	r0, [sp]
			find_available_port(context,
   35a0c:	4669      	mov	r1, sp
   35a0e:	4620      	mov	r0, r4
		addr4.sin_addr.s_addr = INADDR_ANY;
   35a10:	9301      	str	r3, [sp, #4]
			find_available_port(context,
   35a12:	f7e6 fe91 	bl	1c738 <find_available_port>
		return net_context_bind(context, (struct sockaddr *)&addr4,
   35a16:	2208      	movs	r2, #8
		addr4.sin_port =
   35a18:	f8ad 0002 	strh.w	r0, [sp, #2]
		return net_context_bind(context, (struct sockaddr *)&addr4,
   35a1c:	4669      	mov	r1, sp
   35a1e:	4620      	mov	r0, r4
   35a20:	f7e7 f822 	bl	1ca68 <net_context_bind>
}
   35a24:	b002      	add	sp, #8
   35a26:	bd10      	pop	{r4, pc}
			return 0;
   35a28:	2000      	movs	r0, #0
   35a2a:	e7fb      	b.n	35a24 <bind_default+0x2c>
	return -EINVAL;
   35a2c:	f06f 0015 	mvn.w	r0, #21
   35a30:	e7f8      	b.n	35a24 <bind_default+0x2c>

00035a32 <net_context_send>:
{
   35a32:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
   35a36:	4604      	mov	r4, r0
	k_mutex_lock(&context->lock, K_FOREVER);
   35a38:	f100 0508 	add.w	r5, r0, #8
   35a3c:	4628      	mov	r0, r5
{
   35a3e:	4698      	mov	r8, r3
   35a40:	460e      	mov	r6, r1
   35a42:	4617      	mov	r7, r2
	k_mutex_lock(&context->lock, K_FOREVER);
   35a44:	f7ff ffa3 	bl	3598e <k_mutex_lock.constprop.28>
	if (!(context->flags & NET_CONTEXT_REMOTE_ADDR_SET) ||
   35a48:	f8b4 307a 	ldrh.w	r3, [r4, #122]	; 0x7a
   35a4c:	05db      	lsls	r3, r3, #23
   35a4e:	d51d      	bpl.n	35a8c <net_context_send+0x5a>
   35a50:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
   35a52:	b1db      	cbz	r3, 35a8c <net_context_send+0x5a>
		   net_context_get_family(context) == AF_INET) {
   35a54:	4620      	mov	r0, r4
   35a56:	f7e6 fe2f 	bl	1c6b8 <net_context_get_family>
	ret = context_sendto(context, buf, len, &context->remote,
   35a5a:	2200      	movs	r2, #0
	} else if (IS_ENABLED(CONFIG_NET_IPV4) &&
   35a5c:	2801      	cmp	r0, #1
		addrlen = 0;
   35a5e:	bf0c      	ite	eq
   35a60:	2308      	moveq	r3, #8
   35a62:	2300      	movne	r3, #0
	ret = context_sendto(context, buf, len, &context->remote,
   35a64:	9203      	str	r2, [sp, #12]
   35a66:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
   35a68:	9300      	str	r3, [sp, #0]
   35a6a:	e9cd 8201 	strd	r8, r2, [sp, #4]
   35a6e:	f104 0324 	add.w	r3, r4, #36	; 0x24
   35a72:	4620      	mov	r0, r4
   35a74:	463a      	mov	r2, r7
   35a76:	4631      	mov	r1, r6
   35a78:	f7e7 f8f8 	bl	1cc6c <context_sendto.isra.21>
   35a7c:	4604      	mov	r4, r0
	k_mutex_unlock(&context->lock);
   35a7e:	4628      	mov	r0, r5
   35a80:	f7ff ff68 	bl	35954 <k_mutex_unlock>
}
   35a84:	4620      	mov	r0, r4
   35a86:	b004      	add	sp, #16
   35a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		ret = -EDESTADDRREQ;
   35a8c:	f06f 0478 	mvn.w	r4, #120	; 0x78
   35a90:	e7f5      	b.n	35a7e <net_context_send+0x4c>

00035a92 <net_context_sendmsg>:
{
   35a92:	b5f0      	push	{r4, r5, r6, r7, lr}
	k_mutex_lock(&context->lock, K_FOREVER);
   35a94:	f100 0408 	add.w	r4, r0, #8
{
   35a98:	b085      	sub	sp, #20
   35a9a:	4605      	mov	r5, r0
	k_mutex_lock(&context->lock, K_FOREVER);
   35a9c:	4620      	mov	r0, r4
{
   35a9e:	461f      	mov	r7, r3
   35aa0:	460e      	mov	r6, r1
	k_mutex_lock(&context->lock, K_FOREVER);
   35aa2:	f7ff ff74 	bl	3598e <k_mutex_lock.constprop.28>
	ret = context_sendto(context, msghdr, 0, NULL, 0,
   35aa6:	2301      	movs	r3, #1
   35aa8:	9303      	str	r3, [sp, #12]
   35aaa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   35aac:	4631      	mov	r1, r6
   35aae:	e9cd 7301 	strd	r7, r3, [sp, #4]
   35ab2:	2300      	movs	r3, #0
   35ab4:	4628      	mov	r0, r5
   35ab6:	9300      	str	r3, [sp, #0]
   35ab8:	461a      	mov	r2, r3
   35aba:	f7e7 f8d7 	bl	1cc6c <context_sendto.isra.21>
   35abe:	4605      	mov	r5, r0
	k_mutex_unlock(&context->lock);
   35ac0:	4620      	mov	r0, r4
   35ac2:	f7ff ff47 	bl	35954 <k_mutex_unlock>
}
   35ac6:	4628      	mov	r0, r5
   35ac8:	b005      	add	sp, #20
   35aca:	bdf0      	pop	{r4, r5, r6, r7, pc}

00035acc <net_context_sendto>:
{
   35acc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	k_mutex_lock(&context->lock, K_FOREVER);
   35ad0:	f100 0408 	add.w	r4, r0, #8
{
   35ad4:	4605      	mov	r5, r0
	k_mutex_lock(&context->lock, K_FOREVER);
   35ad6:	4620      	mov	r0, r4
{
   35ad8:	4698      	mov	r8, r3
   35ada:	460e      	mov	r6, r1
   35adc:	4617      	mov	r7, r2
	k_mutex_lock(&context->lock, K_FOREVER);
   35ade:	f7ff ff56 	bl	3598e <k_mutex_lock.constprop.28>
	ret = context_sendto(context, buf, len, dst_addr, addrlen,
   35ae2:	2301      	movs	r3, #1
   35ae4:	9303      	str	r3, [sp, #12]
   35ae6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
   35ae8:	463a      	mov	r2, r7
   35aea:	9302      	str	r3, [sp, #8]
   35aec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   35aee:	4631      	mov	r1, r6
   35af0:	9301      	str	r3, [sp, #4]
   35af2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   35af4:	4628      	mov	r0, r5
   35af6:	9300      	str	r3, [sp, #0]
   35af8:	4643      	mov	r3, r8
   35afa:	f7e7 f8b7 	bl	1cc6c <context_sendto.isra.21>
   35afe:	4605      	mov	r5, r0
	k_mutex_unlock(&context->lock);
   35b00:	4620      	mov	r0, r4
   35b02:	f7ff ff27 	bl	35954 <k_mutex_unlock>
}
   35b06:	4628      	mov	r0, r5
   35b08:	b004      	add	sp, #16
   35b0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00035b0e <net_context_update_recv_wnd>:

int net_context_update_recv_wnd(struct net_context *context,
				s32_t delta)
{
   35b0e:	b570      	push	{r4, r5, r6, lr}
   35b10:	4605      	mov	r5, r0
   35b12:	460e      	mov	r6, r1
	if (IS_ENABLED(CONFIG_NET_OFFLOAD) &&
		net_if_is_ip_offloaded(net_context_get_iface(context))) {
		return 0;
	}

	k_mutex_lock(&context->lock, K_FOREVER);
   35b14:	f100 0408 	add.w	r4, r0, #8
   35b18:	4620      	mov	r0, r4
   35b1a:	f7ff ff38 	bl	3598e <k_mutex_lock.constprop.28>

	ret = net_tcp_update_recv_wnd(context, delta);
   35b1e:	4631      	mov	r1, r6
   35b20:	4628      	mov	r0, r5
   35b22:	f001 fa54 	bl	36fce <net_tcp_update_recv_wnd>
   35b26:	4605      	mov	r5, r0

	k_mutex_unlock(&context->lock);
   35b28:	4620      	mov	r0, r4
   35b2a:	f7ff ff13 	bl	35954 <k_mutex_unlock>

	return ret;
}
   35b2e:	4628      	mov	r0, r5
   35b30:	bd70      	pop	{r4, r5, r6, pc}

00035b32 <net_buf_frags_len>:
{
   35b32:	4603      	mov	r3, r0
	size_t bytes = 0;
   35b34:	2000      	movs	r0, #0
	while (buf) {
   35b36:	b903      	cbnz	r3, 35b3a <net_buf_frags_len+0x8>
	}

	return bytes;
}
   35b38:	4770      	bx	lr
		bytes += buf->len;
   35b3a:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   35b3c:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   35b3e:	4410      	add	r0, r2
		buf = buf->frags;
   35b40:	e7f9      	b.n	35b36 <net_buf_frags_len+0x4>

00035b42 <pkt_cursor_jump>:

static void pkt_cursor_jump(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;

	cursor->buf = cursor->buf->frags;
   35b42:	6943      	ldr	r3, [r0, #20]
	while (cursor->buf) {
		size_t len = write ? cursor->buf->size : cursor->buf->len;

		if (!len) {
			cursor->buf = cursor->buf->frags;
   35b44:	681b      	ldr	r3, [r3, #0]
   35b46:	6143      	str	r3, [r0, #20]
	while (cursor->buf) {
   35b48:	6943      	ldr	r3, [r0, #20]
   35b4a:	b90b      	cbnz	r3, 35b50 <pkt_cursor_jump+0xe>
	}

	if (cursor->buf) {
		cursor->pos = cursor->buf->data;
	} else {
		cursor->pos = NULL;
   35b4c:	6183      	str	r3, [r0, #24]
	}
}
   35b4e:	4770      	bx	lr
		size_t len = write ? cursor->buf->size : cursor->buf->len;
   35b50:	b121      	cbz	r1, 35b5c <pkt_cursor_jump+0x1a>
   35b52:	89da      	ldrh	r2, [r3, #14]
		if (!len) {
   35b54:	2a00      	cmp	r2, #0
   35b56:	d0f5      	beq.n	35b44 <pkt_cursor_jump+0x2>
		cursor->pos = cursor->buf->data;
   35b58:	689b      	ldr	r3, [r3, #8]
   35b5a:	e7f7      	b.n	35b4c <pkt_cursor_jump+0xa>
		size_t len = write ? cursor->buf->size : cursor->buf->len;
   35b5c:	899a      	ldrh	r2, [r3, #12]
   35b5e:	e7f9      	b.n	35b54 <pkt_cursor_jump+0x12>

00035b60 <pkt_cursor_advance>:
static void pkt_cursor_advance(struct net_pkt *pkt, bool write)
{
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (!cursor->buf) {
   35b60:	6943      	ldr	r3, [r0, #20]
{
   35b62:	b410      	push	{r4}
	if (!cursor->buf) {
   35b64:	b163      	cbz	r3, 35b80 <pkt_cursor_advance+0x20>
		return;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
   35b66:	b149      	cbz	r1, 35b7c <pkt_cursor_advance+0x1c>
   35b68:	89dc      	ldrh	r4, [r3, #14]
	if ((cursor->pos - cursor->buf->data) == len) {
   35b6a:	6982      	ldr	r2, [r0, #24]
   35b6c:	689b      	ldr	r3, [r3, #8]
   35b6e:	1ad2      	subs	r2, r2, r3
   35b70:	42a2      	cmp	r2, r4
   35b72:	d105      	bne.n	35b80 <pkt_cursor_advance+0x20>
		pkt_cursor_jump(pkt, write);
	}
}
   35b74:	f85d 4b04 	ldr.w	r4, [sp], #4
		pkt_cursor_jump(pkt, write);
   35b78:	f7ff bfe3 	b.w	35b42 <pkt_cursor_jump>
	len = write ? cursor->buf->size : cursor->buf->len;
   35b7c:	899c      	ldrh	r4, [r3, #12]
   35b7e:	e7f4      	b.n	35b6a <pkt_cursor_advance+0xa>
}
   35b80:	f85d 4b04 	ldr.w	r4, [sp], #4
   35b84:	4770      	bx	lr

00035b86 <pkt_cursor_update>:
	return pkt->overwrite;
   35b86:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d

static void pkt_cursor_update(struct net_pkt *pkt,
			      size_t length, bool write)
{
   35b8a:	b4f0      	push	{r4, r5, r6, r7}
	struct net_pkt_cursor *cursor = &pkt->cursor;
	size_t len;

	if (net_pkt_is_being_overwritten(pkt)) {
   35b8c:	f013 0601 	ands.w	r6, r3, #1
   35b90:	6945      	ldr	r5, [r0, #20]
   35b92:	d10f      	bne.n	35bb4 <pkt_cursor_update+0x2e>
		write = false;
	}

	len = write ? cursor->buf->size : cursor->buf->len;
   35b94:	b172      	cbz	r2, 35bb4 <pkt_cursor_update+0x2e>
   35b96:	89ef      	ldrh	r7, [r5, #14]
	if (length + (cursor->pos - cursor->buf->data) == len &&
   35b98:	6984      	ldr	r4, [r0, #24]
   35b9a:	68ab      	ldr	r3, [r5, #8]
   35b9c:	1ae3      	subs	r3, r4, r3
   35b9e:	440b      	add	r3, r1
   35ba0:	42bb      	cmp	r3, r7
   35ba2:	d10a      	bne.n	35bba <pkt_cursor_update+0x34>
   35ba4:	b116      	cbz	r6, 35bac <pkt_cursor_update+0x26>
	    !(net_pkt_is_being_overwritten(pkt) && len < cursor->buf->size)) {
   35ba6:	89eb      	ldrh	r3, [r5, #14]
   35ba8:	42bb      	cmp	r3, r7
   35baa:	d806      	bhi.n	35bba <pkt_cursor_update+0x34>
		pkt_cursor_jump(pkt, write);
	} else {
		cursor->pos += length;
	}
}
   35bac:	bcf0      	pop	{r4, r5, r6, r7}
		pkt_cursor_jump(pkt, write);
   35bae:	4611      	mov	r1, r2
   35bb0:	f7ff bfc7 	b.w	35b42 <pkt_cursor_jump>
	len = write ? cursor->buf->size : cursor->buf->len;
   35bb4:	89af      	ldrh	r7, [r5, #12]
   35bb6:	2200      	movs	r2, #0
   35bb8:	e7ee      	b.n	35b98 <pkt_cursor_update+0x12>
		cursor->pos += length;
   35bba:	440c      	add	r4, r1
   35bbc:	6184      	str	r4, [r0, #24]
}
   35bbe:	bcf0      	pop	{r4, r5, r6, r7}
   35bc0:	4770      	bx	lr

00035bc2 <pkt_estimate_headers_length.isra.19.part.20>:
		hdr_len += NET_IPV4H_LEN;
   35bc2:	2801      	cmp	r0, #1
   35bc4:	bf14      	ite	ne
   35bc6:	2000      	movne	r0, #0
   35bc8:	2014      	moveq	r0, #20
	if (IS_ENABLED(CONFIG_NET_TCP) && proto == IPPROTO_TCP) {
   35bca:	2906      	cmp	r1, #6
   35bcc:	d101      	bne.n	35bd2 <pkt_estimate_headers_length.isra.19.part.20+0x10>
		hdr_len += NET_TCPH_LEN + NET_TCP_MAX_OPT_SIZE;
   35bce:	301c      	adds	r0, #28
   35bd0:	4770      	bx	lr
	} else if (IS_ENABLED(CONFIG_NET_UDP) && proto == IPPROTO_UDP) {
   35bd2:	2911      	cmp	r1, #17
   35bd4:	d101      	bne.n	35bda <pkt_estimate_headers_length.isra.19.part.20+0x18>
		hdr_len += NET_UDPH_LEN;
   35bd6:	3008      	adds	r0, #8
   35bd8:	4770      	bx	lr
	} else if (proto == IPPROTO_ICMP || proto == IPPROTO_ICMPV6) {
   35bda:	2901      	cmp	r1, #1
   35bdc:	d001      	beq.n	35be2 <pkt_estimate_headers_length.isra.19.part.20+0x20>
   35bde:	293a      	cmp	r1, #58	; 0x3a
   35be0:	d100      	bne.n	35be4 <pkt_estimate_headers_length.isra.19.part.20+0x22>
		hdr_len += NET_ICMPH_LEN;
   35be2:	3004      	adds	r0, #4
}
   35be4:	4770      	bx	lr

00035be6 <net_pkt_cursor_operate>:

/* Internal function that does all operation (skip/read/write/memset) */
static int net_pkt_cursor_operate(struct net_pkt *pkt,
				  void *data, size_t length,
				  bool copy, bool write)
{
   35be6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   35bea:	4606      	mov	r6, r0
   35bec:	460f      	mov	r7, r1
   35bee:	4615      	mov	r5, r2
   35bf0:	4699      	mov	r9, r3
   35bf2:	f89d 8020 	ldrb.w	r8, [sp, #32]
	/* We use such variable to avoid lengthy lines */
	struct net_pkt_cursor *c_op = &pkt->cursor;

	while (c_op->buf && length) {
   35bf6:	6973      	ldr	r3, [r6, #20]
   35bf8:	2b00      	cmp	r3, #0
   35bfa:	d051      	beq.n	35ca0 <net_pkt_cursor_operate+0xba>
   35bfc:	b90d      	cbnz	r5, 35c02 <net_pkt_cursor_operate+0x1c>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
   35bfe:	4628      	mov	r0, r5
   35c00:	e00d      	b.n	35c1e <net_pkt_cursor_operate+0x38>
   35c02:	f896 303d 	ldrb.w	r3, [r6, #61]	; 0x3d
		pkt_cursor_advance(pkt, net_pkt_is_being_overwritten(pkt) ?
   35c06:	4630      	mov	r0, r6
   35c08:	f013 0f01 	tst.w	r3, #1
   35c0c:	bf0c      	ite	eq
   35c0e:	4641      	moveq	r1, r8
   35c10:	2100      	movne	r1, #0
   35c12:	f7ff ffa5 	bl	35b60 <pkt_cursor_advance>
		if (c_op->buf == NULL) {
   35c16:	6973      	ldr	r3, [r6, #20]
   35c18:	b91b      	cbnz	r3, 35c22 <net_pkt_cursor_operate+0x3c>
		return -ENOBUFS;
   35c1a:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   35c1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (write && !net_pkt_is_being_overwritten(pkt)) {
   35c22:	69b0      	ldr	r0, [r6, #24]
   35c24:	689c      	ldr	r4, [r3, #8]
   35c26:	1b04      	subs	r4, r0, r4
   35c28:	f1b8 0f00 	cmp.w	r8, #0
   35c2c:	d02d      	beq.n	35c8a <net_pkt_cursor_operate+0xa4>
   35c2e:	f896 203d 	ldrb.w	r2, [r6, #61]	; 0x3d
   35c32:	07d2      	lsls	r2, r2, #31
   35c34:	d429      	bmi.n	35c8a <net_pkt_cursor_operate+0xa4>
			d_len = c_op->buf->size - (c_op->pos - c_op->buf->data);
   35c36:	89db      	ldrh	r3, [r3, #14]
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
   35c38:	1b1c      	subs	r4, r3, r4
		if (!d_len) {
   35c3a:	2c00      	cmp	r4, #0
   35c3c:	d0ed      	beq.n	35c1a <net_pkt_cursor_operate+0x34>
		if (length < d_len) {
   35c3e:	42ac      	cmp	r4, r5
   35c40:	bf28      	it	cs
   35c42:	462c      	movcs	r4, r5
		if (copy) {
   35c44:	f1b9 0f00 	cmp.w	r9, #0
   35c48:	d023      	beq.n	35c92 <net_pkt_cursor_operate+0xac>
			memcpy(write ? c_op->pos : data,
   35c4a:	f1b8 0f00 	cmp.w	r8, #0
   35c4e:	d11e      	bne.n	35c8e <net_pkt_cursor_operate+0xa8>
   35c50:	4601      	mov	r1, r0
   35c52:	4638      	mov	r0, r7
   35c54:	4622      	mov	r2, r4
   35c56:	f003 f9bf 	bl	38fd8 <memcpy>
		if (write && !net_pkt_is_being_overwritten(pkt)) {
   35c5a:	f1b8 0f00 	cmp.w	r8, #0
   35c5e:	d008      	beq.n	35c72 <net_pkt_cursor_operate+0x8c>
   35c60:	f896 303d 	ldrb.w	r3, [r6, #61]	; 0x3d
   35c64:	07db      	lsls	r3, r3, #31
   35c66:	d404      	bmi.n	35c72 <net_pkt_cursor_operate+0x8c>
			net_buf_add(c_op->buf, len);
   35c68:	6970      	ldr	r0, [r6, #20]
   35c6a:	4621      	mov	r1, r4
   35c6c:	3008      	adds	r0, #8
   35c6e:	f7e6 f9b1 	bl	1bfd4 <net_buf_simple_add>
		pkt_cursor_update(pkt, len, write);
   35c72:	4642      	mov	r2, r8
   35c74:	4621      	mov	r1, r4
   35c76:	4630      	mov	r0, r6
   35c78:	f7ff ff85 	bl	35b86 <pkt_cursor_update>
		if (copy && data) {
   35c7c:	f1b9 0f00 	cmp.w	r9, #0
   35c80:	d001      	beq.n	35c86 <net_pkt_cursor_operate+0xa0>
   35c82:	b107      	cbz	r7, 35c86 <net_pkt_cursor_operate+0xa0>
			data = (u8_t *) data + len;
   35c84:	4427      	add	r7, r4
		length -= len;
   35c86:	1b2d      	subs	r5, r5, r4
   35c88:	e7b5      	b.n	35bf6 <net_pkt_cursor_operate+0x10>
			d_len = c_op->buf->len - (c_op->pos - c_op->buf->data);
   35c8a:	899b      	ldrh	r3, [r3, #12]
   35c8c:	e7d4      	b.n	35c38 <net_pkt_cursor_operate+0x52>
   35c8e:	4639      	mov	r1, r7
   35c90:	e7e0      	b.n	35c54 <net_pkt_cursor_operate+0x6e>
		} else if (data) {
   35c92:	2f00      	cmp	r7, #0
   35c94:	d0e1      	beq.n	35c5a <net_pkt_cursor_operate+0x74>
__ssp_bos_icheck3(memset, void *, int)
   35c96:	4622      	mov	r2, r4
   35c98:	6839      	ldr	r1, [r7, #0]
   35c9a:	f003 f9d7 	bl	3904c <memset>
   35c9e:	e7dc      	b.n	35c5a <net_pkt_cursor_operate+0x74>
	if (length) {
   35ca0:	2d00      	cmp	r5, #0
   35ca2:	d0ac      	beq.n	35bfe <net_pkt_cursor_operate+0x18>
   35ca4:	e7b9      	b.n	35c1a <net_pkt_cursor_operate+0x34>

00035ca6 <net_pkt_ref>:
{
   35ca6:	b510      	push	{r4, lr}
		ref = pkt ? atomic_get(&pkt->atomic_ref) : 0;
   35ca8:	f100 0324 	add.w	r3, r0, #36	; 0x24
   35cac:	b170      	cbz	r0, 35ccc <net_pkt_ref+0x26>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   35cae:	e8d3 2faf 	lda	r2, [r3]
		if (!ref) {
   35cb2:	b15a      	cbz	r2, 35ccc <net_pkt_ref+0x26>
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref + 1));
   35cb4:	1c51      	adds	r1, r2, #1
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   35cb6:	e8d3 4fef 	ldaex	r4, [r3]
   35cba:	4294      	cmp	r4, r2
   35cbc:	d104      	bne.n	35cc8 <net_pkt_ref+0x22>
   35cbe:	e8c3 1fec 	stlex	ip, r1, [r3]
   35cc2:	f1bc 0f00 	cmp.w	ip, #0
   35cc6:	d1f6      	bne.n	35cb6 <net_pkt_ref+0x10>
   35cc8:	d1f0      	bne.n	35cac <net_pkt_ref+0x6>
}
   35cca:	bd10      	pop	{r4, pc}
			return NULL;
   35ccc:	2000      	movs	r0, #0
   35cce:	e7fc      	b.n	35cca <net_pkt_ref+0x24>

00035cd0 <net_pkt_frag_unref>:
	if (!frag) {
   35cd0:	b108      	cbz	r0, 35cd6 <net_pkt_frag_unref+0x6>
	net_buf_unref(frag);
   35cd2:	f7e6 b8ef 	b.w	1beb4 <net_buf_unref>
}
   35cd6:	4770      	bx	lr

00035cd8 <net_pkt_unref>:
{
   35cd8:	b507      	push	{r0, r1, r2, lr}
   35cda:	9001      	str	r0, [sp, #4]
	if (!pkt) {
   35cdc:	b1e8      	cbz	r0, 35d1a <net_pkt_unref+0x42>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   35cde:	9b01      	ldr	r3, [sp, #4]
   35ce0:	3324      	adds	r3, #36	; 0x24
   35ce2:	e8d3 3faf 	lda	r3, [r3]
		if (!ref) {
   35ce6:	b1c3      	cbz	r3, 35d1a <net_pkt_unref+0x42>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   35ce8:	9a01      	ldr	r2, [sp, #4]
	} while (!atomic_cas(&pkt->atomic_ref, ref, ref - 1));
   35cea:	1e59      	subs	r1, r3, #1
   35cec:	3224      	adds	r2, #36	; 0x24
   35cee:	e8d2 0fef 	ldaex	r0, [r2]
   35cf2:	4298      	cmp	r0, r3
   35cf4:	d104      	bne.n	35d00 <net_pkt_unref+0x28>
   35cf6:	e8c2 1fec 	stlex	ip, r1, [r2]
   35cfa:	f1bc 0f00 	cmp.w	ip, #0
   35cfe:	d1f6      	bne.n	35cee <net_pkt_unref+0x16>
   35d00:	d1ed      	bne.n	35cde <net_pkt_unref+0x6>
	if (ref > 1) {
   35d02:	2b01      	cmp	r3, #1
   35d04:	dc09      	bgt.n	35d1a <net_pkt_unref+0x42>
	if (pkt->frags) {
   35d06:	9b01      	ldr	r3, [sp, #4]
   35d08:	6918      	ldr	r0, [r3, #16]
   35d0a:	b108      	cbz	r0, 35d10 <net_pkt_unref+0x38>
		net_pkt_frag_unref(pkt->frags);
   35d0c:	f7ff ffe0 	bl	35cd0 <net_pkt_frag_unref>
	k_mem_slab_free(pkt->slab, (void **)&pkt);
   35d10:	9b01      	ldr	r3, [sp, #4]
   35d12:	a901      	add	r1, sp, #4
   35d14:	68d8      	ldr	r0, [r3, #12]
   35d16:	f7f6 fa81 	bl	2c21c <k_mem_slab_free>
}
   35d1a:	b003      	add	sp, #12
   35d1c:	f85d fb04 	ldr.w	pc, [sp], #4

00035d20 <net_pkt_available_buffer>:
{
   35d20:	b508      	push	{r3, lr}
	if (!pkt) {
   35d22:	b130      	cbz	r0, 35d32 <net_pkt_available_buffer+0x12>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
   35d24:	6900      	ldr	r0, [r0, #16]
	size_t size = 0;
   35d26:	2100      	movs	r1, #0
	struct net_buf *buf = pkt->buffer;
   35d28:	4603      	mov	r3, r0
	while (buf) {
   35d2a:	b91b      	cbnz	r3, 35d34 <net_pkt_available_buffer+0x14>
	return net_buf_frags_len(pkt->frags);
   35d2c:	f7ff ff01 	bl	35b32 <net_buf_frags_len>
	return pkt_get_size(pkt) - net_pkt_get_len(pkt);
   35d30:	1a08      	subs	r0, r1, r0
}
   35d32:	bd08      	pop	{r3, pc}
		size += buf->size;
   35d34:	89da      	ldrh	r2, [r3, #14]
		buf = buf->frags;
   35d36:	681b      	ldr	r3, [r3, #0]
		size += buf->size;
   35d38:	4411      	add	r1, r2
		buf = buf->frags;
   35d3a:	e7f6      	b.n	35d2a <net_pkt_available_buffer+0xa>

00035d3c <net_pkt_available_payload_buffer>:
{
   35d3c:	b538      	push	{r3, r4, r5, lr}
	if (!pkt) {
   35d3e:	4605      	mov	r5, r0
   35d40:	b198      	cbz	r0, 35d6a <net_pkt_available_payload_buffer+0x2e>
	return pkt->family;
   35d42:	f890 303f 	ldrb.w	r3, [r0, #63]	; 0x3f
	hdr_len = pkt_estimate_headers_length(pkt, net_pkt_family(pkt), proto);
   35d46:	f3c3 0042 	ubfx	r0, r3, #1, #3
	if (family == AF_UNSPEC) {
   35d4a:	b108      	cbz	r0, 35d50 <net_pkt_available_payload_buffer+0x14>
   35d4c:	f7ff ff39 	bl	35bc2 <pkt_estimate_headers_length.isra.19.part.20>
		return  0;
   35d50:	4604      	mov	r4, r0
	return net_buf_frags_len(pkt->frags);
   35d52:	6928      	ldr	r0, [r5, #16]
   35d54:	f7ff feed 	bl	35b32 <net_buf_frags_len>
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
   35d58:	42a0      	cmp	r0, r4
   35d5a:	bf38      	it	cc
   35d5c:	1a24      	subcc	r4, r4, r0
	len = net_pkt_available_buffer(pkt) - hdr_len;
   35d5e:	4628      	mov	r0, r5
	hdr_len = hdr_len <= len ? 0 : hdr_len - len;
   35d60:	bf28      	it	cs
   35d62:	2400      	movcs	r4, #0
	len = net_pkt_available_buffer(pkt) - hdr_len;
   35d64:	f7ff ffdc 	bl	35d20 <net_pkt_available_buffer>
   35d68:	1b00      	subs	r0, r0, r4
}
   35d6a:	bd38      	pop	{r3, r4, r5, pc}

00035d6c <net_pkt_trim_buffer>:
{
   35d6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   35d6e:	4605      	mov	r5, r0
	buf = pkt->buffer;
   35d70:	6900      	ldr	r0, [r0, #16]
			buf->frags = NULL;
   35d72:	2700      	movs	r7, #0
	prev = buf;
   35d74:	4604      	mov	r4, r0
	while (buf) {
   35d76:	b900      	cbnz	r0, 35d7a <net_pkt_trim_buffer+0xe>
}
   35d78:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (!buf->len) {
   35d7a:	8983      	ldrh	r3, [r0, #12]
		struct net_buf *next = buf->frags;
   35d7c:	6806      	ldr	r6, [r0, #0]
		if (!buf->len) {
   35d7e:	b93b      	cbnz	r3, 35d90 <net_pkt_trim_buffer+0x24>
			if (buf == pkt->buffer) {
   35d80:	692b      	ldr	r3, [r5, #16]
   35d82:	4283      	cmp	r3, r0
   35d84:	d107      	bne.n	35d96 <net_pkt_trim_buffer+0x2a>
				pkt->buffer = next;
   35d86:	612e      	str	r6, [r5, #16]
			buf->frags = NULL;
   35d88:	6007      	str	r7, [r0, #0]
			net_buf_unref(buf);
   35d8a:	f7e6 f893 	bl	1beb4 <net_buf_unref>
   35d8e:	4620      	mov	r0, r4
   35d90:	4604      	mov	r4, r0
   35d92:	4630      	mov	r0, r6
   35d94:	e7ef      	b.n	35d76 <net_pkt_trim_buffer+0xa>
			} else if (buf == prev->frags) {
   35d96:	6823      	ldr	r3, [r4, #0]
   35d98:	4283      	cmp	r3, r0
				prev->frags = next;
   35d9a:	bf08      	it	eq
   35d9c:	6026      	streq	r6, [r4, #0]
   35d9e:	e7f3      	b.n	35d88 <net_pkt_trim_buffer+0x1c>

00035da0 <net_pkt_cursor_init>:
	pkt->cursor.buf = pkt->buffer;
   35da0:	6903      	ldr	r3, [r0, #16]
   35da2:	6143      	str	r3, [r0, #20]
	if (pkt->cursor.buf) {
   35da4:	b103      	cbz	r3, 35da8 <net_pkt_cursor_init+0x8>
		pkt->cursor.pos = pkt->cursor.buf->data;
   35da6:	689b      	ldr	r3, [r3, #8]
   35da8:	6183      	str	r3, [r0, #24]
}
   35daa:	4770      	bx	lr

00035dac <pkt_alloc>:
{
   35dac:	b537      	push	{r0, r1, r2, r4, r5, lr}
   35dae:	460d      	mov	r5, r1
   35db0:	4604      	mov	r4, r0
	if (k_is_in_isr()) {
   35db2:	f002 ffc6 	bl	38d42 <k_is_in_isr>
   35db6:	2800      	cmp	r0, #0
	ret = k_mem_slab_alloc(slab, (void **)&pkt, timeout);
   35db8:	a901      	add	r1, sp, #4
   35dba:	bf0c      	ite	eq
   35dbc:	462a      	moveq	r2, r5
   35dbe:	2200      	movne	r2, #0
   35dc0:	4620      	mov	r0, r4
   35dc2:	f7f6 f9c7 	bl	2c154 <k_mem_slab_alloc>
	if (ret) {
   35dc6:	4601      	mov	r1, r0
   35dc8:	b960      	cbnz	r0, 35de4 <pkt_alloc+0x38>
   35dca:	2244      	movs	r2, #68	; 0x44
   35dcc:	9801      	ldr	r0, [sp, #4]
   35dce:	f003 f93d 	bl	3904c <memset>
	pkt->atomic_ref = ATOMIC_INIT(1);
   35dd2:	2301      	movs	r3, #1
   35dd4:	9801      	ldr	r0, [sp, #4]
   35dd6:	6243      	str	r3, [r0, #36]	; 0x24
	pkt->slab = slab;
   35dd8:	60c4      	str	r4, [r0, #12]
	net_pkt_cursor_init(pkt);
   35dda:	f7ff ffe1 	bl	35da0 <net_pkt_cursor_init>
	return pkt;
   35dde:	9801      	ldr	r0, [sp, #4]
}
   35de0:	b003      	add	sp, #12
   35de2:	bd30      	pop	{r4, r5, pc}
		return NULL;
   35de4:	2000      	movs	r0, #0
   35de6:	e7fb      	b.n	35de0 <pkt_alloc+0x34>

00035de8 <pkt_alloc_on_iface>:
{
   35de8:	b510      	push	{r4, lr}
   35dea:	460c      	mov	r4, r1
	pkt = pkt_alloc(slab, timeout);
   35dec:	4611      	mov	r1, r2
   35dee:	f7ff ffdd 	bl	35dac <pkt_alloc>
	if (pkt) {
   35df2:	b148      	cbz	r0, 35e08 <pkt_alloc_on_iface+0x20>
	pkt->iface = iface;
   35df4:	6204      	str	r4, [r0, #32]
	if (iface) {
   35df6:	b13c      	cbz	r4, 35e08 <pkt_alloc_on_iface+0x20>
		pkt->lladdr_src.type = net_if_get_link_addr(iface)->type;
   35df8:	6823      	ldr	r3, [r4, #0]
   35dfa:	7d5b      	ldrb	r3, [r3, #21]
   35dfc:	f880 302d 	strb.w	r3, [r0, #45]	; 0x2d
		pkt->lladdr_dst.type = net_if_get_link_addr(iface)->type;
   35e00:	6823      	ldr	r3, [r4, #0]
   35e02:	7d5b      	ldrb	r3, [r3, #21]
   35e04:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
}
   35e08:	bd10      	pop	{r4, pc}

00035e0a <net_pkt_append_buffer>:
	if (!pkt->buffer) {
   35e0a:	6903      	ldr	r3, [r0, #16]
{
   35e0c:	b510      	push	{r4, lr}
   35e0e:	4602      	mov	r2, r0
   35e10:	460c      	mov	r4, r1
	if (!pkt->buffer) {
   35e12:	b923      	cbnz	r3, 35e1e <net_pkt_append_buffer+0x14>
}
   35e14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		pkt->buffer = buffer;
   35e18:	6111      	str	r1, [r2, #16]
		net_pkt_cursor_init(pkt);
   35e1a:	f7ff bfc1 	b.w	35da0 <net_pkt_cursor_init>
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   35e1e:	4618      	mov	r0, r3
   35e20:	f7e6 f88e 	bl	1bf40 <net_buf_frag_last>
   35e24:	4621      	mov	r1, r4
}
   35e26:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		net_buf_frag_insert(net_buf_frag_last(pkt->buffer), buffer);
   35e2a:	f7e6 b8a5 	b.w	1bf78 <net_buf_frag_insert>

00035e2e <pkt_alloc_with_buffer>:
{
   35e2e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   35e32:	9c0d      	ldr	r4, [sp, #52]	; 0x34
   35e34:	4682      	mov	sl, r0
	u64_t end = z_timeout_end_calc(timeout);
   35e36:	4620      	mov	r0, r4
{
   35e38:	468b      	mov	fp, r1
   35e3a:	4690      	mov	r8, r2
   35e3c:	9301      	str	r3, [sp, #4]
	u64_t end = z_timeout_end_calc(timeout);
   35e3e:	f002 ffff 	bl	38e40 <z_timeout_end_calc>
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
   35e42:	4622      	mov	r2, r4
	u64_t end = z_timeout_end_calc(timeout);
   35e44:	4605      	mov	r5, r0
   35e46:	4689      	mov	r9, r1
	pkt = pkt_alloc_on_iface(slab, iface, timeout);
   35e48:	4650      	mov	r0, sl
   35e4a:	4659      	mov	r1, fp
   35e4c:	f7ff ffcc 	bl	35de8 <pkt_alloc_on_iface>
	if (!pkt) {
   35e50:	4682      	mov	sl, r0
   35e52:	b358      	cbz	r0, 35eac <pkt_alloc_with_buffer+0x7e>
	pkt->family = family;
   35e54:	f890 203f 	ldrb.w	r2, [r0, #63]	; 0x3f
   35e58:	9b01      	ldr	r3, [sp, #4]
   35e5a:	f363 0243 	bfi	r2, r3, #1, #3
	if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
   35e5e:	1c63      	adds	r3, r4, #1
   35e60:	2b01      	cmp	r3, #1
   35e62:	f880 203f 	strb.w	r2, [r0, #63]	; 0x3f
   35e66:	d914      	bls.n	35e92 <pkt_alloc_with_buffer+0x64>
		s64_t remaining = end - z_tick_get();
   35e68:	f7f8 ff48 	bl	2ecfc <z_tick_get>
   35e6c:	1a2e      	subs	r6, r5, r0
   35e6e:	eb69 0701 	sbc.w	r7, r9, r1
		if (remaining <= 0) {
   35e72:	2e01      	cmp	r6, #1
   35e74:	f177 0300 	sbcs.w	r3, r7, #0
			return (u32_t)((t * to_hz + off) / from_hz);
   35e78:	bfa3      	ittte	ge
   35e7a:	f647 72ff 	movwge	r2, #32767	; 0x7fff
   35e7e:	2300      	movge	r3, #0
   35e80:	f44f 717a 	movge.w	r1, #1000	; 0x3e8
			timeout = K_NO_WAIT;
   35e84:	2400      	movlt	r4, #0
   35e86:	bfa2      	ittt	ge
   35e88:	fbe1 2306 	umlalge	r2, r3, r1, r6
   35e8c:	0bd4      	lsrge	r4, r2, #15
   35e8e:	ea44 4443 	orrge.w	r4, r4, r3, lsl #17
	ret = net_pkt_alloc_buffer(pkt, size, proto, timeout);
   35e92:	4623      	mov	r3, r4
   35e94:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   35e98:	4641      	mov	r1, r8
   35e9a:	4650      	mov	r0, sl
   35e9c:	f7e7 f9bc 	bl	1d218 <net_pkt_alloc_buffer>
	if (ret) {
   35ea0:	b120      	cbz	r0, 35eac <pkt_alloc_with_buffer+0x7e>
		net_pkt_unref(pkt);
   35ea2:	4650      	mov	r0, sl
   35ea4:	f7ff ff18 	bl	35cd8 <net_pkt_unref>
		return NULL;
   35ea8:	f04f 0a00 	mov.w	sl, #0
}
   35eac:	4650      	mov	r0, sl
   35eae:	b003      	add	sp, #12
   35eb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00035eb4 <net_pkt_skip>:

int net_pkt_skip(struct net_pkt *pkt, size_t skip)
{
	NET_DBG("pkt %p skip %zu", pkt, skip);

	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   35eb4:	2301      	movs	r3, #1
{
   35eb6:	b507      	push	{r0, r1, r2, lr}
	return net_pkt_cursor_operate(pkt, NULL, skip, false, true);
   35eb8:	9300      	str	r3, [sp, #0]
   35eba:	2300      	movs	r3, #0
   35ebc:	460a      	mov	r2, r1
   35ebe:	4619      	mov	r1, r3
   35ec0:	f7ff fe91 	bl	35be6 <net_pkt_cursor_operate>
}
   35ec4:	b003      	add	sp, #12
   35ec6:	f85d fb04 	ldr.w	pc, [sp], #4

00035eca <net_pkt_memset>:

int net_pkt_memset(struct net_pkt *pkt, int byte, size_t amount)
{
   35eca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	NET_DBG("pkt %p byte %d amount %zu", pkt, byte, amount);

	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
   35ecc:	2301      	movs	r3, #1
{
   35ece:	9103      	str	r1, [sp, #12]
	return net_pkt_cursor_operate(pkt, &byte, amount, false, true);
   35ed0:	9300      	str	r3, [sp, #0]
   35ed2:	a903      	add	r1, sp, #12
   35ed4:	2300      	movs	r3, #0
   35ed6:	f7ff fe86 	bl	35be6 <net_pkt_cursor_operate>
}
   35eda:	b005      	add	sp, #20
   35edc:	f85d fb04 	ldr.w	pc, [sp], #4

00035ee0 <net_pkt_read>:

int net_pkt_read(struct net_pkt *pkt, void *data, size_t length)
{
	NET_DBG("pkt %p data %p length %zu", pkt, data, length);

	return net_pkt_cursor_operate(pkt, data, length, true, false);
   35ee0:	2300      	movs	r3, #0
{
   35ee2:	b507      	push	{r0, r1, r2, lr}
	return net_pkt_cursor_operate(pkt, data, length, true, false);
   35ee4:	9300      	str	r3, [sp, #0]
   35ee6:	2301      	movs	r3, #1
   35ee8:	f7ff fe7d 	bl	35be6 <net_pkt_cursor_operate>
}
   35eec:	b003      	add	sp, #12
   35eee:	f85d fb04 	ldr.w	pc, [sp], #4

00035ef2 <net_pkt_read_be16>:

int net_pkt_read_be16(struct net_pkt *pkt, u16_t *data)
{
   35ef2:	b513      	push	{r0, r1, r4, lr}
	u8_t d16[2];
	int ret;

	ret = net_pkt_read(pkt, d16, sizeof(u16_t));
   35ef4:	2202      	movs	r2, #2
{
   35ef6:	460c      	mov	r4, r1
	ret = net_pkt_read(pkt, d16, sizeof(u16_t));
   35ef8:	a901      	add	r1, sp, #4
   35efa:	f7ff fff1 	bl	35ee0 <net_pkt_read>

	*data = d16[0] << 8 | d16[1];
   35efe:	f89d 2004 	ldrb.w	r2, [sp, #4]
   35f02:	f89d 3005 	ldrb.w	r3, [sp, #5]
   35f06:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   35f0a:	8023      	strh	r3, [r4, #0]

	return ret;
}
   35f0c:	b002      	add	sp, #8
   35f0e:	bd10      	pop	{r4, pc}

00035f10 <net_pkt_copy>:
}

int net_pkt_copy(struct net_pkt *pkt_dst,
		 struct net_pkt *pkt_src,
		 size_t length)
{
   35f10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   35f12:	4606      	mov	r6, r0
   35f14:	460f      	mov	r7, r1
   35f16:	4614      	mov	r4, r2
	struct net_pkt_cursor *c_dst = &pkt_dst->cursor;
	struct net_pkt_cursor *c_src = &pkt_src->cursor;

	while (c_dst->buf && c_src->buf && length) {
   35f18:	6973      	ldr	r3, [r6, #20]
   35f1a:	2b00      	cmp	r3, #0
   35f1c:	d041      	beq.n	35fa2 <net_pkt_copy+0x92>
   35f1e:	697b      	ldr	r3, [r7, #20]
   35f20:	2b00      	cmp	r3, #0
   35f22:	d03e      	beq.n	35fa2 <net_pkt_copy+0x92>
   35f24:	b90c      	cbnz	r4, 35f2a <net_pkt_copy+0x1a>
	if (length) {
		NET_DBG("Still some length to go %zu", length);
		return -ENOBUFS;
	}

	return 0;
   35f26:	4620      	mov	r0, r4
   35f28:	e021      	b.n	35f6e <net_pkt_copy+0x5e>
		pkt_cursor_advance(pkt_dst, true);
   35f2a:	2101      	movs	r1, #1
   35f2c:	4630      	mov	r0, r6
   35f2e:	f7ff fe17 	bl	35b60 <pkt_cursor_advance>
		pkt_cursor_advance(pkt_src, false);
   35f32:	2100      	movs	r1, #0
   35f34:	4638      	mov	r0, r7
   35f36:	f7ff fe13 	bl	35b60 <pkt_cursor_advance>
		if (!c_dst->buf || !c_src->buf) {
   35f3a:	6972      	ldr	r2, [r6, #20]
   35f3c:	b1aa      	cbz	r2, 35f6a <net_pkt_copy+0x5a>
   35f3e:	697b      	ldr	r3, [r7, #20]
   35f40:	b19b      	cbz	r3, 35f6a <net_pkt_copy+0x5a>
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   35f42:	899d      	ldrh	r5, [r3, #12]
   35f44:	69b9      	ldr	r1, [r7, #24]
   35f46:	689b      	ldr	r3, [r3, #8]
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   35f48:	69b0      	ldr	r0, [r6, #24]
		s_len = c_src->buf->len - (c_src->pos - c_src->buf->data);
   35f4a:	1acb      	subs	r3, r1, r3
   35f4c:	1aed      	subs	r5, r5, r3
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   35f4e:	89d3      	ldrh	r3, [r2, #14]
   35f50:	6892      	ldr	r2, [r2, #8]
		if (length < s_len && length < d_len) {
   35f52:	42ac      	cmp	r4, r5
		d_len = c_dst->buf->size - (c_dst->pos - c_dst->buf->data);
   35f54:	eba0 0202 	sub.w	r2, r0, r2
   35f58:	eba3 0302 	sub.w	r3, r3, r2
		if (length < s_len && length < d_len) {
   35f5c:	d201      	bcs.n	35f62 <net_pkt_copy+0x52>
   35f5e:	429c      	cmp	r4, r3
   35f60:	d306      	bcc.n	35f70 <net_pkt_copy+0x60>
			if (d_len < s_len) {
   35f62:	429d      	cmp	r5, r3
   35f64:	bf28      	it	cs
   35f66:	461d      	movcs	r5, r3
		if (!len) {
   35f68:	b91d      	cbnz	r5, 35f72 <net_pkt_copy+0x62>
		return -ENOBUFS;
   35f6a:	f06f 0068 	mvn.w	r0, #104	; 0x68
}
   35f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   35f70:	4625      	mov	r5, r4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   35f72:	462a      	mov	r2, r5
   35f74:	f003 f830 	bl	38fd8 <memcpy>
	return pkt->overwrite;
   35f78:	f896 303d 	ldrb.w	r3, [r6, #61]	; 0x3d
		if (!net_pkt_is_being_overwritten(pkt_dst)) {
   35f7c:	07db      	lsls	r3, r3, #31
   35f7e:	d404      	bmi.n	35f8a <net_pkt_copy+0x7a>
			net_buf_add(c_dst->buf, len);
   35f80:	6970      	ldr	r0, [r6, #20]
   35f82:	4629      	mov	r1, r5
   35f84:	3008      	adds	r0, #8
   35f86:	f7e6 f825 	bl	1bfd4 <net_buf_simple_add>
		pkt_cursor_update(pkt_dst, len, true);
   35f8a:	2201      	movs	r2, #1
   35f8c:	4629      	mov	r1, r5
   35f8e:	4630      	mov	r0, r6
   35f90:	f7ff fdf9 	bl	35b86 <pkt_cursor_update>
		pkt_cursor_update(pkt_src, len, false);
   35f94:	2200      	movs	r2, #0
   35f96:	4629      	mov	r1, r5
   35f98:	4638      	mov	r0, r7
   35f9a:	f7ff fdf4 	bl	35b86 <pkt_cursor_update>
		length -= len;
   35f9e:	1b64      	subs	r4, r4, r5
   35fa0:	e7ba      	b.n	35f18 <net_pkt_copy+0x8>
	if (length) {
   35fa2:	2c00      	cmp	r4, #0
   35fa4:	d0bf      	beq.n	35f26 <net_pkt_copy+0x16>
   35fa6:	e7e0      	b.n	35f6a <net_pkt_copy+0x5a>

00035fa8 <net_pkt_remaining_data>:
size_t net_pkt_remaining_data(struct net_pkt *pkt)
{
	struct net_buf *buf;
	size_t data_length;

	if (!pkt || !pkt->cursor.buf || !pkt->cursor.pos) {
   35fa8:	b170      	cbz	r0, 35fc8 <net_pkt_remaining_data+0x20>
   35faa:	6943      	ldr	r3, [r0, #20]
   35fac:	b15b      	cbz	r3, 35fc6 <net_pkt_remaining_data+0x1e>
   35fae:	6980      	ldr	r0, [r0, #24]
   35fb0:	b150      	cbz	r0, 35fc8 <net_pkt_remaining_data+0x20>
		return 0;
	}

	buf = pkt->cursor.buf;
	data_length = buf->len - (pkt->cursor.pos - buf->data);
   35fb2:	6899      	ldr	r1, [r3, #8]
   35fb4:	899a      	ldrh	r2, [r3, #12]
   35fb6:	1a40      	subs	r0, r0, r1
   35fb8:	1a10      	subs	r0, r2, r0

	buf = buf->frags;
	while (buf) {
		data_length += buf->len;
		buf = buf->frags;
   35fba:	681b      	ldr	r3, [r3, #0]
	while (buf) {
   35fbc:	b903      	cbnz	r3, 35fc0 <net_pkt_remaining_data+0x18>
   35fbe:	4770      	bx	lr
		data_length += buf->len;
   35fc0:	899a      	ldrh	r2, [r3, #12]
   35fc2:	4410      	add	r0, r2
   35fc4:	e7f9      	b.n	35fba <net_pkt_remaining_data+0x12>
		return 0;
   35fc6:	4618      	mov	r0, r3
	}

	return data_length;
}
   35fc8:	4770      	bx	lr

00035fca <net_pkt_update_length>:

int net_pkt_update_length(struct net_pkt *pkt, size_t length)
{
	struct net_buf *buf;

	for (buf = pkt->buffer; buf; buf = buf->frags) {
   35fca:	6903      	ldr	r3, [r0, #16]
   35fcc:	b92b      	cbnz	r3, 35fda <net_pkt_update_length+0x10>
			buf->len = length;
			length = 0;
		}
	}

	return !length ? 0 : -EINVAL;
   35fce:	2900      	cmp	r1, #0
}
   35fd0:	bf14      	ite	ne
   35fd2:	f06f 0015 	mvnne.w	r0, #21
   35fd6:	2000      	moveq	r0, #0
   35fd8:	4770      	bx	lr
		if (buf->len < length) {
   35fda:	899a      	ldrh	r2, [r3, #12]
   35fdc:	428a      	cmp	r2, r1
			buf->len = length;
   35fde:	bf2a      	itet	cs
   35fe0:	8199      	strhcs	r1, [r3, #12]
			length -= buf->len;
   35fe2:	1a89      	subcc	r1, r1, r2
			length = 0;
   35fe4:	2100      	movcs	r1, #0
	for (buf = pkt->buffer; buf; buf = buf->frags) {
   35fe6:	681b      	ldr	r3, [r3, #0]
   35fe8:	e7f0      	b.n	35fcc <net_pkt_update_length+0x2>

00035fea <net_pkt_get_current_offset>:
u16_t net_pkt_get_current_offset(struct net_pkt *pkt)
{
	struct net_buf *buf = pkt->buffer;
	u16_t offset;

	if (!pkt->cursor.buf || !pkt->cursor.pos) {
   35fea:	6941      	ldr	r1, [r0, #20]
{
   35fec:	b510      	push	{r4, lr}
	if (!pkt->cursor.buf || !pkt->cursor.pos) {
   35fee:	b179      	cbz	r1, 36010 <net_pkt_get_current_offset+0x26>
   35ff0:	6983      	ldr	r3, [r0, #24]
   35ff2:	b17b      	cbz	r3, 36014 <net_pkt_get_current_offset+0x2a>
		return 0;
	}

	offset = 0U;
   35ff4:	2200      	movs	r2, #0
	struct net_buf *buf = pkt->buffer;
   35ff6:	6904      	ldr	r4, [r0, #16]

	while (buf != pkt->cursor.buf) {
   35ff8:	42a1      	cmp	r1, r4
   35ffa:	d104      	bne.n	36006 <net_pkt_get_current_offset+0x1c>
		offset += buf->len;
		buf = buf->frags;
	}

	offset += pkt->cursor.pos - buf->data;
   35ffc:	6888      	ldr	r0, [r1, #8]
   35ffe:	1a1b      	subs	r3, r3, r0
   36000:	4413      	add	r3, r2
   36002:	b298      	uxth	r0, r3

	return offset;
}
   36004:	bd10      	pop	{r4, pc}
		offset += buf->len;
   36006:	89a0      	ldrh	r0, [r4, #12]
		buf = buf->frags;
   36008:	6824      	ldr	r4, [r4, #0]
		offset += buf->len;
   3600a:	4402      	add	r2, r0
   3600c:	b292      	uxth	r2, r2
		buf = buf->frags;
   3600e:	e7f3      	b.n	35ff8 <net_pkt_get_current_offset+0xe>
		return 0;
   36010:	4608      	mov	r0, r1
   36012:	e7f7      	b.n	36004 <net_pkt_get_current_offset+0x1a>
   36014:	4618      	mov	r0, r3
   36016:	e7f5      	b.n	36004 <net_pkt_get_current_offset+0x1a>

00036018 <net_pkt_clone>:
{
   36018:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   3601c:	460c      	mov	r4, r1
   3601e:	4605      	mov	r5, r0
	size_t cursor_offset = net_pkt_get_current_offset(pkt);
   36020:	f7ff ffe3 	bl	35fea <net_pkt_get_current_offset>
   36024:	4680      	mov	r8, r0
	return net_buf_frags_len(pkt->frags);
   36026:	6928      	ldr	r0, [r5, #16]
   36028:	f7ff fd83 	bl	35b32 <net_buf_frags_len>
	clone_pkt = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
   3602c:	2300      	movs	r3, #0
   3602e:	9400      	str	r4, [sp, #0]
   36030:	4601      	mov	r1, r0
   36032:	461a      	mov	r2, r3
   36034:	6a28      	ldr	r0, [r5, #32]
   36036:	f7e7 f9b1 	bl	1d39c <net_pkt_alloc_with_buffer>
	if (!clone_pkt) {
   3603a:	4604      	mov	r4, r0
   3603c:	b198      	cbz	r0, 36066 <net_pkt_clone+0x4e>
	backup->pos = pkt->cursor.pos;
   3603e:	e9d5 7605 	ldrd	r7, r6, [r5, #20]
	net_pkt_cursor_init(pkt);
   36042:	4628      	mov	r0, r5
   36044:	f7ff feac 	bl	35da0 <net_pkt_cursor_init>
	return net_buf_frags_len(pkt->frags);
   36048:	6928      	ldr	r0, [r5, #16]
   3604a:	f7ff fd72 	bl	35b32 <net_buf_frags_len>
	if (net_pkt_copy(clone_pkt, pkt, net_pkt_get_len(pkt))) {
   3604e:	4629      	mov	r1, r5
   36050:	4602      	mov	r2, r0
   36052:	4620      	mov	r0, r4
   36054:	f7ff ff5c 	bl	35f10 <net_pkt_copy>
   36058:	b148      	cbz	r0, 3606e <net_pkt_clone+0x56>
		net_pkt_unref(clone_pkt);
   3605a:	4620      	mov	r0, r4
		return NULL;
   3605c:	2400      	movs	r4, #0
		net_pkt_unref(clone_pkt);
   3605e:	f7ff fe3b 	bl	35cd8 <net_pkt_unref>
	pkt->cursor.pos = backup->pos;
   36062:	e9c5 7605 	strd	r7, r6, [r5, #20]
}
   36066:	4620      	mov	r0, r4
   36068:	b002      	add	sp, #8
   3606a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (clone_pkt->buffer) {
   3606e:	6923      	ldr	r3, [r4, #16]
   36070:	b15b      	cbz	r3, 3608a <net_pkt_clone+0x72>
   36072:	462a      	mov	r2, r5
   36074:	f852 3f28 	ldr.w	r3, [r2, #40]!
   36078:	62a3      	str	r3, [r4, #40]	; 0x28
   3607a:	6853      	ldr	r3, [r2, #4]
   3607c:	462a      	mov	r2, r5
   3607e:	62e3      	str	r3, [r4, #44]	; 0x2c
   36080:	f852 3f30 	ldr.w	r3, [r2, #48]!
   36084:	6323      	str	r3, [r4, #48]	; 0x30
   36086:	6853      	ldr	r3, [r2, #4]
   36088:	6363      	str	r3, [r4, #52]	; 0x34
	return pkt->family;
   3608a:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
	pkt->family = family;
   3608e:	f894 203f 	ldrb.w	r2, [r4, #63]	; 0x3f
	return pkt->family;
   36092:	f3c3 0342 	ubfx	r3, r3, #1, #3
	pkt->family = family;
   36096:	f363 0243 	bfi	r2, r3, #1, #3
   3609a:	f884 203f 	strb.w	r2, [r4, #63]	; 0x3f
	net_pkt_set_context(clone_pkt, net_pkt_context(pkt));
   3609e:	69eb      	ldr	r3, [r5, #28]
	net_pkt_cursor_init(clone_pkt);
   360a0:	4620      	mov	r0, r4
	pkt->context = ctx;
   360a2:	61e3      	str	r3, [r4, #28]
	net_pkt_set_ip_hdr_len(clone_pkt, net_pkt_ip_hdr_len(pkt));
   360a4:	f895 303c 	ldrb.w	r3, [r5, #60]	; 0x3c
	pkt->ip_hdr_len = len;
   360a8:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	return pkt->family;
   360ac:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
	if (IS_ENABLED(CONFIG_NET_IPV4) && net_pkt_family(pkt) == AF_INET) {
   360b0:	f3c3 0342 	ubfx	r3, r3, #1, #3
   360b4:	2b01      	cmp	r3, #1
		net_pkt_set_ipv4_ttl(clone_pkt, net_pkt_ipv4_ttl(pkt));
   360b6:	bf01      	itttt	eq
   360b8:	f895 3042 	ldrbeq.w	r3, [r5, #66]	; 0x42
	pkt->ipv4_ttl = ttl;
   360bc:	f884 3042 	strbeq.w	r3, [r4, #66]	; 0x42
		net_pkt_set_ipv4_opts_len(clone_pkt,
   360c0:	f895 3043 	ldrbeq.w	r3, [r5, #67]	; 0x43
	pkt->ipv4_opts_len = opts_len;
   360c4:	f884 3043 	strbeq.w	r3, [r4, #67]	; 0x43
	net_pkt_cursor_init(clone_pkt);
   360c8:	f7ff fe6a 	bl	35da0 <net_pkt_cursor_init>
	if (cursor_offset) {
   360cc:	f1b8 0f00 	cmp.w	r8, #0
   360d0:	d008      	beq.n	360e4 <net_pkt_clone+0xcc>
	pkt->overwrite = overwrite;
   360d2:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
		net_pkt_skip(clone_pkt, cursor_offset);
   360d6:	4641      	mov	r1, r8
   360d8:	f043 0301 	orr.w	r3, r3, #1
   360dc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   360e0:	f7ff fee8 	bl	35eb4 <net_pkt_skip>
	pkt->cursor.pos = backup->pos;
   360e4:	e9c5 7605 	strd	r7, r6, [r5, #20]
	return clone_pkt;
   360e8:	e7bd      	b.n	36066 <net_pkt_clone+0x4e>

000360ea <net_pkt_is_contiguous>:

bool net_pkt_is_contiguous(struct net_pkt *pkt, size_t size)
{
   360ea:	b538      	push	{r3, r4, r5, lr}
   360ec:	460d      	mov	r5, r1
	return pkt->overwrite;
   360ee:	f890 103d 	ldrb.w	r1, [r0, #61]	; 0x3d
   360f2:	4604      	mov	r4, r0
	pkt_cursor_advance(pkt, !net_pkt_is_being_overwritten(pkt));
   360f4:	43c9      	mvns	r1, r1
   360f6:	f001 0101 	and.w	r1, r1, #1
   360fa:	f7ff fd31 	bl	35b60 <pkt_cursor_advance>

	if (pkt->cursor.buf && pkt->cursor.pos) {
   360fe:	6943      	ldr	r3, [r0, #20]
   36100:	b17b      	cbz	r3, 36122 <net_pkt_is_contiguous+0x38>
   36102:	6980      	ldr	r0, [r0, #24]
   36104:	b160      	cbz	r0, 36120 <net_pkt_is_contiguous+0x36>
   36106:	f894 203d 	ldrb.w	r2, [r4, #61]	; 0x3d
		size_t len;

		len = net_pkt_is_being_overwritten(pkt) ?
			pkt->cursor.buf->len : pkt->cursor.buf->size;
   3610a:	07d2      	lsls	r2, r2, #31
   3610c:	bf4c      	ite	mi
   3610e:	899a      	ldrhmi	r2, [r3, #12]
   36110:	89da      	ldrhpl	r2, [r3, #14]
		len -= pkt->cursor.pos - pkt->cursor.buf->data;
   36112:	689b      	ldr	r3, [r3, #8]
   36114:	1ac0      	subs	r0, r0, r3
   36116:	1a10      	subs	r0, r2, r0
		if (len >= size) {
   36118:	42a8      	cmp	r0, r5
   3611a:	bf34      	ite	cc
   3611c:	2000      	movcc	r0, #0
   3611e:	2001      	movcs	r0, #1
			return true;
		}
	}

	return false;
}
   36120:	bd38      	pop	{r3, r4, r5, pc}
	return false;
   36122:	4618      	mov	r0, r3
   36124:	e7fc      	b.n	36120 <net_pkt_is_contiguous+0x36>

00036126 <net_pkt_write>:
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   36126:	6983      	ldr	r3, [r0, #24]
{
   36128:	b573      	push	{r0, r1, r4, r5, r6, lr}
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   3612a:	4299      	cmp	r1, r3
{
   3612c:	4604      	mov	r4, r0
   3612e:	460e      	mov	r6, r1
   36130:	4615      	mov	r5, r2
	if (data == pkt->cursor.pos && net_pkt_is_contiguous(pkt, length)) {
   36132:	d10a      	bne.n	3614a <net_pkt_write+0x24>
   36134:	4611      	mov	r1, r2
   36136:	f7ff ffd8 	bl	360ea <net_pkt_is_contiguous>
   3613a:	b130      	cbz	r0, 3614a <net_pkt_write+0x24>
		return net_pkt_skip(pkt, length);
   3613c:	4629      	mov	r1, r5
   3613e:	4620      	mov	r0, r4
}
   36140:	b002      	add	sp, #8
   36142:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return net_pkt_skip(pkt, length);
   36146:	f7ff beb5 	b.w	35eb4 <net_pkt_skip>
	return net_pkt_cursor_operate(pkt, (void *)data, length, true, true);
   3614a:	2301      	movs	r3, #1
   3614c:	462a      	mov	r2, r5
   3614e:	9300      	str	r3, [sp, #0]
   36150:	4631      	mov	r1, r6
   36152:	4620      	mov	r0, r4
   36154:	f7ff fd47 	bl	35be6 <net_pkt_cursor_operate>
}
   36158:	b002      	add	sp, #8
   3615a:	bd70      	pop	{r4, r5, r6, pc}

0003615c <net_pkt_get_data>:

void *net_pkt_get_data(struct net_pkt *pkt,
		       struct net_pkt_data_access *access)
{
   3615c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   36160:	460d      	mov	r5, r1
			return NULL;
		}

		return pkt->cursor.pos;
	} else {
		if (net_pkt_is_contiguous(pkt, access->size)) {
   36162:	6849      	ldr	r1, [r1, #4]
{
   36164:	4604      	mov	r4, r0
		if (net_pkt_is_contiguous(pkt, access->size)) {
   36166:	f7ff ffc0 	bl	360ea <net_pkt_is_contiguous>
   3616a:	4680      	mov	r8, r0
   3616c:	b118      	cbz	r0, 36176 <net_pkt_get_data+0x1a>
			access->data = pkt->cursor.pos;
   3616e:	69a3      	ldr	r3, [r4, #24]
   36170:	602b      	str	r3, [r5, #0]
			}

			net_pkt_cursor_restore(pkt, &backup);
		}

		return access->data;
   36172:	6829      	ldr	r1, [r5, #0]
   36174:	e010      	b.n	36198 <net_pkt_get_data+0x3c>
   36176:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
		} else if (net_pkt_is_being_overwritten(pkt)) {
   3617a:	07db      	lsls	r3, r3, #31
   3617c:	d5f9      	bpl.n	36172 <net_pkt_get_data+0x16>
   3617e:	6829      	ldr	r1, [r5, #0]
			if (!access->data) {
   36180:	b151      	cbz	r1, 36198 <net_pkt_get_data+0x3c>
	backup->pos = pkt->cursor.pos;
   36182:	e9d4 7605 	ldrd	r7, r6, [r4, #20]
			if (net_pkt_read(pkt, access->data, access->size)) {
   36186:	686a      	ldr	r2, [r5, #4]
   36188:	4620      	mov	r0, r4
   3618a:	f7ff fea9 	bl	35ee0 <net_pkt_read>
	pkt->cursor.pos = backup->pos;
   3618e:	e9c4 7605 	strd	r7, r6, [r4, #20]
   36192:	2800      	cmp	r0, #0
   36194:	d0ed      	beq.n	36172 <net_pkt_get_data+0x16>
				return NULL;
   36196:	4641      	mov	r1, r8
	}

	return NULL;
}
   36198:	4608      	mov	r0, r1
   3619a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003619e <net_pkt_set_data>:
{
	if (IS_ENABLED(CONFIG_NET_HEADERS_ALWAYS_CONTIGUOUS)) {
		return net_pkt_skip(pkt, access->size);
	}

	return net_pkt_write(pkt, access->data, access->size);
   3619e:	e9d1 1200 	ldrd	r1, r2, [r1]
   361a2:	f7ff bfc0 	b.w	36126 <net_pkt_write>

000361a6 <net_pkt_init>:
		(size_t)(k_mem_slab_num_free_get(&tx_pkts) *
			 sizeof(struct net_pkt)),
		get_frees(&rx_bufs), get_size(&rx_bufs),
		get_frees(&tx_bufs), get_size(&tx_bufs));
#endif
}
   361a6:	4770      	bx	lr

000361a8 <k_work_submit_to_queue>:
{
   361a8:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   361aa:	f101 0308 	add.w	r3, r1, #8
   361ae:	e8d3 2fef 	ldaex	r2, [r3]
   361b2:	f042 0c01 	orr.w	ip, r2, #1
   361b6:	e8c3 cfee 	stlex	lr, ip, [r3]
   361ba:	f1be 0f00 	cmp.w	lr, #0
   361be:	d1f6      	bne.n	361ae <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   361c0:	07d3      	lsls	r3, r2, #31
   361c2:	d403      	bmi.n	361cc <k_work_submit_to_queue+0x24>
}
   361c4:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   361c8:	f002 bd6c 	b.w	38ca4 <k_queue_append>
}
   361cc:	f85d fb04 	ldr.w	pc, [sp], #4

000361d0 <icmpv4_create>:
{
   361d0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   361d2:	2304      	movs	r3, #4
   361d4:	2400      	movs	r4, #0
{
   361d6:	460f      	mov	r7, r1
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   361d8:	4669      	mov	r1, sp
{
   361da:	4605      	mov	r5, r0
   361dc:	4616      	mov	r6, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   361de:	e9cd 4300 	strd	r4, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   361e2:	f7ff ffbb 	bl	3615c <net_pkt_get_data>
	if (!icmp_hdr) {
   361e6:	b148      	cbz	r0, 361fc <icmpv4_create+0x2c>
	icmp_hdr->type   = icmp_type;
   361e8:	7007      	strb	r7, [r0, #0]
	icmp_hdr->code   = icmp_code;
   361ea:	7046      	strb	r6, [r0, #1]
	icmp_hdr->chksum = 0U;
   361ec:	7084      	strb	r4, [r0, #2]
   361ee:	70c4      	strb	r4, [r0, #3]
	return net_pkt_set_data(pkt, &icmpv4_access);
   361f0:	4669      	mov	r1, sp
   361f2:	4628      	mov	r0, r5
   361f4:	f7ff ffd3 	bl	3619e <net_pkt_set_data>
}
   361f8:	b003      	add	sp, #12
   361fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   361fc:	f06f 0068 	mvn.w	r0, #104	; 0x68
   36200:	e7fa      	b.n	361f8 <icmpv4_create+0x28>

00036202 <icmpv4_handle_echo_request>:
	return UNALIGNED_GET(&addr->s_addr) == 0;
   36202:	68cb      	ldr	r3, [r1, #12]
{
   36204:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   36206:	4606      	mov	r6, r0
   36208:	460f      	mov	r7, r1
	if (net_ipv4_is_addr_unspecified(&ip_hdr->src)) {
   3620a:	b90b      	cbnz	r3, 36210 <icmpv4_handle_echo_request+0xe>
	return NET_DROP;
   3620c:	2002      	movs	r0, #2
   3620e:	e04b      	b.n	362a8 <icmpv4_handle_echo_request+0xa6>
	size_t bytes = 0;
   36210:	2200      	movs	r2, #0
	payload_len = net_pkt_get_len(pkt) -
   36212:	6903      	ldr	r3, [r0, #16]
	while (buf) {
   36214:	2b00      	cmp	r3, #0
   36216:	d149      	bne.n	362ac <icmpv4_handle_echo_request+0xaa>
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
   36218:	f896 1043 	ldrb.w	r1, [r6, #67]	; 0x43
		      net_pkt_ip_hdr_len(pkt) -
   3621c:	f896 403c 	ldrb.w	r4, [r6, #60]	; 0x3c
		      net_pkt_ipv4_opts_len(pkt) - NET_ICMPH_LEN;
   36220:	440c      	add	r4, r1
   36222:	f5c4 447f 	rsb	r4, r4, #65280	; 0xff00
   36226:	34fc      	adds	r4, #252	; 0xfc
   36228:	4414      	add	r4, r2
	payload_len = net_pkt_get_len(pkt) -
   3622a:	b224      	sxth	r4, r4
	if (payload_len < NET_ICMPV4_UNUSED_LEN) {
   3622c:	2c03      	cmp	r4, #3
   3622e:	dded      	ble.n	3620c <icmpv4_handle_echo_request+0xa>
	reply = net_pkt_alloc_with_buffer(net_pkt_iface(pkt),
   36230:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   36234:	9300      	str	r3, [sp, #0]
   36236:	2301      	movs	r3, #1
   36238:	4421      	add	r1, r4
   3623a:	461a      	mov	r2, r3
   3623c:	6a30      	ldr	r0, [r6, #32]
   3623e:	f7e7 f8ad 	bl	1d39c <net_pkt_alloc_with_buffer>
	if (!reply) {
   36242:	4605      	mov	r5, r0
   36244:	2800      	cmp	r0, #0
   36246:	d0e1      	beq.n	3620c <icmpv4_handle_echo_request+0xa>
	if (net_ipv4_is_addr_mcast(&ip_hdr->dst)) {
   36248:	693b      	ldr	r3, [r7, #16]
   3624a:	f107 0110 	add.w	r1, r7, #16
	return (ntohl(UNALIGNED_GET(&addr->s_addr)) & 0xE0000000) == 0xE0000000;
   3624e:	ba1b      	rev	r3, r3
   36250:	f003 4360 	and.w	r3, r3, #3758096384	; 0xe0000000
   36254:	f1b3 4f60 	cmp.w	r3, #3758096384	; 0xe0000000
   36258:	d103      	bne.n	36262 <icmpv4_handle_echo_request+0x60>
		src = net_if_ipv4_select_src_addr(net_pkt_iface(pkt),
   3625a:	6a30      	ldr	r0, [r6, #32]
   3625c:	f7e6 f828 	bl	1c2b0 <net_if_ipv4_select_src_addr>
   36260:	4601      	mov	r1, r0
	if (net_ipv4_create(reply, src, &ip_hdr->src)) {
   36262:	f107 020c 	add.w	r2, r7, #12
   36266:	4628      	mov	r0, r5
   36268:	f000 f8ce 	bl	36408 <net_ipv4_create>
   3626c:	4602      	mov	r2, r0
   3626e:	bb08      	cbnz	r0, 362b4 <icmpv4_handle_echo_request+0xb2>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   36270:	4601      	mov	r1, r0
   36272:	4628      	mov	r0, r5
   36274:	f7ff ffac 	bl	361d0 <icmpv4_create>
   36278:	b9e0      	cbnz	r0, 362b4 <icmpv4_handle_echo_request+0xb2>
	    net_pkt_copy(reply, pkt, payload_len)) {
   3627a:	4622      	mov	r2, r4
   3627c:	4631      	mov	r1, r6
   3627e:	4628      	mov	r0, r5
   36280:	f7ff fe46 	bl	35f10 <net_pkt_copy>
	if (icmpv4_create(reply, NET_ICMPV4_ECHO_REPLY, 0) ||
   36284:	4604      	mov	r4, r0
   36286:	b9a8      	cbnz	r0, 362b4 <icmpv4_handle_echo_request+0xb2>
	net_pkt_cursor_init(reply);
   36288:	4628      	mov	r0, r5
   3628a:	f7ff fd89 	bl	35da0 <net_pkt_cursor_init>
	net_ipv4_finalize(reply, IPPROTO_ICMP);
   3628e:	2101      	movs	r1, #1
   36290:	4628      	mov	r0, r5
   36292:	f000 f8ec 	bl	3646e <net_ipv4_finalize>
	if (net_send_data(reply) < 0) {
   36296:	4628      	mov	r0, r5
   36298:	f7ff f96f 	bl	3557a <net_send_data>
   3629c:	2800      	cmp	r0, #0
   3629e:	db09      	blt.n	362b4 <icmpv4_handle_echo_request+0xb2>
	net_pkt_unref(pkt);
   362a0:	4630      	mov	r0, r6
   362a2:	f7ff fd19 	bl	35cd8 <net_pkt_unref>
	return NET_OK;
   362a6:	4620      	mov	r0, r4
}
   362a8:	b003      	add	sp, #12
   362aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   362ac:	8999      	ldrh	r1, [r3, #12]
		buf = buf->frags;
   362ae:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   362b0:	440a      	add	r2, r1
		buf = buf->frags;
   362b2:	e7af      	b.n	36214 <icmpv4_handle_echo_request+0x12>
		net_pkt_unref(reply);
   362b4:	4628      	mov	r0, r5
   362b6:	f7ff fd0f 	bl	35cd8 <net_pkt_unref>
   362ba:	e7a7      	b.n	3620c <icmpv4_handle_echo_request+0xa>

000362bc <net_icmpv4_finalize>:
{
   362bc:	b537      	push	{r0, r1, r2, r4, r5, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   362be:	2304      	movs	r3, #4
   362c0:	2200      	movs	r2, #0
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   362c2:	4669      	mov	r1, sp
{
   362c4:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   362c6:	e9cd 2300 	strd	r2, r3, [sp]
	icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(pkt, &icmpv4_access);
   362ca:	f7ff ff47 	bl	3615c <net_pkt_get_data>
	if (!icmp_hdr) {
   362ce:	4605      	mov	r5, r0
   362d0:	b150      	cbz	r0, 362e8 <net_icmpv4_finalize+0x2c>
   362d2:	2101      	movs	r1, #1
   362d4:	4620      	mov	r0, r4
   362d6:	f7ff fa9b 	bl	35810 <net_calc_chksum>
	return net_pkt_set_data(pkt, &icmpv4_access);
   362da:	4669      	mov	r1, sp
	icmp_hdr->chksum = net_calc_chksum_icmpv4(pkt);
   362dc:	8068      	strh	r0, [r5, #2]
	return net_pkt_set_data(pkt, &icmpv4_access);
   362de:	4620      	mov	r0, r4
   362e0:	f7ff ff5d 	bl	3619e <net_pkt_set_data>
}
   362e4:	b003      	add	sp, #12
   362e6:	bd30      	pop	{r4, r5, pc}
		return -ENOBUFS;
   362e8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   362ec:	e7fa      	b.n	362e4 <net_icmpv4_finalize+0x28>

000362ee <net_icmpv4_send_error>:
{
   362ee:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   362f2:	2314      	movs	r3, #20
{
   362f4:	4606      	mov	r6, r0
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   362f6:	2400      	movs	r4, #0
{
   362f8:	b087      	sub	sp, #28
   362fa:	4688      	mov	r8, r1
   362fc:	4691      	mov	r9, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   362fe:	e9cd 4302 	strd	r4, r3, [sp, #8]
	net_pkt_cursor_init(orig);
   36302:	f7ff fd4d 	bl	35da0 <net_pkt_cursor_init>
	ip_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(orig, &ipv4_access);
   36306:	a902      	add	r1, sp, #8
   36308:	4630      	mov	r0, r6
   3630a:	f7ff ff27 	bl	3615c <net_pkt_get_data>
	if (!ip_hdr) {
   3630e:	4605      	mov	r5, r0
   36310:	b378      	cbz	r0, 36372 <net_icmpv4_send_error+0x84>
	if (ip_hdr->proto == IPPROTO_ICMP) {
   36312:	7a43      	ldrb	r3, [r0, #9]
   36314:	2b01      	cmp	r3, #1
   36316:	d110      	bne.n	3633a <net_icmpv4_send_error+0x4c>
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   36318:	2304      	movs	r3, #4
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   3631a:	a904      	add	r1, sp, #16
   3631c:	4630      	mov	r0, r6
		NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(icmpv4_access,
   3631e:	9404      	str	r4, [sp, #16]
   36320:	9305      	str	r3, [sp, #20]
		icmp_hdr = (struct net_icmp_hdr *)net_pkt_get_data(
   36322:	f7ff ff1b 	bl	3615c <net_pkt_get_data>
		if (!icmp_hdr || icmp_hdr->code < 8) {
   36326:	b110      	cbz	r0, 3632e <net_icmpv4_send_error+0x40>
   36328:	7843      	ldrb	r3, [r0, #1]
   3632a:	2b07      	cmp	r3, #7
   3632c:	d805      	bhi.n	3633a <net_icmpv4_send_error+0x4c>
			err = -EINVAL;
   3632e:	f06f 0515 	mvn.w	r5, #21
}
   36332:	4628      	mov	r0, r5
   36334:	b007      	add	sp, #28
   36336:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (ip_hdr->proto == IPPROTO_UDP) {
   3633a:	7a6b      	ldrb	r3, [r5, #9]
   3633c:	2b11      	cmp	r3, #17
   3633e:	d01b      	beq.n	36378 <net_icmpv4_send_error+0x8a>
		copy_len = 0;
   36340:	2b06      	cmp	r3, #6
   36342:	bf0c      	ite	eq
   36344:	2728      	moveq	r7, #40	; 0x28
   36346:	2700      	movne	r7, #0
	pkt = net_pkt_alloc_with_buffer(net_pkt_iface(orig),
   36348:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   3634c:	9300      	str	r3, [sp, #0]
   3634e:	2301      	movs	r3, #1
   36350:	1d39      	adds	r1, r7, #4
   36352:	461a      	mov	r2, r3
   36354:	6a30      	ldr	r0, [r6, #32]
   36356:	f7e7 f821 	bl	1d39c <net_pkt_alloc_with_buffer>
	if (!pkt) {
   3635a:	4604      	mov	r4, r0
   3635c:	b3b8      	cbz	r0, 363ce <net_icmpv4_send_error+0xe0>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   3635e:	f105 020c 	add.w	r2, r5, #12
   36362:	f105 0110 	add.w	r1, r5, #16
   36366:	f000 f84f 	bl	36408 <net_ipv4_create>
   3636a:	b138      	cbz	r0, 3637c <net_icmpv4_send_error+0x8e>
	net_pkt_unref(pkt);
   3636c:	4620      	mov	r0, r4
   3636e:	f7ff fcb3 	bl	35cd8 <net_pkt_unref>
	int err = -EIO;
   36372:	f06f 0504 	mvn.w	r5, #4
   36376:	e7dc      	b.n	36332 <net_icmpv4_send_error+0x44>
		copy_len = sizeof(struct net_ipv4_hdr) +
   36378:	271c      	movs	r7, #28
   3637a:	e7e5      	b.n	36348 <net_icmpv4_send_error+0x5a>
	    icmpv4_create(pkt, type, code) ||
   3637c:	4641      	mov	r1, r8
   3637e:	464a      	mov	r2, r9
   36380:	4620      	mov	r0, r4
   36382:	f7ff ff25 	bl	361d0 <icmpv4_create>
	if (net_ipv4_create(pkt, &ip_hdr->dst, &ip_hdr->src) ||
   36386:	4601      	mov	r1, r0
   36388:	2800      	cmp	r0, #0
   3638a:	d1ef      	bne.n	3636c <net_icmpv4_send_error+0x7e>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   3638c:	2204      	movs	r2, #4
   3638e:	4620      	mov	r0, r4
   36390:	f7ff fd9b 	bl	35eca <net_pkt_memset>
	    icmpv4_create(pkt, type, code) ||
   36394:	2800      	cmp	r0, #0
   36396:	d1e9      	bne.n	3636c <net_icmpv4_send_error+0x7e>
	    net_pkt_copy(pkt, orig, copy_len)) {
   36398:	463a      	mov	r2, r7
   3639a:	4631      	mov	r1, r6
   3639c:	4620      	mov	r0, r4
   3639e:	f7ff fdb7 	bl	35f10 <net_pkt_copy>
	    net_pkt_memset(pkt, 0, NET_ICMPV4_UNUSED_LEN) ||
   363a2:	4605      	mov	r5, r0
   363a4:	2800      	cmp	r0, #0
   363a6:	d1e1      	bne.n	3636c <net_icmpv4_send_error+0x7e>
	net_pkt_cursor_init(pkt);
   363a8:	4620      	mov	r0, r4
   363aa:	f7ff fcf9 	bl	35da0 <net_pkt_cursor_init>
	net_ipv4_finalize(pkt, IPPROTO_ICMP);
   363ae:	2101      	movs	r1, #1
   363b0:	4620      	mov	r0, r4
   363b2:	f000 f85c 	bl	3646e <net_ipv4_finalize>
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   363b6:	6ab3      	ldr	r3, [r6, #40]	; 0x28
	if (net_send_data(pkt) >= 0) {
   363b8:	4620      	mov	r0, r4
	net_pkt_lladdr_dst(pkt)->addr = net_pkt_lladdr_src(orig)->addr;
   363ba:	6323      	str	r3, [r4, #48]	; 0x30
	net_pkt_lladdr_dst(pkt)->len = net_pkt_lladdr_src(orig)->len;
   363bc:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
   363c0:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
	if (net_send_data(pkt) >= 0) {
   363c4:	f7ff f8d9 	bl	3557a <net_send_data>
   363c8:	2800      	cmp	r0, #0
   363ca:	dab2      	bge.n	36332 <net_icmpv4_send_error+0x44>
   363cc:	e7ce      	b.n	3636c <net_icmpv4_send_error+0x7e>
		err =  -ENOMEM;
   363ce:	f06f 050b 	mvn.w	r5, #11
   363d2:	e7ae      	b.n	36332 <net_icmpv4_send_error+0x44>

000363d4 <net_ipv4_is_addr_mcast>:
   363d4:	6800      	ldr	r0, [r0, #0]
   363d6:	ba00      	rev	r0, r0
   363d8:	f000 4060 	and.w	r0, r0, #3758096384	; 0xe0000000
}
   363dc:	f100 5300 	add.w	r3, r0, #536870912	; 0x20000000
   363e0:	4258      	negs	r0, r3
   363e2:	4158      	adcs	r0, r3
   363e4:	4770      	bx	lr

000363e6 <net_ipv4_is_addr_bcast>:
{
   363e6:	b538      	push	{r3, r4, r5, lr}
   363e8:	460c      	mov	r4, r1
   363ea:	4605      	mov	r5, r0
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   363ec:	f7e6 f8fa 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   363f0:	6822      	ldr	r2, [r4, #0]
   363f2:	6803      	ldr	r3, [r0, #0]
	if (net_ipv4_addr_cmp(addr, net_ipv4_broadcast_address())) {
   363f4:	429a      	cmp	r2, r3
   363f6:	d005      	beq.n	36404 <net_ipv4_is_addr_bcast+0x1e>
	return net_if_ipv4_is_addr_bcast(iface, addr);
   363f8:	4621      	mov	r1, r4
   363fa:	4628      	mov	r0, r5
}
   363fc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_if_ipv4_is_addr_bcast(iface, addr);
   36400:	f7e5 bf24 	b.w	1c24c <net_if_ipv4_is_addr_bcast>
}
   36404:	2001      	movs	r0, #1
   36406:	bd38      	pop	{r3, r4, r5, pc}

00036408 <net_ipv4_create>:
#define NET_BUF_TIMEOUT K_MSEC(50)

int net_ipv4_create(struct net_pkt *pkt,
		    const struct in_addr *src,
		    const struct in_addr *dst)
{
   36408:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   3640a:	2314      	movs	r3, #20
   3640c:	2400      	movs	r4, #0
{
   3640e:	460e      	mov	r6, r1
	struct net_ipv4_hdr *ipv4_hdr;

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   36410:	4669      	mov	r1, sp
{
   36412:	4605      	mov	r5, r0
   36414:	4617      	mov	r7, r2
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   36416:	e9cd 4300 	strd	r4, r3, [sp]
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   3641a:	f7ff fe9f 	bl	3615c <net_pkt_get_data>
	if (!ipv4_hdr) {
   3641e:	b318      	cbz	r0, 36468 <net_ipv4_create+0x60>
		return -ENOBUFS;
	}

	ipv4_hdr->vhl       = 0x45;
   36420:	2345      	movs	r3, #69	; 0x45
	ipv4_hdr->tos       = 0x00;
   36422:	7044      	strb	r4, [r0, #1]
	ipv4_hdr->vhl       = 0x45;
   36424:	7003      	strb	r3, [r0, #0]
	ipv4_hdr->len       = 0U;
	ipv4_hdr->id[0]     = 0U;
   36426:	7104      	strb	r4, [r0, #4]
	ipv4_hdr->id[1]     = 0U;
   36428:	7144      	strb	r4, [r0, #5]
	ipv4_hdr->offset[0] = 0U;
   3642a:	7184      	strb	r4, [r0, #6]
	ipv4_hdr->offset[1] = 0U;
   3642c:	71c4      	strb	r4, [r0, #7]

	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
   3642e:	f895 3042 	ldrb.w	r3, [r5, #66]	; 0x42
	ipv4_hdr->len       = 0U;
   36432:	7084      	strb	r4, [r0, #2]
   36434:	70c4      	strb	r4, [r0, #3]
	ipv4_hdr->ttl       = net_pkt_ipv4_ttl(pkt);
   36436:	7203      	strb	r3, [r0, #8]
	if (ipv4_hdr->ttl == 0U) {
   36438:	b92b      	cbnz	r3, 36446 <net_ipv4_create+0x3e>
		ipv4_hdr->ttl = net_if_ipv4_get_ttl(net_pkt_iface(pkt));
   3643a:	6a2a      	ldr	r2, [r5, #32]
   3643c:	6851      	ldr	r1, [r2, #4]
 * @return Time-to-live
 */
static inline u8_t net_if_ipv4_get_ttl(struct net_if *iface)
{
#if defined(CONFIG_NET_NATIVE_IPV4)
	if (!iface->config.ip.ipv4) {
   3643e:	b109      	cbz	r1, 36444 <net_ipv4_create+0x3c>
		return 0;
	}

	return iface->config.ip.ipv4->ttl;
   36440:	f891 3038 	ldrb.w	r3, [r1, #56]	; 0x38
   36444:	7203      	strb	r3, [r0, #8]
	}

	ipv4_hdr->proto     = 0U;
   36446:	2300      	movs	r3, #0
   36448:	7243      	strb	r3, [r0, #9]
	ipv4_hdr->chksum    = 0U;
   3644a:	7283      	strb	r3, [r0, #10]
   3644c:	72c3      	strb	r3, [r0, #11]

	net_ipaddr_copy(&ipv4_hdr->dst, dst);
   3644e:	683b      	ldr	r3, [r7, #0]
   36450:	6103      	str	r3, [r0, #16]
	net_ipaddr_copy(&ipv4_hdr->src, src);
   36452:	6833      	ldr	r3, [r6, #0]
   36454:	60c3      	str	r3, [r0, #12]
	pkt->ip_hdr_len = len;
   36456:	2314      	movs	r3, #20

	net_pkt_set_ip_hdr_len(pkt, sizeof(struct net_ipv4_hdr));

	return net_pkt_set_data(pkt, &ipv4_access);
   36458:	4669      	mov	r1, sp
   3645a:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
   3645e:	4628      	mov	r0, r5
   36460:	f7ff fe9d 	bl	3619e <net_pkt_set_data>
}
   36464:	b003      	add	sp, #12
   36466:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -ENOBUFS;
   36468:	f06f 0068 	mvn.w	r0, #104	; 0x68
   3646c:	e7fa      	b.n	36464 <net_ipv4_create+0x5c>

0003646e <net_ipv4_finalize>:

int net_ipv4_finalize(struct net_pkt *pkt, u8_t next_header_proto)
{
   3646e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   36470:	2314      	movs	r3, #20
   36472:	2500      	movs	r5, #0
   36474:	e9cd 5300 	strd	r5, r3, [sp]
	pkt->overwrite = overwrite;
   36478:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
{
   3647c:	460e      	mov	r6, r1
   3647e:	f043 0301 	orr.w	r3, r3, #1
   36482:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
	struct net_ipv4_hdr *ipv4_hdr;

	net_pkt_set_overwrite(pkt, true);

	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   36486:	4669      	mov	r1, sp
{
   36488:	4604      	mov	r4, r0
	ipv4_hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   3648a:	f7ff fe67 	bl	3615c <net_pkt_get_data>
	if (!ipv4_hdr) {
   3648e:	4607      	mov	r7, r0
   36490:	b340      	cbz	r0, 364e4 <net_ipv4_finalize+0x76>
	size_t bytes = 0;
   36492:	462b      	mov	r3, r5
					((net_pkt_ip_hdr_len(pkt) +
					  net_pkt_ipv4_opts_len(pkt)) / 4U));
		}
	}

	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   36494:	6922      	ldr	r2, [r4, #16]
	while (buf) {
   36496:	b9aa      	cbnz	r2, 364c4 <net_ipv4_finalize+0x56>
   36498:	ba5b      	rev16	r3, r3
	ipv4_hdr->proto = next_header_proto;
   3649a:	727e      	strb	r6, [r7, #9]
	ipv4_hdr->len   = htons(net_pkt_get_len(pkt));
   3649c:	807b      	strh	r3, [r7, #2]

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   3649e:	6a20      	ldr	r0, [r4, #32]
   364a0:	f7ff f996 	bl	357d0 <net_if_need_calc_tx_checksum>
   364a4:	b118      	cbz	r0, 364ae <net_ipv4_finalize+0x40>
		ipv4_hdr->chksum = net_calc_chksum_ipv4(pkt);
   364a6:	4620      	mov	r0, r4
   364a8:	f7ff fa37 	bl	3591a <net_calc_chksum_ipv4>
   364ac:	8178      	strh	r0, [r7, #10]
	}

	net_pkt_set_data(pkt, &ipv4_access);
   364ae:	4669      	mov	r1, sp
   364b0:	4620      	mov	r0, r4
   364b2:	f7ff fe74 	bl	3619e <net_pkt_set_data>

	if (IS_ENABLED(CONFIG_NET_UDP) &&
   364b6:	2e11      	cmp	r6, #17
   364b8:	d108      	bne.n	364cc <net_ipv4_finalize+0x5e>
	    next_header_proto == IPPROTO_UDP) {
		return net_udp_finalize(pkt);
   364ba:	4620      	mov	r0, r4
   364bc:	f000 fdd4 	bl	37068 <net_udp_finalize>
	} else if (next_header_proto == IPPROTO_ICMP) {
		return net_icmpv4_finalize(pkt);
	}

	return 0;
}
   364c0:	b003      	add	sp, #12
   364c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   364c4:	8991      	ldrh	r1, [r2, #12]
		buf = buf->frags;
   364c6:	6812      	ldr	r2, [r2, #0]
		bytes += buf->len;
   364c8:	440b      	add	r3, r1
		buf = buf->frags;
   364ca:	e7e4      	b.n	36496 <net_ipv4_finalize+0x28>
	} else if (IS_ENABLED(CONFIG_NET_TCP) &&
   364cc:	2e06      	cmp	r6, #6
   364ce:	d103      	bne.n	364d8 <net_ipv4_finalize+0x6a>
		return net_tcp_finalize(pkt);
   364d0:	4620      	mov	r0, r4
   364d2:	f000 fcb5 	bl	36e40 <net_tcp_finalize>
   364d6:	e7f3      	b.n	364c0 <net_ipv4_finalize+0x52>
	} else if (next_header_proto == IPPROTO_ICMP) {
   364d8:	2e01      	cmp	r6, #1
   364da:	d106      	bne.n	364ea <net_ipv4_finalize+0x7c>
		return net_icmpv4_finalize(pkt);
   364dc:	4620      	mov	r0, r4
   364de:	f7ff feed 	bl	362bc <net_icmpv4_finalize>
   364e2:	e7ed      	b.n	364c0 <net_ipv4_finalize+0x52>
		return -ENOBUFS;
   364e4:	f06f 0068 	mvn.w	r0, #104	; 0x68
   364e8:	e7ea      	b.n	364c0 <net_ipv4_finalize+0x52>
	return 0;
   364ea:	2000      	movs	r0, #0
   364ec:	e7e8      	b.n	364c0 <net_ipv4_finalize+0x52>

000364ee <net_ipv4_input>:
}
#endif

enum net_verdict net_ipv4_input(struct net_pkt *pkt)
{
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   364ee:	2314      	movs	r3, #20
{
   364f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   364f2:	b091      	sub	sp, #68	; 0x44
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   364f4:	eb0d 0203 	add.w	r2, sp, r3
   364f8:	9207      	str	r2, [sp, #28]
   364fa:	2208      	movs	r2, #8
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   364fc:	2700      	movs	r7, #0
{
   364fe:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   36500:	9208      	str	r2, [sp, #32]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36502:	aa0b      	add	r2, sp, #44	; 0x2c
	NET_PKT_DATA_ACCESS_CONTIGUOUS_DEFINE(ipv4_access, struct net_ipv4_hdr);
   36504:	e9cd 7303 	strd	r7, r3, [sp, #12]
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36508:	e9cd 2309 	strd	r2, r3, [sp, #36]	; 0x24
	int real_len = net_pkt_get_len(pkt);
   3650c:	6903      	ldr	r3, [r0, #16]
	while (buf) {
   3650e:	b943      	cbnz	r3, 36522 <net_ipv4_input+0x34>
	u8_t opts_len;
	int pkt_len;

	net_stats_update_ipv4_recv(net_pkt_iface(pkt));

	hdr = (struct net_ipv4_hdr *)net_pkt_get_data(pkt, &ipv4_access);
   36510:	a903      	add	r1, sp, #12
   36512:	4620      	mov	r0, r4
   36514:	f7ff fe22 	bl	3615c <net_pkt_get_data>
	if (!hdr) {
   36518:	4605      	mov	r5, r0
   3651a:	b930      	cbnz	r0, 3652a <net_ipv4_input+0x3c>
	if (verdict != NET_DROP) {
		return verdict;
	}
drop:
	net_stats_update_ipv4_drop(net_pkt_iface(pkt));
	return NET_DROP;
   3651c:	2002      	movs	r0, #2
}
   3651e:	b011      	add	sp, #68	; 0x44
   36520:	bdf0      	pop	{r4, r5, r6, r7, pc}
		bytes += buf->len;
   36522:	899a      	ldrh	r2, [r3, #12]
		buf = buf->frags;
   36524:	681b      	ldr	r3, [r3, #0]
		bytes += buf->len;
   36526:	4417      	add	r7, r2
		buf = buf->frags;
   36528:	e7f1      	b.n	3650e <net_ipv4_input+0x20>
	hdr_len = (hdr->vhl & NET_IPV4_IHL_MASK) * 4U;
   3652a:	7806      	ldrb	r6, [r0, #0]
   3652c:	f006 060f 	and.w	r6, r6, #15
   36530:	00b6      	lsls	r6, r6, #2
	if (hdr_len < sizeof(struct net_ipv4_hdr)) {
   36532:	2e13      	cmp	r6, #19
   36534:	d9f2      	bls.n	3651c <net_ipv4_input+0x2e>
	pkt->ip_hdr_len = len;
   36536:	2314      	movs	r3, #20
	opts_len = hdr_len - sizeof(struct net_ipv4_hdr);
   36538:	3e14      	subs	r6, #20
   3653a:	b2f6      	uxtb	r6, r6
   3653c:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	pkt->ipv4_opts_len = opts_len;
   36540:	f884 6043 	strb.w	r6, [r4, #67]	; 0x43
	pkt_len = ntohs(hdr->len);
   36544:	8843      	ldrh	r3, [r0, #2]
   36546:	0219      	lsls	r1, r3, #8
   36548:	ea41 2113 	orr.w	r1, r1, r3, lsr #8
   3654c:	b289      	uxth	r1, r1
	if (real_len < pkt_len) {
   3654e:	428f      	cmp	r7, r1
   36550:	dbe4      	blt.n	3651c <net_ipv4_input+0x2e>
	} else if (real_len > pkt_len) {
   36552:	dd02      	ble.n	3655a <net_ipv4_input+0x6c>
		net_pkt_update_length(pkt, pkt_len);
   36554:	4620      	mov	r0, r4
   36556:	f7ff fd38 	bl	35fca <net_pkt_update_length>
	if (net_ipv4_is_addr_mcast(&hdr->src)) {
   3655a:	f105 010c 	add.w	r1, r5, #12
   3655e:	4608      	mov	r0, r1
   36560:	f7ff ff38 	bl	363d4 <net_ipv4_is_addr_mcast>
   36564:	2800      	cmp	r0, #0
   36566:	d1d9      	bne.n	3651c <net_ipv4_input+0x2e>
	if (net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->src)) {
   36568:	6a20      	ldr	r0, [r4, #32]
   3656a:	f7ff ff3c 	bl	363e6 <net_ipv4_is_addr_bcast>
   3656e:	2800      	cmp	r0, #0
   36570:	d1d4      	bne.n	3651c <net_ipv4_input+0x2e>
	return UNALIGNED_GET(&addr->s_addr) == 0;
   36572:	68eb      	ldr	r3, [r5, #12]
	if (net_ipv4_is_addr_unspecified(&hdr->src)) {
   36574:	2b00      	cmp	r3, #0
   36576:	d0d1      	beq.n	3651c <net_ipv4_input+0x2e>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   36578:	6a20      	ldr	r0, [r4, #32]
   3657a:	f7ff f92b 	bl	357d4 <net_if_need_calc_rx_checksum>
   3657e:	2800      	cmp	r0, #0
   36580:	d145      	bne.n	3660e <net_ipv4_input+0x120>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
   36582:	f105 0710 	add.w	r7, r5, #16
	ret = net_if_ipv4_addr_lookup(addr, NULL) != NULL;
   36586:	2100      	movs	r1, #0
   36588:	4638      	mov	r0, r7
   3658a:	f7e5 fedf 	bl	1c34c <net_if_ipv4_addr_lookup>
   3658e:	2800      	cmp	r0, #0
   36590:	bf14      	ite	ne
   36592:	2301      	movne	r3, #1
   36594:	2300      	moveq	r3, #0
	if (!ret) {
   36596:	d103      	bne.n	365a0 <net_ipv4_input+0xb2>
		ret = net_ipv4_is_addr_bcast(NULL, addr);
   36598:	4639      	mov	r1, r7
   3659a:	f7ff ff24 	bl	363e6 <net_ipv4_is_addr_bcast>
   3659e:	4603      	mov	r3, r0
   365a0:	2b00      	cmp	r3, #0
   365a2:	d03a      	beq.n	3661a <net_ipv4_input+0x12c>
				   net_ipv4_unspecified_address()))))) ||
   365a4:	7a6b      	ldrb	r3, [r5, #9]
   365a6:	2b06      	cmp	r3, #6
   365a8:	d105      	bne.n	365b6 <net_ipv4_input+0xc8>
	     net_ipv4_is_addr_bcast(net_pkt_iface(pkt), &hdr->dst))) {
   365aa:	4639      	mov	r1, r7
   365ac:	6a20      	ldr	r0, [r4, #32]
   365ae:	f7ff ff1a 	bl	363e6 <net_ipv4_is_addr_bcast>
	    (hdr->proto == IPPROTO_TCP &&
   365b2:	2800      	cmp	r0, #0
   365b4:	d1b2      	bne.n	3651c <net_ipv4_input+0x2e>
	return net_pkt_skip(pkt, access->size);
   365b6:	9904      	ldr	r1, [sp, #16]
   365b8:	4620      	mov	r0, r4
   365ba:	f7ff fc7b 	bl	35eb4 <net_pkt_skip>
	if (opts_len) {
   365be:	b12e      	cbz	r6, 365cc <net_ipv4_input+0xde>
		if (net_pkt_skip(pkt, opts_len)) {
   365c0:	4631      	mov	r1, r6
   365c2:	4620      	mov	r0, r4
   365c4:	f7ff fc76 	bl	35eb4 <net_pkt_skip>
   365c8:	2800      	cmp	r0, #0
   365ca:	d1a7      	bne.n	3651c <net_ipv4_input+0x2e>
	pkt->family = family;
   365cc:	2201      	movs	r2, #1
	net_pkt_set_ipv4_ttl(pkt, hdr->ttl);
   365ce:	7a2b      	ldrb	r3, [r5, #8]
	pkt->ipv4_ttl = ttl;
   365d0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
	pkt->family = family;
   365d4:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
   365d8:	f362 0343 	bfi	r3, r2, #1, #3
   365dc:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
	switch (hdr->proto) {
   365e0:	7a6b      	ldrb	r3, [r5, #9]
   365e2:	2b06      	cmp	r3, #6
   365e4:	d029      	beq.n	3663a <net_ipv4_input+0x14c>
   365e6:	2b11      	cmp	r3, #17
   365e8:	d031      	beq.n	3664e <net_ipv4_input+0x160>
   365ea:	4293      	cmp	r3, r2
   365ec:	d196      	bne.n	3651c <net_ipv4_input+0x2e>
		verdict = net_icmpv4_input(pkt, hdr);
   365ee:	4629      	mov	r1, r5
   365f0:	4620      	mov	r0, r4
   365f2:	f7e6 ff3b 	bl	1d46c <net_icmpv4_input>
	if (verdict == NET_DROP) {
   365f6:	2802      	cmp	r0, #2
   365f8:	d090      	beq.n	3651c <net_ipv4_input+0x2e>
	} else if (hdr->proto == IPPROTO_ICMP) {
   365fa:	7a6a      	ldrb	r2, [r5, #9]
   365fc:	2a01      	cmp	r2, #1
   365fe:	d08e      	beq.n	3651e <net_ipv4_input+0x30>
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
   36600:	ab01      	add	r3, sp, #4
   36602:	a902      	add	r1, sp, #8
   36604:	4620      	mov	r0, r4
	ip.ipv4 = hdr;
   36606:	9502      	str	r5, [sp, #8]
	verdict = net_conn_input(pkt, &ip, hdr->proto, &proto_hdr);
   36608:	f7e7 f878 	bl	1d6fc <net_conn_input>
	if (verdict != NET_DROP) {
   3660c:	e787      	b.n	3651e <net_ipv4_input+0x30>
	    net_calc_chksum_ipv4(pkt) != 0U) {
   3660e:	4620      	mov	r0, r4
   36610:	f7ff f983 	bl	3591a <net_calc_chksum_ipv4>
	if (net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   36614:	2800      	cmp	r0, #0
   36616:	d0b4      	beq.n	36582 <net_ipv4_input+0x94>
   36618:	e780      	b.n	3651c <net_ipv4_input+0x2e>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
   3661a:	4638      	mov	r0, r7
   3661c:	f7ff feda 	bl	363d4 <net_ipv4_is_addr_mcast>
	if ((!net_ipv4_is_my_addr(&hdr->dst) &&
   36620:	2800      	cmp	r0, #0
   36622:	d1bf      	bne.n	365a4 <net_ipv4_input+0xb6>
	     !net_ipv4_is_addr_mcast(&hdr->dst) &&
   36624:	7a6b      	ldrb	r3, [r5, #9]
   36626:	2b11      	cmp	r3, #17
   36628:	f47f af78 	bne.w	3651c <net_ipv4_input+0x2e>
	       (net_ipv4_addr_cmp(&hdr->dst, net_ipv4_broadcast_address()) ||
   3662c:	f7e5 ffda 	bl	1c5e4 <net_ipv4_broadcast_address>
	return UNALIGNED_GET(&addr1->s_addr) == UNALIGNED_GET(&addr2->s_addr);
   36630:	692b      	ldr	r3, [r5, #16]
   36632:	6802      	ldr	r2, [r0, #0]
	     !(hdr->proto == IPPROTO_UDP &&
   36634:	429a      	cmp	r2, r3
   36636:	d0b5      	beq.n	365a4 <net_ipv4_input+0xb6>
   36638:	e770      	b.n	3651c <net_ipv4_input+0x2e>
		proto_hdr.tcp = net_tcp_input(pkt, &tcp_access);
   3663a:	a909      	add	r1, sp, #36	; 0x24
   3663c:	4620      	mov	r0, r4
   3663e:	f000 fcd8 	bl	36ff2 <net_tcp_input>
   36642:	9001      	str	r0, [sp, #4]
		if (proto_hdr.tcp) {
   36644:	2800      	cmp	r0, #0
   36646:	f43f af69 	beq.w	3651c <net_ipv4_input+0x2e>
			verdict = NET_OK;
   3664a:	2000      	movs	r0, #0
   3664c:	e7d5      	b.n	365fa <net_ipv4_input+0x10c>
		proto_hdr.udp = net_udp_input(pkt, &udp_access);
   3664e:	a907      	add	r1, sp, #28
   36650:	4620      	mov	r0, r4
   36652:	f000 fd3c 	bl	370ce <net_udp_input>
   36656:	e7f4      	b.n	36642 <net_ipv4_input+0x154>

00036658 <sys_get_be32>:
 *
 *  @return 16-bit integer in host endianness.
 */
static inline u16_t sys_get_be16(const u8_t src[2])
{
	return ((u16_t)src[0] << 8) | src[1];
   36658:	7803      	ldrb	r3, [r0, #0]
   3665a:	7842      	ldrb	r2, [r0, #1]
   3665c:	7881      	ldrb	r1, [r0, #2]
 *
 *  @return 32-bit integer in host endianness.
 */
static inline u32_t sys_get_be32(const u8_t src[4])
{
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
   3665e:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
	return ((u16_t)src[0] << 8) | src[1];
   36662:	78c3      	ldrb	r3, [r0, #3]
	return ((u32_t)sys_get_be16(&src[0]) << 16) | sys_get_be16(&src[2]);
   36664:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
}
   36668:	ea43 4002 	orr.w	r0, r3, r2, lsl #16
   3666c:	4770      	bx	lr

0003666e <handle_fin_timeout>:
	net_context_unref(tcp->context);
   3666e:	f850 0c28 	ldr.w	r0, [r0, #-40]
   36672:	f7ff b99a 	b.w	359aa <net_context_unref>

00036676 <net_tcp_is_used>:
	return tcp->flags & NET_TCP_IN_USE;
   36676:	f8b0 00bc 	ldrh.w	r0, [r0, #188]	; 0xbc
}
   3667a:	f3c0 1040 	ubfx	r0, r0, #5, #1
   3667e:	4770      	bx	lr

00036680 <net_tcp_queue_pkt.isra.22>:
	parent->next = child;
   36680:	2200      	movs	r2, #0
static int net_tcp_queue_pkt(struct net_context *context, struct net_pkt *pkt)
   36682:	b538      	push	{r3, r4, r5, lr}
   36684:	4605      	mov	r5, r0
	sys_slist_append(&context->tcp->sent_list, &pkt->sent_list);
   36686:	6800      	ldr	r0, [r0, #0]
   36688:	638a      	str	r2, [r1, #56]	; 0x38
Z_GENLIST_APPEND(slist, snode)
   3668a:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
static int net_tcp_queue_pkt(struct net_context *context, struct net_pkt *pkt)
   3668e:	460c      	mov	r4, r1
	sys_slist_append(&context->tcp->sent_list, &pkt->sent_list);
   36690:	f101 0338 	add.w	r3, r1, #56	; 0x38
   36694:	b9da      	cbnz	r2, 366ce <net_tcp_queue_pkt.isra.22+0x4e>
	list->head = node;
   36696:	e9c0 3322 	strd	r3, r3, [r0, #136]	; 0x88
	return k_ticks_to_ms_floor32(z_timeout_remaining(&work->timeout));
   3669a:	3054      	adds	r0, #84	; 0x54
   3669c:	f7f8 f99a 	bl	2e9d4 <z_timeout_remaining>
   366a0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   366a4:	fba0 0103 	umull	r0, r1, r0, r3
   366a8:	0bc3      	lsrs	r3, r0, #15
	if (k_delayed_work_remaining_get(&context->tcp->retry_timer) == 0) {
   366aa:	ea53 4341 	orrs.w	r3, r3, r1, lsl #17
   366ae:	d109      	bne.n	366c4 <net_tcp_queue_pkt.isra.22+0x44>
		k_delayed_work_submit(&context->tcp->retry_timer,
   366b0:	21c8      	movs	r1, #200	; 0xc8
   366b2:	6828      	ldr	r0, [r5, #0]
	return K_MSEC(((u32_t)1 << tcp->retry_timeout_shift) *
   366b4:	f890 30bc 	ldrb.w	r3, [r0, #188]	; 0xbc
		k_delayed_work_submit(&context->tcp->retry_timer,
   366b8:	3048      	adds	r0, #72	; 0x48
	return K_MSEC(((u32_t)1 << tcp->retry_timeout_shift) *
   366ba:	f003 031f 	and.w	r3, r3, #31
		k_delayed_work_submit(&context->tcp->retry_timer,
   366be:	4099      	lsls	r1, r3
   366c0:	f7e7 f924 	bl	1d90c <k_delayed_work_submit>
	do_ref_if_needed(context->tcp, pkt);
   366c4:	4620      	mov	r0, r4
   366c6:	f7ff faee 	bl	35ca6 <net_pkt_ref>
}
   366ca:	2000      	movs	r0, #0
   366cc:	bd38      	pop	{r3, r4, r5, pc}
	parent->next = child;
   366ce:	6013      	str	r3, [r2, #0]
	list->tail = node;
   366d0:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
   366d4:	e7e1      	b.n	3669a <net_tcp_queue_pkt.isra.22+0x1a>

000366d6 <net_tcp_get_recv_mss>:
{
   366d6:	b510      	push	{r4, lr}
   366d8:	4604      	mov	r4, r0
	sa_family_t family = net_context_get_family(tcp->context);
   366da:	6800      	ldr	r0, [r0, #0]
   366dc:	f7e7 f91e 	bl	1d91c <net_context_get_family>
	if (family == AF_INET) {
   366e0:	2801      	cmp	r0, #1
   366e2:	d001      	beq.n	366e8 <net_tcp_get_recv_mss+0x12>
	return 0;
   366e4:	2000      	movs	r0, #0
}
   366e6:	bd10      	pop	{r4, pc}
		struct net_if *iface = net_context_get_iface(tcp->context);
   366e8:	6820      	ldr	r0, [r4, #0]
   366ea:	f7e7 f97b 	bl	1d9e4 <net_context_get_iface>
		if (iface && net_if_get_mtu(iface) >= NET_IPV4TCPH_LEN) {
   366ee:	2800      	cmp	r0, #0
   366f0:	d0f8      	beq.n	366e4 <net_tcp_get_recv_mss+0xe>
	return iface->if_dev->mtu;
   366f2:	6803      	ldr	r3, [r0, #0]
   366f4:	8b18      	ldrh	r0, [r3, #24]
   366f6:	2827      	cmp	r0, #39	; 0x27
   366f8:	d9f4      	bls.n	366e4 <net_tcp_get_recv_mss+0xe>
			return net_if_get_mtu(iface) - NET_IPV4TCPH_LEN;
   366fa:	3828      	subs	r0, #40	; 0x28
   366fc:	b280      	uxth	r0, r0
   366fe:	e7f2      	b.n	366e6 <net_tcp_get_recv_mss+0x10>

00036700 <net_tcp_set_syn_opt>:
	*optionlen = 0U;
   36700:	2300      	movs	r3, #0
{
   36702:	b570      	push	{r4, r5, r6, lr}
	*optionlen = 0U;
   36704:	7013      	strb	r3, [r2, #0]
{
   36706:	4614      	mov	r4, r2
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
   36708:	f8b0 20bc 	ldrh.w	r2, [r0, #188]	; 0xbc
{
   3670c:	4605      	mov	r5, r0
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
   3670e:	0552      	lsls	r2, r2, #21
{
   36710:	460e      	mov	r6, r1
	if (!(tcp->flags & NET_TCP_RECV_MSS_SET)) {
   36712:	d418      	bmi.n	36746 <net_tcp_set_syn_opt+0x46>
		recv_mss = net_tcp_get_recv_mss(tcp);
   36714:	f7ff ffdf 	bl	366d6 <net_tcp_get_recv_mss>
		tcp->flags |= NET_TCP_RECV_MSS_SET;
   36718:	f8b5 30bc 	ldrh.w	r3, [r5, #188]	; 0xbc
   3671c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   36720:	f8a5 30bc 	strh.w	r3, [r5, #188]	; 0xbc
	recv_mss |= (NET_TCP_MSS_OPT << 24) | (NET_TCP_MSS_SIZE << 16);
   36724:	f040 7301 	orr.w	r3, r0, #33816576	; 0x2040000
	UNALIGNED_PUT(htonl(recv_mss),
   36728:	0218      	lsls	r0, r3, #8
   3672a:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
   3672e:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
   36732:	7822      	ldrb	r2, [r4, #0]
   36734:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
   36738:	f040 0002 	orr.w	r0, r0, #2
   3673c:	50b0      	str	r0, [r6, r2]
	*optionlen += NET_TCP_MSS_SIZE;
   3673e:	7823      	ldrb	r3, [r4, #0]
   36740:	3304      	adds	r3, #4
   36742:	7023      	strb	r3, [r4, #0]
}
   36744:	bd70      	pop	{r4, r5, r6, pc}
		recv_mss = 0U;
   36746:	4618      	mov	r0, r3
   36748:	e7ec      	b.n	36724 <net_tcp_set_syn_opt+0x24>

0003674a <net_tcp_prepare_reset>:
{
   3674a:	b5f0      	push	{r4, r5, r6, r7, lr}
   3674c:	4605      	mov	r5, r0
   3674e:	b089      	sub	sp, #36	; 0x24
   36750:	460c      	mov	r4, r1
   36752:	4617      	mov	r7, r2
	struct tcp_segment segment = { 0 };
   36754:	2100      	movs	r1, #0
   36756:	2218      	movs	r2, #24
   36758:	a802      	add	r0, sp, #8
{
   3675a:	461e      	mov	r6, r3
	struct tcp_segment segment = { 0 };
   3675c:	f002 fc76 	bl	3904c <memset>
	if ((net_context_get_state(tcp->context) != NET_CONTEXT_UNCONNECTED) &&
   36760:	6828      	ldr	r0, [r5, #0]
   36762:	f7e7 f8fb 	bl	1d95c <net_context_get_state>
   36766:	b300      	cbz	r0, 367aa <net_tcp_prepare_reset+0x60>
	return (enum net_tcp_state)tcp->state;
   36768:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
   3676c:	f3c2 3243 	ubfx	r2, r2, #13, #4
   36770:	2a02      	cmp	r2, #2
   36772:	d02c      	beq.n	367ce <net_tcp_prepare_reset+0x84>
	    (net_tcp_get_state(tcp) != NET_TCP_SYN_SENT) &&
   36774:	2a09      	cmp	r2, #9
   36776:	d02a      	beq.n	367ce <net_tcp_prepare_reset+0x84>
		segment.ack = tcp->send_ack;
   36778:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
   3677c:	6828      	ldr	r0, [r5, #0]
   3677e:	9303      	str	r3, [sp, #12]
		segment.flags = NET_TCP_RST | NET_TCP_ACK;
   36780:	2314      	movs	r3, #20
   36782:	f88d 3012 	strb.w	r3, [sp, #18]
		segment.seq = tcp->send_seq;
   36786:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   3678a:	9302      	str	r3, [sp, #8]
		if (!local) {
   3678c:	b97c      	cbnz	r4, 367ae <net_tcp_prepare_reset+0x64>
			segment.src_addr = &tcp->context->local;
   3678e:	f100 031c 	add.w	r3, r0, #28
   36792:	9306      	str	r3, [sp, #24]
		segment.wnd = 0U;
   36794:	2200      	movs	r2, #0
		status = prepare_segment(tcp, &segment, NULL, pkt);
   36796:	4633      	mov	r3, r6
   36798:	a902      	add	r1, sp, #8
		segment.dst_addr = remote;
   3679a:	9707      	str	r7, [sp, #28]
		segment.wnd = 0U;
   3679c:	f8ad 2010 	strh.w	r2, [sp, #16]
		segment.options = NULL;
   367a0:	9205      	str	r2, [sp, #20]
		segment.optlen = 0U;
   367a2:	f88d 2013 	strb.w	r2, [sp, #19]
		status = prepare_segment(tcp, &segment, NULL, pkt);
   367a6:	f7e7 f985 	bl	1dab4 <prepare_segment.isra.21>
}
   367aa:	b009      	add	sp, #36	; 0x24
   367ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
	(void)memset(addr, 0, sizeof(struct sockaddr_ptr));
   367ae:	2300      	movs	r3, #0
   367b0:	e9cd 3300 	strd	r3, r3, [sp]
	if (local->sa_family == AF_INET) {
   367b4:	8823      	ldrh	r3, [r4, #0]
   367b6:	2b01      	cmp	r3, #1
   367b8:	d106      	bne.n	367c8 <net_tcp_prepare_reset+0x7e>
		net_sin_ptr(addr)->sin_family = AF_INET;
   367ba:	f8ad 3000 	strh.w	r3, [sp]
		net_sin_ptr(addr)->sin_port = net_sin(local)->sin_port;
   367be:	8863      	ldrh	r3, [r4, #2]
		net_sin_ptr(addr)->sin_addr = &net_sin(local)->sin_addr;
   367c0:	3404      	adds	r4, #4
		net_sin_ptr(addr)->sin_port = net_sin(local)->sin_port;
   367c2:	f8ad 3002 	strh.w	r3, [sp, #2]
		net_sin_ptr(addr)->sin_addr = &net_sin(local)->sin_addr;
   367c6:	9401      	str	r4, [sp, #4]
			segment.src_addr = &src_addr_ptr;
   367c8:	f8cd d018 	str.w	sp, [sp, #24]
   367cc:	e7e2      	b.n	36794 <net_tcp_prepare_reset+0x4a>
	int status = 0;
   367ce:	2000      	movs	r0, #0
	return status;
   367d0:	e7eb      	b.n	367aa <net_tcp_prepare_reset+0x60>

000367d2 <send_reset.isra.29>:
	struct net_pkt *pkt = NULL;
   367d2:	2300      	movs	r3, #0
static int send_reset(struct net_context *context,
   367d4:	b513      	push	{r0, r1, r4, lr}
	struct net_pkt *pkt = NULL;
   367d6:	9301      	str	r3, [sp, #4]
	ret = net_tcp_prepare_reset(context->tcp, local, remote, &pkt);
   367d8:	ab01      	add	r3, sp, #4
   367da:	f7ff ffb6 	bl	3674a <net_tcp_prepare_reset>
	if (ret || !pkt) {
   367de:	4604      	mov	r4, r0
   367e0:	b978      	cbnz	r0, 36802 <send_reset.isra.29+0x30>
   367e2:	9801      	ldr	r0, [sp, #4]
   367e4:	b168      	cbz	r0, 36802 <send_reset.isra.29+0x30>
	ret = net_send_data(pkt);
   367e6:	f7fe fec8 	bl	3557a <net_send_data>
	if (ret < 0) {
   367ea:	1e04      	subs	r4, r0, #0
   367ec:	da02      	bge.n	367f4 <send_reset.isra.29+0x22>
		net_pkt_unref(pkt);
   367ee:	9801      	ldr	r0, [sp, #4]
   367f0:	f7ff fa72 	bl	35cd8 <net_pkt_unref>
	pkt->sent_or_eof = sent;
   367f4:	9a01      	ldr	r2, [sp, #4]
   367f6:	f892 303d 	ldrb.w	r3, [r2, #61]	; 0x3d
   367fa:	f043 0302 	orr.w	r3, r3, #2
   367fe:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
}
   36802:	4620      	mov	r0, r4
   36804:	b002      	add	sp, #8
   36806:	bd10      	pop	{r4, pc}

00036808 <backlog_ack_timeout>:
{
   36808:	b510      	push	{r4, lr}
	send_reset(backlog->tcp->context, NULL, &backlog->remote);
   3680a:	f850 3c0c 	ldr.w	r3, [r0, #-12]
   3680e:	f1a0 040c 	sub.w	r4, r0, #12
   36812:	681b      	ldr	r3, [r3, #0]
   36814:	f100 0220 	add.w	r2, r0, #32
   36818:	2100      	movs	r1, #0
   3681a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
   3681c:	f7ff ffd9 	bl	367d2 <send_reset.isra.29>
__ssp_bos_icheck3(memset, void *, int)
   36820:	4620      	mov	r0, r4
}
   36822:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   36826:	2238      	movs	r2, #56	; 0x38
   36828:	2100      	movs	r1, #0
   3682a:	f002 bc0f 	b.w	3904c <memset>

0003682e <net_tcp_send_pkt>:
{
   3682e:	b5f0      	push	{r4, r5, r6, r7, lr}
   36830:	b089      	sub	sp, #36	; 0x24
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36832:	ab03      	add	r3, sp, #12
   36834:	9301      	str	r3, [sp, #4]
   36836:	2314      	movs	r3, #20
	struct net_context *ctx = net_pkt_context(pkt);
   36838:	69c7      	ldr	r7, [r0, #28]
{
   3683a:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   3683c:	9302      	str	r3, [sp, #8]
	if (!ctx || !ctx->tcp) {
   3683e:	2f00      	cmp	r7, #0
   36840:	d075      	beq.n	3692e <net_tcp_send_pkt+0x100>
   36842:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   36844:	2b00      	cmp	r3, #0
   36846:	d072      	beq.n	3692e <net_tcp_send_pkt+0x100>
	net_pkt_cursor_init(pkt);
   36848:	f7ff faaa 	bl	35da0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
   3684c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
   36850:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
   36854:	f043 0301 	orr.w	r3, r3, #1
   36858:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
			 net_pkt_ip_opts_len(pkt))) {
   3685c:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
	if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
   36860:	4620      	mov	r0, r4
   36862:	4419      	add	r1, r3
   36864:	f7ff fb26 	bl	35eb4 <net_pkt_skip>
   36868:	4606      	mov	r6, r0
   3686a:	b118      	cbz	r0, 36874 <net_tcp_send_pkt+0x46>
		return -EMSGSIZE;
   3686c:	f06f 0079 	mvn.w	r0, #121	; 0x79
}
   36870:	b009      	add	sp, #36	; 0x24
   36872:	bdf0      	pop	{r4, r5, r6, r7, pc}
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   36874:	a901      	add	r1, sp, #4
   36876:	4620      	mov	r0, r4
   36878:	f7ff fc70 	bl	3615c <net_pkt_get_data>
	if (!tcp_hdr) {
   3687c:	4605      	mov	r5, r0
   3687e:	2800      	cmp	r0, #0
   36880:	d0f4      	beq.n	3686c <net_tcp_send_pkt+0x3e>
	if (sys_get_be32(tcp_hdr->ack) != ctx->tcp->send_ack) {
   36882:	3008      	adds	r0, #8
   36884:	f7ff fee8 	bl	36658 <sys_get_be32>
   36888:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   3688a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
   3688e:	4298      	cmp	r0, r3
   36890:	d00a      	beq.n	368a8 <net_tcp_send_pkt+0x7a>
		tcp_hdr->chksum = 0U;
   36892:	742e      	strb	r6, [r5, #16]
   36894:	746e      	strb	r6, [r5, #17]
		calc_chksum = true;
   36896:	2601      	movs	r6, #1
	sys_put_be16(val >> 16, dst);
   36898:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val >> 8;
   3689a:	0a11      	lsrs	r1, r2, #8
	dst[1] = val;
   3689c:	726a      	strb	r2, [r5, #9]
	dst[0] = val >> 8;
   3689e:	f3c3 2207 	ubfx	r2, r3, #8, #8
   368a2:	7229      	strb	r1, [r5, #8]
   368a4:	72aa      	strb	r2, [r5, #10]
	dst[1] = val;
   368a6:	72eb      	strb	r3, [r5, #11]
	if (ctx->tcp->sent_ack != ctx->tcp->send_ack &&
   368a8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   368aa:	e9d3 3225 	ldrd	r3, r2, [r3, #148]	; 0x94
   368ae:	429a      	cmp	r2, r3
   368b0:	d009      	beq.n	368c6 <net_tcp_send_pkt+0x98>
		(tcp_hdr->flags & NET_TCP_ACK) == 0U) {
   368b2:	7b6b      	ldrb	r3, [r5, #13]
	if (ctx->tcp->sent_ack != ctx->tcp->send_ack &&
   368b4:	f013 0210 	ands.w	r2, r3, #16
   368b8:	d105      	bne.n	368c6 <net_tcp_send_pkt+0x98>
		calc_chksum = true;
   368ba:	2601      	movs	r6, #1
		tcp_hdr->flags |= NET_TCP_ACK;
   368bc:	f043 0310 	orr.w	r3, r3, #16
   368c0:	736b      	strb	r3, [r5, #13]
		tcp_hdr->chksum = 0U;
   368c2:	742a      	strb	r2, [r5, #16]
   368c4:	746a      	strb	r2, [r5, #17]
	net_pkt_set_data(pkt, &tcp_access);
   368c6:	a901      	add	r1, sp, #4
   368c8:	4620      	mov	r0, r4
   368ca:	f7ff fc68 	bl	3619e <net_pkt_set_data>
	if (calc_chksum) {
   368ce:	b19e      	cbz	r6, 368f8 <net_tcp_send_pkt+0xca>
		net_pkt_cursor_init(pkt);
   368d0:	4620      	mov	r0, r4
   368d2:	f7ff fa65 	bl	35da0 <net_pkt_cursor_init>
			     net_pkt_ip_opts_len(pkt));
   368d6:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
		net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
   368da:	f894 103c 	ldrb.w	r1, [r4, #60]	; 0x3c
   368de:	4620      	mov	r0, r4
   368e0:	4419      	add	r1, r3
   368e2:	f7ff fae7 	bl	35eb4 <net_pkt_skip>
	return net_calc_chksum(pkt, IPPROTO_UDP);
}

static inline u16_t net_calc_chksum_tcp(struct net_pkt *pkt)
{
	return net_calc_chksum(pkt, IPPROTO_TCP);
   368e6:	2106      	movs	r1, #6
   368e8:	4620      	mov	r0, r4
   368ea:	f7fe ff91 	bl	35810 <net_calc_chksum>
		net_pkt_set_data(pkt, &tcp_access);
   368ee:	a901      	add	r1, sp, #4
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
   368f0:	8228      	strh	r0, [r5, #16]
		net_pkt_set_data(pkt, &tcp_access);
   368f2:	4620      	mov	r0, r4
   368f4:	f7ff fc53 	bl	3619e <net_pkt_set_data>
	if (tcp_hdr->flags & NET_TCP_FIN) {
   368f8:	7b6a      	ldrb	r2, [r5, #13]
   368fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   368fc:	07d2      	lsls	r2, r2, #31
		ctx->tcp->fin_sent = 1U;
   368fe:	bf48      	it	mi
   36900:	f893 20be 	ldrbmi.w	r2, [r3, #190]	; 0xbe
	ret = net_send_data(pkt);
   36904:	4620      	mov	r0, r4
		ctx->tcp->fin_sent = 1U;
   36906:	bf44      	itt	mi
   36908:	f042 0202 	orrmi.w	r2, r2, #2
   3690c:	f883 20be 	strbmi.w	r2, [r3, #190]	; 0xbe
	ctx->tcp->sent_ack = ctx->tcp->send_ack;
   36910:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
   36914:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	ret = net_send_data(pkt);
   36918:	f7fe fe2f 	bl	3557a <net_send_data>
	if (ret == 0) {
   3691c:	2800      	cmp	r0, #0
   3691e:	d1a7      	bne.n	36870 <net_tcp_send_pkt+0x42>
	pkt->sent_or_eof = sent;
   36920:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
   36924:	f043 0302 	orr.w	r3, r3, #2
   36928:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
   3692c:	e7a0      	b.n	36870 <net_tcp_send_pkt+0x42>
		return -EINVAL;
   3692e:	f06f 0015 	mvn.w	r0, #21
   36932:	e79d      	b.n	36870 <net_tcp_send_pkt+0x42>

00036934 <tcp_retry_expired>:
	if (!sys_slist_is_empty(&tcp->sent_list)) {
   36934:	6c03      	ldr	r3, [r0, #64]	; 0x40
{
   36936:	b573      	push	{r0, r1, r4, r5, r6, lr}
   36938:	4604      	mov	r4, r0
	if (!sys_slist_is_empty(&tcp->sent_list)) {
   3693a:	2b00      	cmp	r3, #0
   3693c:	d043      	beq.n	369c6 <tcp_retry_expired+0x92>
		tcp->retry_timeout_shift++;
   3693e:	f890 2074 	ldrb.w	r2, [r0, #116]	; 0x74
   36942:	1c53      	adds	r3, r2, #1
   36944:	f003 031f 	and.w	r3, r3, #31
   36948:	f363 0204 	bfi	r2, r3, #0, #5
		if (tcp->retry_timeout_shift > CONFIG_NET_TCP_RETRY_COUNT) {
   3694c:	2b09      	cmp	r3, #9
		tcp->retry_timeout_shift++;
   3694e:	f880 2074 	strb.w	r2, [r0, #116]	; 0x74
		if (tcp->retry_timeout_shift > CONFIG_NET_TCP_RETRY_COUNT) {
   36952:	d914      	bls.n	3697e <tcp_retry_expired+0x4a>
	struct net_context *ctx = tcp->context;
   36954:	f850 5c48 	ldr.w	r5, [r0, #-72]
	if (ctx->recv_cb) {
   36958:	6b2e      	ldr	r6, [r5, #48]	; 0x30
   3695a:	b156      	cbz	r6, 36972 <tcp_retry_expired+0x3e>
		ctx->recv_cb(ctx, NULL, NULL, NULL, -ECONNRESET,
   3695c:	f850 3c44 	ldr.w	r3, [r0, #-68]
   36960:	4628      	mov	r0, r5
   36962:	9301      	str	r3, [sp, #4]
   36964:	f06f 0367 	mvn.w	r3, #103	; 0x67
   36968:	9300      	str	r3, [sp, #0]
   3696a:	2300      	movs	r3, #0
   3696c:	461a      	mov	r2, r3
   3696e:	4619      	mov	r1, r3
   36970:	47b0      	blx	r6
	net_context_unref(ctx);
   36972:	4628      	mov	r0, r5
}
   36974:	b002      	add	sp, #8
   36976:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_context_unref(tcp->context);
   3697a:	f7ff b816 	b.w	359aa <net_context_unref>
		k_delayed_work_submit(&tcp->retry_timer, retry_timeout(tcp));
   3697e:	21c8      	movs	r1, #200	; 0xc8
   36980:	4099      	lsls	r1, r3
   36982:	f7e6 ffc3 	bl	1d90c <k_delayed_work_submit>
		pkt = CONTAINER_OF(sys_slist_peek_head(&tcp->sent_list),
   36986:	6c23      	ldr	r3, [r4, #64]	; 0x40
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   36988:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
   3698c:	e8d2 2faf 	lda	r2, [r2]
		if (k_work_pending(net_pkt_work(pkt))) {
   36990:	f012 0201 	ands.w	r2, r2, #1
   36994:	d120      	bne.n	369d8 <tcp_retry_expired+0xa4>
	pkt->pkt_queued = send;
   36996:	7999      	ldrb	r1, [r3, #6]
		pkt = CONTAINER_OF(sys_slist_peek_head(&tcp->sent_list),
   36998:	f1a3 0438 	sub.w	r4, r3, #56	; 0x38
   3699c:	f041 0101 	orr.w	r1, r1, #1
   369a0:	7199      	strb	r1, [r3, #6]
	pkt->tcp_first_msg = is_1st;
   369a2:	7a59      	ldrb	r1, [r3, #9]
			net_pkt_ref(pkt);
   369a4:	4620      	mov	r0, r4
   369a6:	f362 0100 	bfi	r1, r2, #0, #1
   369aa:	7259      	strb	r1, [r3, #9]
   369ac:	f7ff f97b 	bl	35ca6 <net_pkt_ref>
		if (net_tcp_send_pkt(pkt) < 0 && !is_6lo_technology(pkt)) {
   369b0:	4620      	mov	r0, r4
   369b2:	f7ff ff3c 	bl	3682e <net_tcp_send_pkt>
   369b6:	2800      	cmp	r0, #0
   369b8:	da0e      	bge.n	369d8 <tcp_retry_expired+0xa4>
			net_pkt_unref(pkt);
   369ba:	4620      	mov	r0, r4
}
   369bc:	b002      	add	sp, #8
   369be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			net_pkt_unref(pkt);
   369c2:	f7ff b989 	b.w	35cd8 <net_pkt_unref>
		if (tcp->fin_sent && tcp->fin_rcvd) {
   369c6:	f890 3076 	ldrb.w	r3, [r0, #118]	; 0x76
   369ca:	f003 0306 	and.w	r3, r3, #6
   369ce:	2b06      	cmp	r3, #6
   369d0:	d102      	bne.n	369d8 <tcp_retry_expired+0xa4>
			net_context_unref(tcp->context);
   369d2:	f850 0c48 	ldr.w	r0, [r0, #-72]
   369d6:	e7cd      	b.n	36974 <tcp_retry_expired+0x40>
}
   369d8:	b002      	add	sp, #8
   369da:	bd70      	pop	{r4, r5, r6, pc}

000369dc <net_tcp_send_data>:
{
   369dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   369e0:	4680      	mov	r8, r0
   369e2:	460e      	mov	r6, r1
   369e4:	4617      	mov	r7, r2
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, pkt, sent_list) {
   369e6:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   369e8:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
   369ec:	b984      	cbnz	r4, 36a10 <net_tcp_send_data+0x34>
	if (cb) {
   369ee:	bb46      	cbnz	r6, 36a42 <net_tcp_send_data+0x66>
		cb(context, 0, user_data);
   369f0:	2500      	movs	r5, #0
   369f2:	e023      	b.n	36a3c <net_tcp_send_data+0x60>
	pkt->pkt_queued = send;
   369f4:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
   369f8:	f043 0301 	orr.w	r3, r3, #1
   369fc:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
	pkt->tcp_first_msg = is_1st;
   36a00:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   36a04:	f36f 0300 	bfc	r3, #0, #1
   36a08:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   36a0c:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	return node->next;
   36a0e:	e7ed      	b.n	369ec <net_tcp_send_data+0x10>
	SYS_SLIST_FOR_EACH_CONTAINER(&context->tcp->sent_list, pkt, sent_list) {
   36a10:	3c38      	subs	r4, #56	; 0x38
   36a12:	2c00      	cmp	r4, #0
   36a14:	d0eb      	beq.n	369ee <net_tcp_send_data+0x12>
	return pkt->pkt_queued;
   36a16:	f894 303e 	ldrb.w	r3, [r4, #62]	; 0x3e
		if (net_pkt_queued(pkt)) {
   36a1a:	07da      	lsls	r2, r3, #31
   36a1c:	d4f6      	bmi.n	36a0c <net_tcp_send_data+0x30>
	return pkt->tcp_first_msg;
   36a1e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
			if (!net_pkt_tcp_1st_msg(pkt)) {
   36a22:	07db      	lsls	r3, r3, #31
   36a24:	d402      	bmi.n	36a2c <net_tcp_send_data+0x50>
				net_pkt_ref(pkt);
   36a26:	4620      	mov	r0, r4
   36a28:	f7ff f93d 	bl	35ca6 <net_pkt_ref>
		ret = net_tcp_send_pkt(pkt);
   36a2c:	4620      	mov	r0, r4
   36a2e:	f7ff fefe 	bl	3682e <net_tcp_send_pkt>
		if (ret < 0) {
   36a32:	1e05      	subs	r5, r0, #0
   36a34:	dade      	bge.n	369f4 <net_tcp_send_data+0x18>
				net_pkt_unref(pkt);
   36a36:	4620      	mov	r0, r4
   36a38:	f7ff f94e 	bl	35cd8 <net_pkt_unref>
}
   36a3c:	4628      	mov	r0, r5
   36a3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cb(context, 0, user_data);
   36a42:	463a      	mov	r2, r7
   36a44:	2100      	movs	r1, #0
   36a46:	4640      	mov	r0, r8
   36a48:	47b0      	blx	r6
   36a4a:	e7d1      	b.n	369f0 <net_tcp_send_data+0x14>

00036a4c <net_tcp_init>:
}
   36a4c:	4770      	bx	lr

00036a4e <net_tcp_prepare_segment>:
{
   36a4e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   36a52:	b087      	sub	sp, #28
   36a54:	9e0e      	ldr	r6, [sp, #56]	; 0x38
   36a56:	4604      	mov	r4, r0
   36a58:	460d      	mov	r5, r1
   36a5a:	4691      	mov	r9, r2
	struct tcp_segment segment = { 0 };
   36a5c:	2100      	movs	r1, #0
   36a5e:	2218      	movs	r2, #24
   36a60:	4668      	mov	r0, sp
{
   36a62:	4698      	mov	r8, r3
	struct tcp_segment segment = { 0 };
   36a64:	f002 faf2 	bl	3904c <memset>
	if (!local) {
   36a68:	b90e      	cbnz	r6, 36a6e <net_tcp_prepare_segment+0x20>
		local = &tcp->context->local;
   36a6a:	6826      	ldr	r6, [r4, #0]
   36a6c:	361c      	adds	r6, #28
	if (flags & NET_TCP_ACK) {
   36a6e:	06e9      	lsls	r1, r5, #27
	seq = tcp->send_seq;
   36a70:	f8d4 7090 	ldr.w	r7, [r4, #144]	; 0x90
	if (flags & NET_TCP_ACK) {
   36a74:	d50f      	bpl.n	36a96 <net_tcp_prepare_segment+0x48>
   36a76:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
   36a7a:	f3c3 3343 	ubfx	r3, r3, #13, #4
		if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_1) {
   36a7e:	2b07      	cmp	r3, #7
   36a80:	d13d      	bne.n	36afe <net_tcp_prepare_segment+0xb0>
			if (flags & NET_TCP_FIN) {
   36a82:	07ea      	lsls	r2, r5, #31
   36a84:	d503      	bpl.n	36a8e <net_tcp_prepare_segment+0x40>
				flags &= ~NET_TCP_FIN;
   36a86:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
			net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
   36a8a:	2109      	movs	r1, #9
   36a8c:	e000      	b.n	36a90 <net_tcp_prepare_segment+0x42>
				net_tcp_change_state(tcp, NET_TCP_CLOSING);
   36a8e:	210a      	movs	r1, #10
			net_tcp_change_state(tcp, NET_TCP_LAST_ACK);
   36a90:	4620      	mov	r0, r4
   36a92:	f7e7 f96b 	bl	1dd6c <net_tcp_change_state>
	if (flags & NET_TCP_FIN) {
   36a96:	07eb      	lsls	r3, r5, #31
   36a98:	d510      	bpl.n	36abc <net_tcp_prepare_segment+0x6e>
   36a9a:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc
		flags |= NET_TCP_ACK;
   36a9e:	f045 0510 	orr.w	r5, r5, #16
   36aa2:	f3c3 3343 	ubfx	r3, r3, #13, #4
		if (net_tcp_get_state(tcp) == NET_TCP_ESTABLISHED ||
   36aa6:	330d      	adds	r3, #13
   36aa8:	f003 030f 	and.w	r3, r3, #15
   36aac:	2b01      	cmp	r3, #1
		seq++;
   36aae:	f107 0701 	add.w	r7, r7, #1
		if (net_tcp_get_state(tcp) == NET_TCP_ESTABLISHED ||
   36ab2:	d803      	bhi.n	36abc <net_tcp_prepare_segment+0x6e>
			net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_1);
   36ab4:	2107      	movs	r1, #7
   36ab6:	4620      	mov	r0, r4
   36ab8:	f7e7 f958 	bl	1dd6c <net_tcp_change_state>
	segment.dst_addr = remote;
   36abc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
	return tcp->recv_wnd;
   36abe:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	; 0xb8
	segment.dst_addr = remote;
   36ac2:	9205      	str	r2, [sp, #20]
	segment.seq = tcp->send_seq;
   36ac4:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
	segment.wnd = wnd;
   36ac8:	f8ad 3008 	strh.w	r3, [sp, #8]
	segment.seq = tcp->send_seq;
   36acc:	9200      	str	r2, [sp, #0]
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   36ace:	9b10      	ldr	r3, [sp, #64]	; 0x40
	segment.ack = tcp->send_ack;
   36ad0:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   36ad4:	4669      	mov	r1, sp
	segment.ack = tcp->send_ack;
   36ad6:	9201      	str	r2, [sp, #4]
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   36ad8:	6820      	ldr	r0, [r4, #0]
   36ada:	681a      	ldr	r2, [r3, #0]
	segment.src_addr = (struct sockaddr_ptr *)local;
   36adc:	9604      	str	r6, [sp, #16]
	segment.flags = flags;
   36ade:	f88d 500a 	strb.w	r5, [sp, #10]
	segment.options = options;
   36ae2:	f8cd 900c 	str.w	r9, [sp, #12]
	segment.optlen = optlen;
   36ae6:	f88d 800b 	strb.w	r8, [sp, #11]
	status = prepare_segment(tcp, &segment, *send_pkt, send_pkt);
   36aea:	f7e6 ffe3 	bl	1dab4 <prepare_segment.isra.21>
	if (status < 0) {
   36aee:	2800      	cmp	r0, #0
	return 0;
   36af0:	bfa4      	itt	ge
   36af2:	2000      	movge	r0, #0
	tcp->send_seq = seq;
   36af4:	f8c4 7090 	strge.w	r7, [r4, #144]	; 0x90
}
   36af8:	b007      	add	sp, #28
   36afa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		} else if (net_tcp_get_state(tcp) == NET_TCP_FIN_WAIT_2) {
   36afe:	2b08      	cmp	r3, #8
   36b00:	d0c3      	beq.n	36a8a <net_tcp_prepare_segment+0x3c>
		} else if (net_tcp_get_state(tcp) == NET_TCP_CLOSE_WAIT) {
   36b02:	2b05      	cmp	r3, #5
   36b04:	d1c7      	bne.n	36a96 <net_tcp_prepare_segment+0x48>
			tcp->flags |= NET_TCP_IS_SHUTDOWN;
   36b06:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
			flags |= NET_TCP_FIN;
   36b0a:	f045 0501 	orr.w	r5, r5, #1
			tcp->flags |= NET_TCP_IS_SHUTDOWN;
   36b0e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   36b12:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
			net_tcp_change_state(tcp, NET_TCP_LAST_ACK);
   36b16:	2106      	movs	r1, #6
   36b18:	e7ba      	b.n	36a90 <net_tcp_prepare_segment+0x42>

00036b1a <net_tcp_prepare_ack>:
{
   36b1a:	b570      	push	{r4, r5, r6, lr}
   36b1c:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc
   36b20:	b088      	sub	sp, #32
   36b22:	f3c3 3343 	ubfx	r3, r3, #13, #4
	switch (net_tcp_get_state(tcp)) {
   36b26:	2b03      	cmp	r3, #3
{
   36b28:	4604      	mov	r4, r0
   36b2a:	460d      	mov	r5, r1
   36b2c:	4616      	mov	r6, r2
	switch (net_tcp_get_state(tcp)) {
   36b2e:	d00c      	beq.n	36b4a <net_tcp_prepare_ack+0x30>
   36b30:	d304      	bcc.n	36b3c <net_tcp_prepare_ack+0x22>
   36b32:	330a      	adds	r3, #10
   36b34:	f003 030f 	and.w	r3, r3, #15
   36b38:	2b01      	cmp	r3, #1
   36b3a:	d915      	bls.n	36b68 <net_tcp_prepare_ack+0x4e>
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   36b3c:	2300      	movs	r3, #0
   36b3e:	e9cd 5601 	strd	r5, r6, [sp, #4]
   36b42:	9300      	str	r3, [sp, #0]
   36b44:	461a      	mov	r2, r3
   36b46:	2110      	movs	r1, #16
   36b48:	e00c      	b.n	36b64 <net_tcp_prepare_ack+0x4a>
		net_tcp_set_syn_opt(tcp, options, &optionlen);
   36b4a:	f10d 0217 	add.w	r2, sp, #23
   36b4e:	a906      	add	r1, sp, #24
   36b50:	f7ff fdd6 	bl	36700 <net_tcp_set_syn_opt>
		return net_tcp_prepare_segment(tcp, NET_TCP_SYN | NET_TCP_ACK,
   36b54:	2300      	movs	r3, #0
   36b56:	2112      	movs	r1, #18
   36b58:	e9cd 5601 	strd	r5, r6, [sp, #4]
   36b5c:	9300      	str	r3, [sp, #0]
   36b5e:	f89d 3017 	ldrb.w	r3, [sp, #23]
   36b62:	aa06      	add	r2, sp, #24
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   36b64:	4620      	mov	r0, r4
   36b66:	e005      	b.n	36b74 <net_tcp_prepare_ack+0x5a>
		return net_tcp_prepare_segment(tcp, NET_TCP_FIN | NET_TCP_ACK,
   36b68:	2300      	movs	r3, #0
   36b6a:	e9cd 1201 	strd	r1, r2, [sp, #4]
   36b6e:	461a      	mov	r2, r3
   36b70:	2111      	movs	r1, #17
   36b72:	9300      	str	r3, [sp, #0]
		return net_tcp_prepare_segment(tcp, NET_TCP_ACK, 0, 0, NULL,
   36b74:	f7ff ff6b 	bl	36a4e <net_tcp_prepare_segment>
}
   36b78:	b008      	add	sp, #32
   36b7a:	bd70      	pop	{r4, r5, r6, pc}

00036b7c <send_ack.isra.34>:
	struct net_pkt *pkt = NULL;
   36b7c:	2300      	movs	r3, #0
static int send_ack(struct net_context *context,
   36b7e:	b513      	push	{r0, r1, r4, lr}
	struct net_pkt *pkt = NULL;
   36b80:	9301      	str	r3, [sp, #4]
	if (!force && context->tcp->send_ack == context->tcp->sent_ack) {
   36b82:	b91a      	cbnz	r2, 36b8c <send_ack.isra.34+0x10>
   36b84:	e9d0 4325 	ldrd	r4, r3, [r0, #148]	; 0x94
   36b88:	429c      	cmp	r4, r3
   36b8a:	d00f      	beq.n	36bac <send_ack.isra.34+0x30>
	ret = net_tcp_prepare_ack(context->tcp, remote, &pkt);
   36b8c:	aa01      	add	r2, sp, #4
   36b8e:	f7ff ffc4 	bl	36b1a <net_tcp_prepare_ack>
	if (ret) {
   36b92:	4604      	mov	r4, r0
   36b94:	b938      	cbnz	r0, 36ba6 <send_ack.isra.34+0x2a>
	ret = net_tcp_send_pkt(pkt);
   36b96:	9801      	ldr	r0, [sp, #4]
   36b98:	f7ff fe49 	bl	3682e <net_tcp_send_pkt>
	if (ret < 0) {
   36b9c:	1e04      	subs	r4, r0, #0
   36b9e:	da02      	bge.n	36ba6 <send_ack.isra.34+0x2a>
		net_pkt_unref(pkt);
   36ba0:	9801      	ldr	r0, [sp, #4]
   36ba2:	f7ff f899 	bl	35cd8 <net_pkt_unref>
}
   36ba6:	4620      	mov	r0, r4
   36ba8:	b002      	add	sp, #8
   36baa:	bd10      	pop	{r4, pc}
		return 0;
   36bac:	4614      	mov	r4, r2
   36bae:	e7fa      	b.n	36ba6 <send_ack.isra.34+0x2a>

00036bb0 <send_syn_segment.isra.35>:
static inline int send_syn_segment(struct net_context *context,
   36bb0:	b5f0      	push	{r4, r5, r6, r7, lr}
   36bb2:	461c      	mov	r4, r3
	struct net_pkt *pkt = NULL;
   36bb4:	2300      	movs	r3, #0
static inline int send_syn_segment(struct net_context *context,
   36bb6:	b089      	sub	sp, #36	; 0x24
	if (flags == NET_TCP_SYN) {
   36bb8:	2c02      	cmp	r4, #2
static inline int send_syn_segment(struct net_context *context,
   36bba:	4605      	mov	r5, r0
   36bbc:	460e      	mov	r6, r1
   36bbe:	4617      	mov	r7, r2
	struct net_pkt *pkt = NULL;
   36bc0:	9305      	str	r3, [sp, #20]
	u8_t optionlen = 0U;
   36bc2:	f88d 3013 	strb.w	r3, [sp, #19]
	if (flags == NET_TCP_SYN) {
   36bc6:	d105      	bne.n	36bd4 <send_syn_segment.isra.35+0x24>
		net_tcp_set_syn_opt(context->tcp, options, &optionlen);
   36bc8:	f10d 0213 	add.w	r2, sp, #19
   36bcc:	a906      	add	r1, sp, #24
   36bce:	6800      	ldr	r0, [r0, #0]
   36bd0:	f7ff fd96 	bl	36700 <net_tcp_set_syn_opt>
	ret = net_tcp_prepare_segment(context->tcp, flags, options, optionlen,
   36bd4:	ab05      	add	r3, sp, #20
   36bd6:	e9cd 7301 	strd	r7, r3, [sp, #4]
   36bda:	b2e1      	uxtb	r1, r4
   36bdc:	9600      	str	r6, [sp, #0]
   36bde:	f89d 3013 	ldrb.w	r3, [sp, #19]
   36be2:	aa06      	add	r2, sp, #24
   36be4:	6828      	ldr	r0, [r5, #0]
   36be6:	f7ff ff32 	bl	36a4e <net_tcp_prepare_segment>
	if (ret) {
   36bea:	4604      	mov	r4, r0
   36bec:	b938      	cbnz	r0, 36bfe <send_syn_segment.isra.35+0x4e>
	ret = net_send_data(pkt);
   36bee:	9805      	ldr	r0, [sp, #20]
   36bf0:	f7fe fcc3 	bl	3557a <net_send_data>
	if (ret < 0) {
   36bf4:	1e04      	subs	r4, r0, #0
   36bf6:	da05      	bge.n	36c04 <send_syn_segment.isra.35+0x54>
		net_pkt_unref(pkt);
   36bf8:	9805      	ldr	r0, [sp, #20]
   36bfa:	f7ff f86d 	bl	35cd8 <net_pkt_unref>
}
   36bfe:	4620      	mov	r0, r4
   36c00:	b009      	add	sp, #36	; 0x24
   36c02:	bdf0      	pop	{r4, r5, r6, r7, pc}
	pkt->sent_or_eof = sent;
   36c04:	9a05      	ldr	r2, [sp, #20]
   36c06:	f892 303d 	ldrb.w	r3, [r2, #61]	; 0x3d
   36c0a:	f043 0302 	orr.w	r3, r3, #2
   36c0e:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
	context->tcp->send_seq++;
   36c12:	682a      	ldr	r2, [r5, #0]
   36c14:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   36c18:	3301      	adds	r3, #1
   36c1a:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
	return ret;
   36c1e:	e7ee      	b.n	36bfe <send_syn_segment.isra.35+0x4e>

00036c20 <net_tcp_ack_received>:
{
   36c20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct net_tcp *tcp = ctx->tcp;
   36c24:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
{
   36c26:	b08b      	sub	sp, #44	; 0x2c
	return (s32_t)(seq1 - seq2);
   36c28:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
   36c2c:	4680      	mov	r8, r0
   36c2e:	1acb      	subs	r3, r1, r3
	if (net_tcp_seq_greater(ack, ctx->tcp->send_seq)) {
   36c30:	2b00      	cmp	r3, #0
{
   36c32:	4689      	mov	r9, r1
		return false;
   36c34:	f04f 0700 	mov.w	r7, #0
	if (net_tcp_seq_greater(ack, ctx->tcp->send_seq)) {
   36c38:	dc22      	bgt.n	36c80 <net_tcp_ack_received+0x60>
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36c3a:	f04f 0b14 	mov.w	fp, #20
Z_GENLIST_IS_EMPTY(slist)
   36c3e:	f8d5 4088 	ldr.w	r4, [r5, #136]	; 0x88
	while (!sys_slist_is_empty(list)) {
   36c42:	bb0c      	cbnz	r4, 36c88 <net_tcp_ack_received+0x68>
	if (valid_ack) {
   36c44:	2f00      	cmp	r7, #0
   36c46:	f000 80a6 	beq.w	36d96 <net_tcp_ack_received+0x176>
		restart_timer(ctx->tcp);
   36c4a:	f8d8 403c 	ldr.w	r4, [r8, #60]	; 0x3c
	if (!sys_slist_is_empty(&tcp->sent_list)) {
   36c4e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
   36c52:	f104 0048 	add.w	r0, r4, #72	; 0x48
   36c56:	2b00      	cmp	r3, #0
   36c58:	f000 8083 	beq.w	36d62 <net_tcp_ack_received+0x142>
		tcp->flags |= NET_TCP_RETRYING;
   36c5c:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
		k_delayed_work_submit(&tcp->retry_timer, retry_timeout(tcp));
   36c60:	21c8      	movs	r1, #200	; 0xc8
		tcp->flags |= NET_TCP_RETRYING;
   36c62:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   36c66:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
		tcp->retry_timeout_shift = 0U;
   36c6a:	f36f 0304 	bfc	r3, #0, #5
   36c6e:	f884 30bc 	strb.w	r3, [r4, #188]	; 0xbc
		k_delayed_work_submit(&tcp->retry_timer, retry_timeout(tcp));
   36c72:	f7e6 fe4b 	bl	1d90c <k_delayed_work_submit>
	(void)net_tcp_send_data(context, NULL, NULL);
   36c76:	2200      	movs	r2, #0
   36c78:	4640      	mov	r0, r8
   36c7a:	4611      	mov	r1, r2
   36c7c:	f7ff feae 	bl	369dc <net_tcp_send_data>
}
   36c80:	4638      	mov	r0, r7
   36c82:	b00b      	add	sp, #44	; 0x2c
   36c84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		pkt = CONTAINER_OF(head, struct net_pkt, sent_list);
   36c88:	f1a4 0638 	sub.w	r6, r4, #56	; 0x38
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36c8c:	ab05      	add	r3, sp, #20
		net_pkt_cursor_init(pkt);
   36c8e:	4630      	mov	r0, r6
		NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36c90:	e9cd 3b03 	strd	r3, fp, [sp, #12]
		net_pkt_cursor_init(pkt);
   36c94:	f7ff f884 	bl	35da0 <net_pkt_cursor_init>
	pkt->overwrite = overwrite;
   36c98:	7963      	ldrb	r3, [r4, #5]
		if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
   36c9a:	7921      	ldrb	r1, [r4, #4]
   36c9c:	f043 0301 	orr.w	r3, r3, #1
   36ca0:	7163      	strb	r3, [r4, #5]
				 net_pkt_ip_opts_len(pkt))) {
   36ca2:	7ae3      	ldrb	r3, [r4, #11]
		if (net_pkt_skip(pkt, net_pkt_ip_hdr_len(pkt) +
   36ca4:	4630      	mov	r0, r6
   36ca6:	4419      	add	r1, r3
   36ca8:	f7ff f904 	bl	35eb4 <net_pkt_skip>
   36cac:	b170      	cbz	r0, 36ccc <net_tcp_ack_received+0xac>
Z_GENLIST_REMOVE(slist, snode)
   36cae:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
   36cb2:	6823      	ldr	r3, [r4, #0]
   36cb4:	4294      	cmp	r4, r2
	list->head = node;
   36cb6:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	list->tail = node;
   36cba:	bf08      	it	eq
   36cbc:	f8c5 308c 	streq.w	r3, [r5, #140]	; 0x8c
	parent->next = child;
   36cc0:	2300      	movs	r3, #0
			net_pkt_unref(pkt);
   36cc2:	4630      	mov	r0, r6
   36cc4:	6023      	str	r3, [r4, #0]
   36cc6:	f7ff f807 	bl	35cd8 <net_pkt_unref>
			continue;
   36cca:	e7b8      	b.n	36c3e <net_tcp_ack_received+0x1e>
		tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt,
   36ccc:	a903      	add	r1, sp, #12
   36cce:	4630      	mov	r0, r6
   36cd0:	f7ff fa44 	bl	3615c <net_pkt_get_data>
		if (!tcp_hdr) {
   36cd4:	2800      	cmp	r0, #0
   36cd6:	d0ea      	beq.n	36cae <net_tcp_ack_received+0x8e>
	return net_pkt_skip(pkt, access->size);
   36cd8:	9904      	ldr	r1, [sp, #16]
   36cda:	9001      	str	r0, [sp, #4]
   36cdc:	4630      	mov	r0, r6
   36cde:	f7ff f8e9 	bl	35eb4 <net_pkt_skip>
		seq_len = net_pkt_remaining_data(pkt);
   36ce2:	4630      	mov	r0, r6
   36ce4:	f7ff f960 	bl	35fa8 <net_pkt_remaining_data>
   36ce8:	4682      	mov	sl, r0
		if (tcp_hdr->flags & NET_TCP_SYN) {
   36cea:	9a01      	ldr	r2, [sp, #4]
   36cec:	7b53      	ldrb	r3, [r2, #13]
   36cee:	0799      	lsls	r1, r3, #30
			seq_len += 1U;
   36cf0:	bf48      	it	mi
   36cf2:	f100 0a01 	addmi.w	sl, r0, #1
		if (tcp_hdr->flags & NET_TCP_FIN) {
   36cf6:	f013 0301 	ands.w	r3, r3, #1
		last_seq = sys_get_be32(tcp_hdr->seq) + seq_len - 1;
   36cfa:	f102 0004 	add.w	r0, r2, #4
			seq_len += 1U;
   36cfe:	bf18      	it	ne
   36d00:	f10a 0a01 	addne.w	sl, sl, #1
   36d04:	9301      	str	r3, [sp, #4]
		last_seq = sys_get_be32(tcp_hdr->seq) + seq_len - 1;
   36d06:	f7ff fca7 	bl	36658 <sys_get_be32>
   36d0a:	f109 0201 	add.w	r2, r9, #1
   36d0e:	1a10      	subs	r0, r2, r0
   36d10:	eba0 010a 	sub.w	r1, r0, sl
		if (!net_tcp_seq_greater(ack, last_seq)) {
   36d14:	2900      	cmp	r1, #0
   36d16:	dd95      	ble.n	36c44 <net_tcp_ack_received+0x24>
		if (tcp_hdr->flags & NET_TCP_FIN) {
   36d18:	9b01      	ldr	r3, [sp, #4]
   36d1a:	b14b      	cbz	r3, 36d30 <net_tcp_ack_received+0x110>
   36d1c:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
   36d20:	f3c3 3343 	ubfx	r3, r3, #13, #4
			if (s == NET_TCP_FIN_WAIT_1) {
   36d24:	2b07      	cmp	r3, #7
   36d26:	d118      	bne.n	36d5a <net_tcp_ack_received+0x13a>
				net_tcp_change_state(tcp, NET_TCP_FIN_WAIT_2);
   36d28:	2108      	movs	r1, #8
				net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
   36d2a:	4628      	mov	r0, r5
   36d2c:	f7e7 f81e 	bl	1dd6c <net_tcp_change_state>
Z_GENLIST_REMOVE(slist, snode)
   36d30:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
   36d34:	6823      	ldr	r3, [r4, #0]
   36d36:	4294      	cmp	r4, r2
	parent->next = child;
   36d38:	f04f 0200 	mov.w	r2, #0
	list->head = node;
   36d3c:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
	list->tail = node;
   36d40:	bf08      	it	eq
   36d42:	f8c5 308c 	streq.w	r3, [r5, #140]	; 0x8c
	pkt->sent_or_eof = sent;
   36d46:	7963      	ldrb	r3, [r4, #5]
	parent->next = child;
   36d48:	6022      	str	r2, [r4, #0]
   36d4a:	f362 0341 	bfi	r3, r2, #1, #1
   36d4e:	7163      	strb	r3, [r4, #5]
		net_pkt_unref(pkt);
   36d50:	4630      	mov	r0, r6
   36d52:	f7fe ffc1 	bl	35cd8 <net_pkt_unref>
		valid_ack = true;
   36d56:	2701      	movs	r7, #1
   36d58:	e771      	b.n	36c3e <net_tcp_ack_received+0x1e>
			} else if (s == NET_TCP_CLOSING) {
   36d5a:	2b0a      	cmp	r3, #10
   36d5c:	d1e8      	bne.n	36d30 <net_tcp_ack_received+0x110>
				net_tcp_change_state(tcp, NET_TCP_TIME_WAIT);
   36d5e:	2109      	movs	r1, #9
   36d60:	e7e3      	b.n	36d2a <net_tcp_ack_received+0x10a>
			(tcp->fin_sent && tcp->fin_rcvd)) {
   36d62:	f894 30be 	ldrb.w	r3, [r4, #190]	; 0xbe
	} else if (CONFIG_NET_TCP_TIME_WAIT_DELAY != 0 &&
   36d66:	f003 0306 	and.w	r3, r3, #6
   36d6a:	2b06      	cmp	r3, #6
   36d6c:	d106      	bne.n	36d7c <net_tcp_ack_received+0x15c>
		k_delayed_work_submit(&tcp->retry_timer,
   36d6e:	21fa      	movs	r1, #250	; 0xfa
   36d70:	f7e6 fdcc 	bl	1d90c <k_delayed_work_submit>
		net_context_ref(tcp->context);
   36d74:	6820      	ldr	r0, [r4, #0]
   36d76:	f7fe fe0e 	bl	35996 <net_context_ref>
   36d7a:	e77c      	b.n	36c76 <net_tcp_ack_received+0x56>
		k_delayed_work_cancel(&tcp->retry_timer);
   36d7c:	f7f7 fc8c 	bl	2e698 <k_delayed_work_cancel>
		tcp->flags &= ~NET_TCP_RETRYING;
   36d80:	f8b4 30bc 	ldrh.w	r3, [r4, #188]	; 0xbc
   36d84:	f3c3 1247 	ubfx	r2, r3, #5, #8
   36d88:	f022 0210 	bic.w	r2, r2, #16
   36d8c:	f362 134c 	bfi	r3, r2, #5, #8
   36d90:	f8a4 30bc 	strh.w	r3, [r4, #188]	; 0xbc
   36d94:	e76f      	b.n	36c76 <net_tcp_ack_received+0x56>
	return true;
   36d96:	2701      	movs	r7, #1
   36d98:	e772      	b.n	36c80 <net_tcp_ack_received+0x60>

00036d9a <handle_timewait_timeout>:
   36d9a:	6d43      	ldr	r3, [r0, #84]	; 0x54
{
   36d9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (net_tcp_get_state(tcp) == NET_TCP_TIME_WAIT) {
   36d9e:	f3c3 3343 	ubfx	r3, r3, #13, #4
   36da2:	2b09      	cmp	r3, #9
{
   36da4:	4604      	mov	r4, r0
	if (net_tcp_get_state(tcp) == NET_TCP_TIME_WAIT) {
   36da6:	d116      	bne.n	36dd6 <handle_timewait_timeout+0x3c>
		net_tcp_change_state(tcp, NET_TCP_CLOSED);
   36da8:	3868      	subs	r0, #104	; 0x68
   36daa:	2100      	movs	r1, #0
   36dac:	f7e6 ffde 	bl	1dd6c <net_tcp_change_state>
		if (tcp->context->recv_cb) {
   36db0:	f854 0c68 	ldr.w	r0, [r4, #-104]
   36db4:	6b05      	ldr	r5, [r0, #48]	; 0x30
   36db6:	b13d      	cbz	r5, 36dc8 <handle_timewait_timeout+0x2e>
			tcp->context->recv_cb(tcp->context, NULL, NULL, NULL,
   36db8:	f854 3c64 	ldr.w	r3, [r4, #-100]
   36dbc:	9301      	str	r3, [sp, #4]
   36dbe:	2300      	movs	r3, #0
   36dc0:	9300      	str	r3, [sp, #0]
   36dc2:	461a      	mov	r2, r3
   36dc4:	4619      	mov	r1, r3
   36dc6:	47a8      	blx	r5
		net_context_unref(tcp->context);
   36dc8:	f854 0c68 	ldr.w	r0, [r4, #-104]
}
   36dcc:	b003      	add	sp, #12
   36dce:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_context_unref(tcp->context);
   36dd2:	f7fe bdea 	b.w	359aa <net_context_unref>
}
   36dd6:	b003      	add	sp, #12
   36dd8:	bd30      	pop	{r4, r5, pc}

00036dda <handle_ack_timeout>:
   36dda:	f8d0 30b4 	ldr.w	r3, [r0, #180]	; 0xb4
{
   36dde:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (net_tcp_get_state(tcp) == NET_TCP_LAST_ACK) {
   36de0:	f3c3 3343 	ubfx	r3, r3, #13, #4
   36de4:	2b06      	cmp	r3, #6
{
   36de6:	4604      	mov	r4, r0
	if (net_tcp_get_state(tcp) == NET_TCP_LAST_ACK) {
   36de8:	d116      	bne.n	36e18 <handle_ack_timeout+0x3e>
		net_tcp_change_state(tcp, NET_TCP_CLOSED);
   36dea:	3808      	subs	r0, #8
   36dec:	2100      	movs	r1, #0
   36dee:	f7e6 ffbd 	bl	1dd6c <net_tcp_change_state>
		if (tcp->context->recv_cb) {
   36df2:	f854 0c08 	ldr.w	r0, [r4, #-8]
   36df6:	6b05      	ldr	r5, [r0, #48]	; 0x30
   36df8:	b13d      	cbz	r5, 36e0a <handle_ack_timeout+0x30>
			tcp->context->recv_cb(tcp->context, NULL, NULL, NULL,
   36dfa:	f854 3c04 	ldr.w	r3, [r4, #-4]
   36dfe:	9301      	str	r3, [sp, #4]
   36e00:	2300      	movs	r3, #0
   36e02:	9300      	str	r3, [sp, #0]
   36e04:	461a      	mov	r2, r3
   36e06:	4619      	mov	r1, r3
   36e08:	47a8      	blx	r5
		net_context_unref(tcp->context);
   36e0a:	f854 0c08 	ldr.w	r0, [r4, #-8]
}
   36e0e:	b003      	add	sp, #12
   36e10:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		net_context_unref(tcp->context);
   36e14:	f7fe bdc9 	b.w	359aa <net_context_unref>
}
   36e18:	b003      	add	sp, #12
   36e1a:	bd30      	pop	{r4, r5, pc}

00036e1c <net_tcp_validate_seq>:
{
   36e1c:	b510      	push	{r4, lr}
   36e1e:	4604      	mov	r4, r0
	return (net_tcp_seq_cmp(sys_get_be32(tcp_hdr->seq),
   36e20:	1d08      	adds	r0, r1, #4
   36e22:	f7ff fc19 	bl	36658 <sys_get_be32>
   36e26:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
   36e2a:	1a83      	subs	r3, r0, r2
				tcp->send_ack) >= 0) &&
   36e2c:	2b00      	cmp	r3, #0
	return tcp->recv_wnd;
   36e2e:	bfa9      	itett	ge
   36e30:	f8b4 30b8 	ldrhge.w	r3, [r4, #184]	; 0xb8
				tcp->send_ack) >= 0) &&
   36e34:	2000      	movlt	r0, #0
   36e36:	189b      	addge	r3, r3, r2
   36e38:	1ac0      	subge	r0, r0, r3
   36e3a:	bfa8      	it	ge
   36e3c:	0fc0      	lsrge	r0, r0, #31
}
   36e3e:	bd10      	pop	{r4, pc}

00036e40 <net_tcp_finalize>:
{
   36e40:	b530      	push	{r4, r5, lr}
   36e42:	b089      	sub	sp, #36	; 0x24
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36e44:	ab03      	add	r3, sp, #12
   36e46:	9301      	str	r3, [sp, #4]
   36e48:	2314      	movs	r3, #20
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   36e4a:	a901      	add	r1, sp, #4
{
   36e4c:	4605      	mov	r5, r0
	NET_PKT_DATA_ACCESS_DEFINE(tcp_access, struct net_tcp_hdr);
   36e4e:	9302      	str	r3, [sp, #8]
	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, &tcp_access);
   36e50:	f7ff f984 	bl	3615c <net_pkt_get_data>
	if (!tcp_hdr) {
   36e54:	4604      	mov	r4, r0
   36e56:	b188      	cbz	r0, 36e7c <net_tcp_finalize+0x3c>
	tcp_hdr->chksum = 0U;
   36e58:	2300      	movs	r3, #0
   36e5a:	7403      	strb	r3, [r0, #16]
   36e5c:	7443      	strb	r3, [r0, #17]
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   36e5e:	6a28      	ldr	r0, [r5, #32]
   36e60:	f7fe fcb6 	bl	357d0 <net_if_need_calc_tx_checksum>
   36e64:	b120      	cbz	r0, 36e70 <net_tcp_finalize+0x30>
   36e66:	2106      	movs	r1, #6
   36e68:	4628      	mov	r0, r5
   36e6a:	f7fe fcd1 	bl	35810 <net_calc_chksum>
		tcp_hdr->chksum = net_calc_chksum_tcp(pkt);
   36e6e:	8220      	strh	r0, [r4, #16]
	return net_pkt_set_data(pkt, &tcp_access);
   36e70:	a901      	add	r1, sp, #4
   36e72:	4628      	mov	r0, r5
   36e74:	f7ff f993 	bl	3619e <net_pkt_set_data>
}
   36e78:	b009      	add	sp, #36	; 0x24
   36e7a:	bd30      	pop	{r4, r5, pc}
		return -ENOBUFS;
   36e7c:	f06f 0068 	mvn.w	r0, #104	; 0x68
   36e80:	e7fa      	b.n	36e78 <net_tcp_finalize+0x38>

00036e82 <net_tcp_parse_opts>:
{
   36e82:	b573      	push	{r0, r1, r4, r5, r6, lr}
   36e84:	4605      	mov	r5, r0
   36e86:	460c      	mov	r4, r1
   36e88:	4616      	mov	r6, r2
	while (opt_totlen) {
   36e8a:	b174      	cbz	r4, 36eaa <net_tcp_parse_opts+0x28>
	return net_pkt_read(pkt, data, 1);
   36e8c:	2201      	movs	r2, #1
   36e8e:	f10d 0106 	add.w	r1, sp, #6
   36e92:	4628      	mov	r0, r5
   36e94:	f7ff f824 	bl	35ee0 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &opt)) {
   36e98:	b118      	cbz	r0, 36ea2 <net_tcp_parse_opts+0x20>
	return -EINVAL;
   36e9a:	f06f 0015 	mvn.w	r0, #21
}
   36e9e:	b002      	add	sp, #8
   36ea0:	bd70      	pop	{r4, r5, r6, pc}
		if (opt == NET_TCP_END_OPT) {
   36ea2:	f89d 2006 	ldrb.w	r2, [sp, #6]
		opt_totlen--;
   36ea6:	1e63      	subs	r3, r4, #1
		if (opt == NET_TCP_END_OPT) {
   36ea8:	b90a      	cbnz	r2, 36eae <net_tcp_parse_opts+0x2c>
	return 0;
   36eaa:	2000      	movs	r0, #0
   36eac:	e7f7      	b.n	36e9e <net_tcp_parse_opts+0x1c>
		} else if (opt == NET_TCP_NOP_OPT) {
   36eae:	2a01      	cmp	r2, #1
   36eb0:	d028      	beq.n	36f04 <net_tcp_parse_opts+0x82>
		if (!opt_totlen) {
   36eb2:	2b00      	cmp	r3, #0
   36eb4:	d0f1      	beq.n	36e9a <net_tcp_parse_opts+0x18>
   36eb6:	2201      	movs	r2, #1
   36eb8:	f10d 0107 	add.w	r1, sp, #7
   36ebc:	4628      	mov	r0, r5
   36ebe:	f7ff f80f 	bl	35ee0 <net_pkt_read>
		if (net_pkt_read_u8(pkt, &optlen) || optlen < 2) {
   36ec2:	2800      	cmp	r0, #0
   36ec4:	d1e9      	bne.n	36e9a <net_tcp_parse_opts+0x18>
   36ec6:	f89d 1007 	ldrb.w	r1, [sp, #7]
   36eca:	2901      	cmp	r1, #1
   36ecc:	d9e5      	bls.n	36e9a <net_tcp_parse_opts+0x18>
		optlen -= 2U;
   36ece:	3902      	subs	r1, #2
   36ed0:	b2c9      	uxtb	r1, r1
		opt_totlen--;
   36ed2:	3c02      	subs	r4, #2
		if (opt_totlen < optlen) {
   36ed4:	42a1      	cmp	r1, r4
		optlen -= 2U;
   36ed6:	f88d 1007 	strb.w	r1, [sp, #7]
		if (opt_totlen < optlen) {
   36eda:	dcde      	bgt.n	36e9a <net_tcp_parse_opts+0x18>
		switch (opt) {
   36edc:	f89d 3006 	ldrb.w	r3, [sp, #6]
   36ee0:	2b02      	cmp	r3, #2
   36ee2:	d10b      	bne.n	36efc <net_tcp_parse_opts+0x7a>
			if (optlen != 2U) {
   36ee4:	2902      	cmp	r1, #2
   36ee6:	d1d8      	bne.n	36e9a <net_tcp_parse_opts+0x18>
			if (net_pkt_read_be16(pkt, &opts->mss)) {
   36ee8:	4631      	mov	r1, r6
   36eea:	4628      	mov	r0, r5
   36eec:	f7ff f801 	bl	35ef2 <net_pkt_read_be16>
			if (net_pkt_skip(pkt, optlen)) {
   36ef0:	2800      	cmp	r0, #0
   36ef2:	d1d2      	bne.n	36e9a <net_tcp_parse_opts+0x18>
		opt_totlen -= optlen;
   36ef4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   36ef8:	1ae4      	subs	r4, r4, r3
   36efa:	e7c6      	b.n	36e8a <net_tcp_parse_opts+0x8>
			if (net_pkt_skip(pkt, optlen)) {
   36efc:	4628      	mov	r0, r5
   36efe:	f7fe ffd9 	bl	35eb4 <net_pkt_skip>
   36f02:	e7f5      	b.n	36ef0 <net_tcp_parse_opts+0x6e>
		opt_totlen--;
   36f04:	461c      	mov	r4, r3
   36f06:	e7c0      	b.n	36e8a <net_tcp_parse_opts+0x8>

00036f08 <net_tcp_put>:
{
   36f08:	b530      	push	{r4, r5, lr}
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36f0a:	f8b0 3078 	ldrh.w	r3, [r0, #120]	; 0x78
{
   36f0e:	b087      	sub	sp, #28
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36f10:	2b06      	cmp	r3, #6
{
   36f12:	4604      	mov	r4, r0
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36f14:	d145      	bne.n	36fa2 <net_tcp_put+0x9a>
		if ((net_context_get_state(context) == NET_CONTEXT_CONNECTED ||
   36f16:	f7e6 fd21 	bl	1d95c <net_context_get_state>
   36f1a:	2802      	cmp	r0, #2
   36f1c:	d10f      	bne.n	36f3e <net_tcp_put+0x36>
		    && context->tcp
   36f1e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
   36f20:	b998      	cbnz	r0, 36f4a <net_tcp_put+0x42>
		if (context->tcp &&
   36f22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   36f24:	b143      	cbz	r3, 36f38 <net_tcp_put+0x30>
   36f26:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
   36f2a:	f3c3 3343 	ubfx	r3, r3, #13, #4
   36f2e:	2b02      	cmp	r3, #2
   36f30:	d102      	bne.n	36f38 <net_tcp_put+0x30>
			net_context_unref(context);
   36f32:	4620      	mov	r0, r4
   36f34:	f7fe fd39 	bl	359aa <net_context_unref>
		return -ENOTCONN;
   36f38:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   36f3c:	e020      	b.n	36f80 <net_tcp_put+0x78>
		     net_context_get_state(context) == NET_CONTEXT_LISTENING)
   36f3e:	4620      	mov	r0, r4
   36f40:	f7e6 fd0c 	bl	1d95c <net_context_get_state>
		if ((net_context_get_state(context) == NET_CONTEXT_CONNECTED ||
   36f44:	2803      	cmp	r0, #3
   36f46:	d0ea      	beq.n	36f1e <net_tcp_put+0x16>
   36f48:	e7eb      	b.n	36f22 <net_tcp_put+0x1a>
		    && !context->tcp->fin_rcvd) {
   36f4a:	f890 50be 	ldrb.w	r5, [r0, #190]	; 0xbe
   36f4e:	f015 0504 	ands.w	r5, r5, #4
   36f52:	d1e6      	bne.n	36f22 <net_tcp_put+0x1a>
			k_delayed_work_submit(&context->tcp->fin_timer,
   36f54:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   36f58:	3028      	adds	r0, #40	; 0x28
   36f5a:	f7e6 fcd7 	bl	1d90c <k_delayed_work_submit>
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   36f5e:	ab05      	add	r3, sp, #20
   36f60:	9302      	str	r3, [sp, #8]
				      NULL, &ctx->remote, &pkt);
   36f62:	f104 0324 	add.w	r3, r4, #36	; 0x24
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   36f66:	e9cd 5300 	strd	r5, r3, [sp]
   36f6a:	462a      	mov	r2, r5
   36f6c:	462b      	mov	r3, r5
   36f6e:	2101      	movs	r1, #1
   36f70:	6be0      	ldr	r0, [r4, #60]	; 0x3c
	struct net_pkt *pkt = NULL;
   36f72:	9505      	str	r5, [sp, #20]
	ret = net_tcp_prepare_segment(ctx->tcp, NET_TCP_FIN, NULL, 0,
   36f74:	f7ff fd6b 	bl	36a4e <net_tcp_prepare_segment>
	if (ret || !pkt) {
   36f78:	b908      	cbnz	r0, 36f7e <net_tcp_put+0x76>
   36f7a:	9905      	ldr	r1, [sp, #20]
   36f7c:	b911      	cbnz	r1, 36f84 <net_tcp_put+0x7c>
			return 0;
   36f7e:	2000      	movs	r0, #0
}
   36f80:	b007      	add	sp, #28
   36f82:	bd30      	pop	{r4, r5, pc}
Z_GENLIST_IS_EMPTY(slist)
   36f84:	4620      	mov	r0, r4
   36f86:	f850 3f3c 	ldr.w	r3, [r0, #60]!
   36f8a:	f8d3 5088 	ldr.w	r5, [r3, #136]	; 0x88
	net_tcp_queue_pkt(ctx, pkt);
   36f8e:	f7ff fb77 	bl	36680 <net_tcp_queue_pkt.isra.22>
	if (flush) {
   36f92:	2d00      	cmp	r5, #0
   36f94:	d1f3      	bne.n	36f7e <net_tcp_put+0x76>
	(void)net_tcp_send_data(context, NULL, NULL);
   36f96:	462a      	mov	r2, r5
   36f98:	4629      	mov	r1, r5
   36f9a:	4620      	mov	r0, r4
   36f9c:	f7ff fd1e 	bl	369dc <net_tcp_send_data>
   36fa0:	e7ed      	b.n	36f7e <net_tcp_put+0x76>
	return -EOPNOTSUPP;
   36fa2:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   36fa6:	e7eb      	b.n	36f80 <net_tcp_put+0x78>

00036fa8 <net_tcp_listen>:
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36fa8:	f8b0 3078 	ldrh.w	r3, [r0, #120]	; 0x78
{
   36fac:	b510      	push	{r4, lr}
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36fae:	2b06      	cmp	r3, #6
{
   36fb0:	4604      	mov	r4, r0
	if (net_context_get_ip_proto(context) == IPPROTO_TCP) {
   36fb2:	d109      	bne.n	36fc8 <net_tcp_listen+0x20>
		net_tcp_change_state(context->tcp, NET_TCP_LISTEN);
   36fb4:	2101      	movs	r1, #1
   36fb6:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   36fb8:	f7e6 fed8 	bl	1dd6c <net_tcp_change_state>
		net_context_set_state(context, NET_CONTEXT_LISTENING);
   36fbc:	4620      	mov	r0, r4
   36fbe:	2103      	movs	r1, #3
   36fc0:	f7e6 fcec 	bl	1d99c <net_context_set_state>
		return 0;
   36fc4:	2000      	movs	r0, #0
}
   36fc6:	bd10      	pop	{r4, pc}
	return -EOPNOTSUPP;
   36fc8:	f06f 005e 	mvn.w	r0, #94	; 0x5e
   36fcc:	e7fb      	b.n	36fc6 <net_tcp_listen+0x1e>

00036fce <net_tcp_update_recv_wnd>:
	if (!context->tcp) {
   36fce:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
   36fd0:	b14a      	cbz	r2, 36fe6 <net_tcp_update_recv_wnd+0x18>
	new_win = context->tcp->recv_wnd + delta;
   36fd2:	f8b2 30b8 	ldrh.w	r3, [r2, #184]	; 0xb8
   36fd6:	4419      	add	r1, r3
	if (new_win < 0 || new_win > UINT16_MAX) {
   36fd8:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
   36fdc:	d206      	bcs.n	36fec <net_tcp_update_recv_wnd+0x1e>
	context->tcp->recv_wnd = new_win;
   36fde:	f8a2 10b8 	strh.w	r1, [r2, #184]	; 0xb8
	return 0;
   36fe2:	2000      	movs	r0, #0
   36fe4:	4770      	bx	lr
		return -EPROTOTYPE;
   36fe6:	f06f 006a 	mvn.w	r0, #106	; 0x6a
   36fea:	4770      	bx	lr
		return -EINVAL;
   36fec:	f06f 0015 	mvn.w	r0, #21
}
   36ff0:	4770      	bx	lr

00036ff2 <net_tcp_input>:

struct net_tcp_hdr *net_tcp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *tcp_access)
{
   36ff2:	b570      	push	{r4, r5, r6, lr}
   36ff4:	4604      	mov	r4, r0
	struct net_tcp_hdr *tcp_hdr;

	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   36ff6:	6a00      	ldr	r0, [r0, #32]
{
   36ff8:	460e      	mov	r6, r1
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   36ffa:	f7fe fbeb 	bl	357d4 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_TCP_CHECKSUM) &&
   36ffe:	b940      	cbnz	r0, 37012 <net_tcp_input+0x20>
	    net_calc_chksum_tcp(pkt) != 0U) {
		NET_DBG("DROP: checksum mismatch");
		goto drop;
	}

	tcp_hdr = (struct net_tcp_hdr *)net_pkt_get_data(pkt, tcp_access);
   37000:	4631      	mov	r1, r6
   37002:	4620      	mov	r0, r4
   37004:	f7ff f8aa 	bl	3615c <net_pkt_get_data>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
   37008:	4605      	mov	r5, r0
   3700a:	b948      	cbnz	r0, 37020 <net_tcp_input+0x2e>
		return tcp_hdr;
	}

drop:
	net_stats_update_tcp_seg_chkerr(net_pkt_iface(pkt));
	return NULL;
   3700c:	2500      	movs	r5, #0
}
   3700e:	4628      	mov	r0, r5
   37010:	bd70      	pop	{r4, r5, r6, pc}
   37012:	2106      	movs	r1, #6
   37014:	4620      	mov	r0, r4
   37016:	f7fe fbfb 	bl	35810 <net_calc_chksum>
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt)) &&
   3701a:	2800      	cmp	r0, #0
   3701c:	d0f0      	beq.n	37000 <net_tcp_input+0xe>
   3701e:	e7f5      	b.n	3700c <net_tcp_input+0x1a>
	if (tcp_hdr && !net_pkt_set_data(pkt, tcp_access)) {
   37020:	4631      	mov	r1, r6
   37022:	4620      	mov	r0, r4
   37024:	f7ff f8bb 	bl	3619e <net_pkt_set_data>
   37028:	2800      	cmp	r0, #0
   3702a:	d0f0      	beq.n	3700e <net_tcp_input+0x1c>
drop:
   3702c:	e7ee      	b.n	3700c <net_tcp_input+0x1a>

0003702e <net_udp_create>:
#include "net_stats.h"

#define PKT_WAIT_TIME K_SECONDS(1)

int net_udp_create(struct net_pkt *pkt, u16_t src_port, u16_t dst_port)
{
   3702e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   37030:	2308      	movs	r3, #8
{
   37032:	460e      	mov	r6, r1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   37034:	eb0d 0103 	add.w	r1, sp, r3
{
   37038:	4604      	mov	r4, r0
   3703a:	4615      	mov	r5, r2
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   3703c:	f8cd d008 	str.w	sp, [sp, #8]
   37040:	9303      	str	r3, [sp, #12]
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   37042:	f7ff f88b 	bl	3615c <net_pkt_get_data>
	if (!udp_hdr) {
   37046:	b160      	cbz	r0, 37062 <net_udp_create+0x34>
		return -ENOBUFS;
	}

	udp_hdr->src_port = src_port;
	udp_hdr->dst_port = dst_port;
	udp_hdr->len      = 0U;
   37048:	2300      	movs	r3, #0
	udp_hdr->src_port = src_port;
   3704a:	8006      	strh	r6, [r0, #0]
	udp_hdr->dst_port = dst_port;
   3704c:	8045      	strh	r5, [r0, #2]
	udp_hdr->len      = 0U;
   3704e:	7103      	strb	r3, [r0, #4]
   37050:	7143      	strb	r3, [r0, #5]
	udp_hdr->chksum   = 0U;
   37052:	7183      	strb	r3, [r0, #6]
   37054:	71c3      	strb	r3, [r0, #7]

	return net_pkt_set_data(pkt, &udp_access);
   37056:	a902      	add	r1, sp, #8
   37058:	4620      	mov	r0, r4
   3705a:	f7ff f8a0 	bl	3619e <net_pkt_set_data>
}
   3705e:	b004      	add	sp, #16
   37060:	bd70      	pop	{r4, r5, r6, pc}
		return -ENOBUFS;
   37062:	f06f 0068 	mvn.w	r0, #104	; 0x68
   37066:	e7fa      	b.n	3705e <net_udp_create+0x30>

00037068 <net_udp_finalize>:

int net_udp_finalize(struct net_pkt *pkt)
{
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   37068:	2308      	movs	r3, #8
{
   3706a:	b530      	push	{r4, r5, lr}
   3706c:	b085      	sub	sp, #20
	struct net_udp_hdr *udp_hdr;
	u16_t length = 0;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   3706e:	eb0d 0103 	add.w	r1, sp, r3
{
   37072:	4604      	mov	r4, r0
	NET_PKT_DATA_ACCESS_DEFINE(udp_access, struct net_udp_hdr);
   37074:	f8cd d008 	str.w	sp, [sp, #8]
   37078:	9303      	str	r3, [sp, #12]
	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, &udp_access);
   3707a:	f7ff f86f 	bl	3615c <net_pkt_get_data>
	if (!udp_hdr) {
   3707e:	4605      	mov	r5, r0
   37080:	b310      	cbz	r0, 370c8 <net_udp_finalize+0x60>
	size_t bytes = 0;
   37082:	2300      	movs	r3, #0
		return -ENOBUFS;
	}

	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
   37084:	6922      	ldr	r2, [r4, #16]
	while (buf) {
   37086:	b9da      	cbnz	r2, 370c0 <net_udp_finalize+0x58>
   37088:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
	return pkt->ipv4_opts_len;
   3708c:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
		 net_pkt_ip_opts_len(pkt);

	udp_hdr->len = htons(length);

	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   37090:	6a20      	ldr	r0, [r4, #32]
	length = net_pkt_get_len(pkt) - net_pkt_ip_hdr_len(pkt) -
   37092:	440a      	add	r2, r1
   37094:	1a9b      	subs	r3, r3, r2
	udp_hdr->len = htons(length);
   37096:	ba5b      	rev16	r3, r3
   37098:	80ab      	strh	r3, [r5, #4]
	if (net_if_need_calc_tx_checksum(net_pkt_iface(pkt))) {
   3709a:	f7fe fb99 	bl	357d0 <net_if_need_calc_tx_checksum>
   3709e:	b148      	cbz	r0, 370b4 <net_udp_finalize+0x4c>
	u16_t chksum = net_calc_chksum(pkt, IPPROTO_UDP);
   370a0:	2111      	movs	r1, #17
   370a2:	4620      	mov	r0, r4
   370a4:	f7fe fbb4 	bl	35810 <net_calc_chksum>
		udp_hdr->chksum = net_calc_chksum_udp(pkt);
   370a8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   370ac:	2800      	cmp	r0, #0
   370ae:	bf08      	it	eq
   370b0:	4618      	moveq	r0, r3
   370b2:	80e8      	strh	r0, [r5, #6]
	}

	return net_pkt_set_data(pkt, &udp_access);
   370b4:	a902      	add	r1, sp, #8
   370b6:	4620      	mov	r0, r4
   370b8:	f7ff f871 	bl	3619e <net_pkt_set_data>
}
   370bc:	b005      	add	sp, #20
   370be:	bd30      	pop	{r4, r5, pc}
		bytes += buf->len;
   370c0:	8991      	ldrh	r1, [r2, #12]
		buf = buf->frags;
   370c2:	6812      	ldr	r2, [r2, #0]
		bytes += buf->len;
   370c4:	440b      	add	r3, r1
		buf = buf->frags;
   370c6:	e7de      	b.n	37086 <net_udp_finalize+0x1e>
		return -ENOBUFS;
   370c8:	f06f 0068 	mvn.w	r0, #104	; 0x68
   370cc:	e7f6      	b.n	370bc <net_udp_finalize+0x54>

000370ce <net_udp_input>:
	return net_conn_unregister(handle);
}

struct net_udp_hdr *net_udp_input(struct net_pkt *pkt,
				  struct net_pkt_data_access *udp_access)
{
   370ce:	b570      	push	{r4, r5, r6, lr}
   370d0:	4604      	mov	r4, r0
   370d2:	460e      	mov	r6, r1
	struct net_udp_hdr *udp_hdr;

	udp_hdr = (struct net_udp_hdr *)net_pkt_get_data(pkt, udp_access);
   370d4:	f7ff f842 	bl	3615c <net_pkt_get_data>
	if (!udp_hdr || net_pkt_set_data(pkt, udp_access)) {
   370d8:	4605      	mov	r5, r0
   370da:	b1f0      	cbz	r0, 3711a <net_udp_input+0x4c>
   370dc:	4631      	mov	r1, r6
   370de:	4620      	mov	r0, r4
   370e0:	f7ff f85d 	bl	3619e <net_pkt_set_data>
   370e4:	b9c8      	cbnz	r0, 3711a <net_udp_input+0x4c>
		NET_DBG("DROP: corrupted header");
		goto drop;
	}

	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
   370e6:	88aa      	ldrh	r2, [r5, #4]
   370e8:	0213      	lsls	r3, r2, #8
   370ea:	ea43 2312 	orr.w	r3, r3, r2, lsr #8
   370ee:	6922      	ldr	r2, [r4, #16]
   370f0:	b29b      	uxth	r3, r3
	while (buf) {
   370f2:	b9aa      	cbnz	r2, 37120 <net_udp_input+0x52>
				    net_pkt_ip_hdr_len(pkt) -
   370f4:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
				    net_pkt_ip_opts_len(pkt))) {
   370f8:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
				    net_pkt_ip_hdr_len(pkt) -
   370fc:	440a      	add	r2, r1
   370fe:	1a80      	subs	r0, r0, r2
	if (ntohs(udp_hdr->len) != (net_pkt_get_len(pkt) -
   37100:	4283      	cmp	r3, r0
   37102:	d10a      	bne.n	3711a <net_udp_input+0x4c>
		NET_DBG("DROP: Invalid hdr length");
		goto drop;
	}

	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
	    net_if_need_calc_rx_checksum(net_pkt_iface(pkt))) {
   37104:	6a20      	ldr	r0, [r4, #32]
   37106:	f7fe fb65 	bl	357d4 <net_if_need_calc_rx_checksum>
	if (IS_ENABLED(CONFIG_NET_UDP_CHECKSUM) &&
   3710a:	b138      	cbz	r0, 3711c <net_udp_input+0x4e>
		if (!udp_hdr->chksum) {
   3710c:	88eb      	ldrh	r3, [r5, #6]
   3710e:	b123      	cbz	r3, 3711a <net_udp_input+0x4c>
	return net_calc_chksum(pkt, IPPROTO_UDP);
   37110:	2111      	movs	r1, #17
   37112:	4620      	mov	r0, r4
   37114:	f7fe fb7c 	bl	35810 <net_calc_chksum>
			}

			goto drop;
		}

		if (net_calc_verify_chksum_udp(pkt) != 0U) {
   37118:	b100      	cbz	r0, 3711c <net_udp_input+0x4e>
	}
out:
	return udp_hdr;
drop:
	net_stats_update_udp_chkerr(net_pkt_iface(pkt));
	return NULL;
   3711a:	2500      	movs	r5, #0
}
   3711c:	4628      	mov	r0, r5
   3711e:	bd70      	pop	{r4, r5, r6, pc}
		bytes += buf->len;
   37120:	8991      	ldrh	r1, [r2, #12]
		buf = buf->frags;
   37122:	6812      	ldr	r2, [r2, #0]
		bytes += buf->len;
   37124:	4408      	add	r0, r1
		buf = buf->frags;
   37126:	e7e4      	b.n	370f2 <net_udp_input+0x24>

00037128 <unpack_uint16>:
 */
static int unpack_uint16(struct buf_ctx *buf, u16_t *val)
{
	MQTT_TRC(">> cur:%p, end:%p", buf->cur, buf->end);

	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   37128:	e9d0 2300 	ldrd	r2, r3, [r0]
   3712c:	1a9b      	subs	r3, r3, r2
   3712e:	2b01      	cmp	r3, #1
{
   37130:	b510      	push	{r4, lr}
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   37132:	d90c      	bls.n	3714e <unpack_uint16+0x26>
		return -EINVAL;
	}

	*val = *(buf->cur++) << 8; /* MSB */
   37134:	4614      	mov	r4, r2
   37136:	1c53      	adds	r3, r2, #1
   37138:	6003      	str	r3, [r0, #0]
   3713a:	f814 3b02 	ldrb.w	r3, [r4], #2
   3713e:	021b      	lsls	r3, r3, #8
   37140:	800b      	strh	r3, [r1, #0]
	*val |= *(buf->cur++); /* LSB */
   37142:	6004      	str	r4, [r0, #0]

	MQTT_TRC("<< val:%04x", *val);

	return 0;
   37144:	2000      	movs	r0, #0
	*val |= *(buf->cur++); /* LSB */
   37146:	7852      	ldrb	r2, [r2, #1]
   37148:	4313      	orrs	r3, r2
   3714a:	800b      	strh	r3, [r1, #0]
}
   3714c:	bd10      	pop	{r4, pc}
		return -EINVAL;
   3714e:	f06f 0015 	mvn.w	r0, #21
   37152:	e7fb      	b.n	3714c <unpack_uint16+0x24>

00037154 <fixed_header_decode>:
	return 0;
}

int fixed_header_decode(struct buf_ctx *buf, u8_t *type_and_flags,
			u32_t *length)
{
   37154:	b5f0      	push	{r4, r5, r6, r7, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   37156:	e9d0 3400 	ldrd	r3, r4, [r0]
   3715a:	429c      	cmp	r4, r3
   3715c:	d01f      	beq.n	3719e <fixed_header_decode+0x4a>
	*val = *(buf->cur++);
   3715e:	1c5c      	adds	r4, r3, #1
   37160:	6004      	str	r4, [r0, #0]
   37162:	781b      	ldrb	r3, [r3, #0]
   37164:	700b      	strb	r3, [r1, #0]
	*length = 0U;
   37166:	2100      	movs	r1, #0
		if (buf->cur >= buf->end) {
   37168:	6847      	ldr	r7, [r0, #4]
	*length = 0U;
   3716a:	6011      	str	r1, [r2, #0]
		if (buf->cur >= buf->end) {
   3716c:	6804      	ldr	r4, [r0, #0]
   3716e:	42bc      	cmp	r4, r7
   37170:	d218      	bcs.n	371a4 <fixed_header_decode+0x50>
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   37172:	4625      	mov	r5, r4
   37174:	f815 3b01 	ldrb.w	r3, [r5], #1
   37178:	6816      	ldr	r6, [r2, #0]
   3717a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
								<< shift;
   3717e:	408b      	lsls	r3, r1
		*length += ((u32_t)*(buf->cur) & MQTT_LENGTH_VALUE_MASK)
   37180:	4433      	add	r3, r6
   37182:	6013      	str	r3, [r2, #0]
	} while ((*(buf->cur++) & MQTT_LENGTH_CONTINUATION_BIT) != 0U);
   37184:	6005      	str	r5, [r0, #0]
   37186:	f994 4000 	ldrsb.w	r4, [r4]
   3718a:	2c00      	cmp	r4, #0
   3718c:	db04      	blt.n	37198 <fixed_header_decode+0x44>
	if (*length > MQTT_MAX_PAYLOAD_SIZE) {
   3718e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   37192:	d204      	bcs.n	3719e <fixed_header_decode+0x4a>
	return 0;
   37194:	2000      	movs	r0, #0
   37196:	e004      	b.n	371a2 <fixed_header_decode+0x4e>
		if (bytes >= MQTT_MAX_LENGTH_BYTES) {
   37198:	3107      	adds	r1, #7
   3719a:	291c      	cmp	r1, #28
   3719c:	d1e6      	bne.n	3716c <fixed_header_decode+0x18>
		return -EINVAL;
   3719e:	f06f 0015 	mvn.w	r0, #21
	if (err_code != 0) {
		return err_code;
	}

	return packet_length_decode(buf, length);
}
   371a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return -EAGAIN;
   371a4:	f06f 000a 	mvn.w	r0, #10
   371a8:	e7fb      	b.n	371a2 <fixed_header_decode+0x4e>

000371aa <connect_ack_decode>:

int connect_ack_decode(const struct mqtt_client *client, struct buf_ctx *buf,
		       struct mqtt_connack_param *param)
{
   371aa:	b530      	push	{r4, r5, lr}
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   371ac:	e9d1 3500 	ldrd	r3, r5, [r1]
   371b0:	429d      	cmp	r5, r3
   371b2:	d102      	bne.n	371ba <connect_ack_decode+0x10>
		return -EINVAL;
   371b4:	f06f 0015 	mvn.w	r0, #21
	}

	param->return_code = (enum mqtt_conn_return_code)ret_code;

	return 0;
}
   371b8:	bd30      	pop	{r4, r5, pc}
	*val = *(buf->cur++);
   371ba:	1c5c      	adds	r4, r3, #1
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   371bc:	42a5      	cmp	r5, r4
	*val = *(buf->cur++);
   371be:	600c      	str	r4, [r1, #0]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   371c0:	d0f8      	beq.n	371b4 <connect_ack_decode+0xa>
	*val = *(buf->cur++);
   371c2:	461d      	mov	r5, r3
   371c4:	f815 4b02 	ldrb.w	r4, [r5], #2
   371c8:	600d      	str	r5, [r1, #0]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   371ca:	f890 107a 	ldrb.w	r1, [r0, #122]	; 0x7a
	*val = *(buf->cur++);
   371ce:	785b      	ldrb	r3, [r3, #1]
	if (client->protocol_version == MQTT_VERSION_3_1_1) {
   371d0:	2904      	cmp	r1, #4
			flags & MQTT_CONNACK_FLAG_SESSION_PRESENT;
   371d2:	bf04      	itt	eq
   371d4:	f004 0401 	andeq.w	r4, r4, #1
		param->session_present_flag =
   371d8:	7014      	strbeq	r4, [r2, #0]
	param->return_code = (enum mqtt_conn_return_code)ret_code;
   371da:	7053      	strb	r3, [r2, #1]
	return 0;
   371dc:	2000      	movs	r0, #0
   371de:	e7eb      	b.n	371b8 <connect_ack_decode+0xe>

000371e0 <publish_decode>:

int publish_decode(u8_t flags, u32_t var_length, struct buf_ctx *buf,
		   struct mqtt_publish_param *param)
{
   371e0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   371e4:	461d      	mov	r5, r3
	int err_code;
	u32_t var_header_length;

	param->dup_flag = flags & MQTT_HEADER_DUP_MASK;
   371e6:	7d9b      	ldrb	r3, [r3, #22]
{
   371e8:	4688      	mov	r8, r1
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   371ea:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   371ee:	f360 0341 	bfi	r3, r0, #1, #1
	param->message.topic.qos = ((flags & MQTT_HEADER_QOS_MASK) >> 1);
   371f2:	f3c0 0041 	ubfx	r0, r0, #1, #2
   371f6:	7228      	strb	r0, [r5, #8]
	param->retain_flag = flags & MQTT_HEADER_RETAIN_MASK;
   371f8:	75ab      	strb	r3, [r5, #22]
	err_code = unpack_uint16(buf, &utf8_strlen);
   371fa:	f10d 0106 	add.w	r1, sp, #6
   371fe:	4610      	mov	r0, r2
{
   37200:	4617      	mov	r7, r2
	err_code = unpack_uint16(buf, &utf8_strlen);
   37202:	f7ff ff91 	bl	37128 <unpack_uint16>
	if (err_code != 0) {
   37206:	4606      	mov	r6, r0
   37208:	b9c0      	cbnz	r0, 3723c <publish_decode+0x5c>
	if ((buf->end - buf->cur) < utf8_strlen) {
   3720a:	683b      	ldr	r3, [r7, #0]
   3720c:	687a      	ldr	r2, [r7, #4]
   3720e:	f8bd 4006 	ldrh.w	r4, [sp, #6]
   37212:	1ad2      	subs	r2, r2, r3
   37214:	42a2      	cmp	r2, r4
   37216:	da02      	bge.n	3721e <publish_decode+0x3e>

	if (var_length < var_header_length) {
		MQTT_ERR("Corrupted PUBLISH message, header length (%u) larger "
			 "than total length (%u)", var_header_length,
			 var_length);
		return -EINVAL;
   37218:	f06f 0615 	mvn.w	r6, #21
   3721c:	e00e      	b.n	3723c <publish_decode+0x5c>
	str->size = utf8_strlen;
   3721e:	606c      	str	r4, [r5, #4]
	if (utf8_strlen) {
   37220:	b184      	cbz	r4, 37244 <publish_decode+0x64>
		str->utf8 = buf->cur;
   37222:	602b      	str	r3, [r5, #0]
		buf->cur += utf8_strlen;
   37224:	4423      	add	r3, r4
   37226:	603b      	str	r3, [r7, #0]
	if (param->message.topic.qos > MQTT_QOS_0_AT_MOST_ONCE) {
   37228:	7a2b      	ldrb	r3, [r5, #8]
   3722a:	b96b      	cbnz	r3, 37248 <publish_decode+0x68>
	var_header_length = param->message.topic.topic.size + sizeof(u16_t);
   3722c:	3402      	adds	r4, #2
	if (var_length < var_header_length) {
   3722e:	4544      	cmp	r4, r8
   37230:	d8f2      	bhi.n	37218 <publish_decode+0x38>
	}

	param->message.payload.data = NULL;
   37232:	2300      	movs	r3, #0
	param->message.payload.len = var_length - var_header_length;
   37234:	eba8 0404 	sub.w	r4, r8, r4
	param->message.payload.data = NULL;
   37238:	60eb      	str	r3, [r5, #12]
	param->message.payload.len = var_length - var_header_length;
   3723a:	612c      	str	r4, [r5, #16]

	return 0;
}
   3723c:	4630      	mov	r0, r6
   3723e:	b002      	add	sp, #8
   37240:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		str->utf8 = NULL;
   37244:	602c      	str	r4, [r5, #0]
	if (err_code != 0) {
   37246:	e7ef      	b.n	37228 <publish_decode+0x48>
		err_code = unpack_uint16(buf, &param->message_id);
   37248:	f105 0114 	add.w	r1, r5, #20
   3724c:	4638      	mov	r0, r7
   3724e:	f7ff ff6b 	bl	37128 <unpack_uint16>
		if (err_code != 0) {
   37252:	b908      	cbnz	r0, 37258 <publish_decode+0x78>
		var_header_length += sizeof(u16_t);
   37254:	3404      	adds	r4, #4
   37256:	e7ea      	b.n	3722e <publish_decode+0x4e>
   37258:	4606      	mov	r6, r0
   3725a:	e7ef      	b.n	3723c <publish_decode+0x5c>

0003725c <publish_ack_decode>:

int publish_ack_decode(struct buf_ctx *buf, struct mqtt_puback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3725c:	f7ff bf64 	b.w	37128 <unpack_uint16>

00037260 <publish_receive_decode>:
}

int publish_receive_decode(struct buf_ctx *buf, struct mqtt_pubrec_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   37260:	f7ff bf62 	b.w	37128 <unpack_uint16>

00037264 <publish_release_decode>:
}

int publish_release_decode(struct buf_ctx *buf, struct mqtt_pubrel_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   37264:	f7ff bf60 	b.w	37128 <unpack_uint16>

00037268 <publish_complete_decode>:
}

int publish_complete_decode(struct buf_ctx *buf,
			    struct mqtt_pubcomp_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   37268:	f7ff bf5e 	b.w	37128 <unpack_uint16>

0003726c <subscribe_ack_decode>:
}

int subscribe_ack_decode(struct buf_ctx *buf, struct mqtt_suback_param *param)
{
   3726c:	b538      	push	{r3, r4, r5, lr}
   3726e:	4605      	mov	r5, r0
   37270:	460c      	mov	r4, r1
	int err_code;

	err_code = unpack_uint16(buf, &param->message_id);
   37272:	f7ff ff59 	bl	37128 <unpack_uint16>
	if (err_code != 0) {
   37276:	b930      	cbnz	r0, 37286 <subscribe_ack_decode+0x1a>
		return err_code;
	}

	return unpack_data(buf->end - buf->cur, buf, &param->return_codes);
   37278:	e9d5 2300 	ldrd	r2, r3, [r5]
   3727c:	1a99      	subs	r1, r3, r2
	str->len = length;
   3727e:	60a1      	str	r1, [r4, #8]
	if (length > 0) {
   37280:	b111      	cbz	r1, 37288 <subscribe_ack_decode+0x1c>
		str->data = buf->cur;
   37282:	6062      	str	r2, [r4, #4]
		buf->cur += length;
   37284:	602b      	str	r3, [r5, #0]
}
   37286:	bd38      	pop	{r3, r4, r5, pc}
		str->data = NULL;
   37288:	6060      	str	r0, [r4, #4]
   3728a:	e7fc      	b.n	37286 <subscribe_ack_decode+0x1a>

0003728c <unsubscribe_ack_decode>:

int unsubscribe_ack_decode(struct buf_ctx *buf,
			   struct mqtt_unsuback_param *param)
{
	return unpack_uint16(buf, &param->message_id);
   3728c:	f7ff bf4c 	b.w	37128 <unpack_uint16>

00037290 <pack_uint16>:
	if ((buf->end - buf->cur) < sizeof(u16_t)) {
   37290:	e9d1 3200 	ldrd	r3, r2, [r1]
   37294:	1ad2      	subs	r2, r2, r3
   37296:	2a01      	cmp	r2, #1
   37298:	d909      	bls.n	372ae <pack_uint16+0x1e>
	*(buf->cur++) = (val >> 8) & 0xFF;
   3729a:	1c5a      	adds	r2, r3, #1
   3729c:	600a      	str	r2, [r1, #0]
   3729e:	0a02      	lsrs	r2, r0, #8
   372a0:	701a      	strb	r2, [r3, #0]
	*(buf->cur++) = val & 0xFF;
   372a2:	680b      	ldr	r3, [r1, #0]
   372a4:	1c5a      	adds	r2, r3, #1
   372a6:	600a      	str	r2, [r1, #0]
   372a8:	7018      	strb	r0, [r3, #0]
	return 0;
   372aa:	2000      	movs	r0, #0
   372ac:	4770      	bx	lr
		return -ENOMEM;
   372ae:	f06f 000b 	mvn.w	r0, #11
}
   372b2:	4770      	bx	lr

000372b4 <pack_utf8_str>:
{
   372b4:	b538      	push	{r3, r4, r5, lr}
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   372b6:	e9d1 2300 	ldrd	r2, r3, [r1]
{
   372ba:	4605      	mov	r5, r0
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   372bc:	6840      	ldr	r0, [r0, #4]
   372be:	1a9b      	subs	r3, r3, r2
   372c0:	1c82      	adds	r2, r0, #2
   372c2:	4293      	cmp	r3, r2
{
   372c4:	460c      	mov	r4, r1
	if ((buf->end - buf->cur) < GET_UT8STR_BUFFER_SIZE(str)) {
   372c6:	d30d      	bcc.n	372e4 <pack_utf8_str+0x30>
	(void)pack_uint16(str->size, buf);
   372c8:	b280      	uxth	r0, r0
   372ca:	f7ff ffe1 	bl	37290 <pack_uint16>
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   372ce:	e9d5 1200 	ldrd	r1, r2, [r5]
   372d2:	6820      	ldr	r0, [r4, #0]
   372d4:	f001 fe80 	bl	38fd8 <memcpy>
	return 0;
   372d8:	2000      	movs	r0, #0
	buf->cur += str->size;
   372da:	6823      	ldr	r3, [r4, #0]
   372dc:	686a      	ldr	r2, [r5, #4]
   372de:	4413      	add	r3, r2
   372e0:	6023      	str	r3, [r4, #0]
}
   372e2:	bd38      	pop	{r3, r4, r5, pc}
		return -ENOMEM;
   372e4:	f06f 000b 	mvn.w	r0, #11
   372e8:	e7fb      	b.n	372e2 <pack_utf8_str+0x2e>

000372ea <mqtt_encode_fixed_header>:
{
   372ea:	b570      	push	{r4, r5, r6, lr}
	u32_t length = buf->cur - start;
   372ec:	6815      	ldr	r5, [r2, #0]
   372ee:	1a6d      	subs	r5, r5, r1
	if (length > MQTT_MAX_PAYLOAD_SIZE) {
   372f0:	f1b5 5f80 	cmp.w	r5, #268435456	; 0x10000000
   372f4:	d227      	bcs.n	37346 <mqtt_encode_fixed_header+0x5c>
   372f6:	462c      	mov	r4, r5
   372f8:	2600      	movs	r6, #0
	} while (length > 0);
   372fa:	09e4      	lsrs	r4, r4, #7
   372fc:	b2f3      	uxtb	r3, r6
		if (buf != NULL) {
   372fe:	f106 0601 	add.w	r6, r6, #1
	} while (length > 0);
   37302:	d1fa      	bne.n	372fa <mqtt_encode_fixed_header+0x10>
	fixed_header_length += sizeof(u8_t);
   37304:	3302      	adds	r3, #2
	buf->cur = start - fixed_header_length;
   37306:	b2db      	uxtb	r3, r3
   37308:	425b      	negs	r3, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3730a:	6856      	ldr	r6, [r2, #4]
	buf->cur = start - fixed_header_length;
   3730c:	18cc      	adds	r4, r1, r3
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3730e:	42b4      	cmp	r4, r6
	buf->cur = start - fixed_header_length;
   37310:	6014      	str	r4, [r2, #0]
	*(buf->cur++) = val;
   37312:	bf1e      	ittt	ne
   37314:	3401      	addne	r4, #1
   37316:	6014      	strne	r4, [r2, #0]
   37318:	54c8      	strbne	r0, [r1, r3]
	return 0;
   3731a:	4628      	mov	r0, r5
			*(buf->cur) = length & MQTT_LENGTH_VALUE_MASK;
   3731c:	6811      	ldr	r1, [r2, #0]
   3731e:	f000 047f 	and.w	r4, r0, #127	; 0x7f
   37322:	700c      	strb	r4, [r1, #0]
			if (length > 0) {
   37324:	09c0      	lsrs	r0, r0, #7
				*(buf->cur) |= MQTT_LENGTH_CONTINUATION_BIT;
   37326:	bf1f      	itttt	ne
   37328:	6814      	ldrne	r4, [r2, #0]
   3732a:	7821      	ldrbne	r1, [r4, #0]
   3732c:	f061 017f 	ornne	r1, r1, #127	; 0x7f
   37330:	7021      	strbne	r1, [r4, #0]
			buf->cur++;
   37332:	6811      	ldr	r1, [r2, #0]
   37334:	3101      	adds	r1, #1
   37336:	6011      	str	r1, [r2, #0]
	} while (length > 0);
   37338:	2800      	cmp	r0, #0
   3733a:	d1ef      	bne.n	3731c <mqtt_encode_fixed_header+0x32>
	buf->cur = buf->cur - fixed_header_length;
   3733c:	440b      	add	r3, r1
	buf->end = buf->cur + length + fixed_header_length;
   3733e:	4429      	add	r1, r5
	buf->cur = buf->cur - fixed_header_length;
   37340:	6013      	str	r3, [r2, #0]
	buf->end = buf->cur + length + fixed_header_length;
   37342:	6051      	str	r1, [r2, #4]
}
   37344:	bd70      	pop	{r4, r5, r6, pc}
		return -EMSGSIZE;
   37346:	f06f 0079 	mvn.w	r0, #121	; 0x79
   3734a:	e7fb      	b.n	37344 <mqtt_encode_fixed_header+0x5a>

0003734c <mqtt_message_id_only_enc>:
{
   3734c:	b570      	push	{r4, r5, r6, lr}
   3734e:	4606      	mov	r6, r0
   37350:	4615      	mov	r5, r2
	if (message_id == 0U) {
   37352:	4608      	mov	r0, r1
   37354:	b169      	cbz	r1, 37372 <mqtt_message_id_only_enc+0x26>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   37356:	6814      	ldr	r4, [r2, #0]
	err_code = pack_uint16(message_id, buf);
   37358:	4611      	mov	r1, r2
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   3735a:	3405      	adds	r4, #5
   3735c:	6014      	str	r4, [r2, #0]
	err_code = pack_uint16(message_id, buf);
   3735e:	f7ff ff97 	bl	37290 <pack_uint16>
	if (err_code != 0) {
   37362:	b940      	cbnz	r0, 37376 <mqtt_message_id_only_enc+0x2a>
	return mqtt_encode_fixed_header(message_type, start, buf);
   37364:	462a      	mov	r2, r5
   37366:	4621      	mov	r1, r4
   37368:	4630      	mov	r0, r6
}
   3736a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   3736e:	f7ff bfbc 	b.w	372ea <mqtt_encode_fixed_header>
		return -EINVAL;
   37372:	f06f 0015 	mvn.w	r0, #21
}
   37376:	bd70      	pop	{r4, r5, r6, pc}

00037378 <publish_encode>:
{
   37378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   3737c:	4607      	mov	r7, r0
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   3737e:	7d80      	ldrb	r0, [r0, #22]
   37380:	7a3c      	ldrb	r4, [r7, #8]
{
   37382:	460d      	mov	r5, r1
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   37384:	f000 0801 	and.w	r8, r0, #1
   37388:	f3c0 0940 	ubfx	r9, r0, #1, #1
	if ((param->message.topic.qos) && (param->message_id == 0U)) {
   3738c:	b10c      	cbz	r4, 37392 <publish_encode+0x1a>
   3738e:	8abb      	ldrh	r3, [r7, #20]
   37390:	b35b      	cbz	r3, 373ea <publish_encode+0x72>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   37392:	682e      	ldr	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   37394:	4629      	mov	r1, r5
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   37396:	3605      	adds	r6, #5
   37398:	602e      	str	r6, [r5, #0]
	err_code = pack_utf8_str(&param->message.topic.topic, buf);
   3739a:	4638      	mov	r0, r7
   3739c:	f7ff ff8a 	bl	372b4 <pack_utf8_str>
	if (err_code != 0) {
   373a0:	b9a8      	cbnz	r0, 373ce <publish_encode+0x56>
	if (param->message.topic.qos) {
   373a2:	7a3b      	ldrb	r3, [r7, #8]
   373a4:	b9ab      	cbnz	r3, 373d2 <publish_encode+0x5a>
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   373a6:	0060      	lsls	r0, r4, #1
   373a8:	f000 0006 	and.w	r0, r0, #6
	buf->cur += param->message.payload.len;
   373ac:	693a      	ldr	r2, [r7, #16]
   373ae:	682b      	ldr	r3, [r5, #0]
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   373b0:	ea40 0009 	orr.w	r0, r0, r9
   373b4:	ea40 00c8 	orr.w	r0, r0, r8, lsl #3
	buf->cur += param->message.payload.len;
   373b8:	4413      	add	r3, r2
	const u8_t message_type = MQTT_MESSAGES_OPTIONS(
   373ba:	f040 0030 	orr.w	r0, r0, #48	; 0x30
	buf->cur += param->message.payload.len;
   373be:	602b      	str	r3, [r5, #0]
	err_code = mqtt_encode_fixed_header(message_type, start, buf);
   373c0:	462a      	mov	r2, r5
   373c2:	4631      	mov	r1, r6
   373c4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   373c8:	f7ff ff8f 	bl	372ea <mqtt_encode_fixed_header>
	if (err_code != 0) {
   373cc:	b140      	cbz	r0, 373e0 <publish_encode+0x68>
}
   373ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_uint16(param->message_id, buf);
   373d2:	4629      	mov	r1, r5
   373d4:	8ab8      	ldrh	r0, [r7, #20]
   373d6:	f7ff ff5b 	bl	37290 <pack_uint16>
		if (err_code != 0) {
   373da:	2800      	cmp	r0, #0
   373dc:	d0e3      	beq.n	373a6 <publish_encode+0x2e>
   373de:	e7f6      	b.n	373ce <publish_encode+0x56>
	buf->end -= param->message.payload.len;
   373e0:	686b      	ldr	r3, [r5, #4]
   373e2:	693a      	ldr	r2, [r7, #16]
   373e4:	1a9b      	subs	r3, r3, r2
   373e6:	606b      	str	r3, [r5, #4]
	return 0;
   373e8:	e7f1      	b.n	373ce <publish_encode+0x56>
		return -EINVAL;
   373ea:	f06f 0015 	mvn.w	r0, #21
   373ee:	e7ee      	b.n	373ce <publish_encode+0x56>

000373f0 <publish_ack_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
   373f0:	460a      	mov	r2, r1
   373f2:	8801      	ldrh	r1, [r0, #0]
   373f4:	2040      	movs	r0, #64	; 0x40
   373f6:	f7ff bfa9 	b.w	3734c <mqtt_message_id_only_enc>

000373fa <publish_release_encode>:
	return mqtt_message_id_only_enc(message_type, param->message_id, buf);
   373fa:	460a      	mov	r2, r1
   373fc:	8801      	ldrh	r1, [r0, #0]
   373fe:	2062      	movs	r0, #98	; 0x62
   37400:	f7ff bfa4 	b.w	3734c <mqtt_message_id_only_enc>

00037404 <subscribe_encode>:
{
   37404:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   37408:	4607      	mov	r7, r0
	if (param->message_id == 0U) {
   3740a:	88c0      	ldrh	r0, [r0, #6]
{
   3740c:	460d      	mov	r5, r1
	if (param->message_id == 0U) {
   3740e:	b330      	cbz	r0, 3745e <subscribe_encode+0x5a>
	buf->cur += MQTT_FIXED_HEADER_MAX_SIZE;
   37410:	680e      	ldr	r6, [r1, #0]
   37412:	3605      	adds	r6, #5
   37414:	600e      	str	r6, [r1, #0]
	err_code = pack_uint16(param->message_id, buf);
   37416:	f7ff ff3b 	bl	37290 <pack_uint16>
	if (err_code != 0) {
   3741a:	4604      	mov	r4, r0
   3741c:	bb08      	cbnz	r0, 37462 <subscribe_encode+0x5e>
   3741e:	f04f 090c 	mov.w	r9, #12
	for (i = 0; i < param->list_count; i++) {
   37422:	88bb      	ldrh	r3, [r7, #4]
   37424:	42a3      	cmp	r3, r4
   37426:	dc06      	bgt.n	37436 <subscribe_encode+0x32>
	return mqtt_encode_fixed_header(message_type, start, buf);
   37428:	462a      	mov	r2, r5
   3742a:	4631      	mov	r1, r6
}
   3742c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return mqtt_encode_fixed_header(message_type, start, buf);
   37430:	2082      	movs	r0, #130	; 0x82
   37432:	f7ff bf5a 	b.w	372ea <mqtt_encode_fixed_header>
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   37436:	fb09 f804 	mul.w	r8, r9, r4
   3743a:	6838      	ldr	r0, [r7, #0]
   3743c:	4629      	mov	r1, r5
   3743e:	4440      	add	r0, r8
   37440:	f7ff ff38 	bl	372b4 <pack_utf8_str>
		if (err_code != 0) {
   37444:	b980      	cbnz	r0, 37468 <subscribe_encode+0x64>
		err_code = pack_uint8(param->list[i].qos, buf);
   37446:	683b      	ldr	r3, [r7, #0]
   37448:	4443      	add	r3, r8
   3744a:	7a1a      	ldrb	r2, [r3, #8]
	if ((buf->end - buf->cur) < sizeof(u8_t)) {
   3744c:	e9d5 3100 	ldrd	r3, r1, [r5]
   37450:	4299      	cmp	r1, r3
   37452:	d00b      	beq.n	3746c <subscribe_encode+0x68>
	*(buf->cur++) = val;
   37454:	1c59      	adds	r1, r3, #1
   37456:	6029      	str	r1, [r5, #0]
	for (i = 0; i < param->list_count; i++) {
   37458:	3401      	adds	r4, #1
	*(buf->cur++) = val;
   3745a:	701a      	strb	r2, [r3, #0]
		if (err_code != 0) {
   3745c:	e7e1      	b.n	37422 <subscribe_encode+0x1e>
		return -EINVAL;
   3745e:	f06f 0415 	mvn.w	r4, #21
}
   37462:	4620      	mov	r0, r4
   37464:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		err_code = pack_utf8_str(&param->list[i].topic, buf);
   37468:	4604      	mov	r4, r0
   3746a:	e7fa      	b.n	37462 <subscribe_encode+0x5e>
		return -ENOMEM;
   3746c:	f06f 040b 	mvn.w	r4, #11
   37470:	e7f7      	b.n	37462 <subscribe_encode+0x5e>

00037472 <mqtt_read_message_chunk>:
	return err_code;
}

static int mqtt_read_message_chunk(struct mqtt_client *client,
				   struct buf_ctx *buf, u32_t length)
{
   37472:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   37474:	460d      	mov	r5, r1
	u32_t remaining;
	int len;

	/* In case all data requested has already been buffered, return. */
	if (length <= (buf->end - buf->cur)) {
   37476:	e9d1 3100 	ldrd	r3, r1, [r1]
   3747a:	1acb      	subs	r3, r1, r3
   3747c:	4293      	cmp	r3, r2
{
   3747e:	4606      	mov	r6, r0
	if (length <= (buf->end - buf->cur)) {
   37480:	d301      	bcc.n	37486 <mqtt_read_message_chunk+0x14>
		return 0;
   37482:	2000      	movs	r0, #0
		MQTT_TRC("[CID %p]: Message partially received.", client);
		return -EAGAIN;
	}

	return 0;
}
   37484:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	remaining = length - (buf->end - buf->cur);
   37486:	1ad4      	subs	r4, r2, r3
	if ((buf->end + remaining > client->rx_buf + client->rx_buf_size) ||
   37488:	190f      	adds	r7, r1, r4
   3748a:	e9d0 231a 	ldrd	r2, r3, [r0, #104]	; 0x68
   3748e:	4413      	add	r3, r2
   37490:	429f      	cmp	r7, r3
   37492:	d813      	bhi.n	374bc <mqtt_read_message_chunk+0x4a>
   37494:	4297      	cmp	r7, r2
   37496:	d311      	bcc.n	374bc <mqtt_read_message_chunk+0x4a>
	len = mqtt_transport_read(client, buf->end, remaining, false);
   37498:	2300      	movs	r3, #0
   3749a:	4622      	mov	r2, r4
   3749c:	f7e7 fbb4 	bl	1ec08 <mqtt_transport_read>
	if (len < 0) {
   374a0:	2800      	cmp	r0, #0
   374a2:	dbef      	blt.n	37484 <mqtt_read_message_chunk+0x12>
	if (len == 0) {
   374a4:	d00d      	beq.n	374c2 <mqtt_read_message_chunk+0x50>
	client->internal.rx_buf_datalen += len;
   374a6:	69f3      	ldr	r3, [r6, #28]
	if (len < remaining) {
   374a8:	42a0      	cmp	r0, r4
	client->internal.rx_buf_datalen += len;
   374aa:	4403      	add	r3, r0
   374ac:	61f3      	str	r3, [r6, #28]
	buf->end += len;
   374ae:	686b      	ldr	r3, [r5, #4]
   374b0:	4403      	add	r3, r0
   374b2:	606b      	str	r3, [r5, #4]
	if (len < remaining) {
   374b4:	d2e5      	bcs.n	37482 <mqtt_read_message_chunk+0x10>
		return -EAGAIN;
   374b6:	f06f 000a 	mvn.w	r0, #10
   374ba:	e7e3      	b.n	37484 <mqtt_read_message_chunk+0x12>
		return -ENOMEM;
   374bc:	f06f 000b 	mvn.w	r0, #11
   374c0:	e7e0      	b.n	37484 <mqtt_read_message_chunk+0x12>
		return -ENOTCONN;
   374c2:	f06f 007f 	mvn.w	r0, #127	; 0x7f
   374c6:	e7dd      	b.n	37484 <mqtt_read_message_chunk+0x12>

000374c8 <mqtt_handle_rx>:

	return err_code;
}

int mqtt_handle_rx(struct mqtt_client *client)
{
   374c8:	b570      	push	{r4, r5, r6, lr}
	int err_code;
	u8_t type_and_flags;
	u32_t var_length;
	struct buf_ctx buf;

	buf.cur = client->rx_buf;
   374ca:	6e83      	ldr	r3, [r0, #104]	; 0x68
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   374cc:	69c2      	ldr	r2, [r0, #28]
{
   374ce:	b08c      	sub	sp, #48	; 0x30
	buf.cur = client->rx_buf;
   374d0:	9302      	str	r3, [sp, #8]
{
   374d2:	4605      	mov	r5, r0
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   374d4:	4413      	add	r3, r2
	u8_t chunk_size = MQTT_FIXED_HEADER_MIN_SIZE;
   374d6:	2202      	movs	r2, #2
	buf.end = client->rx_buf + client->internal.rx_buf_datalen;
   374d8:	9303      	str	r3, [sp, #12]
		err_code = mqtt_read_message_chunk(client, buf, chunk_size);
   374da:	a902      	add	r1, sp, #8
   374dc:	4628      	mov	r0, r5
   374de:	f7ff ffc8 	bl	37472 <mqtt_read_message_chunk>
		if (err_code < 0) {
   374e2:	1e04      	subs	r4, r0, #0
   374e4:	db2b      	blt.n	3753e <mqtt_handle_rx+0x76>
		buf->cur = client->rx_buf;
   374e6:	6eab      	ldr	r3, [r5, #104]	; 0x68
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   374e8:	aa01      	add	r2, sp, #4
   374ea:	f10d 0103 	add.w	r1, sp, #3
   374ee:	a802      	add	r0, sp, #8
		buf->cur = client->rx_buf;
   374f0:	9302      	str	r3, [sp, #8]
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   374f2:	f7ff fe2f 	bl	37154 <fixed_header_decode>
	} while (err_code == -EAGAIN);
   374f6:	f110 0f0b 	cmn.w	r0, #11
		err_code = fixed_header_decode(buf, type_and_flags, var_length);
   374fa:	4604      	mov	r4, r0
		chunk_size = 1U;
   374fc:	f04f 0201 	mov.w	r2, #1
	} while (err_code == -EAGAIN);
   37500:	d0eb      	beq.n	374da <mqtt_handle_rx+0x12>

	err_code = mqtt_read_and_parse_fixed_header(client, &type_and_flags,
						    &var_length, &buf);
	if (err_code < 0) {
   37502:	2800      	cmp	r0, #0
   37504:	db1f      	blt.n	37546 <mqtt_handle_rx+0x7e>
		return (err_code == -EAGAIN) ? 0 : err_code;
	}

	if ((type_and_flags & 0xF0) == MQTT_PKT_TYPE_PUBLISH) {
   37506:	f89d 6003 	ldrb.w	r6, [sp, #3]
   3750a:	f006 03f0 	and.w	r3, r6, #240	; 0xf0
   3750e:	2b30      	cmp	r3, #48	; 0x30
   37510:	d11c      	bne.n	3754c <mqtt_handle_rx+0x84>
	err_code = mqtt_read_message_chunk(client, buf, sizeof(u16_t));
   37512:	2202      	movs	r2, #2
   37514:	a902      	add	r1, sp, #8
   37516:	4628      	mov	r0, r5
   37518:	f7ff ffab 	bl	37472 <mqtt_read_message_chunk>
	if (err_code < 0) {
   3751c:	1e04      	subs	r4, r0, #0
   3751e:	db0e      	blt.n	3753e <mqtt_handle_rx+0x76>
	variable_header_length = *buf->cur << 8; /* MSB */
   37520:	9b02      	ldr	r3, [sp, #8]
	if (qos > MQTT_QOS_0_AT_MOST_ONCE) {
   37522:	f016 0f06 	tst.w	r6, #6
   37526:	881a      	ldrh	r2, [r3, #0]
   37528:	ba52      	rev16	r2, r2
   3752a:	b292      	uxth	r2, r2
	variable_header_length += sizeof(u16_t);
   3752c:	bf0c      	ite	eq
   3752e:	3202      	addeq	r2, #2
		variable_header_length += sizeof(u16_t);
   37530:	3204      	addne	r2, #4
		err_code = mqtt_read_publish_var_header(client, type_and_flags,
							&buf);
	} else {
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   37532:	a902      	add	r1, sp, #8
   37534:	4628      	mov	r0, r5
   37536:	f7ff ff9c 	bl	37472 <mqtt_read_message_chunk>
	}

	if (err_code < 0) {
   3753a:	1e04      	subs	r4, r0, #0
   3753c:	da08      	bge.n	37550 <mqtt_handle_rx+0x88>
		return (err_code == -EAGAIN) ? 0 : err_code;
   3753e:	f114 0f0b 	cmn.w	r4, #11
   37542:	d100      	bne.n	37546 <mqtt_handle_rx+0x7e>
   37544:	2400      	movs	r4, #0
	}

	client->internal.rx_buf_datalen = 0U;

	return 0;
}
   37546:	4620      	mov	r0, r4
   37548:	b00c      	add	sp, #48	; 0x30
   3754a:	bd70      	pop	{r4, r5, r6, pc}
		err_code = mqtt_read_message_chunk(client, &buf, var_length);
   3754c:	9a01      	ldr	r2, [sp, #4]
   3754e:	e7f0      	b.n	37532 <mqtt_handle_rx+0x6a>
	evt.result = 0;
   37550:	2200      	movs	r2, #0
	err_code = mqtt_handle_packet(client, type_and_flags, var_length, &buf);
   37552:	f89d 0003 	ldrb.w	r0, [sp, #3]
   37556:	9901      	ldr	r1, [sp, #4]
	evt.result = 0;
   37558:	f000 03f0 	and.w	r3, r0, #240	; 0xf0
	switch (type_and_flags & 0xF0) {
   3755c:	2b60      	cmp	r3, #96	; 0x60
	evt.result = 0;
   3755e:	920b      	str	r2, [sp, #44]	; 0x2c
	switch (type_and_flags & 0xF0) {
   37560:	d063      	beq.n	3762a <mqtt_handle_rx+0x162>
   37562:	d813      	bhi.n	3758c <mqtt_handle_rx+0xc4>
   37564:	2b30      	cmp	r3, #48	; 0x30
   37566:	d04a      	beq.n	375fe <mqtt_handle_rx+0x136>
   37568:	d804      	bhi.n	37574 <mqtt_handle_rx+0xac>
   3756a:	2b20      	cmp	r3, #32
   3756c:	d02f      	beq.n	375ce <mqtt_handle_rx+0x106>
	client->internal.rx_buf_datalen = 0U;
   3756e:	2400      	movs	r4, #0
   37570:	61ec      	str	r4, [r5, #28]
	return 0;
   37572:	e7e8      	b.n	37546 <mqtt_handle_rx+0x7e>
	switch (type_and_flags & 0xF0) {
   37574:	2b40      	cmp	r3, #64	; 0x40
   37576:	d04e      	beq.n	37616 <mqtt_handle_rx+0x14e>
   37578:	2b50      	cmp	r3, #80	; 0x50
   3757a:	d1f8      	bne.n	3756e <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBREC;
   3757c:	2304      	movs	r3, #4
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   3757e:	a905      	add	r1, sp, #20
   37580:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREC;
   37582:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_receive_decode(buf, &evt.param.pubrec);
   37586:	f7ff fe6b 	bl	37260 <publish_receive_decode>
   3758a:	e04b      	b.n	37624 <mqtt_handle_rx+0x15c>
	switch (type_and_flags & 0xF0) {
   3758c:	2b90      	cmp	r3, #144	; 0x90
   3758e:	d054      	beq.n	3763a <mqtt_handle_rx+0x172>
   37590:	d809      	bhi.n	375a6 <mqtt_handle_rx+0xde>
   37592:	2b70      	cmp	r3, #112	; 0x70
   37594:	d1eb      	bne.n	3756e <mqtt_handle_rx+0xa6>
		evt.type = MQTT_EVT_PUBCOMP;
   37596:	2306      	movs	r3, #6
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   37598:	a905      	add	r1, sp, #20
   3759a:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBCOMP;
   3759c:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_complete_decode(buf, &evt.param.pubcomp);
   375a0:	f7ff fe62 	bl	37268 <publish_complete_decode>
   375a4:	e03e      	b.n	37624 <mqtt_handle_rx+0x15c>
	switch (type_and_flags & 0xF0) {
   375a6:	2bb0      	cmp	r3, #176	; 0xb0
   375a8:	d04f      	beq.n	3764a <mqtt_handle_rx+0x182>
   375aa:	2bd0      	cmp	r3, #208	; 0xd0
   375ac:	d1df      	bne.n	3756e <mqtt_handle_rx+0xa6>
		if (client->unacked_ping <= 0) {
   375ae:	f995 307b 	ldrsb.w	r3, [r5, #123]	; 0x7b
	int err_code = 0;
   375b2:	2400      	movs	r4, #0
		if (client->unacked_ping <= 0) {
   375b4:	2b00      	cmp	r3, #0
			client->unacked_ping--;
   375b6:	bfc8      	it	gt
   375b8:	f103 32ff 	addgt.w	r2, r3, #4294967295	; 0xffffffff
		evt.type = MQTT_EVT_PINGRESP;
   375bc:	f04f 0309 	mov.w	r3, #9
			client->unacked_ping--;
   375c0:	bfc8      	it	gt
   375c2:	b252      	sxtbgt	r2, r2
   375c4:	f885 207b 	strb.w	r2, [r5, #123]	; 0x7b
		evt.type = MQTT_EVT_PINGRESP;
   375c8:	f88d 3010 	strb.w	r3, [sp, #16]
	if (notify_event == true) {
   375cc:	e010      	b.n	375f0 <mqtt_handle_rx+0x128>
		evt.type = MQTT_EVT_CONNACK;
   375ce:	f88d 2010 	strb.w	r2, [sp, #16]
		err_code = connect_ack_decode(client, buf, &evt.param.connack);
   375d2:	a902      	add	r1, sp, #8
   375d4:	aa05      	add	r2, sp, #20
   375d6:	4628      	mov	r0, r5
   375d8:	f7ff fde7 	bl	371aa <connect_ack_decode>
		if (err_code == 0) {
   375dc:	4604      	mov	r4, r0
   375de:	bb10      	cbnz	r0, 37626 <mqtt_handle_rx+0x15e>
			if (evt.param.connack.return_code ==
   375e0:	f89d 2015 	ldrb.w	r2, [sp, #21]
   375e4:	b91a      	cbnz	r2, 375ee <mqtt_handle_rx+0x126>
				MQTT_SET_STATE(client, MQTT_STATE_CONNECTED);
   375e6:	69ab      	ldr	r3, [r5, #24]
   375e8:	f043 0304 	orr.w	r3, r3, #4
   375ec:	61ab      	str	r3, [r5, #24]
			evt.result = evt.param.connack.return_code;
   375ee:	920b      	str	r2, [sp, #44]	; 0x2c
		event_notify(client, &evt);
   375f0:	a904      	add	r1, sp, #16
   375f2:	4628      	mov	r0, r5
   375f4:	f000 f8bb 	bl	3776e <event_notify>
	if (err_code < 0) {
   375f8:	2c00      	cmp	r4, #0
   375fa:	dab8      	bge.n	3756e <mqtt_handle_rx+0xa6>
   375fc:	e7a3      	b.n	37546 <mqtt_handle_rx+0x7e>
		evt.type = MQTT_EVT_PUBLISH;
   375fe:	2302      	movs	r3, #2
		err_code = publish_decode(type_and_flags, var_length, buf,
   37600:	aa02      	add	r2, sp, #8
		evt.type = MQTT_EVT_PUBLISH;
   37602:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_decode(type_and_flags, var_length, buf,
   37606:	ab05      	add	r3, sp, #20
   37608:	f7ff fdea 	bl	371e0 <publish_decode>
		client->internal.remaining_payload =
   3760c:	9b09      	ldr	r3, [sp, #36]	; 0x24
		err_code = publish_decode(type_and_flags, var_length, buf,
   3760e:	4604      	mov	r4, r0
		evt.result = err_code;
   37610:	900b      	str	r0, [sp, #44]	; 0x2c
		client->internal.remaining_payload =
   37612:	622b      	str	r3, [r5, #32]
	if (notify_event == true) {
   37614:	e7ec      	b.n	375f0 <mqtt_handle_rx+0x128>
		evt.type = MQTT_EVT_PUBACK;
   37616:	2303      	movs	r3, #3
		err_code = publish_ack_decode(buf, &evt.param.puback);
   37618:	a905      	add	r1, sp, #20
   3761a:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBACK;
   3761c:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_ack_decode(buf, &evt.param.puback);
   37620:	f7ff fe1c 	bl	3725c <publish_ack_decode>
   37624:	4604      	mov	r4, r0
		evt.result = err_code;
   37626:	940b      	str	r4, [sp, #44]	; 0x2c
	if (notify_event == true) {
   37628:	e7e2      	b.n	375f0 <mqtt_handle_rx+0x128>
		evt.type = MQTT_EVT_PUBREL;
   3762a:	2305      	movs	r3, #5
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   3762c:	a905      	add	r1, sp, #20
   3762e:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_PUBREL;
   37630:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = publish_release_decode(buf, &evt.param.pubrel);
   37634:	f7ff fe16 	bl	37264 <publish_release_decode>
   37638:	e7f4      	b.n	37624 <mqtt_handle_rx+0x15c>
		evt.type = MQTT_EVT_SUBACK;
   3763a:	2307      	movs	r3, #7
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   3763c:	a905      	add	r1, sp, #20
   3763e:	a802      	add	r0, sp, #8
		evt.type = MQTT_EVT_SUBACK;
   37640:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = subscribe_ack_decode(buf, &evt.param.suback);
   37644:	f7ff fe12 	bl	3726c <subscribe_ack_decode>
   37648:	e7ec      	b.n	37624 <mqtt_handle_rx+0x15c>
		evt.type = MQTT_EVT_UNSUBACK;
   3764a:	2308      	movs	r3, #8
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   3764c:	a905      	add	r1, sp, #20
   3764e:	eb0d 0003 	add.w	r0, sp, r3
		evt.type = MQTT_EVT_UNSUBACK;
   37652:	f88d 3010 	strb.w	r3, [sp, #16]
		err_code = unsubscribe_ack_decode(buf, &evt.param.unsuback);
   37656:	f7ff fe19 	bl	3728c <unsubscribe_ack_decode>
   3765a:	e7e3      	b.n	37624 <mqtt_handle_rx+0x15c>

0003765c <mqtt_client_tcp_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tcp_connect(struct mqtt_client *client)
{
   3765c:	b538      	push	{r3, r4, r5, lr}
	const struct sockaddr *broker = client->broker;
   3765e:	6d05      	ldr	r5, [r0, #80]	; 0x50
{
   37660:	4604      	mov	r4, r0
	int ret;

	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   37662:	8828      	ldrh	r0, [r5, #0]
	return z_impl_zsock_socket(family, type, proto);
   37664:	2206      	movs	r2, #6
   37666:	2101      	movs	r1, #1
   37668:	f7e1 fecc 	bl	19404 <z_impl_zsock_socket>
					    IPPROTO_TCP);
	if (client->transport.tcp.sock < 0) {
   3766c:	2800      	cmp	r0, #0
	client->transport.tcp.sock = socket(broker->sa_family, SOCK_STREAM,
   3766e:	62a0      	str	r0, [r4, #40]	; 0x28
	if (client->transport.tcp.sock < 0) {
   37670:	da04      	bge.n	3767c <mqtt_client_tcp_connect+0x20>

	ret = connect(client->transport.tcp.sock, client->broker,
		      peer_addr_size);
	if (ret < 0) {
		(void)close(client->transport.tcp.sock);
		return -errno;
   37672:	f7fd ff39 	bl	354e8 <__errno>
   37676:	6800      	ldr	r0, [r0, #0]
   37678:	4240      	negs	r0, r0
	}

	MQTT_TRC("Connect completed");
	return 0;
}
   3767a:	bd38      	pop	{r3, r4, r5, pc}
	if (broker->sa_family == AF_INET) {
   3767c:	882b      	ldrh	r3, [r5, #0]
	ret = connect(client->transport.tcp.sock, client->broker,
   3767e:	6d21      	ldr	r1, [r4, #80]	; 0x50
	if (broker->sa_family == AF_INET) {
   37680:	2b01      	cmp	r3, #1
		peer_addr_size = sizeof(struct sockaddr_in);
   37682:	bf14      	ite	ne
   37684:	2218      	movne	r2, #24
   37686:	2208      	moveq	r2, #8
	return z_impl_zsock_connect(sock, addr, addrlen);
   37688:	f7fc fbe1 	bl	33e4e <z_impl_zsock_connect>
	if (ret < 0) {
   3768c:	2800      	cmp	r0, #0
   3768e:	da03      	bge.n	37698 <mqtt_client_tcp_connect+0x3c>
		(void)close(client->transport.tcp.sock);
   37690:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return z_impl_zsock_close(sock);
   37692:	f7fc fbc3 	bl	33e1c <z_impl_zsock_close>
   37696:	e7ec      	b.n	37672 <mqtt_client_tcp_connect+0x16>
	return 0;
   37698:	2000      	movs	r0, #0
   3769a:	e7ee      	b.n	3767a <mqtt_client_tcp_connect+0x1e>

0003769c <mqtt_client_tcp_write>:

int mqtt_client_tcp_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   3769c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	u32_t offset = 0U;
   376a0:	2400      	movs	r4, #0
{
   376a2:	4607      	mov	r7, r0
   376a4:	4688      	mov	r8, r1
   376a6:	4615      	mov	r5, r2
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   376a8:	4626      	mov	r6, r4
	int ret;

	while (offset < datalen) {
   376aa:	42ac      	cmp	r4, r5
   376ac:	d301      	bcc.n	376b2 <mqtt_client_tcp_write+0x16>
		}

		offset += ret;
	}

	return 0;
   376ae:	2000      	movs	r0, #0
   376b0:	e00e      	b.n	376d0 <mqtt_client_tcp_write+0x34>
		ret = send(client->transport.tcp.sock, data + offset,
   376b2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   376b4:	2300      	movs	r3, #0
   376b6:	e9cd 6600 	strd	r6, r6, [sp]
   376ba:	1b2a      	subs	r2, r5, r4
   376bc:	eb08 0104 	add.w	r1, r8, r4
   376c0:	f7fc fbe6 	bl	33e90 <z_impl_zsock_sendto>
		if (ret < 0) {
   376c4:	2800      	cmp	r0, #0
   376c6:	da06      	bge.n	376d6 <mqtt_client_tcp_write+0x3a>
			return -errno;
   376c8:	f7fd ff0e 	bl	354e8 <__errno>
   376cc:	6800      	ldr	r0, [r0, #0]
   376ce:	4240      	negs	r0, r0
}
   376d0:	b002      	add	sp, #8
   376d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		offset += ret;
   376d6:	4404      	add	r4, r0
   376d8:	e7e7      	b.n	376aa <mqtt_client_tcp_write+0xe>

000376da <mqtt_client_tcp_write_msg>:

int mqtt_client_tcp_write_msg(struct mqtt_client *client,
			      const struct msghdr *message)

{
   376da:	b508      	push	{r3, lr}
	int ret;

	ret = sendmsg(client->transport.tcp.sock, message, 0);
   376dc:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_sendmsg(sock, msg, flags);
   376de:	2200      	movs	r2, #0
   376e0:	f7fc fc0b 	bl	33efa <z_impl_zsock_sendmsg>
	if (ret < 0) {
   376e4:	2800      	cmp	r0, #0
   376e6:	da04      	bge.n	376f2 <mqtt_client_tcp_write_msg+0x18>
		return -errno;
   376e8:	f7fd fefe 	bl	354e8 <__errno>
   376ec:	6800      	ldr	r0, [r0, #0]
   376ee:	4240      	negs	r0, r0
	}

	return 0;
}
   376f0:	bd08      	pop	{r3, pc}
	return 0;
   376f2:	2000      	movs	r0, #0
   376f4:	e7fc      	b.n	376f0 <mqtt_client_tcp_write_msg+0x16>

000376f6 <mqtt_client_tcp_read>:

int mqtt_client_tcp_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   376f6:	b513      	push	{r0, r1, r4, lr}
   376f8:	2400      	movs	r4, #0
	int flags = 0;
	int ret;

	if (!shall_block) {
   376fa:	2b00      	cmp	r3, #0
		flags |= MSG_DONTWAIT;
   376fc:	bf14      	ite	ne
   376fe:	4623      	movne	r3, r4
   37700:	2340      	moveq	r3, #64	; 0x40
	}

	ret = recv(client->transport.tcp.sock, data, buflen, flags);
   37702:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   37704:	e9cd 4400 	strd	r4, r4, [sp]
   37708:	f7fc fc14 	bl	33f34 <z_impl_zsock_recvfrom>
	if (ret < 0) {
   3770c:	2800      	cmp	r0, #0
   3770e:	da03      	bge.n	37718 <mqtt_client_tcp_read+0x22>
		return -errno;
   37710:	f7fd feea 	bl	354e8 <__errno>
   37714:	6800      	ldr	r0, [r0, #0]
   37716:	4240      	negs	r0, r0
	}

	return ret;
}
   37718:	b002      	add	sp, #8
   3771a:	bd10      	pop	{r4, pc}

0003771c <mqtt_client_tcp_disconnect>:

int mqtt_client_tcp_disconnect(struct mqtt_client *client)
{
   3771c:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tcp.sock);

	ret = close(client->transport.tcp.sock);
   3771e:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_close(sock);
   37720:	f7fc fb7c 	bl	33e1c <z_impl_zsock_close>
	if (ret < 0) {
   37724:	2800      	cmp	r0, #0
   37726:	da04      	bge.n	37732 <mqtt_client_tcp_disconnect+0x16>
		return -errno;
   37728:	f7fd fede 	bl	354e8 <__errno>
   3772c:	6800      	ldr	r0, [r0, #0]
   3772e:	4240      	negs	r0, r0
	}

	return 0;
}
   37730:	bd08      	pop	{r3, pc}
	return 0;
   37732:	2000      	movs	r0, #0
   37734:	e7fc      	b.n	37730 <mqtt_client_tcp_disconnect+0x14>

00037736 <k_uptime_get>:
{
   37736:	b510      	push	{r4, lr}
	return z_impl_k_uptime_ticks();
   37738:	f001 fb80 	bl	38e3c <z_impl_k_uptime_ticks>
			return (t * to_hz + off) / from_hz;
   3773c:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   37740:	fba0 2304 	umull	r2, r3, r0, r4
   37744:	fb04 3301 	mla	r3, r4, r1, r3
   37748:	0bd0      	lsrs	r0, r2, #15
}
   3774a:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   3774e:	0bd9      	lsrs	r1, r3, #15
   37750:	bd10      	pop	{r4, pc}

00037752 <tx_buf_init>:
	client->internal.remaining_payload = 0U;
}

/** @brief Initialize tx buffer. */
static void tx_buf_init(struct mqtt_client *client, struct buf_ctx *buf)
{
   37752:	b538      	push	{r3, r4, r5, lr}
   37754:	4604      	mov	r4, r0
   37756:	460d      	mov	r5, r1
__ssp_bos_icheck3(memset, void *, int)
   37758:	6f42      	ldr	r2, [r0, #116]	; 0x74
   3775a:	2100      	movs	r1, #0
   3775c:	6f00      	ldr	r0, [r0, #112]	; 0x70
   3775e:	f001 fc75 	bl	3904c <memset>
	memset(client->tx_buf, 0, client->tx_buf_size);
	buf->cur = client->tx_buf;
   37762:	6f23      	ldr	r3, [r4, #112]	; 0x70
	buf->end = client->tx_buf + client->tx_buf_size;
   37764:	6f62      	ldr	r2, [r4, #116]	; 0x74
	buf->cur = client->tx_buf;
   37766:	602b      	str	r3, [r5, #0]
	buf->end = client->tx_buf + client->tx_buf_size;
   37768:	4413      	add	r3, r2
   3776a:	606b      	str	r3, [r5, #4]
}
   3776c:	bd38      	pop	{r3, r4, r5, pc}

0003776e <event_notify>:
	/* Reset internal state. */
	client_reset(client);
}

void event_notify(struct mqtt_client *client, const struct mqtt_evt *evt)
{
   3776e:	b538      	push	{r3, r4, r5, lr}
	if (client->evt_cb != NULL) {
   37770:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
   37772:	4604      	mov	r4, r0
   37774:	460d      	mov	r5, r1
	if (client->evt_cb != NULL) {
   37776:	b153      	cbz	r3, 3778e <event_notify+0x20>
		mqtt_mutex_unlock(client);
   37778:	f7e7 fa5e 	bl	1ec38 <mqtt_mutex_unlock>

		client->evt_cb(client, evt);
   3777c:	4620      	mov	r0, r4
   3777e:	6e63      	ldr	r3, [r4, #100]	; 0x64
   37780:	4629      	mov	r1, r5
   37782:	4798      	blx	r3

		mqtt_mutex_lock(client);
   37784:	4620      	mov	r0, r4
	}
}
   37786:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		mqtt_mutex_lock(client);
   3778a:	f7e7 ba81 	b.w	1ec90 <mqtt_mutex_lock>
}
   3778e:	bd38      	pop	{r3, r4, r5, pc}

00037790 <client_disconnect>:

static void client_disconnect(struct mqtt_client *client, int result)
{
   37790:	b530      	push	{r4, r5, lr}
   37792:	4604      	mov	r4, r0
   37794:	b089      	sub	sp, #36	; 0x24
   37796:	460d      	mov	r5, r1
	int err_code;

	err_code = mqtt_transport_disconnect(client);
   37798:	f7e7 fa44 	bl	1ec24 <mqtt_transport_disconnect>
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3779c:	69a3      	ldr	r3, [r4, #24]
	event_notify(client, &evt);
   3779e:	4669      	mov	r1, sp
	if (MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   377a0:	f013 0304 	ands.w	r3, r3, #4
		evt.type = MQTT_EVT_DISCONNECT;
   377a4:	bf12      	itee	ne
   377a6:	2301      	movne	r3, #1
		evt.type = MQTT_EVT_CONNACK;
   377a8:	f88d 3000 	strbeq.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   377ac:	f06f 036e 	mvneq.w	r3, #110	; 0x6e
	event_notify(client, &evt);
   377b0:	4620      	mov	r0, r4
		evt.type = MQTT_EVT_DISCONNECT;
   377b2:	bf16      	itet	ne
   377b4:	f88d 3000 	strbne.w	r3, [sp]
		evt.result = -ECONNREFUSED;
   377b8:	9307      	streq	r3, [sp, #28]
		evt.result = result;
   377ba:	9507      	strne	r5, [sp, #28]
	event_notify(client, &evt);
   377bc:	f7ff ffd7 	bl	3776e <event_notify>
	MQTT_STATE_INIT(client);
   377c0:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   377c2:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   377c6:	e9c4 3307 	strd	r3, r3, [r4, #28]
	if (err_code < 0) {
		MQTT_ERR("Failed to disconnect transport!");
	}

	disconnect_event_notify(client, result);
}
   377ca:	b009      	add	sp, #36	; 0x24
   377cc:	bd30      	pop	{r4, r5, pc}

000377ce <client_write>:
	return err_code;
}

static int client_write(struct mqtt_client *client, const u8_t *data,
			u32_t datalen)
{
   377ce:	b538      	push	{r3, r4, r5, lr}
   377d0:	4605      	mov	r5, r0
	int err_code;

	MQTT_TRC("[%p]: Transport writing %d bytes.", client, datalen);

	err_code = mqtt_transport_write(client, data, datalen);
   377d2:	f7e7 f9ff 	bl	1ebd4 <mqtt_transport_write>
	if (err_code < 0) {
   377d6:	1e04      	subs	r4, r0, #0
   377d8:	da05      	bge.n	377e6 <client_write+0x18>
		MQTT_TRC("Transport write failed, err_code = %d, "
			 "closing connection", err_code);
		client_disconnect(client, err_code);
   377da:	4621      	mov	r1, r4
   377dc:	4628      	mov	r0, r5
   377de:	f7ff ffd7 	bl	37790 <client_disconnect>

	MQTT_TRC("[%p]: Transport write complete.", client);
	client->internal.last_activity = mqtt_sys_tick_in_ms_get();

	return 0;
}
   377e2:	4620      	mov	r0, r4
   377e4:	bd38      	pop	{r3, r4, r5, pc}
	return (u32_t)k_uptime_get();
   377e6:	f7ff ffa6 	bl	37736 <k_uptime_get>
	return 0;
   377ea:	2400      	movs	r4, #0
   377ec:	6168      	str	r0, [r5, #20]
   377ee:	e7f8      	b.n	377e2 <client_write+0x14>

000377f0 <mqtt_client_init>:

	return 0;
}

void mqtt_client_init(struct mqtt_client *client)
{
   377f0:	b510      	push	{r4, lr}
	NULL_PARAM_CHECK_VOID(client);
   377f2:	4604      	mov	r4, r0
   377f4:	b1a0      	cbz	r0, 37820 <mqtt_client_init+0x30>
   377f6:	2280      	movs	r2, #128	; 0x80
   377f8:	2100      	movs	r1, #0
   377fa:	f001 fc27 	bl	3904c <memset>

	memset(client, 0, sizeof(*client));

	MQTT_STATE_INIT(client);
   377fe:	2300      	movs	r3, #0
   37800:	61a3      	str	r3, [r4, #24]
	return z_impl_k_mutex_init(mutex);
   37802:	4620      	mov	r0, r4
   37804:	f001 fa2e 	bl	38c64 <z_impl_k_mutex_init>
	mqtt_mutex_init(client);

	client->protocol_version = MQTT_VERSION_3_1_1;
   37808:	2304      	movs	r3, #4
   3780a:	f884 307a 	strb.w	r3, [r4, #122]	; 0x7a
	client->clean_session = 1U;
   3780e:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
   37812:	f043 0302 	orr.w	r3, r3, #2
   37816:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
	client->keepalive = MQTT_KEEPALIVE;
   3781a:	233c      	movs	r3, #60	; 0x3c
   3781c:	f8a4 3078 	strh.w	r3, [r4, #120]	; 0x78
}
   37820:	bd10      	pop	{r4, pc}

00037822 <mqtt_connect>:
	return -ENOTSUP;
}
#endif

int mqtt_connect(struct mqtt_client *client)
{
   37822:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int err_code;

	NULL_PARAM_CHECK(client);
   37824:	4604      	mov	r4, r0
   37826:	2800      	cmp	r0, #0
   37828:	d03c      	beq.n	378a4 <mqtt_connect+0x82>
	NULL_PARAM_CHECK(client->client_id.utf8);
   3782a:	6c83      	ldr	r3, [r0, #72]	; 0x48
   3782c:	2b00      	cmp	r3, #0
   3782e:	d039      	beq.n	378a4 <mqtt_connect+0x82>

	mqtt_mutex_lock(client);
   37830:	f7e7 fa2e 	bl	1ec90 <mqtt_mutex_lock>

	if ((client->tx_buf == NULL) || (client->rx_buf == NULL)) {
   37834:	6f23      	ldr	r3, [r4, #112]	; 0x70
   37836:	b393      	cbz	r3, 3789e <mqtt_connect+0x7c>
   37838:	6ea3      	ldr	r3, [r4, #104]	; 0x68
   3783a:	b383      	cbz	r3, 3789e <mqtt_connect+0x7c>
	err_code = mqtt_transport_connect(client);
   3783c:	4620      	mov	r0, r4
   3783e:	f7e7 f9bf 	bl	1ebc0 <mqtt_transport_connect>
	if (err_code < 0) {
   37842:	1e05      	subs	r5, r0, #0
   37844:	db25      	blt.n	37892 <mqtt_connect+0x70>
	tx_buf_init(client, &packet);
   37846:	4669      	mov	r1, sp
   37848:	4620      	mov	r0, r4
   3784a:	f7ff ff82 	bl	37752 <tx_buf_init>
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   3784e:	69a3      	ldr	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   37850:	4669      	mov	r1, sp
	MQTT_SET_STATE(client, MQTT_STATE_TCP_CONNECTED);
   37852:	f043 0302 	orr.w	r3, r3, #2
   37856:	61a3      	str	r3, [r4, #24]
	err_code = connect_request_encode(client, &packet);
   37858:	4620      	mov	r0, r4
   3785a:	f7e7 f90d 	bl	1ea78 <connect_request_encode>
	if (err_code < 0) {
   3785e:	1e05      	subs	r5, r0, #0
   37860:	db13      	blt.n	3788a <mqtt_connect+0x68>
	err_code = mqtt_transport_write(client, packet.cur,
   37862:	e9dd 1200 	ldrd	r1, r2, [sp]
   37866:	4620      	mov	r0, r4
   37868:	1a52      	subs	r2, r2, r1
   3786a:	f7e7 f9b3 	bl	1ebd4 <mqtt_transport_write>
	if (err_code < 0) {
   3786e:	1e05      	subs	r5, r0, #0
   37870:	db0b      	blt.n	3788a <mqtt_connect+0x68>
   37872:	f7ff ff60 	bl	37736 <k_uptime_get>
	client->unacked_ping = 0;
   37876:	2500      	movs	r5, #0
   37878:	6160      	str	r0, [r4, #20]
   3787a:	f884 507b 	strb.w	r5, [r4, #123]	; 0x7b
error:
	if (err_code < 0) {
		client_reset(client);
	}

	mqtt_mutex_unlock(client);
   3787e:	4620      	mov	r0, r4
   37880:	f7e7 f9da 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37884:	4628      	mov	r0, r5
   37886:	b003      	add	sp, #12
   37888:	bd30      	pop	{r4, r5, pc}
	client_disconnect(client, err_code);
   3788a:	4629      	mov	r1, r5
   3788c:	4620      	mov	r0, r4
   3788e:	f7ff ff7f 	bl	37790 <client_disconnect>
	MQTT_STATE_INIT(client);
   37892:	2300      	movs	r3, #0
	client->internal.last_activity = 0U;
   37894:	e9c4 3305 	strd	r3, r3, [r4, #20]
	client->internal.remaining_payload = 0U;
   37898:	e9c4 3307 	strd	r3, r3, [r4, #28]
   3789c:	e7ef      	b.n	3787e <mqtt_connect+0x5c>
		err_code = -ENOMEM;
   3789e:	f06f 050b 	mvn.w	r5, #11
   378a2:	e7f6      	b.n	37892 <mqtt_connect+0x70>
	NULL_PARAM_CHECK(client);
   378a4:	f06f 0515 	mvn.w	r5, #21
   378a8:	e7ec      	b.n	37884 <mqtt_connect+0x62>

000378aa <mqtt_publish>:
	return 0;
}

int mqtt_publish(struct mqtt_client *client,
		 const struct mqtt_publish_param *param)
{
   378aa:	b570      	push	{r4, r5, r6, lr}
   378ac:	460e      	mov	r6, r1
   378ae:	b08e      	sub	sp, #56	; 0x38
	int err_code;
	struct buf_ctx packet;
	struct iovec io_vector[2];
	struct msghdr msg;

	NULL_PARAM_CHECK(client);
   378b0:	4605      	mov	r5, r0
   378b2:	2800      	cmp	r0, #0
   378b4:	d03b      	beq.n	3792e <mqtt_publish+0x84>
	NULL_PARAM_CHECK(param);
   378b6:	2900      	cmp	r1, #0
   378b8:	d039      	beq.n	3792e <mqtt_publish+0x84>
	MQTT_TRC("[CID %p]:[State 0x%02x]: >> Topic size 0x%08x, "
		 "Data size 0x%08x", client, client->internal.state,
		 param->message.topic.topic.size,
		 param->message.payload.len);

	mqtt_mutex_lock(client);
   378ba:	f7e7 f9e9 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   378be:	a901      	add	r1, sp, #4
   378c0:	4628      	mov	r0, r5
   378c2:	f7ff ff46 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   378c6:	69ab      	ldr	r3, [r5, #24]
   378c8:	075b      	lsls	r3, r3, #29
   378ca:	d52d      	bpl.n	37928 <mqtt_publish+0x7e>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = publish_encode(param, &packet);
   378cc:	a901      	add	r1, sp, #4
   378ce:	4630      	mov	r0, r6
   378d0:	f7ff fd52 	bl	37378 <publish_encode>
	if (err_code < 0) {
   378d4:	1e04      	subs	r4, r0, #0
   378d6:	db1c      	blt.n	37912 <mqtt_publish+0x68>
		goto error;
	}

	io_vector[0].iov_base = packet.cur;
   378d8:	9a01      	ldr	r2, [sp, #4]
	io_vector[0].iov_len = packet.end - packet.cur;
   378da:	9b02      	ldr	r3, [sp, #8]
	io_vector[0].iov_base = packet.cur;
   378dc:	9203      	str	r2, [sp, #12]
	io_vector[0].iov_len = packet.end - packet.cur;
   378de:	1a9b      	subs	r3, r3, r2
	io_vector[1].iov_base = param->message.payload.data;
	io_vector[1].iov_len = param->message.payload.len;

	memset(&msg, 0, sizeof(msg));
   378e0:	221c      	movs	r2, #28
	io_vector[0].iov_len = packet.end - packet.cur;
   378e2:	9304      	str	r3, [sp, #16]
	io_vector[1].iov_base = param->message.payload.data;
   378e4:	68f3      	ldr	r3, [r6, #12]
	memset(&msg, 0, sizeof(msg));
   378e6:	2100      	movs	r1, #0
	io_vector[1].iov_base = param->message.payload.data;
   378e8:	9305      	str	r3, [sp, #20]
	io_vector[1].iov_len = param->message.payload.len;
   378ea:	6933      	ldr	r3, [r6, #16]
	memset(&msg, 0, sizeof(msg));
   378ec:	eb0d 0002 	add.w	r0, sp, r2
	io_vector[1].iov_len = param->message.payload.len;
   378f0:	9306      	str	r3, [sp, #24]
	memset(&msg, 0, sizeof(msg));
   378f2:	f001 fbab 	bl	3904c <memset>

	msg.msg_iov = io_vector;
   378f6:	ab03      	add	r3, sp, #12
   378f8:	9309      	str	r3, [sp, #36]	; 0x24
	msg.msg_iovlen = ARRAY_SIZE(io_vector);
   378fa:	2302      	movs	r3, #2
	err_code = mqtt_transport_write_msg(client, message);
   378fc:	a907      	add	r1, sp, #28
   378fe:	4628      	mov	r0, r5
	msg.msg_iovlen = ARRAY_SIZE(io_vector);
   37900:	930a      	str	r3, [sp, #40]	; 0x28
	err_code = mqtt_transport_write_msg(client, message);
   37902:	f7e7 f973 	bl	1ebec <mqtt_transport_write_msg>
	if (err_code < 0) {
   37906:	1e04      	subs	r4, r0, #0
   37908:	da09      	bge.n	3791e <mqtt_publish+0x74>
		client_disconnect(client, err_code);
   3790a:	4621      	mov	r1, r4
   3790c:	4628      	mov	r0, r5
   3790e:	f7ff ff3f 	bl	37790 <client_disconnect>

error:
	MQTT_TRC("[CID %p]:[State 0x%02x]: << result 0x%08x",
			 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);
   37912:	4628      	mov	r0, r5
   37914:	f7e7 f990 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37918:	4620      	mov	r0, r4
   3791a:	b00e      	add	sp, #56	; 0x38
   3791c:	bd70      	pop	{r4, r5, r6, pc}
   3791e:	f7ff ff0a 	bl	37736 <k_uptime_get>
	return 0;
   37922:	2400      	movs	r4, #0
   37924:	6168      	str	r0, [r5, #20]
   37926:	e7f4      	b.n	37912 <mqtt_publish+0x68>
		return -ENOTCONN;
   37928:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   3792c:	e7f1      	b.n	37912 <mqtt_publish+0x68>
	NULL_PARAM_CHECK(client);
   3792e:	f06f 0415 	mvn.w	r4, #21
   37932:	e7f1      	b.n	37918 <mqtt_publish+0x6e>

00037934 <mqtt_publish_qos1_ack>:

int mqtt_publish_qos1_ack(struct mqtt_client *client,
			  const struct mqtt_puback_param *param)
{
   37934:	b537      	push	{r0, r1, r2, r4, r5, lr}
   37936:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   37938:	4605      	mov	r5, r0
   3793a:	b1f8      	cbz	r0, 3797c <mqtt_publish_qos1_ack+0x48>
	NULL_PARAM_CHECK(param);
   3793c:	b1f1      	cbz	r1, 3797c <mqtt_publish_qos1_ack+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> Message id 0x%04x",
		 client, client->internal.state, param->message_id);

	mqtt_mutex_lock(client);
   3793e:	f7e7 f9a7 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   37942:	4669      	mov	r1, sp
   37944:	4628      	mov	r0, r5
   37946:	f7ff ff04 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   3794a:	69ab      	ldr	r3, [r5, #24]
   3794c:	075b      	lsls	r3, r3, #29
   3794e:	d512      	bpl.n	37976 <mqtt_publish_qos1_ack+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = publish_ack_encode(param, &packet);
   37950:	4620      	mov	r0, r4
   37952:	4669      	mov	r1, sp
   37954:	f7ff fd4c 	bl	373f0 <publish_ack_encode>
	if (err_code < 0) {
   37958:	1e04      	subs	r4, r0, #0
   3795a:	db06      	blt.n	3796a <mqtt_publish_qos1_ack+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   3795c:	e9dd 1200 	ldrd	r1, r2, [sp]
   37960:	4628      	mov	r0, r5
   37962:	1a52      	subs	r2, r2, r1
   37964:	f7ff ff33 	bl	377ce <client_write>
   37968:	4604      	mov	r4, r0

error:
	MQTT_TRC("[CID %p]:[State 0x%02x]: << result 0x%08x",
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);
   3796a:	4628      	mov	r0, r5
   3796c:	f7e7 f964 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37970:	4620      	mov	r0, r4
   37972:	b003      	add	sp, #12
   37974:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   37976:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   3797a:	e7f6      	b.n	3796a <mqtt_publish_qos1_ack+0x36>
	NULL_PARAM_CHECK(client);
   3797c:	f06f 0415 	mvn.w	r4, #21
   37980:	e7f6      	b.n	37970 <mqtt_publish_qos1_ack+0x3c>

00037982 <mqtt_publish_qos2_release>:
	return err_code;
}

int mqtt_publish_qos2_release(struct mqtt_client *client,
			      const struct mqtt_pubrel_param *param)
{
   37982:	b537      	push	{r0, r1, r2, r4, r5, lr}
   37984:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   37986:	4605      	mov	r5, r0
   37988:	b1f8      	cbz	r0, 379ca <mqtt_publish_qos2_release+0x48>
	NULL_PARAM_CHECK(param);
   3798a:	b1f1      	cbz	r1, 379ca <mqtt_publish_qos2_release+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> Message id 0x%04x",
		 client, client->internal.state, param->message_id);

	mqtt_mutex_lock(client);
   3798c:	f7e7 f980 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   37990:	4669      	mov	r1, sp
   37992:	4628      	mov	r0, r5
   37994:	f7ff fedd 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   37998:	69ab      	ldr	r3, [r5, #24]
   3799a:	075b      	lsls	r3, r3, #29
   3799c:	d512      	bpl.n	379c4 <mqtt_publish_qos2_release+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = publish_release_encode(param, &packet);
   3799e:	4620      	mov	r0, r4
   379a0:	4669      	mov	r1, sp
   379a2:	f7ff fd2a 	bl	373fa <publish_release_encode>
	if (err_code < 0) {
   379a6:	1e04      	subs	r4, r0, #0
   379a8:	db06      	blt.n	379b8 <mqtt_publish_qos2_release+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   379aa:	e9dd 1200 	ldrd	r1, r2, [sp]
   379ae:	4628      	mov	r0, r5
   379b0:	1a52      	subs	r2, r2, r1
   379b2:	f7ff ff0c 	bl	377ce <client_write>
   379b6:	4604      	mov	r4, r0

error:
	MQTT_TRC("[CID %p]:[State 0x%02x]: << result 0x%08x",
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);
   379b8:	4628      	mov	r0, r5
   379ba:	f7e7 f93d 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   379be:	4620      	mov	r0, r4
   379c0:	b003      	add	sp, #12
   379c2:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   379c4:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   379c8:	e7f6      	b.n	379b8 <mqtt_publish_qos2_release+0x36>
	NULL_PARAM_CHECK(client);
   379ca:	f06f 0415 	mvn.w	r4, #21
   379ce:	e7f6      	b.n	379be <mqtt_publish_qos2_release+0x3c>

000379d0 <mqtt_disconnect>:

	return err_code;
}

int mqtt_disconnect(struct mqtt_client *client)
{
   379d0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   379d2:	4604      	mov	r4, r0
   379d4:	b310      	cbz	r0, 37a1c <mqtt_disconnect+0x4c>

	mqtt_mutex_lock(client);
   379d6:	f7e7 f95b 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   379da:	4669      	mov	r1, sp
   379dc:	4620      	mov	r0, r4
   379de:	f7ff feb8 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   379e2:	69a3      	ldr	r3, [r4, #24]
   379e4:	075b      	lsls	r3, r3, #29
   379e6:	d516      	bpl.n	37a16 <mqtt_disconnect+0x46>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = disconnect_encode(&packet);
   379e8:	4668      	mov	r0, sp
   379ea:	f7e7 f8c5 	bl	1eb78 <disconnect_encode>
	if (err_code < 0) {
   379ee:	1e05      	subs	r5, r0, #0
   379f0:	db0b      	blt.n	37a0a <mqtt_disconnect+0x3a>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   379f2:	e9dd 1200 	ldrd	r1, r2, [sp]
   379f6:	4620      	mov	r0, r4
   379f8:	1a52      	subs	r2, r2, r1
   379fa:	f7ff fee8 	bl	377ce <client_write>
	if (err_code < 0) {
   379fe:	1e05      	subs	r5, r0, #0
   37a00:	db03      	blt.n	37a0a <mqtt_disconnect+0x3a>
		goto error;
	}

	client_disconnect(client, 0);
   37a02:	2100      	movs	r1, #0
   37a04:	4620      	mov	r0, r4
   37a06:	f7ff fec3 	bl	37790 <client_disconnect>

error:
	mqtt_mutex_unlock(client);
   37a0a:	4620      	mov	r0, r4
   37a0c:	f7e7 f914 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37a10:	4628      	mov	r0, r5
   37a12:	b003      	add	sp, #12
   37a14:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   37a16:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   37a1a:	e7f6      	b.n	37a0a <mqtt_disconnect+0x3a>
	NULL_PARAM_CHECK(client);
   37a1c:	f06f 0515 	mvn.w	r5, #21
   37a20:	e7f6      	b.n	37a10 <mqtt_disconnect+0x40>

00037a22 <mqtt_subscribe>:

int mqtt_subscribe(struct mqtt_client *client,
		   const struct mqtt_subscription_list *param)
{
   37a22:	b537      	push	{r0, r1, r2, r4, r5, lr}
   37a24:	460c      	mov	r4, r1
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   37a26:	4605      	mov	r5, r0
   37a28:	b1f8      	cbz	r0, 37a6a <mqtt_subscribe+0x48>
	NULL_PARAM_CHECK(param);
   37a2a:	b1f1      	cbz	r1, 37a6a <mqtt_subscribe+0x48>

	MQTT_TRC("[CID %p]:[State 0x%02x]: >> message id 0x%04x "
		 "topic count 0x%04x", client, client->internal.state,
		 param->message_id, param->list_count);

	mqtt_mutex_lock(client);
   37a2c:	f7e7 f930 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   37a30:	4669      	mov	r1, sp
   37a32:	4628      	mov	r0, r5
   37a34:	f7ff fe8d 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   37a38:	69ab      	ldr	r3, [r5, #24]
   37a3a:	075b      	lsls	r3, r3, #29
   37a3c:	d512      	bpl.n	37a64 <mqtt_subscribe+0x42>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = subscribe_encode(param, &packet);
   37a3e:	4620      	mov	r0, r4
   37a40:	4669      	mov	r1, sp
   37a42:	f7ff fcdf 	bl	37404 <subscribe_encode>
	if (err_code < 0) {
   37a46:	1e04      	subs	r4, r0, #0
   37a48:	db06      	blt.n	37a58 <mqtt_subscribe+0x36>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   37a4a:	e9dd 1200 	ldrd	r1, r2, [sp]
   37a4e:	4628      	mov	r0, r5
   37a50:	1a52      	subs	r2, r2, r1
   37a52:	f7ff febc 	bl	377ce <client_write>
   37a56:	4604      	mov	r4, r0

error:
	MQTT_TRC("[CID %p]:[State 0x%02x]: << result 0x%08x",
		 client, client->internal.state, err_code);

	mqtt_mutex_unlock(client);
   37a58:	4628      	mov	r0, r5
   37a5a:	f7e7 f8ed 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37a5e:	4620      	mov	r0, r4
   37a60:	b003      	add	sp, #12
   37a62:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   37a64:	f06f 047f 	mvn.w	r4, #127	; 0x7f
   37a68:	e7f6      	b.n	37a58 <mqtt_subscribe+0x36>
	NULL_PARAM_CHECK(client);
   37a6a:	f06f 0415 	mvn.w	r4, #21
   37a6e:	e7f6      	b.n	37a5e <mqtt_subscribe+0x3c>

00037a70 <mqtt_ping>:

	return err_code;
}

int mqtt_ping(struct mqtt_client *client)
{
   37a70:	b537      	push	{r0, r1, r2, r4, r5, lr}
	int err_code;
	struct buf_ctx packet;

	NULL_PARAM_CHECK(client);
   37a72:	4604      	mov	r4, r0
   37a74:	b320      	cbz	r0, 37ac0 <mqtt_ping+0x50>

	mqtt_mutex_lock(client);
   37a76:	f7e7 f90b 	bl	1ec90 <mqtt_mutex_lock>

	tx_buf_init(client, &packet);
   37a7a:	4669      	mov	r1, sp
   37a7c:	4620      	mov	r0, r4
   37a7e:	f7ff fe68 	bl	37752 <tx_buf_init>
	if (!MQTT_HAS_STATE(client, MQTT_STATE_CONNECTED)) {
   37a82:	69a3      	ldr	r3, [r4, #24]
   37a84:	075b      	lsls	r3, r3, #29
   37a86:	d518      	bpl.n	37aba <mqtt_ping+0x4a>
	err_code = verify_tx_state(client);
	if (err_code < 0) {
		goto error;
	}

	err_code = ping_request_encode(&packet);
   37a88:	4668      	mov	r0, sp
   37a8a:	f7e7 f887 	bl	1eb9c <ping_request_encode>
	if (err_code < 0) {
   37a8e:	1e05      	subs	r5, r0, #0
   37a90:	db0d      	blt.n	37aae <mqtt_ping+0x3e>
		goto error;
	}

	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   37a92:	e9dd 1200 	ldrd	r1, r2, [sp]
   37a96:	4620      	mov	r0, r4
   37a98:	1a52      	subs	r2, r2, r1
   37a9a:	f7ff fe98 	bl	377ce <client_write>

	if (client->unacked_ping >= INT8_MAX) {
   37a9e:	f994 307b 	ldrsb.w	r3, [r4, #123]	; 0x7b
	err_code = client_write(client, packet.cur, packet.end - packet.cur);
   37aa2:	4605      	mov	r5, r0
	if (client->unacked_ping >= INT8_MAX) {
   37aa4:	2b7f      	cmp	r3, #127	; 0x7f
   37aa6:	d002      	beq.n	37aae <mqtt_ping+0x3e>
		MQTT_TRC("PING count overflow!");
	} else {
		client->unacked_ping++;
   37aa8:	3301      	adds	r3, #1
   37aaa:	f884 307b 	strb.w	r3, [r4, #123]	; 0x7b
	}

error:
	mqtt_mutex_unlock(client);
   37aae:	4620      	mov	r0, r4
   37ab0:	f7e7 f8c2 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37ab4:	4628      	mov	r0, r5
   37ab6:	b003      	add	sp, #12
   37ab8:	bd30      	pop	{r4, r5, pc}
		return -ENOTCONN;
   37aba:	f06f 057f 	mvn.w	r5, #127	; 0x7f
   37abe:	e7f6      	b.n	37aae <mqtt_ping+0x3e>
	NULL_PARAM_CHECK(client);
   37ac0:	f06f 0515 	mvn.w	r5, #21
   37ac4:	e7f6      	b.n	37ab4 <mqtt_ping+0x44>

00037ac6 <mqtt_live>:

	return 0;
}

int mqtt_live(struct mqtt_client *client)
{
   37ac6:	b570      	push	{r4, r5, r6, lr}
	int err_code = 0;
	u32_t elapsed_time;
	bool ping_sent = false;

	NULL_PARAM_CHECK(client);
   37ac8:	4606      	mov	r6, r0
   37aca:	b300      	cbz	r0, 37b0e <mqtt_live+0x48>

	mqtt_mutex_lock(client);
   37acc:	f7e7 f8e0 	bl	1ec90 <mqtt_mutex_lock>

	elapsed_time = mqtt_elapsed_time_in_ms_get(
   37ad0:	6974      	ldr	r4, [r6, #20]
   37ad2:	f7ff fe30 	bl	37736 <k_uptime_get>
 *
 * @retval Time elapsed since last_activity time.
 */
static inline u32_t mqtt_elapsed_time_in_ms_get(u32_t last_activity)
{
	s32_t diff = k_uptime_get_32() - last_activity;
   37ad6:	1b00      	subs	r0, r0, r4
				client->internal.last_activity);
	if ((client->keepalive > 0) &&
   37ad8:	f8b6 4078 	ldrh.w	r4, [r6, #120]	; 0x78

	if (diff < 0) {
		return 0;
   37adc:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   37ae0:	b19c      	cbz	r4, 37b0a <mqtt_live+0x44>
	    (elapsed_time >= (client->keepalive * 1000))) {
   37ae2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   37ae6:	435c      	muls	r4, r3
	if ((client->keepalive > 0) &&
   37ae8:	4284      	cmp	r4, r0
   37aea:	d80d      	bhi.n	37b08 <mqtt_live+0x42>
		err_code = mqtt_ping(client);
   37aec:	4630      	mov	r0, r6
   37aee:	f7ff ffbf 	bl	37a70 <mqtt_ping>
		ping_sent = true;
   37af2:	2401      	movs	r4, #1
		err_code = mqtt_ping(client);
   37af4:	4605      	mov	r5, r0
	}

	mqtt_mutex_unlock(client);
   37af6:	4630      	mov	r0, r6
   37af8:	f7e7 f89e 	bl	1ec38 <mqtt_mutex_unlock>

	if (ping_sent) {
		return err_code;
	} else {
		return -EAGAIN;
   37afc:	2c00      	cmp	r4, #0
   37afe:	bf08      	it	eq
   37b00:	f06f 050a 	mvneq.w	r5, #10
	}
}
   37b04:	4628      	mov	r0, r5
   37b06:	bd70      	pop	{r4, r5, r6, pc}
	bool ping_sent = false;
   37b08:	2400      	movs	r4, #0
	int err_code = 0;
   37b0a:	4625      	mov	r5, r4
   37b0c:	e7f3      	b.n	37af6 <mqtt_live+0x30>
	NULL_PARAM_CHECK(client);
   37b0e:	f06f 0515 	mvn.w	r5, #21
   37b12:	e7f7      	b.n	37b04 <mqtt_live+0x3e>

00037b14 <mqtt_input>:

	return keepalive_ms - elapsed_time;
}

int mqtt_input(struct mqtt_client *client)
{
   37b14:	b538      	push	{r3, r4, r5, lr}
	int err_code = 0;

	NULL_PARAM_CHECK(client);
   37b16:	4605      	mov	r5, r0
   37b18:	b1d0      	cbz	r0, 37b50 <mqtt_input+0x3c>

	mqtt_mutex_lock(client);
   37b1a:	f7e7 f8b9 	bl	1ec90 <mqtt_mutex_lock>

	MQTT_TRC("state:0x%08x", client->internal.state);

	if (MQTT_HAS_STATE(client, MQTT_STATE_TCP_CONNECTED)) {
   37b1e:	69ab      	ldr	r3, [r5, #24]
   37b20:	079b      	lsls	r3, r3, #30
   37b22:	d50f      	bpl.n	37b44 <mqtt_input+0x30>
	if (client->internal.remaining_payload > 0) {
   37b24:	6a2b      	ldr	r3, [r5, #32]
   37b26:	b983      	cbnz	r3, 37b4a <mqtt_input+0x36>
	err_code = mqtt_handle_rx(client);
   37b28:	4628      	mov	r0, r5
   37b2a:	f7ff fccd 	bl	374c8 <mqtt_handle_rx>
	if (err_code < 0) {
   37b2e:	1e04      	subs	r4, r0, #0
   37b30:	da03      	bge.n	37b3a <mqtt_input+0x26>
		client_disconnect(client, err_code);
   37b32:	4621      	mov	r1, r4
   37b34:	4628      	mov	r0, r5
   37b36:	f7ff fe2b 	bl	37790 <client_disconnect>
		err_code = client_read(client);
	} else {
		err_code = -EACCES;
	}

	mqtt_mutex_unlock(client);
   37b3a:	4628      	mov	r0, r5
   37b3c:	f7e7 f87c 	bl	1ec38 <mqtt_mutex_unlock>

	return err_code;
}
   37b40:	4620      	mov	r0, r4
   37b42:	bd38      	pop	{r3, r4, r5, pc}
		err_code = -EACCES;
   37b44:	f06f 040c 	mvn.w	r4, #12
   37b48:	e7f7      	b.n	37b3a <mqtt_input+0x26>
		return -EBUSY;
   37b4a:	f06f 040f 	mvn.w	r4, #15
   37b4e:	e7f4      	b.n	37b3a <mqtt_input+0x26>
	NULL_PARAM_CHECK(client);
   37b50:	f06f 0415 	mvn.w	r4, #21
   37b54:	e7f4      	b.n	37b40 <mqtt_input+0x2c>

00037b56 <mqtt_client_tls_connect>:
#include <net/mqtt.h>

#include "mqtt_os.h"

int mqtt_client_tls_connect(struct mqtt_client *client)
{
   37b56:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	const struct sockaddr *broker = client->broker;
   37b58:	6d06      	ldr	r6, [r0, #80]	; 0x50
{
   37b5a:	4604      	mov	r4, r0
	struct mqtt_sec_config *tls_config = &client->transport.tls.config;
	int ret;

	client->transport.tls.sock = socket(broker->sa_family,
   37b5c:	8830      	ldrh	r0, [r6, #0]
	return z_impl_zsock_socket(family, type, proto);
   37b5e:	f44f 7281 	mov.w	r2, #258	; 0x102
   37b62:	2101      	movs	r1, #1
   37b64:	f7e1 fc4e 	bl	19404 <z_impl_zsock_socket>
					    SOCK_STREAM, IPPROTO_TLS_1_2);
	if (client->transport.tls.sock < 0) {
   37b68:	2800      	cmp	r0, #0
	client->transport.tls.sock = socket(broker->sa_family,
   37b6a:	62a0      	str	r0, [r4, #40]	; 0x28
	if (client->transport.tls.sock < 0) {
   37b6c:	da05      	bge.n	37b7a <mqtt_client_tls_connect+0x24>
	MQTT_TRC("Connect completed");
	return 0;

error:
	(void)close(client->transport.tls.sock);
	return -errno;
   37b6e:	f7fd fcbb 	bl	354e8 <__errno>
   37b72:	6800      	ldr	r0, [r0, #0]
   37b74:	4240      	negs	r0, r0
}
   37b76:	b003      	add	sp, #12
   37b78:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke5(*(uintptr_t *)&sock, *(uintptr_t *)&level, *(uintptr_t *)&optname, *(uintptr_t *)&optval, *(uintptr_t *)&optlen, K_SYSCALL_ZSOCK_SETSOCKOPT);
	}
#endif
	compiler_barrier();
	return z_impl_zsock_setsockopt(sock, level, optname, optval, optlen);
   37b7a:	2304      	movs	r3, #4
   37b7c:	2205      	movs	r2, #5
   37b7e:	9300      	str	r3, [sp, #0]
   37b80:	f44f 718d 	mov.w	r1, #282	; 0x11a
   37b84:	f104 032c 	add.w	r3, r4, #44	; 0x2c
   37b88:	f7fc fa05 	bl	33f96 <z_impl_zsock_setsockopt>
	if (ret < 0) {
   37b8c:	2800      	cmp	r0, #0
   37b8e:	da03      	bge.n	37b98 <mqtt_client_tls_connect+0x42>
	(void)close(client->transport.tls.sock);
   37b90:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return z_impl_zsock_close(sock);
   37b92:	f7fc f943 	bl	33e1c <z_impl_zsock_close>
   37b96:	e7ea      	b.n	37b6e <mqtt_client_tls_connect+0x18>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   37b98:	6b63      	ldr	r3, [r4, #52]	; 0x34
   37b9a:	bb03      	cbnz	r3, 37bde <mqtt_client_tls_connect+0x88>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   37b9c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   37b9e:	bb63      	cbnz	r3, 37bfa <mqtt_client_tls_connect+0xa4>
	if (tls_config->hostname) {
   37ba0:	6c25      	ldr	r5, [r4, #64]	; 0x40
   37ba2:	2d00      	cmp	r5, #0
   37ba4:	d137      	bne.n	37c16 <mqtt_client_tls_connect+0xc0>
	if (tls_config->session_cache == TLS_SESSION_CACHE_ENABLED) {
   37ba6:	6c63      	ldr	r3, [r4, #68]	; 0x44
   37ba8:	2b01      	cmp	r3, #1
   37baa:	d10b      	bne.n	37bc4 <mqtt_client_tls_connect+0x6e>
   37bac:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	return z_impl_zsock_setsockopt(sock, level, optname, optval, optlen);
   37bae:	2304      	movs	r3, #4
   37bb0:	2207      	movs	r2, #7
   37bb2:	9300      	str	r3, [sp, #0]
   37bb4:	f44f 718d 	mov.w	r1, #282	; 0x11a
   37bb8:	f104 0344 	add.w	r3, r4, #68	; 0x44
   37bbc:	f7fc f9eb 	bl	33f96 <z_impl_zsock_setsockopt>
		if (ret < 0) {
   37bc0:	2800      	cmp	r0, #0
   37bc2:	dbe5      	blt.n	37b90 <mqtt_client_tls_connect+0x3a>
	if (broker->sa_family == AF_INET) {
   37bc4:	8833      	ldrh	r3, [r6, #0]
	ret = connect(client->transport.tls.sock, client->broker,
   37bc6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
	size_t peer_addr_size = sizeof(struct sockaddr_in6);
   37bc8:	2b01      	cmp	r3, #1
   37bca:	bf0c      	ite	eq
   37bcc:	2208      	moveq	r2, #8
   37bce:	2218      	movne	r2, #24
	ret = connect(client->transport.tls.sock, client->broker,
   37bd0:	6d21      	ldr	r1, [r4, #80]	; 0x50
	return z_impl_zsock_connect(sock, addr, addrlen);
   37bd2:	f7fc f93c 	bl	33e4e <z_impl_zsock_connect>
	if (ret < 0) {
   37bd6:	2800      	cmp	r0, #0
   37bd8:	dbda      	blt.n	37b90 <mqtt_client_tls_connect+0x3a>
	return 0;
   37bda:	2000      	movs	r0, #0
   37bdc:	e7cb      	b.n	37b76 <mqtt_client_tls_connect+0x20>
	if (tls_config->cipher_list != NULL && tls_config->cipher_count > 0) {
   37bde:	6b22      	ldr	r2, [r4, #48]	; 0x30
   37be0:	2a00      	cmp	r2, #0
   37be2:	d0db      	beq.n	37b9c <mqtt_client_tls_connect+0x46>
   37be4:	6aa0      	ldr	r0, [r4, #40]	; 0x28
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   37be6:	0092      	lsls	r2, r2, #2
	return z_impl_zsock_setsockopt(sock, level, optname, optval, optlen);
   37be8:	9200      	str	r2, [sp, #0]
   37bea:	f44f 718d 	mov.w	r1, #282	; 0x11a
   37bee:	2203      	movs	r2, #3
   37bf0:	f7fc f9d1 	bl	33f96 <z_impl_zsock_setsockopt>
		if (ret < 0) {
   37bf4:	2800      	cmp	r0, #0
   37bf6:	dad1      	bge.n	37b9c <mqtt_client_tls_connect+0x46>
   37bf8:	e7ca      	b.n	37b90 <mqtt_client_tls_connect+0x3a>
	if (tls_config->sec_tag_list != NULL && tls_config->sec_tag_count > 0) {
   37bfa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   37bfc:	2a00      	cmp	r2, #0
   37bfe:	d0cf      	beq.n	37ba0 <mqtt_client_tls_connect+0x4a>
   37c00:	6aa0      	ldr	r0, [r4, #40]	; 0x28
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   37c02:	0092      	lsls	r2, r2, #2
   37c04:	9200      	str	r2, [sp, #0]
   37c06:	f44f 718d 	mov.w	r1, #282	; 0x11a
   37c0a:	2201      	movs	r2, #1
   37c0c:	f7fc f9c3 	bl	33f96 <z_impl_zsock_setsockopt>
		if (ret < 0) {
   37c10:	2800      	cmp	r0, #0
   37c12:	dac5      	bge.n	37ba0 <mqtt_client_tls_connect+0x4a>
   37c14:	e7bc      	b.n	37b90 <mqtt_client_tls_connect+0x3a>
		ret = setsockopt(client->transport.tls.sock, SOL_TLS,
   37c16:	4628      	mov	r0, r5
   37c18:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   37c1a:	f7da fa31 	bl	12080 <strlen>
   37c1e:	2202      	movs	r2, #2
   37c20:	9000      	str	r0, [sp, #0]
   37c22:	462b      	mov	r3, r5
   37c24:	f44f 718d 	mov.w	r1, #282	; 0x11a
   37c28:	4638      	mov	r0, r7
   37c2a:	f7fc f9b4 	bl	33f96 <z_impl_zsock_setsockopt>
		if (ret < 0) {
   37c2e:	2800      	cmp	r0, #0
   37c30:	dab9      	bge.n	37ba6 <mqtt_client_tls_connect+0x50>
   37c32:	e7ad      	b.n	37b90 <mqtt_client_tls_connect+0x3a>

00037c34 <mqtt_client_tls_write>:

int mqtt_client_tls_write(struct mqtt_client *client, const u8_t *data,
			  u32_t datalen)
{
   37c34:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	u32_t offset = 0U;
   37c38:	2400      	movs	r4, #0
{
   37c3a:	4607      	mov	r7, r0
   37c3c:	4688      	mov	r8, r1
   37c3e:	4615      	mov	r5, r2
	return z_impl_zsock_sendto(sock, buf, len, flags, dest_addr, addrlen);
   37c40:	4626      	mov	r6, r4
	int ret;

	while (offset < datalen) {
   37c42:	42ac      	cmp	r4, r5
   37c44:	d301      	bcc.n	37c4a <mqtt_client_tls_write+0x16>
		}

		offset += ret;
	}

	return 0;
   37c46:	2000      	movs	r0, #0
   37c48:	e00e      	b.n	37c68 <mqtt_client_tls_write+0x34>
		ret = send(client->transport.tls.sock, data + offset,
   37c4a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   37c4c:	2300      	movs	r3, #0
   37c4e:	e9cd 6600 	strd	r6, r6, [sp]
   37c52:	1b2a      	subs	r2, r5, r4
   37c54:	eb08 0104 	add.w	r1, r8, r4
   37c58:	f7fc f91a 	bl	33e90 <z_impl_zsock_sendto>
		if (ret < 0) {
   37c5c:	2800      	cmp	r0, #0
   37c5e:	da06      	bge.n	37c6e <mqtt_client_tls_write+0x3a>
			return -errno;
   37c60:	f7fd fc42 	bl	354e8 <__errno>
   37c64:	6800      	ldr	r0, [r0, #0]
   37c66:	4240      	negs	r0, r0
}
   37c68:	b002      	add	sp, #8
   37c6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		offset += ret;
   37c6e:	4404      	add	r4, r0
   37c70:	e7e7      	b.n	37c42 <mqtt_client_tls_write+0xe>

00037c72 <mqtt_client_tls_write_msg>:

int mqtt_client_tls_write_msg(struct mqtt_client *client,
			      const struct msghdr *message)
{
   37c72:	b508      	push	{r3, lr}
	int ret;

	ret = sendmsg(client->transport.tls.sock, message, 0);
   37c74:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_sendmsg(sock, msg, flags);
   37c76:	2200      	movs	r2, #0
   37c78:	f7fc f93f 	bl	33efa <z_impl_zsock_sendmsg>
	if (ret < 0) {
   37c7c:	2800      	cmp	r0, #0
   37c7e:	da04      	bge.n	37c8a <mqtt_client_tls_write_msg+0x18>
		return -errno;
   37c80:	f7fd fc32 	bl	354e8 <__errno>
   37c84:	6800      	ldr	r0, [r0, #0]
   37c86:	4240      	negs	r0, r0
	}

	return 0;
}
   37c88:	bd08      	pop	{r3, pc}
	return 0;
   37c8a:	2000      	movs	r0, #0
   37c8c:	e7fc      	b.n	37c88 <mqtt_client_tls_write_msg+0x16>

00037c8e <mqtt_client_tls_read>:

int mqtt_client_tls_read(struct mqtt_client *client, u8_t *data, u32_t buflen,
			 bool shall_block)
{
   37c8e:	b513      	push	{r0, r1, r4, lr}
   37c90:	2400      	movs	r4, #0
	int flags = 0;
	int ret;

	if (!shall_block) {
   37c92:	2b00      	cmp	r3, #0
		flags |= MSG_DONTWAIT;
   37c94:	bf14      	ite	ne
   37c96:	4623      	movne	r3, r4
   37c98:	2340      	moveq	r3, #64	; 0x40
	}

	ret = recv(client->transport.tls.sock, data, buflen, flags);
   37c9a:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_recvfrom(sock, buf, max_len, flags, src_addr, addrlen);
   37c9c:	e9cd 4400 	strd	r4, r4, [sp]
   37ca0:	f7fc f948 	bl	33f34 <z_impl_zsock_recvfrom>
	if (ret < 0) {
   37ca4:	2800      	cmp	r0, #0
   37ca6:	da03      	bge.n	37cb0 <mqtt_client_tls_read+0x22>
		return -errno;
   37ca8:	f7fd fc1e 	bl	354e8 <__errno>
   37cac:	6800      	ldr	r0, [r0, #0]
   37cae:	4240      	negs	r0, r0
	}

	return ret;
}
   37cb0:	b002      	add	sp, #8
   37cb2:	bd10      	pop	{r4, pc}

00037cb4 <mqtt_client_tls_disconnect>:

int mqtt_client_tls_disconnect(struct mqtt_client *client)
{
   37cb4:	b508      	push	{r3, lr}
	int ret;

	MQTT_TRC("Closing socket %d", client->transport.tls.sock);
	ret = close(client->transport.tls.sock);
   37cb6:	6a80      	ldr	r0, [r0, #40]	; 0x28
	return z_impl_zsock_close(sock);
   37cb8:	f7fc f8b0 	bl	33e1c <z_impl_zsock_close>
	if (ret < 0) {
   37cbc:	2800      	cmp	r0, #0
   37cbe:	da04      	bge.n	37cca <mqtt_client_tls_disconnect+0x16>
		return -errno;
   37cc0:	f7fd fc12 	bl	354e8 <__errno>
   37cc4:	6800      	ldr	r0, [r0, #0]
   37cc6:	4240      	negs	r0, r0
	}

	return 0;
}
   37cc8:	bd08      	pop	{r3, pc}
	return 0;
   37cca:	2000      	movs	r0, #0
   37ccc:	e7fc      	b.n	37cc8 <mqtt_client_tls_disconnect+0x14>

00037cce <dns_init_resolver>:
	ret = dns_resolve_init(dns_resolve_get_default(), dns_servers, NULL);
	if (ret < 0) {
		NET_WARN("Cannot initialize DNS resolver (%d)", ret);
	}
#endif
}
   37cce:	4770      	bx	lr

00037cd0 <base64_char>:
	if (value < 26) {
   37cd0:	2819      	cmp	r0, #25
   37cd2:	dc01      	bgt.n	37cd8 <base64_char+0x8>
		return value + 'A';
   37cd4:	3041      	adds	r0, #65	; 0x41
   37cd6:	4770      	bx	lr
	} else if (value < 52) {
   37cd8:	2833      	cmp	r0, #51	; 0x33
   37cda:	dc01      	bgt.n	37ce0 <base64_char+0x10>
		return value + 'a' - 26;
   37cdc:	3047      	adds	r0, #71	; 0x47
   37cde:	4770      	bx	lr
	} else if (value < 62) {
   37ce0:	283d      	cmp	r0, #61	; 0x3d
   37ce2:	dc01      	bgt.n	37ce8 <base64_char+0x18>
		return value + '0' - 52;
   37ce4:	3804      	subs	r0, #4
   37ce6:	4770      	bx	lr
	} else if (value == 62) {
   37ce8:	283e      	cmp	r0, #62	; 0x3e
		return '_';
   37cea:	bf0c      	ite	eq
   37cec:	202d      	moveq	r0, #45	; 0x2d
   37cee:	205f      	movne	r0, #95	; 0x5f
}
   37cf0:	4770      	bx	lr

00037cf2 <base64_outch>:
	if (st->overflowed) {
   37cf2:	7b02      	ldrb	r2, [r0, #12]
{
   37cf4:	b510      	push	{r4, lr}
	if (st->overflowed) {
   37cf6:	b922      	cbnz	r2, 37d02 <base64_outch+0x10>
	if (st->len < 2) {
   37cf8:	6883      	ldr	r3, [r0, #8]
   37cfa:	2b01      	cmp	r3, #1
   37cfc:	d802      	bhi.n	37d04 <base64_outch+0x12>
		st->overflowed = true;
   37cfe:	2301      	movs	r3, #1
   37d00:	7303      	strb	r3, [r0, #12]
}
   37d02:	bd10      	pop	{r4, pc}
	*st->buf++ = ch;
   37d04:	6843      	ldr	r3, [r0, #4]
   37d06:	1c5c      	adds	r4, r3, #1
   37d08:	6044      	str	r4, [r0, #4]
   37d0a:	7019      	strb	r1, [r3, #0]
	st->len--;
   37d0c:	6883      	ldr	r3, [r0, #8]
   37d0e:	3b01      	subs	r3, #1
   37d10:	6083      	str	r3, [r0, #8]
	*st->buf = 0;
   37d12:	6843      	ldr	r3, [r0, #4]
   37d14:	701a      	strb	r2, [r3, #0]
   37d16:	e7f4      	b.n	37d02 <base64_outch+0x10>

00037d18 <base64_flush>:
	if (st->pending < 1) {
   37d18:	6903      	ldr	r3, [r0, #16]
{
   37d1a:	b510      	push	{r4, lr}
	if (st->pending < 1) {
   37d1c:	2b00      	cmp	r3, #0
{
   37d1e:	4604      	mov	r4, r0
	if (st->pending < 1) {
   37d20:	dd35      	ble.n	37d8e <base64_flush+0x76>
	base64_outch(st, base64_char(st->wip[0] >> 2));
   37d22:	7b40      	ldrb	r0, [r0, #13]
   37d24:	0880      	lsrs	r0, r0, #2
   37d26:	f7ff ffd3 	bl	37cd0 <base64_char>
   37d2a:	b2c1      	uxtb	r1, r0
   37d2c:	4620      	mov	r0, r4
   37d2e:	f7ff ffe0 	bl	37cf2 <base64_outch>
	base64_outch(st, base64_char(((st->wip[0] & 0x03) << 4) |
   37d32:	7b63      	ldrb	r3, [r4, #13]
				(st->wip[1] >> 4)));
   37d34:	7ba0      	ldrb	r0, [r4, #14]
	base64_outch(st, base64_char(((st->wip[0] & 0x03) << 4) |
   37d36:	011b      	lsls	r3, r3, #4
   37d38:	f003 0330 	and.w	r3, r3, #48	; 0x30
   37d3c:	ea43 1010 	orr.w	r0, r3, r0, lsr #4
   37d40:	f7ff ffc6 	bl	37cd0 <base64_char>
   37d44:	b2c1      	uxtb	r1, r0
   37d46:	4620      	mov	r0, r4
   37d48:	f7ff ffd3 	bl	37cf2 <base64_outch>
	if (st->pending >= 2) {
   37d4c:	6923      	ldr	r3, [r4, #16]
   37d4e:	2b01      	cmp	r3, #1
   37d50:	dd0c      	ble.n	37d6c <base64_flush+0x54>
		base64_outch(st, base64_char(((st->wip[1] & 0x0f) << 2) |
   37d52:	7ba3      	ldrb	r3, [r4, #14]
				(st->wip[2] >> 6)));
   37d54:	7be0      	ldrb	r0, [r4, #15]
		base64_outch(st, base64_char(((st->wip[1] & 0x0f) << 2) |
   37d56:	009b      	lsls	r3, r3, #2
   37d58:	f003 033c 	and.w	r3, r3, #60	; 0x3c
   37d5c:	ea43 1090 	orr.w	r0, r3, r0, lsr #6
   37d60:	f7ff ffb6 	bl	37cd0 <base64_char>
   37d64:	b2c1      	uxtb	r1, r0
   37d66:	4620      	mov	r0, r4
   37d68:	f7ff ffc3 	bl	37cf2 <base64_outch>
	if (st->pending >= 3) {
   37d6c:	6923      	ldr	r3, [r4, #16]
   37d6e:	2b02      	cmp	r3, #2
   37d70:	dd08      	ble.n	37d84 <base64_flush+0x6c>
		base64_outch(st, base64_char(st->wip[2] & 0x3f));
   37d72:	7be0      	ldrb	r0, [r4, #15]
   37d74:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   37d78:	f7ff ffaa 	bl	37cd0 <base64_char>
   37d7c:	b2c1      	uxtb	r1, r0
   37d7e:	4620      	mov	r0, r4
   37d80:	f7ff ffb7 	bl	37cf2 <base64_outch>
	st->pending = 0;
   37d84:	2300      	movs	r3, #0
   37d86:	6123      	str	r3, [r4, #16]
   37d88:	f8a4 300d 	strh.w	r3, [r4, #13]
   37d8c:	73e3      	strb	r3, [r4, #15]
}
   37d8e:	bd10      	pop	{r4, pc}

00037d90 <base64_append_bytes>:
{
   37d90:	b570      	push	{r4, r5, r6, lr}
   37d92:	4604      	mov	r4, r0
   37d94:	4615      	mov	r5, r2
	while (len-- > 0) {
   37d96:	1846      	adds	r6, r0, r1
   37d98:	42b4      	cmp	r4, r6
   37d9a:	d101      	bne.n	37da0 <base64_append_bytes+0x10>
}
   37d9c:	2000      	movs	r0, #0
   37d9e:	bd70      	pop	{r4, r5, r6, pc}
	st->wip[st->pending++] = byte;
   37da0:	692b      	ldr	r3, [r5, #16]
		base64_addbyte(st, *bytes++);
   37da2:	f814 1b01 	ldrb.w	r1, [r4], #1
	st->wip[st->pending++] = byte;
   37da6:	1c5a      	adds	r2, r3, #1
	if (st->pending == 3) {
   37da8:	2a03      	cmp	r2, #3
	st->wip[st->pending++] = byte;
   37daa:	442b      	add	r3, r5
   37dac:	612a      	str	r2, [r5, #16]
   37dae:	7359      	strb	r1, [r3, #13]
	if (st->pending == 3) {
   37db0:	d1f2      	bne.n	37d98 <base64_append_bytes+0x8>
		base64_flush(st);
   37db2:	4628      	mov	r0, r5
   37db4:	f7ff ffb0 	bl	37d18 <base64_flush>
   37db8:	e7ee      	b.n	37d98 <base64_append_bytes+0x8>

00037dba <nrf_gpio_pin_present_check>:
    switch (port)
   37dba:	0943      	lsrs	r3, r0, #5
   37dbc:	bf0c      	ite	eq
   37dbe:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   37dc2:	2300      	movne	r3, #0
    pin_number &= 0x1F;
   37dc4:	f000 001f 	and.w	r0, r0, #31
    return (mask & (1UL << pin_number)) ? true : false;
   37dc8:	fa23 f000 	lsr.w	r0, r3, r0
}
   37dcc:	f000 0001 	and.w	r0, r0, #1
   37dd0:	4770      	bx	lr

00037dd2 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37dd2:	6843      	ldr	r3, [r0, #4]
}
   37dd4:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37dd6:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   37dd8:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   37dda:	600b      	str	r3, [r1, #0]
}
   37ddc:	4770      	bx	lr

00037dde <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37dde:	6843      	ldr	r3, [r0, #4]
   37de0:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   37de2:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   37de4:	4042      	eors	r2, r0
   37de6:	400a      	ands	r2, r1
   37de8:	4042      	eors	r2, r0
    p_reg->OUT = value;
   37dea:	605a      	str	r2, [r3, #4]
}
   37dec:	2000      	movs	r0, #0
   37dee:	4770      	bx	lr

00037df0 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37df0:	6843      	ldr	r3, [r0, #4]
}
   37df2:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37df4:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   37df6:	6099      	str	r1, [r3, #8]
}
   37df8:	4770      	bx	lr

00037dfa <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37dfa:	6843      	ldr	r3, [r0, #4]
}
   37dfc:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37dfe:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   37e00:	60d9      	str	r1, [r3, #12]
}
   37e02:	4770      	bx	lr

00037e04 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37e04:	6843      	ldr	r3, [r0, #4]
}
   37e06:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   37e08:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   37e0a:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   37e0c:	4059      	eors	r1, r3
    p_reg->OUT = value;
   37e0e:	6051      	str	r1, [r2, #4]
}
   37e10:	4770      	bx	lr

00037e12 <gpio_nrfx_pin_disable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
   37e12:	2301      	movs	r3, #1
{
   37e14:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   37e16:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
   37e18:	fa03 f201 	lsl.w	r2, r3, r1
   37e1c:	6923      	ldr	r3, [r4, #16]
   37e1e:	ea23 0302 	bic.w	r3, r3, r2
   37e22:	6123      	str	r3, [r4, #16]
}
   37e24:	f85d 4b04 	ldr.w	r4, [sp], #4
	return gpiote_pin_int_cfg(port, pin);
   37e28:	f7e7 b940 	b.w	1f0ac <gpiote_pin_int_cfg>

00037e2c <gpio_nrfx_pin_enable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
   37e2c:	2301      	movs	r3, #1
{
   37e2e:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
   37e30:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
   37e32:	fa03 f201 	lsl.w	r2, r3, r1
   37e36:	6923      	ldr	r3, [r4, #16]
   37e38:	4313      	orrs	r3, r2
   37e3a:	6123      	str	r3, [r4, #16]
}
   37e3c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return gpiote_pin_int_cfg(port, pin);
   37e40:	f7e7 b934 	b.w	1f0ac <gpiote_pin_int_cfg>

00037e44 <_spi_context_cs_control.isra.6>:
static inline void _spi_context_cs_control(struct spi_context *ctx,
   37e44:	b538      	push	{r3, r4, r5, lr}
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   37e46:	6804      	ldr	r4, [r0, #0]
static inline void _spi_context_cs_control(struct spi_context *ctx,
   37e48:	4605      	mov	r5, r0
	if (ctx->config && ctx->config->cs && ctx->config->cs->gpio_dev) {
   37e4a:	b324      	cbz	r4, 37e96 <_spi_context_cs_control.isra.6+0x52>
   37e4c:	68a3      	ldr	r3, [r4, #8]
   37e4e:	b313      	cbz	r3, 37e96 <_spi_context_cs_control.isra.6+0x52>
   37e50:	6818      	ldr	r0, [r3, #0]
   37e52:	b300      	cbz	r0, 37e96 <_spi_context_cs_control.isra.6+0x52>
		if (on) {
   37e54:	b161      	cbz	r1, 37e70 <_spi_context_cs_control.isra.6+0x2c>
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   37e56:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   37e5a:	7919      	ldrb	r1, [r3, #4]
   37e5c:	0fd2      	lsrs	r2, r2, #31
   37e5e:	f7e7 fbbf 	bl	1f5e0 <gpio_pin_set>
			k_busy_wait(ctx->config->cs->delay);
   37e62:	682b      	ldr	r3, [r5, #0]
   37e64:	689b      	ldr	r3, [r3, #8]
   37e66:	6898      	ldr	r0, [r3, #8]
}
   37e68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_impl_k_busy_wait(usec_to_wait);
   37e6c:	f000 bf6f 	b.w	38d4e <z_impl_k_busy_wait>
			if (!force_off &&
   37e70:	b912      	cbnz	r2, 37e78 <_spi_context_cs_control.isra.6+0x34>
   37e72:	88a2      	ldrh	r2, [r4, #4]
   37e74:	0492      	lsls	r2, r2, #18
   37e76:	d40e      	bmi.n	37e96 <_spi_context_cs_control.isra.6+0x52>
			k_busy_wait(ctx->config->cs->delay);
   37e78:	6898      	ldr	r0, [r3, #8]
   37e7a:	f000 ff68 	bl	38d4e <z_impl_k_busy_wait>
			gpio_pin_set(ctx->config->cs->gpio_dev,
   37e7e:	682a      	ldr	r2, [r5, #0]
   37e80:	6893      	ldr	r3, [r2, #8]
	if (ctx->config->operation & SPI_CS_ACTIVE_HIGH) {
   37e82:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
			gpio_pin_set(ctx->config->cs->gpio_dev,
   37e86:	7919      	ldrb	r1, [r3, #4]
   37e88:	43d2      	mvns	r2, r2
   37e8a:	6818      	ldr	r0, [r3, #0]
   37e8c:	0fd2      	lsrs	r2, r2, #31
}
   37e8e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			gpio_pin_set(ctx->config->cs->gpio_dev,
   37e92:	f7e7 bba5 	b.w	1f5e0 <gpio_pin_set>
}
   37e96:	bd38      	pop	{r3, r4, r5, pc}

00037e98 <spi_context_unlock_unconditionally>:
{
   37e98:	b510      	push	{r4, lr}
	_spi_context_cs_control(ctx, false, true);
   37e9a:	2201      	movs	r2, #1
   37e9c:	2100      	movs	r1, #0
{
   37e9e:	4604      	mov	r4, r0
	_spi_context_cs_control(ctx, false, true);
   37ea0:	f7ff ffd0 	bl	37e44 <_spi_context_cs_control.isra.6>
	if (!k_sem_count_get(&ctx->lock)) {
   37ea4:	68e3      	ldr	r3, [r4, #12]
   37ea6:	b923      	cbnz	r3, 37eb2 <spi_context_unlock_unconditionally+0x1a>
	z_impl_k_sem_give(sem);
   37ea8:	1d20      	adds	r0, r4, #4
}
   37eaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   37eae:	f7f6 b89d 	b.w	2dfec <z_impl_k_sem_give>
   37eb2:	bd10      	pop	{r4, pc}

00037eb4 <spi_nrfx_release>:
	struct spi_nrfx_data *dev_data = get_dev_data(dev);
   37eb4:	68c0      	ldr	r0, [r0, #12]
{
   37eb6:	b510      	push	{r4, lr}
	if (!spi_context_configured(&dev_data->ctx, spi_cfg)) {
   37eb8:	6803      	ldr	r3, [r0, #0]
   37eba:	428b      	cmp	r3, r1
   37ebc:	d106      	bne.n	37ecc <spi_nrfx_release+0x18>
	if (dev_data->busy) {
   37ebe:	f890 405c 	ldrb.w	r4, [r0, #92]	; 0x5c
   37ec2:	b934      	cbnz	r4, 37ed2 <spi_nrfx_release+0x1e>
	spi_context_unlock_unconditionally(&dev_data->ctx);
   37ec4:	f7ff ffe8 	bl	37e98 <spi_context_unlock_unconditionally>
	return 0;
   37ec8:	4620      	mov	r0, r4
}
   37eca:	bd10      	pop	{r4, pc}
		return -EINVAL;
   37ecc:	f06f 0015 	mvn.w	r0, #21
   37ed0:	e7fb      	b.n	37eca <spi_nrfx_release+0x16>
		return -EBUSY;
   37ed2:	f06f 000f 	mvn.w	r0, #15
   37ed6:	e7f8      	b.n	37eca <spi_nrfx_release+0x16>

00037ed8 <nrf_gpio_pin_present_check>:
    switch (port)
   37ed8:	0943      	lsrs	r3, r0, #5
   37eda:	bf0c      	ite	eq
   37edc:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   37ee0:	2300      	movne	r3, #0
    pin_number &= 0x1F;
   37ee2:	f000 001f 	and.w	r0, r0, #31
    return (mask & (1UL << pin_number)) ? true : false;
   37ee6:	fa23 f000 	lsr.w	r0, r3, r0
}
   37eea:	f000 0001 	and.w	r0, r0, #1
   37eee:	4770      	bx	lr

00037ef0 <uarte_nrfx_isr_int>:
	if (data->int_driven->disable_tx_irq &&
   37ef0:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   37ef2:	6843      	ldr	r3, [r0, #4]
	if (data->int_driven->disable_tx_irq &&
   37ef4:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   37ef6:	681b      	ldr	r3, [r3, #0]
	if (data->int_driven->disable_tx_irq &&
   37ef8:	7b91      	ldrb	r1, [r2, #14]
   37efa:	b159      	cbz	r1, 37f14 <uarte_nrfx_isr_int+0x24>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37efc:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
   37f00:	b141      	cbz	r1, 37f14 <uarte_nrfx_isr_int+0x24>
    p_reg->INTENCLR = mask;
   37f02:	f44f 7180 	mov.w	r1, #256	; 0x100
   37f06:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37f0a:	2101      	movs	r1, #1
   37f0c:	60d9      	str	r1, [r3, #12]
		data->int_driven->disable_tx_irq = false;
   37f0e:	2300      	movs	r3, #0
   37f10:	7393      	strb	r3, [r2, #14]
		return;
   37f12:	4770      	bx	lr
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37f14:	f8d3 1124 	ldr.w	r1, [r3, #292]	; 0x124
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {
   37f18:	b111      	cbz	r1, 37f20 <uarte_nrfx_isr_int+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   37f1a:	2100      	movs	r1, #0
   37f1c:	f8c3 1124 	str.w	r1, [r3, #292]	; 0x124
	if (data->int_driven->cb) {
   37f20:	6813      	ldr	r3, [r2, #0]
   37f22:	b10b      	cbz	r3, 37f28 <uarte_nrfx_isr_int+0x38>
		data->int_driven->cb(data->int_driven->cb_data);
   37f24:	6850      	ldr	r0, [r2, #4]
   37f26:	4718      	bx	r3
}
   37f28:	4770      	bx	lr

00037f2a <uarte_nrfx_config_get>:
{
   37f2a:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   37f2c:	68c2      	ldr	r2, [r0, #12]
   37f2e:	e892 0003 	ldmia.w	r2, {r0, r1}
   37f32:	e883 0003 	stmia.w	r3, {r0, r1}
}
   37f36:	2000      	movs	r0, #0
   37f38:	4770      	bx	lr

00037f3a <uarte_nrfx_err_check>:
	return config->uarte_regs;
   37f3a:	6843      	ldr	r3, [r0, #4]
   37f3c:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   37f3e:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   37f42:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   37f46:	4770      	bx	lr

00037f48 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   37f48:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   37f4a:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   37f4c:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37f4e:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   37f52:	b138      	cbz	r0, 37f64 <uarte_nrfx_poll_in+0x1c>
	*c = data->rx_data;
   37f54:	7c12      	ldrb	r2, [r2, #16]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   37f56:	2000      	movs	r0, #0
   37f58:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37f5a:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   37f5c:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37f60:	601a      	str	r2, [r3, #0]
	return 0;
   37f62:	4770      	bx	lr
		return -1;
   37f64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   37f68:	4770      	bx	lr

00037f6a <uarte_nrfx_fifo_fill>:
	return config->uarte_regs;
   37f6a:	6843      	ldr	r3, [r0, #4]
{
   37f6c:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
   37f6e:	681c      	ldr	r4, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37f70:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   37f74:	b1bb      	cbz	r3, 37fa6 <uarte_nrfx_fifo_fill+0x3c>
	struct uarte_nrfx_data *data = get_dev_data(dev);
   37f76:	68c5      	ldr	r5, [r0, #12]
	if (len > data->int_driven->tx_buff_size) {
   37f78:	68ab      	ldr	r3, [r5, #8]
   37f7a:	8998      	ldrh	r0, [r3, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   37f7c:	2300      	movs	r3, #0
   37f7e:	4290      	cmp	r0, r2
   37f80:	bfa8      	it	ge
   37f82:	4610      	movge	r0, r2
   37f84:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
	for (int i = 0; i < len; i++) {
   37f88:	68aa      	ldr	r2, [r5, #8]
   37f8a:	4283      	cmp	r3, r0
   37f8c:	6892      	ldr	r2, [r2, #8]
   37f8e:	db06      	blt.n	37f9e <uarte_nrfx_fifo_fill+0x34>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37f90:	2301      	movs	r3, #1
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   37f92:	f8c4 2544 	str.w	r2, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   37f96:	f8c4 0548 	str.w	r0, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37f9a:	60a3      	str	r3, [r4, #8]
}
   37f9c:	bd70      	pop	{r4, r5, r6, pc}
		data->int_driven->tx_buffer[i] = tx_data[i];
   37f9e:	5cce      	ldrb	r6, [r1, r3]
   37fa0:	54d6      	strb	r6, [r2, r3]
	for (int i = 0; i < len; i++) {
   37fa2:	3301      	adds	r3, #1
   37fa4:	e7f0      	b.n	37f88 <uarte_nrfx_fifo_fill+0x1e>
		return 0;
   37fa6:	4618      	mov	r0, r3
   37fa8:	e7f8      	b.n	37f9c <uarte_nrfx_fifo_fill+0x32>

00037faa <uarte_nrfx_fifo_read>:
	return config->uarte_regs;
   37faa:	6843      	ldr	r3, [r0, #4]
   37fac:	681a      	ldr	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37fae:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   37fb2:	b143      	cbz	r3, 37fc6 <uarte_nrfx_fifo_read+0x1c>
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   37fb4:	68c3      	ldr	r3, [r0, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   37fb6:	2000      	movs	r0, #0
   37fb8:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   37fbc:	2001      	movs	r0, #1
		rx_data[num_rx++] = (u8_t)data->rx_data;
   37fbe:	7c1b      	ldrb	r3, [r3, #16]
   37fc0:	700b      	strb	r3, [r1, #0]
   37fc2:	6010      	str	r0, [r2, #0]
   37fc4:	4770      	bx	lr
	int num_rx = 0;
   37fc6:	4618      	mov	r0, r3
}
   37fc8:	4770      	bx	lr

00037fca <uarte_nrfx_irq_tx_enable>:
	data->int_driven->disable_tx_irq = false;
   37fca:	2100      	movs	r1, #0
   37fcc:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   37fce:	6843      	ldr	r3, [r0, #4]
	data->int_driven->disable_tx_irq = false;
   37fd0:	6892      	ldr	r2, [r2, #8]
	return config->uarte_regs;
   37fd2:	681b      	ldr	r3, [r3, #0]
	data->int_driven->disable_tx_irq = false;
   37fd4:	7391      	strb	r1, [r2, #14]
    p_reg->INTENSET = mask;
   37fd6:	f44f 7280 	mov.w	r2, #256	; 0x100
   37fda:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   37fde:	4770      	bx	lr

00037fe0 <uarte_nrfx_irq_tx_disable>:
	data->int_driven->disable_tx_irq = true;
   37fe0:	2201      	movs	r2, #1
   37fe2:	68c3      	ldr	r3, [r0, #12]
   37fe4:	689b      	ldr	r3, [r3, #8]
   37fe6:	739a      	strb	r2, [r3, #14]
}
   37fe8:	4770      	bx	lr

00037fea <uarte_nrfx_irq_tx_ready_complete>:
	return !data->int_driven->disable_tx_irq &&
   37fea:	68c3      	ldr	r3, [r0, #12]
   37fec:	689b      	ldr	r3, [r3, #8]
   37fee:	7b9b      	ldrb	r3, [r3, #14]
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   37ff0:	b94b      	cbnz	r3, 38006 <uarte_nrfx_irq_tx_ready_complete+0x1c>
	return config->uarte_regs;
   37ff2:	6843      	ldr	r3, [r0, #4]
   37ff4:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   37ff6:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
	return !data->int_driven->disable_tx_irq &&
   37ffa:	b128      	cbz	r0, 38008 <uarte_nrfx_irq_tx_ready_complete+0x1e>
    return p_reg->INTENSET & mask;
   37ffc:	f8d3 0304 	ldr.w	r0, [r3, #772]	; 0x304
	       nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX) &&
   38000:	f3c0 2000 	ubfx	r0, r0, #8, #1
   38004:	4770      	bx	lr
   38006:	2000      	movs	r0, #0
}
   38008:	4770      	bx	lr

0003800a <uarte_nrfx_irq_rx_ready>:
	return config->uarte_regs;
   3800a:	6843      	ldr	r3, [r0, #4]
   3800c:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   3800e:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
}
   38012:	3000      	adds	r0, #0
   38014:	bf18      	it	ne
   38016:	2001      	movne	r0, #1
   38018:	4770      	bx	lr

0003801a <uarte_nrfx_irq_rx_enable>:
    p_reg->INTENSET = mask;
   3801a:	2210      	movs	r2, #16
	return config->uarte_regs;
   3801c:	6843      	ldr	r3, [r0, #4]
   3801e:	681b      	ldr	r3, [r3, #0]
   38020:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   38024:	4770      	bx	lr

00038026 <uarte_nrfx_irq_rx_disable>:
    p_reg->INTENCLR = mask;
   38026:	2210      	movs	r2, #16
	return config->uarte_regs;
   38028:	6843      	ldr	r3, [r0, #4]
   3802a:	681b      	ldr	r3, [r3, #0]
   3802c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   38030:	4770      	bx	lr

00038032 <uarte_nrfx_irq_err_enable>:
    p_reg->INTENSET = mask;
   38032:	f44f 7200 	mov.w	r2, #512	; 0x200
	return config->uarte_regs;
   38036:	6843      	ldr	r3, [r0, #4]
   38038:	681b      	ldr	r3, [r3, #0]
   3803a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   3803e:	4770      	bx	lr

00038040 <uarte_nrfx_irq_err_disable>:
    p_reg->INTENCLR = mask;
   38040:	f44f 7200 	mov.w	r2, #512	; 0x200
	return config->uarte_regs;
   38044:	6843      	ldr	r3, [r0, #4]
   38046:	681b      	ldr	r3, [r3, #0]
   38048:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
   3804c:	4770      	bx	lr

0003804e <uarte_nrfx_irq_update>:
}
   3804e:	2001      	movs	r0, #1
   38050:	4770      	bx	lr

00038052 <uarte_nrfx_irq_callback_set>:
	data->int_driven->cb = cb;
   38052:	68c3      	ldr	r3, [r0, #12]
   38054:	689b      	ldr	r3, [r3, #8]
	data->int_driven->cb_data = cb_data;
   38056:	e9c3 1200 	strd	r1, r2, [r3]
}
   3805a:	4770      	bx	lr

0003805c <uarte_nrfx_irq_is_pending>:
{
   3805c:	b508      	push	{r3, lr}
	return config->uarte_regs;
   3805e:	6843      	ldr	r3, [r0, #4]
{
   38060:	4602      	mov	r2, r0
	return config->uarte_regs;
   38062:	6819      	ldr	r1, [r3, #0]
    return p_reg->INTENSET & mask;
   38064:	f8d1 3304 	ldr.w	r3, [r1, #772]	; 0x304
		||
   38068:	05db      	lsls	r3, r3, #23
   3806a:	d405      	bmi.n	38078 <uarte_nrfx_irq_is_pending+0x1c>
   3806c:	f8d1 0304 	ldr.w	r0, [r1, #772]	; 0x304
   38070:	f010 0010 	ands.w	r0, r0, #16
   38074:	d106      	bne.n	38084 <uarte_nrfx_irq_is_pending+0x28>
}
   38076:	bd08      	pop	{r3, pc}
		 uarte_nrfx_irq_tx_ready_complete(dev))
   38078:	f7ff ffb7 	bl	37fea <uarte_nrfx_irq_tx_ready_complete>
					    NRF_UARTE_INT_ENDTX_MASK) &&
   3807c:	2800      	cmp	r0, #0
   3807e:	d0f5      	beq.n	3806c <uarte_nrfx_irq_is_pending+0x10>
		||
   38080:	2001      	movs	r0, #1
   38082:	e7f8      	b.n	38076 <uarte_nrfx_irq_is_pending+0x1a>
		 uarte_nrfx_irq_rx_ready(dev)));
   38084:	4610      	mov	r0, r2
   38086:	f7ff ffc0 	bl	3800a <uarte_nrfx_irq_rx_ready>
					    NRF_UARTE_INT_ENDRX_MASK) &&
   3808a:	3000      	adds	r0, #0
   3808c:	bf18      	it	ne
   3808e:	2001      	movne	r0, #1
   38090:	e7f1      	b.n	38076 <uarte_nrfx_irq_is_pending+0x1a>

00038092 <uarte_nrfx_poll_out>:
{
   38092:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return config->uarte_regs;
   38096:	6843      	ldr	r3, [r0, #4]
{
   38098:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
   3809c:	681c      	ldr	r4, [r3, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
   3809e:	68c6      	ldr	r6, [r0, #12]
	if (!k_is_in_isr()) {
   380a0:	f000 fe4f 	bl	38d42 <k_is_in_isr>
   380a4:	b9b8      	cbnz	r0, 380d6 <uarte_nrfx_poll_out+0x44>
   380a6:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
   380a8:	f04f 0801 	mov.w	r8, #1
   380ac:	f106 070c 	add.w	r7, r6, #12
   380b0:	e8d7 3fef 	ldaex	r3, [r7]
   380b4:	2b00      	cmp	r3, #0
   380b6:	d103      	bne.n	380c0 <uarte_nrfx_poll_out+0x2e>
   380b8:	e8c7 8fe2 	stlex	r2, r8, [r7]
   380bc:	2a00      	cmp	r2, #0
   380be:	d1f7      	bne.n	380b0 <uarte_nrfx_poll_out+0x1e>
		while (atomic_cas((atomic_t *) lock,
   380c0:	d00b      	beq.n	380da <uarte_nrfx_poll_out+0x48>
	return z_impl_k_sleep(timeout);
   380c2:	2001      	movs	r0, #1
   380c4:	3d01      	subs	r5, #1
   380c6:	f7f5 ff4f 	bl	2df68 <z_impl_k_sleep>
			if (--safety_cnt == 0) {
   380ca:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   380ce:	d1ef      	bne.n	380b0 <uarte_nrfx_poll_out+0x1e>
}
   380d0:	b002      	add	sp, #8
   380d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*lock = 1;
   380d6:	2301      	movs	r3, #1
   380d8:	60f3      	str	r3, [r6, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   380da:	2300      	movs	r3, #0
   380dc:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
   380e0:	f10d 0307 	add.w	r3, sp, #7
   380e4:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
   380e8:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   380ea:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    p_reg->TXD.MAXCNT = length;
   380ee:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   380f2:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   380f4:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
   380f8:	b923      	cbnz	r3, 38104 <uarte_nrfx_poll_out+0x72>
   380fa:	2001      	movs	r0, #1
   380fc:	f000 fcbe 	bl	38a7c <nrfx_busy_wait>
   38100:	3d01      	subs	r5, #1
   38102:	d1f7      	bne.n	380f4 <uarte_nrfx_poll_out+0x62>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   38104:	2301      	movs	r3, #1
   38106:	60e3      	str	r3, [r4, #12]
	*lock = 0;
   38108:	2300      	movs	r3, #0
   3810a:	60f3      	str	r3, [r6, #12]
   3810c:	e7e0      	b.n	380d0 <uarte_nrfx_poll_out+0x3e>

0003810e <entropy_cc310_rng_init>:
{
	/* No initialization is required */
	(void)dev;

	return 0;
}
   3810e:	2000      	movs	r0, #0
   38110:	4770      	bx	lr

00038112 <trace_proxy_irq_handler>:
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   38112:	4668      	mov	r0, sp
   38114:	f020 0107 	bic.w	r1, r0, #7
   38118:	468d      	mov	sp, r1
   3811a:	b501      	push	{r0, lr}
	bsd_os_trace_irq_handler();
   3811c:	f7ea fdaa 	bl	22c74 <bsd_os_trace_irq_handler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   38120:	f7e2 fda8 	bl	1ac74 <_arch_isr_direct_pm>
   38124:	f7e3 f9f4 	bl	1b510 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(trace_proxy_irq_handler)
   38128:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3812c:	4685      	mov	sp, r0
   3812e:	4770      	bx	lr

00038130 <ipc_proxy_irq_handler>:
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   38130:	4668      	mov	r0, sp
   38132:	f020 0107 	bic.w	r1, r0, #7
   38136:	468d      	mov	sp, r1
   38138:	b501      	push	{r0, lr}
	IPC_IRQHandler();
   3813a:	f7eb f8c5 	bl	232c8 <IPC_IRQHandler>
	ISR_DIRECT_PM(); /* PM done after servicing interrupt for best latency
   3813e:	f7e2 fd99 	bl	1ac74 <_arch_isr_direct_pm>
   38142:	f7e3 f9e5 	bl	1b510 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(ipc_proxy_irq_handler)
   38146:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
   3814a:	4685      	mov	sp, r0
   3814c:	4770      	bx	lr

0003814e <trace_task_create>:
{
   3814e:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(TRACE_IRQ, TRACE_IRQ_PRIORITY,
   38150:	201d      	movs	r0, #29
   38152:	2200      	movs	r2, #0
   38154:	2106      	movs	r1, #6
   38156:	f7e2 fd5b 	bl	1ac10 <z_arm_irq_priority_set>
}
   3815a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(TRACE_IRQ);
   3815e:	201d      	movs	r0, #29
   38160:	f7e2 bd46 	b.w	1abf0 <arch_irq_enable>

00038164 <read_task_create>:
{
   38164:	b508      	push	{r3, lr}
	IRQ_DIRECT_CONNECT(BSD_APPLICATION_IRQ, BSD_APPLICATION_IRQ_PRIORITY,
   38166:	201c      	movs	r0, #28
   38168:	2200      	movs	r2, #0
   3816a:	2106      	movs	r1, #6
   3816c:	f7e2 fd50 	bl	1ac10 <z_arm_irq_priority_set>
}
   38170:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	irq_enable(BSD_APPLICATION_IRQ);
   38174:	201c      	movs	r0, #28
   38176:	f7e2 bd3b 	b.w	1abf0 <arch_irq_enable>

0003817a <bsd_os_trace_put>:
		remaining_bytes -= transfer_len;
	}
#endif

	return 0;
}
   3817a:	2000      	movs	r0, #0
   3817c:	4770      	bx	lr

0003817e <z_to_nrf_flags>:
		nrf_flags |= NRF_MSG_DONTWAIT;
   3817e:	f010 0340 	ands.w	r3, r0, #64	; 0x40
   38182:	bf18      	it	ne
   38184:	2302      	movne	r3, #2
	if (z_flags & MSG_PEEK) {
   38186:	0781      	lsls	r1, r0, #30
		nrf_flags |= NRF_MSG_PEEK;
   38188:	bf48      	it	mi
   3818a:	f043 0308 	orrmi.w	r3, r3, #8
	if (z_flags & MSG_TRUNC) {
   3818e:	06c2      	lsls	r2, r0, #27
		nrf_flags |= NRF_MSG_TRUNC;
   38190:	bf48      	it	mi
   38192:	f043 0320 	orrmi.w	r3, r3, #32
}
   38196:	4618      	mov	r0, r3
   38198:	4770      	bx	lr

0003819a <z_to_nrf_family>:
	switch (z_family) {
   3819a:	2803      	cmp	r0, #3
   3819c:	d00f      	beq.n	381be <z_to_nrf_family+0x24>
   3819e:	d808      	bhi.n	381b2 <z_to_nrf_family+0x18>
   381a0:	2801      	cmp	r0, #1
   381a2:	d00e      	beq.n	381c2 <z_to_nrf_family+0x28>
   381a4:	2802      	cmp	r0, #2
		return -EAFNOSUPPORT;
   381a6:	bf08      	it	eq
   381a8:	200a      	moveq	r0, #10
   381aa:	bf18      	it	ne
   381ac:	f06f 0069 	mvnne.w	r0, #105	; 0x69
   381b0:	4770      	bx	lr
	switch (z_family) {
   381b2:	2806      	cmp	r0, #6
   381b4:	d007      	beq.n	381c6 <z_to_nrf_family+0x2c>
   381b6:	2866      	cmp	r0, #102	; 0x66
		return -EAFNOSUPPORT;
   381b8:	bf08      	it	eq
   381ba:	2066      	moveq	r0, #102	; 0x66
   381bc:	e7f5      	b.n	381aa <z_to_nrf_family+0x10>
		return NRF_AF_PACKET;
   381be:	2005      	movs	r0, #5
   381c0:	4770      	bx	lr
		return NRF_AF_INET;
   381c2:	2002      	movs	r0, #2
   381c4:	4770      	bx	lr
		return NRF_AF_LOCAL;
   381c6:	2001      	movs	r0, #1
}
   381c8:	4770      	bx	lr

000381ca <z_to_nrf_protocol>:
	switch (proto) {
   381ca:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
   381ce:	d01d      	beq.n	3820c <z_to_nrf_protocol+0x42>
   381d0:	dc08      	bgt.n	381e4 <z_to_nrf_protocol+0x1a>
   381d2:	2806      	cmp	r0, #6
   381d4:	d01d      	beq.n	38212 <z_to_nrf_protocol+0x48>
   381d6:	2811      	cmp	r0, #17
   381d8:	d01d      	beq.n	38216 <z_to_nrf_protocol+0x4c>
   381da:	2800      	cmp	r0, #0
		return -EPROTONOSUPPORT;
   381dc:	bf18      	it	ne
   381de:	f06f 007a 	mvnne.w	r0, #122	; 0x7a
   381e2:	4770      	bx	lr
	switch (proto) {
   381e4:	f240 2301 	movw	r3, #513	; 0x201
   381e8:	4298      	cmp	r0, r3
   381ea:	d015      	beq.n	38218 <z_to_nrf_protocol+0x4e>
   381ec:	dc06      	bgt.n	381fc <z_to_nrf_protocol+0x32>
   381ee:	f240 1311 	movw	r3, #273	; 0x111
   381f2:	4298      	cmp	r0, r3
		return -EPROTONOSUPPORT;
   381f4:	bf08      	it	eq
   381f6:	f44f 7087 	moveq.w	r0, #270	; 0x10e
   381fa:	e7ef      	b.n	381dc <z_to_nrf_protocol+0x12>
	switch (proto) {
   381fc:	f240 2302 	movw	r3, #514	; 0x202
   38200:	4298      	cmp	r0, r3
   38202:	d009      	beq.n	38218 <z_to_nrf_protocol+0x4e>
   38204:	f240 2303 	movw	r3, #515	; 0x203
   38208:	4298      	cmp	r0, r3
   3820a:	e7e7      	b.n	381dc <z_to_nrf_protocol+0x12>
		return NRF_SPROTO_TLS1v2;
   3820c:	f44f 7082 	mov.w	r0, #260	; 0x104
   38210:	4770      	bx	lr
		return NRF_IPPROTO_TCP;
   38212:	2001      	movs	r0, #1
   38214:	4770      	bx	lr
		return NRF_IPPROTO_UDP;
   38216:	2002      	movs	r0, #2
}
   38218:	4770      	bx	lr

0003821a <nrf91_socket_is_supported>:
}
   3821a:	2001      	movs	r0, #1
   3821c:	4770      	bx	lr

0003821e <nrf91_bsdlib_socket_offload_init>:
}
   3821e:	2000      	movs	r0, #0
   38220:	4770      	bx	lr

00038222 <nrf91_socket_offload_getsockopt>:
{
   38222:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   38226:	461d      	mov	r5, r3
	struct nrf_timeval nrf_timeo = {0, 0};
   38228:	2300      	movs	r3, #0
{
   3822a:	b086      	sub	sp, #24
   3822c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	struct nrf_timeval nrf_timeo = {0, 0};
   38230:	e9cd 3304 	strd	r3, r3, [sp, #16]
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   38234:	f8d8 3000 	ldr.w	r3, [r8]
	switch (z_in_level) {
   38238:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   3823c:	460c      	mov	r4, r1
   3823e:	4616      	mov	r6, r2
	int sd = OBJ_TO_SD(obj);
   38240:	f100 37ff 	add.w	r7, r0, #4294967295	; 0xffffffff
	nrf_socklen_t nrf_optlen = (nrf_socklen_t)*optlen;
   38244:	9303      	str	r3, [sp, #12]
	switch (z_in_level) {
   38246:	d002      	beq.n	3824e <nrf91_socket_offload_getsockopt+0x2c>
   38248:	dc2d      	bgt.n	382a6 <nrf91_socket_offload_getsockopt+0x84>
   3824a:	2901      	cmp	r1, #1
   3824c:	d140      	bne.n	382d0 <nrf91_socket_offload_getsockopt+0xae>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   3824e:	aa02      	add	r2, sp, #8
   38250:	4631      	mov	r1, r6
   38252:	4620      	mov	r0, r4
   38254:	f7e8 f832 	bl	202bc <z_to_nrf_optname>
   38258:	2800      	cmp	r0, #0
   3825a:	db39      	blt.n	382d0 <nrf91_socket_offload_getsockopt+0xae>
	if ((level == SOL_SOCKET) && ((optname == SO_RCVTIMEO) ||
   3825c:	2c01      	cmp	r4, #1
   3825e:	d12a      	bne.n	382b6 <nrf91_socket_offload_getsockopt+0x94>
   38260:	f1a6 0314 	sub.w	r3, r6, #20
   38264:	2b01      	cmp	r3, #1
   38266:	d826      	bhi.n	382b6 <nrf91_socket_offload_getsockopt+0x94>
		nrf_optlen = sizeof(struct nrf_timeval);
   38268:	2308      	movs	r3, #8
   3826a:	9303      	str	r3, [sp, #12]
		nrf_optval = &nrf_timeo;
   3826c:	ab04      	add	r3, sp, #16
	retval = nrf_getsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   3826e:	aa03      	add	r2, sp, #12
   38270:	9200      	str	r2, [sp, #0]
   38272:	4638      	mov	r0, r7
   38274:	9a02      	ldr	r2, [sp, #8]
   38276:	4621      	mov	r1, r4
   38278:	f7f0 fede 	bl	29038 <nrf_getsockopt>
	if ((retval == 0) && (optval != NULL)) {
   3827c:	4607      	mov	r7, r0
   3827e:	b970      	cbnz	r0, 3829e <nrf91_socket_offload_getsockopt+0x7c>
   38280:	b16d      	cbz	r5, 3829e <nrf91_socket_offload_getsockopt+0x7c>
		*optlen = nrf_optlen;
   38282:	9b03      	ldr	r3, [sp, #12]
		if (level == SOL_SOCKET) {
   38284:	2c01      	cmp	r4, #1
		*optlen = nrf_optlen;
   38286:	f8c8 3000 	str.w	r3, [r8]
		if (level == SOL_SOCKET) {
   3828a:	d108      	bne.n	3829e <nrf91_socket_offload_getsockopt+0x7c>
			if (optname == SO_ERROR) {
   3828c:	2e04      	cmp	r6, #4
   3828e:	d114      	bne.n	382ba <nrf91_socket_offload_getsockopt+0x98>
				bsd_os_errno_set(*(int *)optval);
   38290:	6828      	ldr	r0, [r5, #0]
   38292:	f7e7 fee5 	bl	20060 <bsd_os_errno_set>
				*(int *)optval = errno;
   38296:	f7fd f927 	bl	354e8 <__errno>
   3829a:	6803      	ldr	r3, [r0, #0]
   3829c:	602b      	str	r3, [r5, #0]
}
   3829e:	4638      	mov	r0, r7
   382a0:	b006      	add	sp, #24
   382a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   382a6:	f240 2302 	movw	r3, #514	; 0x202
   382aa:	4299      	cmp	r1, r3
   382ac:	d0cf      	beq.n	3824e <nrf91_socket_offload_getsockopt+0x2c>
   382ae:	f240 2303 	movw	r3, #515	; 0x203
   382b2:	4299      	cmp	r1, r3
   382b4:	e7ca      	b.n	3824c <nrf91_socket_offload_getsockopt+0x2a>
   382b6:	462b      	mov	r3, r5
   382b8:	e7d9      	b.n	3826e <nrf91_socket_offload_getsockopt+0x4c>
			} else if ((optname == SO_RCVTIMEO) ||
   382ba:	3e14      	subs	r6, #20
   382bc:	2e01      	cmp	r6, #1
   382be:	d8ee      	bhi.n	3829e <nrf91_socket_offload_getsockopt+0x7c>
				((struct timeval *)optval)->tv_sec =
   382c0:	9b04      	ldr	r3, [sp, #16]
   382c2:	602b      	str	r3, [r5, #0]
				((struct timeval *)optval)->tv_usec =
   382c4:	9b05      	ldr	r3, [sp, #20]
   382c6:	606b      	str	r3, [r5, #4]
				*optlen = sizeof(struct timeval);
   382c8:	2308      	movs	r3, #8
   382ca:	f8c8 3000 	str.w	r3, [r8]
   382ce:	e7e6      	b.n	3829e <nrf91_socket_offload_getsockopt+0x7c>
	errno = ENOPROTOOPT;
   382d0:	f7fd f90a 	bl	354e8 <__errno>
   382d4:	236d      	movs	r3, #109	; 0x6d
	return retval;
   382d6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
	errno = ENOPROTOOPT;
   382da:	6003      	str	r3, [r0, #0]
	return retval;
   382dc:	e7df      	b.n	3829e <nrf91_socket_offload_getsockopt+0x7c>

000382de <nrf91_socket_offload_listen>:
	return nrf_listen(sd, backlog);
   382de:	3801      	subs	r0, #1
   382e0:	f7f0 be56 	b.w	28f90 <nrf_listen>

000382e4 <nrf91_socket_offload_freeaddrinfo>:
{
   382e4:	b538      	push	{r3, r4, r5, lr}
   382e6:	4604      	mov	r4, r0
	while (next != NULL) {
   382e8:	b904      	cbnz	r4, 382ec <nrf91_socket_offload_freeaddrinfo+0x8>
}
   382ea:	bd38      	pop	{r3, r4, r5, pc}
		k_free(this->ai_addr);
   382ec:	69a0      	ldr	r0, [r4, #24]
		next = next->ai_next;
   382ee:	6825      	ldr	r5, [r4, #0]
		k_free(this->ai_addr);
   382f0:	f000 fc8e 	bl	38c10 <k_free>
		k_free(this);
   382f4:	4620      	mov	r0, r4
   382f6:	f000 fc8b 	bl	38c10 <k_free>
		next = next->ai_next;
   382fa:	462c      	mov	r4, r5
   382fc:	e7f4      	b.n	382e8 <nrf91_socket_offload_freeaddrinfo+0x4>

000382fe <z_to_nrf_addrinfo_hints>:
{
   382fe:	b538      	push	{r3, r4, r5, lr}
   38300:	460c      	mov	r4, r1
   38302:	4605      	mov	r5, r0
   38304:	221c      	movs	r2, #28
   38306:	2100      	movs	r1, #0
   38308:	1d20      	adds	r0, r4, #4
   3830a:	f000 fe9f 	bl	3904c <memset>
	nrf_out->ai_flags = z_to_nrf_addrinfo_flags(z_in->ai_flags);
   3830e:	2300      	movs	r3, #0
   38310:	6023      	str	r3, [r4, #0]
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   38312:	68eb      	ldr	r3, [r5, #12]
	switch (socktype) {
   38314:	2b03      	cmp	r3, #3
   38316:	d003      	beq.n	38320 <z_to_nrf_addrinfo_hints+0x22>
		return NRF_SOCK_MGMT;
   38318:	2b04      	cmp	r3, #4
   3831a:	bf08      	it	eq
   3831c:	f44f 7300 	moveq.w	r3, #512	; 0x200
	nrf_out->ai_socktype = z_to_nrf_socktype(z_in->ai_socktype);
   38320:	60a3      	str	r3, [r4, #8]
	family = z_to_nrf_family(z_in->ai_family);
   38322:	8928      	ldrh	r0, [r5, #8]
   38324:	f7ff ff39 	bl	3819a <z_to_nrf_family>
	if (family == -EAFNOSUPPORT) {
   38328:	f110 0f6a 	cmn.w	r0, #106	; 0x6a
   3832c:	d00b      	beq.n	38346 <z_to_nrf_addrinfo_hints+0x48>
	nrf_out->ai_family = family;
   3832e:	6060      	str	r0, [r4, #4]
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   38330:	6928      	ldr	r0, [r5, #16]
   38332:	f7ff ff4a 	bl	381ca <z_to_nrf_protocol>
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   38336:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
	nrf_out->ai_protocol = z_to_nrf_protocol(z_in->ai_protocol);
   3833a:	60e0      	str	r0, [r4, #12]
	if (nrf_out->ai_protocol == -EPROTONOSUPPORT) {
   3833c:	d003      	beq.n	38346 <z_to_nrf_addrinfo_hints+0x48>
	if (z_in->ai_canonname != NULL) {
   3833e:	69e8      	ldr	r0, [r5, #28]
   38340:	b108      	cbz	r0, 38346 <z_to_nrf_addrinfo_hints+0x48>
		nrf_out->ai_canonname = z_in->ai_canonname;
   38342:	61a0      	str	r0, [r4, #24]
	return 0;
   38344:	2000      	movs	r0, #0
}
   38346:	bd38      	pop	{r3, r4, r5, pc}

00038348 <nrf_to_z_ipv6>:
	ptr->sin6_port = nrf_in->sin6_port;
   38348:	890b      	ldrh	r3, [r1, #8]
	ptr->sin6_family = AF_INET6;
   3834a:	2202      	movs	r2, #2
	ptr->sin6_port = nrf_in->sin6_port;
   3834c:	8043      	strh	r3, [r0, #2]
	ptr->sin6_family = AF_INET6;
   3834e:	4603      	mov	r3, r0
{
   38350:	b530      	push	{r4, r5, lr}
	ptr->sin6_family = AF_INET6;
   38352:	f823 2b04 	strh.w	r2, [r3], #4
__ssp_bos_icheck3_restrict(memcpy, void *, const void *)
   38356:	f101 0210 	add.w	r2, r1, #16
   3835a:	f102 0410 	add.w	r4, r2, #16
   3835e:	f852 5b04 	ldr.w	r5, [r2], #4
   38362:	42a2      	cmp	r2, r4
   38364:	f843 5b04 	str.w	r5, [r3], #4
   38368:	d1f9      	bne.n	3835e <nrf_to_z_ipv6+0x16>
	ptr->sin6_scope_id = (u8_t)nrf_in->sin6_scope_id;
   3836a:	6a0b      	ldr	r3, [r1, #32]
   3836c:	7503      	strb	r3, [r0, #20]
}
   3836e:	bd30      	pop	{r4, r5, pc}

00038370 <nrf91_socket_offload_recvfrom>:
{
   38370:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int sd = OBJ_TO_SD(obj);
   38374:	1e45      	subs	r5, r0, #1
{
   38376:	b08d      	sub	sp, #52	; 0x34
   38378:	4618      	mov	r0, r3
   3837a:	e9dd 4614 	ldrd	r4, r6, [sp, #80]	; 0x50
   3837e:	4688      	mov	r8, r1
   38380:	4691      	mov	r9, r2
   38382:	f7ff fefc 	bl	3817e <z_to_nrf_flags>
   38386:	4603      	mov	r3, r0
	if (from == NULL) {
   38388:	b95c      	cbnz	r4, 383a2 <nrf91_socket_offload_recvfrom+0x32>
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags), NULL,
   3838a:	4628      	mov	r0, r5
   3838c:	e9cd 4400 	strd	r4, r4, [sp]
   38390:	464a      	mov	r2, r9
   38392:	4641      	mov	r1, r8
   38394:	f7f0 fdce 	bl	28f34 <nrf_recvfrom>
   38398:	4605      	mov	r5, r0
}
   3839a:	4628      	mov	r0, r5
   3839c:	b00d      	add	sp, #52	; 0x34
   3839e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   383a2:	2224      	movs	r2, #36	; 0x24
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   383a4:	af03      	add	r7, sp, #12
		nrf_socklen_t sock_len = sizeof(struct nrf_sockaddr_in6);
   383a6:	9202      	str	r2, [sp, #8]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   383a8:	aa02      	add	r2, sp, #8
   383aa:	9201      	str	r2, [sp, #4]
   383ac:	4628      	mov	r0, r5
   383ae:	9700      	str	r7, [sp, #0]
   383b0:	464a      	mov	r2, r9
   383b2:	4641      	mov	r1, r8
   383b4:	f7f0 fdbe 	bl	28f34 <nrf_recvfrom>
		if (cliaddr->sa_family == NRF_AF_INET) {
   383b8:	9b04      	ldr	r3, [sp, #16]
		retval = nrf_recvfrom(sd, buf, len, z_to_nrf_flags(flags),
   383ba:	4605      	mov	r5, r0
		if (cliaddr->sa_family == NRF_AF_INET) {
   383bc:	2b02      	cmp	r3, #2
   383be:	d109      	bne.n	383d4 <nrf91_socket_offload_recvfrom+0x64>
	ptr->sin_port = nrf_in->sin_port;
   383c0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   383c4:	8063      	strh	r3, [r4, #2]
	ptr->sin_family = AF_INET;
   383c6:	2301      	movs	r3, #1
   383c8:	8023      	strh	r3, [r4, #0]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   383ca:	9b06      	ldr	r3, [sp, #24]
   383cc:	6063      	str	r3, [r4, #4]
			*fromlen = sizeof(struct sockaddr_in);
   383ce:	2308      	movs	r3, #8
			*fromlen = sizeof(struct sockaddr_in6);
   383d0:	6033      	str	r3, [r6, #0]
	return retval;
   383d2:	e7e2      	b.n	3839a <nrf91_socket_offload_recvfrom+0x2a>
		} else if (cliaddr->sa_family == NRF_AF_INET6) {
   383d4:	2b0a      	cmp	r3, #10
   383d6:	d1e0      	bne.n	3839a <nrf91_socket_offload_recvfrom+0x2a>
			nrf_to_z_ipv6(from, (struct nrf_sockaddr_in6 *)
   383d8:	4639      	mov	r1, r7
   383da:	4620      	mov	r0, r4
   383dc:	f7ff ffb4 	bl	38348 <nrf_to_z_ipv6>
			*fromlen = sizeof(struct sockaddr_in6);
   383e0:	2318      	movs	r3, #24
   383e2:	e7f5      	b.n	383d0 <nrf91_socket_offload_recvfrom+0x60>

000383e4 <nrf91_socket_offload_read>:
	return nrf91_socket_offload_recvfrom(obj, buffer, count, 0, NULL, 0);
   383e4:	2300      	movs	r3, #0
{
   383e6:	b507      	push	{r0, r1, r2, lr}
	return nrf91_socket_offload_recvfrom(obj, buffer, count, 0, NULL, 0);
   383e8:	e9cd 3300 	strd	r3, r3, [sp]
   383ec:	f7ff ffc0 	bl	38370 <nrf91_socket_offload_recvfrom>
}
   383f0:	b003      	add	sp, #12
   383f2:	f85d fb04 	ldr.w	pc, [sp], #4

000383f6 <nrf91_socket_offload_getaddrinfo>:
{
   383f6:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   383fa:	4614      	mov	r4, r2
   383fc:	460e      	mov	r6, r1
	struct nrf_addrinfo *nrf_res = NULL;
   383fe:	2100      	movs	r1, #0
{
   38400:	b093      	sub	sp, #76	; 0x4c
   38402:	4605      	mov	r5, r0
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   38404:	2220      	movs	r2, #32
   38406:	a802      	add	r0, sp, #8
{
   38408:	461f      	mov	r7, r3
	struct nrf_addrinfo *nrf_res = NULL;
   3840a:	9101      	str	r1, [sp, #4]
	memset(&nrf_hints, 0, sizeof(struct nrf_addrinfo));
   3840c:	f000 fe1e 	bl	3904c <memset>
	if (hints != NULL) {
   38410:	b194      	cbz	r4, 38438 <nrf91_socket_offload_getaddrinfo+0x42>
		error = z_to_nrf_addrinfo_hints(hints, &nrf_hints);
   38412:	a902      	add	r1, sp, #8
   38414:	4620      	mov	r0, r4
   38416:	f7ff ff72 	bl	382fe <z_to_nrf_addrinfo_hints>
		if (error == -EPROTONOSUPPORT) {
   3841a:	f110 0f7b 	cmn.w	r0, #123	; 0x7b
   3841e:	f000 80c1 	beq.w	385a4 <nrf91_socket_offload_getaddrinfo+0x1ae>
		} else if (error == -EAFNOSUPPORT) {
   38422:	306a      	adds	r0, #106	; 0x6a
   38424:	f000 80c1 	beq.w	385aa <nrf91_socket_offload_getaddrinfo+0x1b4>
		if (hints->ai_next != NULL) {
   38428:	6820      	ldr	r0, [r4, #0]
   3842a:	b120      	cbz	r0, 38436 <nrf91_socket_offload_getaddrinfo+0x40>
			z_to_nrf_addrinfo_hints(hints->ai_next, &nrf_hints_pdn);
   3842c:	ac0a      	add	r4, sp, #40	; 0x28
   3842e:	4621      	mov	r1, r4
   38430:	f7ff ff65 	bl	382fe <z_to_nrf_addrinfo_hints>
			nrf_hints.ai_next = &nrf_hints_pdn;
   38434:	9409      	str	r4, [sp, #36]	; 0x24
		nrf_hints_ptr = &nrf_hints;
   38436:	ac02      	add	r4, sp, #8
	int retval = nrf_getaddrinfo(node, service, nrf_hints_ptr, &nrf_res);
   38438:	4628      	mov	r0, r5
   3843a:	ab01      	add	r3, sp, #4
   3843c:	4622      	mov	r2, r4
   3843e:	4631      	mov	r1, r6
   38440:	f7f0 fe16 	bl	29070 <nrf_getaddrinfo>
	if (retval != 0) {
   38444:	4605      	mov	r5, r0
   38446:	b1b0      	cbz	r0, 38476 <nrf91_socket_offload_getaddrinfo+0x80>
	switch (nrf_error) {
   38448:	2823      	cmp	r0, #35	; 0x23
   3844a:	f000 80b1 	beq.w	385b0 <nrf91_socket_offload_getaddrinfo+0x1ba>
   3844e:	dc0a      	bgt.n	38466 <nrf91_socket_offload_getaddrinfo+0x70>
		return DNS_EAI_SYSTEM;
   38450:	280c      	cmp	r0, #12
   38452:	bf08      	it	eq
   38454:	f06f 0509 	mvneq.w	r5, #9
   38458:	bf18      	it	ne
   3845a:	f06f 050a 	mvnne.w	r5, #10
}
   3845e:	4628      	mov	r0, r5
   38460:	b013      	add	sp, #76	; 0x4c
   38462:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	switch (nrf_error) {
   38466:	282f      	cmp	r0, #47	; 0x2f
   38468:	f000 80a5 	beq.w	385b6 <nrf91_socket_offload_getaddrinfo+0x1c0>
		return DNS_EAI_SYSTEM;
   3846c:	2873      	cmp	r0, #115	; 0x73
   3846e:	bf08      	it	eq
   38470:	f06f 0563 	mvneq.w	r5, #99	; 0x63
   38474:	e7f0      	b.n	38458 <nrf91_socket_offload_getaddrinfo+0x62>
	struct zsock_addrinfo *latest_z_res = NULL;
   38476:	4680      	mov	r8, r0
	z_out->ai_next = NULL;
   38478:	4681      	mov	r9, r0
	struct nrf_addrinfo *next_nrf_res = nrf_res;
   3847a:	9e01      	ldr	r6, [sp, #4]
	*res = NULL;
   3847c:	6038      	str	r0, [r7, #0]
	while ((retval == 0) && (next_nrf_res != NULL)) {
   3847e:	b91e      	cbnz	r6, 38488 <nrf91_socket_offload_getaddrinfo+0x92>
	nrf_freeaddrinfo(nrf_res);
   38480:	9801      	ldr	r0, [sp, #4]
   38482:	f7f0 fdf7 	bl	29074 <nrf_freeaddrinfo>
	return retval;
   38486:	e7ea      	b.n	3845e <nrf91_socket_offload_getaddrinfo+0x68>
					k_malloc(sizeof(struct zsock_addrinfo));
   38488:	2040      	movs	r0, #64	; 0x40
   3848a:	f7f3 ff25 	bl	2c2d8 <k_malloc>
		if (next_z_res == NULL) {
   3848e:	4604      	mov	r4, r0
   38490:	2800      	cmp	r0, #0
   38492:	d07c      	beq.n	3858e <nrf91_socket_offload_getaddrinfo+0x198>
	family = nrf_to_z_family(nrf_in->ai_family);
   38494:	6872      	ldr	r2, [r6, #4]
	z_out->ai_socktype = nrf_in->ai_socktype;
   38496:	68b3      	ldr	r3, [r6, #8]
	switch (nrf_family) {
   38498:	2a05      	cmp	r2, #5
	z_out->ai_next = NULL;
   3849a:	f8c0 9000 	str.w	r9, [r0]
	z_out->ai_canonname = NULL; /* TODO Do proper content copy. */
   3849e:	f8c0 901c 	str.w	r9, [r0, #28]
	z_out->ai_flags = nrf_to_z_addrinfo_flags(nrf_in->ai_flags);
   384a2:	f8c0 9004 	str.w	r9, [r0, #4]
	z_out->ai_socktype = nrf_in->ai_socktype;
   384a6:	60c3      	str	r3, [r0, #12]
	switch (nrf_family) {
   384a8:	d033      	beq.n	38512 <nrf91_socket_offload_getaddrinfo+0x11c>
   384aa:	dc09      	bgt.n	384c0 <nrf91_socket_offload_getaddrinfo+0xca>
   384ac:	2a01      	cmp	r2, #1
   384ae:	d032      	beq.n	38516 <nrf91_socket_offload_getaddrinfo+0x120>
   384b0:	2a02      	cmp	r2, #2
   384b2:	d032      	beq.n	3851a <nrf91_socket_offload_getaddrinfo+0x124>
			k_free(next_z_res);
   384b4:	4620      	mov	r0, r4
   384b6:	f000 fbab 	bl	38c10 <k_free>
			retval = DNS_EAI_ADDRFAMILY;
   384ba:	f06f 0508 	mvn.w	r5, #8
   384be:	e068      	b.n	38592 <nrf91_socket_offload_getaddrinfo+0x19c>
	switch (nrf_family) {
   384c0:	2a0a      	cmp	r2, #10
   384c2:	d02c      	beq.n	3851e <nrf91_socket_offload_getaddrinfo+0x128>
   384c4:	2a66      	cmp	r2, #102	; 0x66
   384c6:	d1f5      	bne.n	384b4 <nrf91_socket_offload_getaddrinfo+0xbe>
		return AF_LTE;
   384c8:	4613      	mov	r3, r2
	z_out->ai_family = family;
   384ca:	60a3      	str	r3, [r4, #8]
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   384cc:	68f3      	ldr	r3, [r6, #12]
	switch (proto) {
   384ce:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
   384d2:	d045      	beq.n	38560 <nrf91_socket_offload_getaddrinfo+0x16a>
   384d4:	dc25      	bgt.n	38522 <nrf91_socket_offload_getaddrinfo+0x12c>
   384d6:	2b01      	cmp	r3, #1
   384d8:	d047      	beq.n	3856a <nrf91_socket_offload_getaddrinfo+0x174>
   384da:	2b02      	cmp	r3, #2
   384dc:	d043      	beq.n	38566 <nrf91_socket_offload_getaddrinfo+0x170>
   384de:	bb43      	cbnz	r3, 38532 <nrf91_socket_offload_getaddrinfo+0x13c>
	if (nrf_in->ai_family == NRF_AF_INET) {
   384e0:	2a02      	cmp	r2, #2
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   384e2:	6123      	str	r3, [r4, #16]
	if (nrf_in->ai_family == NRF_AF_INET) {
   384e4:	d143      	bne.n	3856e <nrf91_socket_offload_getaddrinfo+0x178>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in));
   384e6:	2008      	movs	r0, #8
   384e8:	f7f3 fef6 	bl	2c2d8 <k_malloc>
   384ec:	61a0      	str	r0, [r4, #24]
		if (z_out->ai_addr == NULL) {
   384ee:	2800      	cmp	r0, #0
   384f0:	d04a      	beq.n	38588 <nrf91_socket_offload_getaddrinfo+0x192>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in);
   384f2:	2308      	movs	r3, #8
   384f4:	6163      	str	r3, [r4, #20]
			(const struct nrf_sockaddr_in *)nrf_in->ai_addr);
   384f6:	6973      	ldr	r3, [r6, #20]
	ptr->sin_port = nrf_in->sin_port;
   384f8:	891a      	ldrh	r2, [r3, #8]
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   384fa:	68db      	ldr	r3, [r3, #12]
	ptr->sin_port = nrf_in->sin_port;
   384fc:	8042      	strh	r2, [r0, #2]
	ptr->sin_family = AF_INET;
   384fe:	2201      	movs	r2, #1
	ptr->sin_addr.s_addr = nrf_in->sin_addr.s_addr;
   38500:	6043      	str	r3, [r0, #4]
	ptr->sin_family = AF_INET;
   38502:	8002      	strh	r2, [r0, #0]
		if (latest_z_res == NULL) {
   38504:	f1b8 0f00 	cmp.w	r8, #0
   38508:	d149      	bne.n	3859e <nrf91_socket_offload_getaddrinfo+0x1a8>
			*res = next_z_res;
   3850a:	603c      	str	r4, [r7, #0]
		next_nrf_res = next_nrf_res->ai_next;
   3850c:	69f6      	ldr	r6, [r6, #28]
   3850e:	46a0      	mov	r8, r4
   38510:	e7b5      	b.n	3847e <nrf91_socket_offload_getaddrinfo+0x88>
		return AF_PACKET;
   38512:	2303      	movs	r3, #3
   38514:	e7d9      	b.n	384ca <nrf91_socket_offload_getaddrinfo+0xd4>
		return AF_LOCAL;
   38516:	2306      	movs	r3, #6
   38518:	e7d7      	b.n	384ca <nrf91_socket_offload_getaddrinfo+0xd4>
		return AF_INET;
   3851a:	2301      	movs	r3, #1
   3851c:	e7d5      	b.n	384ca <nrf91_socket_offload_getaddrinfo+0xd4>
		return AF_INET6;
   3851e:	2302      	movs	r3, #2
   38520:	e7d3      	b.n	384ca <nrf91_socket_offload_getaddrinfo+0xd4>
	switch (proto) {
   38522:	f240 2101 	movw	r1, #513	; 0x201
   38526:	428b      	cmp	r3, r1
   38528:	d0da      	beq.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   3852a:	dc0d      	bgt.n	38548 <nrf91_socket_offload_getaddrinfo+0x152>
   3852c:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   38530:	d013      	beq.n	3855a <nrf91_socket_offload_getaddrinfo+0x164>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   38532:	f06f 037a 	mvn.w	r3, #122	; 0x7a
   38536:	6123      	str	r3, [r4, #16]
		z_out->ai_addr = NULL;
   38538:	2300      	movs	r3, #0
   3853a:	61a3      	str	r3, [r4, #24]
			k_free(next_z_res);
   3853c:	4620      	mov	r0, r4
   3853e:	f000 fb67 	bl	38c10 <k_free>
			retval = DNS_EAI_SOCKTYPE;
   38542:	f06f 0506 	mvn.w	r5, #6
   38546:	e024      	b.n	38592 <nrf91_socket_offload_getaddrinfo+0x19c>
	switch (proto) {
   38548:	f240 2102 	movw	r1, #514	; 0x202
   3854c:	428b      	cmp	r3, r1
   3854e:	d0c7      	beq.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   38550:	f240 2103 	movw	r1, #515	; 0x203
   38554:	428b      	cmp	r3, r1
   38556:	d0c3      	beq.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   38558:	e7eb      	b.n	38532 <nrf91_socket_offload_getaddrinfo+0x13c>
	z_out->ai_protocol = nrf_to_z_protocol(nrf_in->ai_protocol);
   3855a:	f240 1311 	movw	r3, #273	; 0x111
   3855e:	e7bf      	b.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   38560:	f44f 7381 	mov.w	r3, #258	; 0x102
   38564:	e7bc      	b.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   38566:	2311      	movs	r3, #17
   38568:	e7ba      	b.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
   3856a:	2306      	movs	r3, #6
   3856c:	e7b8      	b.n	384e0 <nrf91_socket_offload_getaddrinfo+0xea>
	} else if (nrf_in->ai_family == NRF_AF_INET6) {
   3856e:	2a0a      	cmp	r2, #10
   38570:	d1e4      	bne.n	3853c <nrf91_socket_offload_getaddrinfo+0x146>
		z_out->ai_addr = k_malloc(sizeof(struct sockaddr_in6));
   38572:	2018      	movs	r0, #24
   38574:	f7f3 feb0 	bl	2c2d8 <k_malloc>
   38578:	61a0      	str	r0, [r4, #24]
		if (z_out->ai_addr == NULL) {
   3857a:	b128      	cbz	r0, 38588 <nrf91_socket_offload_getaddrinfo+0x192>
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   3857c:	2318      	movs	r3, #24
		nrf_to_z_ipv6(z_out->ai_addr,
   3857e:	6971      	ldr	r1, [r6, #20]
		z_out->ai_addrlen  = sizeof(struct sockaddr_in6);
   38580:	6163      	str	r3, [r4, #20]
		nrf_to_z_ipv6(z_out->ai_addr,
   38582:	f7ff fee1 	bl	38348 <nrf_to_z_ipv6>
		} else if (error == -EAFNOSUPPORT) {
   38586:	e7bd      	b.n	38504 <nrf91_socket_offload_getaddrinfo+0x10e>
			k_free(next_z_res);
   38588:	4620      	mov	r0, r4
   3858a:	f000 fb41 	bl	38c10 <k_free>
			retval = DNS_EAI_MEMORY;
   3858e:	f06f 0509 	mvn.w	r5, #9
		nrf91_socket_offload_freeaddrinfo(*res);
   38592:	6838      	ldr	r0, [r7, #0]
   38594:	f7ff fea6 	bl	382e4 <nrf91_socket_offload_freeaddrinfo>
		*res = NULL;
   38598:	2300      	movs	r3, #0
   3859a:	603b      	str	r3, [r7, #0]
   3859c:	e770      	b.n	38480 <nrf91_socket_offload_getaddrinfo+0x8a>
			latest_z_res->ai_next = next_z_res;
   3859e:	f8c8 4000 	str.w	r4, [r8]
   385a2:	e7b3      	b.n	3850c <nrf91_socket_offload_getaddrinfo+0x116>
			return DNS_EAI_SOCKTYPE;
   385a4:	f06f 0506 	mvn.w	r5, #6
   385a8:	e759      	b.n	3845e <nrf91_socket_offload_getaddrinfo+0x68>
			return DNS_EAI_ADDRFAMILY;
   385aa:	f06f 0508 	mvn.w	r5, #8
   385ae:	e756      	b.n	3845e <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_AGAIN;
   385b0:	f06f 0502 	mvn.w	r5, #2
   385b4:	e753      	b.n	3845e <nrf91_socket_offload_getaddrinfo+0x68>
		return DNS_EAI_NONAME;
   385b6:	f06f 0501 	mvn.w	r5, #1
   385ba:	e750      	b.n	3845e <nrf91_socket_offload_getaddrinfo+0x68>

000385bc <z_to_nrf_ipv6>:
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   385bc:	2224      	movs	r2, #36	; 0x24
{
   385be:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_out->sin6_len = sizeof(struct nrf_sockaddr_in6);
   385c0:	700a      	strb	r2, [r1, #0]
	nrf_out->sin6_port = ptr->sin6_port;
   385c2:	8842      	ldrh	r2, [r0, #2]
{
   385c4:	4604      	mov	r4, r0
	nrf_out->sin6_port = ptr->sin6_port;
   385c6:	810a      	strh	r2, [r1, #8]
	nrf_out->sin6_family = NRF_AF_INET6;
   385c8:	220a      	movs	r2, #10
{
   385ca:	460b      	mov	r3, r1
	nrf_out->sin6_family = NRF_AF_INET6;
   385cc:	604a      	str	r2, [r1, #4]
   385ce:	f101 0610 	add.w	r6, r1, #16
   385d2:	1d02      	adds	r2, r0, #4
   385d4:	f100 0714 	add.w	r7, r0, #20
   385d8:	4635      	mov	r5, r6
   385da:	6810      	ldr	r0, [r2, #0]
   385dc:	6851      	ldr	r1, [r2, #4]
   385de:	3208      	adds	r2, #8
   385e0:	c503      	stmia	r5!, {r0, r1}
   385e2:	42ba      	cmp	r2, r7
   385e4:	462e      	mov	r6, r5
   385e6:	d1f7      	bne.n	385d8 <z_to_nrf_ipv6+0x1c>
	nrf_out->sin6_scope_id = (u32_t)ptr->sin6_scope_id;
   385e8:	7d22      	ldrb	r2, [r4, #20]
   385ea:	621a      	str	r2, [r3, #32]
}
   385ec:	bdf0      	pop	{r4, r5, r6, r7, pc}

000385ee <nrf91_socket_offload_sendto>:
{
   385ee:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   385f2:	b08d      	sub	sp, #52	; 0x34
   385f4:	9c14      	ldr	r4, [sp, #80]	; 0x50
   385f6:	460e      	mov	r6, r1
   385f8:	4617      	mov	r7, r2
   385fa:	4698      	mov	r8, r3
	int sd = OBJ_TO_SD(obj);
   385fc:	1e45      	subs	r5, r0, #1
	if (to == NULL) {
   385fe:	b96c      	cbnz	r4, 3861c <nrf91_socket_offload_sendto+0x2e>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), NULL,
   38600:	4618      	mov	r0, r3
   38602:	f7ff fdbc 	bl	3817e <z_to_nrf_flags>
   38606:	e9cd 4400 	strd	r4, r4, [sp]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   3860a:	4603      	mov	r3, r0
   3860c:	463a      	mov	r2, r7
   3860e:	4631      	mov	r1, r6
   38610:	4628      	mov	r0, r5
   38612:	f7f0 fc73 	bl	28efc <nrf_sendto>
}
   38616:	b00d      	add	sp, #52	; 0x34
   38618:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	} else if (to->sa_family == AF_INET) {
   3861c:	8823      	ldrh	r3, [r4, #0]
   3861e:	2b01      	cmp	r3, #1
   38620:	d112      	bne.n	38648 <nrf91_socket_offload_sendto+0x5a>
	nrf_out->sin_port = ptr->sin_port;
   38622:	8863      	ldrh	r3, [r4, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   38624:	f04f 0910 	mov.w	r9, #16
	nrf_out->sin_port = ptr->sin_port;
   38628:	f8ad 3014 	strh.w	r3, [sp, #20]
	nrf_out->sin_family = NRF_AF_INET;
   3862c:	2302      	movs	r3, #2
   3862e:	9304      	str	r3, [sp, #16]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   38630:	6863      	ldr	r3, [r4, #4]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   38632:	4640      	mov	r0, r8
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   38634:	9306      	str	r3, [sp, #24]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   38636:	f88d 900c 	strb.w	r9, [sp, #12]
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv4,
   3863a:	f7ff fda0 	bl	3817e <z_to_nrf_flags>
   3863e:	ab03      	add	r3, sp, #12
   38640:	f8cd 9004 	str.w	r9, [sp, #4]
   38644:	9300      	str	r3, [sp, #0]
   38646:	e7e0      	b.n	3860a <nrf91_socket_offload_sendto+0x1c>
	} else if (to->sa_family == AF_INET6) {
   38648:	2b02      	cmp	r3, #2
   3864a:	d10c      	bne.n	38666 <nrf91_socket_offload_sendto+0x78>
		z_to_nrf_ipv6(to, &ipv6);
   3864c:	f10d 090c 	add.w	r9, sp, #12
   38650:	4649      	mov	r1, r9
   38652:	4620      	mov	r0, r4
   38654:	f7ff ffb2 	bl	385bc <z_to_nrf_ipv6>
		retval = nrf_sendto(sd, buf, len, z_to_nrf_flags(flags), &ipv6,
   38658:	4640      	mov	r0, r8
   3865a:	f7ff fd90 	bl	3817e <z_to_nrf_flags>
   3865e:	2324      	movs	r3, #36	; 0x24
   38660:	e9cd 9300 	strd	r9, r3, [sp]
   38664:	e7d1      	b.n	3860a <nrf91_socket_offload_sendto+0x1c>
	errno = ENOTSUP;
   38666:	f7fc ff3f 	bl	354e8 <__errno>
   3866a:	2386      	movs	r3, #134	; 0x86
   3866c:	6003      	str	r3, [r0, #0]
	return retval;
   3866e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   38672:	e7d0      	b.n	38616 <nrf91_socket_offload_sendto+0x28>

00038674 <nrf91_socket_offload_write>:
	return nrf91_socket_offload_sendto(obj, buffer, count, 0, NULL, 0);
   38674:	2300      	movs	r3, #0
{
   38676:	b507      	push	{r0, r1, r2, lr}
	return nrf91_socket_offload_sendto(obj, buffer, count, 0, NULL, 0);
   38678:	e9cd 3300 	strd	r3, r3, [sp]
   3867c:	f7ff ffb7 	bl	385ee <nrf91_socket_offload_sendto>
}
   38680:	b003      	add	sp, #12
   38682:	f85d fb04 	ldr.w	pc, [sp], #4

00038686 <nrf91_socket_offload_connect>:
{
   38686:	b510      	push	{r4, lr}
	int sd = OBJ_TO_SD(obj);
   38688:	1e44      	subs	r4, r0, #1
	if (addr->sa_family == AF_INET) {
   3868a:	8808      	ldrh	r0, [r1, #0]
{
   3868c:	b08a      	sub	sp, #40	; 0x28
	if (addr->sa_family == AF_INET) {
   3868e:	2801      	cmp	r0, #1
{
   38690:	460b      	mov	r3, r1
	if (addr->sa_family == AF_INET) {
   38692:	d10f      	bne.n	386b4 <nrf91_socket_offload_connect+0x2e>
	nrf_out->sin_port = ptr->sin_port;
   38694:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   38696:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   38698:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   3869c:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   3869e:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   386a0:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_family = NRF_AF_INET;
   386a4:	9102      	str	r1, [sp, #8]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   386a6:	9304      	str	r3, [sp, #16]
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   386a8:	a901      	add	r1, sp, #4
   386aa:	4620      	mov	r0, r4
   386ac:	f7f0 fc5e 	bl	28f6c <nrf_connect>
}
   386b0:	b00a      	add	sp, #40	; 0x28
   386b2:	bd10      	pop	{r4, pc}
	} else if (addr->sa_family == AF_INET6) {
   386b4:	2802      	cmp	r0, #2
   386b6:	d105      	bne.n	386c4 <nrf91_socket_offload_connect+0x3e>
		z_to_nrf_ipv6(addr, &ipv6);
   386b8:	a901      	add	r1, sp, #4
   386ba:	4618      	mov	r0, r3
   386bc:	f7ff ff7e 	bl	385bc <z_to_nrf_ipv6>
		retval = nrf_connect(sd, (const struct nrf_sockaddr *)&ipv6,
   386c0:	2224      	movs	r2, #36	; 0x24
   386c2:	e7f1      	b.n	386a8 <nrf91_socket_offload_connect+0x22>
		retval = nrf_connect(sd, (void *)addr, addrlen);
   386c4:	4620      	mov	r0, r4
   386c6:	f7f0 fc51 	bl	28f6c <nrf_connect>
		if (retval < 0) {
   386ca:	2800      	cmp	r0, #0
   386cc:	daf0      	bge.n	386b0 <nrf91_socket_offload_connect+0x2a>
	errno = ENOTSUP;
   386ce:	f7fc ff0b 	bl	354e8 <__errno>
   386d2:	2386      	movs	r3, #134	; 0x86
   386d4:	6003      	str	r3, [r0, #0]
   386d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   386da:	e7e9      	b.n	386b0 <nrf91_socket_offload_connect+0x2a>

000386dc <nrf91_socket_offload_setsockopt>:
{
   386dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	switch (z_in_level) {
   386e0:	f5b1 7f8d 	cmp.w	r1, #282	; 0x11a
{
   386e4:	b086      	sub	sp, #24
   386e6:	460c      	mov	r4, r1
   386e8:	4615      	mov	r5, r2
   386ea:	461e      	mov	r6, r3
   386ec:	9f0c      	ldr	r7, [sp, #48]	; 0x30
	int sd = OBJ_TO_SD(obj);
   386ee:	f100 38ff 	add.w	r8, r0, #4294967295	; 0xffffffff
	switch (z_in_level) {
   386f2:	d002      	beq.n	386fa <nrf91_socket_offload_setsockopt+0x1e>
   386f4:	dc1d      	bgt.n	38732 <nrf91_socket_offload_setsockopt+0x56>
   386f6:	2901      	cmp	r1, #1
   386f8:	d12a      	bne.n	38750 <nrf91_socket_offload_setsockopt+0x74>
	if (z_to_nrf_optname(level, optname, &nrf_optname) < 0)
   386fa:	aa03      	add	r2, sp, #12
   386fc:	4629      	mov	r1, r5
   386fe:	4620      	mov	r0, r4
   38700:	f7e7 fddc 	bl	202bc <z_to_nrf_optname>
   38704:	2800      	cmp	r0, #0
   38706:	db23      	blt.n	38750 <nrf91_socket_offload_setsockopt+0x74>
	if ((level == SOL_SOCKET) && ((optname == SO_RCVTIMEO) ||
   38708:	2c01      	cmp	r4, #1
   3870a:	d11a      	bne.n	38742 <nrf91_socket_offload_setsockopt+0x66>
   3870c:	3d14      	subs	r5, #20
   3870e:	2d01      	cmp	r5, #1
   38710:	d805      	bhi.n	3871e <nrf91_socket_offload_setsockopt+0x42>
		nrf_optlen = sizeof(struct nrf_timeval);
   38712:	2708      	movs	r7, #8
		nrf_timeo.tv_sec = ((struct timeval *)optval)->tv_sec;
   38714:	6833      	ldr	r3, [r6, #0]
   38716:	9304      	str	r3, [sp, #16]
		nrf_timeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   38718:	6873      	ldr	r3, [r6, #4]
		nrf_optval = &nrf_timeo;
   3871a:	ae04      	add	r6, sp, #16
		nrf_timeo.tv_usec = ((struct timeval *)optval)->tv_usec;
   3871c:	9305      	str	r3, [sp, #20]
	retval = nrf_setsockopt(sd, nrf_level, nrf_optname, nrf_optval,
   3871e:	9700      	str	r7, [sp, #0]
   38720:	4633      	mov	r3, r6
   38722:	9a03      	ldr	r2, [sp, #12]
   38724:	4621      	mov	r1, r4
   38726:	4640      	mov	r0, r8
   38728:	f7f0 fc6a 	bl	29000 <nrf_setsockopt>
}
   3872c:	b006      	add	sp, #24
   3872e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (z_in_level) {
   38732:	f240 2302 	movw	r3, #514	; 0x202
   38736:	4299      	cmp	r1, r3
   38738:	d0df      	beq.n	386fa <nrf91_socket_offload_setsockopt+0x1e>
   3873a:	f240 2303 	movw	r3, #515	; 0x203
   3873e:	4299      	cmp	r1, r3
   38740:	e7da      	b.n	386f8 <nrf91_socket_offload_setsockopt+0x1c>
	} else if ((level == SOL_TLS) && (optname == TLS_SESSION_CACHE)) {
   38742:	f5b4 7f8d 	cmp.w	r4, #282	; 0x11a
   38746:	d1ea      	bne.n	3871e <nrf91_socket_offload_setsockopt+0x42>
		nrf_optlen = sizeof(nrf_sec_session_cache_t);
   38748:	2d07      	cmp	r5, #7
   3874a:	bf08      	it	eq
   3874c:	2701      	moveq	r7, #1
   3874e:	e7e6      	b.n	3871e <nrf91_socket_offload_setsockopt+0x42>
	errno = ENOPROTOOPT;
   38750:	f7fc feca 	bl	354e8 <__errno>
   38754:	236d      	movs	r3, #109	; 0x6d
   38756:	6003      	str	r3, [r0, #0]
   38758:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3875c:	e7e6      	b.n	3872c <nrf91_socket_offload_setsockopt+0x50>

0003875e <nrf91_socket_offload_bind>:
{
   3875e:	b510      	push	{r4, lr}
	if (addr->sa_family == AF_INET) {
   38760:	880a      	ldrh	r2, [r1, #0]
{
   38762:	b08a      	sub	sp, #40	; 0x28
	if (addr->sa_family == AF_INET) {
   38764:	2a01      	cmp	r2, #1
{
   38766:	460b      	mov	r3, r1
	int sd = OBJ_TO_SD(obj);
   38768:	f100 34ff 	add.w	r4, r0, #4294967295	; 0xffffffff
	if (addr->sa_family == AF_INET) {
   3876c:	d10f      	bne.n	3878e <nrf91_socket_offload_bind+0x30>
	nrf_out->sin_port = ptr->sin_port;
   3876e:	8849      	ldrh	r1, [r1, #2]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   38770:	2210      	movs	r2, #16
	nrf_out->sin_port = ptr->sin_port;
   38772:	f8ad 100c 	strh.w	r1, [sp, #12]
	nrf_out->sin_family = NRF_AF_INET;
   38776:	2102      	movs	r1, #2
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   38778:	685b      	ldr	r3, [r3, #4]
	nrf_out->sin_len = sizeof(struct nrf_sockaddr_in);
   3877a:	f88d 2004 	strb.w	r2, [sp, #4]
	nrf_out->sin_family = NRF_AF_INET;
   3877e:	9102      	str	r1, [sp, #8]
	nrf_out->sin_addr.s_addr = ptr->sin_addr.s_addr;
   38780:	9304      	str	r3, [sp, #16]
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   38782:	a901      	add	r1, sp, #4
   38784:	4620      	mov	r0, r4
   38786:	f7f0 fc29 	bl	28fdc <nrf_bind>
}
   3878a:	b00a      	add	sp, #40	; 0x28
   3878c:	bd10      	pop	{r4, pc}
	} else if (addr->sa_family == AF_INET6) {
   3878e:	2a02      	cmp	r2, #2
   38790:	d105      	bne.n	3879e <nrf91_socket_offload_bind+0x40>
		z_to_nrf_ipv6(addr, &ipv6);
   38792:	a901      	add	r1, sp, #4
   38794:	4618      	mov	r0, r3
   38796:	f7ff ff11 	bl	385bc <z_to_nrf_ipv6>
		retval = nrf_bind(sd, (const struct nrf_sockaddr *)&ipv6,
   3879a:	2224      	movs	r2, #36	; 0x24
   3879c:	e7f1      	b.n	38782 <nrf91_socket_offload_bind+0x24>
	errno = ENOTSUP;
   3879e:	f7fc fea3 	bl	354e8 <__errno>
   387a2:	2386      	movs	r3, #134	; 0x86
   387a4:	6003      	str	r3, [r0, #0]
   387a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   387aa:	e7ee      	b.n	3878a <nrf91_socket_offload_bind+0x2c>

000387ac <is_lfcr>:
	if ((chr == '\r') || (chr == '\n')) {
   387ac:	280d      	cmp	r0, #13
   387ae:	d004      	beq.n	387ba <is_lfcr+0xe>
   387b0:	f1a0 030a 	sub.w	r3, r0, #10
   387b4:	4258      	negs	r0, r3
   387b6:	4158      	adcs	r0, r3
   387b8:	4770      	bx	lr
		return true;
   387ba:	2001      	movs	r0, #1
}
   387bc:	4770      	bx	lr

000387be <skip_command_prefix>:
{
   387be:	b510      	push	{r4, lr}
	*cmd += sizeof("AT") - 1;
   387c0:	6802      	ldr	r2, [r0, #0]
{
   387c2:	4601      	mov	r1, r0
	*cmd += sizeof("AT") - 1;
   387c4:	1c93      	adds	r3, r2, #2
   387c6:	6003      	str	r3, [r0, #0]
	if (is_lfcr(**cmd) || is_terminated(**cmd)) {
   387c8:	7894      	ldrb	r4, [r2, #2]
   387ca:	4620      	mov	r0, r4
   387cc:	f7ff ffee 	bl	387ac <is_lfcr>
   387d0:	b910      	cbnz	r0, 387d8 <skip_command_prefix+0x1a>
	if (chr == AT_CMD_BUFFER_TERMINATOR) {
   387d2:	b10c      	cbz	r4, 387d8 <skip_command_prefix+0x1a>
	(*cmd)++;
   387d4:	3203      	adds	r2, #3
   387d6:	600a      	str	r2, [r1, #0]
}
   387d8:	bd10      	pop	{r4, pc}

000387da <at_parser_params_from_str>:
	return at_parser_max_params_from_str(at_params_str, next_params_str,
   387da:	6813      	ldr	r3, [r2, #0]
   387dc:	f7e8 bbfc 	b.w	20fd8 <at_parser_max_params_from_str>

000387e0 <at_params_list_init>:
{
   387e0:	b538      	push	{r3, r4, r5, lr}
   387e2:	460d      	mov	r5, r1
	if (list == NULL) {
   387e4:	4604      	mov	r4, r0
   387e6:	b140      	cbz	r0, 387fa <at_params_list_init+0x1a>
	list->params = k_calloc(max_params_count, sizeof(struct at_param));
   387e8:	210c      	movs	r1, #12
   387ea:	4628      	mov	r0, r5
   387ec:	f000 fa15 	bl	38c1a <k_calloc>
   387f0:	6060      	str	r0, [r4, #4]
	if (list->params == NULL) {
   387f2:	b128      	cbz	r0, 38800 <at_params_list_init+0x20>
	return 0;
   387f4:	2000      	movs	r0, #0
	list->param_count = max_params_count;
   387f6:	6025      	str	r5, [r4, #0]
}
   387f8:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   387fa:	f06f 0015 	mvn.w	r0, #21
   387fe:	e7fb      	b.n	387f8 <at_params_list_init+0x18>
		return -ENOMEM;
   38800:	f06f 000b 	mvn.w	r0, #11
   38804:	e7f8      	b.n	387f8 <at_params_list_init+0x18>

00038806 <at_params_list_free>:

void at_params_list_free(struct at_param_list *list)
{
   38806:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   38808:	4604      	mov	r4, r0
   3880a:	b148      	cbz	r0, 38820 <at_params_list_free+0x1a>
   3880c:	6843      	ldr	r3, [r0, #4]
   3880e:	b13b      	cbz	r3, 38820 <at_params_list_free+0x1a>
		return;
	}

	at_params_list_clear(list);

	list->param_count = 0;
   38810:	2500      	movs	r5, #0
	at_params_list_clear(list);
   38812:	f7e8 fcdd 	bl	211d0 <at_params_list_clear>
	list->param_count = 0;
   38816:	6025      	str	r5, [r4, #0]
	k_free(list->params);
   38818:	6860      	ldr	r0, [r4, #4]
   3881a:	f000 f9f9 	bl	38c10 <k_free>
	list->params = NULL;
   3881e:	6065      	str	r5, [r4, #4]
}
   38820:	bd38      	pop	{r3, r4, r5, pc}

00038822 <at_params_short_put>:

int at_params_short_put(const struct at_param_list *list, size_t index,
			u16_t value)
{
   38822:	b538      	push	{r3, r4, r5, lr}
   38824:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   38826:	b910      	cbnz	r0, 3882e <at_params_short_put+0xc>
		return -EINVAL;
   38828:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_SHORT;
	param->value.int_val = (u32_t)(value & USHRT_MAX);
	return 0;
}
   3882c:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   3882e:	6843      	ldr	r3, [r0, #4]
   38830:	2b00      	cmp	r3, #0
   38832:	d0f9      	beq.n	38828 <at_params_short_put+0x6>
	struct at_param *param = at_params_get(list, index);
   38834:	f7e8 fc60 	bl	210f8 <at_params_get>
	if (param == NULL) {
   38838:	4604      	mov	r4, r0
   3883a:	2800      	cmp	r0, #0
   3883c:	d0f4      	beq.n	38828 <at_params_short_put+0x6>
	at_param_clear(param);
   3883e:	f7e8 fca5 	bl	2118c <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   38842:	2301      	movs	r3, #1
	param->value.int_val = (u32_t)(value & USHRT_MAX);
   38844:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_SHORT;
   38846:	7023      	strb	r3, [r4, #0]
	return 0;
   38848:	2000      	movs	r0, #0
   3884a:	e7ef      	b.n	3882c <at_params_short_put+0xa>

0003884c <at_params_empty_put>:

int at_params_empty_put(const struct at_param_list *list, size_t index)
{
   3884c:	b510      	push	{r4, lr}
	if (list == NULL || list->params == NULL) {
   3884e:	b910      	cbnz	r0, 38856 <at_params_empty_put+0xa>
		return -EINVAL;
   38850:	f06f 0015 	mvn.w	r0, #21

	param->type = AT_PARAM_TYPE_EMPTY;
	param->value.int_val = 0;

	return 0;
}
   38854:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL) {
   38856:	6843      	ldr	r3, [r0, #4]
   38858:	2b00      	cmp	r3, #0
   3885a:	d0f9      	beq.n	38850 <at_params_empty_put+0x4>
	struct at_param *param = at_params_get(list, index);
   3885c:	f7e8 fc4c 	bl	210f8 <at_params_get>
	if (param == NULL) {
   38860:	4604      	mov	r4, r0
   38862:	2800      	cmp	r0, #0
   38864:	d0f4      	beq.n	38850 <at_params_empty_put+0x4>
	at_param_clear(param);
   38866:	f7e8 fc91 	bl	2118c <at_param_clear>
	param->type = AT_PARAM_TYPE_EMPTY;
   3886a:	2305      	movs	r3, #5
	param->value.int_val = 0;
   3886c:	2000      	movs	r0, #0
	param->type = AT_PARAM_TYPE_EMPTY;
   3886e:	7023      	strb	r3, [r4, #0]
	param->value.int_val = 0;
   38870:	60a0      	str	r0, [r4, #8]
	return 0;
   38872:	e7ef      	b.n	38854 <at_params_empty_put+0x8>

00038874 <at_params_int_put>:

int at_params_int_put(const struct at_param_list *list, size_t index,
		      u32_t value)
{
   38874:	b538      	push	{r3, r4, r5, lr}
   38876:	4615      	mov	r5, r2
	if (list == NULL || list->params == NULL) {
   38878:	b910      	cbnz	r0, 38880 <at_params_int_put+0xc>
		return -EINVAL;
   3887a:	f06f 0015 	mvn.w	r0, #21
	at_param_clear(param);

	param->type = AT_PARAM_TYPE_NUM_INT;
	param->value.int_val = value;
	return 0;
}
   3887e:	bd38      	pop	{r3, r4, r5, pc}
	if (list == NULL || list->params == NULL) {
   38880:	6843      	ldr	r3, [r0, #4]
   38882:	2b00      	cmp	r3, #0
   38884:	d0f9      	beq.n	3887a <at_params_int_put+0x6>
	struct at_param *param = at_params_get(list, index);
   38886:	f7e8 fc37 	bl	210f8 <at_params_get>
	if (param == NULL) {
   3888a:	4604      	mov	r4, r0
   3888c:	2800      	cmp	r0, #0
   3888e:	d0f4      	beq.n	3887a <at_params_int_put+0x6>
	at_param_clear(param);
   38890:	f7e8 fc7c 	bl	2118c <at_param_clear>
	param->type = AT_PARAM_TYPE_NUM_INT;
   38894:	2302      	movs	r3, #2
	param->value.int_val = value;
   38896:	60a5      	str	r5, [r4, #8]
	param->type = AT_PARAM_TYPE_NUM_INT;
   38898:	7023      	strb	r3, [r4, #0]
	return 0;
   3889a:	2000      	movs	r0, #0
   3889c:	e7ef      	b.n	3887e <at_params_int_put+0xa>

0003889e <at_params_string_put>:

int at_params_string_put(const struct at_param_list *list, size_t index,
			 const char *str, size_t str_len)
{
   3889e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   388a0:	4616      	mov	r6, r2
   388a2:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || str == NULL) {
   388a4:	b910      	cbnz	r0, 388ac <at_params_string_put+0xe>
		return -EINVAL;
   388a6:	f06f 0015 	mvn.w	r0, #21
	param->size = str_len;
	param->type = AT_PARAM_TYPE_STRING;
	param->value.str_val = param_value;

	return 0;
}
   388aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || str == NULL) {
   388ac:	6843      	ldr	r3, [r0, #4]
   388ae:	2b00      	cmp	r3, #0
   388b0:	d0f9      	beq.n	388a6 <at_params_string_put+0x8>
   388b2:	2a00      	cmp	r2, #0
   388b4:	d0f7      	beq.n	388a6 <at_params_string_put+0x8>
	struct at_param *param = at_params_get(list, index);
   388b6:	f7e8 fc1f 	bl	210f8 <at_params_get>
	if (param == NULL) {
   388ba:	4604      	mov	r4, r0
   388bc:	2800      	cmp	r0, #0
   388be:	d0f2      	beq.n	388a6 <at_params_string_put+0x8>
	char *param_value = (char *)k_malloc(str_len + 1);
   388c0:	1c68      	adds	r0, r5, #1
   388c2:	f7f3 fd09 	bl	2c2d8 <k_malloc>
	if (param_value == NULL) {
   388c6:	4607      	mov	r7, r0
   388c8:	b160      	cbz	r0, 388e4 <at_params_string_put+0x46>
   388ca:	462a      	mov	r2, r5
   388cc:	4631      	mov	r1, r6
   388ce:	f000 fb83 	bl	38fd8 <memcpy>
	at_param_clear(param);
   388d2:	4620      	mov	r0, r4
   388d4:	f7e8 fc5a 	bl	2118c <at_param_clear>
	param->type = AT_PARAM_TYPE_STRING;
   388d8:	2303      	movs	r3, #3
	param->size = str_len;
   388da:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_STRING;
   388dc:	7023      	strb	r3, [r4, #0]
	param->value.str_val = param_value;
   388de:	60a7      	str	r7, [r4, #8]
	return 0;
   388e0:	2000      	movs	r0, #0
   388e2:	e7e2      	b.n	388aa <at_params_string_put+0xc>
		return -ENOMEM;
   388e4:	f06f 000b 	mvn.w	r0, #11
   388e8:	e7df      	b.n	388aa <at_params_string_put+0xc>

000388ea <at_params_array_put>:

int at_params_array_put(const struct at_param_list *list, size_t index,
			const u32_t *array, size_t array_len)
{
   388ea:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   388ec:	4616      	mov	r6, r2
   388ee:	461d      	mov	r5, r3
	if (list == NULL || list->params == NULL || array == NULL) {
   388f0:	b910      	cbnz	r0, 388f8 <at_params_array_put+0xe>
		return -EINVAL;
   388f2:	f06f 0015 	mvn.w	r0, #21
	param->size = array_len;
	param->type = AT_PARAM_TYPE_ARRAY;
	param->value.array_val = param_value;

	return 0;
}
   388f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || array == NULL) {
   388f8:	6843      	ldr	r3, [r0, #4]
   388fa:	2b00      	cmp	r3, #0
   388fc:	d0f9      	beq.n	388f2 <at_params_array_put+0x8>
   388fe:	2a00      	cmp	r2, #0
   38900:	d0f7      	beq.n	388f2 <at_params_array_put+0x8>
	struct at_param *param = at_params_get(list, index);
   38902:	f7e8 fbf9 	bl	210f8 <at_params_get>
	if (param == NULL) {
   38906:	4604      	mov	r4, r0
   38908:	2800      	cmp	r0, #0
   3890a:	d0f2      	beq.n	388f2 <at_params_array_put+0x8>
	u32_t *param_value = (u32_t *)k_malloc(array_len);
   3890c:	4628      	mov	r0, r5
   3890e:	f7f3 fce3 	bl	2c2d8 <k_malloc>
	if (param_value == NULL) {
   38912:	4607      	mov	r7, r0
   38914:	b160      	cbz	r0, 38930 <at_params_array_put+0x46>
   38916:	462a      	mov	r2, r5
   38918:	4631      	mov	r1, r6
   3891a:	f000 fb5d 	bl	38fd8 <memcpy>
	at_param_clear(param);
   3891e:	4620      	mov	r0, r4
   38920:	f7e8 fc34 	bl	2118c <at_param_clear>
	param->type = AT_PARAM_TYPE_ARRAY;
   38924:	2304      	movs	r3, #4
	param->size = array_len;
   38926:	6065      	str	r5, [r4, #4]
	param->type = AT_PARAM_TYPE_ARRAY;
   38928:	7023      	strb	r3, [r4, #0]
	param->value.array_val = param_value;
   3892a:	60a7      	str	r7, [r4, #8]
	return 0;
   3892c:	2000      	movs	r0, #0
   3892e:	e7e2      	b.n	388f6 <at_params_array_put+0xc>
		return -ENOMEM;
   38930:	f06f 000b 	mvn.w	r0, #11
   38934:	e7df      	b.n	388f6 <at_params_array_put+0xc>

00038936 <at_params_short_get>:
	return 0;
}

int at_params_short_get(const struct at_param_list *list, size_t index,
			u16_t *value)
{
   38936:	b510      	push	{r4, lr}
   38938:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   3893a:	b910      	cbnz	r0, 38942 <at_params_short_get+0xc>
		return -EINVAL;
   3893c:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = (u16_t)param->value.int_val;
	return 0;
}
   38940:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   38942:	6843      	ldr	r3, [r0, #4]
   38944:	2b00      	cmp	r3, #0
   38946:	d0f9      	beq.n	3893c <at_params_short_get+0x6>
   38948:	2a00      	cmp	r2, #0
   3894a:	d0f7      	beq.n	3893c <at_params_short_get+0x6>
	struct at_param *param = at_params_get(list, index);
   3894c:	f7e8 fbd4 	bl	210f8 <at_params_get>
	if (param == NULL) {
   38950:	2800      	cmp	r0, #0
   38952:	d0f3      	beq.n	3893c <at_params_short_get+0x6>
	if (param->type != AT_PARAM_TYPE_NUM_SHORT) {
   38954:	7803      	ldrb	r3, [r0, #0]
   38956:	2b01      	cmp	r3, #1
   38958:	d1f0      	bne.n	3893c <at_params_short_get+0x6>
	*value = (u16_t)param->value.int_val;
   3895a:	6883      	ldr	r3, [r0, #8]
	return 0;
   3895c:	2000      	movs	r0, #0
	*value = (u16_t)param->value.int_val;
   3895e:	8023      	strh	r3, [r4, #0]
	return 0;
   38960:	e7ee      	b.n	38940 <at_params_short_get+0xa>

00038962 <at_params_int_get>:

int at_params_int_get(const struct at_param_list *list, size_t index,
		      u32_t *value)
{
   38962:	b510      	push	{r4, lr}
   38964:	4614      	mov	r4, r2
	if (list == NULL || list->params == NULL || value == NULL) {
   38966:	b910      	cbnz	r0, 3896e <at_params_int_get+0xc>
		return -EINVAL;
   38968:	f06f 0015 	mvn.w	r0, #21
		return -EINVAL;
	}

	*value = param->value.int_val;
	return 0;
}
   3896c:	bd10      	pop	{r4, pc}
	if (list == NULL || list->params == NULL || value == NULL) {
   3896e:	6843      	ldr	r3, [r0, #4]
   38970:	2b00      	cmp	r3, #0
   38972:	d0f9      	beq.n	38968 <at_params_int_get+0x6>
   38974:	2a00      	cmp	r2, #0
   38976:	d0f7      	beq.n	38968 <at_params_int_get+0x6>
	struct at_param *param = at_params_get(list, index);
   38978:	f7e8 fbbe 	bl	210f8 <at_params_get>
	if (param == NULL) {
   3897c:	2800      	cmp	r0, #0
   3897e:	d0f3      	beq.n	38968 <at_params_int_get+0x6>
	if ((param->type != AT_PARAM_TYPE_NUM_INT) &&
   38980:	7803      	ldrb	r3, [r0, #0]
   38982:	3b01      	subs	r3, #1
   38984:	2b01      	cmp	r3, #1
   38986:	d8ef      	bhi.n	38968 <at_params_int_get+0x6>
	*value = param->value.int_val;
   38988:	6883      	ldr	r3, [r0, #8]
	return 0;
   3898a:	2000      	movs	r0, #0
	*value = param->value.int_val;
   3898c:	6023      	str	r3, [r4, #0]
	return 0;
   3898e:	e7ed      	b.n	3896c <at_params_int_get+0xa>

00038990 <at_params_string_get>:

int at_params_string_get(const struct at_param_list *list, size_t index,
			 char *value, size_t *len)
{
   38990:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   38992:	4616      	mov	r6, r2
   38994:	461c      	mov	r4, r3
	if (list == NULL || list->params == NULL || value == NULL ||
   38996:	b910      	cbnz	r0, 3899e <at_params_string_get+0xe>
	    value == NULL || len == NULL) {
		return -EINVAL;
   38998:	f06f 0015 	mvn.w	r0, #21

	memcpy(value, param->value.str_val, param_len);
	*len = param_len;

	return 0;
}
   3899c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (list == NULL || list->params == NULL || value == NULL ||
   3899e:	6843      	ldr	r3, [r0, #4]
   389a0:	2b00      	cmp	r3, #0
   389a2:	d0f9      	beq.n	38998 <at_params_string_get+0x8>
   389a4:	2a00      	cmp	r2, #0
   389a6:	d0f7      	beq.n	38998 <at_params_string_get+0x8>
	    value == NULL || len == NULL) {
   389a8:	2c00      	cmp	r4, #0
   389aa:	d0f5      	beq.n	38998 <at_params_string_get+0x8>
	struct at_param *param = at_params_get(list, index);
   389ac:	f7e8 fba4 	bl	210f8 <at_params_get>
	if (param == NULL) {
   389b0:	4607      	mov	r7, r0
   389b2:	2800      	cmp	r0, #0
   389b4:	d0f0      	beq.n	38998 <at_params_string_get+0x8>
	if (param->type != AT_PARAM_TYPE_STRING) {
   389b6:	7803      	ldrb	r3, [r0, #0]
   389b8:	2b03      	cmp	r3, #3
   389ba:	d1ed      	bne.n	38998 <at_params_string_get+0x8>
	size_t param_len = at_param_size(param);
   389bc:	f7e8 fbbe 	bl	2113c <at_param_size>
	if (*len < param_len) {
   389c0:	6823      	ldr	r3, [r4, #0]
	size_t param_len = at_param_size(param);
   389c2:	4605      	mov	r5, r0
	if (*len < param_len) {
   389c4:	4283      	cmp	r3, r0
   389c6:	d307      	bcc.n	389d8 <at_params_string_get+0x48>
   389c8:	4602      	mov	r2, r0
   389ca:	68b9      	ldr	r1, [r7, #8]
   389cc:	4630      	mov	r0, r6
   389ce:	f000 fb03 	bl	38fd8 <memcpy>
	*len = param_len;
   389d2:	6025      	str	r5, [r4, #0]
	return 0;
   389d4:	2000      	movs	r0, #0
   389d6:	e7e1      	b.n	3899c <at_params_string_get+0xc>
		return -ENOMEM;
   389d8:	f06f 000b 	mvn.w	r0, #11
   389dc:	e7de      	b.n	3899c <at_params_string_get+0xc>

000389de <at_params_valid_count_get>:

	return 0;
}

u32_t at_params_valid_count_get(const struct at_param_list *list)
{
   389de:	b538      	push	{r3, r4, r5, lr}
	if (list == NULL || list->params == NULL) {
   389e0:	4605      	mov	r5, r0
   389e2:	b180      	cbz	r0, 38a06 <at_params_valid_count_get+0x28>
   389e4:	6843      	ldr	r3, [r0, #4]
   389e6:	b173      	cbz	r3, 38a06 <at_params_valid_count_get+0x28>
		return -EINVAL;
	}

	size_t valid_i = 0;
	struct at_param *param = at_params_get(list, valid_i);
   389e8:	2100      	movs	r1, #0
   389ea:	f7e8 fb85 	bl	210f8 <at_params_get>
	size_t valid_i = 0;
   389ee:	2400      	movs	r4, #0

	while (param != NULL && param->type != AT_PARAM_TYPE_INVALID) {
   389f0:	b108      	cbz	r0, 389f6 <at_params_valid_count_get+0x18>
   389f2:	7803      	ldrb	r3, [r0, #0]
   389f4:	b90b      	cbnz	r3, 389fa <at_params_valid_count_get+0x1c>
		valid_i += 1;
		param = at_params_get(list, valid_i);
	}

	return valid_i;
}
   389f6:	4620      	mov	r0, r4
   389f8:	bd38      	pop	{r3, r4, r5, pc}
		valid_i += 1;
   389fa:	3401      	adds	r4, #1
		param = at_params_get(list, valid_i);
   389fc:	4621      	mov	r1, r4
   389fe:	4628      	mov	r0, r5
   38a00:	f7e8 fb7a 	bl	210f8 <at_params_get>
   38a04:	e7f4      	b.n	389f0 <at_params_valid_count_get+0x12>
		return -EINVAL;
   38a06:	f06f 0415 	mvn.w	r4, #21
   38a0a:	e7f4      	b.n	389f6 <at_params_valid_count_get+0x18>

00038a0c <response_is_valid>:
{
   38a0c:	b570      	push	{r4, r5, r6, lr}
   38a0e:	4606      	mov	r6, r0
	if ((response_len < strlen(check)) ||
   38a10:	4610      	mov	r0, r2
{
   38a12:	460d      	mov	r5, r1
   38a14:	4614      	mov	r4, r2
	if ((response_len < strlen(check)) ||
   38a16:	f7d9 fb33 	bl	12080 <strlen>
   38a1a:	42a8      	cmp	r0, r5
   38a1c:	d808      	bhi.n	38a30 <response_is_valid+0x24>
	    (memcmp(response, check, response_len) != 0)) {
   38a1e:	462a      	mov	r2, r5
   38a20:	4621      	mov	r1, r4
   38a22:	4630      	mov	r0, r6
   38a24:	f000 faca 	bl	38fbc <memcmp>
	if ((response_len < strlen(check)) ||
   38a28:	fab0 f080 	clz	r0, r0
   38a2c:	0940      	lsrs	r0, r0, #5
}
   38a2e:	bd70      	pop	{r4, r5, r6, pc}
		return false;
   38a30:	2000      	movs	r0, #0
   38a32:	e7fc      	b.n	38a2e <response_is_valid+0x22>

00038a34 <lte_lc_init_and_connect>:
{
   38a34:	b508      	push	{r3, lr}
	ret = w_lte_lc_init();
   38a36:	f7e8 fd57 	bl	214e8 <w_lte_lc_init>
	if (ret) {
   38a3a:	b920      	cbnz	r0, 38a46 <lte_lc_init_and_connect+0x12>
}
   38a3c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return w_lte_lc_connect(true);
   38a40:	2001      	movs	r0, #1
   38a42:	f7e8 be1b 	b.w	2167c <w_lte_lc_connect>
}
   38a46:	bd08      	pop	{r3, pc}

00038a48 <k_uptime_get>:
{
   38a48:	b510      	push	{r4, lr}
	return z_impl_k_uptime_ticks();
   38a4a:	f000 f9f7 	bl	38e3c <z_impl_k_uptime_ticks>
   38a4e:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
   38a52:	fba0 2304 	umull	r2, r3, r0, r4
   38a56:	fb04 3301 	mla	r3, r4, r1, r3
   38a5a:	0bd0      	lsrs	r0, r2, #15
}
   38a5c:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
   38a60:	0bd9      	lsrs	r1, r3, #15
   38a62:	bd10      	pop	{r4, pc}

00038a64 <date_time_now>:

int date_time_now(s64_t *unix_time_ms)
{
   38a64:	b510      	push	{r4, lr}
   38a66:	4604      	mov	r4, r0
	*unix_time_ms = k_uptime_get();
   38a68:	f7ff ffee 	bl	38a48 <k_uptime_get>
   38a6c:	e9c4 0100 	strd	r0, r1, [r4]

	return date_time_uptime_to_unix_time_ms(unix_time_ms);
   38a70:	4620      	mov	r0, r4
}
   38a72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return date_time_uptime_to_unix_time_ms(unix_time_ms);
   38a76:	f7e9 bcab 	b.w	223d0 <date_time_uptime_to_unix_time_ms>

00038a7a <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   38a7a:	4700      	bx	r0

00038a7c <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   38a7c:	f000 b967 	b.w	38d4e <z_impl_k_busy_wait>

00038a80 <nrf_gpio_pin_clear>:
{
   38a80:	b510      	push	{r4, lr}
   38a82:	4604      	mov	r4, r0
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   38a84:	f7f1 fffc 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
   38a88:	2301      	movs	r3, #1
   38a8a:	40a3      	lsls	r3, r4
    p_reg->OUTCLR = clr_mask;
   38a8c:	60c3      	str	r3, [r0, #12]
}
   38a8e:	bd10      	pop	{r4, pc}

00038a90 <nrf_gpio_pin_set>:
{
   38a90:	b510      	push	{r4, lr}
   38a92:	4604      	mov	r4, r0
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
   38a94:	f7f1 fff4 	bl	2aa80 <nrf_gpio_pin_port_decode.isra.0>
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
   38a98:	2301      	movs	r3, #1
   38a9a:	40a3      	lsls	r3, r4
    p_reg->OUTSET = set_mask;
   38a9c:	6083      	str	r3, [r0, #8]
}
   38a9e:	bd10      	pop	{r4, pc}

00038aa0 <xfer_completeness_check>:
    switch (p_cb->xfer_desc.type)
   38aa0:	7b0b      	ldrb	r3, [r1, #12]
   38aa2:	2b03      	cmp	r3, #3
   38aa4:	d82a      	bhi.n	38afc <xfer_completeness_check+0x5c>
   38aa6:	e8df f003 	tbb	[pc, r3]
   38aaa:	2622      	.short	0x2622
   38aac:	021a      	.short	0x021a
            if (((p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   38aae:	688b      	ldr	r3, [r1, #8]
   38ab0:	035a      	lsls	r2, r3, #13
   38ab2:	d504      	bpl.n	38abe <xfer_completeness_check+0x1e>
    return p_reg->TXD.AMOUNT;
   38ab4:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
   38ab8:	690a      	ldr	r2, [r1, #16]
   38aba:	429a      	cmp	r2, r3
   38abc:	d107      	bne.n	38ace <xfer_completeness_check+0x2e>
                (!(p_cb->int_mask & NRF_TWIM_INT_SUSPENDED_MASK) &&
   38abe:	688b      	ldr	r3, [r1, #8]
                 (nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)) ||
   38ac0:	035b      	lsls	r3, r3, #13
   38ac2:	d41b      	bmi.n	38afc <xfer_completeness_check+0x5c>
   38ac4:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   38ac8:	694a      	ldr	r2, [r1, #20]
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   38aca:	429a      	cmp	r2, r3
   38acc:	d016      	beq.n	38afc <xfer_completeness_check+0x5c>
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   38ace:	2300      	movs	r3, #0
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   38ad0:	2206      	movs	r2, #6
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Disabled << TWIM_ENABLE_ENABLE_Pos);
   38ad2:	f8c0 3500 	str.w	r3, [r0, #1280]	; 0x500
    p_reg->ENABLE = (TWIM_ENABLE_ENABLE_Enabled << TWIM_ENABLE_ENABLE_Pos);
   38ad6:	f8c0 2500 	str.w	r2, [r0, #1280]	; 0x500
   38ada:	4618      	mov	r0, r3
   38adc:	4770      	bx	lr
    return p_reg->TXD.AMOUNT;
   38ade:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if ((nrf_twim_txd_amount_get(p_twim) != p_cb->xfer_desc.primary_length) ||
   38ae2:	690a      	ldr	r2, [r1, #16]
   38ae4:	429a      	cmp	r2, r3
   38ae6:	d1f2      	bne.n	38ace <xfer_completeness_check+0x2e>
    return p_reg->RXD.AMOUNT;
   38ae8:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   38aec:	e7ec      	b.n	38ac8 <xfer_completeness_check+0x28>
    return p_reg->TXD.AMOUNT;
   38aee:	f8d0 354c 	ldr.w	r3, [r0, #1356]	; 0x54c
            if (nrf_twim_rxd_amount_get(p_twim) != p_cb->xfer_desc.primary_length)
   38af2:	690a      	ldr	r2, [r1, #16]
   38af4:	e7e9      	b.n	38aca <xfer_completeness_check+0x2a>
    return p_reg->RXD.AMOUNT;
   38af6:	f8d0 353c 	ldr.w	r3, [r0, #1340]	; 0x53c
   38afa:	e7fa      	b.n	38af2 <xfer_completeness_check+0x52>
    bool transfer_complete = true;
   38afc:	2001      	movs	r0, #1
}
   38afe:	4770      	bx	lr

00038b00 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
   38b00:	f7fb bb54 	b.w	341ac <z_clock_idle_exit>

00038b04 <k_heap_init>:
{
   38b04:	b410      	push	{r4}
   38b06:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   38b0a:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   38b0e:	f85d 4b04 	ldr.w	r4, [sp], #4
	sys_heap_init(&h->heap, mem, bytes);
   38b12:	f7fa bfbc 	b.w	33a8e <sys_heap_init>

00038b16 <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
   38b16:	b570      	push	{r4, r5, r6, lr}
   38b18:	4614      	mov	r4, r2
	block->id.heap = p->heap;
   38b1a:	6800      	ldr	r0, [r0, #0]
{
   38b1c:	460e      	mov	r6, r1
	block->id.heap = p->heap;
   38b1e:	6048      	str	r0, [r1, #4]
	block->data = k_heap_alloc(p->heap, size, timeout);
   38b20:	461a      	mov	r2, r3
   38b22:	4621      	mov	r1, r4
{
   38b24:	461d      	mov	r5, r3
	block->data = k_heap_alloc(p->heap, size, timeout);
   38b26:	f7f3 f83b 	bl	2bba0 <k_heap_alloc>
   38b2a:	6030      	str	r0, [r6, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
   38b2c:	b13c      	cbz	r4, 38b3e <k_mem_pool_alloc+0x28>
   38b2e:	b930      	cbnz	r0, 38b3e <k_mem_pool_alloc+0x28>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
   38b30:	2d00      	cmp	r5, #0
   38b32:	bf0c      	ite	eq
   38b34:	f06f 000b 	mvneq.w	r0, #11
   38b38:	f06f 000a 	mvnne.w	r0, #10
	} else {
		return 0;
	}
}
   38b3c:	bd70      	pop	{r4, r5, r6, pc}
		return 0;
   38b3e:	2000      	movs	r0, #0
   38b40:	e7fc      	b.n	38b3c <k_mem_pool_alloc+0x26>

00038b42 <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	k_heap_free(id->heap, id->data);
   38b42:	e9d0 1000 	ldrd	r1, r0, [r0]
   38b46:	f7f3 b8db 	b.w	2bd00 <k_heap_free>

00038b4a <mbox_message_match>:
{
   38b4a:	460b      	mov	r3, r1
	if (((tx_msg->tx_target_thread == (k_tid_t)K_ANY) ||
   38b4c:	6a01      	ldr	r1, [r0, #32]
{
   38b4e:	b530      	push	{r4, r5, lr}
   38b50:	4602      	mov	r2, r0
	if (((tx_msg->tx_target_thread == (k_tid_t)K_ANY) ||
   38b52:	b111      	cbz	r1, 38b5a <mbox_message_match+0x10>
   38b54:	6a18      	ldr	r0, [r3, #32]
   38b56:	4281      	cmp	r1, r0
   38b58:	d125      	bne.n	38ba6 <mbox_message_match+0x5c>
	    ((rx_msg->rx_source_thread == (k_tid_t)K_ANY) ||
   38b5a:	69d8      	ldr	r0, [r3, #28]
   38b5c:	69d1      	ldr	r1, [r2, #28]
	     (tx_msg->tx_target_thread == rx_msg->tx_target_thread)) &&
   38b5e:	b108      	cbz	r0, 38b64 <mbox_message_match+0x1a>
	    ((rx_msg->rx_source_thread == (k_tid_t)K_ANY) ||
   38b60:	4288      	cmp	r0, r1
   38b62:	d120      	bne.n	38ba6 <mbox_message_match+0x5c>
		rx_msg->rx_source_thread = tx_msg->rx_source_thread;
   38b64:	61d9      	str	r1, [r3, #28]
		tx_msg->tx_target_thread = rx_msg->tx_target_thread;
   38b66:	6a19      	ldr	r1, [r3, #32]
		rx_msg->info = tx_msg->info;
   38b68:	6890      	ldr	r0, [r2, #8]
		tx_msg->tx_target_thread = rx_msg->tx_target_thread;
   38b6a:	6211      	str	r1, [r2, #32]
		temp_info = rx_msg->info;
   38b6c:	6899      	ldr	r1, [r3, #8]
		rx_msg->info = tx_msg->info;
   38b6e:	6098      	str	r0, [r3, #8]
		tx_msg->info = temp_info;
   38b70:	6091      	str	r1, [r2, #8]
		if (rx_msg->size > tx_msg->size) {
   38b72:	6858      	ldr	r0, [r3, #4]
   38b74:	6851      	ldr	r1, [r2, #4]
		rx_msg->tx_data = tx_msg->tx_data;
   38b76:	68d5      	ldr	r5, [r2, #12]
		if (rx_msg->size > tx_msg->size) {
   38b78:	4288      	cmp	r0, r1
			rx_msg->size = tx_msg->size;
   38b7a:	bf88      	it	hi
   38b7c:	6059      	strhi	r1, [r3, #4]
		rx_msg->tx_block = tx_msg->tx_block;
   38b7e:	f103 0414 	add.w	r4, r3, #20
   38b82:	f102 0114 	add.w	r1, r2, #20
		rx_msg->tx_data = tx_msg->tx_data;
   38b86:	60dd      	str	r5, [r3, #12]
		rx_msg->tx_block = tx_msg->tx_block;
   38b88:	c903      	ldmia	r1, {r0, r1}
   38b8a:	e884 0003 	stmia.w	r4, {r0, r1}
		if (rx_msg->tx_data != NULL) {
   38b8e:	b12d      	cbz	r5, 38b9c <mbox_message_match+0x52>
			rx_msg->tx_block.data = NULL;
   38b90:	2100      	movs	r1, #0
   38b92:	6159      	str	r1, [r3, #20]
		return 0;
   38b94:	2000      	movs	r0, #0
		rx_msg->_syncing_thread = tx_msg->_syncing_thread;
   38b96:	6a52      	ldr	r2, [r2, #36]	; 0x24
   38b98:	625a      	str	r2, [r3, #36]	; 0x24
}
   38b9a:	bd30      	pop	{r4, r5, pc}
		} else if (rx_msg->tx_block.data != NULL) {
   38b9c:	6959      	ldr	r1, [r3, #20]
   38b9e:	2900      	cmp	r1, #0
   38ba0:	d0f8      	beq.n	38b94 <mbox_message_match+0x4a>
			rx_msg->tx_data = rx_msg->tx_block.data;
   38ba2:	60d9      	str	r1, [r3, #12]
   38ba4:	e7f6      	b.n	38b94 <mbox_message_match+0x4a>
	return -1;
   38ba6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   38baa:	e7f6      	b.n	38b9a <mbox_message_match+0x50>

00038bac <k_mbox_init>:
   38bac:	f100 0308 	add.w	r3, r0, #8
   38bb0:	e9c0 3302 	strd	r3, r3, [r0, #8]
	mbox_ptr->lock = (struct k_spinlock) {};
   38bb4:	2300      	movs	r3, #0
   38bb6:	e9c0 0000 	strd	r0, r0, [r0]
   38bba:	6103      	str	r3, [r0, #16]
}
   38bbc:	4770      	bx	lr

00038bbe <k_mbox_data_get>:
{
   38bbe:	b510      	push	{r4, lr}
	if (buffer == NULL) {
   38bc0:	460b      	mov	r3, r1
{
   38bc2:	4604      	mov	r4, r0
	if (buffer == NULL) {
   38bc4:	b921      	cbnz	r1, 38bd0 <k_mbox_data_get+0x12>
		rx_msg->size = 0;
   38bc6:	6061      	str	r1, [r4, #4]
}
   38bc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	mbox_message_dispose(rx_msg);
   38bcc:	f7f3 b996 	b.w	2befc <mbox_message_dispose>
	if ((rx_msg->tx_data != NULL) && (rx_msg->size > 0)) {
   38bd0:	68c1      	ldr	r1, [r0, #12]
   38bd2:	b121      	cbz	r1, 38bde <k_mbox_data_get+0x20>
   38bd4:	6842      	ldr	r2, [r0, #4]
   38bd6:	b112      	cbz	r2, 38bde <k_mbox_data_get+0x20>
   38bd8:	4618      	mov	r0, r3
   38bda:	f000 f9fd 	bl	38fd8 <memcpy>
	mbox_message_dispose(rx_msg);
   38bde:	4620      	mov	r0, r4
   38be0:	e7f2      	b.n	38bc8 <k_mbox_data_get+0xa>

00038be2 <k_mem_pool_free>:
	k_mem_pool_free_id(&block->id);
   38be2:	f7ff bfae 	b.w	38b42 <k_mem_pool_free_id>

00038be6 <k_mem_pool_malloc>:
{
   38be6:	b507      	push	{r0, r1, r2, lr}
   38be8:	2208      	movs	r2, #8
   38bea:	188a      	adds	r2, r1, r2
   38bec:	d204      	bcs.n	38bf8 <k_mem_pool_malloc+0x12>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
   38bee:	2300      	movs	r3, #0
   38bf0:	4669      	mov	r1, sp
   38bf2:	f7ff ff90 	bl	38b16 <k_mem_pool_alloc>
   38bf6:	b118      	cbz	r0, 38c00 <k_mem_pool_malloc+0x1a>
		return NULL;
   38bf8:	2000      	movs	r0, #0
}
   38bfa:	b003      	add	sp, #12
   38bfc:	f85d fb04 	ldr.w	pc, [sp], #4
   38c00:	466b      	mov	r3, sp
   38c02:	9a00      	ldr	r2, [sp, #0]
   38c04:	cb03      	ldmia	r3!, {r0, r1}
   38c06:	6010      	str	r0, [r2, #0]
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
   38c08:	9800      	ldr	r0, [sp, #0]
   38c0a:	6051      	str	r1, [r2, #4]
   38c0c:	3008      	adds	r0, #8
   38c0e:	e7f4      	b.n	38bfa <k_mem_pool_malloc+0x14>

00038c10 <k_free>:
	if (ptr != NULL) {
   38c10:	b110      	cbz	r0, 38c18 <k_free+0x8>
		k_mem_pool_free_id(ptr);
   38c12:	3808      	subs	r0, #8
   38c14:	f7ff bf95 	b.w	38b42 <k_mem_pool_free_id>
}
   38c18:	4770      	bx	lr

00038c1a <k_calloc>:
{
   38c1a:	b538      	push	{r3, r4, r5, lr}
	return a != 0 && (c / a) != b;
}

static inline bool size_mul_overflow(size_t a, size_t b, size_t *result)
{
	size_t c = a * b;
   38c1c:	fb01 f400 	mul.w	r4, r1, r0

	*result = c;

	return a != 0 && (c / a) != b;
   38c20:	b118      	cbz	r0, 38c2a <k_calloc+0x10>
   38c22:	fbb4 f0f0 	udiv	r0, r4, r0
   38c26:	4281      	cmp	r1, r0
   38c28:	d10a      	bne.n	38c40 <k_calloc+0x26>
	ret = k_malloc(bounds);
   38c2a:	4620      	mov	r0, r4
   38c2c:	f7f3 fb54 	bl	2c2d8 <k_malloc>
	if (ret != NULL) {
   38c30:	4605      	mov	r5, r0
   38c32:	b118      	cbz	r0, 38c3c <k_calloc+0x22>
__ssp_bos_icheck3(memset, void *, int)
   38c34:	4622      	mov	r2, r4
   38c36:	2100      	movs	r1, #0
   38c38:	f000 fa08 	bl	3904c <memset>
}
   38c3c:	4628      	mov	r0, r5
   38c3e:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
   38c40:	2500      	movs	r5, #0
   38c42:	e7fb      	b.n	38c3c <k_calloc+0x22>

00038c44 <k_msgq_init>:
	msgq->max_msgs = max_msgs;
   38c44:	e9c0 2303 	strd	r2, r3, [r0, #12]
	msgq->buffer_end = buffer + (max_msgs * msg_size);
   38c48:	fb03 1202 	mla	r2, r3, r2, r1
	msgq->used_msgs = 0;
   38c4c:	2300      	movs	r3, #0
	msgq->buffer_start = buffer;
   38c4e:	6141      	str	r1, [r0, #20]
	msgq->read_ptr = buffer;
   38c50:	e9c0 2106 	strd	r2, r1, [r0, #24]
	msgq->write_ptr = buffer;
   38c54:	6201      	str	r1, [r0, #32]
	msgq->used_msgs = 0;
   38c56:	6243      	str	r3, [r0, #36]	; 0x24
	msgq->flags = 0;
   38c58:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
   38c5c:	e9c0 0000 	strd	r0, r0, [r0]
	msgq->lock = (struct k_spinlock) {};
   38c60:	6083      	str	r3, [r0, #8]
}
   38c62:	4770      	bx	lr

00038c64 <z_impl_k_mutex_init>:
{
   38c64:	4603      	mov	r3, r0
	mutex->owner = NULL;
   38c66:	2000      	movs	r0, #0
   38c68:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   38c6c:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   38c70:	4770      	bx	lr

00038c72 <z_queue_node_peek>:
{
   38c72:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
   38c74:	4604      	mov	r4, r0
   38c76:	b130      	cbz	r0, 38c86 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   38c78:	6802      	ldr	r2, [r0, #0]
   38c7a:	0793      	lsls	r3, r2, #30
   38c7c:	d003      	beq.n	38c86 <z_queue_node_peek+0x14>
		ret = anode->data;
   38c7e:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
   38c80:	b109      	cbz	r1, 38c86 <z_queue_node_peek+0x14>
			k_free(anode);
   38c82:	f7ff ffc5 	bl	38c10 <k_free>
}
   38c86:	4620      	mov	r0, r4
   38c88:	bd10      	pop	{r4, pc}

00038c8a <z_impl_k_queue_init>:
	list->head = NULL;
   38c8a:	2300      	movs	r3, #0
	list->tail = NULL;
   38c8c:	e9c0 3300 	strd	r3, r3, [r0]
	queue->lock = (struct k_spinlock) {};
   38c90:	6083      	str	r3, [r0, #8]
   38c92:	f100 030c 	add.w	r3, r0, #12
   38c96:	e9c0 3303 	strd	r3, r3, [r0, #12]
	sys_dlist_init(&queue->poll_events);
   38c9a:	f100 0314 	add.w	r3, r0, #20
   38c9e:	e9c0 3305 	strd	r3, r3, [r0, #20]
}
   38ca2:	4770      	bx	lr

00038ca4 <k_queue_append>:
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
   38ca4:	460a      	mov	r2, r1
   38ca6:	2300      	movs	r3, #0
   38ca8:	6841      	ldr	r1, [r0, #4]
   38caa:	f7f3 be47 	b.w	2c93c <queue_insert>

00038cae <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false);
   38cae:	2300      	movs	r3, #0
   38cb0:	460a      	mov	r2, r1
   38cb2:	4619      	mov	r1, r3
   38cb4:	f7f3 be42 	b.w	2c93c <queue_insert>

00038cb8 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
   38cb8:	f990 000e 	ldrsb.w	r0, [r0, #14]
   38cbc:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
   38cc0:	4298      	cmp	r0, r3
   38cc2:	bfac      	ite	ge
   38cc4:	2000      	movge	r0, #0
   38cc6:	2001      	movlt	r0, #1
   38cc8:	4770      	bx	lr

00038cca <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   38cca:	4603      	mov	r3, r0
   38ccc:	b920      	cbnz	r0, 38cd8 <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   38cce:	f3ef 8205 	mrs	r2, IPSR
   38cd2:	b90a      	cbnz	r2, 38cd8 <z_reschedule_irqlock+0xe>
   38cd4:	f7e1 bf0a 	b.w	1aaec <arch_swap>
   38cd8:	f383 8811 	msr	BASEPRI, r3
   38cdc:	f3bf 8f6f 	isb	sy
}
   38ce0:	4770      	bx	lr

00038ce2 <z_reschedule_unlocked>:
	__asm__ volatile(
   38ce2:	f04f 0320 	mov.w	r3, #32
   38ce6:	f3ef 8011 	mrs	r0, BASEPRI
   38cea:	f383 8811 	msr	BASEPRI, r3
   38cee:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   38cf2:	f7ff bfea 	b.w	38cca <z_reschedule_irqlock>

00038cf6 <z_priq_dumb_best>:
	return list->head == list;
   38cf6:	6803      	ldr	r3, [r0, #0]
}
   38cf8:	4298      	cmp	r0, r3
   38cfa:	bf14      	ite	ne
   38cfc:	4618      	movne	r0, r3
   38cfe:	2000      	moveq	r0, #0
   38d00:	4770      	bx	lr

00038d02 <z_unpend_all>:
{
   38d02:	b538      	push	{r3, r4, r5, lr}
   38d04:	4605      	mov	r5, r0
	int need_sched = 0;
   38d06:	2000      	movs	r0, #0
   38d08:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   38d0a:	42a5      	cmp	r5, r4
   38d0c:	d000      	beq.n	38d10 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
   38d0e:	b904      	cbnz	r4, 38d12 <z_unpend_all+0x10>
}
   38d10:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
   38d12:	4620      	mov	r0, r4
   38d14:	f7f4 f95a 	bl	2cfcc <z_unpend_thread>
		z_ready_thread(thread);
   38d18:	4620      	mov	r0, r4
   38d1a:	f7f4 fa97 	bl	2d24c <z_ready_thread>
		need_sched = 1;
   38d1e:	2001      	movs	r0, #1
   38d20:	e7f2      	b.n	38d08 <z_unpend_all+0x6>

00038d22 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
   38d22:	b15a      	cbz	r2, 38d3c <z_impl_k_sem_init+0x1a>
   38d24:	428a      	cmp	r2, r1
   38d26:	d309      	bcc.n	38d3c <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
   38d28:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
   38d2c:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
   38d30:	e9c0 0000 	strd	r0, r0, [r0]
   38d34:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
   38d38:	2000      	movs	r0, #0
   38d3a:	4770      	bx	lr
		return -EINVAL;
   38d3c:	f06f 0015 	mvn.w	r0, #21
}
   38d40:	4770      	bx	lr

00038d42 <k_is_in_isr>:
   38d42:	f3ef 8005 	mrs	r0, IPSR
}
   38d46:	3000      	adds	r0, #0
   38d48:	bf18      	it	ne
   38d4a:	2001      	movne	r0, #1
   38d4c:	4770      	bx	lr

00038d4e <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
   38d4e:	f7df bfff 	b.w	18d50 <arch_busy_wait>

00038d52 <z_impl_k_thread_name_set>:
}
   38d52:	f06f 0057 	mvn.w	r0, #87	; 0x57
   38d56:	4770      	bx	lr

00038d58 <k_thread_name_get>:
}
   38d58:	2000      	movs	r0, #0
   38d5a:	4770      	bx	lr

00038d5c <z_init_thread_base>:
	thread_base->user_options = (u8_t)options;
   38d5c:	7303      	strb	r3, [r0, #12]
	thread_base->sched_locked = 0U;
   38d5e:	2300      	movs	r3, #0
	thread_base->thread_state = (u8_t)initial_state;
   38d60:	7342      	strb	r2, [r0, #13]
	thread_base->prio = priority;
   38d62:	7381      	strb	r1, [r0, #14]
	thread_base->sched_locked = 0U;
   38d64:	73c3      	strb	r3, [r0, #15]
	node->prev = NULL;
   38d66:	e9c0 3306 	strd	r3, r3, [r0, #24]
}
   38d6a:	4770      	bx	lr

00038d6c <k_work_submit_to_queue>:
{
   38d6c:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
   38d6e:	f101 0308 	add.w	r3, r1, #8
   38d72:	e8d3 2fef 	ldaex	r2, [r3]
   38d76:	f042 0c01 	orr.w	ip, r2, #1
   38d7a:	e8c3 cfee 	stlex	lr, ip, [r3]
   38d7e:	f1be 0f00 	cmp.w	lr, #0
   38d82:	d1f6      	bne.n	38d72 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
   38d84:	07d3      	lsls	r3, r2, #31
   38d86:	d403      	bmi.n	38d90 <k_work_submit_to_queue+0x24>
}
   38d88:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
   38d8c:	f7ff bf8a 	b.w	38ca4 <k_queue_append>
}
   38d90:	f85d fb04 	ldr.w	pc, [sp], #4

00038d94 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
   38d94:	f1a0 010c 	sub.w	r1, r0, #12
   38d98:	6900      	ldr	r0, [r0, #16]
   38d9a:	f7ff bfe7 	b.w	38d6c <k_work_submit_to_queue>

00038d9e <work_cancel>:
	CHECKIF(work->work_q == NULL) {
   38d9e:	69c3      	ldr	r3, [r0, #28]
{
   38da0:	b570      	push	{r4, r5, r6, lr}
   38da2:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
   38da4:	b913      	cbnz	r3, 38dac <work_cancel+0xe>
		return -EALREADY;
   38da6:	f06f 0077 	mvn.w	r0, #119	; 0x77
}
   38daa:	bd70      	pop	{r4, r5, r6, pc}
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
   38dac:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
   38db0:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
   38db4:	07db      	lsls	r3, r3, #31
   38db6:	d52f      	bpl.n	38e18 <work_cancel+0x7a>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   38db8:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
   38dba:	69c2      	ldr	r2, [r0, #28]
   38dbc:	6813      	ldr	r3, [r2, #0]
   38dbe:	b913      	cbnz	r3, 38dc6 <work_cancel+0x28>
			return -EINVAL;
   38dc0:	f06f 0015 	mvn.w	r0, #21
   38dc4:	e7f1      	b.n	38daa <work_cancel+0xc>
   38dc6:	429c      	cmp	r4, r3
   38dc8:	d121      	bne.n	38e0e <work_cancel+0x70>
Z_GENLIST_REMOVE(sflist, sfnode)
   38dca:	6823      	ldr	r3, [r4, #0]
   38dcc:	6856      	ldr	r6, [r2, #4]
   38dce:	f023 0003 	bic.w	r0, r3, #3
   38dd2:	b991      	cbnz	r1, 38dfa <work_cancel+0x5c>
   38dd4:	42b4      	cmp	r4, r6
	list->head = node;
   38dd6:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   38dd8:	d100      	bne.n	38ddc <work_cancel+0x3e>
	list->tail = node;
   38dda:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   38ddc:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
   38dde:	f003 0303 	and.w	r3, r3, #3
   38de2:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
   38de4:	2000      	movs	r0, #0
   38de6:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
   38de8:	e8d5 3fef 	ldaex	r3, [r5]
   38dec:	f023 0301 	bic.w	r3, r3, #1
   38df0:	e8c5 3fe2 	stlex	r2, r3, [r5]
   38df4:	2a00      	cmp	r2, #0
   38df6:	d0d8      	beq.n	38daa <work_cancel+0xc>
   38df8:	e7f6      	b.n	38de8 <work_cancel+0x4a>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
   38dfa:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
   38dfc:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
   38dfe:	f003 0303 	and.w	r3, r3, #3
   38e02:	ea43 0300 	orr.w	r3, r3, r0
   38e06:	600b      	str	r3, [r1, #0]
	list->tail = node;
   38e08:	bf08      	it	eq
   38e0a:	6051      	streq	r1, [r2, #4]
   38e0c:	e7e6      	b.n	38ddc <work_cancel+0x3e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
   38e0e:	6818      	ldr	r0, [r3, #0]
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
   38e10:	4619      	mov	r1, r3
   38e12:	f020 0303 	bic.w	r3, r0, #3
   38e16:	e7d2      	b.n	38dbe <work_cancel+0x20>
		int err = z_abort_timeout(&work->timeout);
   38e18:	300c      	adds	r0, #12
   38e1a:	f7f5 fd8d 	bl	2e938 <z_abort_timeout>
		if (err) {
   38e1e:	2800      	cmp	r0, #0
   38e20:	d0e0      	beq.n	38de4 <work_cancel+0x46>
   38e22:	e7c0      	b.n	38da6 <work_cancel+0x8>

00038e24 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
   38e24:	2300      	movs	r3, #0
   38e26:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
   38e2a:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
   38e2e:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
   38e30:	61c3      	str	r3, [r0, #28]
}
   38e32:	4770      	bx	lr

00038e34 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
   38e34:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
   38e36:	f7f5 ff61 	bl	2ecfc <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
   38e3a:	bd08      	pop	{r3, pc}

00038e3c <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
   38e3c:	f7f5 bf5e 	b.w	2ecfc <z_tick_get>

00038e40 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
   38e40:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
   38e42:	1c43      	adds	r3, r0, #1
   38e44:	d01e      	beq.n	38e84 <z_timeout_end_calc+0x44>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
   38e46:	b918      	cbnz	r0, 38e50 <z_timeout_end_calc+0x10>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
   38e48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
   38e4c:	f7f5 bf56 	b.w	2ecfc <z_tick_get>
			return (u32_t)((t * to_hz + off) / from_hz);
   38e50:	f44f 4100 	mov.w	r1, #32768	; 0x8000
   38e54:	f240 34e7 	movw	r4, #999	; 0x3e7
   38e58:	2500      	movs	r5, #0
   38e5a:	fbe1 4500 	umlal	r4, r5, r1, r0
   38e5e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   38e62:	4620      	mov	r0, r4
   38e64:	2300      	movs	r3, #0
   38e66:	4629      	mov	r1, r5
   38e68:	f7d4 fc82 	bl	d770 <__aeabi_uldivmod>
   38e6c:	4604      	mov	r4, r0
	return z_tick_get() + MAX(1, dt);
   38e6e:	f7f5 ff45 	bl	2ecfc <z_tick_get>
   38e72:	b12c      	cbz	r4, 38e80 <z_timeout_end_calc+0x40>
   38e74:	4623      	mov	r3, r4
   38e76:	2200      	movs	r2, #0
   38e78:	18c0      	adds	r0, r0, r3
   38e7a:	eb42 0101 	adc.w	r1, r2, r1
}
   38e7e:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
   38e80:	2301      	movs	r3, #1
   38e82:	e7f8      	b.n	38e76 <z_timeout_end_calc+0x36>
		return UINT64_MAX;
   38e84:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   38e88:	4601      	mov	r1, r0
   38e8a:	e7f8      	b.n	38e7e <z_timeout_end_calc+0x3e>

00038e8c <k_timer_init>:
	timer->status = 0U;
   38e8c:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
   38e8e:	e9c0 1206 	strd	r1, r2, [r0, #24]
   38e92:	f100 0210 	add.w	r2, r0, #16
	timer->status = 0U;
   38e96:	6243      	str	r3, [r0, #36]	; 0x24
	list->tail = (sys_dnode_t *)list;
   38e98:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
   38e9c:	e9c0 3300 	strd	r3, r3, [r0]
	timer->user_data = NULL;
   38ea0:	6283      	str	r3, [r0, #40]	; 0x28
}
   38ea2:	4770      	bx	lr

00038ea4 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
   38ea4:	b510      	push	{r4, lr}
   38ea6:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
   38ea8:	f7f5 fd46 	bl	2e938 <z_abort_timeout>

	if (inactive) {
   38eac:	b9d8      	cbnz	r0, 38ee6 <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
   38eae:	69e3      	ldr	r3, [r4, #28]
   38eb0:	b10b      	cbz	r3, 38eb6 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
   38eb2:	4620      	mov	r0, r4
   38eb4:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
   38eb6:	f104 0010 	add.w	r0, r4, #16
   38eba:	2100      	movs	r1, #0
   38ebc:	f7f3 ff08 	bl	2ccd0 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
   38ec0:	4604      	mov	r4, r0
   38ec2:	b180      	cbz	r0, 38ee6 <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
   38ec4:	f7f3 ff4e 	bl	2cd64 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
   38ec8:	4620      	mov	r0, r4
   38eca:	f7f4 f9bf 	bl	2d24c <z_ready_thread>
   38ece:	f04f 0320 	mov.w	r3, #32
   38ed2:	f3ef 8011 	mrs	r0, BASEPRI
   38ed6:	f383 8811 	msr	BASEPRI, r3
   38eda:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
   38ede:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
   38ee2:	f7ff bef2 	b.w	38cca <z_reschedule_irqlock>
   38ee6:	bd10      	pop	{r4, pc}

00038ee8 <signal_poll_event>:
#include <syscalls/k_poll_mrsh.c>
#endif

/* must be called with interrupts locked */
static int signal_poll_event(struct k_poll_event *event, u32_t state)
{
   38ee8:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
   38eea:	6884      	ldr	r4, [r0, #8]
{
   38eec:	4605      	mov	r5, r0
   38eee:	460e      	mov	r6, r1
	int retcode = 0;

	if (poller) {
   38ef0:	b19c      	cbz	r4, 38f1a <signal_poll_event+0x32>
		if (poller->cb != NULL) {
   38ef2:	68a3      	ldr	r3, [r4, #8]
   38ef4:	b95b      	cbnz	r3, 38f0e <signal_poll_event+0x26>
	int retcode = 0;
   38ef6:	4618      	mov	r0, r3
			retcode = poller->cb(event, state);
		}

		poller->is_polling = false;
   38ef8:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
   38efa:	2300      	movs	r3, #0
   38efc:	60ab      	str	r3, [r5, #8]
	event->state |= state;
   38efe:	68eb      	ldr	r3, [r5, #12]
   38f00:	f3c3 3204 	ubfx	r2, r3, #12, #5
   38f04:	4316      	orrs	r6, r2
   38f06:	f366 3310 	bfi	r3, r6, #12, #5
   38f0a:	60eb      	str	r3, [r5, #12]
			return retcode;
		}
	}

	set_event_ready(event, state);
	return retcode;
   38f0c:	e004      	b.n	38f18 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
   38f0e:	4798      	blx	r3
		poller->is_polling = false;
   38f10:	2300      	movs	r3, #0
		if (retcode < 0) {
   38f12:	2800      	cmp	r0, #0
		poller->is_polling = false;
   38f14:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
   38f16:	daf0      	bge.n	38efa <signal_poll_event+0x12>
}
   38f18:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
   38f1a:	4620      	mov	r0, r4
   38f1c:	e7ed      	b.n	38efa <signal_poll_event+0x12>

00038f1e <add_event>:
{
   38f1e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   38f20:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
   38f22:	e9d0 2300 	ldrd	r2, r3, [r0]
   38f26:	4290      	cmp	r0, r2
   38f28:	4604      	mov	r4, r0
   38f2a:	460d      	mov	r5, r1
   38f2c:	d106      	bne.n	38f3c <add_event+0x1e>
	node->prev = list->tail;
   38f2e:	6863      	ldr	r3, [r4, #4]
	node->next = list;
   38f30:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
   38f32:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
   38f34:	6863      	ldr	r3, [r4, #4]
   38f36:	601d      	str	r5, [r3, #0]
	list->tail = node;
   38f38:	6065      	str	r5, [r4, #4]
}
   38f3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
   38f3c:	2b00      	cmp	r3, #0
   38f3e:	d0f6      	beq.n	38f2e <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
   38f40:	689b      	ldr	r3, [r3, #8]
   38f42:	6879      	ldr	r1, [r7, #4]
   38f44:	6858      	ldr	r0, [r3, #4]
   38f46:	f7ff feb7 	bl	38cb8 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
   38f4a:	2800      	cmp	r0, #0
   38f4c:	d1ef      	bne.n	38f2e <add_event+0x10>
	return list->head == list;
   38f4e:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   38f50:	42b4      	cmp	r4, r6
   38f52:	d0ec      	beq.n	38f2e <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
   38f54:	2e00      	cmp	r6, #0
   38f56:	d0ea      	beq.n	38f2e <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
   38f58:	68b3      	ldr	r3, [r6, #8]
   38f5a:	6878      	ldr	r0, [r7, #4]
   38f5c:	6859      	ldr	r1, [r3, #4]
   38f5e:	f7ff feab 	bl	38cb8 <z_is_t1_higher_prio_than_t2>
   38f62:	b128      	cbz	r0, 38f70 <add_event+0x52>
	node->prev = successor->prev;
   38f64:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
   38f66:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
   38f6a:	601d      	str	r5, [r3, #0]
	successor->prev = node;
   38f6c:	6075      	str	r5, [r6, #4]
			return;
   38f6e:	e7e4      	b.n	38f3a <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
   38f70:	6863      	ldr	r3, [r4, #4]
   38f72:	429e      	cmp	r6, r3
   38f74:	d0db      	beq.n	38f2e <add_event+0x10>
   38f76:	6836      	ldr	r6, [r6, #0]
   38f78:	e7ec      	b.n	38f54 <add_event+0x36>

00038f7a <z_handle_obj_poll_events>:
	return list->head == list;
   38f7a:	6803      	ldr	r3, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
   38f7c:	4298      	cmp	r0, r3
   38f7e:	d009      	beq.n	38f94 <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
   38f80:	e9d3 2000 	ldrd	r2, r0, [r3]
   38f84:	6002      	str	r2, [r0, #0]
	node->next->prev = node->prev;
   38f86:	6050      	str	r0, [r2, #4]
	node->next = NULL;
   38f88:	2200      	movs	r2, #0
{
	struct k_poll_event *poll_event;

	poll_event = (struct k_poll_event *)sys_dlist_get(events);
	if (poll_event != NULL) {
		(void) signal_poll_event(poll_event, state);
   38f8a:	4618      	mov	r0, r3
	node->prev = NULL;
   38f8c:	e9c3 2200 	strd	r2, r2, [r3]
   38f90:	f7ff bfaa 	b.w	38ee8 <signal_poll_event>
	}
}
   38f94:	4770      	bx	lr

00038f96 <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   38f96:	4770      	bx	lr

00038f98 <atoi>:
   38f98:	220a      	movs	r2, #10
   38f9a:	2100      	movs	r1, #0
   38f9c:	f7f9 b92c 	b.w	321f8 <strtol>

00038fa0 <memchr>:
   38fa0:	b2c9      	uxtb	r1, r1
   38fa2:	4402      	add	r2, r0
   38fa4:	b510      	push	{r4, lr}
   38fa6:	4290      	cmp	r0, r2
   38fa8:	4603      	mov	r3, r0
   38faa:	d101      	bne.n	38fb0 <memchr+0x10>
   38fac:	2300      	movs	r3, #0
   38fae:	e003      	b.n	38fb8 <memchr+0x18>
   38fb0:	781c      	ldrb	r4, [r3, #0]
   38fb2:	3001      	adds	r0, #1
   38fb4:	428c      	cmp	r4, r1
   38fb6:	d1f6      	bne.n	38fa6 <memchr+0x6>
   38fb8:	4618      	mov	r0, r3
   38fba:	bd10      	pop	{r4, pc}

00038fbc <memcmp>:
   38fbc:	b530      	push	{r4, r5, lr}
   38fbe:	3901      	subs	r1, #1
   38fc0:	2400      	movs	r4, #0
   38fc2:	42a2      	cmp	r2, r4
   38fc4:	d101      	bne.n	38fca <memcmp+0xe>
   38fc6:	2000      	movs	r0, #0
   38fc8:	e005      	b.n	38fd6 <memcmp+0x1a>
   38fca:	5d03      	ldrb	r3, [r0, r4]
   38fcc:	3401      	adds	r4, #1
   38fce:	5d0d      	ldrb	r5, [r1, r4]
   38fd0:	42ab      	cmp	r3, r5
   38fd2:	d0f6      	beq.n	38fc2 <memcmp+0x6>
   38fd4:	1b58      	subs	r0, r3, r5
   38fd6:	bd30      	pop	{r4, r5, pc}

00038fd8 <memcpy>:
   38fd8:	440a      	add	r2, r1
   38fda:	1e43      	subs	r3, r0, #1
   38fdc:	4291      	cmp	r1, r2
   38fde:	d100      	bne.n	38fe2 <memcpy+0xa>
   38fe0:	4770      	bx	lr
   38fe2:	b510      	push	{r4, lr}
   38fe4:	f811 4b01 	ldrb.w	r4, [r1], #1
   38fe8:	4291      	cmp	r1, r2
   38fea:	f803 4f01 	strb.w	r4, [r3, #1]!
   38fee:	d1f9      	bne.n	38fe4 <memcpy+0xc>
   38ff0:	bd10      	pop	{r4, pc}

00038ff2 <__memcpy_chk>:
   38ff2:	429a      	cmp	r2, r3
   38ff4:	b508      	push	{r3, lr}
   38ff6:	d901      	bls.n	38ffc <__memcpy_chk+0xa>
   38ff8:	f7f9 fa46 	bl	32488 <__chk_fail>
   38ffc:	4281      	cmp	r1, r0
   38ffe:	d804      	bhi.n	3900a <__memcpy_chk+0x18>
   39000:	188b      	adds	r3, r1, r2
   39002:	4298      	cmp	r0, r3
   39004:	d3f8      	bcc.n	38ff8 <__memcpy_chk+0x6>
   39006:	4281      	cmp	r1, r0
   39008:	d102      	bne.n	39010 <__memcpy_chk+0x1e>
   3900a:	1883      	adds	r3, r0, r2
   3900c:	4299      	cmp	r1, r3
   3900e:	d3f3      	bcc.n	38ff8 <__memcpy_chk+0x6>
   39010:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   39014:	f7ff bfe0 	b.w	38fd8 <memcpy>

00039018 <memmove>:
   39018:	4288      	cmp	r0, r1
   3901a:	eb01 0302 	add.w	r3, r1, r2
   3901e:	b510      	push	{r4, lr}
   39020:	d902      	bls.n	39028 <memmove+0x10>
   39022:	4283      	cmp	r3, r0
   39024:	461c      	mov	r4, r3
   39026:	d807      	bhi.n	39038 <memmove+0x20>
   39028:	1e42      	subs	r2, r0, #1
   3902a:	4299      	cmp	r1, r3
   3902c:	d008      	beq.n	39040 <memmove+0x28>
   3902e:	f811 4b01 	ldrb.w	r4, [r1], #1
   39032:	f802 4f01 	strb.w	r4, [r2, #1]!
   39036:	e7f8      	b.n	3902a <memmove+0x12>
   39038:	1883      	adds	r3, r0, r2
   3903a:	1a9a      	subs	r2, r3, r2
   3903c:	429a      	cmp	r2, r3
   3903e:	d100      	bne.n	39042 <memmove+0x2a>
   39040:	bd10      	pop	{r4, pc}
   39042:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
   39046:	f803 1d01 	strb.w	r1, [r3, #-1]!
   3904a:	e7f7      	b.n	3903c <memmove+0x24>

0003904c <memset>:
   3904c:	4402      	add	r2, r0
   3904e:	4603      	mov	r3, r0
   39050:	4293      	cmp	r3, r2
   39052:	d100      	bne.n	39056 <memset+0xa>
   39054:	4770      	bx	lr
   39056:	f803 1b01 	strb.w	r1, [r3], #1
   3905a:	e7f9      	b.n	39050 <memset+0x4>

0003905c <_calloc_r>:
   3905c:	b538      	push	{r3, r4, r5, lr}
   3905e:	fb02 f401 	mul.w	r4, r2, r1
   39062:	4621      	mov	r1, r4
   39064:	f7f8 f93c 	bl	312e0 <_malloc_r>
   39068:	4605      	mov	r5, r0
   3906a:	b118      	cbz	r0, 39074 <_calloc_r+0x18>
   3906c:	4622      	mov	r2, r4
   3906e:	2100      	movs	r1, #0
   39070:	f7ff ffec 	bl	3904c <memset>
   39074:	4628      	mov	r0, r5
   39076:	bd38      	pop	{r3, r4, r5, pc}

00039078 <__sfputc_r>:
   39078:	6893      	ldr	r3, [r2, #8]
   3907a:	3b01      	subs	r3, #1
   3907c:	2b00      	cmp	r3, #0
   3907e:	6093      	str	r3, [r2, #8]
   39080:	b410      	push	{r4}
   39082:	da08      	bge.n	39096 <__sfputc_r+0x1e>
   39084:	6994      	ldr	r4, [r2, #24]
   39086:	42a3      	cmp	r3, r4
   39088:	db01      	blt.n	3908e <__sfputc_r+0x16>
   3908a:	290a      	cmp	r1, #10
   3908c:	d103      	bne.n	39096 <__sfputc_r+0x1e>
   3908e:	f85d 4b04 	ldr.w	r4, [sp], #4
   39092:	f7f9 b939 	b.w	32308 <__swbuf_r>
   39096:	6813      	ldr	r3, [r2, #0]
   39098:	1c58      	adds	r0, r3, #1
   3909a:	6010      	str	r0, [r2, #0]
   3909c:	4608      	mov	r0, r1
   3909e:	7019      	strb	r1, [r3, #0]
   390a0:	f85d 4b04 	ldr.w	r4, [sp], #4
   390a4:	4770      	bx	lr

000390a6 <__sfputs_r>:
   390a6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   390a8:	4606      	mov	r6, r0
   390aa:	460f      	mov	r7, r1
   390ac:	4614      	mov	r4, r2
   390ae:	18d5      	adds	r5, r2, r3
   390b0:	42ac      	cmp	r4, r5
   390b2:	d101      	bne.n	390b8 <__sfputs_r+0x12>
   390b4:	2000      	movs	r0, #0
   390b6:	e007      	b.n	390c8 <__sfputs_r+0x22>
   390b8:	463a      	mov	r2, r7
   390ba:	f814 1b01 	ldrb.w	r1, [r4], #1
   390be:	4630      	mov	r0, r6
   390c0:	f7ff ffda 	bl	39078 <__sfputc_r>
   390c4:	1c43      	adds	r3, r0, #1
   390c6:	d1f3      	bne.n	390b0 <__sfputs_r+0xa>
   390c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000390ca <__cvt>:
   390ca:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   390ce:	ec55 4b10 	vmov	r4, r5, d0
   390d2:	2d00      	cmp	r5, #0
   390d4:	460e      	mov	r6, r1
   390d6:	4691      	mov	r9, r2
   390d8:	4619      	mov	r1, r3
   390da:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   390de:	f04f 0200 	mov.w	r2, #0
   390e2:	da03      	bge.n	390ec <__cvt+0x22>
   390e4:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
   390e8:	222d      	movs	r2, #45	; 0x2d
   390ea:	461d      	mov	r5, r3
   390ec:	9f0d      	ldr	r7, [sp, #52]	; 0x34
   390ee:	700a      	strb	r2, [r1, #0]
   390f0:	f027 0720 	bic.w	r7, r7, #32
   390f4:	2f46      	cmp	r7, #70	; 0x46
   390f6:	d004      	beq.n	39102 <__cvt+0x38>
   390f8:	2f45      	cmp	r7, #69	; 0x45
   390fa:	d100      	bne.n	390fe <__cvt+0x34>
   390fc:	3601      	adds	r6, #1
   390fe:	2102      	movs	r1, #2
   39100:	e000      	b.n	39104 <__cvt+0x3a>
   39102:	2103      	movs	r1, #3
   39104:	ab03      	add	r3, sp, #12
   39106:	4632      	mov	r2, r6
   39108:	9301      	str	r3, [sp, #4]
   3910a:	ab02      	add	r3, sp, #8
   3910c:	ec45 4b10 	vmov	d0, r4, r5
   39110:	9300      	str	r3, [sp, #0]
   39112:	4653      	mov	r3, sl
   39114:	f7da ff04 	bl	13f20 <_dtoa_r>
   39118:	2f47      	cmp	r7, #71	; 0x47
   3911a:	4680      	mov	r8, r0
   3911c:	d102      	bne.n	39124 <__cvt+0x5a>
   3911e:	f019 0f01 	tst.w	r9, #1
   39122:	d022      	beq.n	3916a <__cvt+0xa0>
   39124:	2f46      	cmp	r7, #70	; 0x46
   39126:	eb08 0906 	add.w	r9, r8, r6
   3912a:	d111      	bne.n	39150 <__cvt+0x86>
   3912c:	f898 3000 	ldrb.w	r3, [r8]
   39130:	2b30      	cmp	r3, #48	; 0x30
   39132:	d10a      	bne.n	3914a <__cvt+0x80>
   39134:	2200      	movs	r2, #0
   39136:	2300      	movs	r3, #0
   39138:	4620      	mov	r0, r4
   3913a:	4629      	mov	r1, r5
   3913c:	f7d4 fa1e 	bl	d57c <__aeabi_dcmpeq>
   39140:	b918      	cbnz	r0, 3914a <__cvt+0x80>
   39142:	f1c6 0601 	rsb	r6, r6, #1
   39146:	f8ca 6000 	str.w	r6, [sl]
   3914a:	f8da 3000 	ldr.w	r3, [sl]
   3914e:	4499      	add	r9, r3
   39150:	2200      	movs	r2, #0
   39152:	2300      	movs	r3, #0
   39154:	4620      	mov	r0, r4
   39156:	4629      	mov	r1, r5
   39158:	f7d4 fa10 	bl	d57c <__aeabi_dcmpeq>
   3915c:	b108      	cbz	r0, 39162 <__cvt+0x98>
   3915e:	f8cd 900c 	str.w	r9, [sp, #12]
   39162:	2230      	movs	r2, #48	; 0x30
   39164:	9b03      	ldr	r3, [sp, #12]
   39166:	454b      	cmp	r3, r9
   39168:	d308      	bcc.n	3917c <__cvt+0xb2>
   3916a:	9b03      	ldr	r3, [sp, #12]
   3916c:	4640      	mov	r0, r8
   3916e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
   39170:	eba3 0308 	sub.w	r3, r3, r8
   39174:	6013      	str	r3, [r2, #0]
   39176:	b004      	add	sp, #16
   39178:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3917c:	1c59      	adds	r1, r3, #1
   3917e:	9103      	str	r1, [sp, #12]
   39180:	701a      	strb	r2, [r3, #0]
   39182:	e7ef      	b.n	39164 <__cvt+0x9a>

00039184 <__exponent>:
   39184:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   39186:	2900      	cmp	r1, #0
   39188:	7002      	strb	r2, [r0, #0]
   3918a:	bfba      	itte	lt
   3918c:	4249      	neglt	r1, r1
   3918e:	232d      	movlt	r3, #45	; 0x2d
   39190:	232b      	movge	r3, #43	; 0x2b
   39192:	2909      	cmp	r1, #9
   39194:	7043      	strb	r3, [r0, #1]
   39196:	dd22      	ble.n	391de <__exponent+0x5a>
   39198:	f10d 0307 	add.w	r3, sp, #7
   3919c:	260a      	movs	r6, #10
   3919e:	461f      	mov	r7, r3
   391a0:	2963      	cmp	r1, #99	; 0x63
   391a2:	f103 35ff 	add.w	r5, r3, #4294967295	; 0xffffffff
   391a6:	fb91 f2f6 	sdiv	r2, r1, r6
   391aa:	fb06 1412 	mls	r4, r6, r2, r1
   391ae:	f104 0430 	add.w	r4, r4, #48	; 0x30
   391b2:	f803 4c01 	strb.w	r4, [r3, #-1]
   391b6:	dc0a      	bgt.n	391ce <__exponent+0x4a>
   391b8:	3230      	adds	r2, #48	; 0x30
   391ba:	3b02      	subs	r3, #2
   391bc:	f805 2c01 	strb.w	r2, [r5, #-1]
   391c0:	1c82      	adds	r2, r0, #2
   391c2:	42bb      	cmp	r3, r7
   391c4:	4614      	mov	r4, r2
   391c6:	d305      	bcc.n	391d4 <__exponent+0x50>
   391c8:	1a20      	subs	r0, r4, r0
   391ca:	b003      	add	sp, #12
   391cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
   391ce:	462b      	mov	r3, r5
   391d0:	4611      	mov	r1, r2
   391d2:	e7e5      	b.n	391a0 <__exponent+0x1c>
   391d4:	f813 1b01 	ldrb.w	r1, [r3], #1
   391d8:	f802 1b01 	strb.w	r1, [r2], #1
   391dc:	e7f1      	b.n	391c2 <__exponent+0x3e>
   391de:	2330      	movs	r3, #48	; 0x30
   391e0:	1d04      	adds	r4, r0, #4
   391e2:	4419      	add	r1, r3
   391e4:	7083      	strb	r3, [r0, #2]
   391e6:	70c1      	strb	r1, [r0, #3]
   391e8:	e7ee      	b.n	391c8 <__exponent+0x44>

000391ea <_printf_common>:
   391ea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   391ee:	4691      	mov	r9, r2
   391f0:	461f      	mov	r7, r3
   391f2:	688a      	ldr	r2, [r1, #8]
   391f4:	4606      	mov	r6, r0
   391f6:	690b      	ldr	r3, [r1, #16]
   391f8:	460c      	mov	r4, r1
   391fa:	f8dd 8020 	ldr.w	r8, [sp, #32]
   391fe:	4293      	cmp	r3, r2
   39200:	bfb8      	it	lt
   39202:	4613      	movlt	r3, r2
   39204:	f8c9 3000 	str.w	r3, [r9]
   39208:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   3920c:	b112      	cbz	r2, 39214 <_printf_common+0x2a>
   3920e:	3301      	adds	r3, #1
   39210:	f8c9 3000 	str.w	r3, [r9]
   39214:	6823      	ldr	r3, [r4, #0]
   39216:	0699      	lsls	r1, r3, #26
   39218:	bf42      	ittt	mi
   3921a:	f8d9 3000 	ldrmi.w	r3, [r9]
   3921e:	3302      	addmi	r3, #2
   39220:	f8c9 3000 	strmi.w	r3, [r9]
   39224:	6825      	ldr	r5, [r4, #0]
   39226:	f015 0506 	ands.w	r5, r5, #6
   3922a:	d107      	bne.n	3923c <_printf_common+0x52>
   3922c:	f104 0a19 	add.w	sl, r4, #25
   39230:	68e3      	ldr	r3, [r4, #12]
   39232:	f8d9 2000 	ldr.w	r2, [r9]
   39236:	1a9b      	subs	r3, r3, r2
   39238:	42ab      	cmp	r3, r5
   3923a:	dc2b      	bgt.n	39294 <_printf_common+0xaa>
   3923c:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   39240:	6822      	ldr	r2, [r4, #0]
   39242:	3300      	adds	r3, #0
   39244:	bf18      	it	ne
   39246:	2301      	movne	r3, #1
   39248:	0692      	lsls	r2, r2, #26
   3924a:	d430      	bmi.n	392ae <_printf_common+0xc4>
   3924c:	f104 0243 	add.w	r2, r4, #67	; 0x43
   39250:	4639      	mov	r1, r7
   39252:	4630      	mov	r0, r6
   39254:	47c0      	blx	r8
   39256:	3001      	adds	r0, #1
   39258:	d023      	beq.n	392a2 <_printf_common+0xb8>
   3925a:	6823      	ldr	r3, [r4, #0]
   3925c:	341a      	adds	r4, #26
   3925e:	f854 5c0e 	ldr.w	r5, [r4, #-14]
   39262:	f003 0306 	and.w	r3, r3, #6
   39266:	f8d9 2000 	ldr.w	r2, [r9]
   3926a:	f04f 0900 	mov.w	r9, #0
   3926e:	2b04      	cmp	r3, #4
   39270:	f854 3c12 	ldr.w	r3, [r4, #-18]
   39274:	bf08      	it	eq
   39276:	1aad      	subeq	r5, r5, r2
   39278:	f854 2c0a 	ldr.w	r2, [r4, #-10]
   3927c:	bf14      	ite	ne
   3927e:	2500      	movne	r5, #0
   39280:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   39284:	4293      	cmp	r3, r2
   39286:	bfc4      	itt	gt
   39288:	1a9b      	subgt	r3, r3, r2
   3928a:	18ed      	addgt	r5, r5, r3
   3928c:	454d      	cmp	r5, r9
   3928e:	d11a      	bne.n	392c6 <_printf_common+0xdc>
   39290:	2000      	movs	r0, #0
   39292:	e008      	b.n	392a6 <_printf_common+0xbc>
   39294:	2301      	movs	r3, #1
   39296:	4652      	mov	r2, sl
   39298:	4639      	mov	r1, r7
   3929a:	4630      	mov	r0, r6
   3929c:	47c0      	blx	r8
   3929e:	3001      	adds	r0, #1
   392a0:	d103      	bne.n	392aa <_printf_common+0xc0>
   392a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   392a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   392aa:	3501      	adds	r5, #1
   392ac:	e7c0      	b.n	39230 <_printf_common+0x46>
   392ae:	18e1      	adds	r1, r4, r3
   392b0:	1c5a      	adds	r2, r3, #1
   392b2:	2030      	movs	r0, #48	; 0x30
   392b4:	3302      	adds	r3, #2
   392b6:	4422      	add	r2, r4
   392b8:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   392bc:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   392c0:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   392c4:	e7c2      	b.n	3924c <_printf_common+0x62>
   392c6:	2301      	movs	r3, #1
   392c8:	4622      	mov	r2, r4
   392ca:	4639      	mov	r1, r7
   392cc:	4630      	mov	r0, r6
   392ce:	47c0      	blx	r8
   392d0:	3001      	adds	r0, #1
   392d2:	d0e6      	beq.n	392a2 <_printf_common+0xb8>
   392d4:	f109 0901 	add.w	r9, r9, #1
   392d8:	e7d8      	b.n	3928c <_printf_common+0xa2>

000392da <strchr>:
   392da:	b2c9      	uxtb	r1, r1
   392dc:	4603      	mov	r3, r0
   392de:	f810 2b01 	ldrb.w	r2, [r0], #1
   392e2:	b11a      	cbz	r2, 392ec <strchr+0x12>
   392e4:	428a      	cmp	r2, r1
   392e6:	d1f9      	bne.n	392dc <strchr+0x2>
   392e8:	4618      	mov	r0, r3
   392ea:	4770      	bx	lr
   392ec:	2900      	cmp	r1, #0
   392ee:	bf18      	it	ne
   392f0:	2300      	movne	r3, #0
   392f2:	e7f9      	b.n	392e8 <strchr+0xe>

000392f4 <strcpy>:
   392f4:	4603      	mov	r3, r0
   392f6:	f811 2b01 	ldrb.w	r2, [r1], #1
   392fa:	f803 2b01 	strb.w	r2, [r3], #1
   392fe:	2a00      	cmp	r2, #0
   39300:	d1f9      	bne.n	392f6 <strcpy+0x2>
   39302:	4770      	bx	lr

00039304 <strncmp>:
   39304:	b510      	push	{r4, lr}
   39306:	b16a      	cbz	r2, 39324 <strncmp+0x20>
   39308:	3901      	subs	r1, #1
   3930a:	1884      	adds	r4, r0, r2
   3930c:	f810 3b01 	ldrb.w	r3, [r0], #1
   39310:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   39314:	4293      	cmp	r3, r2
   39316:	d103      	bne.n	39320 <strncmp+0x1c>
   39318:	42a0      	cmp	r0, r4
   3931a:	d001      	beq.n	39320 <strncmp+0x1c>
   3931c:	2b00      	cmp	r3, #0
   3931e:	d1f5      	bne.n	3930c <strncmp+0x8>
   39320:	1a98      	subs	r0, r3, r2
   39322:	bd10      	pop	{r4, pc}
   39324:	4610      	mov	r0, r2
   39326:	e7fc      	b.n	39322 <strncmp+0x1e>

00039328 <strstr>:
   39328:	b5f0      	push	{r4, r5, r6, r7, lr}
   3932a:	780c      	ldrb	r4, [r1, #0]
   3932c:	b164      	cbz	r4, 39348 <strstr+0x20>
   3932e:	4603      	mov	r3, r0
   39330:	781a      	ldrb	r2, [r3, #0]
   39332:	4618      	mov	r0, r3
   39334:	1c5e      	adds	r6, r3, #1
   39336:	b90a      	cbnz	r2, 3933c <strstr+0x14>
   39338:	4610      	mov	r0, r2
   3933a:	e005      	b.n	39348 <strstr+0x20>
   3933c:	4294      	cmp	r4, r2
   3933e:	d108      	bne.n	39352 <strstr+0x2a>
   39340:	460d      	mov	r5, r1
   39342:	f815 2f01 	ldrb.w	r2, [r5, #1]!
   39346:	b902      	cbnz	r2, 3934a <strstr+0x22>
   39348:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3934a:	f813 7f01 	ldrb.w	r7, [r3, #1]!
   3934e:	4297      	cmp	r7, r2
   39350:	d0f7      	beq.n	39342 <strstr+0x1a>
   39352:	4633      	mov	r3, r6
   39354:	e7ec      	b.n	39330 <strstr+0x8>

00039356 <_user_strerror>:
   39356:	2000      	movs	r0, #0
   39358:	4770      	bx	lr

0003935a <abort>:
   3935a:	b508      	push	{r3, lr}
   3935c:	2006      	movs	r0, #6
   3935e:	f7f9 fbcd 	bl	32afc <raise>
   39362:	2001      	movs	r0, #1
   39364:	f7e2 fb92 	bl	1ba8c <_exit>

00039368 <quorem>:
   39368:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3936c:	6903      	ldr	r3, [r0, #16]
   3936e:	4680      	mov	r8, r0
   39370:	690c      	ldr	r4, [r1, #16]
   39372:	42a3      	cmp	r3, r4
   39374:	f2c0 8084 	blt.w	39480 <quorem+0x118>
   39378:	3c01      	subs	r4, #1
   3937a:	f108 0514 	add.w	r5, r8, #20
   3937e:	f101 0714 	add.w	r7, r1, #20
   39382:	00a0      	lsls	r0, r4, #2
   39384:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   39388:	182b      	adds	r3, r5, r0
   3938a:	eb07 0900 	add.w	r9, r7, r0
   3938e:	9301      	str	r3, [sp, #4]
   39390:	f857 3024 	ldr.w	r3, [r7, r4, lsl #2]
   39394:	3301      	adds	r3, #1
   39396:	429a      	cmp	r2, r3
   39398:	fbb2 f6f3 	udiv	r6, r2, r3
   3939c:	d333      	bcc.n	39406 <quorem+0x9e>
   3939e:	f04f 0a00 	mov.w	sl, #0
   393a2:	46bc      	mov	ip, r7
   393a4:	46ae      	mov	lr, r5
   393a6:	46d3      	mov	fp, sl
   393a8:	f85c 2b04 	ldr.w	r2, [ip], #4
   393ac:	b293      	uxth	r3, r2
   393ae:	45e1      	cmp	r9, ip
   393b0:	ea4f 4212 	mov.w	r2, r2, lsr #16
   393b4:	fb06 a303 	mla	r3, r6, r3, sl
   393b8:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   393bc:	b29b      	uxth	r3, r3
   393be:	fb06 a202 	mla	r2, r6, r2, sl
   393c2:	ebab 0303 	sub.w	r3, fp, r3
   393c6:	f8de b000 	ldr.w	fp, [lr]
   393ca:	ea4f 4a12 	mov.w	sl, r2, lsr #16
   393ce:	fa1f fb8b 	uxth.w	fp, fp
   393d2:	445b      	add	r3, fp
   393d4:	fa1f fb82 	uxth.w	fp, r2
   393d8:	f8de 2000 	ldr.w	r2, [lr]
   393dc:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
   393e0:	eb02 4223 	add.w	r2, r2, r3, asr #16
   393e4:	b29b      	uxth	r3, r3
   393e6:	ea4f 4b22 	mov.w	fp, r2, asr #16
   393ea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   393ee:	f84e 3b04 	str.w	r3, [lr], #4
   393f2:	d2d9      	bcs.n	393a8 <quorem+0x40>
   393f4:	582b      	ldr	r3, [r5, r0]
   393f6:	b933      	cbnz	r3, 39406 <quorem+0x9e>
   393f8:	9b01      	ldr	r3, [sp, #4]
   393fa:	3b04      	subs	r3, #4
   393fc:	429d      	cmp	r5, r3
   393fe:	461a      	mov	r2, r3
   39400:	d332      	bcc.n	39468 <quorem+0x100>
   39402:	f8c8 4010 	str.w	r4, [r8, #16]
   39406:	4640      	mov	r0, r8
   39408:	f000 fa5a 	bl	398c0 <__mcmp>
   3940c:	2800      	cmp	r0, #0
   3940e:	db27      	blt.n	39460 <quorem+0xf8>
   39410:	3601      	adds	r6, #1
   39412:	4628      	mov	r0, r5
   39414:	f04f 0c00 	mov.w	ip, #0
   39418:	f857 1b04 	ldr.w	r1, [r7], #4
   3941c:	f8d0 e000 	ldr.w	lr, [r0]
   39420:	b28b      	uxth	r3, r1
   39422:	45b9      	cmp	r9, r7
   39424:	fa1f f28e 	uxth.w	r2, lr
   39428:	ebac 0303 	sub.w	r3, ip, r3
   3942c:	4413      	add	r3, r2
   3942e:	ea4f 4211 	mov.w	r2, r1, lsr #16
   39432:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
   39436:	eb02 4223 	add.w	r2, r2, r3, asr #16
   3943a:	b29b      	uxth	r3, r3
   3943c:	ea4f 4c22 	mov.w	ip, r2, asr #16
   39440:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   39444:	f840 3b04 	str.w	r3, [r0], #4
   39448:	d2e6      	bcs.n	39418 <quorem+0xb0>
   3944a:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
   3944e:	eb05 0384 	add.w	r3, r5, r4, lsl #2
   39452:	b92a      	cbnz	r2, 39460 <quorem+0xf8>
   39454:	3b04      	subs	r3, #4
   39456:	429d      	cmp	r5, r3
   39458:	461a      	mov	r2, r3
   3945a:	d30b      	bcc.n	39474 <quorem+0x10c>
   3945c:	f8c8 4010 	str.w	r4, [r8, #16]
   39460:	4630      	mov	r0, r6
   39462:	b003      	add	sp, #12
   39464:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   39468:	6812      	ldr	r2, [r2, #0]
   3946a:	3b04      	subs	r3, #4
   3946c:	2a00      	cmp	r2, #0
   3946e:	d1c8      	bne.n	39402 <quorem+0x9a>
   39470:	3c01      	subs	r4, #1
   39472:	e7c3      	b.n	393fc <quorem+0x94>
   39474:	6812      	ldr	r2, [r2, #0]
   39476:	3b04      	subs	r3, #4
   39478:	2a00      	cmp	r2, #0
   3947a:	d1ef      	bne.n	3945c <quorem+0xf4>
   3947c:	3c01      	subs	r4, #1
   3947e:	e7ea      	b.n	39456 <quorem+0xee>
   39480:	2000      	movs	r0, #0
   39482:	e7ee      	b.n	39462 <quorem+0xfa>

00039484 <__sfmoreglue>:
   39484:	b570      	push	{r4, r5, r6, lr}
   39486:	1e4a      	subs	r2, r1, #1
   39488:	2568      	movs	r5, #104	; 0x68
   3948a:	460e      	mov	r6, r1
   3948c:	4355      	muls	r5, r2
   3948e:	f105 0174 	add.w	r1, r5, #116	; 0x74
   39492:	f7f7 ff25 	bl	312e0 <_malloc_r>
   39496:	4604      	mov	r4, r0
   39498:	b140      	cbz	r0, 394ac <__sfmoreglue+0x28>
   3949a:	2100      	movs	r1, #0
   3949c:	f105 0268 	add.w	r2, r5, #104	; 0x68
   394a0:	e9c0 1600 	strd	r1, r6, [r0]
   394a4:	300c      	adds	r0, #12
   394a6:	60a0      	str	r0, [r4, #8]
   394a8:	f7ff fdd0 	bl	3904c <memset>
   394ac:	4620      	mov	r0, r4
   394ae:	bd70      	pop	{r4, r5, r6, pc}

000394b0 <_fwalk_reent>:
   394b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   394b4:	4680      	mov	r8, r0
   394b6:	4689      	mov	r9, r1
   394b8:	f100 0448 	add.w	r4, r0, #72	; 0x48
   394bc:	2600      	movs	r6, #0
   394be:	b914      	cbnz	r4, 394c6 <_fwalk_reent+0x16>
   394c0:	4630      	mov	r0, r6
   394c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   394c6:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
   394ca:	3f01      	subs	r7, #1
   394cc:	d501      	bpl.n	394d2 <_fwalk_reent+0x22>
   394ce:	6824      	ldr	r4, [r4, #0]
   394d0:	e7f5      	b.n	394be <_fwalk_reent+0xe>
   394d2:	89ab      	ldrh	r3, [r5, #12]
   394d4:	2b01      	cmp	r3, #1
   394d6:	d907      	bls.n	394e8 <_fwalk_reent+0x38>
   394d8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   394dc:	3301      	adds	r3, #1
   394de:	d003      	beq.n	394e8 <_fwalk_reent+0x38>
   394e0:	4629      	mov	r1, r5
   394e2:	4640      	mov	r0, r8
   394e4:	47c8      	blx	r9
   394e6:	4306      	orrs	r6, r0
   394e8:	3568      	adds	r5, #104	; 0x68
   394ea:	e7ee      	b.n	394ca <_fwalk_reent+0x1a>

000394ec <__retarget_lock_init_recursive>:
   394ec:	4770      	bx	lr

000394ee <__retarget_lock_acquire_recursive>:
   394ee:	4770      	bx	lr

000394f0 <__retarget_lock_release_recursive>:
   394f0:	4770      	bx	lr

000394f2 <__swhatbuf_r>:
   394f2:	b570      	push	{r4, r5, r6, lr}
   394f4:	460e      	mov	r6, r1
   394f6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   394fa:	b096      	sub	sp, #88	; 0x58
   394fc:	4614      	mov	r4, r2
   394fe:	2900      	cmp	r1, #0
   39500:	461d      	mov	r5, r3
   39502:	da07      	bge.n	39514 <__swhatbuf_r+0x22>
   39504:	2300      	movs	r3, #0
   39506:	602b      	str	r3, [r5, #0]
   39508:	89b3      	ldrh	r3, [r6, #12]
   3950a:	061a      	lsls	r2, r3, #24
   3950c:	d410      	bmi.n	39530 <__swhatbuf_r+0x3e>
   3950e:	f44f 6380 	mov.w	r3, #1024	; 0x400
   39512:	e00e      	b.n	39532 <__swhatbuf_r+0x40>
   39514:	466a      	mov	r2, sp
   39516:	f7f9 fb2d 	bl	32b74 <_fstat_r>
   3951a:	2800      	cmp	r0, #0
   3951c:	dbf2      	blt.n	39504 <__swhatbuf_r+0x12>
   3951e:	9a01      	ldr	r2, [sp, #4]
   39520:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   39524:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   39528:	425a      	negs	r2, r3
   3952a:	415a      	adcs	r2, r3
   3952c:	602a      	str	r2, [r5, #0]
   3952e:	e7ee      	b.n	3950e <__swhatbuf_r+0x1c>
   39530:	2340      	movs	r3, #64	; 0x40
   39532:	2000      	movs	r0, #0
   39534:	6023      	str	r3, [r4, #0]
   39536:	b016      	add	sp, #88	; 0x58
   39538:	bd70      	pop	{r4, r5, r6, pc}

0003953a <_Balloc>:
   3953a:	b570      	push	{r4, r5, r6, lr}
   3953c:	6a45      	ldr	r5, [r0, #36]	; 0x24
   3953e:	4604      	mov	r4, r0
   39540:	460e      	mov	r6, r1
   39542:	b93d      	cbnz	r5, 39554 <_Balloc+0x1a>
   39544:	2010      	movs	r0, #16
   39546:	f7f7 fe6d 	bl	31224 <malloc>
   3954a:	6260      	str	r0, [r4, #36]	; 0x24
   3954c:	6005      	str	r5, [r0, #0]
   3954e:	60c5      	str	r5, [r0, #12]
   39550:	e9c0 5501 	strd	r5, r5, [r0, #4]
   39554:	6a65      	ldr	r5, [r4, #36]	; 0x24
   39556:	68eb      	ldr	r3, [r5, #12]
   39558:	b183      	cbz	r3, 3957c <_Balloc+0x42>
   3955a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3955c:	68db      	ldr	r3, [r3, #12]
   3955e:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
   39562:	b9b8      	cbnz	r0, 39594 <_Balloc+0x5a>
   39564:	2101      	movs	r1, #1
   39566:	4620      	mov	r0, r4
   39568:	fa01 f506 	lsl.w	r5, r1, r6
   3956c:	1d6a      	adds	r2, r5, #5
   3956e:	0092      	lsls	r2, r2, #2
   39570:	f7ff fd74 	bl	3905c <_calloc_r>
   39574:	b160      	cbz	r0, 39590 <_Balloc+0x56>
   39576:	e9c0 6501 	strd	r6, r5, [r0, #4]
   3957a:	e00e      	b.n	3959a <_Balloc+0x60>
   3957c:	2221      	movs	r2, #33	; 0x21
   3957e:	2104      	movs	r1, #4
   39580:	4620      	mov	r0, r4
   39582:	f7ff fd6b 	bl	3905c <_calloc_r>
   39586:	6a63      	ldr	r3, [r4, #36]	; 0x24
   39588:	60e8      	str	r0, [r5, #12]
   3958a:	68db      	ldr	r3, [r3, #12]
   3958c:	2b00      	cmp	r3, #0
   3958e:	d1e4      	bne.n	3955a <_Balloc+0x20>
   39590:	2000      	movs	r0, #0
   39592:	bd70      	pop	{r4, r5, r6, pc}
   39594:	6802      	ldr	r2, [r0, #0]
   39596:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
   3959a:	2300      	movs	r3, #0
   3959c:	e9c0 3303 	strd	r3, r3, [r0, #12]
   395a0:	e7f7      	b.n	39592 <_Balloc+0x58>

000395a2 <_Bfree>:
   395a2:	b570      	push	{r4, r5, r6, lr}
   395a4:	6a44      	ldr	r4, [r0, #36]	; 0x24
   395a6:	4606      	mov	r6, r0
   395a8:	460d      	mov	r5, r1
   395aa:	b93c      	cbnz	r4, 395bc <_Bfree+0x1a>
   395ac:	2010      	movs	r0, #16
   395ae:	f7f7 fe39 	bl	31224 <malloc>
   395b2:	6270      	str	r0, [r6, #36]	; 0x24
   395b4:	6004      	str	r4, [r0, #0]
   395b6:	60c4      	str	r4, [r0, #12]
   395b8:	e9c0 4401 	strd	r4, r4, [r0, #4]
   395bc:	b13d      	cbz	r5, 395ce <_Bfree+0x2c>
   395be:	6a73      	ldr	r3, [r6, #36]	; 0x24
   395c0:	686a      	ldr	r2, [r5, #4]
   395c2:	68db      	ldr	r3, [r3, #12]
   395c4:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
   395c8:	6029      	str	r1, [r5, #0]
   395ca:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
   395ce:	bd70      	pop	{r4, r5, r6, pc}

000395d0 <__multadd>:
   395d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   395d4:	f101 0c14 	add.w	ip, r1, #20
   395d8:	461f      	mov	r7, r3
   395da:	4606      	mov	r6, r0
   395dc:	460c      	mov	r4, r1
   395de:	690d      	ldr	r5, [r1, #16]
   395e0:	2300      	movs	r3, #0
   395e2:	f8dc 0000 	ldr.w	r0, [ip]
   395e6:	3301      	adds	r3, #1
   395e8:	b281      	uxth	r1, r0
   395ea:	429d      	cmp	r5, r3
   395ec:	ea4f 4010 	mov.w	r0, r0, lsr #16
   395f0:	fb02 7101 	mla	r1, r2, r1, r7
   395f4:	ea4f 4711 	mov.w	r7, r1, lsr #16
   395f8:	b289      	uxth	r1, r1
   395fa:	fb02 7000 	mla	r0, r2, r0, r7
   395fe:	eb01 4100 	add.w	r1, r1, r0, lsl #16
   39602:	ea4f 4710 	mov.w	r7, r0, lsr #16
   39606:	f84c 1b04 	str.w	r1, [ip], #4
   3960a:	dcea      	bgt.n	395e2 <__multadd+0x12>
   3960c:	b1d7      	cbz	r7, 39644 <__multadd+0x74>
   3960e:	68a3      	ldr	r3, [r4, #8]
   39610:	42ab      	cmp	r3, r5
   39612:	dc12      	bgt.n	3963a <__multadd+0x6a>
   39614:	6861      	ldr	r1, [r4, #4]
   39616:	4630      	mov	r0, r6
   39618:	3101      	adds	r1, #1
   3961a:	f7ff ff8e 	bl	3953a <_Balloc>
   3961e:	6922      	ldr	r2, [r4, #16]
   39620:	4680      	mov	r8, r0
   39622:	f104 010c 	add.w	r1, r4, #12
   39626:	3202      	adds	r2, #2
   39628:	300c      	adds	r0, #12
   3962a:	0092      	lsls	r2, r2, #2
   3962c:	f7ff fcd4 	bl	38fd8 <memcpy>
   39630:	4621      	mov	r1, r4
   39632:	4644      	mov	r4, r8
   39634:	4630      	mov	r0, r6
   39636:	f7ff ffb4 	bl	395a2 <_Bfree>
   3963a:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   3963e:	3501      	adds	r5, #1
   39640:	615f      	str	r7, [r3, #20]
   39642:	6125      	str	r5, [r4, #16]
   39644:	4620      	mov	r0, r4
   39646:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0003964a <__hi0bits>:
   3964a:	0c02      	lsrs	r2, r0, #16
   3964c:	4603      	mov	r3, r0
   3964e:	0412      	lsls	r2, r2, #16
   39650:	b9ca      	cbnz	r2, 39686 <__hi0bits+0x3c>
   39652:	0403      	lsls	r3, r0, #16
   39654:	2010      	movs	r0, #16
   39656:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
   3965a:	bf04      	itt	eq
   3965c:	021b      	lsleq	r3, r3, #8
   3965e:	3008      	addeq	r0, #8
   39660:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
   39664:	bf04      	itt	eq
   39666:	011b      	lsleq	r3, r3, #4
   39668:	3004      	addeq	r0, #4
   3966a:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
   3966e:	bf04      	itt	eq
   39670:	009b      	lsleq	r3, r3, #2
   39672:	3002      	addeq	r0, #2
   39674:	2b00      	cmp	r3, #0
   39676:	db05      	blt.n	39684 <__hi0bits+0x3a>
   39678:	f013 4f80 	tst.w	r3, #1073741824	; 0x40000000
   3967c:	f100 0001 	add.w	r0, r0, #1
   39680:	bf08      	it	eq
   39682:	2020      	moveq	r0, #32
   39684:	4770      	bx	lr
   39686:	2000      	movs	r0, #0
   39688:	e7e5      	b.n	39656 <__hi0bits+0xc>

0003968a <__lo0bits>:
   3968a:	6803      	ldr	r3, [r0, #0]
   3968c:	4601      	mov	r1, r0
   3968e:	f013 0207 	ands.w	r2, r3, #7
   39692:	d00b      	beq.n	396ac <__lo0bits+0x22>
   39694:	07da      	lsls	r2, r3, #31
   39696:	d424      	bmi.n	396e2 <__lo0bits+0x58>
   39698:	0798      	lsls	r0, r3, #30
   3969a:	bf47      	ittee	mi
   3969c:	085b      	lsrmi	r3, r3, #1
   3969e:	2001      	movmi	r0, #1
   396a0:	089b      	lsrpl	r3, r3, #2
   396a2:	2002      	movpl	r0, #2
   396a4:	bf4c      	ite	mi
   396a6:	600b      	strmi	r3, [r1, #0]
   396a8:	600b      	strpl	r3, [r1, #0]
   396aa:	4770      	bx	lr
   396ac:	b298      	uxth	r0, r3
   396ae:	b9b0      	cbnz	r0, 396de <__lo0bits+0x54>
   396b0:	0c1b      	lsrs	r3, r3, #16
   396b2:	2010      	movs	r0, #16
   396b4:	f013 0fff 	tst.w	r3, #255	; 0xff
   396b8:	bf04      	itt	eq
   396ba:	0a1b      	lsreq	r3, r3, #8
   396bc:	3008      	addeq	r0, #8
   396be:	071a      	lsls	r2, r3, #28
   396c0:	bf04      	itt	eq
   396c2:	091b      	lsreq	r3, r3, #4
   396c4:	3004      	addeq	r0, #4
   396c6:	079a      	lsls	r2, r3, #30
   396c8:	bf04      	itt	eq
   396ca:	089b      	lsreq	r3, r3, #2
   396cc:	3002      	addeq	r0, #2
   396ce:	07da      	lsls	r2, r3, #31
   396d0:	d403      	bmi.n	396da <__lo0bits+0x50>
   396d2:	085b      	lsrs	r3, r3, #1
   396d4:	f100 0001 	add.w	r0, r0, #1
   396d8:	d005      	beq.n	396e6 <__lo0bits+0x5c>
   396da:	600b      	str	r3, [r1, #0]
   396dc:	4770      	bx	lr
   396de:	4610      	mov	r0, r2
   396e0:	e7e8      	b.n	396b4 <__lo0bits+0x2a>
   396e2:	2000      	movs	r0, #0
   396e4:	4770      	bx	lr
   396e6:	2020      	movs	r0, #32
   396e8:	4770      	bx	lr

000396ea <__i2b>:
   396ea:	b510      	push	{r4, lr}
   396ec:	460c      	mov	r4, r1
   396ee:	2101      	movs	r1, #1
   396f0:	f7ff ff23 	bl	3953a <_Balloc>
   396f4:	2201      	movs	r2, #1
   396f6:	6144      	str	r4, [r0, #20]
   396f8:	6102      	str	r2, [r0, #16]
   396fa:	bd10      	pop	{r4, pc}

000396fc <__multiply>:
   396fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   39700:	4690      	mov	r8, r2
   39702:	690a      	ldr	r2, [r1, #16]
   39704:	460c      	mov	r4, r1
   39706:	f8d8 3010 	ldr.w	r3, [r8, #16]
   3970a:	429a      	cmp	r2, r3
   3970c:	bfbe      	ittt	lt
   3970e:	460b      	movlt	r3, r1
   39710:	4644      	movlt	r4, r8
   39712:	4698      	movlt	r8, r3
   39714:	6927      	ldr	r7, [r4, #16]
   39716:	68a3      	ldr	r3, [r4, #8]
   39718:	f8d8 9010 	ldr.w	r9, [r8, #16]
   3971c:	6861      	ldr	r1, [r4, #4]
   3971e:	eb07 0609 	add.w	r6, r7, r9
   39722:	42b3      	cmp	r3, r6
   39724:	bfb8      	it	lt
   39726:	3101      	addlt	r1, #1
   39728:	f7ff ff07 	bl	3953a <_Balloc>
   3972c:	f100 0514 	add.w	r5, r0, #20
   39730:	2200      	movs	r2, #0
   39732:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
   39736:	462b      	mov	r3, r5
   39738:	4573      	cmp	r3, lr
   3973a:	d316      	bcc.n	3976a <__multiply+0x6e>
   3973c:	f104 0314 	add.w	r3, r4, #20
   39740:	f108 0214 	add.w	r2, r8, #20
   39744:	eb03 0787 	add.w	r7, r3, r7, lsl #2
   39748:	eb02 0389 	add.w	r3, r2, r9, lsl #2
   3974c:	9300      	str	r3, [sp, #0]
   3974e:	9b00      	ldr	r3, [sp, #0]
   39750:	9201      	str	r2, [sp, #4]
   39752:	4293      	cmp	r3, r2
   39754:	d80c      	bhi.n	39770 <__multiply+0x74>
   39756:	2e00      	cmp	r6, #0
   39758:	dd03      	ble.n	39762 <__multiply+0x66>
   3975a:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
   3975e:	2b00      	cmp	r3, #0
   39760:	d059      	beq.n	39816 <__multiply+0x11a>
   39762:	6106      	str	r6, [r0, #16]
   39764:	b003      	add	sp, #12
   39766:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3976a:	f843 2b04 	str.w	r2, [r3], #4
   3976e:	e7e3      	b.n	39738 <__multiply+0x3c>
   39770:	f8b2 a000 	ldrh.w	sl, [r2]
   39774:	f1ba 0f00 	cmp.w	sl, #0
   39778:	d023      	beq.n	397c2 <__multiply+0xc6>
   3977a:	f104 0914 	add.w	r9, r4, #20
   3977e:	46ac      	mov	ip, r5
   39780:	f04f 0800 	mov.w	r8, #0
   39784:	f859 1b04 	ldr.w	r1, [r9], #4
   39788:	f8dc b000 	ldr.w	fp, [ip]
   3978c:	b28b      	uxth	r3, r1
   3978e:	454f      	cmp	r7, r9
   39790:	fa1f fb8b 	uxth.w	fp, fp
   39794:	fb0a b303 	mla	r3, sl, r3, fp
   39798:	ea4f 4b11 	mov.w	fp, r1, lsr #16
   3979c:	f8dc 1000 	ldr.w	r1, [ip]
   397a0:	4443      	add	r3, r8
   397a2:	ea4f 4811 	mov.w	r8, r1, lsr #16
   397a6:	fb0a 810b 	mla	r1, sl, fp, r8
   397aa:	eb01 4113 	add.w	r1, r1, r3, lsr #16
   397ae:	b29b      	uxth	r3, r3
   397b0:	ea4f 4811 	mov.w	r8, r1, lsr #16
   397b4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   397b8:	f84c 3b04 	str.w	r3, [ip], #4
   397bc:	d8e2      	bhi.n	39784 <__multiply+0x88>
   397be:	f8cc 8000 	str.w	r8, [ip]
   397c2:	9b01      	ldr	r3, [sp, #4]
   397c4:	3204      	adds	r2, #4
   397c6:	f8b3 9002 	ldrh.w	r9, [r3, #2]
   397ca:	f1b9 0f00 	cmp.w	r9, #0
   397ce:	d020      	beq.n	39812 <__multiply+0x116>
   397d0:	682b      	ldr	r3, [r5, #0]
   397d2:	f104 0814 	add.w	r8, r4, #20
   397d6:	46ac      	mov	ip, r5
   397d8:	f04f 0a00 	mov.w	sl, #0
   397dc:	f8b8 1000 	ldrh.w	r1, [r8]
   397e0:	b29b      	uxth	r3, r3
   397e2:	f8bc b002 	ldrh.w	fp, [ip, #2]
   397e6:	fb09 b101 	mla	r1, r9, r1, fp
   397ea:	448a      	add	sl, r1
   397ec:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
   397f0:	f84c 3b04 	str.w	r3, [ip], #4
   397f4:	f858 3b04 	ldr.w	r3, [r8], #4
   397f8:	f8bc 1000 	ldrh.w	r1, [ip]
   397fc:	0c1b      	lsrs	r3, r3, #16
   397fe:	4547      	cmp	r7, r8
   39800:	fb09 1303 	mla	r3, r9, r3, r1
   39804:	eb03 431a 	add.w	r3, r3, sl, lsr #16
   39808:	ea4f 4a13 	mov.w	sl, r3, lsr #16
   3980c:	d8e6      	bhi.n	397dc <__multiply+0xe0>
   3980e:	f8cc 3000 	str.w	r3, [ip]
   39812:	3504      	adds	r5, #4
   39814:	e79b      	b.n	3974e <__multiply+0x52>
   39816:	3e01      	subs	r6, #1
   39818:	e79d      	b.n	39756 <__multiply+0x5a>

0003981a <__lshift>:
   3981a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3981e:	460c      	mov	r4, r1
   39820:	ea4f 1a62 	mov.w	sl, r2, asr #5
   39824:	4607      	mov	r7, r0
   39826:	4616      	mov	r6, r2
   39828:	6923      	ldr	r3, [r4, #16]
   3982a:	6849      	ldr	r1, [r1, #4]
   3982c:	eb0a 0903 	add.w	r9, sl, r3
   39830:	68a3      	ldr	r3, [r4, #8]
   39832:	f109 0501 	add.w	r5, r9, #1
   39836:	42ab      	cmp	r3, r5
   39838:	db33      	blt.n	398a2 <__lshift+0x88>
   3983a:	4638      	mov	r0, r7
   3983c:	f7ff fe7d 	bl	3953a <_Balloc>
   39840:	2300      	movs	r3, #0
   39842:	4680      	mov	r8, r0
   39844:	f100 0114 	add.w	r1, r0, #20
   39848:	f100 0210 	add.w	r2, r0, #16
   3984c:	4618      	mov	r0, r3
   3984e:	4553      	cmp	r3, sl
   39850:	db2a      	blt.n	398a8 <__lshift+0x8e>
   39852:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
   39856:	f104 0314 	add.w	r3, r4, #20
   3985a:	6920      	ldr	r0, [r4, #16]
   3985c:	f016 021f 	ands.w	r2, r6, #31
   39860:	eb01 018a 	add.w	r1, r1, sl, lsl #2
   39864:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
   39868:	d022      	beq.n	398b0 <__lshift+0x96>
   3986a:	f1c2 0e20 	rsb	lr, r2, #32
   3986e:	2000      	movs	r0, #0
   39870:	681e      	ldr	r6, [r3, #0]
   39872:	4096      	lsls	r6, r2
   39874:	4330      	orrs	r0, r6
   39876:	f841 0b04 	str.w	r0, [r1], #4
   3987a:	f853 0b04 	ldr.w	r0, [r3], #4
   3987e:	459c      	cmp	ip, r3
   39880:	fa20 f00e 	lsr.w	r0, r0, lr
   39884:	d8f4      	bhi.n	39870 <__lshift+0x56>
   39886:	6008      	str	r0, [r1, #0]
   39888:	b108      	cbz	r0, 3988e <__lshift+0x74>
   3988a:	f109 0502 	add.w	r5, r9, #2
   3988e:	3d01      	subs	r5, #1
   39890:	4638      	mov	r0, r7
   39892:	4621      	mov	r1, r4
   39894:	f8c8 5010 	str.w	r5, [r8, #16]
   39898:	f7ff fe83 	bl	395a2 <_Bfree>
   3989c:	4640      	mov	r0, r8
   3989e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   398a2:	3101      	adds	r1, #1
   398a4:	005b      	lsls	r3, r3, #1
   398a6:	e7c6      	b.n	39836 <__lshift+0x1c>
   398a8:	f842 0f04 	str.w	r0, [r2, #4]!
   398ac:	3301      	adds	r3, #1
   398ae:	e7ce      	b.n	3984e <__lshift+0x34>
   398b0:	3904      	subs	r1, #4
   398b2:	f853 2b04 	ldr.w	r2, [r3], #4
   398b6:	459c      	cmp	ip, r3
   398b8:	f841 2f04 	str.w	r2, [r1, #4]!
   398bc:	d8f9      	bhi.n	398b2 <__lshift+0x98>
   398be:	e7e6      	b.n	3988e <__lshift+0x74>

000398c0 <__mcmp>:
   398c0:	6903      	ldr	r3, [r0, #16]
   398c2:	690a      	ldr	r2, [r1, #16]
   398c4:	1a9b      	subs	r3, r3, r2
   398c6:	b530      	push	{r4, r5, lr}
   398c8:	d10c      	bne.n	398e4 <__mcmp+0x24>
   398ca:	0092      	lsls	r2, r2, #2
   398cc:	3014      	adds	r0, #20
   398ce:	3114      	adds	r1, #20
   398d0:	1884      	adds	r4, r0, r2
   398d2:	4411      	add	r1, r2
   398d4:	f854 5d04 	ldr.w	r5, [r4, #-4]!
   398d8:	f851 2d04 	ldr.w	r2, [r1, #-4]!
   398dc:	4295      	cmp	r5, r2
   398de:	d003      	beq.n	398e8 <__mcmp+0x28>
   398e0:	d305      	bcc.n	398ee <__mcmp+0x2e>
   398e2:	2301      	movs	r3, #1
   398e4:	4618      	mov	r0, r3
   398e6:	bd30      	pop	{r4, r5, pc}
   398e8:	42a0      	cmp	r0, r4
   398ea:	d3f3      	bcc.n	398d4 <__mcmp+0x14>
   398ec:	e7fa      	b.n	398e4 <__mcmp+0x24>
   398ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   398f2:	e7f7      	b.n	398e4 <__mcmp+0x24>

000398f4 <__mdiff>:
   398f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   398f8:	460d      	mov	r5, r1
   398fa:	4607      	mov	r7, r0
   398fc:	4611      	mov	r1, r2
   398fe:	4614      	mov	r4, r2
   39900:	4628      	mov	r0, r5
   39902:	f7ff ffdd 	bl	398c0 <__mcmp>
   39906:	1e06      	subs	r6, r0, #0
   39908:	d108      	bne.n	3991c <__mdiff+0x28>
   3990a:	4631      	mov	r1, r6
   3990c:	4638      	mov	r0, r7
   3990e:	f7ff fe14 	bl	3953a <_Balloc>
   39912:	2301      	movs	r3, #1
   39914:	e9c0 3604 	strd	r3, r6, [r0, #16]
   39918:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3991c:	bfa3      	ittte	ge
   3991e:	4623      	movge	r3, r4
   39920:	462c      	movge	r4, r5
   39922:	2600      	movge	r6, #0
   39924:	2601      	movlt	r6, #1
   39926:	bfa8      	it	ge
   39928:	461d      	movge	r5, r3
   3992a:	6861      	ldr	r1, [r4, #4]
   3992c:	4638      	mov	r0, r7
   3992e:	f7ff fe04 	bl	3953a <_Balloc>
   39932:	f105 0914 	add.w	r9, r5, #20
   39936:	60c6      	str	r6, [r0, #12]
   39938:	f104 0214 	add.w	r2, r4, #20
   3993c:	6926      	ldr	r6, [r4, #16]
   3993e:	f100 0114 	add.w	r1, r0, #20
   39942:	692b      	ldr	r3, [r5, #16]
   39944:	f04f 0e00 	mov.w	lr, #0
   39948:	eb02 0786 	add.w	r7, r2, r6, lsl #2
   3994c:	eb09 0883 	add.w	r8, r9, r3, lsl #2
   39950:	f852 ab04 	ldr.w	sl, [r2], #4
   39954:	f859 5b04 	ldr.w	r5, [r9], #4
   39958:	fa1f f38a 	uxth.w	r3, sl
   3995c:	4694      	mov	ip, r2
   3995e:	b2ac      	uxth	r4, r5
   39960:	45c8      	cmp	r8, r9
   39962:	4473      	add	r3, lr
   39964:	eba3 0304 	sub.w	r3, r3, r4
   39968:	ea4f 4415 	mov.w	r4, r5, lsr #16
   3996c:	ebc4 441a 	rsb	r4, r4, sl, lsr #16
   39970:	eb04 4423 	add.w	r4, r4, r3, asr #16
   39974:	b29b      	uxth	r3, r3
   39976:	ea4f 4e24 	mov.w	lr, r4, asr #16
   3997a:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
   3997e:	f841 4b04 	str.w	r4, [r1], #4
   39982:	d8e5      	bhi.n	39950 <__mdiff+0x5c>
   39984:	45bc      	cmp	ip, r7
   39986:	d304      	bcc.n	39992 <__mdiff+0x9e>
   39988:	f851 3d04 	ldr.w	r3, [r1, #-4]!
   3998c:	b183      	cbz	r3, 399b0 <__mdiff+0xbc>
   3998e:	6106      	str	r6, [r0, #16]
   39990:	e7c2      	b.n	39918 <__mdiff+0x24>
   39992:	f85c 4b04 	ldr.w	r4, [ip], #4
   39996:	b2a2      	uxth	r2, r4
   39998:	4472      	add	r2, lr
   3999a:	1413      	asrs	r3, r2, #16
   3999c:	b292      	uxth	r2, r2
   3999e:	eb03 4314 	add.w	r3, r3, r4, lsr #16
   399a2:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
   399a6:	ea4f 4e23 	mov.w	lr, r3, asr #16
   399aa:	f841 2b04 	str.w	r2, [r1], #4
   399ae:	e7e9      	b.n	39984 <__mdiff+0x90>
   399b0:	3e01      	subs	r6, #1
   399b2:	e7e9      	b.n	39988 <__mdiff+0x94>

000399b4 <__d2b>:
   399b4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   399b8:	ec59 8b10 	vmov	r8, r9, d0
   399bc:	f3c9 540a 	ubfx	r4, r9, #20, #11
   399c0:	460e      	mov	r6, r1
   399c2:	2101      	movs	r1, #1
   399c4:	4615      	mov	r5, r2
   399c6:	f7ff fdb8 	bl	3953a <_Balloc>
   399ca:	f3c9 0313 	ubfx	r3, r9, #0, #20
   399ce:	4607      	mov	r7, r0
   399d0:	bb2c      	cbnz	r4, 39a1e <__d2b+0x6a>
   399d2:	9301      	str	r3, [sp, #4]
   399d4:	f1b8 0300 	subs.w	r3, r8, #0
   399d8:	d026      	beq.n	39a28 <__d2b+0x74>
   399da:	4668      	mov	r0, sp
   399dc:	9300      	str	r3, [sp, #0]
   399de:	f7ff fe54 	bl	3968a <__lo0bits>
   399e2:	9900      	ldr	r1, [sp, #0]
   399e4:	b1f0      	cbz	r0, 39a24 <__d2b+0x70>
   399e6:	9a01      	ldr	r2, [sp, #4]
   399e8:	f1c0 0320 	rsb	r3, r0, #32
   399ec:	fa02 f303 	lsl.w	r3, r2, r3
   399f0:	40c2      	lsrs	r2, r0
   399f2:	430b      	orrs	r3, r1
   399f4:	9201      	str	r2, [sp, #4]
   399f6:	617b      	str	r3, [r7, #20]
   399f8:	9b01      	ldr	r3, [sp, #4]
   399fa:	2b00      	cmp	r3, #0
   399fc:	61bb      	str	r3, [r7, #24]
   399fe:	bf14      	ite	ne
   39a00:	2102      	movne	r1, #2
   39a02:	2101      	moveq	r1, #1
   39a04:	6139      	str	r1, [r7, #16]
   39a06:	b1c4      	cbz	r4, 39a3a <__d2b+0x86>
   39a08:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
   39a0c:	4404      	add	r4, r0
   39a0e:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
   39a12:	6034      	str	r4, [r6, #0]
   39a14:	6028      	str	r0, [r5, #0]
   39a16:	4638      	mov	r0, r7
   39a18:	b003      	add	sp, #12
   39a1a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   39a1e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   39a22:	e7d6      	b.n	399d2 <__d2b+0x1e>
   39a24:	6179      	str	r1, [r7, #20]
   39a26:	e7e7      	b.n	399f8 <__d2b+0x44>
   39a28:	a801      	add	r0, sp, #4
   39a2a:	f7ff fe2e 	bl	3968a <__lo0bits>
   39a2e:	9b01      	ldr	r3, [sp, #4]
   39a30:	2101      	movs	r1, #1
   39a32:	3020      	adds	r0, #32
   39a34:	617b      	str	r3, [r7, #20]
   39a36:	6139      	str	r1, [r7, #16]
   39a38:	e7e5      	b.n	39a06 <__d2b+0x52>
   39a3a:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
   39a3e:	eb07 0381 	add.w	r3, r7, r1, lsl #2
   39a42:	6030      	str	r0, [r6, #0]
   39a44:	6918      	ldr	r0, [r3, #16]
   39a46:	f7ff fe00 	bl	3964a <__hi0bits>
   39a4a:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
   39a4e:	e7e1      	b.n	39a14 <__d2b+0x60>

00039a50 <_realloc_r>:
   39a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   39a52:	4607      	mov	r7, r0
   39a54:	4614      	mov	r4, r2
   39a56:	460e      	mov	r6, r1
   39a58:	b921      	cbnz	r1, 39a64 <_realloc_r+0x14>
   39a5a:	4611      	mov	r1, r2
   39a5c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   39a60:	f7f7 bc3e 	b.w	312e0 <_malloc_r>
   39a64:	b922      	cbnz	r2, 39a70 <_realloc_r+0x20>
   39a66:	4625      	mov	r5, r4
   39a68:	f7f7 fbec 	bl	31244 <_free_r>
   39a6c:	4628      	mov	r0, r5
   39a6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   39a70:	f000 f8ee 	bl	39c50 <_malloc_usable_size_r>
   39a74:	42a0      	cmp	r0, r4
   39a76:	d20f      	bcs.n	39a98 <_realloc_r+0x48>
   39a78:	4621      	mov	r1, r4
   39a7a:	4638      	mov	r0, r7
   39a7c:	f7f7 fc30 	bl	312e0 <_malloc_r>
   39a80:	4605      	mov	r5, r0
   39a82:	2800      	cmp	r0, #0
   39a84:	d0f2      	beq.n	39a6c <_realloc_r+0x1c>
   39a86:	4631      	mov	r1, r6
   39a88:	4622      	mov	r2, r4
   39a8a:	f7ff faa5 	bl	38fd8 <memcpy>
   39a8e:	4631      	mov	r1, r6
   39a90:	4638      	mov	r0, r7
   39a92:	f7f7 fbd7 	bl	31244 <_free_r>
   39a96:	e7e9      	b.n	39a6c <_realloc_r+0x1c>
   39a98:	4635      	mov	r5, r6
   39a9a:	e7e7      	b.n	39a6c <_realloc_r+0x1c>

00039a9c <__ssputs_r>:
   39a9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   39aa0:	688e      	ldr	r6, [r1, #8]
   39aa2:	4682      	mov	sl, r0
   39aa4:	460c      	mov	r4, r1
   39aa6:	4691      	mov	r9, r2
   39aa8:	429e      	cmp	r6, r3
   39aaa:	4698      	mov	r8, r3
   39aac:	d838      	bhi.n	39b20 <__ssputs_r+0x84>
   39aae:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
   39ab2:	f41c 6f90 	tst.w	ip, #1152	; 0x480
   39ab6:	d031      	beq.n	39b1c <__ssputs_r+0x80>
   39ab8:	6962      	ldr	r2, [r4, #20]
   39aba:	3301      	adds	r3, #1
   39abc:	6825      	ldr	r5, [r4, #0]
   39abe:	6909      	ldr	r1, [r1, #16]
   39ac0:	eb02 0242 	add.w	r2, r2, r2, lsl #1
   39ac4:	1a6f      	subs	r7, r5, r1
   39ac6:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
   39aca:	443b      	add	r3, r7
   39acc:	1055      	asrs	r5, r2, #1
   39ace:	429d      	cmp	r5, r3
   39ad0:	bf38      	it	cc
   39ad2:	461d      	movcc	r5, r3
   39ad4:	f41c 6f80 	tst.w	ip, #1024	; 0x400
   39ad8:	d030      	beq.n	39b3c <__ssputs_r+0xa0>
   39ada:	4629      	mov	r1, r5
   39adc:	f7f7 fc00 	bl	312e0 <_malloc_r>
   39ae0:	4606      	mov	r6, r0
   39ae2:	b950      	cbnz	r0, 39afa <__ssputs_r+0x5e>
   39ae4:	230c      	movs	r3, #12
   39ae6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   39aea:	f8ca 3000 	str.w	r3, [sl]
   39aee:	89a3      	ldrh	r3, [r4, #12]
   39af0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   39af4:	81a3      	strh	r3, [r4, #12]
   39af6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   39afa:	463a      	mov	r2, r7
   39afc:	6921      	ldr	r1, [r4, #16]
   39afe:	f7ff fa6b 	bl	38fd8 <memcpy>
   39b02:	89a3      	ldrh	r3, [r4, #12]
   39b04:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   39b08:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   39b0c:	81a3      	strh	r3, [r4, #12]
   39b0e:	6126      	str	r6, [r4, #16]
   39b10:	443e      	add	r6, r7
   39b12:	6165      	str	r5, [r4, #20]
   39b14:	1bed      	subs	r5, r5, r7
   39b16:	6026      	str	r6, [r4, #0]
   39b18:	4646      	mov	r6, r8
   39b1a:	60a5      	str	r5, [r4, #8]
   39b1c:	4546      	cmp	r6, r8
   39b1e:	d900      	bls.n	39b22 <__ssputs_r+0x86>
   39b20:	4646      	mov	r6, r8
   39b22:	4632      	mov	r2, r6
   39b24:	4649      	mov	r1, r9
   39b26:	6820      	ldr	r0, [r4, #0]
   39b28:	f7ff fa76 	bl	39018 <memmove>
   39b2c:	68a3      	ldr	r3, [r4, #8]
   39b2e:	2000      	movs	r0, #0
   39b30:	1b9b      	subs	r3, r3, r6
   39b32:	60a3      	str	r3, [r4, #8]
   39b34:	6823      	ldr	r3, [r4, #0]
   39b36:	441e      	add	r6, r3
   39b38:	6026      	str	r6, [r4, #0]
   39b3a:	e7dc      	b.n	39af6 <__ssputs_r+0x5a>
   39b3c:	462a      	mov	r2, r5
   39b3e:	f7ff ff87 	bl	39a50 <_realloc_r>
   39b42:	4606      	mov	r6, r0
   39b44:	2800      	cmp	r0, #0
   39b46:	d1e2      	bne.n	39b0e <__ssputs_r+0x72>
   39b48:	6921      	ldr	r1, [r4, #16]
   39b4a:	4650      	mov	r0, sl
   39b4c:	f7f7 fb7a 	bl	31244 <_free_r>
   39b50:	e7c8      	b.n	39ae4 <__ssputs_r+0x48>

00039b52 <_raise_r>:
   39b52:	291f      	cmp	r1, #31
   39b54:	b538      	push	{r3, r4, r5, lr}
   39b56:	4604      	mov	r4, r0
   39b58:	460d      	mov	r5, r1
   39b5a:	d904      	bls.n	39b66 <_raise_r+0x14>
   39b5c:	2316      	movs	r3, #22
   39b5e:	6003      	str	r3, [r0, #0]
   39b60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   39b64:	bd38      	pop	{r3, r4, r5, pc}
   39b66:	6c42      	ldr	r2, [r0, #68]	; 0x44
   39b68:	b112      	cbz	r2, 39b70 <_raise_r+0x1e>
   39b6a:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   39b6e:	b94b      	cbnz	r3, 39b84 <_raise_r+0x32>
   39b70:	4620      	mov	r0, r4
   39b72:	f000 f816 	bl	39ba2 <_getpid_r>
   39b76:	462a      	mov	r2, r5
   39b78:	4601      	mov	r1, r0
   39b7a:	4620      	mov	r0, r4
   39b7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   39b80:	f7f8 bfc4 	b.w	32b0c <_kill_r>
   39b84:	2b01      	cmp	r3, #1
   39b86:	d00a      	beq.n	39b9e <_raise_r+0x4c>
   39b88:	1c59      	adds	r1, r3, #1
   39b8a:	d103      	bne.n	39b94 <_raise_r+0x42>
   39b8c:	2316      	movs	r3, #22
   39b8e:	6003      	str	r3, [r0, #0]
   39b90:	2001      	movs	r0, #1
   39b92:	e7e7      	b.n	39b64 <_raise_r+0x12>
   39b94:	2400      	movs	r4, #0
   39b96:	4628      	mov	r0, r5
   39b98:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   39b9c:	4798      	blx	r3
   39b9e:	2000      	movs	r0, #0
   39ba0:	e7e0      	b.n	39b64 <_raise_r+0x12>

00039ba2 <_getpid_r>:
   39ba2:	f7fb bc9a 	b.w	354da <_getpid>

00039ba6 <__sread>:
   39ba6:	b510      	push	{r4, lr}
   39ba8:	460c      	mov	r4, r1
   39baa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   39bae:	f7f9 f815 	bl	32bdc <_read_r>
   39bb2:	2800      	cmp	r0, #0
   39bb4:	bfab      	itete	ge
   39bb6:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   39bb8:	89a3      	ldrhlt	r3, [r4, #12]
   39bba:	181b      	addge	r3, r3, r0
   39bbc:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   39bc0:	bfac      	ite	ge
   39bc2:	6563      	strge	r3, [r4, #84]	; 0x54
   39bc4:	81a3      	strhlt	r3, [r4, #12]
   39bc6:	bd10      	pop	{r4, pc}

00039bc8 <__swrite>:
   39bc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   39bcc:	461f      	mov	r7, r3
   39bce:	898b      	ldrh	r3, [r1, #12]
   39bd0:	4605      	mov	r5, r0
   39bd2:	460c      	mov	r4, r1
   39bd4:	05db      	lsls	r3, r3, #23
   39bd6:	4616      	mov	r6, r2
   39bd8:	d505      	bpl.n	39be6 <__swrite+0x1e>
   39bda:	2302      	movs	r3, #2
   39bdc:	2200      	movs	r2, #0
   39bde:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   39be2:	f7f8 ffe9 	bl	32bb8 <_lseek_r>
   39be6:	89a3      	ldrh	r3, [r4, #12]
   39be8:	4632      	mov	r2, r6
   39bea:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   39bee:	4628      	mov	r0, r5
   39bf0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   39bf4:	81a3      	strh	r3, [r4, #12]
   39bf6:	463b      	mov	r3, r7
   39bf8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   39bfc:	f7f8 bf98 	b.w	32b30 <_write_r>

00039c00 <__sseek>:
   39c00:	b510      	push	{r4, lr}
   39c02:	460c      	mov	r4, r1
   39c04:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   39c08:	f7f8 ffd6 	bl	32bb8 <_lseek_r>
   39c0c:	1c43      	adds	r3, r0, #1
   39c0e:	89a3      	ldrh	r3, [r4, #12]
   39c10:	bf15      	itete	ne
   39c12:	6560      	strne	r0, [r4, #84]	; 0x54
   39c14:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   39c18:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   39c1c:	81a3      	strheq	r3, [r4, #12]
   39c1e:	bf18      	it	ne
   39c20:	81a3      	strhne	r3, [r4, #12]
   39c22:	bd10      	pop	{r4, pc}

00039c24 <__sclose>:
   39c24:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   39c28:	f7f8 bf94 	b.w	32b54 <_close_r>

00039c2c <__ascii_mbtowc>:
   39c2c:	b082      	sub	sp, #8
   39c2e:	b901      	cbnz	r1, 39c32 <__ascii_mbtowc+0x6>
   39c30:	a901      	add	r1, sp, #4
   39c32:	b142      	cbz	r2, 39c46 <__ascii_mbtowc+0x1a>
   39c34:	b14b      	cbz	r3, 39c4a <__ascii_mbtowc+0x1e>
   39c36:	7813      	ldrb	r3, [r2, #0]
   39c38:	600b      	str	r3, [r1, #0]
   39c3a:	7812      	ldrb	r2, [r2, #0]
   39c3c:	1c10      	adds	r0, r2, #0
   39c3e:	bf18      	it	ne
   39c40:	2001      	movne	r0, #1
   39c42:	b002      	add	sp, #8
   39c44:	4770      	bx	lr
   39c46:	4610      	mov	r0, r2
   39c48:	e7fb      	b.n	39c42 <__ascii_mbtowc+0x16>
   39c4a:	f06f 0001 	mvn.w	r0, #1
   39c4e:	e7f8      	b.n	39c42 <__ascii_mbtowc+0x16>

00039c50 <_malloc_usable_size_r>:
   39c50:	f851 3c04 	ldr.w	r3, [r1, #-4]
   39c54:	1f18      	subs	r0, r3, #4
   39c56:	2b00      	cmp	r3, #0
   39c58:	bfbc      	itt	lt
   39c5a:	580b      	ldrlt	r3, [r1, r0]
   39c5c:	18c0      	addlt	r0, r0, r3
   39c5e:	4770      	bx	lr

00039c60 <__ascii_wctomb>:
   39c60:	b149      	cbz	r1, 39c76 <__ascii_wctomb+0x16>
   39c62:	2aff      	cmp	r2, #255	; 0xff
   39c64:	bf8d      	iteet	hi
   39c66:	238a      	movhi	r3, #138	; 0x8a
   39c68:	700a      	strbls	r2, [r1, #0]
   39c6a:	2001      	movls	r0, #1
   39c6c:	6003      	strhi	r3, [r0, #0]
   39c6e:	bf88      	it	hi
   39c70:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
   39c74:	4770      	bx	lr
   39c76:	4608      	mov	r0, r1
   39c78:	4770      	bx	lr
